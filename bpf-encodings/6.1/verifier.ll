; ModuleID = 'kernel/bpf/verifier.c'
source_filename = "kernel/bpf/verifier.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_bpf_verifier_log_write:\09\09\09\09\09"
module asm "\09.asciz \09\22bpf_verifier_log_write\22\09\09\09\09\09"
module asm "__kstrtabns_bpf_verifier_log_write:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___ksymtab_gpl+bpf_verifier_log_write\22, \22a\22\09"
module asm "\09.balign\094\09\09\09\09\09"
module asm "__ksymtab_bpf_verifier_log_write:\09\09\09\09"
module asm "\09.long\09bpf_verifier_log_write- .\09\09\09\09"
module asm "\09.long\09__kstrtab_bpf_verifier_log_write- .\09\09\09"
module asm "\09.long\09__kstrtabns_bpf_verifier_log_write- .\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_bpf_log:\09\09\09\09\09"
module asm "\09.asciz \09\22bpf_log\22\09\09\09\09\09"
module asm "__kstrtabns_bpf_log:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___ksymtab_gpl+bpf_log\22, \22a\22\09"
module asm "\09.balign\094\09\09\09\09\09"
module asm "__ksymtab_bpf_log:\09\09\09\09"
module asm "\09.long\09bpf_log- .\09\09\09\09"
module asm "\09.long\09__kstrtab_bpf_log- .\09\09\09"
module asm "\09.long\09__kstrtabns_bpf_log- .\09\09\09"
module asm "\09.previous\09\09\09\09\09"

%struct.bpf_insn = type { i8, i8, i16, i32 }
%struct.btf = type opaque
%struct.mutex = type { %struct.atomic64_t, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.list_head }
%struct.atomic64_t = type { i64 }
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.qspinlock = type { %union.anon }
%union.anon = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.bpf_verifier_ops = type { %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, %struct.bpf_insn*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (%struct.bpf_verifier_log*, %struct.btf*, %struct.btf_type*, i32, i32, i32, i32*, i32*)* }
%struct.bpf_func_proto = type { i64 (i64, i64, i64, i64, i64)*, i8, i8, i32, %union.anon.203, %union.anon.205, i32*, i1 (%struct.bpf_prog*)* }
%union.anon.203 = type { %struct.anon.204 }
%struct.anon.204 = type { i32, i32, i32, i32, i32 }
%union.anon.205 = type { %struct.anon.206 }
%struct.anon.206 = type { i32*, i32*, i32*, i32*, i32* }
%struct.bpf_prog = type { i16, i16, i32, i32, i32, i32, [8 x i8], %struct.bpf_prog_stats*, i32*, i32 (i8*, %struct.bpf_insn*)*, %struct.bpf_prog_aux*, %struct.sock_fprog_kern*, %union.anon.198 }
%struct.bpf_prog_stats = type { %struct.u64_stats_t, %struct.u64_stats_t, %struct.u64_stats_t, %struct.u64_stats_sync, [8 x i8] }
%struct.u64_stats_t = type { %struct.local64_t }
%struct.local64_t = type { %struct.local_t }
%struct.local_t = type { %struct.atomic64_t }
%struct.u64_stats_sync = type {}
%struct.bpf_prog_aux = type { %struct.atomic64_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.btf*, %struct.bpf_ctx_arg_aux*, %struct.mutex, %struct.bpf_prog*, %struct.bpf_trampoline*, i32, i32, i8, i8, i8, i8, i8, i8, i8, %struct.btf_type*, i8*, %struct.bpf_prog**, i8*, %struct.bpf_jit_poke_descriptor*, %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_btf_tab*, i32, %struct.bpf_ksym, %struct.bpf_prog_ops*, %struct.bpf_map**, %struct.mutex, %struct.btf_mod_pair*, %struct.bpf_prog*, %struct.user_struct*, i64, i32, i32, [2 x %struct.bpf_map*], [16 x i8], i8*, %struct.bpf_prog_offload*, %struct.btf*, %struct.bpf_func_info*, %struct.bpf_func_info_aux*, %struct.bpf_line_info*, i8**, i32, i32, i32, i32, %struct.exception_table_entry*, %union.anon.197 }
%struct.bpf_ctx_arg_aux = type { i32, i32, i32 }
%struct.bpf_trampoline = type { %struct.hlist_node, %struct.ftrace_ops*, %struct.mutex, %struct.refcount_struct, i32, i64, %struct.anon.1, %struct.bpf_prog*, [3 x %struct.hlist_head], [3 x i32], %struct.bpf_tramp_image*, i64, %struct.module* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.ftrace_ops = type opaque
%struct.refcount_struct = type { %struct.atomic_t }
%struct.anon.1 = type { %struct.btf_func_model, i8*, i8 }
%struct.btf_func_model = type { i8, i8, [12 x i8], [12 x i8] }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.bpf_tramp_image = type { i8*, %struct.bpf_ksym, %struct.percpu_ref, i8*, i8*, %union.anon.2 }
%struct.percpu_ref = type { i64, %struct.percpu_ref_data* }
%struct.percpu_ref_data = type { %struct.atomic64_t, void (%struct.percpu_ref*)*, void (%struct.percpu_ref*)*, i8, %struct.callback_head, %struct.percpu_ref* }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%union.anon.2 = type { %struct.work_struct }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, i32, %struct.exception_table_entry*, i32 ()*, %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i8*, i32, i32, i32*, i32, %struct.srcu_struct**, i32, %struct.bpf_raw_event_map*, %struct.jump_entry*, i32, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_eval_map**, i32, i8*, i32, i64*, i32, i32, %struct.static_call_site*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, [12 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.3 }
%union.anon.3 = type { %struct.raw_spinlock }
%struct.kset_uevent_ops = type { i32 (%struct.kobject*)*, i8* (%struct.kobject*)*, i32 (%struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [64 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute_group**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)*, void (%struct.kobject*, %struct.kuid_t*, %struct.kgid_t*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, %struct.address_space* ()*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.address_space = type { %struct.inode*, %struct.xarray, %struct.rw_semaphore, i32, %struct.atomic_t, %struct.rb_root_cached, %struct.rw_semaphore, i64, i64, %struct.address_space_operations*, i64, i32, %struct.spinlock, %struct.list_head, i8* }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.237, i32, i64, %struct.timespec64, %struct.timespec64, %struct.timespec64, %struct.spinlock, i16, i8, i8, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.238, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.239, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.240, i32, i32, %struct.fsnotify_mark_connector*, i8* }
%struct.kuid_t = type { i32 }
%struct.kgid_t = type { i32 }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.user_namespace*, %struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32, i1)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.user_namespace*, %struct.dentry*, %struct.iattr*)*, i32 (%struct.user_namespace*, %struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec64*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.file*, i16)*, i32 (%struct.user_namespace*, %struct.inode*, %struct.posix_acl*, i32)*, i32 (%struct.user_namespace*, %struct.dentry*, %struct.fileattr*)*, i32 (%struct.dentry*, %struct.fileattr*)*, [8 x i8] }
%struct.dentry = type { i32, %struct.seqcount_spinlock, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.123, %struct.list_head, %struct.list_head, %union.anon.124 }
%struct.seqcount_spinlock = type { %struct.seqcount }
%struct.seqcount = type { i32 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.17, i8* }
%union.anon.17 = type { i64 }
%struct.lockref = type { %union.anon.19 }
%union.anon.19 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*)*, [24 x i8] }
%struct.vfsmount = type { %struct.dentry*, %struct.super_block*, i32, %struct.user_namespace* }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.user_namespace*, i32, %struct.kuid_t, %struct.kgid_t, %struct.ns_common, i64, i8, %struct.list_head, %struct.key*, %struct.rw_semaphore, %struct.work_struct, %struct.ctl_table_set, %struct.ctl_table_header*, %struct.ucounts*, [10 x i64], [4 x i64] }
%struct.uid_gid_map = type { i32, %union.anon.29 }
%union.anon.29 = type { %struct.anon.30, [48 x i8] }
%struct.anon.30 = type { %struct.uid_gid_extent*, %struct.uid_gid_extent* }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.ns_common = type { %struct.atomic64_t, %struct.proc_ns_operations*, i32, %struct.refcount_struct }
%struct.proc_ns_operations = type opaque
%struct.key = type { %struct.refcount_struct, i32, %union.anon.31, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.32, i64, %struct.kuid_t, %struct.kgid_t, i32, i16, i16, i16, i64, %union.anon.33, %union.anon.37, %struct.key_restriction* }
%union.anon.31 = type { %struct.rb_node }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.key_user = type opaque
%union.anon.32 = type { i64 }
%union.anon.33 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { i64, %union.anon.34, %struct.key_type*, %struct.key_tag*, i8* }
%union.anon.34 = type { i64 }
%struct.key_type = type opaque
%struct.key_tag = type { %struct.callback_head, %struct.refcount_struct, i8 }
%union.anon.37 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.key_restriction = type { i32 (%struct.key*, %struct.key_type*, %union.key_payload*, %struct.key*)*, %struct.key*, %struct.key_type* }
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_table_header = type { %union.anon.39, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node*, %struct.hlist_head }
%union.anon.39 = type { %struct.anon.40 }
%struct.anon.40 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.wait_queue_head }
%struct.wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*)*, void (%struct.ctl_table_header*, %struct.ctl_table*, %struct.kuid_t*, %struct.kgid_t*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.rb_root = type { %struct.rb_node* }
%struct.ucounts = type { %struct.hlist_node, %struct.user_namespace*, %struct.kuid_t, %struct.atomic_t, [10 x %struct.atomic64_t], [4 x %struct.atomic64_t] }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%union.anon.123 = type { %struct.list_head }
%union.anon.124 = type { %struct.hlist_node }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %union.anon.235, %union.anon.236, i64, %struct.timespec64, %struct.timespec64, %struct.timespec64, %struct.file* }
%union.anon.235 = type { %struct.kuid_t }
%union.anon.236 = type { %struct.kgid_t }
%struct.file = type { %union.anon.16, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.hlist_head*, %struct.address_space*, i32, i32 }
%union.anon.16 = type { %struct.callback_head }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.kiocb*, %struct.io_comp_batch*, i32)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i64, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, {}*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.io_uring_cmd*, i32)*, i32 (%struct.io_uring_cmd*, %struct.io_comp_batch*, i32)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64)*, i8*, i32, i16, %struct.wait_page_queue* }
%struct.wait_page_queue = type opaque
%struct.iov_iter = type { i8, i8, i8, i8, %union.anon.49, i64, %union.anon.50, %union.anon.53 }
%union.anon.49 = type { i64 }
%union.anon.50 = type { %struct.iovec* }
%struct.iovec = type { i8*, i64 }
%union.anon.53 = type { i64 }
%struct.io_comp_batch = type opaque
%struct.dir_context = type { i1 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.wait_queue_head*, %struct.poll_table_struct*)*, i32 }
%struct.vm_area_struct = type { i64, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon.89, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.atomic64_t, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.mm_struct = type { %struct.anon.14, [0 x i64] }
%struct.anon.14 = type { %struct.maple_tree, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, %struct.atomic64_t, i64, i64, i64, i64, %struct.seqcount, %struct.spinlock, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [48 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.mm_context_t, i64, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_subscriptions*, %struct.atomic_t, %struct.atomic_t, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.maple_tree = type { %union.anon.15, i8*, i32 }
%union.anon.15 = type { %struct.spinlock }
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i64, %struct.atomic64_t, %struct.rw_semaphore, %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_subscriptions = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.pgprot = type { i64 }
%union.anon.89 = type { %struct.anon.90 }
%struct.anon.90 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, i64, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, i32 (%struct.vm_fault*, i64, i64)*, i64 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.anon.91, i32, %struct.pmd_t*, %struct.pud_t*, %union.anon.92, %struct.page*, %struct.page*, %struct.pte_t*, %struct.spinlock*, %struct.page* }
%struct.anon.91 = type { %struct.vm_area_struct*, i32, i64, i64, i64 }
%struct.pmd_t = type { i64 }
%struct.pud_t = type { i64 }
%union.anon.92 = type { %struct.pte_t }
%struct.pte_t = type { i64 }
%struct.page = type { i64, %union.anon.4, %union.anon.129, %struct.atomic_t, [8 x i8] }
%union.anon.4 = type { %struct.anon.5 }
%struct.anon.5 = type { %union.anon.6, %struct.address_space*, i64, i64 }
%union.anon.6 = type { %struct.list_head }
%union.anon.129 = type { %struct.atomic_t }
%struct.mempolicy = type opaque
%struct.vm_userfaultfd_ctx = type {}
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, %struct.list_head, i8*, i32, i8, i32, i32, %struct.wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.125 }
%struct.fasync_struct = type { %struct.rwlock_t, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %union.anon.51, %struct.qspinlock }
%union.anon.51 = type { %struct.atomic_t }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i8*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)*, i1 (%struct.file_lock*)*, i1 (%struct.file_lock*)*, void ()* }
%union.anon.125 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.pipe_inode_info = type { %struct.mutex, %struct.wait_queue_head, %struct.wait_queue_head, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, %struct.page*, %struct.fasync_struct*, %struct.fasync_struct*, %struct.pipe_buffer*, %struct.user_struct* }
%struct.pipe_buffer = type { %struct.page*, i32, i32, %struct.pipe_buf_operations*, i32, i64 }
%struct.pipe_buf_operations = type { i32 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, void (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, i1 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, i1 (%struct.pipe_inode_info*, %struct.pipe_buffer*)* }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.io_uring_cmd = type opaque
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.pid = type { %struct.refcount_struct, i32, %struct.spinlock, [4 x %struct.hlist_head], %struct.hlist_head, %struct.wait_queue_head, %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace* }
%struct.pid_namespace = type { %struct.idr, %struct.callback_head, i32, %struct.task_struct*, %struct.kmem_cache*, i32, %struct.pid_namespace*, %struct.fs_pin*, %struct.user_namespace*, %struct.ucounts*, i32, %struct.ns_common }
%struct.idr = type { %struct.xarray, i32, i32 }
%struct.task_struct = type { %struct.thread_info, i32, i8*, %struct.refcount_struct, i32, i32, i32, %struct.__call_single_node, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, i32, %struct.sched_entity, %struct.sched_rt_entity, %struct.sched_dl_entity, %struct.sched_class*, %struct.task_group*, [32 x i8], %struct.sched_statistics, i32, i32, i32, %struct.cpumask*, %struct.cpumask*, %struct.cpumask, i8*, i16, i16, i32, %union.rcu_special, %struct.list_head, %struct.rcu_node*, i64, i8, i8, i32, %struct.list_head, i32, i32, %union.rcu_special, %struct.list_head, %struct.list_head, i32, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i16, i64, %struct.restart_block, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.pid*, [4 x %struct.hlist_node], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i8*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.posix_cputimers, %struct.posix_cputimers_work, %struct.cred*, %struct.cred*, %struct.cred*, %struct.key*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, %struct.fs_struct*, %struct.files_struct*, %struct.io_uring_task*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, %struct.syscall_user_dispatch, i64, i64, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root_cached, %struct.task_struct*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, %struct.capture_control*, i64, %struct.kernel_siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount_spinlock, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, %struct.mutex, i32, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, i64, %struct.mempolicy*, i16, i16, %struct.rseq*, i32, i64, %struct.tlbflush_unmap_batch, %union.anon.115, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, %struct.request_queue*, %struct.uprobe_task*, %struct.kmap_ctrl, i32, %struct.task_struct*, %struct.timer_list, %struct.vm_struct*, %struct.refcount_struct, i8*, %struct.bpf_local_storage*, %struct.bpf_run_ctx*, i8*, i64, i64, i64, %struct.callback_head, i32, %struct.llist_head, %struct.llist_head, %struct.callback_head, [16 x i8], %struct.thread_struct }
%struct.thread_info = type { i64, i64, i32, i32 }
%struct.__call_single_node = type { %struct.llist_node, %union.anon.22, i16, i16 }
%struct.llist_node = type { %struct.llist_node* }
%union.anon.22 = type { i32 }
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, i64, [48 x i8], %struct.sched_avg }
%struct.load_weight = type { i64, i32 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i64, i32, i32, i64, i64, i64, %struct.util_est }
%struct.util_est = type { i32, i32 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i64, i32, i8, %struct.hrtimer, %struct.hrtimer, %struct.sched_dl_entity* }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.seqcount_raw_spinlock, %struct.hrtimer*, %struct.timerqueue_head, i64 ()*, i64 }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, i32, i8, i32, i16, i16, i32, i64, %struct.hrtimer*, i64, %struct.hrtimer*, [8 x %struct.hrtimer_clock_base] }
%struct.seqcount_raw_spinlock = type { %struct.seqcount }
%struct.timerqueue_head = type { %struct.rb_root_cached }
%struct.sched_class = type opaque
%struct.task_group = type opaque
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [32 x i8] }
%struct.cpumask = type { [1 x i64] }
%struct.rcu_node = type opaque
%union.rcu_special = type { i32 }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64, i64 (%struct.restart_block*)*, %union.anon.24 }
%union.anon.24 = type { %struct.anon.25 }
%struct.anon.25 = type { i32*, i32, i32, i32, i64, i32* }
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.posix_cputimers = type { [3 x %struct.posix_cputimer_base], i32, i32 }
%struct.posix_cputimer_base = type { i64, %struct.timerqueue_head }
%struct.posix_cputimers_work = type { %struct.callback_head, i32 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.io_uring_task = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net*, %struct.time_namespace*, %struct.time_namespace*, %struct.cgroup_namespace* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type { %struct.refcount_struct, %struct.spinlock, %struct.atomic_t, i32, i32, %struct.spinlock, %struct.atomic_t, %struct.list_head, %struct.list_head, %struct.llist_node, %struct.key_tag*, %struct.user_namespace*, %struct.ucounts*, %struct.idr, %struct.ns_common, %struct.ref_tracker_dir, %struct.list_head, %struct.proc_dir_entry*, %struct.proc_dir_entry*, %struct.ctl_table_set, %struct.sock*, %struct.sock*, %struct.uevent_sock*, %struct.hlist_head*, %struct.hlist_head*, %struct.raw_notifier_head, i32, %struct.net_device*, %struct.list_head, %struct.netns_core, %struct.netns_mib, %struct.netns_packet, %struct.netns_unix, %struct.netns_nexthop, [16 x i8], %struct.netns_ipv4, %struct.netns_ipv6, %struct.netns_nf, %struct.netns_ct, %struct.net_generic*, %struct.netns_bpf, [16 x i8], %struct.netns_xfrm, i64, %struct.sock*, [48 x i8] }
%struct.ref_tracker_dir = type {}
%struct.proc_dir_entry = type opaque
%struct.uevent_sock = type opaque
%struct.raw_notifier_head = type { %struct.notifier_block* }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.net_device = type { [16 x i8], %struct.netdev_name_node*, %struct.dev_ifalias*, i64, i64, i64, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.anon.177, i32, i64, %struct.net_device_ops*, i32, i16, i16, i32, i16, i16, i64, i64, i64, i64, i64, i64, i64, i32, i32, i16, i8, i8, i32, %struct.net_device_stats, %struct.net_device_core_stats*, %struct.atomic_t, %struct.atomic_t, %struct.ethtool_ops*, %struct.ndisc_ops*, %struct.header_ops*, i8, i8, i8, i8, [32 x i8], i8, i8, i8, i8, i16, i16, i16, i16, %struct.spinlock, i32, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.kset*, i32, i32, i8, %struct.in_device*, %struct.inet6_dev*, %struct.wireless_dev*, i8*, %struct.netdev_rx_queue*, i32, i32, %struct.bpf_prog*, i64, i32, i32, i32 (%struct.sk_buff**)*, i8*, %struct.mini_Qdisc*, %struct.netdev_queue*, %struct.nf_hook_entries*, [32 x i8], %struct.cpu_rmap*, %struct.hlist_node, [24 x i8], %struct.netdev_queue*, i32, i32, %struct.Qdisc*, i32, %struct.spinlock, %struct.xdp_dev_bulk_queue*, [2 x %struct.xps_dev_maps*], %struct.mini_Qdisc*, %struct.nf_hook_entries*, [16 x %struct.hlist_head], %struct.timer_list, i32, i32, %struct.list_head, i32*, %struct.ref_tracker_dir, %struct.list_head, i8, i8, i16, i8, void (%struct.net_device*)*, %struct.netpoll_info*, %struct.possible_net_t, i8*, i32, %union.anon.196, %struct.device, [4 x %struct.attribute_group*], %struct.attribute_group*, %struct.rtnl_link_ops*, i32, i32, i16, i16, i16, [16 x %struct.netdev_tc_txq], [16 x i8], %struct.netprio_map*, %struct.phy_device*, %struct.sfp_bus*, %struct.lock_class_key*, i8, i8, %struct.list_head, %struct.udp_tunnel_nic_info*, %struct.udp_tunnel_nic*, [3 x %struct.bpf_xdp_entity], [32 x i8], %struct.netdevice_tracker, %struct.netdevice_tracker, %struct.netdevice_tracker, %struct.rtnl_hw_stats64*, [32 x i8] }
%struct.netdev_name_node = type opaque
%struct.dev_ifalias = type { %struct.callback_head, [0 x i8] }
%struct.anon.177 = type { %struct.list_head, %struct.list_head }
%struct.net_device_ops = type { i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.sk_buff*, %struct.net_device*, i64)*, i16 (%struct.net_device*, %struct.sk_buff*, %struct.net_device*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i8*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.if_settings*)*, i32 (%struct.net_device*, %struct.ifreq*, i8*, i32)*, i32 (%struct.net_device*, %struct.ifmap*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.neigh_parms*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*, %struct.rtnl_link_stats64*)*, i1 (%struct.net_device*, i32)*, i32 (i32, %struct.net_device*, i8*)*, %struct.net_device_stats* (%struct.net_device*)*, i32 (%struct.net_device*, i16, i16)*, i32 (%struct.net_device*, i16, i16)*, void (%struct.net_device*)*, i32 (%struct.net_device*, %struct.netpoll_info*)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i16, i8, i16)*, i32 (%struct.net_device*, i32, i32, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_info*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_stats*)*, i32 (%struct.net_device*, i32, %struct.nlattr**)*, i32 (%struct.net_device*, i32, %struct.sk_buff*)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_guid*, %struct.ifla_vf_guid*)*, i32 (%struct.net_device*, i32, i64, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, %struct.sk_buff*, i16, i32)*, i32 (%struct.net_device*, %struct.net_device*, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.net_device*)*, %struct.net_device* (%struct.net_device*, %struct.sk_buff*, i1)*, %struct.net_device* (%struct.net_device*, %struct.sock*)*, i64 (%struct.net_device*, i64)*, i32 (%struct.net_device*, i64)*, i32 (%struct.net_device*, %struct.neighbour*)*, void (%struct.net_device*, %struct.neighbour*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16, i16, %struct.netlink_ext_ack*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16, %struct.netlink_ext_ack*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i16, %struct.netlink_ext_ack*)*, i32 (%struct.sk_buff*, %struct.netlink_callback*, %struct.net_device*, %struct.net_device*, i32*)*, i32 (%struct.sk_buff*, %struct.nlattr**, %struct.net_device*, i8*, i16, i32, i32, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16, %struct.netlink_ext_ack*)*, i32 (%struct.sk_buff*, i32, i32, %struct.net_device*, i32, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.netdev_phys_item_id*)*, i32 (%struct.net_device*, %struct.netdev_phys_item_id*)*, i32 (%struct.net_device*, i8*, i64)*, i8* (%struct.net_device*, %struct.net_device*)*, void (%struct.net_device*, i8*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.sk_buff*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.netdev_bpf*)*, i32 (%struct.net_device*, i32, %struct.xdp_frame**, i32)*, %struct.net_device* (%struct.net_device*, %struct.xdp_buff*)*, i32 (%struct.net_device*, i32, i32)*, %struct.devlink_port* (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ip_tunnel_parm*, i32)*, %struct.net_device* (%struct.net_device*)*, i32 (%struct.net_device_path_ctx*, %struct.net_device_path*)*, i64 (%struct.net_device*, %struct.skb_shared_hwtstamps*, i1)* }
%struct.sk_buff = type { %union.anon.56, %union.anon.59, %union.anon.60, [48 x i8], %union.anon.61, i64, i32, i32, i16, i16, i16, [0 x i8], i8, i8, %union.anon.63, i32, i32, i8*, i8*, i32, %struct.refcount_struct, %struct.skb_ext* }
%union.anon.56 = type { %struct.anon.57 }
%struct.anon.57 = type { %struct.sk_buff*, %struct.sk_buff*, %union.anon.58 }
%union.anon.58 = type { %struct.net_device* }
%union.anon.59 = type { %struct.sock* }
%union.anon.60 = type { i64 }
%union.anon.61 = type { %struct.anon.62 }
%struct.anon.62 = type { i64, void (%struct.sk_buff*)* }
%union.anon.63 = type { %struct.anon.64 }
%struct.anon.64 = type <{ [0 x i8], i16, [0 x i8], i24, i16, %union.anon.65, i32, i32, i32, i16, i16, %union.anon.67, i16, [2 x i8], i32, %union.anon.68, %union.anon.69, i16, i16, i16, i16, i16, i16, i16 }>
%union.anon.65 = type { i32 }
%union.anon.67 = type { i32 }
%union.anon.68 = type { i32 }
%union.anon.69 = type { i16 }
%struct.skb_ext = type { %struct.refcount_struct, [1 x i8], i8, [2 x i8], [0 x i8] }
%struct.ifreq = type { %union.anon.178, %union.anon.179 }
%union.anon.178 = type { [16 x i8] }
%union.anon.179 = type { %struct.ifmap }
%struct.ifmap = type { i64, i64, i16, i8, i8, i8 }
%struct.if_settings = type { i32, i32, %union.anon.180 }
%union.anon.180 = type { %struct.raw_hdlc_proto* }
%struct.raw_hdlc_proto = type { i16, i16 }
%struct.neigh_parms = type { %struct.possible_net_t, %struct.net_device*, %struct.netdevice_tracker, %struct.list_head, i32 (%struct.neighbour*)*, %struct.neigh_table*, i8*, i32, %struct.refcount_struct, %struct.callback_head, i32, i32, [14 x i32], [1 x i64] }
%struct.neighbour = type { %struct.neighbour*, %struct.neigh_table*, %struct.neigh_parms*, i64, i64, %struct.rwlock_t, %struct.refcount_struct, i32, %struct.sk_buff_head, %struct.timer_list, i64, %struct.atomic_t, i8, i8, i8, i8, i32, %struct.seqlock_t, [4 x i8], [32 x i8], %struct.hh_cache, i32 (%struct.neighbour*, %struct.sk_buff*)*, %struct.neigh_ops*, %struct.list_head, %struct.list_head, %struct.callback_head, %struct.net_device*, %struct.netdevice_tracker, [0 x i8] }
%struct.sk_buff_head = type { %union.anon.84, i32, %struct.spinlock }
%union.anon.84 = type { %struct.anon.85 }
%struct.anon.85 = type { %struct.sk_buff*, %struct.sk_buff* }
%struct.seqlock_t = type { %struct.seqcount_spinlock, %struct.spinlock }
%struct.hh_cache = type { i32, %struct.seqlock_t, [12 x i64] }
%struct.neigh_ops = type { i32, void (%struct.neighbour*, %struct.sk_buff*)*, void (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)* }
%struct.neigh_table = type { i32, i32, i32, i16, i32 (i8*, %struct.net_device*, i32*)*, i1 (%struct.neighbour*, i8*)*, i32 (%struct.neighbour*)*, i32 (%struct.pneigh_entry*)*, void (%struct.pneigh_entry*)*, void (%struct.sk_buff*)*, i32 (i8*)*, i1 (%struct.net_device*, %struct.netlink_ext_ack*)*, i8*, %struct.neigh_parms, %struct.list_head, i32, i32, i32, i32, i64, %struct.delayed_work, %struct.delayed_work, %struct.timer_list, %struct.sk_buff_head, %struct.atomic_t, %struct.atomic_t, %struct.list_head, %struct.list_head, %struct.rwlock_t, i64, %struct.neigh_statistics*, %struct.neigh_hash_table*, %struct.pneigh_entry** }
%struct.pneigh_entry = type { %struct.pneigh_entry*, %struct.possible_net_t, %struct.net_device*, %struct.netdevice_tracker, i32, i8, [0 x i8] }
%struct.netlink_ext_ack = type { i8*, %struct.nlattr*, %struct.nla_policy*, %struct.nlattr*, i16, [20 x i8], i8 }
%struct.nla_policy = type { i8, i8, i16, %union.anon.82 }
%union.anon.82 = type { i8* }
%struct.nlattr = type { i16, i16 }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.workqueue_struct = type opaque
%struct.neigh_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.neigh_hash_table = type { %struct.neighbour**, i32, [4 x i32], %struct.callback_head }
%struct.rtnl_link_stats64 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ifla_vf_info = type { i32, [32 x i8], i32, i32, i32, i32, i32, i32, i32, i32, i16 }
%struct.ifla_vf_stats = type { i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ifla_vf_guid = type { i32, i64 }
%struct.ndmsg = type { i8, i8, i16, i32, i16, i8, i8 }
%struct.netlink_callback = type { %struct.sk_buff*, %struct.nlmsghdr*, i32 (%struct.sk_buff*, %struct.netlink_callback*)*, i32 (%struct.netlink_callback*)*, i8*, %struct.module*, %struct.netlink_ext_ack*, i16, i16, i32, i32, i32, i8, %union.anon.181 }
%struct.nlmsghdr = type { i32, i16, i16, i32, i32 }
%union.anon.181 = type { [6 x i64] }
%struct.netdev_phys_item_id = type { [32 x i8], i8 }
%struct.netdev_bpf = type { i32, %union.anon.182 }
%union.anon.182 = type { %struct.anon.183 }
%struct.anon.183 = type { i32, %struct.bpf_prog*, %struct.netlink_ext_ack* }
%struct.xdp_frame = type { i8*, i16, i16, i32, %struct.xdp_mem_info, %struct.net_device*, i32, i32 }
%struct.xdp_mem_info = type { i32, i32 }
%struct.xdp_buff = type { i8*, i8*, i8*, i8*, %struct.xdp_rxq_info*, %struct.xdp_txq_info*, i32, i32 }
%struct.xdp_rxq_info = type { %struct.net_device*, i32, i32, %struct.xdp_mem_info, i32, i32, [32 x i8] }
%struct.xdp_txq_info = type { %struct.net_device* }
%struct.devlink_port = type opaque
%struct.ip_tunnel_parm = type opaque
%struct.net_device_path_ctx = type { %struct.net_device*, [6 x i8], i32, [2 x %struct.anon.186] }
%struct.anon.186 = type { i16, i16 }
%struct.net_device_path = type { i32, %struct.net_device*, %union.anon.187 }
%union.anon.187 = type { %struct.anon.189, [4 x i8] }
%struct.anon.189 = type { i32, i16, i16 }
%struct.skb_shared_hwtstamps = type { %union.anon.192 }
%union.anon.192 = type { i64 }
%struct.net_device_stats = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.net_device_core_stats = type { i64, i64, i64, i64 }
%struct.ethtool_ops = type opaque
%struct.ndisc_ops = type opaque
%struct.header_ops = type { i32 (%struct.sk_buff*, %struct.net_device*, i16, i8*, i8*, i32)*, i32 (%struct.sk_buff*, i8*)*, i32 (%struct.neighbour*, %struct.hh_cache*, i16)*, void (%struct.hh_cache*, %struct.net_device*, i8*)*, i1 (i8*, i32)*, i16 (%struct.sk_buff*)* }
%struct.netdev_hw_addr_list = type { %struct.list_head, i32, %struct.rb_root }
%struct.in_device = type opaque
%struct.inet6_dev = type opaque
%struct.wireless_dev = type opaque
%struct.netdev_rx_queue = type { %struct.xdp_rxq_info, %struct.rps_map*, %struct.rps_dev_flow_table*, %struct.kobject, %struct.net_device*, %struct.netdevice_tracker, [40 x i8] }
%struct.rps_map = type { i32, %struct.callback_head, [0 x i16] }
%struct.rps_dev_flow_table = type { i32, %struct.callback_head, [0 x %struct.rps_dev_flow] }
%struct.rps_dev_flow = type { i16, i16, i32 }
%struct.cpu_rmap = type opaque
%struct.netdev_queue = type { %struct.net_device*, %struct.netdevice_tracker, %struct.Qdisc*, %struct.Qdisc*, %struct.kobject, i32, i64, %struct.atomic64_t, %struct.net_device*, [8 x i8], %struct.spinlock, i32, i64, i64, [40 x i8], %struct.dql }
%struct.dql = type { i32, i32, i32, [52 x i8], i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, [20 x i8] }
%struct.Qdisc = type { i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, i32, i32, %struct.Qdisc_ops*, %struct.qdisc_size_table*, %struct.hlist_node, i32, i32, %struct.netdev_queue*, %struct.net_rate_estimator*, %struct.gnet_stats_basic_sync*, %struct.gnet_stats_queue*, i32, %struct.refcount_struct, [24 x i8], %struct.sk_buff_head, %struct.qdisc_skb_head, %struct.gnet_stats_basic_sync, %struct.gnet_stats_queue, i64, i64, %struct.Qdisc*, %struct.sk_buff_head, [56 x i8], %struct.spinlock, %struct.spinlock, %struct.callback_head, %struct.netdevice_tracker, [40 x i8], [0 x i64] }
%struct.Qdisc_ops = type { %struct.Qdisc_ops*, %struct.Qdisc_class_ops*, [16 x i8], i32, i32, i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, %struct.sk_buff* (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, i32)*, void (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*, %struct.sk_buff*)*, i32 (%struct.Qdisc*, %struct.gnet_dump*)*, void (%struct.Qdisc*, i32)*, void (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*)*, i32 (%struct.Qdisc*)*, %struct.module* }
%struct.Qdisc_class_ops = type { i32, %struct.netdev_queue* (%struct.Qdisc*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.Qdisc*, %struct.Qdisc**, %struct.netlink_ext_ack*)*, %struct.Qdisc* (%struct.Qdisc*, i64)*, void (%struct.Qdisc*, i64)*, i64 (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*, i32, i32, %struct.nlattr**, i64*, %struct.netlink_ext_ack*)*, i32 (%struct.Qdisc*, i64, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*, %struct.qdisc_walker*)*, %struct.tcf_block* (%struct.Qdisc*, i64, %struct.netlink_ext_ack*)*, i64 (%struct.Qdisc*, i64, i32)*, void (%struct.Qdisc*, i64)*, i32 (%struct.Qdisc*, i64, %struct.sk_buff*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.gnet_dump*)* }
%struct.tcmsg = type { i8, i8, i16, i32, i32, i32, i32 }
%struct.qdisc_walker = type opaque
%struct.tcf_block = type { %struct.mutex, %struct.list_head, i32, i32, %struct.refcount_struct, %struct.net*, %struct.Qdisc*, %struct.rw_semaphore, %struct.flow_block, %struct.list_head, i8, %struct.atomic_t, i32, i32, %struct.anon.195, %struct.callback_head, [128 x %struct.hlist_head], %struct.mutex }
%struct.flow_block = type { %struct.list_head }
%struct.anon.195 = type { %struct.tcf_chain*, %struct.list_head }
%struct.tcf_chain = type { %struct.mutex, %struct.tcf_proto*, %struct.list_head, %struct.tcf_block*, i32, i32, i32, i8, i8, %struct.tcf_proto_ops*, i8*, %struct.callback_head }
%struct.tcf_proto = type { %struct.tcf_proto*, i8*, i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.tcf_result*)*, i16, i32, i8*, %struct.tcf_proto_ops*, %struct.tcf_chain*, %struct.spinlock, i8, %struct.refcount_struct, %struct.callback_head, %struct.hlist_node }
%struct.tcf_result = type { %union.anon.193 }
%union.anon.193 = type { %struct.anon.194 }
%struct.anon.194 = type { i64, i32 }
%struct.tcf_proto_ops = type { %struct.list_head, [16 x i8], i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.tcf_result*)*, i32 (%struct.tcf_proto*)*, void (%struct.tcf_proto*, i1, %struct.netlink_ext_ack*)*, i8* (%struct.tcf_proto*, i32)*, void (%struct.tcf_proto*, i8*)*, i32 (%struct.net*, %struct.sk_buff*, %struct.tcf_proto*, i64, i32, %struct.nlattr**, i8**, i32, %struct.netlink_ext_ack*)*, i32 (%struct.tcf_proto*, i8*, i8*, i1, %struct.netlink_ext_ack*)*, i1 (%struct.tcf_proto*)*, void (%struct.tcf_proto*, %struct.tcf_walker*, i1)*, i32 (%struct.tcf_proto*, i1, i32 (i32, i8*, i8*)*, i8*, %struct.netlink_ext_ack*)*, void (%struct.tcf_proto*, i8*)*, void (%struct.tcf_proto*, i8*)*, void (i8*, i32, i64, i8*, i64)*, i8* (%struct.net*, %struct.tcf_chain*, %struct.nlattr**, %struct.netlink_ext_ack*)*, void (i8*)*, i32 (%struct.net*, %struct.tcf_proto*, i8*, %struct.sk_buff*, %struct.tcmsg*, i1)*, i32 (%struct.net*, %struct.tcf_proto*, i8*, %struct.sk_buff*, %struct.tcmsg*, i1)*, i32 (%struct.sk_buff*, %struct.net*, i8*)*, %struct.module*, i32 }
%struct.tcf_walker = type opaque
%struct.gnet_dump = type { %struct.spinlock*, %struct.sk_buff*, %struct.nlattr*, i32, i32, i32, i8*, i32, %struct.tc_stats }
%struct.tc_stats = type { i64, i32, i32, i32, i32, i32, i32, i32 }
%struct.qdisc_size_table = type { %struct.callback_head, %struct.list_head, %struct.tc_sizespec, i32, [0 x i16] }
%struct.tc_sizespec = type { i8, i8, i16, i32, i32, i32, i32, i32 }
%struct.net_rate_estimator = type opaque
%struct.qdisc_skb_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.gnet_stats_basic_sync = type { %struct.u64_stats_t, %struct.u64_stats_t, %struct.u64_stats_sync }
%struct.gnet_stats_queue = type { i32, i32, i32, i32, i32 }
%struct.xdp_dev_bulk_queue = type opaque
%struct.xps_dev_maps = type { %struct.callback_head, i32, i16, [0 x %struct.xps_map*] }
%struct.xps_map = type { i32, i32, %struct.callback_head, [0 x i16] }
%struct.mini_Qdisc = type { %struct.tcf_proto*, %struct.tcf_block*, %struct.gnet_stats_basic_sync*, %struct.gnet_stats_queue*, i64 }
%struct.nf_hook_entries = type opaque
%struct.netpoll_info = type opaque
%struct.possible_net_t = type { %struct.net* }
%union.anon.196 = type { %struct.pcpu_lstats* }
%struct.pcpu_lstats = type { %struct.u64_stats_t, %struct.u64_stats_t, %struct.u64_stats_sync }
%struct.device = type { %struct.kobject, %struct.device*, %struct.device_private*, i8*, %struct.device_type*, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.mutex, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.dev_msi_info, %struct.dma_map_ops*, i64*, i64, i64, %struct.bus_dma_region*, %struct.device_dma_parameters*, %struct.list_head, %struct.io_tlb_mem*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, i32, %struct.spinlock, %struct.list_head, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.dev_iommu*, %struct.device_physical_location*, i32, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key, i8 }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.lock_class_key = type {}
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.attribute_group**, %struct.dev_pm_ops*, void (%struct.device*)*, %struct.driver_private* }
%struct.of_device_id = type opaque
%struct.acpi_device_id = type opaque
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, i32, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.hrtimer, i64, %struct.work_struct, %struct.wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.completion = type { i32, %struct.swait_queue_head }
%struct.swait_queue_head = type { %struct.raw_spinlock, %struct.list_head }
%struct.wakeup_source = type { i8*, i32, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.device*, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, i32 (%struct.device*)*, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.dev_msi_info = type { %struct.irq_domain*, %struct.msi_device_data* }
%struct.irq_domain = type opaque
%struct.msi_device_data = type opaque
%struct.dma_map_ops = type opaque
%struct.bus_dma_region = type opaque
%struct.device_dma_parameters = type { i32, i32, i64 }
%struct.io_tlb_mem = type opaque
%struct.dev_archdata = type {}
%struct.device_node = type opaque
%struct.fwnode_handle = type { %struct.fwnode_handle*, %struct.fwnode_operations*, %struct.device*, %struct.list_head, %struct.list_head, i8 }
%struct.fwnode_operations = type { %struct.fwnode_handle* (%struct.fwnode_handle*)*, void (%struct.fwnode_handle*)*, i1 (%struct.fwnode_handle*)*, i8* (%struct.fwnode_handle*, %struct.device*)*, i1 (%struct.fwnode_handle*)*, {}*, i1 (%struct.fwnode_handle*, i8*)*, i32 (%struct.fwnode_handle*, i8*, i32, i8*, i64)*, i32 (%struct.fwnode_handle*, i8*, i8**, i64)*, i8* (%struct.fwnode_handle*)*, i8* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, %struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, i8*)*, i32 (%struct.fwnode_handle*, i8*, i8*, i32, i32, %struct.fwnode_reference_args*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, %struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, i32 (%struct.fwnode_handle*, %struct.fwnode_endpoint*)*, i8* (%struct.fwnode_handle*, i32)*, i32 (%struct.fwnode_handle*, i32)*, i32 (%struct.fwnode_handle*)* }
%struct.fwnode_reference_args = type { %struct.fwnode_handle*, i32, [8 x i64] }
%struct.fwnode_endpoint = type { i32, i32, %struct.fwnode_handle* }
%struct.class = type { i8*, %struct.module*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, void (%struct.device*, %struct.kuid_t*, %struct.kgid_t*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.iommu_group = type opaque
%struct.dev_iommu = type opaque
%struct.device_physical_location = type { i32, i32, i32, i8, i8 }
%struct.rtnl_link_ops = type { %struct.list_head, i8*, i64, %struct.net_device* (%struct.nlattr**, i8*, i8, i32, i32)*, void (%struct.net_device*)*, i8, i32, %struct.nla_policy*, i32 (%struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i32 (%struct.net*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, void (%struct.net_device*, %struct.list_head*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i32 ()*, i32 ()*, i32, %struct.nla_policy*, i32 (%struct.net_device*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i64 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*, %struct.net_device*)*, %struct.net* (%struct.net_device*)*, i64 (%struct.net_device*, i32)*, i32 (%struct.sk_buff*, %struct.net_device*, i32*, i32)* }
%struct.netdev_tc_txq = type { i16, i16 }
%struct.netprio_map = type { %struct.callback_head, i32, [0 x i32] }
%struct.phy_device = type opaque
%struct.sfp_bus = type opaque
%struct.udp_tunnel_nic_info = type opaque
%struct.udp_tunnel_nic = type opaque
%struct.bpf_xdp_entity = type { %struct.bpf_prog*, %struct.bpf_xdp_link* }
%struct.bpf_xdp_link = type opaque
%struct.netdevice_tracker = type {}
%struct.rtnl_hw_stats64 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.netns_core = type { %struct.ctl_table_header*, i32, i8, %struct.prot_inuse* }
%struct.prot_inuse = type { i32, [64 x i32] }
%struct.netns_mib = type { %struct.ipstats_mib*, %struct.ipstats_mib*, %struct.tcp_mib*, %struct.linux_mib*, %struct.udp_mib*, %struct.udp_mib*, %struct.udp_mib*, %struct.udp_mib*, %struct.icmp_mib*, %struct.icmpmsg_mib*, %struct.icmpv6_mib*, %struct.icmpv6msg_mib*, %struct.proc_dir_entry* }
%struct.ipstats_mib = type { [37 x i64], %struct.u64_stats_sync }
%struct.tcp_mib = type { [16 x i64] }
%struct.linux_mib = type { [126 x i64] }
%struct.udp_mib = type { [10 x i64] }
%struct.icmp_mib = type { [28 x i64] }
%struct.icmpmsg_mib = type { [512 x %struct.atomic64_t] }
%struct.icmpv6_mib = type { [6 x i64] }
%struct.icmpv6msg_mib = type { [512 x %struct.atomic64_t] }
%struct.netns_packet = type { %struct.mutex, %struct.hlist_head }
%struct.netns_unix = type { %struct.unix_table, i32, %struct.ctl_table_header* }
%struct.unix_table = type { %struct.spinlock*, %struct.hlist_head* }
%struct.netns_nexthop = type { %struct.rb_root, %struct.hlist_head*, i32, i32, %struct.blocking_notifier_head }
%struct.blocking_notifier_head = type { %struct.rw_semaphore, %struct.notifier_block* }
%struct.netns_ipv4 = type { %struct.inet_timewait_death_row, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ipv4_devconf*, %struct.ipv4_devconf*, %struct.ip_ra_chain*, %struct.mutex, %struct.fib_rules_ops*, %struct.fib_table*, %struct.fib_table*, i32, i8, i8, i8, %struct.hlist_head*, %struct.sock*, %struct.sock*, %struct.inet_peer_base*, %struct.fqdir*, i8, i8, i8, i8, i8, i32, i32, i32, i32, i32, %struct.local_ports, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i32, i32, i32, i32, i32, i32, i32, i8, i8, i8, i8, i8, i8, i32, i8, i8, i8, i8, i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, i32, i32, i32, i8, i8, i8, i8, i32, i32, i32, [3 x i32], [3 x i32], i32, i64, i64, i32, i32, %struct.tcp_congestion_ops*, %struct.tcp_fastopen_context*, i32, %struct.atomic_t, i64, i32, i32, i32, i32, i8, i8, i32, i32, i32, %struct.ping_group_range, %struct.atomic_t, i64*, i32, %struct.mr_table*, i32, i8, i8, %struct.fib_notifier_ops*, i32, %struct.fib_notifier_ops*, i32, %struct.atomic_t, %struct.siphash_key_t, [16 x i8] }
%struct.inet_timewait_death_row = type { %struct.refcount_struct, [60 x i8], %struct.inet_hashinfo*, i32, [52 x i8] }
%struct.inet_hashinfo = type opaque
%struct.ipv4_devconf = type opaque
%struct.ip_ra_chain = type opaque
%struct.fib_rules_ops = type { i32, %struct.list_head, i32, i32, i32, i32, i32, i32 (%struct.fib_rule*, %struct.flowi*, i32, %struct.fib_lookup_arg*)*, i1 (%struct.fib_rule*, i32, %struct.fib_lookup_arg*)*, i32 (%struct.fib_rule*, %struct.flowi*, i32)*, i32 (%struct.fib_rule*, %struct.sk_buff*, %struct.fib_rule_hdr*, %struct.nlattr**, %struct.netlink_ext_ack*)*, i32 (%struct.fib_rule*)*, i32 (%struct.fib_rule*, %struct.fib_rule_hdr*, %struct.nlattr**)*, i32 (%struct.fib_rule*, %struct.sk_buff*, %struct.fib_rule_hdr*)*, i64 (%struct.fib_rule*)*, void (%struct.fib_rules_ops*)*, i32, %struct.list_head, %struct.module*, %struct.net*, %struct.callback_head }
%struct.fib_rule = type { %struct.list_head, i32, i32, i32, i32, i32, i32, i8, i8, i8, i8, i32, i64, %struct.fib_rule*, %struct.net*, %struct.refcount_struct, i32, i32, i32, [16 x i8], [16 x i8], %struct.fib_kuid_range, %struct.fib_rule_port_range, %struct.fib_rule_port_range, %struct.callback_head }
%struct.fib_kuid_range = type { %struct.kuid_t, %struct.kuid_t }
%struct.fib_rule_port_range = type { i16, i16 }
%struct.flowi = type { %union.anon.95 }
%union.anon.95 = type { %struct.flowi6 }
%struct.flowi6 = type { %struct.flowi_common, %struct.in6_addr, %struct.in6_addr, i32, %union.flowi_uli, i32 }
%struct.flowi_common = type { i32, i32, i32, i32, i8, i8, i8, i8, i32, %struct.kuid_t, %struct.flowi_tunnel, i32 }
%struct.flowi_tunnel = type { i64 }
%struct.in6_addr = type { %union.anon.77 }
%union.anon.77 = type { [4 x i32] }
%union.flowi_uli = type { i32 }
%struct.fib_lookup_arg = type { i8*, i8*, i8*, %struct.fib_rule*, i32, i32 }
%struct.fib_rule_hdr = type { i8, i8, i8, i8, i8, i8, i8, i8, i32 }
%struct.fib_table = type opaque
%struct.inet_peer_base = type opaque
%struct.fqdir = type { i64, i64, i32, i32, %struct.inet_frags*, %struct.net*, i8, [23 x i8], %struct.rhashtable, [56 x i8], %struct.atomic64_t, %struct.work_struct, %struct.llist_node, [16 x i8] }
%struct.inet_frags = type { i32, void (%struct.inet_frag_queue*, i8*)*, void (%struct.inet_frag_queue*)*, void (%struct.timer_list*)*, %struct.kmem_cache*, i8*, %struct.rhashtable_params, %struct.refcount_struct, %struct.completion }
%struct.inet_frag_queue = type { %struct.rhash_head, %union.anon.99, %struct.timer_list, %struct.spinlock, %struct.refcount_struct, %struct.rb_root, %struct.sk_buff*, %struct.sk_buff*, i64, i32, i32, i8, i8, i16, %struct.fqdir*, %struct.callback_head }
%struct.rhash_head = type { %struct.rhash_head* }
%union.anon.99 = type { %struct.frag_v6_compare_key }
%struct.frag_v6_compare_key = type { %struct.in6_addr, %struct.in6_addr, i32, i32, i32 }
%struct.rhashtable_params = type { i16, i16, i16, i16, i32, i16, i8, i32 (i8*, i32, i32)*, i32 (i8*, i32, i32)*, i32 (%struct.rhashtable_compare_arg*, i8*)* }
%struct.rhashtable_compare_arg = type { %struct.rhashtable*, i8* }
%struct.rhashtable = type { %struct.bucket_table*, i32, i32, %struct.rhashtable_params, i8, %struct.work_struct, %struct.mutex, %struct.spinlock, %struct.atomic_t }
%struct.bucket_table = type opaque
%struct.local_ports = type { %struct.seqlock_t, [2 x i32], i8 }
%struct.tcp_congestion_ops = type opaque
%struct.tcp_fastopen_context = type opaque
%struct.ping_group_range = type { %struct.seqlock_t, [2 x %struct.kgid_t] }
%struct.mr_table = type opaque
%struct.fib_notifier_ops = type { i32, %struct.list_head, i32 (%struct.net*)*, i32 (%struct.net*, %struct.notifier_block*, %struct.netlink_ext_ack*)*, %struct.module*, %struct.callback_head }
%struct.siphash_key_t = type { [2 x i64] }
%struct.netns_ipv6 = type { %struct.dst_ops, %struct.netns_sysctl_ipv6, %struct.ipv6_devconf*, %struct.ipv6_devconf*, %struct.inet_peer_base*, %struct.fqdir*, %struct.fib6_info*, %struct.rt6_info*, %struct.rt6_statistics*, %struct.timer_list, %struct.hlist_head*, %struct.fib6_table*, %struct.list_head, %struct.rwlock_t, %struct.spinlock, %struct.atomic_t, i64, i8, %struct.sock*, %struct.sock*, %struct.sock*, %struct.sock*, %struct.hlist_head*, %struct.spinlock, %struct.delayed_work, %struct.atomic_t, %struct.atomic_t, %struct.seg6_pernet_data*, %struct.fib_notifier_ops*, %struct.fib_notifier_ops*, i32, %struct.anon.100, %struct.ioam6_pernet_data*, [32 x i8] }
%struct.dst_ops = type { i16, i32, i32 (%struct.dst_ops*)*, %struct.dst_entry* (%struct.dst_entry*, i32)*, i32 (%struct.dst_entry*)*, i32 (%struct.dst_entry*)*, i32* (%struct.dst_entry*, i64)*, void (%struct.dst_entry*)*, void (%struct.dst_entry*, %struct.net_device*, i32)*, %struct.dst_entry* (%struct.dst_entry*)*, void (%struct.sk_buff*)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*, i32, i1)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*)*, i32 (%struct.net*, %struct.sock*, %struct.sk_buff*)*, %struct.neighbour* (%struct.dst_entry*, %struct.sk_buff*, i8*)*, void (%struct.dst_entry*, i8*)*, %struct.kmem_cache*, %struct.percpu_counter, [24 x i8] }
%struct.dst_entry = type { %struct.net_device*, %struct.dst_ops*, i64, i64, %struct.xfrm_state*, i32 (%struct.sk_buff*)*, i32 (%struct.net*, %struct.sock*, %struct.sk_buff*)*, i16, i16, i16, i16, %struct.atomic_t, i32, i64, %struct.lwtunnel_state*, %struct.callback_head, i16, i16, i32, %struct.netdevice_tracker }
%struct.xfrm_state = type opaque
%struct.lwtunnel_state = type opaque
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.netns_sysctl_ipv6 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i8, i8, i8, i32, i8, i8, i8, [4 x i64], i64*, i8, i8, i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i8, i8 }
%struct.ipv6_devconf = type opaque
%struct.fib6_info = type opaque
%struct.rt6_info = type opaque
%struct.rt6_statistics = type opaque
%struct.fib6_table = type opaque
%struct.seg6_pernet_data = type opaque
%struct.anon.100 = type { %struct.hlist_head, %struct.spinlock, i32 }
%struct.ioam6_pernet_data = type opaque
%struct.netns_nf = type { %struct.proc_dir_entry*, [11 x %struct.nf_logger*], %struct.ctl_table_header*, [5 x %struct.nf_hook_entries*], [5 x %struct.nf_hook_entries*], i32, i32 }
%struct.nf_logger = type opaque
%struct.netns_ct = type { i8, i8, i8, i8, i8, %struct.ip_conntrack_stat*, %struct.nf_ct_event_notifier*, %struct.nf_ip_net }
%struct.ip_conntrack_stat = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.nf_ct_event_notifier = type opaque
%struct.nf_ip_net = type { %struct.nf_generic_net, %struct.nf_tcp_net, %struct.nf_udp_net, %struct.nf_icmp_net, %struct.nf_icmp_net }
%struct.nf_generic_net = type { i32 }
%struct.nf_tcp_net = type { [14 x i32], i8, i8, i8, i8 }
%struct.nf_udp_net = type { [2 x i32] }
%struct.nf_icmp_net = type { i32 }
%struct.net_generic = type opaque
%struct.netns_bpf = type { [2 x %struct.bpf_prog_array*], [2 x %struct.bpf_prog*], [2 x %struct.list_head] }
%struct.bpf_prog_array = type { %struct.callback_head, [0 x %struct.bpf_prog_array_item] }
%struct.bpf_prog_array_item = type { %struct.bpf_prog*, %union.anon.101 }
%union.anon.101 = type { [2 x %struct.bpf_cgroup_storage*] }
%struct.bpf_cgroup_storage = type opaque
%struct.netns_xfrm = type { %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, %struct.hlist_head*, %struct.hlist_head*, i32, i32, %struct.work_struct, %struct.list_head, %struct.hlist_head*, i32, [3 x %struct.hlist_head], [3 x %struct.xfrm_policy_hash], [6 x i32], %struct.work_struct, %struct.xfrm_policy_hthresh, %struct.list_head, %struct.sock*, %struct.sock*, i32, i32, i32, i32, [3 x i8], %struct.ctl_table_header*, [24 x i8], %struct.dst_ops, %struct.dst_ops, %struct.spinlock, %struct.seqcount_spinlock, %struct.seqcount_spinlock, %struct.spinlock, %struct.mutex, [16 x i8] }
%struct.xfrm_policy_hash = type { %struct.hlist_head*, i32, i8, i8, i8, i8 }
%struct.xfrm_policy_hthresh = type { %struct.work_struct, %struct.seqlock_t, i8, i8, i8, i8 }
%struct.sock = type { %struct.sock_common, %struct.dst_entry*, i32, i32, %struct.socket_lock_t, %struct.atomic_t, i32, %struct.sk_buff_head, %struct.sk_buff_head, %struct.anon.86, i32, i32, i32, i32, i32, %struct.sk_filter*, %union.anon.87, [2 x %struct.xfrm_policy*], %struct.dst_entry*, %struct.atomic_t, i32, i32, %struct.refcount_struct, i64, %union.anon.88, %struct.sk_buff_head, i32, i32, i32, i32, i64, %struct.timer_list, i32, i32, i64, i64, %struct.page_frag, i64, i32, i32, i32, i32, i8, i8, i16, i16, i16, i64, %struct.proto*, %struct.rwlock_t, i32, i32, i32, i32, %struct.kuid_t, i8, i8, i16, %struct.spinlock, i32, %struct.pid*, %struct.cred*, i64, i64, i16, i8, %struct.atomic_t, %struct.atomic_t, i8, i8, %struct.socket*, i8*, i8*, %struct.sock_cgroup_data, %struct.mem_cgroup*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, %struct.sk_buff*)*, void (%struct.sock*)*, %struct.sock_reuseport*, %struct.bpf_local_storage*, %struct.callback_head, %struct.netns_tracker, %struct.hlist_node }
%struct.sock_common = type { %union.anon.42, %union.anon.44, %union.anon.45, i16, i8, i8, i32, %union.anon.47, %struct.proto*, %struct.possible_net_t, %struct.in6_addr, %struct.in6_addr, %struct.atomic64_t, %union.anon.78, [0 x i32], %union.anon.79, i16, i16, %union.anon.80, %struct.refcount_struct, [0 x i32], %union.anon.81 }
%union.anon.42 = type { i64 }
%union.anon.44 = type { i32 }
%union.anon.45 = type { i32 }
%union.anon.47 = type { %struct.hlist_node }
%union.anon.78 = type { i64 }
%union.anon.79 = type { %struct.hlist_node }
%union.anon.80 = type { i32 }
%union.anon.81 = type { i32 }
%struct.socket_lock_t = type { %struct.spinlock, i32, %struct.wait_queue_head }
%struct.anon.86 = type { %struct.atomic_t, i32, %struct.sk_buff*, %struct.sk_buff* }
%struct.sk_filter = type { %struct.refcount_struct, %struct.callback_head, %struct.bpf_prog* }
%union.anon.87 = type { %struct.socket_wq* }
%struct.socket_wq = type { %struct.wait_queue_head, %struct.fasync_struct*, i64, %struct.callback_head, [8 x i8] }
%struct.xfrm_policy = type opaque
%union.anon.88 = type { %struct.sk_buff* }
%struct.proto = type { void (%struct.sock*, i64)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, i32)*, %struct.sock* (%struct.sock*, i32, i32*, i1)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i8, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, void (%struct.sock*, i32)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.sock*, %struct.msghdr*, i64)*, i32 (%struct.sock*, %struct.msghdr*, i64, i32, i32*)*, i32 (%struct.sock*, %struct.page*, i32, i64, i32)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, %struct.sk_buff*)*, i1 (i32, i32)*, void (%struct.sock*)*, i32 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, i16)*, void (%struct.sock*)*, i32 (%struct.sock*, %struct.sk_psock*, i1)*, i32, i1 (%struct.sock*, i32)*, i1 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, %struct.atomic64_t*, i32*, %struct.percpu_counter*, i64*, i64*, i32*, i32*, i32, i32, i32, i8, %struct.kmem_cache*, i32, i32, i32, i32, i32*, %struct.request_sock_ops*, %struct.timewait_sock_ops*, %union.anon.76, %struct.module*, [32 x i8], %struct.list_head, i32 (%struct.sock*, i32)* }
%struct.msghdr = type { i8*, i32, i32, %struct.iov_iter, %union.anon.55, i8, i32, i64, %struct.kiocb*, %struct.ubuf_info*, i32 (%struct.sock*, %struct.sk_buff*, %struct.iov_iter*, i64)* }
%union.anon.55 = type { i8* }
%struct.ubuf_info = type { void (%struct.sk_buff*, %struct.ubuf_info*, i1)*, %struct.refcount_struct, i8 }
%struct.sockaddr = type { i16, [14 x i8] }
%struct.sk_psock = type opaque
%struct.request_sock_ops = type opaque
%struct.timewait_sock_ops = type opaque
%union.anon.76 = type { %struct.inet_hashinfo* }
%struct.socket = type { i32, i16, i64, %struct.file*, %struct.sock*, %struct.proto_ops*, [24 x i8], %struct.socket_wq }
%struct.proto_ops = type { i32, %struct.module*, i32 (%struct.socket*)*, i32 (%struct.socket*, %struct.sockaddr*, i32)*, i32 (%struct.socket*, %struct.sockaddr*, i32, i32)*, i32 (%struct.socket*, %struct.socket*)*, i32 (%struct.socket*, %struct.socket*, i32, i1)*, i32 (%struct.socket*, %struct.sockaddr*, i32)*, i32 (%struct.file*, %struct.socket*, %struct.poll_table_struct*)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i8*, i1, i1)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i8, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32*)*, void (%struct.seq_file*, %struct.socket*)*, i32 (%struct.socket*, %struct.msghdr*, i64)*, i32 (%struct.socket*, %struct.msghdr*, i64, i32)*, i32 (%struct.file*, %struct.socket*, %struct.vm_area_struct*)*, i64 (%struct.socket*, %struct.page*, i32, i64, i32)*, i64 (%struct.socket*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.sock*, i32)*, i32 (%struct.socket*)*, i32 (%struct.sock*, %struct.read_descriptor_t*, i32 (%struct.read_descriptor_t*, %struct.sk_buff*, i32, i64)*)*, i32 (%struct.sock*, i32 (%struct.sock*, %struct.sk_buff*)*)*, i32 (%struct.sock*, %struct.page*, i32, i64, i32)*, i32 (%struct.sock*, %struct.msghdr*, i64)*, i32 (%struct.sock*, i32)* }
%struct.read_descriptor_t = type { i64, i64, %union.anon.93, i32 }
%union.anon.93 = type { i8* }
%struct.sock_cgroup_data = type { %struct.cgroup*, i32, i16 }
%struct.cgroup = type { %struct.cgroup_subsys_state, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernfs_node*, %struct.cgroup_file, %struct.cgroup_file, [0 x %struct.cgroup_file], i16, i16, i16, i16, [14 x %struct.cgroup_subsys_state*], %struct.cgroup_root*, %struct.list_head, [14 x %struct.list_head], %struct.cgroup*, %struct.cgroup*, %struct.cgroup_rstat_cpu*, %struct.list_head, %struct.cgroup_base_stat, %struct.cgroup_base_stat, %struct.prev_cputime, %struct.list_head, %struct.mutex, %struct.wait_queue_head, %struct.work_struct, %struct.psi_group*, %struct.cgroup_bpf, %struct.atomic_t, %struct.cgroup_freezer_state, [0 x %struct.cgroup*] }
%struct.cgroup_subsys_state = type { %struct.cgroup*, %struct.cgroup_subsys*, %struct.percpu_ref, %struct.list_head, %struct.list_head, %struct.list_head, i32, i32, i64, %struct.atomic_t, %struct.work_struct, %struct.rcu_work, %struct.cgroup_subsys_state* }
%struct.cgroup_subsys = type { %struct.cgroup_subsys_state* (%struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*, i32)*, i32 (%struct.seq_file*, %struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_taskset*)*, void (%struct.cgroup_taskset*)*, void (%struct.cgroup_taskset*)*, void ()*, i32 (%struct.task_struct*, %struct.css_set*)*, void (%struct.task_struct*, %struct.css_set*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.cgroup_subsys_state*)*, i8, i32, i8*, i8*, %struct.cgroup_root*, %struct.idr, %struct.list_head, %struct.cftype*, %struct.cftype*, i32 }
%struct.cgroup_taskset = type opaque
%struct.cftype = type { [64 x i8], i64, i64, i32, i32, %struct.cgroup_subsys*, %struct.list_head, %struct.kernfs_ops*, i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.poll_table_struct*)* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.poll_table_struct*)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.rcu_work = type { %struct.work_struct, %struct.callback_head, %struct.workqueue_struct* }
%struct.cgroup_file = type { %struct.kernfs_node*, i64, %struct.timer_list }
%struct.cgroup_root = type { %struct.kernfs_root*, i32, i32, %struct.cgroup, %struct.cgroup*, %struct.atomic_t, %struct.list_head, i32, [4096 x i8], [64 x i8] }
%struct.kernfs_root = type opaque
%struct.cgroup_rstat_cpu = type { %struct.u64_stats_sync, %struct.cgroup_base_stat, %struct.cgroup_base_stat, %struct.cgroup*, %struct.cgroup* }
%struct.cgroup_base_stat = type { %struct.task_cputime }
%struct.task_cputime = type { i64, i64, i64 }
%struct.psi_group = type {}
%struct.cgroup_bpf = type {}
%struct.cgroup_freezer_state = type { i8, i32, i32, i32 }
%struct.mem_cgroup = type opaque
%struct.sock_reuseport = type opaque
%struct.netns_tracker = type {}
%struct.time_namespace = type opaque
%struct.cgroup_namespace = type { %struct.ns_common, %struct.user_namespace*, %struct.ucounts*, %struct.css_set* }
%struct.signal_struct = type { %struct.refcount_struct, %struct.atomic_t, i32, i32, %struct.list_head, %struct.wait_queue_head, %struct.task_struct*, %struct.sigpending, %struct.hlist_head, i32, i32, %struct.task_struct*, i32, i32, %struct.core_state*, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.posix_cputimers, [4 x %struct.pid*], %struct.pid*, i32, %struct.tty_struct*, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, %struct.tty_audit_buf*, i8, i16, i16, %struct.mm_struct*, %struct.mutex, %struct.rw_semaphore }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.cpu_itimer = type { i64, i64 }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic }
%struct.task_cputime_atomic = type { %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t }
%struct.tty_struct = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type { i16, i32, i8, i8, i64, i64, i64, i64, i64, i64, i64, i64, [32 x i8], i8, [3 x i8], [4 x i8], i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i64, i64, i64, i64, i64 }
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.spinlock, %struct.refcount_struct, %struct.wait_queue_head, [64 x %struct.k_sigaction] }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.atomic_t, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.syscall_user_dispatch = type { i8*, i64, i64, i8 }
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type { i64, %struct.rb_node, %struct.list_head, i64, i64, %struct.kref, i32, i32, i32, i32, %struct.atomic64_t, %struct.bdi_writeback, %struct.list_head, %struct.wait_queue_head, %struct.device*, [64 x i8], %struct.device*, %struct.timer_list, %struct.dentry* }
%struct.bdi_writeback = type { %struct.backing_dev_info*, i64, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.spinlock, %struct.atomic_t, [4 x %struct.percpu_counter], i64, i64, i64, i64, i64, i64, i64, %struct.fprop_local_percpu, i32, i32, %struct.spinlock, %struct.list_head, %struct.delayed_work, %struct.delayed_work, i64, %struct.list_head }
%struct.fprop_local_percpu = type { %struct.percpu_counter, i32, %struct.raw_spinlock }
%struct.io_context = type { %struct.atomic64_t, %struct.atomic_t, i16 }
%struct.capture_control = type opaque
%struct.kernel_siginfo = type { %struct.anon.102 }
%struct.anon.102 = type { i32, i32, i32, %union.__sifields }
%union.__sifields = type { %struct.anon.106 }
%struct.anon.106 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.css_set = type { [14 x %struct.cgroup_subsys_state*], %struct.refcount_struct, %struct.css_set*, %struct.cgroup*, i32, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, [14 x %struct.list_head], %struct.list_head, %struct.list_head, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.cgroup*, %struct.cgroup*, %struct.css_set*, i8, %struct.callback_head }
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.compat_robust_list, i32, i32 }
%struct.compat_robust_list = type { i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type { %struct.pmu*, %struct.raw_spinlock, %struct.mutex, %struct.list_head, %struct.perf_event_groups, %struct.perf_event_groups, %struct.list_head, %struct.list_head, %struct.list_head, i32, i32, i32, i32, i32, i32, i32, i32, %struct.refcount_struct, %struct.task_struct*, i64, i64, i64, %struct.perf_event_context*, i64, i64, i32, i32, i8*, %struct.callback_head, %struct.local_t }
%struct.pmu = type { %struct.list_head, %struct.module*, %struct.device*, %struct.attribute_group**, %struct.attribute_group**, i8*, i32, i32, i32*, %struct.perf_cpu_context*, %struct.atomic_t, i32, i32, i32, void (%struct.pmu*)*, void (%struct.pmu*)*, i32 (%struct.perf_event*)*, void (%struct.perf_event*, %struct.mm_struct*)*, void (%struct.perf_event*, %struct.mm_struct*)*, i32 (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*)*, void (%struct.pmu*, i32)*, i32 (%struct.pmu*)*, void (%struct.pmu*)*, i32 (%struct.perf_event*)*, void (%struct.perf_event_context*, i1)*, %struct.kmem_cache*, void (%struct.perf_event_context*, %struct.perf_event_context*)*, i8* (%struct.perf_event*, i8**, i32, i1)*, void (i8*)*, i64 (%struct.perf_event*, %struct.perf_output_handle*, i64)*, i32 (%struct.list_head*)*, void (%struct.perf_event*)*, i32 (%struct.perf_event*)*, i32 (%struct.perf_event*)*, i32 (%struct.perf_event*, i64)* }
%struct.perf_cpu_context = type { %struct.perf_event_context, %struct.perf_event_context*, i32, i32, %struct.raw_spinlock, %struct.hrtimer, i64, i32, %struct.perf_cgroup*, %struct.list_head, %struct.list_head, i32, i32, i32, %struct.perf_event**, [2 x %struct.perf_event*] }
%struct.perf_cgroup = type { %struct.cgroup_subsys_state, %struct.perf_cgroup_info* }
%struct.perf_cgroup_info = type { i64, i64, i64, i32 }
%struct.perf_event = type { %struct.list_head, %struct.list_head, %struct.list_head, %struct.rb_node, i64, %struct.list_head, %struct.hlist_node, %struct.list_head, i32, i32, i32, %struct.perf_event*, %struct.pmu*, i8*, i32, i32, %struct.local64_t, %struct.atomic64_t, i64, i64, i64, %struct.perf_event_attr, i16, i16, i16, %struct.hw_perf_event, %struct.perf_event_context*, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t, %struct.mutex, %struct.list_head, %struct.perf_event*, i32, i32, %struct.list_head, %struct.task_struct*, %struct.mutex, %struct.atomic_t, %struct.perf_buffer*, %struct.list_head, i64, i32, %struct.wait_queue_head, %struct.fasync_struct*, i32, i32, i32, i32, i64, %struct.irq_work, %struct.callback_head, i32, %struct.atomic_t, %struct.perf_addr_filters_head, %struct.perf_addr_filter_range*, i64, %struct.perf_event*, void (%struct.perf_event*)*, %struct.callback_head, %struct.pid_namespace*, i64, %struct.atomic64_t, i64 ()*, void (%struct.perf_event*, %struct.perf_sample_data*, %struct.pt_regs*)*, i8*, void (%struct.perf_event*, %struct.perf_sample_data*, %struct.pt_regs*)*, %struct.bpf_prog*, i64, %struct.trace_event_call*, %struct.event_filter*, %struct.perf_cgroup*, i8*, %struct.list_head }
%struct.perf_event_attr = type { i32, i32, i64, %union.anon.216, i64, i64, i64, %union.anon.217, i32, %union.anon.218, %union.anon.219, i64, i64, i32, i32, i64, i32, i16, i16, i32, i32, i64 }
%union.anon.216 = type { i64 }
%union.anon.217 = type { i32 }
%union.anon.218 = type { i64 }
%union.anon.219 = type { i64 }
%struct.hw_perf_event = type { %union.anon.220, %struct.task_struct*, i8*, i64, i32, %struct.local64_t, i64, %union.anon.227, i64, i64, i64, i64 }
%union.anon.220 = type { %struct.anon.221 }
%struct.anon.221 = type { i64, i64, i64, i64, i32, i32, i32, i32, %struct.hw_perf_event_extra, %struct.hw_perf_event_extra }
%struct.hw_perf_event_extra = type { i64, i32, i32, i32 }
%union.anon.227 = type { %struct.anon.228 }
%struct.anon.228 = type { i64, %struct.local64_t }
%struct.perf_buffer = type opaque
%struct.irq_work = type { %struct.__call_single_node, void (%struct.irq_work*)*, %struct.rcuwait }
%struct.rcuwait = type { %struct.task_struct* }
%struct.perf_addr_filters_head = type { %struct.list_head, %struct.raw_spinlock, i32 }
%struct.perf_addr_filter_range = type { i64, i64 }
%struct.perf_sample_data = type { i64, i64, %struct.perf_branch_stack*, %union.perf_sample_weight, %union.perf_mem_data_src, i64, i64, %struct.perf_raw_record*, i64, i64, %struct.anon.233, i64, i64, i64, %struct.anon.234, %struct.perf_callchain_entry*, i64, %struct.perf_regs, %struct.perf_regs, i64, i64, i64, i64, i64, [48 x i8] }
%struct.perf_branch_stack = type { i64, i64, [0 x %struct.perf_branch_entry] }
%struct.perf_branch_entry = type { i64, i64, i64 }
%union.perf_sample_weight = type { i64 }
%union.perf_mem_data_src = type { i64 }
%struct.perf_raw_record = type { %struct.perf_raw_frag, i32 }
%struct.perf_raw_frag = type <{ %union.anon.232, i64 (i8*, i8*, i64, i64)*, i8*, i32 }>
%union.anon.232 = type { %struct.perf_raw_frag* }
%struct.anon.233 = type { i32, i32 }
%struct.anon.234 = type { i32, i32 }
%struct.perf_callchain_entry = type { i64, [0 x i64] }
%struct.perf_regs = type { i64, %struct.pt_regs* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.trace_event_call = type opaque
%struct.event_filter = type opaque
%struct.perf_output_handle = type { %struct.perf_event*, %struct.perf_buffer*, i64, i64, i64, %union.anon.114, i32 }
%union.anon.114 = type { i8* }
%struct.perf_event_groups = type { %struct.rb_root, i64 }
%struct.rseq = type { i32, i32, i64, i32, [12 x i8] }
%struct.tlbflush_unmap_batch = type { %struct.arch_tlbflush_unmap_batch, i8, i8 }
%struct.arch_tlbflush_unmap_batch = type { %struct.cpumask }
%union.anon.115 = type { %struct.callback_head }
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.request_queue = type opaque
%struct.uprobe_task = type { i32, %union.anon.116, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.116 = type { %struct.anon.117 }
%struct.anon.117 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.kmap_ctrl = type {}
%struct.timer_list = type { %struct.hlist_node, i64, void (%struct.timer_list*)*, i32 }
%struct.vm_struct = type { %struct.vm_struct*, i8*, i64, i64, %struct.page**, i32, i32, i64, i8* }
%struct.bpf_local_storage = type opaque
%struct.bpf_run_ctx = type {}
%struct.llist_head = type { %struct.llist_node* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.io_bitmap*, i64, i8, i32, [40 x i8], %struct.fpu }
%struct.desc_struct = type { i16, i16, i32 }
%struct.io_bitmap = type opaque
%struct.fpu = type { i32, i64, %struct.fpstate*, %struct.fpstate*, %struct.fpu_state_perm, %struct.fpu_state_perm, %struct.fpstate }
%struct.fpu_state_perm = type { i64, i32, i32 }
%struct.fpstate = type { i32, i32, i64, i64, i64, i8, [31 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.119, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.122 }
%union.anon.119 = type { %struct.anon.120 }
%struct.anon.120 = type { i64, i64 }
%union.anon.122 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.kmem_cache = type opaque
%struct.fs_pin = type opaque
%struct.cred = type { %struct.atomic_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.ucounts*, %struct.group_info*, %union.anon.41 }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.kgid_t] }
%union.anon.41 = type { %struct.callback_head }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec64, %struct.timespec64, %struct.timespec64, %struct.timespec64, i64, i64, i32, i32 }
%struct.fiemap_extent_info = type opaque
%struct.fileattr = type opaque
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, i8*, i32, i64, i64, i32, %struct.fsnotify_mark_connector*, [32 x i8], %struct.uuid_t, i32, i32, %struct.mutex, i8*, %struct.dentry_operations*, %struct.shrinker, %struct.atomic64_t, %struct.atomic64_t, i32, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, %struct.list_lru, %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [44 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, i32 (%struct.fs_context*)*, %struct.fs_parameter_spec*, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.fs_context = type opaque
%struct.fs_parameter_spec = type opaque
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type { i64, i64, i64, i64, i32, i16, %struct.swap_iocb** }
%struct.swap_iocb = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.spinlock, %struct.atomic_t, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.21, i32 }
%union.anon.21 = type { %struct.kuid_t }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.shrink_control = type { i32, i32, i64, i64, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.inode*, i64*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i64, i64, %struct.disk_stats*, i64, i8, i32, %struct.atomic_t, %struct.inode*, %struct.super_block*, i8*, %struct.device, i8*, i32, i8, %struct.kobject*, i8, %struct.spinlock, %struct.gendisk*, %struct.request_queue*, i32, %struct.mutex, %struct.super_block*, %struct.partition_meta_info* }
%struct.disk_stats = type opaque
%struct.gendisk = type opaque
%struct.partition_meta_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.rw_semaphore, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rcuwait, %struct.wait_queue_head, %struct.atomic_t }
%struct.rcu_sync = type { i32, i32, %struct.wait_queue_head, %struct.callback_head }
%struct.uuid_t = type { [16 x i8] }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i64, i32, i32, %struct.list_head, %struct.atomic64_t* }
%struct.list_lru = type { %struct.list_lru_node* }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, i64, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%union.anon.237 = type { i32 }
%struct.timespec64 = type { i64, i64 }
%union.anon.238 = type { %struct.callback_head }
%union.anon.239 = type { %struct.file_operations* }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%union.anon.240 = type { %struct.pipe_inode_info* }
%struct.fsnotify_mark_connector = type opaque
%struct.xarray = type { %struct.spinlock, i32, i8* }
%struct.rb_root_cached = type { %struct.rb_root, %struct.rb_node* }
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.atomic64_t, %struct.optimistic_spin_queue, %struct.raw_spinlock, %struct.list_head }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.folio*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i1 (%struct.address_space*, %struct.folio*)*, void (%struct.readahead_control*)*, i32 (%struct.file*, %struct.address_space*, i64, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.folio*, i64, i64)*, i1 (%struct.folio*, i32)*, void (%struct.folio*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.folio*, %struct.folio*, i32)*, i32 (%struct.folio*)*, i1 (%struct.folio*, i64, i64)*, void (%struct.folio*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)*, i32 (%struct.kiocb*, %struct.iov_iter*)* }
%struct.folio = type { %union.anon.130, i64, i64, i8, i8, %struct.atomic_t, %struct.atomic_t, i32 }
%union.anon.130 = type { %struct.page }
%struct.readahead_control = type opaque
%struct.swap_info_struct = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon.94, i8*, i64, i16, i16, %struct.kernfs_iattrs* }
%union.anon.94 = type { %struct.kernfs_elem_dir }
%struct.kernfs_elem_dir = type { i64, %struct.rb_root, %struct.kernfs_root*, i64 }
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.134 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.134 = type { i8* }
%struct.kernel_symbol = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type { i32, i32*, %struct.orc_entry* }
%struct.orc_entry = type { i16, i16, i16 }
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8*, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.srcu_struct = type { %struct.srcu_node*, [3 x %struct.srcu_node*], i32, %struct.mutex, %struct.spinlock, %struct.mutex, i32, i64, i64, i64, i64, i64, i64, i64, i64, %struct.srcu_data*, i8, i64, %struct.mutex, %struct.completion, %struct.atomic_t, i64, i64, %struct.delayed_work, %struct.lockdep_map }
%struct.srcu_node = type { %struct.spinlock, [4 x i64], [4 x i64], i64, %struct.srcu_node*, i32, i32 }
%struct.srcu_data = type { [2 x i64], [2 x i64], [32 x i8], %struct.spinlock, %struct.rcu_segcblist, i64, i64, i8, %struct.timer_list, %struct.work_struct, %struct.callback_head, %struct.srcu_node*, i64, i32, %struct.srcu_struct*, [48 x i8] }
%struct.rcu_segcblist = type { %struct.callback_head*, [4 x %struct.callback_head**], [4 x i64], i64, [4 x i64], i8 }
%struct.lockdep_map = type {}
%struct.bpf_raw_event_map = type { %struct.tracepoint*, i8*, i32, i32, [8 x i8] }
%struct.tracepoint = type { i8*, %struct.static_key, %struct.static_call_key*, i8*, i8*, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t, %union.anon.135 }
%union.anon.135 = type { i64 }
%struct.static_call_key = type { i8*, %union.anon.136 }
%union.anon.136 = type { i64 }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.jump_entry = type { i32, i32, i64 }
%struct.trace_eval_map = type opaque
%struct.static_call_site = type { i32, i32 }
%struct.btf_type = type { i32, i32, %union.anon.137 }
%union.anon.137 = type { i32 }
%struct.bpf_jit_poke_descriptor = type { i8*, i8*, i8*, i8*, %union.anon.138, i8, i8, i16, i32 }
%union.anon.138 = type { %struct.anon.139 }
%struct.anon.139 = type { %struct.bpf_map*, i32 }
%struct.bpf_map = type { %struct.bpf_map_ops*, %struct.bpf_map*, i8*, i32, i32, i32, i32, i64, i32, i32, %struct.bpf_map_value_off*, i32, i32, i32, i32, i32, i32, %struct.btf*, [16 x i8], %struct.bpf_map_off_arr*, [8 x i8], %struct.atomic64_t, %struct.atomic64_t, %struct.work_struct, %struct.mutex, %struct.atomic64_t, %struct.anon.176, i8, i8, [26 x i8] }
%struct.bpf_map_ops = type { i32 (%union.bpf_attr*)*, %struct.bpf_map* (%union.bpf_attr*)*, void (%struct.bpf_map*, %struct.file*)*, void (%struct.bpf_map*)*, i32 (%struct.bpf_map*, i8*, i8*)*, void (%struct.bpf_map*)*, i8* (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i8* (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*, i64)*, i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)*, i8* (%struct.bpf_map*, i8*, i32)*, i8* (%struct.bpf_map*, %struct.file*, i32)*, void (i8*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (i8*)*, void (%struct.bpf_map*, i8*, %struct.seq_file*)*, i32 (%struct.bpf_map*, %struct.btf*, %struct.btf_type*, %struct.btf_type*)*, i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)*, i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64, i32*)*, i32 (%struct.bpf_map*, %struct.vm_area_struct*)*, i32 (%struct.bpf_map*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.bpf_local_storage_map*, i8*, i32)*, void (%struct.bpf_local_storage_map*, i8*, i32)*, %struct.bpf_local_storage** (i8*)*, i32 (%struct.bpf_map*, i32, i64)*, i1 (%struct.bpf_map*, %struct.bpf_map*)*, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)*, i32 (%struct.bpf_map*, i64 (i64, i64, i64, i64, i64)*, i8*, i64)*, i32*, %struct.bpf_iter_seq_info* }
%union.bpf_attr = type { %struct.anon.144 }
%struct.anon.144 = type { i32, i32, i64, i64, i32, i32, i64, i32, i32, [16 x i8], i32, i32, i32, i32, i64, i32, i32, i64, i32, i32, %union.anon.145, i32, i64, i64, i32 }
%union.anon.145 = type { i32 }
%struct.bpf_local_storage_map = type opaque
%struct.bpf_verifier_env = type { i32, i32, %struct.bpf_prog*, %struct.bpf_verifier_ops*, %struct.bpf_verifier_stack_elem*, i32, i8, i8, %struct.bpf_verifier_state*, %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*, [64 x %struct.bpf_map*], [64 x %struct.btf_mod_pair], i32, i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, %struct.bpf_insn_aux_data*, %struct.bpf_line_info*, %struct.bpf_verifier_log, [257 x %struct.bpf_subprog_info], [75 x %struct.bpf_id_pair], %struct.anon.215, i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, %struct.sockptr_t, i32, i64, i32, i32, [64 x i8] }
%struct.bpf_verifier_stack_elem = type { %struct.bpf_verifier_state, i32, i32, %struct.bpf_verifier_stack_elem*, i32 }
%struct.bpf_verifier_state = type { [8 x %struct.bpf_func_state*], %struct.bpf_verifier_state*, i32, i32, i32, i32, i8, i32, i32, %struct.bpf_idx_pair*, i32 }
%struct.bpf_idx_pair = type { i32, i32 }
%struct.bpf_verifier_state_list = type { %struct.bpf_verifier_state, %struct.bpf_verifier_state_list*, i32, i32 }
%struct.btf_mod_pair = type { %struct.btf*, %struct.module* }
%struct.bpf_insn_aux_data = type { %union.anon.210, i64, i32, i32, i8, i8, i8, i32, i8 }
%union.anon.210 = type { %struct.anon.212 }
%struct.anon.212 = type { i32, %union.anon.213 }
%union.anon.213 = type { %struct.anon.214 }
%struct.anon.214 = type { %struct.btf*, i32 }
%struct.bpf_verifier_log = type { i32, [1024 x i8], i8*, i32, i32 }
%struct.bpf_subprog_info = type { i32, i32, i16, i8, i8, i8, i8 }
%struct.bpf_id_pair = type { i32, i32 }
%struct.anon.215 = type { i32*, i32*, i32 }
%struct.sockptr_t = type { %union.anon.48, i8 }
%union.anon.48 = type { i8* }
%struct.bpf_func_state = type { [11 x %struct.bpf_reg_state], i32, i32, i32, i32, i8, %struct.tnum, i8, i32, %struct.bpf_reference_state*, i32, %struct.bpf_stack_state* }
%struct.bpf_reg_state = type { i32, i32, %union.anon.168, i32, i32, %struct.tnum, i64, i64, i64, i64, i32, i32, i32, i32, %struct.bpf_reg_state*, i32, i32, i32, i8 }
%union.anon.168 = type { %struct.anon.169 }
%struct.anon.169 = type { %struct.bpf_map*, i32 }
%struct.tnum = type { i64, i64 }
%struct.bpf_reference_state = type { i32, i32, i32 }
%struct.bpf_stack_state = type { %struct.bpf_reg_state, [8 x i8] }
%struct.bpf_iter_seq_info = type { %struct.seq_operations*, i32 (i8*, %struct.bpf_iter_aux_info*)*, void (i8*)*, i32 }
%struct.bpf_iter_aux_info = type { %struct.bpf_map*, %struct.anon.173, %struct.anon.174 }
%struct.anon.173 = type { %struct.cgroup*, i32 }
%struct.anon.174 = type { i32, i32 }
%struct.bpf_map_value_off = type { i32, [0 x %struct.bpf_map_value_off_desc] }
%struct.bpf_map_value_off_desc = type { i32, i32, %struct.anon.175 }
%struct.anon.175 = type { %struct.btf*, %struct.module*, void (i8*)*, i32 }
%struct.bpf_map_off_arr = type { i32, [10 x i32], [10 x i8] }
%struct.anon.176 = type { %struct.spinlock, i32, i8, i8 }
%struct.bpf_kfunc_desc_tab = type { [256 x %struct.bpf_kfunc_desc], i32 }
%struct.bpf_kfunc_desc = type { %struct.btf_func_model, i32, i32, i16 }
%struct.bpf_kfunc_btf_tab = type { [256 x %struct.bpf_kfunc_btf], i32 }
%struct.bpf_kfunc_btf = type { %struct.btf*, %struct.module*, i16 }
%struct.bpf_ksym = type { i64, i64, [512 x i8], %struct.list_head, %struct.latch_tree_node, i8 }
%struct.bpf_prog_ops = type { i32 (%struct.bpf_prog*, %union.bpf_attr*, %union.bpf_attr*)* }
%struct.user_struct = type { %struct.refcount_struct, %struct.percpu_counter, i64, %struct.atomic64_t, %struct.hlist_node, %struct.kuid_t, %struct.atomic64_t, %struct.ratelimit_state }
%struct.ratelimit_state = type { %struct.raw_spinlock, i32, i32, i32, i32, i64, i64 }
%struct.bpf_prog_offload = type { %struct.bpf_prog*, %struct.net_device*, %struct.bpf_offload_dev*, i8*, %struct.list_head, i8, i8, i8*, i32 }
%struct.bpf_offload_dev = type opaque
%struct.bpf_func_info = type { i32, i32 }
%struct.bpf_func_info_aux = type { i16, i8 }
%struct.bpf_line_info = type { i32, i32, i32, i32 }
%struct.exception_table_entry = type { i32, i32, i32 }
%union.anon.197 = type { %struct.work_struct }
%struct.sock_fprog_kern = type { i16, %struct.sock_filter* }
%struct.sock_filter = type { i16, i8, i8, i32 }
%union.anon.198 = type { %struct.anon.199 }
%struct.anon.199 = type { %struct.anon.200, [0 x %struct.sock_filter] }
%struct.anon.200 = type {}
%struct.bpf_insn_access_aux = type { i32, %union.anon.208, %struct.bpf_verifier_log* }
%union.anon.208 = type { %struct.anon.209 }
%struct.anon.209 = type { %struct.btf*, i32 }
%struct.btf_id_set = type { i32, [0 x i32] }
%struct.bpf_reg_types = type { [10 x i32], i32* }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.anon.171 = type { i32, i8 }
%struct.bpf_call_arg_meta = type { %struct.bpf_map*, i8, i8, i8, i32, i32, i32, i64, i32, i32, i32, %struct.btf*, i32, %struct.btf*, i32, i32, %struct.bpf_map_value_off_desc*, i8 }
%struct.bpf_attach_target_info = type { %struct.btf_func_model, i64, i8*, %struct.btf_type* }
%struct.anon.201 = type { %struct.anon.202, [0 x %struct.bpf_insn] }
%struct.anon.202 = type {}
%struct.fd = type { %struct.file*, i32 }
%struct.anon.211 = type { i32, i32 }
%struct.bpf_loop_inline_state = type { i8, i32 }
%struct.bpf_array = type { %struct.bpf_map, i32, i32, %struct.bpf_array_aux*, %union.anon.241, [48 x i8] }
%struct.bpf_array_aux = type { %struct.list_head, %struct.bpf_map*, %struct.mutex, %struct.work_struct }
%union.anon.241 = type { [0 x i8*] }
%struct.bpf_insn_cbs = type { void (i8*, i8*, ...)*, i8* (i8*, %struct.bpf_insn*)*, i8* (i8*, %struct.bpf_insn*, i64)*, i8* }
%struct.anon.170 = type { %struct.btf*, i32 }
%struct.bpf_core_relo = type { i32, i32, i32, i32 }
%struct.bpf_core_ctx = type { %struct.bpf_verifier_log*, %struct.btf* }
%struct.bpf_struct_ops = type { %struct.bpf_verifier_ops*, i32 (%struct.btf*)*, i32 (%struct.btf_type*, %struct.btf_member*)*, i32 (%struct.btf_type*, %struct.btf_member*, i8*, i8*)*, i32 (i8*)*, void (i8*)*, %struct.btf_type*, %struct.btf_type*, i8*, [64 x %struct.btf_func_model], i32, i32 }
%struct.btf_member = type { i32, i32, i32 }
%struct.btf_var_secinfo = type { i32, i32, i32 }
%struct.bpf_kfunc_arg_meta = type { i64, i8, i32, i32 }
%struct.btf_param = type { i32, i32 }
%struct.bpf_sanitize_info = type { %struct.bpf_insn_aux_data, i8 }
%struct.anon.172 = type { i64, i64 }

@bpf_verifier_vlog.__already_done = internal global i8 0, section ".data.once", align 1
@.str = private unnamed_addr constant [54 x i8] c"verifier log line truncated - local buffer too short\0A\00", align 1
@.str.1 = private unnamed_addr constant [22 x i8] c"kernel/bpf/verifier.c\00", align 1
@.str.2 = private unnamed_addr constant [12 x i8] c"\013BPF: %s%s\00", align 1
@.str.3 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@__UNIQUE_ID___addressable_bpf_verifier_log_write523 = internal global i8* bitcast (void (%struct.bpf_verifier_env*, i8*, ...)* @bpf_verifier_log_write to i8*), section ".discard.addressable", align 8
@__UNIQUE_ID___addressable_bpf_log524 = internal global i8* bitcast (void (%struct.bpf_verifier_log*, i8*, ...)* @bpf_log to i8*), section ".discard.addressable", align 8
@.str.5 = private unnamed_addr constant [36 x i8] c"cannot pass in dynptr at an offset\0A\00", align 1
@.str.6 = private unnamed_addr constant [55 x i8] c"R%d must have zero offset when passed to release func\0A\00", align 1
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD.insn = private unnamed_addr constant %struct.bpf_insn { i8 15, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB.insn = private unnamed_addr constant %struct.bpf_insn { i8 31, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_OR.insn = private unnamed_addr constant %struct.bpf_insn { i8 79, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_AND.insn = private unnamed_addr constant %struct.bpf_insn { i8 95, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH.insn = private unnamed_addr constant %struct.bpf_insn { i8 111, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH.insn = private unnamed_addr constant %struct.bpf_insn { i8 127, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR.insn = private unnamed_addr constant %struct.bpf_insn { i8 -81, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH.insn = private unnamed_addr constant %struct.bpf_insn { i8 -49, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 12, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 28, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_OR_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 76, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_AND_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 92, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 108, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 124, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 -84, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 -52, i8 33, i16 0, i32 0 }, align 4
@__const.bpf_check_attach_target.prefix = private unnamed_addr constant [11 x i8] c"btf_trace_\00", align 1
@.str.7 = private unnamed_addr constant [38 x i8] c"Tracing programs must provide btf_id\0A\00", align 1
@.str.8 = private unnamed_addr constant [81 x i8] c"FENTRY/FEXIT program can only be attached to another program annotated with BTF\0A\00", align 1
@.str.9 = private unnamed_addr constant [29 x i8] c"attach_btf_id %u is invalid\0A\00", align 1
@.str.10 = private unnamed_addr constant [38 x i8] c"attach_btf_id %u doesn't have a name\0A\00", align 1
@.str.11 = private unnamed_addr constant [26 x i8] c"Subprog %s doesn't exist\0A\00", align 1
@.str.12 = private unnamed_addr constant [33 x i8] c"Cannot replace static functions\0A\00", align 1
@.str.13 = private unnamed_addr constant [36 x i8] c"Extension programs should be JITed\0A\00", align 1
@.str.14 = private unnamed_addr constant [32 x i8] c"Can attach to only JITed progs\0A\00", align 1
@.str.15 = private unnamed_addr constant [27 x i8] c"Cannot recursively attach\0A\00", align 1
@.str.16 = private unnamed_addr constant [28 x i8] c"Cannot extend fentry/fexit\0A\00", align 1
@.str.17 = private unnamed_addr constant [33 x i8] c"Cannot replace kernel functions\0A\00", align 1
@.str.18 = private unnamed_addr constant [60 x i8] c"Only FENTRY/FEXIT progs are attachable to another BPF prog\0A\00", align 1
@.str.19 = private unnamed_addr constant [35 x i8] c"attach_btf_id %u is not a typedef\0A\00", align 1
@.str.20 = private unnamed_addr constant [47 x i8] c"attach_btf_id %u points to wrong type name %s\0A\00", align 1
@.str.21 = private unnamed_addr constant [36 x i8] c"attach_btf_id %u is not a function\0A\00", align 1
@.str.22 = private unnamed_addr constant [44 x i8] c"The address of function %s cannot be found\0A\00", align 1
@.str.23 = private unnamed_addr constant [21 x i8] c"%s is not sleepable\0A\00", align 1
@.str.24 = private unnamed_addr constant [43 x i8] c"can't modify return codes of BPF programs\0A\00", align 1
@.str.25 = private unnamed_addr constant [24 x i8] c"%s() is not modifiable\0A\00", align 1
@btf_vmlinux = dso_local global %struct.btf* null, align 8
@bpf_verifier_lock = internal global %struct.mutex { %struct.atomic64_t zeroinitializer, %struct.raw_spinlock zeroinitializer, %struct.optimistic_spin_queue zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @bpf_verifier_lock to i8*), i64 16) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @bpf_verifier_lock to i8*), i64 16) to %struct.list_head*) } }, align 8
@bpf_verifier_ops = internal constant [32 x %struct.bpf_verifier_ops*] [%struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_filter_verifier_ops, %struct.bpf_verifier_ops* @kprobe_verifier_ops, %struct.bpf_verifier_ops* @tc_cls_act_verifier_ops, %struct.bpf_verifier_ops* @tc_cls_act_verifier_ops, %struct.bpf_verifier_ops* @tracepoint_verifier_ops, %struct.bpf_verifier_ops* @xdp_verifier_ops, %struct.bpf_verifier_ops* @perf_event_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @lwt_in_verifier_ops, %struct.bpf_verifier_ops* @lwt_out_verifier_ops, %struct.bpf_verifier_ops* @lwt_xmit_verifier_ops, %struct.bpf_verifier_ops* @sock_ops_verifier_ops, %struct.bpf_verifier_ops* @sk_skb_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_msg_verifier_ops, %struct.bpf_verifier_ops* @raw_tracepoint_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @lwt_seg6local_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_reuseport_verifier_ops, %struct.bpf_verifier_ops* @flow_dissector_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @raw_tracepoint_writable_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @tracing_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_lookup_verifier_ops, %struct.bpf_verifier_ops* @bpf_syscall_verifier_ops], align 16
@.str.26 = private unnamed_addr constant [28 x i8] c"in-kernel BTF is malformed\0A\00", align 1
@.str.27 = private unnamed_addr constant [28 x i8] c"include/linux/thread_info.h\00", align 1
@__mark_chain_precision.__already_done = internal global i8 0, section ".data.once", align 1
@.str.28 = private unnamed_addr constant [19 x i8] c"backtracing misuse\00", align 1
@.str.29 = private unnamed_addr constant [26 x i8] c"last_idx %d first_idx %d\0A\00", align 1
@.str.30 = private unnamed_addr constant [25 x i8] c"BUG backtracking idx %d\0A\00", align 1
@__mark_chain_precision.__already_done.31 = internal global i8 0, section ".data.once", align 1
@.str.32 = private unnamed_addr constant [26 x i8] c"verifier backtracking bug\00", align 1
@.str.33 = private unnamed_addr constant [36 x i8] c"parent %s regs=%x stack=%llx marks:\00", align 1
@.str.34 = private unnamed_addr constant [12 x i8] c"didn't have\00", align 1
@.str.35 = private unnamed_addr constant [12 x i8] c"already had\00", align 1
@.str.36 = private unnamed_addr constant [27 x i8] c"regs=%x stack=%llx before \00", align 1
@.str.37 = private unnamed_addr constant [5 x i8] c"%d: \00", align 1
@.str.38 = private unnamed_addr constant [12 x i8] c"BUG spi %d\0A\00", align 1
@backtrack_insn.__already_done = internal global i8 0, section ".data.once", align 1
@backtrack_insn.__already_done.39 = internal global i8 0, section ".data.once", align 1
@.str.40 = private unnamed_addr constant [13 x i8] c"BUG regs %x\0A\00", align 1
@backtrack_insn.__already_done.41 = internal global i8 0, section ".data.once", align 1
@.str.42 = private unnamed_addr constant [8 x i8] c"<error>\00", align 1
@.str.43 = private unnamed_addr constant [60 x i8] c"negative offset disallowed for kernel module function call\0A\00", align 1
@.str.44 = private unnamed_addr constant [32 x i8] c"too many different module BTFs\0A\00", align 1
@.str.45 = private unnamed_addr constant [46 x i8] c"kfunc offset > 0 without fd_array is invalid\0A\00", align 1
@.str.46 = private unnamed_addr constant [33 x i8] c"invalid module BTF fd specified\0A\00", align 1
@.str.47 = private unnamed_addr constant [38 x i8] c"BTF fd for kfunc is not a module BTF\0A\00", align 1
@.str.48 = private unnamed_addr constant [10 x i8] c" frame%d:\00", align 1
@.str.49 = private unnamed_addr constant [5 x i8] c" R%d\00", align 1
@.str.50 = private unnamed_addr constant [2 x i8] c"=\00", align 1
@.str.51 = private unnamed_addr constant [2 x i8] c"P\00", align 1
@.str.52 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.53 = private unnamed_addr constant [5 x i8] c"%lld\00", align 1
@.str.54 = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.55 = private unnamed_addr constant [8 x i8] c"%sid=%d\00", align 1
@.str.56 = private unnamed_addr constant [2 x i8] c",\00", align 1
@.str.57 = private unnamed_addr constant [16 x i8] c"%sref_obj_id=%d\00", align 1
@.str.58 = private unnamed_addr constant [9 x i8] c"%soff=%d\00", align 1
@.str.59 = private unnamed_addr constant [7 x i8] c"%sr=%d\00", align 1
@.str.60 = private unnamed_addr constant [14 x i8] c"%sks=%d,vs=%d\00", align 1
@.str.61 = private unnamed_addr constant [11 x i8] c"%simm=%llx\00", align 1
@.str.62 = private unnamed_addr constant [12 x i8] c"%ssmin=%lld\00", align 1
@.str.63 = private unnamed_addr constant [12 x i8] c"%ssmax=%lld\00", align 1
@.str.64 = private unnamed_addr constant [12 x i8] c"%sumin=%llu\00", align 1
@.str.65 = private unnamed_addr constant [12 x i8] c"%sumax=%llu\00", align 1
@.str.66 = private unnamed_addr constant [13 x i8] c"%svar_off=%s\00", align 1
@.str.67 = private unnamed_addr constant [13 x i8] c"%ss32_min=%d\00", align 1
@.str.68 = private unnamed_addr constant [13 x i8] c"%ss32_max=%d\00", align 1
@.str.69 = private unnamed_addr constant [13 x i8] c"%su32_min=%d\00", align 1
@.str.70 = private unnamed_addr constant [13 x i8] c"%su32_max=%d\00", align 1
@.str.71 = private unnamed_addr constant [2 x i8] c")\00", align 1
@slot_type_char = internal global [5 x i8] c"?rm0d", align 1
@.str.72 = private unnamed_addr constant [6 x i8] c" fp%d\00", align 1
@.str.73 = private unnamed_addr constant [4 x i8] c"=%s\00", align 1
@.str.74 = private unnamed_addr constant [9 x i8] c" refs=%d\00", align 1
@.str.75 = private unnamed_addr constant [4 x i8] c",%d\00", align 1
@.str.76 = private unnamed_addr constant [4 x i8] c" cb\00", align 1
@.str.77 = private unnamed_addr constant [10 x i8] c" async_cb\00", align 1
@.str.78 = private unnamed_addr constant [2 x i8] c"_\00", align 1
@.str.79 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.80 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.81 = private unnamed_addr constant [2 x i8] c"D\00", align 1
@reg_type_str.str = internal constant [21 x i8*] [i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.82, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.83, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.84, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.85, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.86, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.87, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.88, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.89, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.90, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.91, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.92, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.93, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.94, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.95, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.96, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.97, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.98, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.99, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.100, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.101, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.102, i32 0, i32 0)], align 16
@.str.82 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.83 = private unnamed_addr constant [7 x i8] c"scalar\00", align 1
@.str.84 = private unnamed_addr constant [4 x i8] c"ctx\00", align 1
@.str.85 = private unnamed_addr constant [8 x i8] c"map_ptr\00", align 1
@.str.86 = private unnamed_addr constant [10 x i8] c"map_value\00", align 1
@.str.87 = private unnamed_addr constant [8 x i8] c"map_key\00", align 1
@.str.88 = private unnamed_addr constant [3 x i8] c"fp\00", align 1
@.str.89 = private unnamed_addr constant [9 x i8] c"pkt_meta\00", align 1
@.str.90 = private unnamed_addr constant [4 x i8] c"pkt\00", align 1
@.str.91 = private unnamed_addr constant [8 x i8] c"pkt_end\00", align 1
@.str.92 = private unnamed_addr constant [10 x i8] c"flow_keys\00", align 1
@.str.93 = private unnamed_addr constant [5 x i8] c"sock\00", align 1
@.str.94 = private unnamed_addr constant [12 x i8] c"sock_common\00", align 1
@.str.95 = private unnamed_addr constant [9 x i8] c"tcp_sock\00", align 1
@.str.96 = private unnamed_addr constant [10 x i8] c"tp_buffer\00", align 1
@.str.97 = private unnamed_addr constant [9 x i8] c"xdp_sock\00", align 1
@.str.98 = private unnamed_addr constant [5 x i8] c"ptr_\00", align 1
@.str.99 = private unnamed_addr constant [4 x i8] c"mem\00", align 1
@.str.100 = private unnamed_addr constant [4 x i8] c"buf\00", align 1
@.str.101 = private unnamed_addr constant [5 x i8] c"func\00", align 1
@.str.102 = private unnamed_addr constant [11 x i8] c"dynptr_ptr\00", align 1
@.str.103 = private unnamed_addr constant [9 x i8] c"or_null_\00", align 1
@.str.104 = private unnamed_addr constant [9 x i8] c"_or_null\00", align 1
@.str.105 = private unnamed_addr constant [8 x i8] c"rdonly_\00", align 1
@.str.106 = private unnamed_addr constant [7 x i8] c"alloc_\00", align 1
@.str.107 = private unnamed_addr constant [6 x i8] c"user_\00", align 1
@.str.108 = private unnamed_addr constant [8 x i8] c"percpu_\00", align 1
@.str.109 = private unnamed_addr constant [11 x i8] c"untrusted_\00", align 1
@.str.110 = private unnamed_addr constant [7 x i8] c"%s%s%s\00", align 1
@.str.111 = private unnamed_addr constant [46 x i8] c"negative offset %s ptr R%d off=%d disallowed\0A\00", align 1
@.str.112 = private unnamed_addr constant [54 x i8] c"dereference of modified %s ptr R%d off=%d disallowed\0A\00", align 1
@.str.113 = private unnamed_addr constant [42 x i8] c"variable %s access var_off=%s disallowed\0A\00", align 1
@.str.114 = private unnamed_addr constant [26 x i8] c"R%d cannot write into %s\0A\00", align 1
@.str.115 = private unnamed_addr constant [13 x i8] c"R%d type=%s \00", align 1
@.str.116 = private unnamed_addr constant [13 x i8] c"expected=%s\0A\00", align 1
@.str.117 = private unnamed_addr constant [84 x i8] c"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\0A\00", align 1
@.str.118 = private unnamed_addr constant [37 x i8] c"R%d offset is outside of the packet\0A\00", align 1
@.str.119 = private unnamed_addr constant [55 x i8] c"invalid access to map key, key_size=%d off=%d size=%d\0A\00", align 1
@.str.120 = private unnamed_addr constant [59 x i8] c"invalid access to map value, value_size=%d off=%d size=%d\0A\00", align 1
@.str.121 = private unnamed_addr constant [66 x i8] c"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\0A\00", align 1
@.str.122 = private unnamed_addr constant [54 x i8] c"invalid access to memory, mem_size=%u off=%d size=%d\0A\00", align 1
@.str.123 = private unnamed_addr constant [54 x i8] c"R%d min value is outside of the allowed memory range\0A\00", align 1
@.str.124 = private unnamed_addr constant [72 x i8] c"R%d unbounded memory access, make sure to bounds check any such access\0A\00", align 1
@.str.125 = private unnamed_addr constant [54 x i8] c"R%d max value is outside of the allowed memory range\0A\00", align 1
@.str.126 = private unnamed_addr constant [56 x i8] c"write into map forbidden, value_size=%d off=%d size=%d\0A\00", align 1
@.str.127 = private unnamed_addr constant [55 x i8] c"read from map forbidden, value_size=%d off=%d size=%d\0A\00", align 1
@.str.128 = private unnamed_addr constant [57 x i8] c"bpf_spin_lock cannot be accessed directly by load/store\0A\00", align 1
@.str.129 = private unnamed_addr constant [53 x i8] c"bpf_timer cannot be accessed directly by load/store\0A\00", align 1
@.str.130 = private unnamed_addr constant [46 x i8] c"kptr cannot be accessed indirectly by helper\0A\00", align 1
@.str.131 = private unnamed_addr constant [41 x i8] c"kptr access cannot have variable offset\0A\00", align 1
@.str.132 = private unnamed_addr constant [45 x i8] c"kptr access misaligned expected=%u off=%llu\0A\00", align 1
@.str.133 = private unnamed_addr constant [33 x i8] c"kptr access size must be BPF_DW\0A\00", align 1
@.str.134 = private unnamed_addr constant [7 x i8] c"rdonly\00", align 1
@.str.135 = private unnamed_addr constant [5 x i8] c"rdwr\00", align 1
@.str.136 = private unnamed_addr constant [47 x i8] c"R%d invalid %s buffer access: off=%d, size=%d\0A\00", align 1
@.str.137 = private unnamed_addr constant [56 x i8] c"R%d invalid variable buffer offset: off=%d, var_off=%s\0A\00", align 1
@.str.138 = private unnamed_addr constant [10 x i8] c" indirect\00", align 1
@.str.139 = private unnamed_addr constant [25 x i8] c"invalid zero-sized read\0A\00", align 1
@.str.140 = private unnamed_addr constant [69 x i8] c"R%d%s variable offset stack access prohibited for !root, var_off=%s\0A\00", align 1
@.str.141 = private unnamed_addr constant [49 x i8] c"invalid%s read from stack R%d off %d+%d size %d\0A\00", align 1
@.str.142 = private unnamed_addr constant [53 x i8] c"invalid%s read from stack R%d var_off %s+%d size %d\0A\00", align 1
@.str.143 = private unnamed_addr constant [20 x i8] c" indirect access to\00", align 1
@.str.144 = private unnamed_addr constant [11 x i8] c" read from\00", align 1
@.str.145 = private unnamed_addr constant [10 x i8] c" write to\00", align 1
@.str.146 = private unnamed_addr constant [47 x i8] c"invalid unbounded variable-offset%s stack R%d\0A\00", align 1
@.str.147 = private unnamed_addr constant [36 x i8] c"invalid%s stack R%d off=%d size=%d\0A\00", align 1
@.str.148 = private unnamed_addr constant [56 x i8] c"invalid variable-offset%s stack R%d var_off=%s size=%d\0A\00", align 1
@tnum_unknown = external dso_local constant %struct.tnum, align 8
@.str.149 = private unnamed_addr constant [42 x i8] c"verifier BUG type %s var_off %lld off %d\0A\00", align 1
@.str.150 = private unnamed_addr constant [37 x i8] c"write to change key R%d not allowed\0A\00", align 1
@.str.151 = private unnamed_addr constant [25 x i8] c"R%d leaks addr into map\0A\00", align 1
@.str.152 = private unnamed_addr constant [29 x i8] c"R%d invalid mem access '%s'\0A\00", align 1
@.str.153 = private unnamed_addr constant [25 x i8] c"R%d leaks addr into mem\0A\00", align 1
@.str.154 = private unnamed_addr constant [25 x i8] c"R%d leaks addr into ctx\0A\00", align 1
@.str.155 = private unnamed_addr constant [3 x i8] c"; \00", align 1
@.str.156 = private unnamed_addr constant [26 x i8] c"cannot write into packet\0A\00", align 1
@.str.157 = private unnamed_addr constant [28 x i8] c"R%d leaks addr into packet\0A\00", align 1
@.str.158 = private unnamed_addr constant [31 x i8] c"R%d leaks addr into flow keys\0A\00", align 1
@.str.159 = private unnamed_addr constant [11 x i8] c"flow keys \00", align 1
@.str.160 = private unnamed_addr constant [5 x i8] c"key \00", align 1
@.str.161 = private unnamed_addr constant [7 x i8] c"value \00", align 1
@.str.162 = private unnamed_addr constant [9 x i8] c"context \00", align 1
@.str.163 = private unnamed_addr constant [7 x i8] c"stack \00", align 1
@.str.164 = private unnamed_addr constant [6 x i8] c"sock \00", align 1
@.str.165 = private unnamed_addr constant [13 x i8] c"sock_common \00", align 1
@.str.166 = private unnamed_addr constant [10 x i8] c"tcp_sock \00", align 1
@.str.167 = private unnamed_addr constant [10 x i8] c"xdp_sock \00", align 1
@.str.168 = private unnamed_addr constant [50 x i8] c"misaligned packet access off %d+%s+%d+%d size %d\0A\00", align 1
@.str.169 = private unnamed_addr constant [42 x i8] c"misaligned %saccess off %s+%d+%d size %d\0A\00", align 1
@.str.170 = private unnamed_addr constant [28 x i8] c"mark_reg_unknown(regs, %u)\0A\00", align 1
@.str.171 = private unnamed_addr constant [65 x i8] c"kptr in map can only be accessed using BPF_MEM instruction mode\0A\00", align 1
@.str.172 = private unnamed_addr constant [37 x i8] c"store to referenced kptr disallowed\0A\00", align 1
@.str.173 = private unnamed_addr constant [53 x i8] c"BPF_ST imm must be 0 when storing to kptr at off=%u\0A\00", align 1
@.str.174 = private unnamed_addr constant [63 x i8] c"kptr in map can only be accessed using BPF_LDX/BPF_STX/BPF_ST\0A\00", align 1
@.str.175 = private unnamed_addr constant [30 x i8] c"R%d must point to kernel BTF\0A\00", align 1
@.str.176 = private unnamed_addr constant [36 x i8] c"invalid kptr access, R%d type=%s%s \00", align 1
@.str.177 = private unnamed_addr constant [14 x i8] c"expected=%s%s\00", align 1
@.str.178 = private unnamed_addr constant [10 x i8] c" or %s%s\0A\00", align 1
@.str.179 = private unnamed_addr constant [43 x i8] c"invalid bpf_context access off=%d size=%d\0A\00", align 1
@.str.180 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@_ctype = external dso_local constant [0 x i8], align 1
@.str.181 = private unnamed_addr constant [31 x i8] c"mark_reg_known_zero(regs, %u)\0A\00", align 1
@.str.182 = private unnamed_addr constant [96 x i8] c"variable offset stack pointer cannot be passed into helper function; var_off=%s off=%d size=%d\0A\00", align 1
@.str.183 = private unnamed_addr constant [67 x i8] c"R%d variable offset stack access prohibited for !root, var_off=%s\0A\00", align 1
@.str.184 = private unnamed_addr constant [31 x i8] c"invalid size of register fill\0A\00", align 1
@.str.185 = private unnamed_addr constant [43 x i8] c"invalid read from stack off %d+%d size %d\0A\00", align 1
@.str.186 = private unnamed_addr constant [35 x i8] c"leaking pointer from stack off %d\0A\00", align 1
@.str.187 = private unnamed_addr constant [45 x i8] c"attempt to corrupt spilled pointer on stack\0A\00", align 1
@.str.188 = private unnamed_addr constant [32 x i8] c"invalid size of register spill\0A\00", align 1
@.str.189 = private unnamed_addr constant [63 x i8] c"cannot spill pointers to stack into stack frame of the caller\0A\00", align 1
@.str.190 = private unnamed_addr constant [69 x i8] c"spilled ptr in range of var-offset stack write; insn %d, ptr off: %d\00", align 1
@.str.191 = private unnamed_addr constant [81 x i8] c"uninit stack in range of var-offset write prohibited for !root; insn %d, off: %d\00", align 1
@.str.192 = private unnamed_addr constant [44 x i8] c"invalid access to flow keys off=%d size=%d\0A\00", align 1
@.str.193 = private unnamed_addr constant [38 x i8] c"R%d invalid %s access off=%d size=%d\0A\00", align 1
@.str.194 = private unnamed_addr constant [11 x i8] c"tracepoint\00", align 1
@.str.195 = private unnamed_addr constant [47 x i8] c"R%d is ptr_%s invalid negative access: off=%d\0A\00", align 1
@.str.196 = private unnamed_addr constant [59 x i8] c"R%d is ptr_%s invalid variable offset: off=%d, var_off=%s\0A\00", align 1
@.str.197 = private unnamed_addr constant [42 x i8] c"R%d is ptr_%s access user memory: off=%d\0A\00", align 1
@.str.198 = private unnamed_addr constant [44 x i8] c"R%d is ptr_%s access percpu memory: off=%d\0A\00", align 1
@.str.199 = private unnamed_addr constant [24 x i8] c"only read is supported\0A\00", align 1
@.str.200 = private unnamed_addr constant [60 x i8] c"map_ptr access not supported without CONFIG_DEBUG_INFO_BTF\0A\00", align 1
@.str.201 = private unnamed_addr constant [46 x i8] c"map_ptr access not supported for map type %d\0A\00", align 1
@.str.202 = private unnamed_addr constant [60 x i8] c"%s access is allowed only to CAP_PERFMON and CAP_SYS_ADMIN\0A\00", align 1
@.str.203 = private unnamed_addr constant [43 x i8] c"R%d is %s invalid negative access: off=%d\0A\00", align 1
@.str.204 = private unnamed_addr constant [32 x i8] c"only read from %s is supported\0A\00", align 1
@.str.205 = private unnamed_addr constant [66 x i8] c"R%d min value is negative, either use unsigned or 'var &= const'\0A\00", align 1
@.str.206 = private unnamed_addr constant [71 x i8] c"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\0A\00", align 1
@sanitize_err.err = internal global i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.207, i32 0, i32 0), align 8
@.str.207 = private unnamed_addr constant [48 x i8] c"pointer arithmetic with it prohibited for !root\00", align 1
@.str.208 = private unnamed_addr constant [4 x i8] c"add\00", align 1
@.str.209 = private unnamed_addr constant [4 x i8] c"sub\00", align 1
@.str.210 = private unnamed_addr constant [53 x i8] c"R%d has unknown scalar with mixed signed bounds, %s\0A\00", align 1
@.str.211 = private unnamed_addr constant [52 x i8] c"R%d has pointer with unsupported alu operation, %s\0A\00", align 1
@.str.212 = private unnamed_addr constant [59 x i8] c"R%d tried to %s from different maps, paths or scalars, %s\0A\00", align 1
@.str.213 = private unnamed_addr constant [43 x i8] c"R%d tried to %s beyond pointer bounds, %s\0A\00", align 1
@.str.214 = private unnamed_addr constant [58 x i8] c"R%d could not be pushed for speculative verification, %s\0A\00", align 1
@.str.215 = private unnamed_addr constant [46 x i8] c"verifier internal error: unknown reason (%d)\0A\00", align 1
@flip_opcode.opcode_flip = internal constant [16 x i8] c"\00\10\A0\B0@P\C0\D0\00\00 0`p\00\00", align 16
@btf_non_sleepable_error_inject = internal global %struct.btf_id_set zeroinitializer, align 4
@.str.216 = private unnamed_addr constant [10 x i8] c"security_\00", align 1
@kmalloc_caches = external dso_local global [3 x [14 x %struct.kmem_cache*]], align 16
@.str.217 = private unnamed_addr constant [21 x i8] c"include/linux/slab.h\00", align 1
@sk_filter_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@kprobe_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@tc_cls_act_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@tracepoint_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@xdp_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@perf_event_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_in_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_out_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_xmit_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sock_ops_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_skb_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_msg_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@raw_tracepoint_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_seg6local_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_reuseport_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@flow_dissector_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@raw_tracepoint_writable_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@tracing_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_lookup_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@bpf_syscall_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@.str.218 = private unnamed_addr constant [89 x i8] c"loading/calling other bpf or kernel functions are allowed for CAP_BPF and CAP_SYS_ADMIN\0A\00", align 1
@.str.219 = private unnamed_addr constant [13 x i8] c"func#%d @%d\0A\00", align 1
@.str.220 = private unnamed_addr constant [29 x i8] c"call to invalid destination\0A\00", align 1
@.str.221 = private unnamed_addr constant [22 x i8] c"too many subprograms\0A\00", align 1
@.str.222 = private unnamed_addr constant [72 x i8] c"calling kernel function is not supported without CONFIG_DEBUG_INFO_BTF\0A\00", align 1
@.str.223 = private unnamed_addr constant [45 x i8] c"JIT is required for calling kernel function\0A\00", align 1
@.str.224 = private unnamed_addr constant [46 x i8] c"JIT does not support calling kernel function\0A\00", align 1
@.str.225 = private unnamed_addr constant [61 x i8] c"cannot call kernel function from non-GPL compatible program\0A\00", align 1
@.str.226 = private unnamed_addr constant [40 x i8] c"failed to find BTF for kernel function\0A\00", align 1
@.str.227 = private unnamed_addr constant [42 x i8] c"too many different kernel function calls\0A\00", align 1
@.str.228 = private unnamed_addr constant [36 x i8] c"kernel btf_id %u is not a function\0A\00", align 1
@.str.229 = private unnamed_addr constant [60 x i8] c"kernel function btf_id %u does not have a valid func_proto\0A\00", align 1
@.str.230 = private unnamed_addr constant [44 x i8] c"cannot find address for kernel function %s\0A\00", align 1
@.str.231 = private unnamed_addr constant [47 x i8] c"address of kernel function %s is out of range\0A\00", align 1
@.str.232 = private unnamed_addr constant [38 x i8] c"jump out of range from insn %d to %d\0A\00", align 1
@.str.233 = private unnamed_addr constant [33 x i8] c"last insn is not an exit or jmp\0A\00", align 1
@.str.234 = private unnamed_addr constant [47 x i8] c"LD_ABS is not allowed in subprogs without BTF\0A\00", align 1
@.str.235 = private unnamed_addr constant [50 x i8] c"tail_call is not allowed in subprogs without BTF\0A\00", align 1
@.str.236 = private unnamed_addr constant [63 x i8] c"number of funcs in func_info doesn't match number of subprogs\0A\00", align 1
@.str.237 = private unnamed_addr constant [31 x i8] c"invalid func info rec size %u\0A\00", align 1
@.str.238 = private unnamed_addr constant [36 x i8] c"nonzero tailing record in func info\00", align 1
@.str.239 = private unnamed_addr constant [51 x i8] c"nonzero insn_off %u for the first func info record\00", align 1
@.str.240 = private unnamed_addr constant [69 x i8] c"same or smaller insn offset (%u) than previous func info record (%u)\00", align 1
@.str.241 = private unnamed_addr constant [67 x i8] c"func_info BTF section doesn't match subprog layout in BPF program\0A\00", align 1
@.str.242 = private unnamed_addr constant [32 x i8] c"invalid type id %d in func info\00", align 1
@.str.243 = private unnamed_addr constant [56 x i8] c"LD_ABS is only allowed in functions that return 'int'.\0A\00", align 1
@.str.244 = private unnamed_addr constant [59 x i8] c"tail_call is only allowed in functions that return 'int'.\0A\00", align 1
@.str.245 = private unnamed_addr constant [36 x i8] c"nonzero tailing record in line_info\00", align 1
@.str.246 = private unnamed_addr constant [65 x i8] c"Invalid line_info[%u].insn_off:%u (prev_offset:%u prog->len:%u)\0A\00", align 1
@.str.247 = private unnamed_addr constant [45 x i8] c"Invalid insn code at line_info[%u].insn_off\0A\00", align 1
@.str.248 = private unnamed_addr constant [50 x i8] c"Invalid line_info[%u].line_off or .file_name_off\0A\00", align 1
@.str.249 = private unnamed_addr constant [35 x i8] c"missing bpf_line_info for func#%u\0A\00", align 1
@.str.250 = private unnamed_addr constant [58 x i8] c"missing bpf_line_info for %u funcs starting from func#%u\0A\00", align 1
@.str.251 = private unnamed_addr constant [36 x i8] c"nonzero tailing record in core_relo\00", align 1
@.str.252 = private unnamed_addr constant [48 x i8] c"Invalid core_relo[%u].insn_off:%u prog->len:%u\0A\00", align 1
@.str.253 = private unnamed_addr constant [40 x i8] c"Syscall programs can only be sleepable\0A\00", align 1
@.str.254 = private unnamed_addr constant [78 x i8] c"Only fentry/fexit/fmod_ret, lsm, and kprobe/uprobe programs can be sleepable\0A\00", align 1
@btf_id_deny = internal global %struct.btf_id_set zeroinitializer, align 4
@.str.255 = private unnamed_addr constant [56 x i8] c"struct ops programs must have a GPL compatible license\0A\00", align 1
@.str.256 = private unnamed_addr constant [44 x i8] c"attach_btf_id %u is not a supported struct\0A\00", align 1
@.str.257 = private unnamed_addr constant [46 x i8] c"attach to invalid member idx %u of struct %s\0A\00", align 1
@.str.258 = private unnamed_addr constant [51 x i8] c"attach to invalid member %s(@idx %u) of struct %s\0A\00", align 1
@.str.259 = private unnamed_addr constant [46 x i8] c"attach to unsupported member %s of struct %s\0A\00", align 1
@.str.260 = private unnamed_addr constant [30 x i8] c"BPF_LDX uses reserved fields\0A\00", align 1
@.str.261 = private unnamed_addr constant [27 x i8] c"invalid bpf_ld_imm64 insn\0A\00", align 1
@.str.262 = private unnamed_addr constant [32 x i8] c"unrecognized bpf_ld_imm64 insn\0A\00", align 1
@.str.263 = private unnamed_addr constant [36 x i8] c"fd_idx without fd_array is invalid\0A\00", align 1
@.str.264 = private unnamed_addr constant [40 x i8] c"fd %d is not pointing to valid bpf_map\0A\00", align 1
@.str.265 = private unnamed_addr constant [42 x i8] c"direct value offset of %u is not allowed\0A\00", align 1
@.str.266 = private unnamed_addr constant [50 x i8] c"no direct value access support for this map type\0A\00", align 1
@.str.267 = private unnamed_addr constant [59 x i8] c"invalid access to map value pointer, value_size=%u off=%u\0A\00", align 1
@.str.268 = private unnamed_addr constant [49 x i8] c"only one cgroup storage of each type is allowed\0A\00", align 1
@.str.269 = private unnamed_addr constant [21 x i8] c"unknown opcode %02x\0A\00", align 1
@.str.270 = private unnamed_addr constant [41 x i8] c"invalid module BTF object FD specified.\0A\00", align 1
@.str.271 = private unnamed_addr constant [83 x i8] c"kernel is missing BTF, make sure CONFIG_DEBUG_INFO_BTF=y is specified in Kconfig.\0A\00", align 1
@.str.272 = private unnamed_addr constant [43 x i8] c"ldimm64 insn specifies invalid btf_id %d.\0A\00", align 1
@.str.273 = private unnamed_addr constant [45 x i8] c"pseudo btf_id %d in ldimm64 isn't KIND_VAR.\0A\00", align 1
@.str.274 = private unnamed_addr constant [60 x i8] c"ldimm64 failed to find the address for kernel symbol '%s'.\0A\00", align 1
@.str.275 = private unnamed_addr constant [54 x i8] c"ldimm64 unable to resolve the size of type '%s': %ld\0A\00", align 1
@.str.276 = private unnamed_addr constant [14 x i8] c".data..percpu\00", align 1
@.str.277 = private unnamed_addr constant [50 x i8] c"socket filter progs cannot use bpf_spin_lock yet\0A\00", align 1
@.str.278 = private unnamed_addr constant [44 x i8] c"tracing progs cannot use bpf_spin_lock yet\0A\00", align 1
@.str.279 = private unnamed_addr constant [46 x i8] c"sleepable progs cannot use bpf_spin_lock yet\0A\00", align 1
@.str.280 = private unnamed_addr constant [40 x i8] c"tracing progs cannot use bpf_timer yet\0A\00", align 1
@.str.281 = private unnamed_addr constant [46 x i8] c"offload device mismatch between prog and map\0A\00", align 1
@.str.282 = private unnamed_addr constant [43 x i8] c"bpf_struct_ops map cannot be used in prog\0A\00", align 1
@.str.283 = private unnamed_addr constant [63 x i8] c"Sleepable programs can only use array, hash, and ringbuf maps\0A\00", align 1
@bpf_map_offload_ops = external dso_local constant %struct.bpf_map_ops, align 8
@.str.284 = private unnamed_addr constant [25 x i8] c"visit_insn internal bug\0A\00", align 1
@.str.285 = private unnamed_addr constant [24 x i8] c"pop stack internal bug\0A\00", align 1
@.str.286 = private unnamed_addr constant [21 x i8] c"unreachable insn %d\0A\00", align 1
@.str.287 = private unnamed_addr constant [30 x i8] c"back-edge from insn %d to %d\0A\00", align 1
@.str.288 = private unnamed_addr constant [25 x i8] c"insn state internal bug\0A\00", align 1
@.str.289 = private unnamed_addr constant [55 x i8] c"Func#%d is safe for any args that match its prototype\0A\00", align 1
@.str.290 = private unnamed_addr constant [29 x i8] c"mark_reg_not_init(regs, %u)\0A\00", align 1
@.str.291 = private unnamed_addr constant [33 x i8] c"invalid insn idx %d insn_cnt %d\0A\00", align 1
@.str.292 = private unnamed_addr constant [45 x i8] c"BPF program is too large. Processed %d insn\0A\00", align 1
@.str.293 = private unnamed_addr constant [24 x i8] c"\0Afrom %d to %d%s: safe\0A\00", align 1
@.str.294 = private unnamed_addr constant [25 x i8] c" (speculative execution)\00", align 1
@.str.295 = private unnamed_addr constant [10 x i8] c"%d: safe\0A\00", align 1
@.str.296 = private unnamed_addr constant [18 x i8] c"\0Afrom %d to %d%s:\00", align 1
@.str.297 = private unnamed_addr constant [50 x i8] c"same insn cannot be used with different pointers\0A\00", align 1
@.str.298 = private unnamed_addr constant [30 x i8] c"BPF_STX uses reserved fields\0A\00", align 1
@.str.299 = private unnamed_addr constant [29 x i8] c"BPF_ST uses reserved fields\0A\00", align 1
@.str.300 = private unnamed_addr constant [42 x i8] c"BPF_ST stores into R%d %s is not allowed\0A\00", align 1
@.str.301 = private unnamed_addr constant [31 x i8] c"BPF_CALL uses reserved fields\0A\00", align 1
@.str.302 = private unnamed_addr constant [53 x i8] c"function calls are not allowed while holding a lock\0A\00", align 1
@.str.303 = private unnamed_addr constant [29 x i8] c"BPF_JA uses reserved fields\0A\00", align 1
@.str.304 = private unnamed_addr constant [31 x i8] c"BPF_EXIT uses reserved fields\0A\00", align 1
@.str.305 = private unnamed_addr constant [28 x i8] c"bpf_spin_unlock is missing\0A\00", align 1
@.str.306 = private unnamed_addr constant [21 x i8] c"invalid BPF_LD mode\0A\00", align 1
@.str.307 = private unnamed_addr constant [23 x i8] c"unknown insn class %d\0A\00", align 1
@.str.308 = private unnamed_addr constant [35 x i8] c"infinite loop detected at insn %d\0A\00", align 1
@is_state_visited.__already_done = internal global i8 0, section ".data.once", align 1
@.str.309 = private unnamed_addr constant [42 x i8] c"BUG live_done but branches_to_explore %d\0A\00", align 1
@is_state_visited.__already_done.310 = internal global i8 0, section ".data.once", align 1
@.str.311 = private unnamed_addr constant [53 x i8] c"BUG is_state_visited:branches_to_explore=%d insn %d\0A\00", align 1
@.str.312 = private unnamed_addr constant [50 x i8] c"propagate_live: parent frame %d current frame %d\0A\00", align 1
@.str.313 = private unnamed_addr constant [17 x i8] c"propagating r%d\0A\00", align 1
@.str.314 = private unnamed_addr constant [18 x i8] c"propagating fp%d\0A\00", align 1
@current_task = external dso_local global %struct.task_struct*, section ".data..percpu", align 8
@_cond_resched.__UNIQUE_ID___addressable___SCK__cond_resched159 = internal global i8* bitcast (%struct.static_call_key* @__SCK__cond_resched to i8*), section ".discard.addressable", align 8
@__SCK__cond_resched = external dso_local global %struct.static_call_key, align 8
@.str.315 = private unnamed_addr constant [5 x i8] c"%*c;\00", align 1
@.str.316 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.317 = private unnamed_addr constant [30 x i8] c"BPF_NEG uses reserved fields\0A\00", align 1
@.str.318 = private unnamed_addr constant [30 x i8] c"BPF_END uses reserved fields\0A\00", align 1
@.str.319 = private unnamed_addr constant [35 x i8] c"R%d pointer arithmetic prohibited\0A\00", align 1
@.str.320 = private unnamed_addr constant [30 x i8] c"BPF_MOV uses reserved fields\0A\00", align 1
@.str.321 = private unnamed_addr constant [29 x i8] c"R%d partial copy of pointer\0A\00", align 1
@.str.322 = private unnamed_addr constant [27 x i8] c"invalid BPF_ALU opcode %x\0A\00", align 1
@.str.323 = private unnamed_addr constant [30 x i8] c"BPF_ALU uses reserved fields\0A\00", align 1
@.str.324 = private unnamed_addr constant [13 x i8] c"div by zero\0A\00", align 1
@.str.325 = private unnamed_addr constant [18 x i8] c"invalid shift %d\0A\00", align 1
@.str.326 = private unnamed_addr constant [35 x i8] c"R%d pointer %s pointer prohibited\0A\00", align 1
@bpf_alu_string = external dso_local constant [16 x i8*], align 16
@.str.327 = private unnamed_addr constant [45 x i8] c"verifier internal error: unexpected ptr_reg\0A\00", align 1
@.str.328 = private unnamed_addr constant [37 x i8] c"verifier internal error: no src_reg\0A\00", align 1
@.str.329 = private unnamed_addr constant [42 x i8] c"R%d 32-bit pointer arithmetic prohibited\0A\00", align 1
@.str.330 = private unnamed_addr constant [62 x i8] c"R%d pointer arithmetic on %s prohibited, null-check it first\0A\00", align 1
@.str.331 = private unnamed_addr constant [41 x i8] c"R%d pointer arithmetic on %s prohibited\0A\00", align 1
@.str.332 = private unnamed_addr constant [43 x i8] c"R%d tried to subtract pointer from scalar\0A\00", align 1
@.str.333 = private unnamed_addr constant [47 x i8] c"R%d subtraction from stack pointer prohibited\0A\00", align 1
@.str.334 = private unnamed_addr constant [47 x i8] c"R%d bitwise operator %s on pointer prohibited\0A\00", align 1
@.str.335 = private unnamed_addr constant [52 x i8] c"R%d pointer arithmetic with %s operator prohibited\0A\00", align 1
@.str.336 = private unnamed_addr constant [49 x i8] c"math between %s pointer and %lld is not allowed\0A\00", align 1
@.str.337 = private unnamed_addr constant [37 x i8] c"%s pointer offset %d is not allowed\0A\00", align 1
@.str.338 = private unnamed_addr constant [78 x i8] c"math between %s pointer and register with unbounded min value is not allowed\0A\00", align 1
@.str.339 = private unnamed_addr constant [46 x i8] c"value %lld makes %s pointer be out of bounds\0A\00", align 1
@.str.340 = private unnamed_addr constant [42 x i8] c"The sequence of %d jumps is too complex.\0A\00", align 1
@.str.341 = private unnamed_addr constant [77 x i8] c"R%d pointer arithmetic of map value goes out of range, prohibited for !root\0A\00", align 1
@.str.342 = private unnamed_addr constant [67 x i8] c"R%d variable stack access prohibited for !root, var_off=%s off=%d\0A\00", align 1
@.str.343 = private unnamed_addr constant [78 x i8] c"R%d stack pointer arithmetic goes out of range, prohibited for !root; off=%d\0A\00", align 1
@.str.344 = private unnamed_addr constant [16 x i8] c"R%d is invalid\0A\00", align 1
@.str.345 = private unnamed_addr constant [14 x i8] c"R%d !read_ok\0A\00", align 1
@.str.346 = private unnamed_addr constant [28 x i8] c"frame pointer is read only\0A\00", align 1
@.str.347 = private unnamed_addr constant [44 x i8] c"BPF_ATOMIC uses invalid atomic opcode %02x\0A\00", align 1
@.str.348 = private unnamed_addr constant [29 x i8] c"invalid atomic operand size\0A\00", align 1
@.str.349 = private unnamed_addr constant [46 x i8] c"BPF_ATOMIC stores into R%d %s is not allowed\0A\00", align 1
@.str.350 = private unnamed_addr constant [44 x i8] c"verifier bug. No program starts at insn %d\0A\00", align 1
@.str.351 = private unnamed_addr constant [41 x i8] c"the call stack of %d frames is too deep\0A\00", align 1
@.str.352 = private unnamed_addr constant [42 x i8] c"verifier bug. Frame %d already allocated\0A\00", align 1
@.str.353 = private unnamed_addr constant [41 x i8] c"Caller passes invalid args into func#%d\0A\00", align 1
@.str.354 = private unnamed_addr constant [40 x i8] c"Func#%d is global and valid. Skipping.\0A\00", align 1
@.str.355 = private unnamed_addr constant [9 x i8] c"caller:\0A\00", align 1
@.str.356 = private unnamed_addr constant [9 x i8] c"callee:\0A\00", align 1
@caller_saved = internal constant [6 x i32] [i32 0, i32 1, i32 2, i32 3, i32 4, i32 5], align 16
@.str.357 = private unnamed_addr constant [55 x i8] c"The sequence of %d jumps is too complex for async cb.\0A\00", align 1
@.str.358 = private unnamed_addr constant [43 x i8] c"calling kernel function %s is not allowed\0A\00", align 1
@.str.359 = private unnamed_addr constant [59 x i8] c"destructive kfunc calls require CAP_SYS_BOOT capabilities\0A\00", align 1
@.str.360 = private unnamed_addr constant [52 x i8] c"kfunc %s#%d reference has not been acquired before\0A\00", align 1
@.str.361 = private unnamed_addr constant [55 x i8] c"acquire kernel function does not return PTR_TO_BTF_ID\0A\00", align 1
@.str.362 = private unnamed_addr constant [64 x i8] c"kernel function %s returns pointer type %s %s is not supported\0A\00", align 1
@.str.363 = private unnamed_addr constant [20 x i8] c"invalid func %s#%d\0A\00", align 1
@.str.364 = private unnamed_addr constant [20 x i8] c"unknown func %s#%d\0A\00", align 1
@.str.365 = private unnamed_addr constant [69 x i8] c"cannot call GPL-restricted function from non-GPL compatible program\0A\00", align 1
@.str.366 = private unnamed_addr constant [37 x i8] c"helper call is not allowed in probe\0A\00", align 1
@.str.367 = private unnamed_addr constant [54 x i8] c"kernel subsystem misconfigured func %s#%d: r1 != ctx\0A\00", align 1
@.str.368 = private unnamed_addr constant [43 x i8] c"kernel subsystem misconfigured func %s#%d\0A\00", align 1
@.str.369 = private unnamed_addr constant [51 x i8] c"func %s#%d reference has not been acquired before\0A\00", align 1
@.str.370 = private unnamed_addr constant [40 x i8] c"tail_call would lead to reference leak\0A\00", align 1
@.str.371 = private unnamed_addr constant [52 x i8] c"get_local_storage() doesn't support non-zero flags\0A\00", align 1
@.str.372 = private unnamed_addr constant [54 x i8] c"Unsupported reg type %s for bpf_dynptr_from_mem data\0A\00", align 1
@.str.373 = private unnamed_addr constant [73 x i8] c"BPF_LSM_CGROUP that attach to void LSM hooks can't modify return value!\0A\00", align 1
@.str.374 = private unnamed_addr constant [54 x i8] c"verifier internal error: meta.ref_obj_id already set\0A\00", align 1
@.str.375 = private unnamed_addr constant [57 x i8] c"verifier internal error: no dynptr in bpf_dynptr_data()\0A\00", align 1
@.str.376 = private unnamed_addr constant [41 x i8] c"kernel subsystem misconfigured verifier\0A\00", align 1
@.str.377 = private unnamed_addr constant [46 x i8] c"unable to resolve the size of type '%s': %ld\0A\00", align 1
@.str.378 = private unnamed_addr constant [25 x i8] c"verifier internal error:\00", align 1
@.str.379 = private unnamed_addr constant [56 x i8] c"func %s has non-overwritten BPF_PTR_POISON return type\0A\00", align 1
@.str.380 = private unnamed_addr constant [38 x i8] c"invalid return type %u of func %s#%d\0A\00", align 1
@.str.381 = private unnamed_addr constant [38 x i8] c"unknown return type %u of func %s#%d\0A\00", align 1
@.str.382 = private unnamed_addr constant [68 x i8] c"verifier internal error: func %s#%d sets ref_obj_id more than once\0A\00", align 1
@sysctl_perf_event_max_stack = external dso_local global i32, align 4
@.str.383 = private unnamed_addr constant [44 x i8] c"cannot get callchain buffer for func %s#%d\0A\00", align 1
@.str.384 = private unnamed_addr constant [37 x i8] c"R%d leaks addr into helper function\0A\00", align 1
@.str.385 = private unnamed_addr constant [44 x i8] c"helper access to the packet is not allowed\0A\00", align 1
@.str.386 = private unnamed_addr constant [35 x i8] c"arg %d is an unacquired reference\0A\00", align 1
@.str.387 = private unnamed_addr constant [56 x i8] c"R%d must be referenced when passed to release function\0A\00", align 1
@.str.388 = private unnamed_addr constant [57 x i8] c"verifier internal error: more than one release argument\0A\00", align 1
@.str.389 = private unnamed_addr constant [70 x i8] c"verifier internal error: more than one arg with ref_obj_id R%d %u %u\0A\00", align 1
@.str.390 = private unnamed_addr constant [75 x i8] c"timer pointer in R1 map_uid=%d doesn't match map pointer in R2 map_uid=%d\0A\00", align 1
@.str.391 = private unnamed_addr constant [36 x i8] c"invalid map_ptr to access map->key\0A\00", align 1
@.str.392 = private unnamed_addr constant [38 x i8] c"invalid map_ptr to access map->value\0A\00", align 1
@.str.393 = private unnamed_addr constant [34 x i8] c"Helper has invalid btf_id in R%d\0A\00", align 1
@.str.394 = private unnamed_addr constant [25 x i8] c"verifier internal error\0A\00", align 1
@.str.395 = private unnamed_addr constant [42 x i8] c"Dynptr has to be an uninitialized dynptr\0A\00", align 1
@.str.396 = private unnamed_addr constant [61 x i8] c"verifier internal error: multiple uninitialized dynptr args\0A\00", align 1
@.str.397 = private unnamed_addr constant [43 x i8] c"Expected an initialized dynptr as arg #%d\0A\00", align 1
@.str.398 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str.399 = private unnamed_addr constant [8 x i8] c"ringbuf\00", align 1
@.str.400 = private unnamed_addr constant [10 x i8] c"<unknown>\00", align 1
@.str.401 = private unnamed_addr constant [41 x i8] c"Expected a dynptr of type %s as arg #%d\0A\00", align 1
@.str.402 = private unnamed_addr constant [30 x i8] c"R%d is not a known constant'\0A\00", align 1
@.str.403 = private unnamed_addr constant [39 x i8] c"R%d does not point to a readonly map'\0A\00", align 1
@.str.404 = private unnamed_addr constant [32 x i8] c"R%d is not a constant address'\0A\00", align 1
@.str.405 = private unnamed_addr constant [38 x i8] c"direct value access on string failed\0A\00", align 1
@.str.406 = private unnamed_addr constant [31 x i8] c"string is not zero-terminated\0A\00", align 1
@.str.407 = private unnamed_addr constant [37 x i8] c"invalid map_ptr to access map->type\0A\00", align 1
@.str.408 = private unnamed_addr constant [39 x i8] c"invalid arg_type for sockmap/sockhash\0A\00", align 1
@compatible_reg_types = internal global [25 x %struct.bpf_reg_types*] [%struct.bpf_reg_types* null, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @const_map_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* @map_key_value_types, %struct.bpf_reg_types* @map_key_value_types, %struct.bpf_reg_types* @mem_types, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @scalar_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @scalar_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @context_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* null, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @spin_lock_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* @sock_types, %struct.bpf_reg_types* @int_ptr_types, %struct.bpf_reg_types* @int_ptr_types, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @fullsock_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @btf_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @alloc_mem_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @scalar_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* @btf_id_sock_common_types, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @percpu_btf_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @func_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @stack_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @const_str_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @timer_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @kptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, i32, [8 x i32] }>, i32* }* @dynptr_types to %struct.bpf_reg_types*)], align 16
@.str.409 = private unnamed_addr constant [50 x i8] c"verifier internal error: unsupported arg type %d\0A\00", align 1
@.str.410 = private unnamed_addr constant [22 x i8] c"R%d type=%s expected=\00", align 1
@.str.411 = private unnamed_addr constant [5 x i8] c"%s, \00", align 1
@.str.412 = private unnamed_addr constant [56 x i8] c"verifier internal error: missing arg compatible BTF ID\0A\00", align 1
@.str.413 = private unnamed_addr constant [45 x i8] c"R%d has non-overwritten BPF_PTR_POISON type\0A\00", align 1
@.str.414 = private unnamed_addr constant [38 x i8] c"R%d is of type %s but %s is expected\0A\00", align 1
@map_key_value_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 6, i32 8, i32 7, i32 5, i32 4, i32 0, i32 0, i32 0, i32 0, i32 0], i32* null }, align 8
@mem_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 6, i32 8, i32 7, i32 5, i32 4, i32 17, i32 1041, i32 18, i32 0, i32 0], i32* null }, align 8
@sock_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 12, i32 11, i32 13, i32 15, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0], i32* null }, align 8
@int_ptr_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 6, i32 8, i32 7, i32 5, i32 4, i32 0, i32 0, i32 0, i32 0, i32 0], i32* null }, align 8
@btf_id_sock_common_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 12, i32 11, i32 13, i32 15, i32 16, i32 0, i32 0, i32 0, i32 0, i32 0], i32* bitcast (i8* getelementptr (i8, i8* bitcast ([0 x i32]* @btf_sock_ids to i8*), i64 24) to i32*) }, align 8
@const_map_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 3, [9 x i32] zeroinitializer }>, i32* null }, align 8
@scalar_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 1, [9 x i32] zeroinitializer }>, i32* null }, align 8
@context_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 2, [9 x i32] zeroinitializer }>, i32* null }, align 8
@spin_lock_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 4, [9 x i32] zeroinitializer }>, i32* null }, align 8
@fullsock_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 11, [9 x i32] zeroinitializer }>, i32* null }, align 8
@btf_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 16, [9 x i32] zeroinitializer }>, i32* null }, align 8
@alloc_mem_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 1041, [9 x i32] zeroinitializer }>, i32* null }, align 8
@btf_sock_ids = external dso_local global [0 x i32], align 4
@percpu_btf_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 4112, [9 x i32] zeroinitializer }>, i32* null }, align 8
@func_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 19, [9 x i32] zeroinitializer }>, i32* null }, align 8
@stack_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 6, [9 x i32] zeroinitializer }>, i32* null }, align 8
@const_str_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 4, [9 x i32] zeroinitializer }>, i32* null }, align 8
@timer_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 4, [9 x i32] zeroinitializer }>, i32* null }, align 8
@kptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 4, [9 x i32] zeroinitializer }>, i32* null }, align 8
@dynptr_types = internal constant { <{ i32, i32, [8 x i32] }>, i32* } { <{ i32, i32, [8 x i32] }> <{ i32 6, i32 65556, [8 x i32] zeroinitializer }>, i32* null }, align 8
@.str.429 = private unnamed_addr constant [82 x i8] c"R%d doesn't have constant offset. bpf_spin_lock has to be at the constant offset\0A\00", align 1
@.str.430 = private unnamed_addr constant [56 x i8] c"map '%s' has to have BTF in order to use bpf_spin_lock\0A\00", align 1
@.str.431 = private unnamed_addr constant [51 x i8] c"map '%s' has more than one 'struct bpf_spin_lock'\0A\00", align 1
@.str.432 = private unnamed_addr constant [46 x i8] c"map '%s' doesn't have 'struct bpf_spin_lock'\0A\00", align 1
@.str.433 = private unnamed_addr constant [59 x i8] c"map '%s' is not a struct type or bpf_spin_lock is mangled\0A\00", align 1
@.str.434 = private unnamed_addr constant [50 x i8] c"off %lld doesn't point to 'struct bpf_spin_lock'\0A\00", align 1
@.str.435 = private unnamed_addr constant [44 x i8] c"Locking two bpf_spin_locks are not allowed\0A\00", align 1
@.str.436 = private unnamed_addr constant [39 x i8] c"bpf_spin_unlock without taking a lock\0A\00", align 1
@.str.437 = private unnamed_addr constant [35 x i8] c"bpf_spin_unlock of different lock\0A\00", align 1
@.str.438 = private unnamed_addr constant [78 x i8] c"R%d doesn't have constant offset. bpf_timer has to be at the constant offset\0A\00", align 1
@.str.439 = private unnamed_addr constant [52 x i8] c"map '%s' has to have BTF in order to use bpf_timer\0A\00", align 1
@.str.440 = private unnamed_addr constant [47 x i8] c"map '%s' has more than one 'struct bpf_timer'\0A\00", align 1
@.str.441 = private unnamed_addr constant [42 x i8] c"map '%s' doesn't have 'struct bpf_timer'\0A\00", align 1
@.str.442 = private unnamed_addr constant [55 x i8] c"map '%s' is not a struct type or bpf_timer is mangled\0A\00", align 1
@.str.443 = private unnamed_addr constant [60 x i8] c"off %lld doesn't point to 'struct bpf_timer' that is at %d\0A\00", align 1
@.str.444 = private unnamed_addr constant [50 x i8] c"verifier bug. Two map pointers in a timer helper\0A\00", align 1
@.str.445 = private unnamed_addr constant [73 x i8] c"R%d doesn't have constant offset. kptr has to be at the constant offset\0A\00", align 1
@.str.446 = private unnamed_addr constant [56 x i8] c"map '%s' has to have BTF in order to use bpf_kptr_xchg\0A\00", align 1
@.str.447 = private unnamed_addr constant [32 x i8] c"map '%s' has more than %d kptr\0A\00", align 1
@.str.448 = private unnamed_addr constant [38 x i8] c"map '%s' has repeating kptr BTF tags\0A\00", align 1
@.str.449 = private unnamed_addr constant [28 x i8] c"map '%s' has no valid kptr\0A\00", align 1
@.str.450 = private unnamed_addr constant [30 x i8] c"off=%d doesn't point to kptr\0A\00", align 1
@.str.451 = private unnamed_addr constant [35 x i8] c"off=%d kptr isn't referenced kptr\0A\00", align 1
@.str.452 = private unnamed_addr constant [26 x i8] c"write into map forbidden\0A\00", align 1
@.str.453 = private unnamed_addr constant [27 x i8] c"tail_call abusing map_ptr\0A\00", align 1
@.str.454 = private unnamed_addr constant [39 x i8] c"callback function not allowed for map\0A\00", align 1
@btf_tracing_ids = external dso_local global [0 x i32], align 4
@.str.455 = private unnamed_addr constant [14 x i8] c"verifier bug\0A\00", align 1
@.str.456 = private unnamed_addr constant [23 x i8] c"Invalid format string\0A\00", align 1
@.str.457 = private unnamed_addr constant [72 x i8] c"tail_calls are not allowed in non-JITed programs with bpf-to-bpf calls\0A\00", align 1
@.str.458 = private unnamed_addr constant [41 x i8] c"cannot pass map_type %d into func %s#%d\0A\00", align 1
@.str.459 = private unnamed_addr constant [39 x i8] c"cannot update sockmap in this context\0A\00", align 1
@.str.460 = private unnamed_addr constant [62 x i8] c"func %s#%d supported only for fentry/fexit/fmod_ret programs\0A\00", align 1
@.str.461 = private unnamed_addr constant [46 x i8] c"func %s#%d not supported for program type %d\0A\00", align 1
@.str.462 = private unnamed_addr constant [42 x i8] c"Unreleased reference id=%d alloc_insn=%d\0A\00", align 1
@.str.463 = private unnamed_addr constant [43 x i8] c"cannot return stack pointer to the caller\0A\00", align 1
@.str.464 = private unnamed_addr constant [23 x i8] c"R0 not a scalar value\0A\00", align 1
@.str.465 = private unnamed_addr constant [16 x i8] c"callback return\00", align 1
@.str.466 = private unnamed_addr constant [3 x i8] c"R0\00", align 1
@.str.467 = private unnamed_addr constant [24 x i8] c"returning from callee:\0A\00", align 1
@.str.468 = private unnamed_addr constant [18 x i8] c"to caller at %d:\0A\00", align 1
@.str.469 = private unnamed_addr constant [23 x i8] c"At %s the register %s \00", align 1
@.str.470 = private unnamed_addr constant [13 x i8] c"has value %s\00", align 1
@.str.471 = private unnamed_addr constant [25 x i8] c"has unknown scalar value\00", align 1
@.str.472 = private unnamed_addr constant [25 x i8] c" should have been in %s\0A\00", align 1
@.str.473 = private unnamed_addr constant [31 x i8] c"R0 leaks addr as return value\0A\00", align 1
@.str.474 = private unnamed_addr constant [61 x i8] c"In async callback the register R0 is not a known value (%s)\0A\00", align 1
@.str.475 = private unnamed_addr constant [15 x i8] c"async callback\00", align 1
@.str.476 = private unnamed_addr constant [63 x i8] c"At subprogram exit the register R0 is not a scalar value (%s)\0A\00", align 1
@.str.477 = private unnamed_addr constant [59 x i8] c"At program exit the register R0 is not a known value (%s)\0A\00", align 1
@.str.478 = private unnamed_addr constant [13 x i8] c"program exit\00", align 1
@.str.479 = private unnamed_addr constant [79 x i8] c"Note, BPF_LSM_CGROUP that attach to void LSM hooks can't modify return value!\0A\00", align 1
@update_branch_counts.__already_done = internal global i8 0, section ".data.once", align 1
@.str.480 = private unnamed_addr constant [49 x i8] c"BUG update_branch_counts:branches_to_explore=%d\0A\00", align 1
@.str.481 = private unnamed_addr constant [33 x i8] c"invalid BPF_JMP/JMP32 opcode %x\0A\00", align 1
@.str.482 = private unnamed_addr constant [36 x i8] c"BPF_JMP/JMP32 uses reserved fields\0A\00", align 1
@.str.483 = private unnamed_addr constant [35 x i8] c"R%d pointer comparison prohibited\0A\00", align 1
@check_ld_abs.ctx_reg = internal constant i32 6, align 4
@.str.484 = private unnamed_addr constant [65 x i8] c"BPF_LD_[ABS|IND] instructions not allowed for this program type\0A\00", align 1
@.str.485 = private unnamed_addr constant [31 x i8] c"bpf verifier is misconfigured\0A\00", align 1
@.str.486 = private unnamed_addr constant [39 x i8] c"BPF_LD_[ABS|IND] uses reserved fields\0A\00", align 1
@.str.487 = private unnamed_addr constant [57 x i8] c"BPF_LD_[ABS|IND] cannot be mixed with socket references\0A\00", align 1
@.str.488 = private unnamed_addr constant [64 x i8] c"BPF_LD_[ABS|IND] cannot be used inside bpf_spin_lock-ed region\0A\00", align 1
@.str.489 = private unnamed_addr constant [52 x i8] c"at the time of BPF_LD_ABS|IND R6 != pointer to skb\0A\00", align 1
@.str.490 = private unnamed_addr constant [25 x i8] c"invalid BPF_LD_IMM insn\0A\00", align 1
@.str.491 = private unnamed_addr constant [35 x i8] c"BPF_LD_IMM64 uses reserved fields\0A\00", align 1
@.str.492 = private unnamed_addr constant [23 x i8] c"missing btf func_info\0A\00", align 1
@.str.493 = private unnamed_addr constant [30 x i8] c"callback function not static\0A\00", align 1
@.str.494 = private unnamed_addr constant [86 x i8] c"tail_calls are not allowed when call stack of previous frames is %d bytes. Too large\0A\00", align 1
@.str.495 = private unnamed_addr constant [50 x i8] c"combined stack size of %d calls is %d. Too large\0A\00", align 1
@check_max_stack_depth.__already_done = internal global i8 0, section ".data.once", align 1
@.str.496 = private unnamed_addr constant [50 x i8] c"verifier bug. subprog has tail_call and async cb\0A\00", align 1
@.str.497 = private unnamed_addr constant [43 x i8] c"the call stack of %d frames is too deep !\0A\00", align 1
@.str.498 = private unnamed_addr constant [47 x i8] c"insn %d cannot be patched due to 16-bit range\0A\00", align 1
@__const.opt_hard_wire_dead_code_branches.ja = private unnamed_addr constant %struct.bpf_insn { i8 5, i8 0, i16 0, i32 0 }, align 4
@__const.opt_remove_nops.ja = private unnamed_addr constant %struct.bpf_insn { i8 5, i8 0, i16 0, i32 0 }, align 4
@__const.sanitize_dead_code.trap = private unnamed_addr constant %struct.bpf_insn { i8 5, i8 0, i16 -1, i32 0 }, align 4
@.str.499 = private unnamed_addr constant [46 x i8] c"bpf verifier narrow ctx access misconfigured\0A\00", align 1
@.str.500 = private unnamed_addr constant [44 x i8] c"bpf verifier narrow ctx load misconfigured\0A\00", align 1
@.str.501 = private unnamed_addr constant [41 x i8] c"adding tail call poke descriptor failed\0A\00", align 1
@jiffies = external dso_local global i64, section ".data..cacheline_aligned", align 64
@.str.502 = private unnamed_addr constant [32 x i8] c"tracking tail call prog failed\0A\00", align 1
@.str.503 = private unnamed_addr constant [62 x i8] c"invalid kernel function call not eliminated in verifier pass\0A\00", align 1
@.str.504 = private unnamed_addr constant [78 x i8] c"verifier internal error: kernel function descriptor not found for func_id %u\0A\00", align 1
@.str.505 = private unnamed_addr constant [54 x i8] c"verifier bug. zext_dst is set, but no reg is defined\0A\00", align 1
@.str.506 = private unnamed_addr constant [64 x i8] c"calling kernel functions are not allowed in non-JITed programs\0A\00", align 1
@.str.507 = private unnamed_addr constant [49 x i8] c"callbacks are not allowed in non-JITed programs\0A\00", align 1
@jit_subprogs.__already_done = internal global i8 0, section ".data.once", align 1
@.str.508 = private unnamed_addr constant [38 x i8] c"JIT doesn't support bpf-to-bpf calls\0A\00", align 1
@get_callee_stack_depth.__already_done = internal global i8 0, section ".data.once", align 1
@.str.509 = private unnamed_addr constant [29 x i8] c"verification time %lld usec\0A\00", align 1
@.str.510 = private unnamed_addr constant [13 x i8] c"stack depth \00", align 1
@.str.511 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.512 = private unnamed_addr constant [2 x i8] c"+\00", align 1
@.str.513 = private unnamed_addr constant [98 x i8] c"processed %d insns (limit %d) max_states_per_insn %d total_states %d peak_states %d mark_read %d\0A\00", align 1
@llvm.compiler.used = appending global [3 x i8*] [i8* bitcast (i8** @__UNIQUE_ID___addressable_bpf_verifier_log_write523 to i8*), i8* bitcast (i8** @__UNIQUE_ID___addressable_bpf_log524 to i8*), i8* bitcast (i8** @_cond_resched.__UNIQUE_ID___addressable___SCK__cond_resched159 to i8*)], section "llvm.metadata"

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log, i8* noundef %fmt, %struct.__va_list_tag* noundef %args) #0 {
entry:
  %retval.i = alloca i1, align 1
  %addr.addr.i = alloca i8*, align 8
  %bytes.addr.i = alloca i64, align 8
  %is_source.addr.i = alloca i8, align 1
  %sz.i = alloca i32, align 4
  %__ret_warn_on.i = alloca i32, align 4
  %__flags.i = alloca i32, align 4
  %tmp.i = alloca i64, align 8
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %fmt.addr = alloca i8*, align 8
  %args.addr = alloca %struct.__va_list_tag*, align 8
  %n = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_cond = alloca i8, align 1
  %__ret_once = alloca i8, align 1
  %tmp = alloca i64, align 8
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp40 = alloca i64, align 8
  %tmp48 = alloca i64, align 8
  %newline = alloca i8, align 1
  %tmp69 = alloca i32, align 4
  %__UNIQUE_ID___x521 = alloca i32, align 4
  %__UNIQUE_ID___y522 = alloca i32, align 4
  %tmp78 = alloca i32, align 4
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  store %struct.__va_list_tag* %args, %struct.__va_list_tag** %args.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %kbuf, i64 0, i64 0
  %1 = load i8*, i8** %fmt.addr, align 8
  %2 = load %struct.__va_list_tag*, %struct.__va_list_tag** %args.addr, align 8
  %call = call i32 @vscnprintf(i8* noundef %arraydecay, i64 noundef 1024, i8* noundef %1, %struct.__va_list_tag* noundef %2) #20
  store i32 %call, i32* %n, align 4
  %3 = load i32, i32* %n, align 4
  %cmp = icmp uge i32 %3, 1023
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %frombool = zext i1 %lnot1 to i8
  store i8 %frombool, i8* %__ret_do_once, align 1
  %4 = load i8, i8* %__ret_do_once, align 1
  %tobool = trunc i8 %4 to i1
  %lnot2 = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot2, true
  %frombool4 = zext i1 %lnot3 to i8
  store i8 %frombool4, i8* %__ret_cond, align 1
  store i8 0, i8* %__ret_once, align 1
  %5 = load i8, i8* %__ret_cond, align 1
  %tobool5 = trunc i8 %5 to i1
  br i1 %tobool5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %6 = load i8, i8* @bpf_verifier_vlog.__already_done, align 1
  %tobool6 = trunc i8 %6 to i1
  %lnot7 = xor i1 %tobool6, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %7 = phi i1 [ false, %entry ], [ %lnot7, %land.rhs ]
  %lnot8 = xor i1 %7, true
  %lnot9 = xor i1 %lnot8, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool10 = icmp ne i64 %conv, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  store i8 1, i8* @bpf_verifier_vlog.__already_done, align 1
  store i8 1, i8* %__ret_once, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.end
  %8 = load i8, i8* %__ret_once, align 1
  %tobool11 = trunc i8 %8 to i1
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  store i64 %conv16, i64* %tmp, align 8
  %9 = load i64, i64* %tmp, align 8
  %tobool17 = icmp ne i64 %9, 0
  br i1 %tobool17, label %if.then18, label %if.end47

if.then18:                                        ; preds = %if.end
  store i32 1, i32* %__ret_warn_on, align 4
  %10 = load i32, i32* %__ret_warn_on, align 4
  %tobool19 = icmp ne i32 %10, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %tobool25 = icmp ne i64 %conv24, 0
  br i1 %tobool25, label %if.then26, label %if.end39

if.then26:                                        ; preds = %if.then18
  br label %do.body

do.body:                                          ; preds = %if.then26
  br label %do.body27

do.body27:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body27
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str, i64 0, i64 0)) #20
  br label %do.body28

do.body28:                                        ; preds = %do.end
  store i32 2313, i32* %__flags, align 4
  br label %do.body29

do.body29:                                        ; preds = %do.body28
  br label %do.end30

do.end30:                                         ; preds = %do.body29
  br label %do.body31

do.body31:                                        ; preds = %do.end30
  %11 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 388, i32 %11, i64 12) #19, !srcloc !6
  br label %do.end32

do.end32:                                         ; preds = %do.body31
  br label %do.body33

do.body33:                                        ; preds = %do.end32
  br label %do.end34

do.end34:                                         ; preds = %do.body33
  br label %do.end35

do.end35:                                         ; preds = %do.end34
  br label %do.body36

do.body36:                                        ; preds = %do.end35
  br label %do.end37

do.end37:                                         ; preds = %do.body36
  br label %do.end38

do.end38:                                         ; preds = %do.end37
  br label %if.end39

if.end39:                                         ; preds = %do.end38, %if.then18
  %12 = load i32, i32* %__ret_warn_on, align 4
  %tobool41 = icmp ne i32 %12, 0
  %lnot42 = xor i1 %tobool41, true
  %lnot44 = xor i1 %lnot42, true
  %lnot.ext45 = zext i1 %lnot44 to i32
  %conv46 = sext i32 %lnot.ext45 to i64
  store i64 %conv46, i64* %tmp40, align 8
  %13 = load i64, i64* %tmp40, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.end39, %if.end
  %14 = load i8, i8* %__ret_do_once, align 1
  %tobool49 = trunc i8 %14 to i1
  %lnot50 = xor i1 %tobool49, true
  %lnot52 = xor i1 %lnot50, true
  %lnot.ext53 = zext i1 %lnot52 to i32
  %conv54 = sext i32 %lnot.ext53 to i64
  store i64 %conv54, i64* %tmp48, align 8
  %15 = load i64, i64* %tmp48, align 8
  %16 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %16, i32 0, i32 0
  %17 = load i32, i32* %level, align 8
  %cmp55 = icmp eq i32 %17, 8
  br i1 %cmp55, label %if.then57, label %if.end75

if.then57:                                        ; preds = %if.end47
  %18 = load i32, i32* %n, align 4
  %cmp58 = icmp ugt i32 %18, 0
  br i1 %cmp58, label %land.rhs60, label %land.end65

land.rhs60:                                       ; preds = %if.then57
  %19 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf61 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %19, i32 0, i32 1
  %20 = load i32, i32* %n, align 4
  %sub = sub i32 %20, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr [1024 x i8], [1024 x i8]* %kbuf61, i64 0, i64 %idxprom
  %21 = load i8, i8* %arrayidx, align 1
  %conv62 = sext i8 %21 to i32
  %cmp63 = icmp eq i32 %conv62, 10
  br label %land.end65

land.end65:                                       ; preds = %land.rhs60, %if.then57
  %22 = phi i1 [ false, %if.then57 ], [ %cmp63, %land.rhs60 ]
  %frombool66 = zext i1 %22 to i8
  store i8 %frombool66, i8* %newline, align 1
  br label %do.body67

do.body67:                                        ; preds = %land.end65
  br label %do.end68

do.end68:                                         ; preds = %do.body67
  %23 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf70 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %23, i32 0, i32 1
  %arraydecay71 = getelementptr inbounds [1024 x i8], [1024 x i8]* %kbuf70, i64 0, i64 0
  %24 = load i8, i8* %newline, align 1
  %tobool72 = trunc i8 %24 to i1
  %25 = zext i1 %tobool72 to i64
  %cond = select i1 %tobool72, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i64 0, i64 0)
  %call74 = call i32 (i8*, ...) @_printk(i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.2, i64 0, i64 0), i8* noundef %arraydecay71, i8* noundef %cond) #21
  store i32 %call74, i32* %tmp69, align 4
  %26 = load i32, i32* %tmp69, align 4
  br label %if.end95

if.end75:                                         ; preds = %if.end47
  %27 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %27, i32 0, i32 4
  %28 = load i32, i32* %len_total, align 4
  %29 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %29, i32 0, i32 3
  %30 = load i32, i32* %len_used, align 8
  %sub76 = sub i32 %28, %30
  %sub77 = sub i32 %sub76, 1
  store i32 %sub77, i32* %__UNIQUE_ID___x521, align 4
  %31 = load i32, i32* %n, align 4
  store i32 %31, i32* %__UNIQUE_ID___y522, align 4
  %32 = load i32, i32* %__UNIQUE_ID___x521, align 4
  %33 = load i32, i32* %__UNIQUE_ID___y522, align 4
  %cmp79 = icmp ult i32 %32, %33
  br i1 %cmp79, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end75
  %34 = load i32, i32* %__UNIQUE_ID___x521, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end75
  %35 = load i32, i32* %__UNIQUE_ID___y522, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond81 = phi i32 [ %34, %cond.true ], [ %35, %cond.false ]
  store i32 %cond81, i32* %tmp78, align 4
  %36 = load i32, i32* %tmp78, align 4
  store i32 %36, i32* %n, align 4
  %37 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf82 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %37, i32 0, i32 1
  %38 = load i32, i32* %n, align 4
  %idxprom83 = zext i32 %38 to i64
  %arrayidx84 = getelementptr [1024 x i8], [1024 x i8]* %kbuf82, i64 0, i64 %idxprom83
  store i8 0, i8* %arrayidx84, align 1
  %39 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %39, i32 0, i32 2
  %40 = load i8*, i8** %ubuf, align 8
  %41 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used85 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %41, i32 0, i32 3
  %42 = load i32, i32* %len_used85, align 8
  %idx.ext = zext i32 %42 to i64
  %add.ptr = getelementptr i8, i8* %40, i64 %idx.ext
  %43 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf86 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %43, i32 0, i32 1
  %arraydecay87 = getelementptr inbounds [1024 x i8], [1024 x i8]* %kbuf86, i64 0, i64 0
  %44 = load i32, i32* %n, align 4
  %add = add i32 %44, 1
  %conv88 = zext i32 %add to i64
  store i8* %add.ptr, i8** %to.addr.i, align 8
  store i8* %arraydecay87, i8** %from.addr.i, align 8
  store i64 %conv88, i64* %n.addr.i, align 8
  %45 = load i8*, i8** %from.addr.i, align 8
  %46 = load i64, i64* %n.addr.i, align 8
  store i8* %45, i8** %addr.addr.i, align 8
  store i64 %46, i64* %bytes.addr.i, align 8
  store i8 1, i8* %is_source.addr.i, align 1
  %47 = load i8*, i8** %addr.addr.i, align 8
  %48 = call i64 @llvm.objectsize.i64.p0i8(i8* %47, i1 false, i1 true, i1 false) #19
  %conv.i = trunc i64 %48 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  %49 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp sge i32 %49, 0
  br i1 %cmp.i, label %land.rhs.i, label %land.end.i

land.rhs.i:                                       ; preds = %cond.end
  %50 = load i32, i32* %sz.i, align 4
  %conv2.i = sext i32 %50 to i64
  %51 = load i64, i64* %bytes.addr.i, align 8
  %cmp3.i = icmp ult i64 %conv2.i, %51
  br label %land.end.i

land.end.i:                                       ; preds = %land.rhs.i, %cond.end
  %52 = phi i1 [ false, %cond.end ], [ %cmp3.i, %land.rhs.i ]
  %lnot.i = xor i1 %52, true
  %lnot.ext.i = zext i1 %52 to i32
  %conv6.i = sext i32 %lnot.ext.i to i64
  br i1 %52, label %if.then.i96, label %if.end12.i

if.then.i96:                                      ; preds = %land.end.i
  %53 = load i64, i64* %bytes.addr.i, align 8
  %54 = call i1 @llvm.is.constant.i64(i64 %53) #19
  br i1 %54, label %if.else.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.then.i96
  %55 = load i32, i32* %sz.i, align 4
  %56 = load i64, i64* %bytes.addr.i, align 8
  call void @copy_overflow(i32 noundef %55, i64 noundef %56) #22
  br label %if.end11.i

if.else.i:                                        ; preds = %if.then.i96
  %57 = load i8, i8* %is_source.addr.i, align 1
  %tobool8.i = trunc i8 %57 to i1
  br i1 %tobool8.i, label %if.then9.i, label %if.else10.i

if.then9.i:                                       ; preds = %if.else.i
  call void @__bad_copy_from() #22, !srcloc !7
  br label %if.end.i

if.else10.i:                                      ; preds = %if.else.i
  call void @__bad_copy_to() #22, !srcloc !8
  br label %if.end.i

if.end.i:                                         ; preds = %if.else10.i, %if.then9.i
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.end.i, %if.then7.i
  store i1 false, i1* %retval.i, align 1
  br label %check_copy_size.exit

if.end12.i:                                       ; preds = %land.end.i
  %58 = load i64, i64* %bytes.addr.i, align 8
  %cmp13.i = icmp ugt i64 %58, 2147483647
  %lnot15.i = xor i1 %cmp13.i, true
  %lnot.ext18.i = zext i1 %cmp13.i to i32
  store i32 %lnot.ext18.i, i32* %__ret_warn_on.i, align 4
  %59 = load i32, i32* %__ret_warn_on.i, align 4
  %tobool19.i = icmp ne i32 %59, 0
  %lnot20.i = xor i1 %tobool19.i, true
  %lnot.ext23.i = zext i1 %tobool19.i to i32
  %conv24.i = sext i32 %lnot.ext23.i to i64
  br i1 %tobool19.i, label %if.then26.i, label %if.end33.i

if.then26.i:                                      ; preds = %if.end12.i
  store i32 2307, i32* %__flags.i, align 4
  %60 = load i32, i32* %__flags.i, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.27, i64 0, i64 0), i32 233, i32 %60, i64 12) #19, !srcloc !9
  br label %if.end33.i

if.end33.i:                                       ; preds = %if.then26.i, %if.end12.i
  %61 = load i32, i32* %__ret_warn_on.i, align 4
  %tobool34.i = icmp ne i32 %61, 0
  %lnot35.i = xor i1 %tobool34.i, true
  %lnot.ext38.i = zext i1 %tobool34.i to i32
  %conv39.i = sext i32 %lnot.ext38.i to i64
  store i64 %conv39.i, i64* %tmp.i, align 8
  %62 = load i64, i64* %tmp.i, align 8
  %tobool40.i = icmp ne i64 %62, 0
  br i1 %tobool40.i, label %if.then41.i, label %if.end42.i

if.then41.i:                                      ; preds = %if.end33.i
  store i1 false, i1* %retval.i, align 1
  br label %check_copy_size.exit

if.end42.i:                                       ; preds = %if.end33.i
  %63 = load i8*, i8** %addr.addr.i, align 8
  %64 = load i64, i64* %bytes.addr.i, align 8
  %65 = load i8, i8* %is_source.addr.i, align 1
  %tobool43.i = trunc i8 %65 to i1
  call void @check_object_size(i8* noundef %63, i64 noundef %64, i1 noundef zeroext %tobool43.i) #22
  store i1 true, i1* %retval.i, align 1
  br label %check_copy_size.exit

check_copy_size.exit:                             ; preds = %if.end11.i, %if.then41.i, %if.end42.i
  %66 = load i1, i1* %retval.i, align 1
  br i1 %66, label %if.then.i, label %copy_to_user.exit

if.then.i:                                        ; preds = %check_copy_size.exit
  %67 = load i8*, i8** %to.addr.i, align 8
  %68 = load i8*, i8** %from.addr.i, align 8
  %69 = load i64, i64* %n.addr.i, align 8
  %call1.i = call i64 @_copy_to_user(i8* noundef %67, i8* noundef %68, i64 noundef %69) #22
  store i64 %call1.i, i64* %n.addr.i, align 8
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %check_copy_size.exit, %if.then.i
  %70 = load i64, i64* %n.addr.i, align 8
  %tobool90 = icmp ne i64 %70, 0
  br i1 %tobool90, label %if.else, label %if.then91

if.then91:                                        ; preds = %copy_to_user.exit
  %71 = load i32, i32* %n, align 4
  %72 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used92 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %72, i32 0, i32 3
  %73 = load i32, i32* %len_used92, align 8
  %add93 = add i32 %73, %71
  store i32 %add93, i32* %len_used92, align 8
  br label %if.end95

if.else:                                          ; preds = %copy_to_user.exit
  %74 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf94 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %74, i32 0, i32 2
  store i8* null, i8** %ubuf94, align 8
  br label %if.end95

if.end95:                                         ; preds = %do.end68, %if.else, %if.then91
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @vscnprintf(i8* noundef, i64 noundef, i8* noundef, %struct.__va_list_tag* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__warn_printk(i8* noundef, ...) #1

; Function Attrs: cold noredzone null_pointer_is_valid
declare dso_local i32 @_printk(i8* noundef, ...) #2

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @bpf_verifier_log_write(%struct.bpf_verifier_env* noundef %env, i8* noundef %fmt, ...) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %fmt.addr = alloca i8*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 26
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #20
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 26
  %2 = load i8*, i8** %fmt.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log2, i8* noundef %2, %struct.__va_list_tag* noundef %arraydecay3) #20
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %tobool = icmp ne %struct.bpf_verifier_log* %0, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %1, i32 0, i32 0
  %2 = load i32, i32* %level, align 8
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %land.rhs
  %3 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %3, i32 0, i32 2
  %4 = load i8*, i8** %ubuf, align 8
  %tobool2 = icmp ne i8* %4, null
  br i1 %tobool2, label %land.lhs.true3, label %lor.rhs

land.lhs.true3:                                   ; preds = %land.lhs.true
  %5 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %call = call zeroext i1 @bpf_verifier_log_full(%struct.bpf_verifier_log* noundef %5) #20
  br i1 %call, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.lhs.true3, %land.lhs.true, %land.rhs
  %6 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %level4 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %6, i32 0, i32 0
  %7 = load i32, i32* %level4, align 8
  %cmp = icmp eq i32 %7, 8
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true3
  %8 = phi i1 [ true, %land.lhs.true3 ], [ %cmp, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %entry
  %9 = phi i1 [ false, %entry ], [ %8, %lor.end ]
  ret i1 %9
}

; Function Attrs: nofree nosync nounwind willreturn
declare void @llvm.va_start(i8*) #3

; Function Attrs: nofree nosync nounwind willreturn
declare void @llvm.va_end(i8*) #3

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @bpf_log(%struct.bpf_verifier_log* noundef %log, i8* noundef %fmt, ...) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %fmt.addr = alloca i8*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %0) #20
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %2 = load i8*, i8** %fmt.addr, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %1, i8* noundef %2, %struct.__va_list_tag* noundef %arraydecay2) #20
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay34 = bitcast %struct.__va_list_tag* %arraydecay3 to i8*
  call void @llvm.va_end(i8* %arraydecay34)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local zeroext i1 @is_dynptr_reg_valid_init(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %spi = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %0, %struct.bpf_reg_state* noundef %1) #20
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 1
  %3 = load i32, i32* %off, align 4
  %call1 = call i32 @get_spi(i32 noundef %3) #20
  store i32 %call1, i32* %spi, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %5 = load i32, i32* %spi, align 4
  %call2 = call zeroext i1 @is_spi_bounds_valid(%struct.bpf_func_state* noundef %4, i32 noundef %5, i32 noundef 2) #20
  br i1 %call2, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 11
  %7 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %8 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %7, i64 %idxprom
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 0
  %9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 2
  %dynptr = bitcast %union.anon.168* %9 to %struct.anon.171*
  %first_slot = getelementptr inbounds %struct.anon.171, %struct.anon.171* %dynptr, i32 0, i32 1
  %10 = load i8, i8* %first_slot, align 4
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %11 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %11, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 11
  %13 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack3, align 8
  %14 = load i32, i32* %spi, align 4
  %idxprom4 = sext i32 %14 to i64
  %arrayidx5 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %13, i64 %idxprom4
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx5, i32 0, i32 1
  %15 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %15 to i64
  %arrayidx7 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom6
  %16 = load i8, i8* %arrayidx7, align 1
  %conv = zext i8 %16 to i32
  %cmp8 = icmp ne i32 %conv, 4
  br i1 %cmp8, label %if.then20, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %for.body
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack11 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 11
  %18 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack11, align 8
  %19 = load i32, i32* %spi, align 4
  %sub = sub i32 %19, 1
  %idxprom12 = sext i32 %sub to i64
  %arrayidx13 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %18, i64 %idxprom12
  %slot_type14 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx13, i32 0, i32 1
  %20 = load i32, i32* %i, align 4
  %idxprom15 = sext i32 %20 to i64
  %arrayidx16 = getelementptr [8 x i8], [8 x i8]* %slot_type14, i64 0, i64 %idxprom15
  %21 = load i8, i8* %arrayidx16, align 1
  %conv17 = zext i8 %21 to i32
  %cmp18 = icmp ne i32 %conv17, 4
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %lor.lhs.false10, %for.body
  store i1 false, i1* %retval, align 1
  br label %return

if.end21:                                         ; preds = %lor.lhs.false10
  br label %for.inc

for.inc:                                          ; preds = %if.end21
  %22 = load i32, i32* %i, align 4
  %inc = add i32 %22, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then20, %if.then
  %23 = load i1, i1* %retval, align 1
  ret i1 %23
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 15
  %4 = load i32, i32* %frameno, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  ret %struct.bpf_func_state* %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @get_spi(i32 noundef %off) #0 {
entry:
  %off.addr = alloca i32, align 4
  store i32 %off, i32* %off.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %0
  %sub1 = sub i32 %sub, 1
  %div = sdiv i32 %sub1, 8
  ret i32 %div
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_spi_bounds_valid(%struct.bpf_func_state* noundef %state, i32 noundef %spi, i32 noundef %nr_slots) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %spi.addr = alloca i32, align 4
  %nr_slots.addr = alloca i32, align 4
  %allocated_slots = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %spi, i32* %spi.addr, align 4
  store i32 %nr_slots, i32* %nr_slots.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 10
  %1 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %1, 8
  store i32 %div, i32* %allocated_slots, align 4
  %2 = load i32, i32* %spi.addr, align 4
  %3 = load i32, i32* %nr_slots.addr, align 4
  %sub = sub i32 %2, %3
  %add = add i32 %sub, 1
  %cmp = icmp sge i32 %add, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %4 = load i32, i32* %spi.addr, align 4
  %5 = load i32, i32* %allocated_slots, align 4
  %cmp1 = icmp slt i32 %4, %5
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local zeroext i1 @is_dynptr_type_expected(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %arg_type) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %arg_type.addr = alloca i32, align 4
  %state = alloca %struct.bpf_func_state*, align 8
  %dynptr_type = alloca i32, align 4
  %spi = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %arg_type, i32* %arg_type.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %0, %struct.bpf_reg_state* noundef %1) #20
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 1
  %3 = load i32, i32* %off, align 4
  %call1 = call i32 @get_spi(i32 noundef %3) #20
  store i32 %call1, i32* %spi, align 4
  %4 = load i32, i32* %arg_type.addr, align 4
  %cmp = icmp eq i32 %4, 24
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, i32* %arg_type.addr, align 4
  %call2 = call i32 @arg_to_dynptr_type(i32 noundef %5) #20
  store i32 %call2, i32* %dynptr_type, align 4
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 11
  %7 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %8 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %7, i64 %idxprom
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 0
  %9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 2
  %dynptr = bitcast %union.anon.168* %9 to %struct.anon.171*
  %type = getelementptr inbounds %struct.anon.171, %struct.anon.171* %dynptr, i32 0, i32 0
  %10 = load i32, i32* %type, align 8
  %11 = load i32, i32* %dynptr_type, align 4
  %cmp3 = icmp eq i32 %10, %11
  store i1 %cmp3, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i1, i1* %retval, align 1
  ret i1 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @arg_to_dynptr_type(i32 noundef %arg_type) #0 {
entry:
  %retval = alloca i32, align 4
  %arg_type.addr = alloca i32, align 4
  store i32 %arg_type, i32* %arg_type.addr, align 4
  %0 = load i32, i32* %arg_type.addr, align 4
  %and = and i32 %0, 196608
  switch i32 %and, label %sw.default [
    i32 65536, label %sw.bb
    i32 131072, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %entry
  store i32 2, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %sw.bb1, %sw.bb
  %1 = load i32, i32* %retval, align 4
  ret i32 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @bpf_free_kfunc_btf_tab(%struct.bpf_kfunc_btf_tab* noundef %tab) #0 {
entry:
  %tab.addr = alloca %struct.bpf_kfunc_btf_tab*, align 8
  store %struct.bpf_kfunc_btf_tab* %tab, %struct.bpf_kfunc_btf_tab** %tab.addr, align 8
  %0 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab.addr, align 8
  %tobool = icmp ne %struct.bpf_kfunc_btf_tab* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %1 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab.addr, align 8
  %nr_descs = getelementptr inbounds %struct.bpf_kfunc_btf_tab, %struct.bpf_kfunc_btf_tab* %1, i32 0, i32 1
  %2 = load i32, i32* %nr_descs, align 8
  %dec = add i32 %2, -1
  store i32 %dec, i32* %nr_descs, align 8
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab.addr, align 8
  %descs = getelementptr inbounds %struct.bpf_kfunc_btf_tab, %struct.bpf_kfunc_btf_tab* %3, i32 0, i32 0
  %4 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab.addr, align 8
  %nr_descs2 = getelementptr inbounds %struct.bpf_kfunc_btf_tab, %struct.bpf_kfunc_btf_tab* %4, i32 0, i32 1
  %5 = load i32, i32* %nr_descs2, align 8
  %idxprom = zext i32 %5 to i64
  %arrayidx = getelementptr [256 x %struct.bpf_kfunc_btf], [256 x %struct.bpf_kfunc_btf]* %descs, i64 0, i64 %idxprom
  %module = getelementptr inbounds %struct.bpf_kfunc_btf, %struct.bpf_kfunc_btf* %arrayidx, i32 0, i32 1
  %6 = load %struct.module*, %struct.module** %module, align 8
  call void @module_put(%struct.module* noundef %6) #20
  %7 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab.addr, align 8
  %descs3 = getelementptr inbounds %struct.bpf_kfunc_btf_tab, %struct.bpf_kfunc_btf_tab* %7, i32 0, i32 0
  %8 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab.addr, align 8
  %nr_descs4 = getelementptr inbounds %struct.bpf_kfunc_btf_tab, %struct.bpf_kfunc_btf_tab* %8, i32 0, i32 1
  %9 = load i32, i32* %nr_descs4, align 8
  %idxprom5 = zext i32 %9 to i64
  %arrayidx6 = getelementptr [256 x %struct.bpf_kfunc_btf], [256 x %struct.bpf_kfunc_btf]* %descs3, i64 0, i64 %idxprom5
  %btf = getelementptr inbounds %struct.bpf_kfunc_btf, %struct.bpf_kfunc_btf* %arrayidx6, i32 0, i32 0
  %10 = load %struct.btf*, %struct.btf** %btf, align 8
  call void @btf_put(%struct.btf* noundef %10) #20
  br label %while.cond, !llvm.loop !12

while.end:                                        ; preds = %while.cond
  %11 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab.addr, align 8
  %12 = bitcast %struct.bpf_kfunc_btf_tab* %11 to i8*
  call void @kfree(i8* noundef %12) #20
  br label %return

return:                                           ; preds = %while.end, %if.then
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @module_put(%struct.module* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @btf_put(%struct.btf* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @kfree(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local zeroext i1 @bpf_prog_has_kfunc_call(%struct.bpf_prog* noundef %prog) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 10
  %1 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %kfunc_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %1, i32 0, i32 33
  %2 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %kfunc_tab, align 8
  %tobool = icmp ne %struct.bpf_kfunc_desc_tab* %2, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  ret i1 %lnot1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local %struct.btf_func_model* @bpf_jit_find_kfunc_model(%struct.bpf_prog* noundef %prog, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %desc = alloca %struct.bpf_kfunc_desc, align 4
  %res = alloca %struct.bpf_kfunc_desc*, align 8
  %tab = alloca %struct.bpf_kfunc_desc_tab*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = bitcast %struct.bpf_kfunc_desc* %desc to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %0, i8 0, i64 40, i1 false)
  %imm = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %desc, i32 0, i32 2
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 3
  %2 = load i32, i32* %imm1, align 4
  store i32 %2, i32* %imm, align 4
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 10
  %4 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %kfunc_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %4, i32 0, i32 33
  %5 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %kfunc_tab, align 8
  store %struct.bpf_kfunc_desc_tab* %5, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %6 = bitcast %struct.bpf_kfunc_desc* %desc to i8*
  %7 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %7, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x %struct.bpf_kfunc_desc], [256 x %struct.bpf_kfunc_desc]* %descs, i64 0, i64 0
  %8 = bitcast %struct.bpf_kfunc_desc* %arraydecay to i8*
  %9 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %nr_descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %9, i32 0, i32 1
  %10 = load i32, i32* %nr_descs, align 4
  %conv = zext i32 %10 to i64
  %call = call i8* @bsearch(i8* noundef %6, i8* noundef %8, i64 noundef %conv, i64 noundef 40, i32 (i8*, i8*)* noundef @kfunc_desc_cmp_by_imm) #20
  %11 = bitcast i8* %call to %struct.bpf_kfunc_desc*
  store %struct.bpf_kfunc_desc* %11, %struct.bpf_kfunc_desc** %res, align 8
  %12 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %res, align 8
  %tobool = icmp ne %struct.bpf_kfunc_desc* %12, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %13 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %res, align 8
  %func_model = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %13, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.btf_func_model* [ %func_model, %cond.true ], [ null, %cond.false ]
  ret %struct.btf_func_model* %cond
}

; Function Attrs: argmemonly nofree nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #4

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @bsearch(i8* noundef, i8* noundef, i64 noundef, i64 noundef, i32 (i8*, i8*)* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @kfunc_desc_cmp_by_imm(i8* noundef %a, i8* noundef %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  %d0 = alloca %struct.bpf_kfunc_desc*, align 8
  %d1 = alloca %struct.bpf_kfunc_desc*, align 8
  store i8* %a, i8** %a.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  %0 = load i8*, i8** %a.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_kfunc_desc*
  store %struct.bpf_kfunc_desc* %1, %struct.bpf_kfunc_desc** %d0, align 8
  %2 = load i8*, i8** %b.addr, align 8
  %3 = bitcast i8* %2 to %struct.bpf_kfunc_desc*
  store %struct.bpf_kfunc_desc* %3, %struct.bpf_kfunc_desc** %d1, align 8
  %4 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d0, align 8
  %imm = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %4, i32 0, i32 2
  %5 = load i32, i32* %imm, align 4
  %6 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d1, align 8
  %imm1 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %6, i32 0, i32 2
  %7 = load i32, i32* %imm1, align 4
  %cmp = icmp sgt i32 %5, %7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %8 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d0, align 8
  %imm2 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %8, i32 0, i32 2
  %9 = load i32, i32* %imm2, align 4
  %10 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d1, align 8
  %imm3 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %10, i32 0, i32 2
  %11 = load i32, i32* %imm3, align 4
  %cmp4 = icmp slt i32 %9, %11
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %12 = load i32, i32* %retval, align 4
  ret i32 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call i32 @__mark_chain_precision(%struct.bpf_verifier_env* noundef %0, i32 noundef %1, i32 noundef -1) #20
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__mark_chain_precision(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %spi) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %spi.addr = alloca i32, align 4
  %st = alloca %struct.bpf_verifier_state*, align 8
  %first_idx = alloca i32, align 4
  %last_idx = alloca i32, align 4
  %func = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %reg_mask = alloca i32, align 4
  %stack_mask = alloca i64, align 8
  %skip_first = alloca i8, align 1
  %new_marks = alloca i8, align 1
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_cond = alloca i8, align 1
  %__ret_once = alloca i8, align 1
  %tmp = alloca i64, align 8
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp52 = alloca i64, align 8
  %tmp60 = alloca i64, align 8
  %mask = alloca [1 x i64], align 8
  %history = alloca i32, align 4
  %__ret_do_once130 = alloca i8, align 1
  %__ret_cond131 = alloca i8, align 1
  %__ret_once138 = alloca i8, align 1
  %tmp154 = alloca i64, align 8
  %__ret_warn_on163 = alloca i32, align 4
  %__flags176 = alloca i32, align 4
  %tmp188 = alloca i64, align 8
  %tmp196 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %spi, i32* %spi.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %st, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %first_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 7
  %3 = load i32, i32* %first_insn_idx, align 4
  store i32 %3, i32* %first_idx, align 4
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 0
  %5 = load i32, i32* %insn_idx, align 8
  store i32 %5, i32* %last_idx, align 4
  %6 = load i32, i32* %regno.addr, align 4
  %cmp = icmp sge i32 %6, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i32, i32* %regno.addr, align 4
  %shl = shl i32 1, %7
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %shl, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %reg_mask, align 4
  %8 = load i32, i32* %spi.addr, align 4
  %cmp1 = icmp sge i32 %8, 0
  br i1 %cmp1, label %cond.true2, label %cond.false4

cond.true2:                                       ; preds = %cond.end
  %9 = load i32, i32* %spi.addr, align 4
  %sh_prom = zext i32 %9 to i64
  %shl3 = shl i64 1, %sh_prom
  br label %cond.end5

cond.false4:                                      ; preds = %cond.end
  br label %cond.end5

cond.end5:                                        ; preds = %cond.false4, %cond.true2
  %cond6 = phi i64 [ %shl3, %cond.true2 ], [ 0, %cond.false4 ]
  store i64 %cond6, i64* %stack_mask, align 8
  store i8 1, i8* %skip_first, align 1
  store i8 0, i8* %new_marks, align 1
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 20
  %11 = load i8, i8* %bpf_capable, align 8
  %tobool = trunc i8 %11 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end5
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end5
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 0
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 4
  %14 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %14 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %15, %struct.bpf_func_state** %func, align 8
  %16 = load i32, i32* %regno.addr, align 4
  %cmp7 = icmp sge i32 %16, 0
  br i1 %cmp7, label %if.then8, label %if.end72

if.then8:                                         ; preds = %if.end
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 0
  %18 = load i32, i32* %regno.addr, align 4
  %idxprom9 = sext i32 %18 to i64
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom9
  store %struct.bpf_reg_state* %arrayidx10, %struct.bpf_reg_state** %reg, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type, align 8
  %cmp11 = icmp ne i32 %20, 1
  br i1 %cmp11, label %if.then12, label %if.end67

if.then12:                                        ; preds = %if.then8
  store i8 1, i8* %__ret_do_once, align 1
  %21 = load i8, i8* %__ret_do_once, align 1
  %tobool13 = trunc i8 %21 to i1
  %lnot = xor i1 %tobool13, true
  %lnot14 = xor i1 %lnot, true
  %frombool = zext i1 %lnot14 to i8
  store i8 %frombool, i8* %__ret_cond, align 1
  store i8 0, i8* %__ret_once, align 1
  %22 = load i8, i8* %__ret_cond, align 1
  %tobool15 = trunc i8 %22 to i1
  br i1 %tobool15, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then12
  %23 = load i8, i8* @__mark_chain_precision.__already_done, align 1
  %tobool16 = trunc i8 %23 to i1
  %lnot17 = xor i1 %tobool16, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then12
  %24 = phi i1 [ false, %if.then12 ], [ %lnot17, %land.rhs ]
  %lnot18 = xor i1 %24, true
  %lnot19 = xor i1 %lnot18, true
  %lnot.ext = zext i1 %lnot19 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool20 = icmp ne i64 %conv, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %land.end
  store i8 1, i8* @__mark_chain_precision.__already_done, align 1
  store i8 1, i8* %__ret_once, align 1
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %land.end
  %25 = load i8, i8* %__ret_once, align 1
  %tobool23 = trunc i8 %25 to i1
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  store i64 %conv28, i64* %tmp, align 8
  %26 = load i64, i64* %tmp, align 8
  %tobool29 = icmp ne i64 %26, 0
  br i1 %tobool29, label %if.then30, label %if.end59

if.then30:                                        ; preds = %if.end22
  store i32 1, i32* %__ret_warn_on, align 4
  %27 = load i32, i32* %__ret_warn_on, align 4
  %tobool31 = icmp ne i32 %27, 0
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %conv36 = sext i32 %lnot.ext35 to i64
  %tobool37 = icmp ne i64 %conv36, 0
  br i1 %tobool37, label %if.then38, label %if.end51

if.then38:                                        ; preds = %if.then30
  br label %do.body

do.body:                                          ; preds = %if.then38
  br label %do.body39

do.body39:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body39
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([19 x i8], [19 x i8]* @.str.28, i64 0, i64 0)) #20
  br label %do.body40

do.body40:                                        ; preds = %do.end
  store i32 2313, i32* %__flags, align 4
  br label %do.body41

do.body41:                                        ; preds = %do.body40
  br label %do.end42

do.end42:                                         ; preds = %do.body41
  br label %do.body43

do.body43:                                        ; preds = %do.end42
  %28 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2884, i32 %28, i64 12) #19, !srcloc !13
  br label %do.end44

do.end44:                                         ; preds = %do.body43
  br label %do.body45

do.body45:                                        ; preds = %do.end44
  br label %do.end46

do.end46:                                         ; preds = %do.body45
  br label %do.end47

do.end47:                                         ; preds = %do.end46
  br label %do.body48

do.body48:                                        ; preds = %do.end47
  br label %do.end49

do.end49:                                         ; preds = %do.body48
  br label %do.end50

do.end50:                                         ; preds = %do.end49
  br label %if.end51

if.end51:                                         ; preds = %do.end50, %if.then30
  %29 = load i32, i32* %__ret_warn_on, align 4
  %tobool53 = icmp ne i32 %29, 0
  %lnot54 = xor i1 %tobool53, true
  %lnot56 = xor i1 %lnot54, true
  %lnot.ext57 = zext i1 %lnot56 to i32
  %conv58 = sext i32 %lnot.ext57 to i64
  store i64 %conv58, i64* %tmp52, align 8
  %30 = load i64, i64* %tmp52, align 8
  br label %if.end59

if.end59:                                         ; preds = %if.end51, %if.end22
  %31 = load i8, i8* %__ret_do_once, align 1
  %tobool61 = trunc i8 %31 to i1
  %lnot62 = xor i1 %tobool61, true
  %lnot64 = xor i1 %lnot62, true
  %lnot.ext65 = zext i1 %lnot64 to i32
  %conv66 = sext i32 %lnot.ext65 to i64
  store i64 %conv66, i64* %tmp60, align 8
  %32 = load i64, i64* %tmp60, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.then8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 18
  %34 = load i8, i8* %precise, align 4
  %tobool68 = trunc i8 %34 to i1
  br i1 %tobool68, label %if.else, label %if.then69

if.then69:                                        ; preds = %if.end67
  store i8 1, i8* %new_marks, align 1
  br label %if.end70

if.else:                                          ; preds = %if.end67
  store i32 0, i32* %reg_mask, align 4
  br label %if.end70

if.end70:                                         ; preds = %if.else, %if.then69
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 18
  store i8 1, i8* %precise71, align 4
  br label %if.end72

if.end72:                                         ; preds = %if.end70, %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end72
  %36 = load i32, i32* %spi.addr, align 4
  %cmp73 = icmp sge i32 %36, 0
  br i1 %cmp73, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %37, i32 0, i32 11
  %38 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %39 = load i32, i32* %spi.addr, align 4
  %idxprom75 = sext i32 %39 to i64
  %arrayidx76 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %38, i64 %idxprom75
  %call = call zeroext i1 @is_spilled_reg(%struct.bpf_stack_state* noundef %arrayidx76) #20
  br i1 %call, label %if.end78, label %if.then77

if.then77:                                        ; preds = %while.body
  store i64 0, i64* %stack_mask, align 8
  br label %while.end

if.end78:                                         ; preds = %while.body
  %40 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack79 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %40, i32 0, i32 11
  %41 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack79, align 8
  %42 = load i32, i32* %spi.addr, align 4
  %idxprom80 = sext i32 %42 to i64
  %arrayidx81 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %41, i64 %idxprom80
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx81, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %reg, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type82 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 0
  %44 = load i32, i32* %type82, align 8
  %cmp83 = icmp ne i32 %44, 1
  br i1 %cmp83, label %if.then85, label %if.end86

if.then85:                                        ; preds = %if.end78
  store i64 0, i64* %stack_mask, align 8
  br label %while.end

if.end86:                                         ; preds = %if.end78
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise87 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 18
  %46 = load i8, i8* %precise87, align 4
  %tobool88 = trunc i8 %46 to i1
  br i1 %tobool88, label %if.else90, label %if.then89

if.then89:                                        ; preds = %if.end86
  store i8 1, i8* %new_marks, align 1
  br label %if.end91

if.else90:                                        ; preds = %if.end86
  store i64 0, i64* %stack_mask, align 8
  br label %if.end91

if.end91:                                         ; preds = %if.else90, %if.then89
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 18
  store i8 1, i8* %precise92, align 4
  br label %while.end

while.end:                                        ; preds = %if.end91, %if.then85, %if.then77, %while.cond
  %48 = load i8, i8* %new_marks, align 1
  %tobool93 = trunc i8 %48 to i1
  br i1 %tobool93, label %if.end95, label %if.then94

if.then94:                                        ; preds = %while.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end95:                                         ; preds = %while.end
  %49 = load i32, i32* %reg_mask, align 4
  %tobool96 = icmp ne i32 %49, 0
  br i1 %tobool96, label %if.end99, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end95
  %50 = load i64, i64* %stack_mask, align 8
  %tobool97 = icmp ne i64 %50, 0
  br i1 %tobool97, label %if.end99, label %if.then98

if.then98:                                        ; preds = %land.lhs.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end99:                                         ; preds = %land.lhs.true, %if.end95
  br label %for.cond

for.cond:                                         ; preds = %if.end295, %if.end99
  %51 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %51, i32 0, i32 10
  %52 = load i32, i32* %jmp_history_cnt, align 8
  store i32 %52, i32* %history, align 4
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %53, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %54 = load i32, i32* %level, align 8
  %and = and i32 %54, 2
  %tobool100 = icmp ne i32 %and, 0
  br i1 %tobool100, label %if.then101, label %if.end102

if.then101:                                       ; preds = %for.cond
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = bitcast %struct.bpf_verifier_env* %55 to i8*
  %57 = load i32, i32* %last_idx, align 4
  %58 = load i32, i32* %first_idx, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %56, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.29, i64 0, i64 0), i32 noundef %57, i32 noundef %58) #20
  br label %if.end102

if.end102:                                        ; preds = %if.then101, %for.cond
  %59 = load i32, i32* %last_idx, align 4
  store i32 %59, i32* %i, align 4
  br label %for.cond103

for.cond103:                                      ; preds = %if.end203, %if.end102
  %60 = load i8, i8* %skip_first, align 1
  %tobool104 = trunc i8 %60 to i1
  br i1 %tobool104, label %if.then105, label %if.else106

if.then105:                                       ; preds = %for.cond103
  store i32 0, i32* %err, align 4
  store i8 0, i8* %skip_first, align 1
  br label %if.end108

if.else106:                                       ; preds = %for.cond103
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %62 = load i32, i32* %i, align 4
  %call107 = call i32 @backtrack_insn(%struct.bpf_verifier_env* noundef %61, i32 noundef %62, i32* noundef %reg_mask, i64* noundef %stack_mask) #20
  store i32 %call107, i32* %err, align 4
  br label %if.end108

if.end108:                                        ; preds = %if.else106, %if.then105
  %63 = load i32, i32* %err, align 4
  %cmp109 = icmp eq i32 %63, -524
  br i1 %cmp109, label %if.then111, label %if.else112

if.then111:                                       ; preds = %if.end108
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  call void @mark_all_scalars_precise(%struct.bpf_verifier_env* noundef %64, %struct.bpf_verifier_state* noundef %65) #20
  store i32 0, i32* %retval, align 4
  br label %return

if.else112:                                       ; preds = %if.end108
  %66 = load i32, i32* %err, align 4
  %tobool113 = icmp ne i32 %66, 0
  br i1 %tobool113, label %if.then114, label %if.end115

if.then114:                                       ; preds = %if.else112
  %67 = load i32, i32* %err, align 4
  store i32 %67, i32* %retval, align 4
  br label %return

if.end115:                                        ; preds = %if.else112
  br label %if.end116

if.end116:                                        ; preds = %if.end115
  %68 = load i32, i32* %reg_mask, align 4
  %tobool117 = icmp ne i32 %68, 0
  br i1 %tobool117, label %if.end121, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.end116
  %69 = load i64, i64* %stack_mask, align 8
  %tobool119 = icmp ne i64 %69, 0
  br i1 %tobool119, label %if.end121, label %if.then120

if.then120:                                       ; preds = %land.lhs.true118
  store i32 0, i32* %retval, align 4
  br label %return

if.end121:                                        ; preds = %land.lhs.true118, %if.end116
  %70 = load i32, i32* %i, align 4
  %71 = load i32, i32* %first_idx, align 4
  %cmp122 = icmp eq i32 %70, %71
  br i1 %cmp122, label %if.then124, label %if.end125

if.then124:                                       ; preds = %if.end121
  br label %for.end

if.end125:                                        ; preds = %if.end121
  %72 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %73 = load i32, i32* %i, align 4
  %call126 = call i32 @get_prev_insn_idx(%struct.bpf_verifier_state* noundef %72, i32 noundef %73, i32* noundef %history) #20
  store i32 %call126, i32* %i, align 4
  %74 = load i32, i32* %i, align 4
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %75, i32 0, i32 2
  %76 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %76, i32 0, i32 4
  %77 = load i32, i32* %len, align 4
  %cmp127 = icmp uge i32 %74, %77
  br i1 %cmp127, label %if.then129, label %if.end203

if.then129:                                       ; preds = %if.end125
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %79 = bitcast %struct.bpf_verifier_env* %78 to i8*
  %80 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %79, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.30, i64 0, i64 0), i32 noundef %80) #20
  store i8 1, i8* %__ret_do_once130, align 1
  %81 = load i8, i8* %__ret_do_once130, align 1
  %tobool132 = trunc i8 %81 to i1
  %lnot133 = xor i1 %tobool132, true
  %lnot135 = xor i1 %lnot133, true
  %frombool137 = zext i1 %lnot135 to i8
  store i8 %frombool137, i8* %__ret_cond131, align 1
  store i8 0, i8* %__ret_once138, align 1
  %82 = load i8, i8* %__ret_cond131, align 1
  %tobool139 = trunc i8 %82 to i1
  br i1 %tobool139, label %land.rhs141, label %land.end145

land.rhs141:                                      ; preds = %if.then129
  %83 = load i8, i8* @__mark_chain_precision.__already_done.31, align 1
  %tobool142 = trunc i8 %83 to i1
  %lnot143 = xor i1 %tobool142, true
  br label %land.end145

land.end145:                                      ; preds = %land.rhs141, %if.then129
  %84 = phi i1 [ false, %if.then129 ], [ %lnot143, %land.rhs141 ]
  %lnot146 = xor i1 %84, true
  %lnot148 = xor i1 %lnot146, true
  %lnot.ext149 = zext i1 %lnot148 to i32
  %conv150 = sext i32 %lnot.ext149 to i64
  %tobool151 = icmp ne i64 %conv150, 0
  br i1 %tobool151, label %if.then152, label %if.end153

if.then152:                                       ; preds = %land.end145
  store i8 1, i8* @__mark_chain_precision.__already_done.31, align 1
  store i8 1, i8* %__ret_once138, align 1
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %land.end145
  %85 = load i8, i8* %__ret_once138, align 1
  %tobool155 = trunc i8 %85 to i1
  %lnot156 = xor i1 %tobool155, true
  %lnot158 = xor i1 %lnot156, true
  %lnot.ext159 = zext i1 %lnot158 to i32
  %conv160 = sext i32 %lnot.ext159 to i64
  store i64 %conv160, i64* %tmp154, align 8
  %86 = load i64, i64* %tmp154, align 8
  %tobool161 = icmp ne i64 %86, 0
  br i1 %tobool161, label %if.then162, label %if.end195

if.then162:                                       ; preds = %if.end153
  store i32 1, i32* %__ret_warn_on163, align 4
  %87 = load i32, i32* %__ret_warn_on163, align 4
  %tobool164 = icmp ne i32 %87, 0
  %lnot165 = xor i1 %tobool164, true
  %lnot167 = xor i1 %lnot165, true
  %lnot.ext168 = zext i1 %lnot167 to i32
  %conv169 = sext i32 %lnot.ext168 to i64
  %tobool170 = icmp ne i64 %conv169, 0
  br i1 %tobool170, label %if.then171, label %if.end187

if.then171:                                       ; preds = %if.then162
  br label %do.body172

do.body172:                                       ; preds = %if.then171
  br label %do.body173

do.body173:                                       ; preds = %do.body172
  br label %do.end174

do.end174:                                        ; preds = %do.body173
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.32, i64 0, i64 0)) #20
  br label %do.body175

do.body175:                                       ; preds = %do.end174
  store i32 2313, i32* %__flags176, align 4
  br label %do.body177

do.body177:                                       ; preds = %do.body175
  br label %do.end178

do.end178:                                        ; preds = %do.body177
  br label %do.body179

do.body179:                                       ; preds = %do.end178
  %88 = load i32, i32* %__flags176, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2952, i32 %88, i64 12) #19, !srcloc !14
  br label %do.end180

do.end180:                                        ; preds = %do.body179
  br label %do.body181

do.body181:                                       ; preds = %do.end180
  br label %do.end182

do.end182:                                        ; preds = %do.body181
  br label %do.end183

do.end183:                                        ; preds = %do.end182
  br label %do.body184

do.body184:                                       ; preds = %do.end183
  br label %do.end185

do.end185:                                        ; preds = %do.body184
  br label %do.end186

do.end186:                                        ; preds = %do.end185
  br label %if.end187

if.end187:                                        ; preds = %do.end186, %if.then162
  %89 = load i32, i32* %__ret_warn_on163, align 4
  %tobool189 = icmp ne i32 %89, 0
  %lnot190 = xor i1 %tobool189, true
  %lnot192 = xor i1 %lnot190, true
  %lnot.ext193 = zext i1 %lnot192 to i32
  %conv194 = sext i32 %lnot.ext193 to i64
  store i64 %conv194, i64* %tmp188, align 8
  %90 = load i64, i64* %tmp188, align 8
  br label %if.end195

if.end195:                                        ; preds = %if.end187, %if.end153
  %91 = load i8, i8* %__ret_do_once130, align 1
  %tobool197 = trunc i8 %91 to i1
  %lnot198 = xor i1 %tobool197, true
  %lnot200 = xor i1 %lnot198, true
  %lnot.ext201 = zext i1 %lnot200 to i32
  %conv202 = sext i32 %lnot.ext201 to i64
  store i64 %conv202, i64* %tmp196, align 8
  %92 = load i64, i64* %tmp196, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end203:                                        ; preds = %if.end125
  br label %for.cond103

for.end:                                          ; preds = %if.then124
  %93 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %93, i32 0, i32 1
  %94 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  store %struct.bpf_verifier_state* %94, %struct.bpf_verifier_state** %st, align 8
  %95 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %tobool204 = icmp ne %struct.bpf_verifier_state* %95, null
  br i1 %tobool204, label %if.end206, label %if.then205

if.then205:                                       ; preds = %for.end
  br label %for.end297

if.end206:                                        ; preds = %for.end
  store i8 0, i8* %new_marks, align 1
  %96 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %frame207 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %96, i32 0, i32 0
  %97 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %curframe208 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %97, i32 0, i32 4
  %98 = load i32, i32* %curframe208, align 8
  %idxprom209 = zext i32 %98 to i64
  %arrayidx210 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame207, i64 0, i64 %idxprom209
  %99 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx210, align 8
  store %struct.bpf_func_state* %99, %struct.bpf_func_state** %func, align 8
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %100 = load i32, i32* %reg_mask, align 4
  %conv211 = zext i32 %100 to i64
  call void @bitmap_from_u64(i64* noundef %arraydecay, i64 noundef %conv211) #20
  store i32 0, i32* %i, align 4
  br label %for.cond212

for.cond212:                                      ; preds = %for.inc, %if.end206
  %arraydecay213 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %101 = load i32, i32* %i, align 4
  %conv214 = sext i32 %101 to i64
  %call215 = call i64 @find_next_bit(i64* noundef %arraydecay213, i64 noundef 32, i64 noundef %conv214) #20
  %conv216 = trunc i64 %call215 to i32
  store i32 %conv216, i32* %i, align 4
  %102 = load i32, i32* %i, align 4
  %cmp217 = icmp slt i32 %102, 32
  br i1 %cmp217, label %for.body, label %for.end234

for.body:                                         ; preds = %for.cond212
  %103 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %regs219 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %103, i32 0, i32 0
  %104 = load i32, i32* %i, align 4
  %idxprom220 = sext i32 %104 to i64
  %arrayidx221 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs219, i64 0, i64 %idxprom220
  store %struct.bpf_reg_state* %arrayidx221, %struct.bpf_reg_state** %reg, align 8
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type222 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %105, i32 0, i32 0
  %106 = load i32, i32* %type222, align 8
  %cmp223 = icmp ne i32 %106, 1
  br i1 %cmp223, label %if.then225, label %if.end228

if.then225:                                       ; preds = %for.body
  %107 = load i32, i32* %i, align 4
  %shl226 = shl i32 1, %107
  %neg = xor i32 %shl226, -1
  %108 = load i32, i32* %reg_mask, align 4
  %and227 = and i32 %108, %neg
  store i32 %and227, i32* %reg_mask, align 4
  br label %for.inc

if.end228:                                        ; preds = %for.body
  %109 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise229 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %109, i32 0, i32 18
  %110 = load i8, i8* %precise229, align 4
  %tobool230 = trunc i8 %110 to i1
  br i1 %tobool230, label %if.end232, label %if.then231

if.then231:                                       ; preds = %if.end228
  store i8 1, i8* %new_marks, align 1
  br label %if.end232

if.end232:                                        ; preds = %if.then231, %if.end228
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise233 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 18
  store i8 1, i8* %precise233, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end232, %if.then225
  %112 = load i32, i32* %i, align 4
  %inc = add i32 %112, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond212, !llvm.loop !15

for.end234:                                       ; preds = %for.cond212
  %arraydecay235 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %113 = load i64, i64* %stack_mask, align 8
  call void @bitmap_from_u64(i64* noundef %arraydecay235, i64 noundef %113) #20
  store i32 0, i32* %i, align 4
  br label %for.cond236

for.cond236:                                      ; preds = %for.inc276, %for.end234
  %arraydecay237 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %114 = load i32, i32* %i, align 4
  %conv238 = sext i32 %114 to i64
  %call239 = call i64 @find_next_bit(i64* noundef %arraydecay237, i64 noundef 64, i64 noundef %conv238) #20
  %conv240 = trunc i64 %call239 to i32
  store i32 %conv240, i32* %i, align 4
  %115 = load i32, i32* %i, align 4
  %cmp241 = icmp slt i32 %115, 64
  br i1 %cmp241, label %for.body243, label %for.end278

for.body243:                                      ; preds = %for.cond236
  %116 = load i32, i32* %i, align 4
  %117 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %117, i32 0, i32 10
  %118 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %118, 8
  %cmp244 = icmp sge i32 %116, %div
  br i1 %cmp244, label %if.then246, label %if.end247

if.then246:                                       ; preds = %for.body243
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %120 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  call void @mark_all_scalars_precise(%struct.bpf_verifier_env* noundef %119, %struct.bpf_verifier_state* noundef %120) #20
  store i32 0, i32* %retval, align 4
  br label %return

if.end247:                                        ; preds = %for.body243
  %121 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack248 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %121, i32 0, i32 11
  %122 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack248, align 8
  %123 = load i32, i32* %i, align 4
  %idxprom249 = sext i32 %123 to i64
  %arrayidx250 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %122, i64 %idxprom249
  %call251 = call zeroext i1 @is_spilled_reg(%struct.bpf_stack_state* noundef %arrayidx250) #20
  br i1 %call251, label %if.end257, label %if.then252

if.then252:                                       ; preds = %if.end247
  %124 = load i32, i32* %i, align 4
  %sh_prom253 = zext i32 %124 to i64
  %shl254 = shl i64 1, %sh_prom253
  %neg255 = xor i64 %shl254, -1
  %125 = load i64, i64* %stack_mask, align 8
  %and256 = and i64 %125, %neg255
  store i64 %and256, i64* %stack_mask, align 8
  br label %for.inc276

if.end257:                                        ; preds = %if.end247
  %126 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack258 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %126, i32 0, i32 11
  %127 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack258, align 8
  %128 = load i32, i32* %i, align 4
  %idxprom259 = sext i32 %128 to i64
  %arrayidx260 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %127, i64 %idxprom259
  %spilled_ptr261 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx260, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr261, %struct.bpf_reg_state** %reg, align 8
  %129 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type262 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %129, i32 0, i32 0
  %130 = load i32, i32* %type262, align 8
  %cmp263 = icmp ne i32 %130, 1
  br i1 %cmp263, label %if.then265, label %if.end270

if.then265:                                       ; preds = %if.end257
  %131 = load i32, i32* %i, align 4
  %sh_prom266 = zext i32 %131 to i64
  %shl267 = shl i64 1, %sh_prom266
  %neg268 = xor i64 %shl267, -1
  %132 = load i64, i64* %stack_mask, align 8
  %and269 = and i64 %132, %neg268
  store i64 %and269, i64* %stack_mask, align 8
  br label %for.inc276

if.end270:                                        ; preds = %if.end257
  %133 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise271 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %133, i32 0, i32 18
  %134 = load i8, i8* %precise271, align 4
  %tobool272 = trunc i8 %134 to i1
  br i1 %tobool272, label %if.end274, label %if.then273

if.then273:                                       ; preds = %if.end270
  store i8 1, i8* %new_marks, align 1
  br label %if.end274

if.end274:                                        ; preds = %if.then273, %if.end270
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise275 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %135, i32 0, i32 18
  store i8 1, i8* %precise275, align 4
  br label %for.inc276

for.inc276:                                       ; preds = %if.end274, %if.then265, %if.then252
  %136 = load i32, i32* %i, align 4
  %inc277 = add i32 %136, 1
  store i32 %inc277, i32* %i, align 4
  br label %for.cond236, !llvm.loop !16

for.end278:                                       ; preds = %for.cond236
  %137 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log279 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %137, i32 0, i32 26
  %level280 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log279, i32 0, i32 0
  %138 = load i32, i32* %level280, align 8
  %and281 = and i32 %138, 2
  %tobool282 = icmp ne i32 %and281, 0
  br i1 %tobool282, label %if.then283, label %if.end287

if.then283:                                       ; preds = %for.end278
  %139 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %140 = bitcast %struct.bpf_verifier_env* %139 to i8*
  %141 = load i8, i8* %new_marks, align 1
  %tobool284 = trunc i8 %141 to i1
  %142 = zext i1 %tobool284 to i64
  %cond286 = select i1 %tobool284, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.34, i64 0, i64 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.35, i64 0, i64 0)
  %143 = load i32, i32* %reg_mask, align 4
  %144 = load i64, i64* %stack_mask, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %140, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.33, i64 0, i64 0), i8* noundef %cond286, i32 noundef %143, i64 noundef %144) #20
  %145 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %146 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %145, %struct.bpf_func_state* noundef %146, i1 noundef zeroext true) #20
  br label %if.end287

if.end287:                                        ; preds = %if.then283, %for.end278
  %147 = load i32, i32* %reg_mask, align 4
  %tobool288 = icmp ne i32 %147, 0
  br i1 %tobool288, label %if.end292, label %land.lhs.true289

land.lhs.true289:                                 ; preds = %if.end287
  %148 = load i64, i64* %stack_mask, align 8
  %tobool290 = icmp ne i64 %148, 0
  br i1 %tobool290, label %if.end292, label %if.then291

if.then291:                                       ; preds = %land.lhs.true289
  br label %for.end297

if.end292:                                        ; preds = %land.lhs.true289, %if.end287
  %149 = load i8, i8* %new_marks, align 1
  %tobool293 = trunc i8 %149 to i1
  br i1 %tobool293, label %if.end295, label %if.then294

if.then294:                                       ; preds = %if.end292
  br label %for.end297

if.end295:                                        ; preds = %if.end292
  %150 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %last_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %150, i32 0, i32 8
  %151 = load i32, i32* %last_insn_idx, align 8
  store i32 %151, i32* %last_idx, align 4
  %152 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %first_insn_idx296 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %152, i32 0, i32 7
  %153 = load i32, i32* %first_insn_idx296, align 4
  store i32 %153, i32* %first_idx, align 4
  br label %for.cond

for.end297:                                       ; preds = %if.then294, %if.then291, %if.then205
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end297, %if.then246, %if.end195, %if.then120, %if.then114, %if.then111, %if.then98, %if.then94, %if.end59, %if.then
  %154 = load i32, i32* %retval, align 4
  ret i32 %154
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @check_ptr_off_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %call = call i32 @__check_ptr_off_reg(%struct.bpf_verifier_env* noundef %0, %struct.bpf_reg_state* noundef %1, i32 noundef %2, i1 noundef zeroext false) #20
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_ptr_off_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i1 noundef zeroext %fixed_off_ok) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %fixed_off_ok.addr = alloca i8, align 1
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %frombool = zext i1 %fixed_off_ok to i8
  store i8 %frombool, i8* %fixed_off_ok.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 1
  %1 = load i32, i32* %off, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 0
  %6 = load i32, i32* %type, align 8
  %call = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %4, i32 noundef %6) #20
  %7 = load i32, i32* %regno.addr, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 1
  %9 = load i32, i32* %off1, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.111, i64 0, i64 0), i8* noundef %call, i32 noundef %7, i32 noundef %9) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i8, i8* %fixed_off_ok.addr, align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.end8, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 1
  %12 = load i32, i32* %off2, align 4
  %tobool3 = icmp ne i32 %12, 0
  br i1 %tobool3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %land.lhs.true
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 0
  %17 = load i32, i32* %type5, align 8
  %call6 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %15, i32 noundef %17) #20
  %18 = load i32, i32* %regno.addr, align 4
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 1
  %20 = load i32, i32* %off7, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.112, i64 0, i64 0), i8* noundef %call6, i32 noundef %18, i32 noundef %20) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %land.lhs.true, %if.end
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 5
  %22 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %22, i32 0, i32 0
  %24 = load i64, i64* %23, align 8
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %22, i32 0, i32 1
  %26 = load i64, i64* %25, align 8
  %call9 = call zeroext i1 @tnum_is_const(i64 %24, i64 %26) #20
  br i1 %call9, label %lor.lhs.false, label %if.then12

lor.lhs.false:                                    ; preds = %if.end8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off10, i32 0, i32 0
  %28 = load i64, i64* %value, align 8
  %tobool11 = icmp ne i64 %28, 0
  br i1 %tobool11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %lor.lhs.false, %if.end8
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 5
  %30 = bitcast %struct.tnum* %var_off13 to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call14 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %32, i64 %34) #20
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 0
  %39 = load i32, i32* %type15, align 8
  %call16 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %37, i32 noundef %39) #20
  %arraydecay17 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.113, i64 0, i64 0), i8* noundef %call16, i8* noundef %arraydecay17) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then12, %if.then4, %if.then
  %40 = load i32, i32* %retval, align 4
  ret i32 %40
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @check_mem_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %mem_size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %mem_size.addr = alloca i32, align 4
  %may_be_null = alloca i8, align 1
  %saved_reg = alloca %struct.bpf_reg_state, align 8
  %meta = alloca %struct.bpf_call_arg_meta, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %mem_size, i32* %mem_size.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %call = call zeroext i1 @type_may_be_null(i32 noundef %1) #20
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %may_be_null, align 1
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call1 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %2) #20
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = bitcast %struct.bpf_call_arg_meta* %meta to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %3, i8 0, i64 96, i1 false)
  %4 = load i8, i8* %may_be_null, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %6 = bitcast %struct.bpf_reg_state* %saved_reg to i8*
  %7 = bitcast %struct.bpf_reg_state* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %6, i8* align 8 %7, i64 120, i1 false)
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @mark_ptr_not_null_reg(%struct.bpf_reg_state* noundef %8) #20
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = load i32, i32* %regno.addr, align 4
  %11 = load i32, i32* %mem_size.addr, align 4
  %call4 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %9, i32 noundef %10, i32 noundef %11, i1 noundef zeroext true, %struct.bpf_call_arg_meta* noundef %meta) #20
  store i32 %call4, i32* %err, align 4
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 1
  store i8 1, i8* %raw_mode, align 8
  %12 = load i32, i32* %err, align 4
  %tobool5 = icmp ne i32 %12, 0
  br i1 %tobool5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end3
  br label %cond.end

cond.false:                                       ; preds = %if.end3
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = load i32, i32* %regno.addr, align 4
  %15 = load i32, i32* %mem_size.addr, align 4
  %call6 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %13, i32 noundef %14, i32 noundef %15, i1 noundef zeroext true, %struct.bpf_call_arg_meta* noundef %meta) #20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %12, %cond.true ], [ %call6, %cond.false ]
  store i32 %cond, i32* %err, align 4
  %16 = load i8, i8* %may_be_null, align 1
  %tobool7 = trunc i8 %16 to i1
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %cond.end
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %18 = bitcast %struct.bpf_reg_state* %17 to i8*
  %19 = bitcast %struct.bpf_reg_state* %saved_reg to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %18, i8* align 8 %19, i64 120, i1 false)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %cond.end
  %20 = load i32, i32* %err, align 4
  store i32 %20, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then
  %21 = load i32, i32* %retval, align 4
  ret i32 %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @type_may_be_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %and = and i32 %0, 256
  %tobool = icmp ne i32 %and, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_equals_const(i64 %5, i64 %7, i64 noundef 0) #20
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %8
}

; Function Attrs: argmemonly nofree nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #5

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_ptr_not_null_reg(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %call = call i32 @base_type(i32 noundef %1) #20
  %cmp = icmp eq i32 %call, 4
  br i1 %cmp, label %if.then, label %if.end23

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 2
  %4 = bitcast %union.anon.168* %3 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %5, %struct.bpf_map** %map, align 8
  %6 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %inner_map_meta = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %6, i32 0, i32 1
  %7 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta, align 8
  %tobool = icmp ne %struct.bpf_map* %7, null
  br i1 %tobool, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 0
  store i32 3, i32* %type2, align 8
  %9 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %inner_map_meta3 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %9, i32 0, i32 1
  %10 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta3, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 2
  %13 = bitcast %union.anon.168* %12 to %struct.anon.169*
  %map_ptr4 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %13, i32 0, i32 0
  store %struct.bpf_map* %10, %struct.bpf_map** %map_ptr4, align 8
  %14 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %inner_map_meta5 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %14, i32 0, i32 1
  %15 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta5, align 8
  %call6 = call zeroext i1 @map_value_has_timer(%struct.bpf_map* noundef %15) #20
  br i1 %call6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then1
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 3
  %17 = load i32, i32* %id, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 2
  %20 = bitcast %union.anon.168* %19 to %struct.anon.169*
  %map_uid = getelementptr inbounds %struct.anon.169, %struct.anon.169* %20, i32 0, i32 1
  store i32 %17, i32* %map_uid, align 8
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.then1
  br label %if.end22

if.else:                                          ; preds = %if.then
  %21 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %21, i32 0, i32 3
  %22 = load i32, i32* %map_type, align 8
  %cmp8 = icmp eq i32 %22, 17
  br i1 %cmp8, label %if.then9, label %if.else11

if.then9:                                         ; preds = %if.else
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 0
  store i32 15, i32* %type10, align 8
  br label %if.end21

if.else11:                                        ; preds = %if.else
  %24 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type12 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %24, i32 0, i32 3
  %25 = load i32, i32* %map_type12, align 8
  %cmp13 = icmp eq i32 %25, 15
  br i1 %cmp13, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else11
  %26 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type14 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %26, i32 0, i32 3
  %27 = load i32, i32* %map_type14, align 8
  %cmp15 = icmp eq i32 %27, 18
  br i1 %cmp15, label %if.then16, label %if.else18

if.then16:                                        ; preds = %lor.lhs.false, %if.else11
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 0
  store i32 11, i32* %type17, align 8
  br label %if.end20

if.else18:                                        ; preds = %lor.lhs.false
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 0
  store i32 4, i32* %type19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else18, %if.then16
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then9
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.end
  br label %return

if.end23:                                         ; preds = %entry
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 0
  %31 = load i32, i32* %type24, align 8
  %and = and i32 %31, -257
  store i32 %and, i32* %type24, align 8
  br label %return

return:                                           ; preds = %if.end23, %if.end22
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %access_size, i1 noundef zeroext %zero_size_allowed, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %access_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %max_access = alloca i32*, align 8
  %atype = alloca i32, align 4
  %offset = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %access_size, i32* %access_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type, align 8
  %call1 = call i32 @base_type(i32 noundef %4) #20
  switch i32 %call1, label %sw.default [
    i32 8, label %sw.bb
    i32 7, label %sw.bb
    i32 5, label %sw.bb3
    i32 4, label %sw.bb10
    i32 17, label %sw.bb22
    i32 18, label %sw.bb38
    i32 6, label %sw.bb56
    i32 2, label %sw.bb60
  ]

sw.bb:                                            ; preds = %entry, %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load i32, i32* %regno.addr, align 4
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 1
  %8 = load i32, i32* %off, align 4
  %9 = load i32, i32* %access_size.addr, align 4
  %10 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %10 to i1
  %call2 = call i32 @check_packet_access(%struct.bpf_verifier_env* noundef %5, i32 noundef %6, i32 noundef %8, i32 noundef %9, i1 noundef zeroext %tobool) #20
  store i32 %call2, i32* %retval, align 4
  br label %return

sw.bb3:                                           ; preds = %entry
  %11 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool4 = icmp ne %struct.bpf_call_arg_meta* %11, null
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %sw.bb3
  %12 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %12, i32 0, i32 1
  %13 = load i8, i8* %raw_mode, align 8
  %tobool5 = trunc i8 %13 to i1
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load i32, i32* %regno.addr, align 4
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 0
  %19 = load i32, i32* %type6, align 8
  %call7 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %17, i32 noundef %19) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.114, i64 0, i64 0), i32 noundef %16, i8* noundef %call7) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %sw.bb3
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = load i32, i32* %regno.addr, align 4
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 1
  %23 = load i32, i32* %off8, align 4
  %24 = load i32, i32* %access_size.addr, align 4
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 2
  %27 = bitcast %union.anon.168* %26 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %27, i32 0, i32 0
  %28 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %key_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %28, i32 0, i32 4
  %29 = load i32, i32* %key_size, align 4
  %call9 = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %20, i32 noundef %21, i32 noundef %23, i32 noundef %24, i32 noundef %29, i1 noundef zeroext false) #20
  store i32 %call9, i32* %retval, align 4
  br label %return

sw.bb10:                                          ; preds = %entry
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load i32, i32* %regno.addr, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 1
  %33 = load i32, i32* %off11, align 4
  %34 = load i32, i32* %access_size.addr, align 4
  %35 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool12 = icmp ne %struct.bpf_call_arg_meta* %35, null
  br i1 %tobool12, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %sw.bb10
  %36 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode13 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %36, i32 0, i32 1
  %37 = load i8, i8* %raw_mode13, align 8
  %tobool14 = trunc i8 %37 to i1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %sw.bb10
  %38 = phi i1 [ false, %sw.bb10 ], [ %tobool14, %land.rhs ]
  %39 = zext i1 %38 to i64
  %cond = select i1 %38, i32 2, i32 1
  %call15 = call i32 @check_map_access_type(%struct.bpf_verifier_env* noundef %30, i32 noundef %31, i32 noundef %33, i32 noundef %34, i32 noundef %cond) #20
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.end
  store i32 -13, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %land.end
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = load i32, i32* %regno.addr, align 4
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 1
  %43 = load i32, i32* %off19, align 4
  %44 = load i32, i32* %access_size.addr, align 4
  %45 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool20 = trunc i8 %45 to i1
  %call21 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %40, i32 noundef %41, i32 noundef %43, i32 noundef %44, i1 noundef zeroext %tobool20, i32 noundef 2) #20
  store i32 %call21, i32* %retval, align 4
  br label %return

sw.bb22:                                          ; preds = %entry
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 0
  %47 = load i32, i32* %type23, align 8
  %call24 = call zeroext i1 @type_is_rdonly_mem(i32 noundef %47) #20
  br i1 %call24, label %if.then25, label %if.end34

if.then25:                                        ; preds = %sw.bb22
  %48 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool26 = icmp ne %struct.bpf_call_arg_meta* %48, null
  br i1 %tobool26, label %land.lhs.true27, label %if.end33

land.lhs.true27:                                  ; preds = %if.then25
  %49 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode28 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %49, i32 0, i32 1
  %50 = load i8, i8* %raw_mode28, align 8
  %tobool29 = trunc i8 %50 to i1
  br i1 %tobool29, label %if.then30, label %if.end33

if.then30:                                        ; preds = %land.lhs.true27
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  %53 = load i32, i32* %regno.addr, align 4
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 0
  %56 = load i32, i32* %type31, align 8
  %call32 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %54, i32 noundef %56) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.114, i64 0, i64 0), i32 noundef %53, i8* noundef %call32) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %land.lhs.true27, %if.then25
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %sw.bb22
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = load i32, i32* %regno.addr, align 4
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 1
  %60 = load i32, i32* %off35, align 4
  %61 = load i32, i32* %access_size.addr, align 4
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %63 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 2
  %mem_size = bitcast %union.anon.168* %63 to i32*
  %64 = load i32, i32* %mem_size, align 8
  %65 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool36 = trunc i8 %65 to i1
  %call37 = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %57, i32 noundef %58, i32 noundef %60, i32 noundef %61, i32 noundef %64, i1 noundef zeroext %tobool36) #20
  store i32 %call37, i32* %retval, align 4
  br label %return

sw.bb38:                                          ; preds = %entry
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type39 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type39, align 8
  %call40 = call zeroext i1 @type_is_rdonly_mem(i32 noundef %67) #20
  br i1 %call40, label %if.then41, label %if.else

if.then41:                                        ; preds = %sw.bb38
  %68 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool42 = icmp ne %struct.bpf_call_arg_meta* %68, null
  br i1 %tobool42, label %land.lhs.true43, label %if.end49

land.lhs.true43:                                  ; preds = %if.then41
  %69 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode44 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %69, i32 0, i32 1
  %70 = load i8, i8* %raw_mode44, align 8
  %tobool45 = trunc i8 %70 to i1
  br i1 %tobool45, label %if.then46, label %if.end49

if.then46:                                        ; preds = %land.lhs.true43
  %71 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %72 = bitcast %struct.bpf_verifier_env* %71 to i8*
  %73 = load i32, i32* %regno.addr, align 4
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type47 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %75, i32 0, i32 0
  %76 = load i32, i32* %type47, align 8
  %call48 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %74, i32 noundef %76) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %72, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.114, i64 0, i64 0), i32 noundef %73, i8* noundef %call48) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end49:                                         ; preds = %land.lhs.true43, %if.then41
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %77, i32 0, i32 2
  %78 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %78, i32 0, i32 10
  %79 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_rdonly_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %79, i32 0, i32 12
  store i32* %max_rdonly_access, i32** %max_access, align 8
  br label %if.end52

if.else:                                          ; preds = %sw.bb38
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog50 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %80, i32 0, i32 2
  %81 = load %struct.bpf_prog*, %struct.bpf_prog** %prog50, align 8
  %aux51 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %81, i32 0, i32 10
  %82 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux51, align 8
  %max_rdwr_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %82, i32 0, i32 13
  store i32* %max_rdwr_access, i32** %max_access, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.else, %if.end49
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %85 = load i32, i32* %regno.addr, align 4
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 1
  %87 = load i32, i32* %off53, align 4
  %88 = load i32, i32* %access_size.addr, align 4
  %89 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool54 = trunc i8 %89 to i1
  %90 = load i32*, i32** %max_access, align 8
  %call55 = call i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %83, %struct.bpf_reg_state* noundef %84, i32 noundef %85, i32 noundef %87, i32 noundef %88, i1 noundef zeroext %tobool54, i32* noundef %90) #20
  store i32 %call55, i32* %retval, align 4
  br label %return

sw.bb56:                                          ; preds = %entry
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %92 = load i32, i32* %regno.addr, align 4
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off57 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %93, i32 0, i32 1
  %94 = load i32, i32* %off57, align 4
  %95 = load i32, i32* %access_size.addr, align 4
  %96 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool58 = trunc i8 %96 to i1
  %97 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call59 = call i32 @check_stack_range_initialized(%struct.bpf_verifier_env* noundef %91, i32 noundef %92, i32 noundef %94, i32 noundef %95, i1 noundef zeroext %tobool58, i32 noundef 2, %struct.bpf_call_arg_meta* noundef %97) #20
  store i32 %call59, i32* %retval, align 4
  br label %return

sw.bb60:                                          ; preds = %entry
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %98, i32 0, i32 3
  %99 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %convert_ctx_access = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %99, i32 0, i32 4
  %100 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  %tobool61 = icmp ne i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* %100, null
  br i1 %tobool61, label %if.end74, label %if.then62

if.then62:                                        ; preds = %sw.bb60
  %101 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool63 = icmp ne %struct.bpf_call_arg_meta* %101, null
  br i1 %tobool63, label %land.rhs64, label %land.end67

land.rhs64:                                       ; preds = %if.then62
  %102 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode65 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %102, i32 0, i32 1
  %103 = load i8, i8* %raw_mode65, align 8
  %tobool66 = trunc i8 %103 to i1
  br label %land.end67

land.end67:                                       ; preds = %land.rhs64, %if.then62
  %104 = phi i1 [ false, %if.then62 ], [ %tobool66, %land.rhs64 ]
  %105 = zext i1 %104 to i64
  %cond68 = select i1 %104, i32 2, i32 1
  store i32 %cond68, i32* %atype, align 4
  %106 = load i32, i32* %access_size.addr, align 4
  %sub = sub i32 %106, 1
  store i32 %sub, i32* %offset, align 4
  %107 = load i32, i32* %access_size.addr, align 4
  %cmp = icmp eq i32 %107, 0
  br i1 %cmp, label %if.then69, label %if.end72

if.then69:                                        ; preds = %land.end67
  %108 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool70 = trunc i8 %108 to i1
  %109 = zext i1 %tobool70 to i64
  %cond71 = select i1 %tobool70, i32 0, i32 -13
  store i32 %cond71, i32* %retval, align 4
  br label %return

if.end72:                                         ; preds = %land.end67
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %111 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %111, i32 0, i32 0
  %112 = load i32, i32* %insn_idx, align 8
  %113 = load i32, i32* %regno.addr, align 4
  %114 = load i32, i32* %offset, align 4
  %115 = load i32, i32* %atype, align 4
  %call73 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %110, i32 noundef %112, i32 noundef %113, i32 noundef %114, i32 noundef 16, i32 noundef %115, i32 noundef -1, i1 noundef zeroext false) #20
  store i32 %call73, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %sw.bb60
  br label %sw.default

sw.default:                                       ; preds = %entry, %if.end74
  %116 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool75 = trunc i8 %116 to i1
  br i1 %tobool75, label %land.lhs.true76, label %if.end81

land.lhs.true76:                                  ; preds = %sw.default
  %117 = load i32, i32* %access_size.addr, align 4
  %cmp77 = icmp eq i32 %117, 0
  br i1 %cmp77, label %land.lhs.true78, label %if.end81

land.lhs.true78:                                  ; preds = %land.lhs.true76
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call79 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %118) #20
  br i1 %call79, label %if.then80, label %if.end81

if.then80:                                        ; preds = %land.lhs.true78
  store i32 0, i32* %retval, align 4
  br label %return

if.end81:                                         ; preds = %land.lhs.true78, %land.lhs.true76, %sw.default
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %120 = bitcast %struct.bpf_verifier_env* %119 to i8*
  %121 = load i32, i32* %regno.addr, align 4
  %122 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %123 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type82 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %123, i32 0, i32 0
  %124 = load i32, i32* %type82, align 8
  %call83 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %122, i32 noundef %124) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %120, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.115, i64 0, i64 0), i32 noundef %121, i8* noundef %call83) #20
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %126 = bitcast %struct.bpf_verifier_env* %125 to i8*
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call84 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %127, i32 noundef 6) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %126, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.116, i64 0, i64 0), i8* noundef %call84) #20
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end81, %if.then80, %if.end72, %if.then69, %sw.bb56, %if.end52, %if.then46, %if.end34, %if.then30, %if.end18, %if.then17, %if.end, %if.then, %sw.bb
  %128 = load i32, i32* %retval, align 4
  ret i32 %128
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @check_kfunc_mem_size_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %mem_reg = alloca %struct.bpf_reg_state*, align 8
  %may_be_null = alloca i8, align 1
  %saved_reg = alloca %struct.bpf_reg_state, align 8
  %meta = alloca %struct.bpf_call_arg_meta, align 8
  %err = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  %1 = load i32, i32* %regno.addr, align 4
  %sub = sub i32 %1, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %mem_reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %mem_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @type_may_be_null(i32 noundef %3) #20
  %frombool = zext i1 %call1 to i8
  store i8 %frombool, i8* %may_be_null, align 1
  %4 = load i32, i32* %regno.addr, align 4
  %cmp = icmp ult i32 %4, 2
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %5 = load i32, i32* %regno.addr, align 4
  %cmp2 = icmp ugt i32 %5, 5
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %6 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  %lnot = xor i1 %6, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %7, 0
  %lnot4 = xor i1 %tobool, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %tobool8 = icmp ne i64 %conv, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  br label %do.body

do.body:                                          ; preds = %if.then
  store i32 2307, i32* %__flags, align 4
  br label %do.body9

do.body9:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body9
  br label %do.body10

do.body10:                                        ; preds = %do.end
  %8 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 5478, i32 %8, i64 12) #19, !srcloc !17
  br label %do.end11

do.end11:                                         ; preds = %do.body10
  br label %do.body12

do.body12:                                        ; preds = %do.end11
  br label %do.end13

do.end13:                                         ; preds = %do.body12
  br label %do.end14

do.end14:                                         ; preds = %do.end13
  br label %if.end

if.end:                                           ; preds = %do.end14, %lor.end
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool15 = icmp ne i32 %9, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  store i64 %conv20, i64* %tmp, align 8
  %10 = load i64, i64* %tmp, align 8
  %11 = bitcast %struct.bpf_call_arg_meta* %meta to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %11, i8 0, i64 96, i1 false)
  %12 = load i8, i8* %may_be_null, align 1
  %tobool21 = trunc i8 %12 to i1
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %mem_reg, align 8
  %14 = bitcast %struct.bpf_reg_state* %saved_reg to i8*
  %15 = bitcast %struct.bpf_reg_state* %13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 8 %15, i64 120, i1 false)
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %mem_reg, align 8
  call void @mark_ptr_not_null_reg(%struct.bpf_reg_state* noundef %16) #20
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.end
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %19 = load i32, i32* %regno.addr, align 4
  %call24 = call i32 @check_mem_size_reg(%struct.bpf_verifier_env* noundef %17, %struct.bpf_reg_state* noundef %18, i32 noundef %19, i1 noundef zeroext true, %struct.bpf_call_arg_meta* noundef %meta) #20
  store i32 %call24, i32* %err, align 4
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 1
  store i8 1, i8* %raw_mode, align 8
  %20 = load i32, i32* %err, align 4
  %tobool25 = icmp ne i32 %20, 0
  br i1 %tobool25, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end23
  br label %cond.end

cond.false:                                       ; preds = %if.end23
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %23 = load i32, i32* %regno.addr, align 4
  %call26 = call i32 @check_mem_size_reg(%struct.bpf_verifier_env* noundef %21, %struct.bpf_reg_state* noundef %22, i32 noundef %23, i1 noundef zeroext true, %struct.bpf_call_arg_meta* noundef %meta) #20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %20, %cond.true ], [ %call26, %cond.false ]
  store i32 %cond, i32* %err, align 4
  %24 = load i8, i8* %may_be_null, align 1
  %tobool27 = trunc i8 %24 to i1
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %cond.end
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %mem_reg, align 8
  %26 = bitcast %struct.bpf_reg_state* %25 to i8*
  %27 = bitcast %struct.bpf_reg_state* %saved_reg to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %26, i8* align 8 %27, i64 120, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %cond.end
  %28 = load i32, i32* %err, align 4
  ret i32 %28
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #20
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %call, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  ret %struct.bpf_reg_state* %arraydecay
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_mem_size_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i1 noundef zeroext %zero_size_allowed, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 9
  %1 = load i64, i64* %umax_value, align 8
  %2 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_max_value = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %2, i32 0, i32 7
  store i64 %1, i64* %msize_max_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 5
  %4 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 0
  %6 = load i64, i64* %5, align 8
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 1
  %8 = load i64, i64* %7, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %6, i64 %8) #20
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct.bpf_call_arg_meta* null, %struct.bpf_call_arg_meta** %meta.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 6
  %10 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %10, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  %13 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([66 x i8], [66 x i8]* @.str.205, i64 0, i64 0), i32 noundef %13) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end2:                                          ; preds = %if.end
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 8
  %15 = load i64, i64* %umin_value, align 8
  %cmp3 = icmp eq i64 %15, 0
  br i1 %cmp3, label %if.then4, label %if.end9

if.then4:                                         ; preds = %if.end2
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load i32, i32* %regno.addr, align 4
  %sub = sub i32 %17, 1
  %18 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %18 to i1
  %19 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call5 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %16, i32 noundef %sub, i32 noundef 0, i1 noundef zeroext %tobool, %struct.bpf_call_arg_meta* noundef %19) #20
  store i32 %call5, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool6 = icmp ne i32 %20, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.then4
  %21 = load i32, i32* %err, align 4
  store i32 %21, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.then4
  br label %if.end9

if.end9:                                          ; preds = %if.end8, %if.end2
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 9
  %23 = load i64, i64* %umax_value10, align 8
  %cmp11 = icmp uge i64 %23, 536870912
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  %26 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([71 x i8], [71 x i8]* @.str.206, i64 0, i64 0), i32 noundef %26) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end9
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load i32, i32* %regno.addr, align 4
  %sub14 = sub i32 %28, 1
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 9
  %30 = load i64, i64* %umax_value15, align 8
  %conv = trunc i64 %30 to i32
  %31 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool16 = trunc i8 %31 to i1
  %32 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call17 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %27, i32 noundef %sub14, i32 noundef %conv, i1 noundef zeroext %tobool16, %struct.bpf_call_arg_meta* noundef %32) #20
  store i32 %call17, i32* %err, align 4
  %33 = load i32, i32* %err, align 4
  %tobool18 = icmp ne i32 %33, 0
  br i1 %tobool18, label %if.end21, label %if.then19

if.then19:                                        ; preds = %if.end13
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = load i32, i32* %regno.addr, align 4
  %call20 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %34, i32 noundef %35) #20
  store i32 %call20, i32* %err, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.end13
  %36 = load i32, i32* %err, align 4
  store i32 %36, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end21, %if.then12, %if.then7, %if.then1
  %37 = load i32, i32* %retval, align 4
  ret i32 %37
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @check_func_arg_reg_off(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %arg_type) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %arg_type.addr = alloca i32, align 4
  %type = alloca i32, align 4
  %fixed_off_ok = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %arg_type, i32* %arg_type.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type1, align 8
  store i32 %1, i32* %type, align 4
  store i8 0, i8* %fixed_off_ok, align 1
  %2 = load i32, i32* %type, align 4
  switch i32 %2, label %sw.default [
    i32 6, label %sw.bb
    i32 8, label %sw.bb2
    i32 7, label %sw.bb2
    i32 5, label %sw.bb2
    i32 4, label %sw.bb2
    i32 17, label %sw.bb2
    i32 529, label %sw.bb2
    i32 1041, label %sw.bb2
    i32 18, label %sw.bb2
    i32 530, label %sw.bb2
    i32 1, label %sw.bb2
    i32 16, label %sw.bb6
  ]

sw.bb:                                            ; preds = %entry
  %3 = load i32, i32* %arg_type.addr, align 4
  %call = call zeroext i1 @arg_type_is_dynptr(i32 noundef %3) #20
  br i1 %call, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %sw.bb
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 1
  %5 = load i32, i32* %off, align 4
  %rem = srem i32 %5, 8
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.5, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %sw.bb
  br label %sw.bb2

sw.bb2:                                           ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %if.end
  %8 = load i32, i32* %arg_type.addr, align 4
  %call3 = call i32 @base_type(i32 noundef %8) #20
  %cmp = icmp ne i32 %call3, 15
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %sw.bb2
  store i32 0, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %sw.bb2
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %9 = load i32, i32* %arg_type.addr, align 4
  %call7 = call zeroext i1 @arg_type_is_release(i32 noundef %9) #20
  br i1 %call7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %sw.bb6
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 1
  %11 = load i32, i32* %off9, align 4
  %tobool10 = icmp ne i32 %11, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.6, i64 0, i64 0), i32 noundef %14) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %land.lhs.true8, %sw.bb6
  store i8 1, i8* %fixed_off_ok, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end12, %if.end5
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %17 = load i32, i32* %regno.addr, align 4
  %18 = load i8, i8* %fixed_off_ok, align 1
  %tobool13 = trunc i8 %18 to i1
  %call14 = call i32 @__check_ptr_off_reg(%struct.bpf_verifier_env* noundef %15, %struct.bpf_reg_state* noundef %16, i32 noundef %17, i1 noundef zeroext %tobool13) #20
  store i32 %call14, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then11, %if.then4, %if.then
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_dynptr(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %call = call i32 @base_type(i32 noundef %0) #20
  %cmp = icmp eq i32 %call, 24
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @verbose(i8* noundef %private_data, i8* noundef %fmt, ...) #0 {
entry:
  %private_data.addr = alloca i8*, align 8
  %fmt.addr = alloca i8*, align 8
  %env = alloca %struct.bpf_verifier_env*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store i8* %private_data, i8** %private_data.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %0 = load i8*, i8** %private_data.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_verifier_env*
  store %struct.bpf_verifier_env* %1, %struct.bpf_verifier_env** %env, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 26
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #20
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 26
  %4 = load i8*, i8** %fmt.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log2, i8* noundef %4, %struct.__va_list_tag* noundef %arraydecay3) #20
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @base_type(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %conv = zext i32 %0 to i64
  %and = and i64 %conv, 255
  %conv1 = trunc i64 %and to i32
  ret i32 %conv1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_release(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %and = and i32 %0, 8192
  %tobool = icmp ne i32 %and, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @map_set_for_each_callback_args(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %caller, %struct.bpf_func_state* noundef %callee) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %caller.addr = alloca %struct.bpf_func_state*, align 8
  %callee.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %caller, %struct.bpf_func_state** %caller.addr, align 8
  store %struct.bpf_func_state* %callee, %struct.bpf_func_state** %callee.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 1
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 1
  %2 = bitcast %struct.bpf_reg_state* %arrayidx to i8*
  %3 = bitcast %struct.bpf_reg_state* %arrayidx2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 %3, i64 120, i1 false)
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arrayidx4 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs3, i64 0, i64 2
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx4, i32 0, i32 0
  store i32 5, i32* %type, align 8
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 0
  %arrayidx6 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs5, i64 0, i64 2
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %arrayidx6) #20
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arrayidx8 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs7, i64 0, i64 1
  %7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx8, i32 0, i32 2
  %8 = bitcast %union.anon.168* %7 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %8, i32 0, i32 0
  %9 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs9 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 0
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs9, i64 0, i64 2
  %11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx10, i32 0, i32 2
  %12 = bitcast %union.anon.168* %11 to %struct.anon.169*
  %map_ptr11 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %12, i32 0, i32 0
  store %struct.bpf_map* %9, %struct.bpf_map** %map_ptr11, align 8
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs12 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 0
  %arrayidx13 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs12, i64 0, i64 3
  %type14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx13, i32 0, i32 0
  store i32 4, i32* %type14, align 8
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 0
  %arrayidx16 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs15, i64 0, i64 3
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %arrayidx16) #20
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs17 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 0
  %arrayidx18 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs17, i64 0, i64 1
  %16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx18, i32 0, i32 2
  %17 = bitcast %union.anon.168* %16 to %struct.anon.169*
  %map_ptr19 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %17, i32 0, i32 0
  %18 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr19, align 8
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs20 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 0
  %arrayidx21 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs20, i64 0, i64 3
  %20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx21, i32 0, i32 2
  %21 = bitcast %union.anon.168* %20 to %struct.anon.169*
  %map_ptr22 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %21, i32 0, i32 0
  store %struct.bpf_map* %18, %struct.bpf_map** %map_ptr22, align 8
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs23 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 0
  %arrayidx24 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs23, i64 0, i64 4
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs25 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 0
  %arrayidx26 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs25, i64 0, i64 3
  %24 = bitcast %struct.bpf_reg_state* %arrayidx24 to i8*
  %25 = bitcast %struct.bpf_reg_state* %arrayidx26 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %24, i8* align 8 %25, i64 120, i1 false)
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs27 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 0
  %arrayidx28 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs27, i64 0, i64 5
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %26, %struct.bpf_reg_state* noundef %arrayidx28) #20
  ret i32 0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %0, i64 noundef 0) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %0, %struct.bpf_reg_state* noundef %1) #20
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 0, i32* %type, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @reg_bounds_sync___(%struct.bpf_reg_state* noundef %dst_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @reg_bounds_sync(%struct.bpf_reg_state* noundef %0) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_bounds_sync(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %0) #20
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %1) #20
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %2) #20
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %3) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ADD(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %src_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %opcode = alloca i8, align 1
  %src_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  %s32_min_val = alloca i32, align 4
  %s32_max_val = alloca i32, align 4
  %u32_min_val = alloca i32, align 4
  %u32_max_val = alloca i32, align 4
  %insn_bitness = alloca i64, align 8
  %alu32 = alloca i8, align 1
  %ret = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  %tmp78 = alloca %struct.tnum, align 8
  %tmp84 = alloca %struct.tnum, align 8
  %tmp90 = alloca %struct.tnum, align 8
  %tmp96 = alloca %struct.tnum, align 8
  %tmp102 = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 0
  %2 = load i8, i8* %code, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %opcode, align 1
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %3, i32 0, i32 0
  %4 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %4 to i32
  %and4 = and i32 %conv3, 7
  %cmp = icmp eq i32 %and4, 7
  %5 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 64, i32 32
  %conv6 = sext i32 %cond to i64
  store i64 %conv6, i64* %insn_bitness, align 8
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code7, align 4
  %conv8 = zext i8 %7 to i32
  %and9 = and i32 %conv8, 7
  %cmp10 = icmp ne i32 %and9, 7
  %frombool = zext i1 %cmp10 to i8
  store i8 %frombool, i8* %alu32, align 1
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 6
  %8 = load i64, i64* %smin_value, align 8
  store i64 %8, i64* %smin_val, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 7
  %9 = load i64, i64* %smax_value, align 8
  store i64 %9, i64* %smax_val, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 8
  %10 = load i64, i64* %umin_value, align 8
  store i64 %10, i64* %umin_val, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 9
  %11 = load i64, i64* %umax_value, align 8
  store i64 %11, i64* %umax_val, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 10
  %12 = load i32, i32* %s32_min_value, align 8
  store i32 %12, i32* %s32_min_val, align 4
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 11
  %13 = load i32, i32* %s32_max_value, align 4
  store i32 %13, i32* %s32_max_val, align 4
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 12
  %14 = load i32, i32* %u32_min_value, align 8
  store i32 %14, i32* %u32_min_val, align 4
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 13
  %15 = load i32, i32* %u32_max_value, align 4
  store i32 %15, i32* %u32_max_val, align 4
  %16 = load i8, i8* %alu32, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %17 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = load i64, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = load i64, i64* %20, align 8
  %call12 = call zeroext i1 @tnum_subreg_is_const(i64 %19, i64 %21) #20
  %frombool13 = zext i1 %call12 to i8
  store i8 %frombool13, i8* %src_known, align 1
  %22 = load i8, i8* %src_known, align 1
  %tobool14 = trunc i8 %22 to i1
  br i1 %tobool14, label %land.lhs.true, label %lor.lhs.false20

land.lhs.true:                                    ; preds = %if.then
  %23 = load i32, i32* %s32_min_val, align 4
  %24 = load i32, i32* %s32_max_val, align 4
  %cmp16 = icmp ne i32 %23, %24
  br i1 %cmp16, label %if.then26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %25 = load i32, i32* %u32_min_val, align 4
  %26 = load i32, i32* %u32_max_val, align 4
  %cmp18 = icmp ne i32 %25, %26
  br i1 %cmp18, label %if.then26, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false, %if.then
  %27 = load i32, i32* %s32_min_val, align 4
  %28 = load i32, i32* %s32_max_val, align 4
  %cmp21 = icmp sgt i32 %27, %28
  br i1 %cmp21, label %if.then26, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %lor.lhs.false20
  %29 = load i32, i32* %u32_min_val, align 4
  %30 = load i32, i32* %u32_max_val, align 4
  %cmp24 = icmp ugt i32 %29, %30
  br i1 %cmp24, label %if.then26, label %if.end

if.then26:                                        ; preds = %lor.lhs.false23, %lor.lhs.false20, %lor.lhs.false, %land.lhs.true
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %31, %struct.bpf_reg_state* noundef %32) #20
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false23
  br label %if.end46

if.else:                                          ; preds = %entry
  %var_off27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %33 = bitcast %struct.tnum* %var_off27 to { i64, i64 }*
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %33, i32 0, i32 0
  %35 = load i64, i64* %34, align 8
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %33, i32 0, i32 1
  %37 = load i64, i64* %36, align 8
  %call28 = call zeroext i1 @tnum_is_const(i64 %35, i64 %37) #20
  %frombool29 = zext i1 %call28 to i8
  store i8 %frombool29, i8* %src_known, align 1
  %38 = load i8, i8* %src_known, align 1
  %tobool30 = trunc i8 %38 to i1
  br i1 %tobool30, label %land.lhs.true32, label %lor.lhs.false38

land.lhs.true32:                                  ; preds = %if.else
  %39 = load i64, i64* %smin_val, align 8
  %40 = load i64, i64* %smax_val, align 8
  %cmp33 = icmp ne i64 %39, %40
  br i1 %cmp33, label %if.then44, label %lor.lhs.false35

lor.lhs.false35:                                  ; preds = %land.lhs.true32
  %41 = load i64, i64* %umin_val, align 8
  %42 = load i64, i64* %umax_val, align 8
  %cmp36 = icmp ne i64 %41, %42
  br i1 %cmp36, label %if.then44, label %lor.lhs.false38

lor.lhs.false38:                                  ; preds = %lor.lhs.false35, %if.else
  %43 = load i64, i64* %smin_val, align 8
  %44 = load i64, i64* %smax_val, align 8
  %cmp39 = icmp sgt i64 %43, %44
  br i1 %cmp39, label %if.then44, label %lor.lhs.false41

lor.lhs.false41:                                  ; preds = %lor.lhs.false38
  %45 = load i64, i64* %umin_val, align 8
  %46 = load i64, i64* %umax_val, align 8
  %cmp42 = icmp ugt i64 %45, %46
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %lor.lhs.false41, %lor.lhs.false38, %lor.lhs.false35, %land.lhs.true32
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %47, %struct.bpf_reg_state* noundef %48) #20
  store i32 0, i32* %retval, align 4
  br label %return

if.end45:                                         ; preds = %lor.lhs.false41
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %if.end
  %49 = load i8, i8* %src_known, align 1
  %tobool47 = trunc i8 %49 to i1
  br i1 %tobool47, label %if.end61, label %land.lhs.true48

land.lhs.true48:                                  ; preds = %if.end46
  %50 = load i8, i8* %opcode, align 1
  %conv49 = zext i8 %50 to i32
  %cmp50 = icmp ne i32 %conv49, 0
  br i1 %cmp50, label %land.lhs.true52, label %if.end61

land.lhs.true52:                                  ; preds = %land.lhs.true48
  %51 = load i8, i8* %opcode, align 1
  %conv53 = zext i8 %51 to i32
  %cmp54 = icmp ne i32 %conv53, 16
  br i1 %cmp54, label %land.lhs.true56, label %if.end61

land.lhs.true56:                                  ; preds = %land.lhs.true52
  %52 = load i8, i8* %opcode, align 1
  %conv57 = zext i8 %52 to i32
  %cmp58 = icmp ne i32 %conv57, 80
  br i1 %cmp58, label %if.then60, label %if.end61

if.then60:                                        ; preds = %land.lhs.true56
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %53, %struct.bpf_reg_state* noundef %54) #20
  store i32 0, i32* %retval, align 4
  br label %return

if.end61:                                         ; preds = %land.lhs.true56, %land.lhs.true52, %land.lhs.true48, %if.end46
  %55 = load i8, i8* %opcode, align 1
  %call62 = call zeroext i1 @sanitize_needed(i8 noundef zeroext %55) #20
  br i1 %call62, label %if.then63, label %if.end70

if.then63:                                        ; preds = %if.end61
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call64 = call i32 @sanitize_val_alu(%struct.bpf_verifier_env* noundef %56, %struct.bpf_insn* noundef %57) #20
  store i32 %call64, i32* %ret, align 4
  %58 = load i32, i32* %ret, align 4
  %cmp65 = icmp slt i32 %58, 0
  br i1 %cmp65, label %if.then67, label %if.end69

if.then67:                                        ; preds = %if.then63
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %61 = load i32, i32* %ret, align 4
  %call68 = call i32 @sanitize_err(%struct.bpf_verifier_env* noundef %59, %struct.bpf_insn* noundef %60, i32 noundef %61, %struct.bpf_reg_state* noundef null, %struct.bpf_reg_state* noundef null) #20
  store i32 %call68, i32* %retval, align 4
  br label %return

if.end69:                                         ; preds = %if.then63
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.end61
  %62 = load i8, i8* %opcode, align 1
  %conv71 = zext i8 %62 to i32
  switch i32 %conv71, label %sw.default [
    i32 0, label %sw.bb
    i32 16, label %sw.bb76
    i32 32, label %sw.bb82
    i32 80, label %sw.bb88
    i32 64, label %sw.bb94
    i32 160, label %sw.bb100
    i32 96, label %sw.bb106
    i32 112, label %sw.bb115
    i32 192, label %sw.bb124
  ]

sw.bb:                                            ; preds = %if.end70
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_add(%struct.bpf_reg_state* noundef %63, %struct.bpf_reg_state* noundef %src_reg) #20
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_add(%struct.bpf_reg_state* noundef %64, %struct.bpf_reg_state* noundef %src_reg) #20
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off72 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 5
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 5
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %67 = bitcast %struct.tnum* %var_off73 to { i64, i64 }*
  %68 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 0
  %69 = load i64, i64* %68, align 8
  %70 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %67, i32 0, i32 1
  %71 = load i64, i64* %70, align 8
  %72 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %73 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %72, i32 0, i32 0
  %74 = load i64, i64* %73, align 8
  %75 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %72, i32 0, i32 1
  %76 = load i64, i64* %75, align 8
  %call75 = call { i64, i64 } @tnum_add(i64 %69, i64 %71, i64 %74, i64 %76) #20
  %77 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %78 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %77, i32 0, i32 0
  %79 = extractvalue { i64, i64 } %call75, 0
  store i64 %79, i64* %78, align 8
  %80 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %77, i32 0, i32 1
  %81 = extractvalue { i64, i64 } %call75, 1
  store i64 %81, i64* %80, align 8
  %82 = bitcast %struct.tnum* %var_off72 to i8*
  %83 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %82, i8* align 8 %83, i64 16, i1 false)
  br label %sw.epilog

sw.bb76:                                          ; preds = %if.end70
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_sub(%struct.bpf_reg_state* noundef %84, %struct.bpf_reg_state* noundef %src_reg) #20
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_sub(%struct.bpf_reg_state* noundef %85, %struct.bpf_reg_state* noundef %src_reg) #20
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off77 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 5
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off79 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %87, i32 0, i32 5
  %var_off80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %88 = bitcast %struct.tnum* %var_off79 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %93 = bitcast %struct.tnum* %var_off80 to { i64, i64 }*
  %94 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %93, i32 0, i32 0
  %95 = load i64, i64* %94, align 8
  %96 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %93, i32 0, i32 1
  %97 = load i64, i64* %96, align 8
  %call81 = call { i64, i64 } @tnum_sub(i64 %90, i64 %92, i64 %95, i64 %97) #20
  %98 = bitcast %struct.tnum* %tmp78 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = extractvalue { i64, i64 } %call81, 0
  store i64 %100, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = extractvalue { i64, i64 } %call81, 1
  store i64 %102, i64* %101, align 8
  %103 = bitcast %struct.tnum* %var_off77 to i8*
  %104 = bitcast %struct.tnum* %tmp78 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %103, i8* align 8 %104, i64 16, i1 false)
  br label %sw.epilog

sw.bb82:                                          ; preds = %if.end70
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off83 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %105, i32 0, i32 5
  %106 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %106, i32 0, i32 5
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %107 = bitcast %struct.tnum* %var_off85 to { i64, i64 }*
  %108 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %107, i32 0, i32 0
  %109 = load i64, i64* %108, align 8
  %110 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %107, i32 0, i32 1
  %111 = load i64, i64* %110, align 8
  %112 = bitcast %struct.tnum* %var_off86 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call87 = call { i64, i64 } @tnum_mul(i64 %109, i64 %111, i64 %114, i64 %116) #20
  %117 = bitcast %struct.tnum* %tmp84 to { i64, i64 }*
  %118 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %117, i32 0, i32 0
  %119 = extractvalue { i64, i64 } %call87, 0
  store i64 %119, i64* %118, align 8
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %117, i32 0, i32 1
  %121 = extractvalue { i64, i64 } %call87, 1
  store i64 %121, i64* %120, align 8
  %122 = bitcast %struct.tnum* %var_off83 to i8*
  %123 = bitcast %struct.tnum* %tmp84 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %122, i8* align 8 %123, i64 16, i1 false)
  %124 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_mul(%struct.bpf_reg_state* noundef %124, %struct.bpf_reg_state* noundef %src_reg) #20
  %125 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_mul(%struct.bpf_reg_state* noundef %125, %struct.bpf_reg_state* noundef %src_reg) #20
  br label %sw.epilog

sw.bb88:                                          ; preds = %if.end70
  %126 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off89 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %126, i32 0, i32 5
  %127 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off91 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %127, i32 0, i32 5
  %var_off92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %128 = bitcast %struct.tnum* %var_off91 to { i64, i64 }*
  %129 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %128, i32 0, i32 0
  %130 = load i64, i64* %129, align 8
  %131 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %128, i32 0, i32 1
  %132 = load i64, i64* %131, align 8
  %133 = bitcast %struct.tnum* %var_off92 to { i64, i64 }*
  %134 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %133, i32 0, i32 0
  %135 = load i64, i64* %134, align 8
  %136 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %133, i32 0, i32 1
  %137 = load i64, i64* %136, align 8
  %call93 = call { i64, i64 } @tnum_and(i64 %130, i64 %132, i64 %135, i64 %137) #20
  %138 = bitcast %struct.tnum* %tmp90 to { i64, i64 }*
  %139 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %138, i32 0, i32 0
  %140 = extractvalue { i64, i64 } %call93, 0
  store i64 %140, i64* %139, align 8
  %141 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %138, i32 0, i32 1
  %142 = extractvalue { i64, i64 } %call93, 1
  store i64 %142, i64* %141, align 8
  %143 = bitcast %struct.tnum* %var_off89 to i8*
  %144 = bitcast %struct.tnum* %tmp90 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %143, i8* align 8 %144, i64 16, i1 false)
  %145 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_and(%struct.bpf_reg_state* noundef %145, %struct.bpf_reg_state* noundef %src_reg) #20
  %146 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_and(%struct.bpf_reg_state* noundef %146, %struct.bpf_reg_state* noundef %src_reg) #20
  br label %sw.epilog

sw.bb94:                                          ; preds = %if.end70
  %147 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %147, i32 0, i32 5
  %148 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off97 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %148, i32 0, i32 5
  %var_off98 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %149 = bitcast %struct.tnum* %var_off97 to { i64, i64 }*
  %150 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %149, i32 0, i32 0
  %151 = load i64, i64* %150, align 8
  %152 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %149, i32 0, i32 1
  %153 = load i64, i64* %152, align 8
  %154 = bitcast %struct.tnum* %var_off98 to { i64, i64 }*
  %155 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %154, i32 0, i32 0
  %156 = load i64, i64* %155, align 8
  %157 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %154, i32 0, i32 1
  %158 = load i64, i64* %157, align 8
  %call99 = call { i64, i64 } @tnum_or(i64 %151, i64 %153, i64 %156, i64 %158) #20
  %159 = bitcast %struct.tnum* %tmp96 to { i64, i64 }*
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 0
  %161 = extractvalue { i64, i64 } %call99, 0
  store i64 %161, i64* %160, align 8
  %162 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 1
  %163 = extractvalue { i64, i64 } %call99, 1
  store i64 %163, i64* %162, align 8
  %164 = bitcast %struct.tnum* %var_off95 to i8*
  %165 = bitcast %struct.tnum* %tmp96 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %164, i8* align 8 %165, i64 16, i1 false)
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_or(%struct.bpf_reg_state* noundef %166, %struct.bpf_reg_state* noundef %src_reg) #20
  %167 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_or(%struct.bpf_reg_state* noundef %167, %struct.bpf_reg_state* noundef %src_reg) #20
  br label %sw.epilog

sw.bb100:                                         ; preds = %if.end70
  %168 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off101 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %168, i32 0, i32 5
  %169 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %169, i32 0, i32 5
  %var_off104 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %170 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %171 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %170, i32 0, i32 0
  %172 = load i64, i64* %171, align 8
  %173 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %170, i32 0, i32 1
  %174 = load i64, i64* %173, align 8
  %175 = bitcast %struct.tnum* %var_off104 to { i64, i64 }*
  %176 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %175, i32 0, i32 0
  %177 = load i64, i64* %176, align 8
  %178 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %175, i32 0, i32 1
  %179 = load i64, i64* %178, align 8
  %call105 = call { i64, i64 } @tnum_xor(i64 %172, i64 %174, i64 %177, i64 %179) #20
  %180 = bitcast %struct.tnum* %tmp102 to { i64, i64 }*
  %181 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %180, i32 0, i32 0
  %182 = extractvalue { i64, i64 } %call105, 0
  store i64 %182, i64* %181, align 8
  %183 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %180, i32 0, i32 1
  %184 = extractvalue { i64, i64 } %call105, 1
  store i64 %184, i64* %183, align 8
  %185 = bitcast %struct.tnum* %var_off101 to i8*
  %186 = bitcast %struct.tnum* %tmp102 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %185, i8* align 8 %186, i64 16, i1 false)
  %187 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_xor(%struct.bpf_reg_state* noundef %187, %struct.bpf_reg_state* noundef %src_reg) #20
  %188 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_xor(%struct.bpf_reg_state* noundef %188, %struct.bpf_reg_state* noundef %src_reg) #20
  br label %sw.epilog

sw.bb106:                                         ; preds = %if.end70
  %189 = load i64, i64* %umax_val, align 8
  %190 = load i64, i64* %insn_bitness, align 8
  %cmp107 = icmp uge i64 %189, %190
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %sw.bb106
  %191 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %191) #20
  br label %sw.epilog

if.end110:                                        ; preds = %sw.bb106
  %192 = load i8, i8* %alu32, align 1
  %tobool111 = trunc i8 %192 to i1
  br i1 %tobool111, label %if.then112, label %if.else113

if.then112:                                       ; preds = %if.end110
  %193 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %193, %struct.bpf_reg_state* noundef %src_reg) #20
  br label %if.end114

if.else113:                                       ; preds = %if.end110
  %194 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_lsh(%struct.bpf_reg_state* noundef %194, %struct.bpf_reg_state* noundef %src_reg) #20
  br label %if.end114

if.end114:                                        ; preds = %if.else113, %if.then112
  br label %sw.epilog

sw.bb115:                                         ; preds = %if.end70
  %195 = load i64, i64* %umax_val, align 8
  %196 = load i64, i64* %insn_bitness, align 8
  %cmp116 = icmp uge i64 %195, %196
  br i1 %cmp116, label %if.then118, label %if.end119

if.then118:                                       ; preds = %sw.bb115
  %197 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %197) #20
  br label %sw.epilog

if.end119:                                        ; preds = %sw.bb115
  %198 = load i8, i8* %alu32, align 1
  %tobool120 = trunc i8 %198 to i1
  br i1 %tobool120, label %if.then121, label %if.else122

if.then121:                                       ; preds = %if.end119
  %199 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_rsh(%struct.bpf_reg_state* noundef %199, %struct.bpf_reg_state* noundef %src_reg) #20
  br label %if.end123

if.else122:                                       ; preds = %if.end119
  %200 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_rsh(%struct.bpf_reg_state* noundef %200, %struct.bpf_reg_state* noundef %src_reg) #20
  br label %if.end123

if.end123:                                        ; preds = %if.else122, %if.then121
  br label %sw.epilog

sw.bb124:                                         ; preds = %if.end70
  %201 = load i64, i64* %umax_val, align 8
  %202 = load i64, i64* %insn_bitness, align 8
  %cmp125 = icmp uge i64 %201, %202
  br i1 %cmp125, label %if.then127, label %if.end128

if.then127:                                       ; preds = %sw.bb124
  %203 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %203) #20
  br label %sw.epilog

if.end128:                                        ; preds = %sw.bb124
  %204 = load i8, i8* %alu32, align 1
  %tobool129 = trunc i8 %204 to i1
  br i1 %tobool129, label %if.then130, label %if.else131

if.then130:                                       ; preds = %if.end128
  %205 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_arsh(%struct.bpf_reg_state* noundef %205, %struct.bpf_reg_state* noundef %src_reg) #20
  br label %if.end132

if.else131:                                       ; preds = %if.end128
  %206 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_arsh(%struct.bpf_reg_state* noundef %206, %struct.bpf_reg_state* noundef %src_reg) #20
  br label %if.end132

if.end132:                                        ; preds = %if.else131, %if.then130
  br label %sw.epilog

sw.default:                                       ; preds = %if.end70
  %207 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %207) #20
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end132, %if.then127, %if.end123, %if.then118, %if.end114, %if.then109, %sw.bb100, %sw.bb94, %sw.bb88, %sw.bb82, %sw.bb76, %sw.bb
  %208 = load i8, i8* %alu32, align 1
  %tobool133 = trunc i8 %208 to i1
  br i1 %tobool133, label %if.then134, label %if.end135

if.then134:                                       ; preds = %sw.epilog
  %209 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @zext_32_to_64(%struct.bpf_reg_state* noundef %209) #20
  br label %if.end135

if.end135:                                        ; preds = %if.then134, %sw.epilog
  %210 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @reg_bounds_sync(%struct.bpf_reg_state* noundef %210) #20
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end135, %if.then67, %if.then60, %if.then44, %if.then26
  %211 = load i32, i32* %retval, align 4
  ret i32 %211
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_SUB(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_OR(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_OR.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_AND(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_AND.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_LSH(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_RSH(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_XOR(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ARSH(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ADD_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_SUB_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_OR_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_OR_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_AND_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_AND_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_LSH_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_RSH_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_XOR_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ARSH_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JEQ(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 29, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @push_stack___(%struct.bpf_reg_state* noundef %to, %struct.bpf_reg_state* noundef %from) #0 {
entry:
  %to.addr = alloca %struct.bpf_reg_state*, align 8
  %from.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %to, %struct.bpf_reg_state** %to.addr, align 8
  store %struct.bpf_reg_state* %from, %struct.bpf_reg_state** %from.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 %1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %4 = load i64, i64* %value, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 5
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off2, i32 0, i32 0
  store i64 %4, i64* %value3, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off4, i32 0, i32 1
  %7 = load i64, i64* %mask, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 5
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 1
  store i64 %7, i64* %mask6, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 6
  %10 = load i64, i64* %smin_value, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %smin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 6
  store i64 %10, i64* %smin_value7, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %smax_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 7
  store i64 %13, i64* %smax_value8, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 8
  %16 = load i64, i64* %umin_value, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 8
  store i64 %16, i64* %umin_value9, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 9
  %19 = load i64, i64* %umax_value, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %umax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  store i64 %19, i64* %umax_value10, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 10
  %22 = load i32, i32* %s32_min_value, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %s32_min_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 10
  store i32 %22, i32* %s32_min_value11, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 11
  %25 = load i32, i32* %s32_max_value, align 4
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %s32_max_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 11
  store i32 %25, i32* %s32_max_value12, align 4
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 12
  %28 = load i32, i32* %u32_min_value, align 8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %u32_min_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 12
  store i32 %28, i32* %u32_min_value13, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 13
  %31 = load i32, i32* %u32_max_value, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %u32_max_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 13
  store i32 %31, i32* %u32_max_value14, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_branch_taken(%struct.bpf_reg_state* noundef %reg, i64 noundef %val, i8 noundef zeroext %opcode, i1 noundef zeroext %is_jmp32) #0 {
entry:
  %retval = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %opcode.addr = alloca i8, align 1
  %is_jmp32.addr = alloca i8, align 1
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %is_jmp32 to i8
  store i8 %frombool, i8* %is_jmp32.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %0) #20
  br i1 %call, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  %2 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @reg_type_not_null(i32 noundef %2) #20
  br i1 %call1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %3 = load i64, i64* %val.addr, align 8
  %cmp = icmp ne i64 %3, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %4 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %4 to i32
  switch i32 %conv, label %sw.default [
    i32 16, label %sw.bb
    i32 80, label %sw.bb5
  ]

sw.bb:                                            ; preds = %if.end4
  store i32 0, i32* %retval, align 4
  br label %return

sw.bb5:                                           ; preds = %if.end4
  store i32 1, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end4
  store i32 -1, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %5 = load i8, i8* %is_jmp32.addr, align 1
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end6
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %7 = load i64, i64* %val.addr, align 8
  %conv8 = trunc i64 %7 to i32
  %8 = load i8, i8* %opcode.addr, align 1
  %call9 = call i32 @is_branch32_taken(%struct.bpf_reg_state* noundef %6, i32 noundef %conv8, i8 noundef zeroext %8) #20
  store i32 %call9, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %10 = load i64, i64* %val.addr, align 8
  %11 = load i8, i8* %opcode.addr, align 1
  %call11 = call i32 @is_branch64_taken(%struct.bpf_reg_state* noundef %9, i64 noundef %10, i8 noundef zeroext %11) #20
  store i32 %call11, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then7, %sw.default, %sw.bb5, %sw.bb, %if.then3, %if.then2
  %12 = load i32, i32* %retval, align 4
  ret i32 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_is_const(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %3 = load i64, i64* %mask, align 8
  %tobool = icmp ne i64 %3, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_subreg(i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_set_min_max(%struct.bpf_reg_state* noundef %true_reg, %struct.bpf_reg_state* noundef %false_reg, i64 noundef %val, i32 noundef %val32, i8 noundef zeroext %opcode, i1 noundef zeroext %is_jmp32) #0 {
entry:
  %true_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %false_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %val32.addr = alloca i32, align 4
  %opcode.addr = alloca i8, align 1
  %is_jmp32.addr = alloca i8, align 1
  %false_32off = alloca %struct.tnum, align 8
  %false_64off = alloca %struct.tnum, align 8
  %true_32off = alloca %struct.tnum, align 8
  %true_64off = alloca %struct.tnum, align 8
  %sval = alloca i64, align 8
  %sval32 = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  %tmp16 = alloca %struct.tnum, align 8
  %tmp25 = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tmp32 = alloca %struct.tnum, align 8
  %agg.tmp33 = alloca %struct.tnum, align 8
  %tmp39 = alloca %struct.tnum, align 8
  %agg.tmp40 = alloca %struct.tnum, align 8
  %tmp46 = alloca %struct.tnum, align 8
  %agg.tmp47 = alloca %struct.tnum, align 8
  %false_umax = alloca i32, align 4
  %true_umin = alloca i32, align 4
  %__UNIQUE_ID___x576 = alloca i32, align 4
  %__UNIQUE_ID___y577 = alloca i32, align 4
  %tmp64 = alloca i32, align 4
  %__UNIQUE_ID___x578 = alloca i32, align 4
  %__UNIQUE_ID___y579 = alloca i32, align 4
  %tmp72 = alloca i32, align 4
  %false_umax81 = alloca i64, align 8
  %true_umin90 = alloca i64, align 8
  %__UNIQUE_ID___x580 = alloca i64, align 8
  %__UNIQUE_ID___y581 = alloca i64, align 8
  %tmp99 = alloca i64, align 8
  %__UNIQUE_ID___x582 = alloca i64, align 8
  %__UNIQUE_ID___y583 = alloca i64, align 8
  %tmp107 = alloca i64, align 8
  %false_smax = alloca i32, align 4
  %true_smin = alloca i32, align 4
  %__UNIQUE_ID___x584 = alloca i32, align 4
  %__UNIQUE_ID___y585 = alloca i32, align 4
  %tmp135 = alloca i32, align 4
  %__UNIQUE_ID___x586 = alloca i32, align 4
  %__UNIQUE_ID___y587 = alloca i32, align 4
  %tmp143 = alloca i32, align 4
  %false_smax152 = alloca i64, align 8
  %true_smin161 = alloca i64, align 8
  %__UNIQUE_ID___x588 = alloca i64, align 8
  %__UNIQUE_ID___y589 = alloca i64, align 8
  %tmp170 = alloca i64, align 8
  %__UNIQUE_ID___x590 = alloca i64, align 8
  %__UNIQUE_ID___y591 = alloca i64, align 8
  %tmp178 = alloca i64, align 8
  %false_umin = alloca i32, align 4
  %true_umax = alloca i32, align 4
  %__UNIQUE_ID___x592 = alloca i32, align 4
  %__UNIQUE_ID___y593 = alloca i32, align 4
  %tmp207 = alloca i32, align 4
  %__UNIQUE_ID___x594 = alloca i32, align 4
  %__UNIQUE_ID___y595 = alloca i32, align 4
  %tmp216 = alloca i32, align 4
  %false_umin225 = alloca i64, align 8
  %true_umax234 = alloca i64, align 8
  %__UNIQUE_ID___x596 = alloca i64, align 8
  %__UNIQUE_ID___y597 = alloca i64, align 8
  %tmp244 = alloca i64, align 8
  %__UNIQUE_ID___x598 = alloca i64, align 8
  %__UNIQUE_ID___y599 = alloca i64, align 8
  %tmp253 = alloca i64, align 8
  %false_smin = alloca i32, align 4
  %true_smax = alloca i32, align 4
  %__UNIQUE_ID___x600 = alloca i32, align 4
  %__UNIQUE_ID___y601 = alloca i32, align 4
  %tmp282 = alloca i32, align 4
  %__UNIQUE_ID___x602 = alloca i32, align 4
  %__UNIQUE_ID___y603 = alloca i32, align 4
  %tmp291 = alloca i32, align 4
  %false_smin300 = alloca i64, align 8
  %true_smax309 = alloca i64, align 8
  %__UNIQUE_ID___x604 = alloca i64, align 8
  %__UNIQUE_ID___y605 = alloca i64, align 8
  %tmp319 = alloca i64, align 8
  %__UNIQUE_ID___x606 = alloca i64, align 8
  %__UNIQUE_ID___y607 = alloca i64, align 8
  %tmp328 = alloca i64, align 8
  %tmp340 = alloca %struct.tnum, align 8
  %agg.tmp341 = alloca %struct.tnum, align 8
  %agg.tmp343 = alloca %struct.tnum, align 8
  %tmp347 = alloca %struct.tnum, align 8
  %agg.tmp348 = alloca %struct.tnum, align 8
  %agg.tmp350 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %true_reg, %struct.bpf_reg_state** %true_reg.addr, align 8
  store %struct.bpf_reg_state* %false_reg, %struct.bpf_reg_state** %false_reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i32 %val32, i32* %val32.addr, align 4
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %is_jmp32 to i8
  store i8 %frombool, i8* %is_jmp32.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %3, i64 %5) #20
  %6 = bitcast %struct.tnum* %false_32off to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 5
  %12 = bitcast %struct.tnum* %false_64off to i8*
  %13 = bitcast %struct.tnum* %var_off1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 8 %13, i64 16, i1 false)
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %15 = bitcast %struct.tnum* %var_off2 to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = load i64, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = load i64, i64* %18, align 8
  %call3 = call { i64, i64 } @tnum_subreg(i64 %17, i64 %19) #20
  %20 = bitcast %struct.tnum* %true_32off to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = extractvalue { i64, i64 } %call3, 0
  store i64 %22, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = extractvalue { i64, i64 } %call3, 1
  store i64 %24, i64* %23, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 5
  %26 = bitcast %struct.tnum* %true_64off to i8*
  %27 = bitcast %struct.tnum* %var_off4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %26, i8* align 8 %27, i64 16, i1 false)
  %28 = load i64, i64* %val.addr, align 8
  store i64 %28, i64* %sval, align 8
  %29 = load i32, i32* %val32.addr, align 4
  store i32 %29, i32* %sval32, align 4
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %call5 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %30) #20
  br i1 %call5, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end356

if.end:                                           ; preds = %entry
  %31 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %31 to i32
  switch i32 %conv, label %sw.default [
    i32 16, label %sw.bb
    i32 80, label %sw.bb12
    i32 64, label %sw.bb22
    i32 48, label %sw.bb52
    i32 32, label %sw.bb52
    i32 112, label %sw.bb116
    i32 96, label %sw.bb116
    i32 176, label %sw.bb187
    i32 160, label %sw.bb187
    i32 208, label %sw.bb262
    i32 192, label %sw.bb262
  ]

sw.bb:                                            ; preds = %if.end
  %32 = load i8, i8* %is_jmp32.addr, align 1
  %tobool = trunc i8 %32 to i1
  br i1 %tobool, label %if.then6, label %if.else

if.then6:                                         ; preds = %sw.bb
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %34 = load i32, i32* %val32.addr, align 4
  %conv7 = zext i32 %34 to i64
  call void @__mark_reg32_known(%struct.bpf_reg_state* noundef %33, i64 noundef %conv7) #20
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off8 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call9 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call9, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call9, 1
  store i64 %45, i64* %44, align 8
  %46 = bitcast %struct.tnum* %true_32off to i8*
  %47 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %46, i8* align 8 %47, i64 16, i1 false)
  br label %if.end11

if.else:                                          ; preds = %sw.bb
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %49 = load i64, i64* %val.addr, align 8
  call void @___mark_reg_known(%struct.bpf_reg_state* noundef %48, i64 noundef %49) #20
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 5
  %51 = bitcast %struct.tnum* %true_64off to i8*
  %52 = bitcast %struct.tnum* %var_off10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %51, i8* align 8 %52, i64 16, i1 false)
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then6
  br label %sw.epilog

sw.bb12:                                          ; preds = %if.end
  %53 = load i8, i8* %is_jmp32.addr, align 1
  %tobool13 = trunc i8 %53 to i1
  br i1 %tobool13, label %if.then14, label %if.else19

if.then14:                                        ; preds = %sw.bb12
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %55 = load i32, i32* %val32.addr, align 4
  %conv15 = zext i32 %55 to i64
  call void @__mark_reg32_known(%struct.bpf_reg_state* noundef %54, i64 noundef %conv15) #20
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 5
  %57 = bitcast %struct.tnum* %var_off17 to { i64, i64 }*
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 0
  %59 = load i64, i64* %58, align 8
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 1
  %61 = load i64, i64* %60, align 8
  %call18 = call { i64, i64 } @tnum_subreg(i64 %59, i64 %61) #20
  %62 = bitcast %struct.tnum* %tmp16 to { i64, i64 }*
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 0
  %64 = extractvalue { i64, i64 } %call18, 0
  store i64 %64, i64* %63, align 8
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 1
  %66 = extractvalue { i64, i64 } %call18, 1
  store i64 %66, i64* %65, align 8
  %67 = bitcast %struct.tnum* %false_32off to i8*
  %68 = bitcast %struct.tnum* %tmp16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %67, i8* align 8 %68, i64 16, i1 false)
  br label %if.end21

if.else19:                                        ; preds = %sw.bb12
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %70 = load i64, i64* %val.addr, align 8
  call void @___mark_reg_known(%struct.bpf_reg_state* noundef %69, i64 noundef %70) #20
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 5
  %72 = bitcast %struct.tnum* %false_64off to i8*
  %73 = bitcast %struct.tnum* %var_off20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %72, i8* align 8 %73, i64 16, i1 false)
  br label %if.end21

if.end21:                                         ; preds = %if.else19, %if.then14
  br label %sw.epilog

sw.bb22:                                          ; preds = %if.end
  %74 = load i8, i8* %is_jmp32.addr, align 1
  %tobool23 = trunc i8 %74 to i1
  br i1 %tobool23, label %if.then24, label %if.else38

if.then24:                                        ; preds = %sw.bb22
  %75 = load i32, i32* %val32.addr, align 4
  %neg = xor i32 %75, -1
  %conv26 = zext i32 %neg to i64
  %call27 = call { i64, i64 } @tnum_const(i64 noundef %conv26) #20
  %76 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %77 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 0
  %78 = extractvalue { i64, i64 } %call27, 0
  store i64 %78, i64* %77, align 8
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 1
  %80 = extractvalue { i64, i64 } %call27, 1
  store i64 %80, i64* %79, align 8
  %81 = bitcast %struct.tnum* %false_32off to { i64, i64 }*
  %82 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 0
  %83 = load i64, i64* %82, align 8
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 1
  %85 = load i64, i64* %84, align 8
  %86 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %87 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %86, i32 0, i32 0
  %88 = load i64, i64* %87, align 8
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %86, i32 0, i32 1
  %90 = load i64, i64* %89, align 8
  %call28 = call { i64, i64 } @tnum_and(i64 %83, i64 %85, i64 %88, i64 %90) #20
  %91 = bitcast %struct.tnum* %tmp25 to { i64, i64 }*
  %92 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %91, i32 0, i32 0
  %93 = extractvalue { i64, i64 } %call28, 0
  store i64 %93, i64* %92, align 8
  %94 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %91, i32 0, i32 1
  %95 = extractvalue { i64, i64 } %call28, 1
  store i64 %95, i64* %94, align 8
  %96 = bitcast %struct.tnum* %false_32off to i8*
  %97 = bitcast %struct.tnum* %tmp25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %96, i8* align 8 %97, i64 16, i1 false)
  %98 = load i32, i32* %val32.addr, align 4
  %conv29 = zext i32 %98 to i64
  %call30 = call zeroext i1 @is_power_of_2(i64 noundef %conv29) #23
  br i1 %call30, label %if.then31, label %if.end37

if.then31:                                        ; preds = %if.then24
  %99 = load i32, i32* %val32.addr, align 4
  %conv34 = zext i32 %99 to i64
  %call35 = call { i64, i64 } @tnum_const(i64 noundef %conv34) #20
  %100 = bitcast %struct.tnum* %agg.tmp33 to { i64, i64 }*
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %100, i32 0, i32 0
  %102 = extractvalue { i64, i64 } %call35, 0
  store i64 %102, i64* %101, align 8
  %103 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %100, i32 0, i32 1
  %104 = extractvalue { i64, i64 } %call35, 1
  store i64 %104, i64* %103, align 8
  %105 = bitcast %struct.tnum* %true_32off to { i64, i64 }*
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %105, i32 0, i32 0
  %107 = load i64, i64* %106, align 8
  %108 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %105, i32 0, i32 1
  %109 = load i64, i64* %108, align 8
  %110 = bitcast %struct.tnum* %agg.tmp33 to { i64, i64 }*
  %111 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %110, i32 0, i32 0
  %112 = load i64, i64* %111, align 8
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %110, i32 0, i32 1
  %114 = load i64, i64* %113, align 8
  %call36 = call { i64, i64 } @tnum_or(i64 %107, i64 %109, i64 %112, i64 %114) #20
  %115 = bitcast %struct.tnum* %tmp32 to { i64, i64 }*
  %116 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %115, i32 0, i32 0
  %117 = extractvalue { i64, i64 } %call36, 0
  store i64 %117, i64* %116, align 8
  %118 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %115, i32 0, i32 1
  %119 = extractvalue { i64, i64 } %call36, 1
  store i64 %119, i64* %118, align 8
  %120 = bitcast %struct.tnum* %true_32off to i8*
  %121 = bitcast %struct.tnum* %tmp32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %120, i8* align 8 %121, i64 16, i1 false)
  br label %if.end37

if.end37:                                         ; preds = %if.then31, %if.then24
  br label %if.end51

if.else38:                                        ; preds = %sw.bb22
  %122 = load i64, i64* %val.addr, align 8
  %neg41 = xor i64 %122, -1
  %call42 = call { i64, i64 } @tnum_const(i64 noundef %neg41) #20
  %123 = bitcast %struct.tnum* %agg.tmp40 to { i64, i64 }*
  %124 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %123, i32 0, i32 0
  %125 = extractvalue { i64, i64 } %call42, 0
  store i64 %125, i64* %124, align 8
  %126 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %123, i32 0, i32 1
  %127 = extractvalue { i64, i64 } %call42, 1
  store i64 %127, i64* %126, align 8
  %128 = bitcast %struct.tnum* %false_64off to { i64, i64 }*
  %129 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %128, i32 0, i32 0
  %130 = load i64, i64* %129, align 8
  %131 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %128, i32 0, i32 1
  %132 = load i64, i64* %131, align 8
  %133 = bitcast %struct.tnum* %agg.tmp40 to { i64, i64 }*
  %134 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %133, i32 0, i32 0
  %135 = load i64, i64* %134, align 8
  %136 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %133, i32 0, i32 1
  %137 = load i64, i64* %136, align 8
  %call43 = call { i64, i64 } @tnum_and(i64 %130, i64 %132, i64 %135, i64 %137) #20
  %138 = bitcast %struct.tnum* %tmp39 to { i64, i64 }*
  %139 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %138, i32 0, i32 0
  %140 = extractvalue { i64, i64 } %call43, 0
  store i64 %140, i64* %139, align 8
  %141 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %138, i32 0, i32 1
  %142 = extractvalue { i64, i64 } %call43, 1
  store i64 %142, i64* %141, align 8
  %143 = bitcast %struct.tnum* %false_64off to i8*
  %144 = bitcast %struct.tnum* %tmp39 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %143, i8* align 8 %144, i64 16, i1 false)
  %145 = load i64, i64* %val.addr, align 8
  %call44 = call zeroext i1 @is_power_of_2(i64 noundef %145) #23
  br i1 %call44, label %if.then45, label %if.end50

if.then45:                                        ; preds = %if.else38
  %146 = load i64, i64* %val.addr, align 8
  %call48 = call { i64, i64 } @tnum_const(i64 noundef %146) #20
  %147 = bitcast %struct.tnum* %agg.tmp47 to { i64, i64 }*
  %148 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %147, i32 0, i32 0
  %149 = extractvalue { i64, i64 } %call48, 0
  store i64 %149, i64* %148, align 8
  %150 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %147, i32 0, i32 1
  %151 = extractvalue { i64, i64 } %call48, 1
  store i64 %151, i64* %150, align 8
  %152 = bitcast %struct.tnum* %true_64off to { i64, i64 }*
  %153 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %152, i32 0, i32 0
  %154 = load i64, i64* %153, align 8
  %155 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %152, i32 0, i32 1
  %156 = load i64, i64* %155, align 8
  %157 = bitcast %struct.tnum* %agg.tmp47 to { i64, i64 }*
  %158 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %157, i32 0, i32 0
  %159 = load i64, i64* %158, align 8
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %157, i32 0, i32 1
  %161 = load i64, i64* %160, align 8
  %call49 = call { i64, i64 } @tnum_or(i64 %154, i64 %156, i64 %159, i64 %161) #20
  %162 = bitcast %struct.tnum* %tmp46 to { i64, i64 }*
  %163 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %162, i32 0, i32 0
  %164 = extractvalue { i64, i64 } %call49, 0
  store i64 %164, i64* %163, align 8
  %165 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %162, i32 0, i32 1
  %166 = extractvalue { i64, i64 } %call49, 1
  store i64 %166, i64* %165, align 8
  %167 = bitcast %struct.tnum* %true_64off to i8*
  %168 = bitcast %struct.tnum* %tmp46 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %167, i8* align 8 %168, i64 16, i1 false)
  br label %if.end50

if.end50:                                         ; preds = %if.then45, %if.else38
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.end37
  br label %sw.epilog

sw.bb52:                                          ; preds = %if.end, %if.end
  %169 = load i8, i8* %is_jmp32.addr, align 1
  %tobool53 = trunc i8 %169 to i1
  br i1 %tobool53, label %if.then54, label %if.else80

if.then54:                                        ; preds = %sw.bb52
  %170 = load i8, i8* %opcode.addr, align 1
  %conv55 = zext i8 %170 to i32
  %cmp = icmp eq i32 %conv55, 32
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then54
  %171 = load i32, i32* %val32.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then54
  %172 = load i32, i32* %val32.addr, align 4
  %sub = sub i32 %172, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %171, %cond.true ], [ %sub, %cond.false ]
  store i32 %cond, i32* %false_umax, align 4
  %173 = load i8, i8* %opcode.addr, align 1
  %conv57 = zext i8 %173 to i32
  %cmp58 = icmp eq i32 %conv57, 32
  br i1 %cmp58, label %cond.true60, label %cond.false61

cond.true60:                                      ; preds = %cond.end
  %174 = load i32, i32* %val32.addr, align 4
  %add = add i32 %174, 1
  br label %cond.end62

cond.false61:                                     ; preds = %cond.end
  %175 = load i32, i32* %val32.addr, align 4
  br label %cond.end62

cond.end62:                                       ; preds = %cond.false61, %cond.true60
  %cond63 = phi i32 [ %add, %cond.true60 ], [ %175, %cond.false61 ]
  store i32 %cond63, i32* %true_umin, align 4
  %176 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %176, i32 0, i32 13
  %177 = load i32, i32* %u32_max_value, align 4
  store i32 %177, i32* %__UNIQUE_ID___x576, align 4
  %178 = load i32, i32* %false_umax, align 4
  store i32 %178, i32* %__UNIQUE_ID___y577, align 4
  %179 = load i32, i32* %__UNIQUE_ID___x576, align 4
  %180 = load i32, i32* %__UNIQUE_ID___y577, align 4
  %cmp65 = icmp ult i32 %179, %180
  br i1 %cmp65, label %cond.true67, label %cond.false68

cond.true67:                                      ; preds = %cond.end62
  %181 = load i32, i32* %__UNIQUE_ID___x576, align 4
  br label %cond.end69

cond.false68:                                     ; preds = %cond.end62
  %182 = load i32, i32* %__UNIQUE_ID___y577, align 4
  br label %cond.end69

cond.end69:                                       ; preds = %cond.false68, %cond.true67
  %cond70 = phi i32 [ %181, %cond.true67 ], [ %182, %cond.false68 ]
  store i32 %cond70, i32* %tmp64, align 4
  %183 = load i32, i32* %tmp64, align 4
  %184 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %u32_max_value71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %184, i32 0, i32 13
  store i32 %183, i32* %u32_max_value71, align 4
  %185 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %185, i32 0, i32 12
  %186 = load i32, i32* %u32_min_value, align 8
  store i32 %186, i32* %__UNIQUE_ID___x578, align 4
  %187 = load i32, i32* %true_umin, align 4
  store i32 %187, i32* %__UNIQUE_ID___y579, align 4
  %188 = load i32, i32* %__UNIQUE_ID___x578, align 4
  %189 = load i32, i32* %__UNIQUE_ID___y579, align 4
  %cmp73 = icmp ugt i32 %188, %189
  br i1 %cmp73, label %cond.true75, label %cond.false76

cond.true75:                                      ; preds = %cond.end69
  %190 = load i32, i32* %__UNIQUE_ID___x578, align 4
  br label %cond.end77

cond.false76:                                     ; preds = %cond.end69
  %191 = load i32, i32* %__UNIQUE_ID___y579, align 4
  br label %cond.end77

cond.end77:                                       ; preds = %cond.false76, %cond.true75
  %cond78 = phi i32 [ %190, %cond.true75 ], [ %191, %cond.false76 ]
  store i32 %cond78, i32* %tmp72, align 4
  %192 = load i32, i32* %tmp72, align 4
  %193 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %u32_min_value79 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %193, i32 0, i32 12
  store i32 %192, i32* %u32_min_value79, align 8
  br label %if.end115

if.else80:                                        ; preds = %sw.bb52
  %194 = load i8, i8* %opcode.addr, align 1
  %conv82 = zext i8 %194 to i32
  %cmp83 = icmp eq i32 %conv82, 32
  br i1 %cmp83, label %cond.true85, label %cond.false86

cond.true85:                                      ; preds = %if.else80
  %195 = load i64, i64* %val.addr, align 8
  br label %cond.end88

cond.false86:                                     ; preds = %if.else80
  %196 = load i64, i64* %val.addr, align 8
  %sub87 = sub i64 %196, 1
  br label %cond.end88

cond.end88:                                       ; preds = %cond.false86, %cond.true85
  %cond89 = phi i64 [ %195, %cond.true85 ], [ %sub87, %cond.false86 ]
  store i64 %cond89, i64* %false_umax81, align 8
  %197 = load i8, i8* %opcode.addr, align 1
  %conv91 = zext i8 %197 to i32
  %cmp92 = icmp eq i32 %conv91, 32
  br i1 %cmp92, label %cond.true94, label %cond.false96

cond.true94:                                      ; preds = %cond.end88
  %198 = load i64, i64* %val.addr, align 8
  %add95 = add i64 %198, 1
  br label %cond.end97

cond.false96:                                     ; preds = %cond.end88
  %199 = load i64, i64* %val.addr, align 8
  br label %cond.end97

cond.end97:                                       ; preds = %cond.false96, %cond.true94
  %cond98 = phi i64 [ %add95, %cond.true94 ], [ %199, %cond.false96 ]
  store i64 %cond98, i64* %true_umin90, align 8
  %200 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %200, i32 0, i32 9
  %201 = load i64, i64* %umax_value, align 8
  store i64 %201, i64* %__UNIQUE_ID___x580, align 8
  %202 = load i64, i64* %false_umax81, align 8
  store i64 %202, i64* %__UNIQUE_ID___y581, align 8
  %203 = load i64, i64* %__UNIQUE_ID___x580, align 8
  %204 = load i64, i64* %__UNIQUE_ID___y581, align 8
  %cmp100 = icmp ult i64 %203, %204
  br i1 %cmp100, label %cond.true102, label %cond.false103

cond.true102:                                     ; preds = %cond.end97
  %205 = load i64, i64* %__UNIQUE_ID___x580, align 8
  br label %cond.end104

cond.false103:                                    ; preds = %cond.end97
  %206 = load i64, i64* %__UNIQUE_ID___y581, align 8
  br label %cond.end104

cond.end104:                                      ; preds = %cond.false103, %cond.true102
  %cond105 = phi i64 [ %205, %cond.true102 ], [ %206, %cond.false103 ]
  store i64 %cond105, i64* %tmp99, align 8
  %207 = load i64, i64* %tmp99, align 8
  %208 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umax_value106 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %208, i32 0, i32 9
  store i64 %207, i64* %umax_value106, align 8
  %209 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %209, i32 0, i32 8
  %210 = load i64, i64* %umin_value, align 8
  store i64 %210, i64* %__UNIQUE_ID___x582, align 8
  %211 = load i64, i64* %true_umin90, align 8
  store i64 %211, i64* %__UNIQUE_ID___y583, align 8
  %212 = load i64, i64* %__UNIQUE_ID___x582, align 8
  %213 = load i64, i64* %__UNIQUE_ID___y583, align 8
  %cmp108 = icmp ugt i64 %212, %213
  br i1 %cmp108, label %cond.true110, label %cond.false111

cond.true110:                                     ; preds = %cond.end104
  %214 = load i64, i64* %__UNIQUE_ID___x582, align 8
  br label %cond.end112

cond.false111:                                    ; preds = %cond.end104
  %215 = load i64, i64* %__UNIQUE_ID___y583, align 8
  br label %cond.end112

cond.end112:                                      ; preds = %cond.false111, %cond.true110
  %cond113 = phi i64 [ %214, %cond.true110 ], [ %215, %cond.false111 ]
  store i64 %cond113, i64* %tmp107, align 8
  %216 = load i64, i64* %tmp107, align 8
  %217 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umin_value114 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %217, i32 0, i32 8
  store i64 %216, i64* %umin_value114, align 8
  br label %if.end115

if.end115:                                        ; preds = %cond.end112, %cond.end77
  br label %sw.epilog

sw.bb116:                                         ; preds = %if.end, %if.end
  %218 = load i8, i8* %is_jmp32.addr, align 1
  %tobool117 = trunc i8 %218 to i1
  br i1 %tobool117, label %if.then118, label %if.else151

if.then118:                                       ; preds = %sw.bb116
  %219 = load i8, i8* %opcode.addr, align 1
  %conv119 = zext i8 %219 to i32
  %cmp120 = icmp eq i32 %conv119, 96
  br i1 %cmp120, label %cond.true122, label %cond.false123

cond.true122:                                     ; preds = %if.then118
  %220 = load i32, i32* %sval32, align 4
  br label %cond.end125

cond.false123:                                    ; preds = %if.then118
  %221 = load i32, i32* %sval32, align 4
  %sub124 = sub i32 %221, 1
  br label %cond.end125

cond.end125:                                      ; preds = %cond.false123, %cond.true122
  %cond126 = phi i32 [ %220, %cond.true122 ], [ %sub124, %cond.false123 ]
  store i32 %cond126, i32* %false_smax, align 4
  %222 = load i8, i8* %opcode.addr, align 1
  %conv127 = zext i8 %222 to i32
  %cmp128 = icmp eq i32 %conv127, 96
  br i1 %cmp128, label %cond.true130, label %cond.false132

cond.true130:                                     ; preds = %cond.end125
  %223 = load i32, i32* %sval32, align 4
  %add131 = add i32 %223, 1
  br label %cond.end133

cond.false132:                                    ; preds = %cond.end125
  %224 = load i32, i32* %sval32, align 4
  br label %cond.end133

cond.end133:                                      ; preds = %cond.false132, %cond.true130
  %cond134 = phi i32 [ %add131, %cond.true130 ], [ %224, %cond.false132 ]
  store i32 %cond134, i32* %true_smin, align 4
  %225 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %225, i32 0, i32 11
  %226 = load i32, i32* %s32_max_value, align 4
  store i32 %226, i32* %__UNIQUE_ID___x584, align 4
  %227 = load i32, i32* %false_smax, align 4
  store i32 %227, i32* %__UNIQUE_ID___y585, align 4
  %228 = load i32, i32* %__UNIQUE_ID___x584, align 4
  %229 = load i32, i32* %__UNIQUE_ID___y585, align 4
  %cmp136 = icmp slt i32 %228, %229
  br i1 %cmp136, label %cond.true138, label %cond.false139

cond.true138:                                     ; preds = %cond.end133
  %230 = load i32, i32* %__UNIQUE_ID___x584, align 4
  br label %cond.end140

cond.false139:                                    ; preds = %cond.end133
  %231 = load i32, i32* %__UNIQUE_ID___y585, align 4
  br label %cond.end140

cond.end140:                                      ; preds = %cond.false139, %cond.true138
  %cond141 = phi i32 [ %230, %cond.true138 ], [ %231, %cond.false139 ]
  store i32 %cond141, i32* %tmp135, align 4
  %232 = load i32, i32* %tmp135, align 4
  %233 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %s32_max_value142 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %233, i32 0, i32 11
  store i32 %232, i32* %s32_max_value142, align 4
  %234 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %234, i32 0, i32 10
  %235 = load i32, i32* %s32_min_value, align 8
  store i32 %235, i32* %__UNIQUE_ID___x586, align 4
  %236 = load i32, i32* %true_smin, align 4
  store i32 %236, i32* %__UNIQUE_ID___y587, align 4
  %237 = load i32, i32* %__UNIQUE_ID___x586, align 4
  %238 = load i32, i32* %__UNIQUE_ID___y587, align 4
  %cmp144 = icmp sgt i32 %237, %238
  br i1 %cmp144, label %cond.true146, label %cond.false147

cond.true146:                                     ; preds = %cond.end140
  %239 = load i32, i32* %__UNIQUE_ID___x586, align 4
  br label %cond.end148

cond.false147:                                    ; preds = %cond.end140
  %240 = load i32, i32* %__UNIQUE_ID___y587, align 4
  br label %cond.end148

cond.end148:                                      ; preds = %cond.false147, %cond.true146
  %cond149 = phi i32 [ %239, %cond.true146 ], [ %240, %cond.false147 ]
  store i32 %cond149, i32* %tmp143, align 4
  %241 = load i32, i32* %tmp143, align 4
  %242 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %s32_min_value150 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %242, i32 0, i32 10
  store i32 %241, i32* %s32_min_value150, align 8
  br label %if.end186

if.else151:                                       ; preds = %sw.bb116
  %243 = load i8, i8* %opcode.addr, align 1
  %conv153 = zext i8 %243 to i32
  %cmp154 = icmp eq i32 %conv153, 96
  br i1 %cmp154, label %cond.true156, label %cond.false157

cond.true156:                                     ; preds = %if.else151
  %244 = load i64, i64* %sval, align 8
  br label %cond.end159

cond.false157:                                    ; preds = %if.else151
  %245 = load i64, i64* %sval, align 8
  %sub158 = sub i64 %245, 1
  br label %cond.end159

cond.end159:                                      ; preds = %cond.false157, %cond.true156
  %cond160 = phi i64 [ %244, %cond.true156 ], [ %sub158, %cond.false157 ]
  store i64 %cond160, i64* %false_smax152, align 8
  %246 = load i8, i8* %opcode.addr, align 1
  %conv162 = zext i8 %246 to i32
  %cmp163 = icmp eq i32 %conv162, 96
  br i1 %cmp163, label %cond.true165, label %cond.false167

cond.true165:                                     ; preds = %cond.end159
  %247 = load i64, i64* %sval, align 8
  %add166 = add i64 %247, 1
  br label %cond.end168

cond.false167:                                    ; preds = %cond.end159
  %248 = load i64, i64* %sval, align 8
  br label %cond.end168

cond.end168:                                      ; preds = %cond.false167, %cond.true165
  %cond169 = phi i64 [ %add166, %cond.true165 ], [ %248, %cond.false167 ]
  store i64 %cond169, i64* %true_smin161, align 8
  %249 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %249, i32 0, i32 7
  %250 = load i64, i64* %smax_value, align 8
  store i64 %250, i64* %__UNIQUE_ID___x588, align 8
  %251 = load i64, i64* %false_smax152, align 8
  store i64 %251, i64* %__UNIQUE_ID___y589, align 8
  %252 = load i64, i64* %__UNIQUE_ID___x588, align 8
  %253 = load i64, i64* %__UNIQUE_ID___y589, align 8
  %cmp171 = icmp slt i64 %252, %253
  br i1 %cmp171, label %cond.true173, label %cond.false174

cond.true173:                                     ; preds = %cond.end168
  %254 = load i64, i64* %__UNIQUE_ID___x588, align 8
  br label %cond.end175

cond.false174:                                    ; preds = %cond.end168
  %255 = load i64, i64* %__UNIQUE_ID___y589, align 8
  br label %cond.end175

cond.end175:                                      ; preds = %cond.false174, %cond.true173
  %cond176 = phi i64 [ %254, %cond.true173 ], [ %255, %cond.false174 ]
  store i64 %cond176, i64* %tmp170, align 8
  %256 = load i64, i64* %tmp170, align 8
  %257 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smax_value177 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %257, i32 0, i32 7
  store i64 %256, i64* %smax_value177, align 8
  %258 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %258, i32 0, i32 6
  %259 = load i64, i64* %smin_value, align 8
  store i64 %259, i64* %__UNIQUE_ID___x590, align 8
  %260 = load i64, i64* %true_smin161, align 8
  store i64 %260, i64* %__UNIQUE_ID___y591, align 8
  %261 = load i64, i64* %__UNIQUE_ID___x590, align 8
  %262 = load i64, i64* %__UNIQUE_ID___y591, align 8
  %cmp179 = icmp sgt i64 %261, %262
  br i1 %cmp179, label %cond.true181, label %cond.false182

cond.true181:                                     ; preds = %cond.end175
  %263 = load i64, i64* %__UNIQUE_ID___x590, align 8
  br label %cond.end183

cond.false182:                                    ; preds = %cond.end175
  %264 = load i64, i64* %__UNIQUE_ID___y591, align 8
  br label %cond.end183

cond.end183:                                      ; preds = %cond.false182, %cond.true181
  %cond184 = phi i64 [ %263, %cond.true181 ], [ %264, %cond.false182 ]
  store i64 %cond184, i64* %tmp178, align 8
  %265 = load i64, i64* %tmp178, align 8
  %266 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smin_value185 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %266, i32 0, i32 6
  store i64 %265, i64* %smin_value185, align 8
  br label %if.end186

if.end186:                                        ; preds = %cond.end183, %cond.end148
  br label %sw.epilog

sw.bb187:                                         ; preds = %if.end, %if.end
  %267 = load i8, i8* %is_jmp32.addr, align 1
  %tobool188 = trunc i8 %267 to i1
  br i1 %tobool188, label %if.then189, label %if.else224

if.then189:                                       ; preds = %sw.bb187
  %268 = load i8, i8* %opcode.addr, align 1
  %conv190 = zext i8 %268 to i32
  %cmp191 = icmp eq i32 %conv190, 160
  br i1 %cmp191, label %cond.true193, label %cond.false194

cond.true193:                                     ; preds = %if.then189
  %269 = load i32, i32* %val32.addr, align 4
  br label %cond.end196

cond.false194:                                    ; preds = %if.then189
  %270 = load i32, i32* %val32.addr, align 4
  %add195 = add i32 %270, 1
  br label %cond.end196

cond.end196:                                      ; preds = %cond.false194, %cond.true193
  %cond197 = phi i32 [ %269, %cond.true193 ], [ %add195, %cond.false194 ]
  store i32 %cond197, i32* %false_umin, align 4
  %271 = load i8, i8* %opcode.addr, align 1
  %conv198 = zext i8 %271 to i32
  %cmp199 = icmp eq i32 %conv198, 160
  br i1 %cmp199, label %cond.true201, label %cond.false203

cond.true201:                                     ; preds = %cond.end196
  %272 = load i32, i32* %val32.addr, align 4
  %sub202 = sub i32 %272, 1
  br label %cond.end204

cond.false203:                                    ; preds = %cond.end196
  %273 = load i32, i32* %val32.addr, align 4
  br label %cond.end204

cond.end204:                                      ; preds = %cond.false203, %cond.true201
  %cond205 = phi i32 [ %sub202, %cond.true201 ], [ %273, %cond.false203 ]
  store i32 %cond205, i32* %true_umax, align 4
  %274 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %u32_min_value206 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %274, i32 0, i32 12
  %275 = load i32, i32* %u32_min_value206, align 8
  store i32 %275, i32* %__UNIQUE_ID___x592, align 4
  %276 = load i32, i32* %false_umin, align 4
  store i32 %276, i32* %__UNIQUE_ID___y593, align 4
  %277 = load i32, i32* %__UNIQUE_ID___x592, align 4
  %278 = load i32, i32* %__UNIQUE_ID___y593, align 4
  %cmp208 = icmp ugt i32 %277, %278
  br i1 %cmp208, label %cond.true210, label %cond.false211

cond.true210:                                     ; preds = %cond.end204
  %279 = load i32, i32* %__UNIQUE_ID___x592, align 4
  br label %cond.end212

cond.false211:                                    ; preds = %cond.end204
  %280 = load i32, i32* %__UNIQUE_ID___y593, align 4
  br label %cond.end212

cond.end212:                                      ; preds = %cond.false211, %cond.true210
  %cond213 = phi i32 [ %279, %cond.true210 ], [ %280, %cond.false211 ]
  store i32 %cond213, i32* %tmp207, align 4
  %281 = load i32, i32* %tmp207, align 4
  %282 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %u32_min_value214 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %282, i32 0, i32 12
  store i32 %281, i32* %u32_min_value214, align 8
  %283 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %u32_max_value215 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %283, i32 0, i32 13
  %284 = load i32, i32* %u32_max_value215, align 4
  store i32 %284, i32* %__UNIQUE_ID___x594, align 4
  %285 = load i32, i32* %true_umax, align 4
  store i32 %285, i32* %__UNIQUE_ID___y595, align 4
  %286 = load i32, i32* %__UNIQUE_ID___x594, align 4
  %287 = load i32, i32* %__UNIQUE_ID___y595, align 4
  %cmp217 = icmp ult i32 %286, %287
  br i1 %cmp217, label %cond.true219, label %cond.false220

cond.true219:                                     ; preds = %cond.end212
  %288 = load i32, i32* %__UNIQUE_ID___x594, align 4
  br label %cond.end221

cond.false220:                                    ; preds = %cond.end212
  %289 = load i32, i32* %__UNIQUE_ID___y595, align 4
  br label %cond.end221

cond.end221:                                      ; preds = %cond.false220, %cond.true219
  %cond222 = phi i32 [ %288, %cond.true219 ], [ %289, %cond.false220 ]
  store i32 %cond222, i32* %tmp216, align 4
  %290 = load i32, i32* %tmp216, align 4
  %291 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %u32_max_value223 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %291, i32 0, i32 13
  store i32 %290, i32* %u32_max_value223, align 4
  br label %if.end261

if.else224:                                       ; preds = %sw.bb187
  %292 = load i8, i8* %opcode.addr, align 1
  %conv226 = zext i8 %292 to i32
  %cmp227 = icmp eq i32 %conv226, 160
  br i1 %cmp227, label %cond.true229, label %cond.false230

cond.true229:                                     ; preds = %if.else224
  %293 = load i64, i64* %val.addr, align 8
  br label %cond.end232

cond.false230:                                    ; preds = %if.else224
  %294 = load i64, i64* %val.addr, align 8
  %add231 = add i64 %294, 1
  br label %cond.end232

cond.end232:                                      ; preds = %cond.false230, %cond.true229
  %cond233 = phi i64 [ %293, %cond.true229 ], [ %add231, %cond.false230 ]
  store i64 %cond233, i64* %false_umin225, align 8
  %295 = load i8, i8* %opcode.addr, align 1
  %conv235 = zext i8 %295 to i32
  %cmp236 = icmp eq i32 %conv235, 160
  br i1 %cmp236, label %cond.true238, label %cond.false240

cond.true238:                                     ; preds = %cond.end232
  %296 = load i64, i64* %val.addr, align 8
  %sub239 = sub i64 %296, 1
  br label %cond.end241

cond.false240:                                    ; preds = %cond.end232
  %297 = load i64, i64* %val.addr, align 8
  br label %cond.end241

cond.end241:                                      ; preds = %cond.false240, %cond.true238
  %cond242 = phi i64 [ %sub239, %cond.true238 ], [ %297, %cond.false240 ]
  store i64 %cond242, i64* %true_umax234, align 8
  %298 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umin_value243 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %298, i32 0, i32 8
  %299 = load i64, i64* %umin_value243, align 8
  store i64 %299, i64* %__UNIQUE_ID___x596, align 8
  %300 = load i64, i64* %false_umin225, align 8
  store i64 %300, i64* %__UNIQUE_ID___y597, align 8
  %301 = load i64, i64* %__UNIQUE_ID___x596, align 8
  %302 = load i64, i64* %__UNIQUE_ID___y597, align 8
  %cmp245 = icmp ugt i64 %301, %302
  br i1 %cmp245, label %cond.true247, label %cond.false248

cond.true247:                                     ; preds = %cond.end241
  %303 = load i64, i64* %__UNIQUE_ID___x596, align 8
  br label %cond.end249

cond.false248:                                    ; preds = %cond.end241
  %304 = load i64, i64* %__UNIQUE_ID___y597, align 8
  br label %cond.end249

cond.end249:                                      ; preds = %cond.false248, %cond.true247
  %cond250 = phi i64 [ %303, %cond.true247 ], [ %304, %cond.false248 ]
  store i64 %cond250, i64* %tmp244, align 8
  %305 = load i64, i64* %tmp244, align 8
  %306 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umin_value251 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %306, i32 0, i32 8
  store i64 %305, i64* %umin_value251, align 8
  %307 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umax_value252 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %307, i32 0, i32 9
  %308 = load i64, i64* %umax_value252, align 8
  store i64 %308, i64* %__UNIQUE_ID___x598, align 8
  %309 = load i64, i64* %true_umax234, align 8
  store i64 %309, i64* %__UNIQUE_ID___y599, align 8
  %310 = load i64, i64* %__UNIQUE_ID___x598, align 8
  %311 = load i64, i64* %__UNIQUE_ID___y599, align 8
  %cmp254 = icmp ult i64 %310, %311
  br i1 %cmp254, label %cond.true256, label %cond.false257

cond.true256:                                     ; preds = %cond.end249
  %312 = load i64, i64* %__UNIQUE_ID___x598, align 8
  br label %cond.end258

cond.false257:                                    ; preds = %cond.end249
  %313 = load i64, i64* %__UNIQUE_ID___y599, align 8
  br label %cond.end258

cond.end258:                                      ; preds = %cond.false257, %cond.true256
  %cond259 = phi i64 [ %312, %cond.true256 ], [ %313, %cond.false257 ]
  store i64 %cond259, i64* %tmp253, align 8
  %314 = load i64, i64* %tmp253, align 8
  %315 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umax_value260 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %315, i32 0, i32 9
  store i64 %314, i64* %umax_value260, align 8
  br label %if.end261

if.end261:                                        ; preds = %cond.end258, %cond.end221
  br label %sw.epilog

sw.bb262:                                         ; preds = %if.end, %if.end
  %316 = load i8, i8* %is_jmp32.addr, align 1
  %tobool263 = trunc i8 %316 to i1
  br i1 %tobool263, label %if.then264, label %if.else299

if.then264:                                       ; preds = %sw.bb262
  %317 = load i8, i8* %opcode.addr, align 1
  %conv265 = zext i8 %317 to i32
  %cmp266 = icmp eq i32 %conv265, 192
  br i1 %cmp266, label %cond.true268, label %cond.false269

cond.true268:                                     ; preds = %if.then264
  %318 = load i32, i32* %sval32, align 4
  br label %cond.end271

cond.false269:                                    ; preds = %if.then264
  %319 = load i32, i32* %sval32, align 4
  %add270 = add i32 %319, 1
  br label %cond.end271

cond.end271:                                      ; preds = %cond.false269, %cond.true268
  %cond272 = phi i32 [ %318, %cond.true268 ], [ %add270, %cond.false269 ]
  store i32 %cond272, i32* %false_smin, align 4
  %320 = load i8, i8* %opcode.addr, align 1
  %conv273 = zext i8 %320 to i32
  %cmp274 = icmp eq i32 %conv273, 192
  br i1 %cmp274, label %cond.true276, label %cond.false278

cond.true276:                                     ; preds = %cond.end271
  %321 = load i32, i32* %sval32, align 4
  %sub277 = sub i32 %321, 1
  br label %cond.end279

cond.false278:                                    ; preds = %cond.end271
  %322 = load i32, i32* %sval32, align 4
  br label %cond.end279

cond.end279:                                      ; preds = %cond.false278, %cond.true276
  %cond280 = phi i32 [ %sub277, %cond.true276 ], [ %322, %cond.false278 ]
  store i32 %cond280, i32* %true_smax, align 4
  %323 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %s32_min_value281 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %323, i32 0, i32 10
  %324 = load i32, i32* %s32_min_value281, align 8
  store i32 %324, i32* %__UNIQUE_ID___x600, align 4
  %325 = load i32, i32* %false_smin, align 4
  store i32 %325, i32* %__UNIQUE_ID___y601, align 4
  %326 = load i32, i32* %__UNIQUE_ID___x600, align 4
  %327 = load i32, i32* %__UNIQUE_ID___y601, align 4
  %cmp283 = icmp sgt i32 %326, %327
  br i1 %cmp283, label %cond.true285, label %cond.false286

cond.true285:                                     ; preds = %cond.end279
  %328 = load i32, i32* %__UNIQUE_ID___x600, align 4
  br label %cond.end287

cond.false286:                                    ; preds = %cond.end279
  %329 = load i32, i32* %__UNIQUE_ID___y601, align 4
  br label %cond.end287

cond.end287:                                      ; preds = %cond.false286, %cond.true285
  %cond288 = phi i32 [ %328, %cond.true285 ], [ %329, %cond.false286 ]
  store i32 %cond288, i32* %tmp282, align 4
  %330 = load i32, i32* %tmp282, align 4
  %331 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %s32_min_value289 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %331, i32 0, i32 10
  store i32 %330, i32* %s32_min_value289, align 8
  %332 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %s32_max_value290 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %332, i32 0, i32 11
  %333 = load i32, i32* %s32_max_value290, align 4
  store i32 %333, i32* %__UNIQUE_ID___x602, align 4
  %334 = load i32, i32* %true_smax, align 4
  store i32 %334, i32* %__UNIQUE_ID___y603, align 4
  %335 = load i32, i32* %__UNIQUE_ID___x602, align 4
  %336 = load i32, i32* %__UNIQUE_ID___y603, align 4
  %cmp292 = icmp slt i32 %335, %336
  br i1 %cmp292, label %cond.true294, label %cond.false295

cond.true294:                                     ; preds = %cond.end287
  %337 = load i32, i32* %__UNIQUE_ID___x602, align 4
  br label %cond.end296

cond.false295:                                    ; preds = %cond.end287
  %338 = load i32, i32* %__UNIQUE_ID___y603, align 4
  br label %cond.end296

cond.end296:                                      ; preds = %cond.false295, %cond.true294
  %cond297 = phi i32 [ %337, %cond.true294 ], [ %338, %cond.false295 ]
  store i32 %cond297, i32* %tmp291, align 4
  %339 = load i32, i32* %tmp291, align 4
  %340 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %s32_max_value298 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %340, i32 0, i32 11
  store i32 %339, i32* %s32_max_value298, align 4
  br label %if.end336

if.else299:                                       ; preds = %sw.bb262
  %341 = load i8, i8* %opcode.addr, align 1
  %conv301 = zext i8 %341 to i32
  %cmp302 = icmp eq i32 %conv301, 192
  br i1 %cmp302, label %cond.true304, label %cond.false305

cond.true304:                                     ; preds = %if.else299
  %342 = load i64, i64* %sval, align 8
  br label %cond.end307

cond.false305:                                    ; preds = %if.else299
  %343 = load i64, i64* %sval, align 8
  %add306 = add i64 %343, 1
  br label %cond.end307

cond.end307:                                      ; preds = %cond.false305, %cond.true304
  %cond308 = phi i64 [ %342, %cond.true304 ], [ %add306, %cond.false305 ]
  store i64 %cond308, i64* %false_smin300, align 8
  %344 = load i8, i8* %opcode.addr, align 1
  %conv310 = zext i8 %344 to i32
  %cmp311 = icmp eq i32 %conv310, 192
  br i1 %cmp311, label %cond.true313, label %cond.false315

cond.true313:                                     ; preds = %cond.end307
  %345 = load i64, i64* %sval, align 8
  %sub314 = sub i64 %345, 1
  br label %cond.end316

cond.false315:                                    ; preds = %cond.end307
  %346 = load i64, i64* %sval, align 8
  br label %cond.end316

cond.end316:                                      ; preds = %cond.false315, %cond.true313
  %cond317 = phi i64 [ %sub314, %cond.true313 ], [ %346, %cond.false315 ]
  store i64 %cond317, i64* %true_smax309, align 8
  %347 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smin_value318 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %347, i32 0, i32 6
  %348 = load i64, i64* %smin_value318, align 8
  store i64 %348, i64* %__UNIQUE_ID___x604, align 8
  %349 = load i64, i64* %false_smin300, align 8
  store i64 %349, i64* %__UNIQUE_ID___y605, align 8
  %350 = load i64, i64* %__UNIQUE_ID___x604, align 8
  %351 = load i64, i64* %__UNIQUE_ID___y605, align 8
  %cmp320 = icmp sgt i64 %350, %351
  br i1 %cmp320, label %cond.true322, label %cond.false323

cond.true322:                                     ; preds = %cond.end316
  %352 = load i64, i64* %__UNIQUE_ID___x604, align 8
  br label %cond.end324

cond.false323:                                    ; preds = %cond.end316
  %353 = load i64, i64* %__UNIQUE_ID___y605, align 8
  br label %cond.end324

cond.end324:                                      ; preds = %cond.false323, %cond.true322
  %cond325 = phi i64 [ %352, %cond.true322 ], [ %353, %cond.false323 ]
  store i64 %cond325, i64* %tmp319, align 8
  %354 = load i64, i64* %tmp319, align 8
  %355 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smin_value326 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %355, i32 0, i32 6
  store i64 %354, i64* %smin_value326, align 8
  %356 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smax_value327 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %356, i32 0, i32 7
  %357 = load i64, i64* %smax_value327, align 8
  store i64 %357, i64* %__UNIQUE_ID___x606, align 8
  %358 = load i64, i64* %true_smax309, align 8
  store i64 %358, i64* %__UNIQUE_ID___y607, align 8
  %359 = load i64, i64* %__UNIQUE_ID___x606, align 8
  %360 = load i64, i64* %__UNIQUE_ID___y607, align 8
  %cmp329 = icmp slt i64 %359, %360
  br i1 %cmp329, label %cond.true331, label %cond.false332

cond.true331:                                     ; preds = %cond.end324
  %361 = load i64, i64* %__UNIQUE_ID___x606, align 8
  br label %cond.end333

cond.false332:                                    ; preds = %cond.end324
  %362 = load i64, i64* %__UNIQUE_ID___y607, align 8
  br label %cond.end333

cond.end333:                                      ; preds = %cond.false332, %cond.true331
  %cond334 = phi i64 [ %361, %cond.true331 ], [ %362, %cond.false332 ]
  store i64 %cond334, i64* %tmp328, align 8
  %363 = load i64, i64* %tmp328, align 8
  %364 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smax_value335 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %364, i32 0, i32 7
  store i64 %363, i64* %smax_value335, align 8
  br label %if.end336

if.end336:                                        ; preds = %cond.end333, %cond.end296
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %if.end356

sw.epilog:                                        ; preds = %if.end336, %if.end261, %if.end186, %if.end115, %if.end51, %if.end21, %if.end11
  %365 = load i8, i8* %is_jmp32.addr, align 1
  %tobool337 = trunc i8 %365 to i1
  br i1 %tobool337, label %if.then338, label %if.else353

if.then338:                                       ; preds = %sw.epilog
  %366 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off339 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %366, i32 0, i32 5
  %367 = bitcast %struct.tnum* %false_64off to { i64, i64 }*
  %368 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %367, i32 0, i32 0
  %369 = load i64, i64* %368, align 8
  %370 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %367, i32 0, i32 1
  %371 = load i64, i64* %370, align 8
  %call342 = call { i64, i64 } @tnum_clear_subreg(i64 %369, i64 %371) #20
  %372 = bitcast %struct.tnum* %agg.tmp341 to { i64, i64 }*
  %373 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %372, i32 0, i32 0
  %374 = extractvalue { i64, i64 } %call342, 0
  store i64 %374, i64* %373, align 8
  %375 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %372, i32 0, i32 1
  %376 = extractvalue { i64, i64 } %call342, 1
  store i64 %376, i64* %375, align 8
  %377 = bitcast %struct.tnum* %false_32off to { i64, i64 }*
  %378 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %377, i32 0, i32 0
  %379 = load i64, i64* %378, align 8
  %380 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %377, i32 0, i32 1
  %381 = load i64, i64* %380, align 8
  %call344 = call { i64, i64 } @tnum_subreg(i64 %379, i64 %381) #20
  %382 = bitcast %struct.tnum* %agg.tmp343 to { i64, i64 }*
  %383 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %382, i32 0, i32 0
  %384 = extractvalue { i64, i64 } %call344, 0
  store i64 %384, i64* %383, align 8
  %385 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %382, i32 0, i32 1
  %386 = extractvalue { i64, i64 } %call344, 1
  store i64 %386, i64* %385, align 8
  %387 = bitcast %struct.tnum* %agg.tmp341 to { i64, i64 }*
  %388 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %387, i32 0, i32 0
  %389 = load i64, i64* %388, align 8
  %390 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %387, i32 0, i32 1
  %391 = load i64, i64* %390, align 8
  %392 = bitcast %struct.tnum* %agg.tmp343 to { i64, i64 }*
  %393 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %392, i32 0, i32 0
  %394 = load i64, i64* %393, align 8
  %395 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %392, i32 0, i32 1
  %396 = load i64, i64* %395, align 8
  %call345 = call { i64, i64 } @tnum_or(i64 %389, i64 %391, i64 %394, i64 %396) #20
  %397 = bitcast %struct.tnum* %tmp340 to { i64, i64 }*
  %398 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %397, i32 0, i32 0
  %399 = extractvalue { i64, i64 } %call345, 0
  store i64 %399, i64* %398, align 8
  %400 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %397, i32 0, i32 1
  %401 = extractvalue { i64, i64 } %call345, 1
  store i64 %401, i64* %400, align 8
  %402 = bitcast %struct.tnum* %var_off339 to i8*
  %403 = bitcast %struct.tnum* %tmp340 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %402, i8* align 8 %403, i64 16, i1 false)
  %404 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off346 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %404, i32 0, i32 5
  %405 = bitcast %struct.tnum* %true_64off to { i64, i64 }*
  %406 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %405, i32 0, i32 0
  %407 = load i64, i64* %406, align 8
  %408 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %405, i32 0, i32 1
  %409 = load i64, i64* %408, align 8
  %call349 = call { i64, i64 } @tnum_clear_subreg(i64 %407, i64 %409) #20
  %410 = bitcast %struct.tnum* %agg.tmp348 to { i64, i64 }*
  %411 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %410, i32 0, i32 0
  %412 = extractvalue { i64, i64 } %call349, 0
  store i64 %412, i64* %411, align 8
  %413 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %410, i32 0, i32 1
  %414 = extractvalue { i64, i64 } %call349, 1
  store i64 %414, i64* %413, align 8
  %415 = bitcast %struct.tnum* %true_32off to { i64, i64 }*
  %416 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %415, i32 0, i32 0
  %417 = load i64, i64* %416, align 8
  %418 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %415, i32 0, i32 1
  %419 = load i64, i64* %418, align 8
  %call351 = call { i64, i64 } @tnum_subreg(i64 %417, i64 %419) #20
  %420 = bitcast %struct.tnum* %agg.tmp350 to { i64, i64 }*
  %421 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %420, i32 0, i32 0
  %422 = extractvalue { i64, i64 } %call351, 0
  store i64 %422, i64* %421, align 8
  %423 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %420, i32 0, i32 1
  %424 = extractvalue { i64, i64 } %call351, 1
  store i64 %424, i64* %423, align 8
  %425 = bitcast %struct.tnum* %agg.tmp348 to { i64, i64 }*
  %426 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %425, i32 0, i32 0
  %427 = load i64, i64* %426, align 8
  %428 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %425, i32 0, i32 1
  %429 = load i64, i64* %428, align 8
  %430 = bitcast %struct.tnum* %agg.tmp350 to { i64, i64 }*
  %431 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %430, i32 0, i32 0
  %432 = load i64, i64* %431, align 8
  %433 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %430, i32 0, i32 1
  %434 = load i64, i64* %433, align 8
  %call352 = call { i64, i64 } @tnum_or(i64 %427, i64 %429, i64 %432, i64 %434) #20
  %435 = bitcast %struct.tnum* %tmp347 to { i64, i64 }*
  %436 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %435, i32 0, i32 0
  %437 = extractvalue { i64, i64 } %call352, 0
  store i64 %437, i64* %436, align 8
  %438 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %435, i32 0, i32 1
  %439 = extractvalue { i64, i64 } %call352, 1
  store i64 %439, i64* %438, align 8
  %440 = bitcast %struct.tnum* %var_off346 to i8*
  %441 = bitcast %struct.tnum* %tmp347 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %440, i8* align 8 %441, i64 16, i1 false)
  %442 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  call void @__reg_combine_32_into_64(%struct.bpf_reg_state* noundef %442) #20
  %443 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  call void @__reg_combine_32_into_64(%struct.bpf_reg_state* noundef %443) #20
  br label %if.end356

if.else353:                                       ; preds = %sw.epilog
  %444 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off354 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %444, i32 0, i32 5
  %445 = bitcast %struct.tnum* %var_off354 to i8*
  %446 = bitcast %struct.tnum* %false_64off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %445, i8* align 8 %446, i64 16, i1 false)
  %447 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off355 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %447, i32 0, i32 5
  %448 = bitcast %struct.tnum* %var_off355 to i8*
  %449 = bitcast %struct.tnum* %true_64off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %448, i8* align 8 %449, i64 16, i1 false)
  %450 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  call void @__reg_combine_64_into_32(%struct.bpf_reg_state* noundef %450) #20
  %451 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  call void @__reg_combine_64_into_32(%struct.bpf_reg_state* noundef %451) #20
  br label %if.end356

if.end356:                                        ; preds = %if.then, %sw.default, %if.else353, %if.then338
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %true_reg, %struct.bpf_reg_state* noundef %false_reg, i64 noundef %val, i32 noundef %val32, i8 noundef zeroext %opcode, i1 noundef zeroext %is_jmp32) #0 {
entry:
  %true_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %false_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %val32.addr = alloca i32, align 4
  %opcode.addr = alloca i8, align 1
  %is_jmp32.addr = alloca i8, align 1
  store %struct.bpf_reg_state* %true_reg, %struct.bpf_reg_state** %true_reg.addr, align 8
  store %struct.bpf_reg_state* %false_reg, %struct.bpf_reg_state** %false_reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i32 %val32, i32* %val32.addr, align 4
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %is_jmp32 to i8
  store i8 %frombool, i8* %is_jmp32.addr, align 1
  %0 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %0 to i32
  %call = call i32 @flip_opcode(i32 noundef %conv) #20
  %conv1 = trunc i32 %call to i8
  store i8 %conv1, i8* %opcode.addr, align 1
  %1 = load i8, i8* %opcode.addr, align 1
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %4 = load i64, i64* %val.addr, align 8
  %5 = load i32, i32* %val32.addr, align 4
  %6 = load i8, i8* %opcode.addr, align 1
  %7 = load i8, i8* %is_jmp32.addr, align 1
  %tobool2 = trunc i8 %7 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %2, %struct.bpf_reg_state* noundef %3, i64 noundef %4, i32 noundef %5, i8 noundef zeroext %6, i1 noundef zeroext %tobool2) #20
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_combine_min_max(%struct.bpf_reg_state* noundef %true_src, %struct.bpf_reg_state* noundef %true_dst, %struct.bpf_reg_state* noundef %false_src, %struct.bpf_reg_state* noundef %false_dst, i8 noundef zeroext %opcode) #0 {
entry:
  %true_src.addr = alloca %struct.bpf_reg_state*, align 8
  %true_dst.addr = alloca %struct.bpf_reg_state*, align 8
  %false_src.addr = alloca %struct.bpf_reg_state*, align 8
  %false_dst.addr = alloca %struct.bpf_reg_state*, align 8
  %opcode.addr = alloca i8, align 1
  store %struct.bpf_reg_state* %true_src, %struct.bpf_reg_state** %true_src.addr, align 8
  store %struct.bpf_reg_state* %true_dst, %struct.bpf_reg_state** %true_dst.addr, align 8
  store %struct.bpf_reg_state* %false_src, %struct.bpf_reg_state** %false_src.addr, align 8
  store %struct.bpf_reg_state* %false_dst, %struct.bpf_reg_state** %false_dst.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %0 to i32
  switch i32 %conv, label %sw.epilog [
    i32 16, label %sw.bb
    i32 80, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_src.addr, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_dst.addr, align 8
  call void @__reg_combine_min_max(%struct.bpf_reg_state* noundef %1, %struct.bpf_reg_state* noundef %2) #20
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_src.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_dst.addr, align 8
  call void @__reg_combine_min_max(%struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef %4) #20
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 45, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 61, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JNE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 93, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -83, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -67, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 109, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 125, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -51, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -35, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JEQ_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 30, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 46, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 62, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JNE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 94, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -82, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -66, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 110, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 126, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -50, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -34, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #20
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #20
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #20
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #20
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #20
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #20
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #20
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #20
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #20
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #20
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #20
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #20
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #20
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #20
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #20
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #20
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #20
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #20
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.then53, %if.then57, %if.end140, %if.end130
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @bpf_check_attach_target(%struct.bpf_verifier_log* noundef %log, %struct.bpf_prog* noundef %prog, %struct.bpf_prog* noundef %tgt_prog, i32 noundef %btf_id, %struct.bpf_attach_target_info* noundef %tgt_info) #0 {
entry:
  %retval = alloca i32, align 4
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %tgt_prog.addr = alloca %struct.bpf_prog*, align 8
  %btf_id.addr = alloca i32, align 4
  %tgt_info.addr = alloca %struct.bpf_attach_target_info*, align 8
  %prog_extension = alloca i8, align 1
  %prefix = alloca [11 x i8], align 1
  %ret = alloca i32, align 4
  %subprog = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.btf_type*, align 8
  %conservative = alloca i8, align 1
  %tname = alloca i8*, align 8
  %btf = alloca %struct.btf*, align 8
  %addr = alloca i64, align 8
  %aux16 = alloca %struct.bpf_prog_aux*, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store %struct.bpf_prog* %tgt_prog, %struct.bpf_prog** %tgt_prog.addr, align 8
  store i32 %btf_id, i32* %btf_id.addr, align 4
  store %struct.bpf_attach_target_info* %tgt_info, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 2
  %1 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %1, 28
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %prog_extension, align 1
  %2 = bitcast [11 x i8]* %prefix to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %2, i8* align 1 getelementptr inbounds ([11 x i8], [11 x i8]* @__const.bpf_check_attach_target.prefix, i32 0, i32 0), i64 11, i1 false)
  store i32 0, i32* %ret, align 4
  store i32 -1, i32* %subprog, align 4
  store i8 1, i8* %conservative, align 1
  store i64 0, i64* %addr, align 8
  %3 = load i32, i32* %btf_id.addr, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %4, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.7, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool1 = icmp ne %struct.bpf_prog* %5, null
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 10
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 50
  %8 = load %struct.btf*, %struct.btf** %btf2, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %9, i32 0, i32 10
  %10 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %attach_btf = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %10, i32 0, i32 14
  %11 = load %struct.btf*, %struct.btf** %attach_btf, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.btf* [ %8, %cond.true ], [ %11, %cond.false ]
  store %struct.btf* %cond, %struct.btf** %btf, align 8
  %12 = load %struct.btf*, %struct.btf** %btf, align 8
  %tobool4 = icmp ne %struct.btf* %12, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %cond.end
  %13 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %13, i8* noundef getelementptr inbounds ([81 x i8], [81 x i8]* @.str.8, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %cond.end
  %14 = load %struct.btf*, %struct.btf** %btf, align 8
  %15 = load i32, i32* %btf_id.addr, align 4
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %14, i32 noundef %15) #20
  store %struct.btf_type* %call, %struct.btf_type** %t, align 8
  %16 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %tobool7 = icmp ne %struct.btf_type* %16, null
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end6
  %17 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %18 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %17, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.9, i64 0, i64 0), i32 noundef %18) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end6
  %19 = load %struct.btf*, %struct.btf** %btf, align 8
  %20 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %20, i32 0, i32 0
  %21 = load i32, i32* %name_off, align 4
  %call10 = call i8* @btf_name_by_offset(%struct.btf* noundef %19, i32 noundef %21) #20
  store i8* %call10, i8** %tname, align 8
  %22 = load i8*, i8** %tname, align 8
  %tobool11 = icmp ne i8* %22, null
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end9
  %23 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %24 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %23, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.10, i64 0, i64 0), i32 noundef %24) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end9
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool14 = icmp ne %struct.bpf_prog* %25, null
  br i1 %tobool14, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end13
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %aux17 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %26, i32 0, i32 10
  %27 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux17, align 8
  store %struct.bpf_prog_aux* %27, %struct.bpf_prog_aux** %aux16, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then15
  %28 = load i32, i32* %i, align 4
  %29 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux16, align 8
  %func_info_cnt = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %29, i32 0, i32 55
  %30 = load i32, i32* %func_info_cnt, align 8
  %cmp18 = icmp ult i32 %28, %30
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %31 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux16, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %31, i32 0, i32 51
  %32 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info, align 8
  %33 = load i32, i32* %i, align 4
  %idxprom = sext i32 %33 to i64
  %arrayidx = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %32, i64 %idxprom
  %type_id = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx, i32 0, i32 1
  %34 = load i32, i32* %type_id, align 4
  %35 = load i32, i32* %btf_id.addr, align 4
  %cmp19 = icmp eq i32 %34, %35
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %for.body
  %36 = load i32, i32* %i, align 4
  store i32 %36, i32* %subprog, align 4
  br label %for.end

if.end21:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end21
  %37 = load i32, i32* %i, align 4
  %inc = add i32 %37, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !18

for.end:                                          ; preds = %if.then20, %for.cond
  %38 = load i32, i32* %subprog, align 4
  %cmp22 = icmp eq i32 %38, -1
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %for.end
  %39 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %40 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %39, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.11, i64 0, i64 0), i8* noundef %40) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %for.end
  %41 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux16, align 8
  %func_info_aux = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %41, i32 0, i32 52
  %42 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %43 = load i32, i32* %subprog, align 4
  %idxprom25 = sext i32 %43 to i64
  %arrayidx26 = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %42, i64 %idxprom25
  %unreliable = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx26, i32 0, i32 1
  %44 = load i8, i8* %unreliable, align 2
  %tobool27 = trunc i8 %44 to i1
  %frombool28 = zext i1 %tobool27 to i8
  store i8 %frombool28, i8* %conservative, align 1
  %45 = load i8, i8* %prog_extension, align 1
  %tobool29 = trunc i8 %45 to i1
  br i1 %tobool29, label %if.then30, label %if.end37

if.then30:                                        ; preds = %if.end24
  %46 = load i8, i8* %conservative, align 1
  %tobool31 = trunc i8 %46 to i1
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.then30
  %47 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %47, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.12, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.then30
  %48 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %48, i32 0, i32 1
  %bf.load = load i16, i16* %jit_requested, align 2
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %tobool34 = icmp ne i16 %bf.clear, 0
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.end33
  %49 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %49, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.13, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.end33
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end24
  %50 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %jited = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %50, i32 0, i32 1
  %bf.load38 = load i16, i16* %jited, align 2
  %bf.clear39 = and i16 %bf.load38, 1
  %tobool40 = icmp ne i16 %bf.clear39, 0
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.end37
  %51 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %51, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.14, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end42:                                         ; preds = %if.end37
  %52 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %type43 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %52, i32 0, i32 2
  %53 = load i32, i32* %type43, align 4
  %54 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type44 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %54, i32 0, i32 2
  %55 = load i32, i32* %type44, align 4
  %cmp45 = icmp eq i32 %53, %55
  br i1 %cmp45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.end42
  %56 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %56, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.15, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end47:                                         ; preds = %if.end42
  %57 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %type48 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %57, i32 0, i32 2
  %58 = load i32, i32* %type48, align 4
  %cmp49 = icmp eq i32 %58, 26
  br i1 %cmp49, label %land.lhs.true, label %if.end56

land.lhs.true:                                    ; preds = %if.end47
  %59 = load i8, i8* %prog_extension, align 1
  %tobool50 = trunc i8 %59 to i1
  br i1 %tobool50, label %land.lhs.true51, label %if.end56

land.lhs.true51:                                  ; preds = %land.lhs.true
  %60 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %60, i32 0, i32 3
  %61 = load i32, i32* %expected_attach_type, align 8
  %cmp52 = icmp eq i32 %61, 24
  br i1 %cmp52, label %if.then55, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true51
  %62 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %expected_attach_type53 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %62, i32 0, i32 3
  %63 = load i32, i32* %expected_attach_type53, align 8
  %cmp54 = icmp eq i32 %63, 25
  br i1 %cmp54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %lor.lhs.false, %land.lhs.true51
  %64 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %64, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.16, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end56:                                         ; preds = %lor.lhs.false, %land.lhs.true, %if.end47
  br label %if.end60

if.else:                                          ; preds = %if.end13
  %65 = load i8, i8* %prog_extension, align 1
  %tobool57 = trunc i8 %65 to i1
  br i1 %tobool57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %if.else
  %66 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %66, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.17, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end59:                                         ; preds = %if.else
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.end56
  %67 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %expected_attach_type61 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %67, i32 0, i32 3
  %68 = load i32, i32* %expected_attach_type61, align 8
  switch i32 %68, label %sw.default [
    i32 23, label %sw.bb
    i32 28, label %sw.bb82
    i32 26, label %sw.bb98
    i32 27, label %sw.bb98
    i32 43, label %sw.bb98
    i32 24, label %sw.bb98
    i32 25, label %sw.bb98
  ]

sw.bb:                                            ; preds = %if.end60
  %69 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool62 = icmp ne %struct.bpf_prog* %69, null
  br i1 %tobool62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %sw.bb
  %70 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %70, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.18, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end64:                                         ; preds = %sw.bb
  %71 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call65 = call zeroext i1 @btf_type_is_typedef(%struct.btf_type* noundef %71) #20
  br i1 %call65, label %if.end67, label %if.then66

if.then66:                                        ; preds = %if.end64
  %72 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %73 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %72, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.19, i64 0, i64 0), i32 noundef %73) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.end64
  %arraydecay = getelementptr inbounds [11 x i8], [11 x i8]* %prefix, i64 0, i64 0
  %74 = load i8*, i8** %tname, align 8
  %call68 = call i32 @strncmp(i8* noundef %arraydecay, i8* noundef %74, i64 noundef 10) #20
  %tobool69 = icmp ne i32 %call68, 0
  br i1 %tobool69, label %if.then70, label %if.end71

if.then70:                                        ; preds = %if.end67
  %75 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %76 = load i32, i32* %btf_id.addr, align 4
  %77 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %75, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.20, i64 0, i64 0), i32 noundef %76, i8* noundef %77) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end71:                                         ; preds = %if.end67
  %78 = load i8*, i8** %tname, align 8
  %add.ptr = getelementptr i8, i8* %78, i64 10
  store i8* %add.ptr, i8** %tname, align 8
  %79 = load %struct.btf*, %struct.btf** %btf, align 8
  %80 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %81 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %80, i32 0, i32 2
  %type72 = bitcast %union.anon.137* %81 to i32*
  %82 = load i32, i32* %type72, align 4
  %call73 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %79, i32 noundef %82) #20
  store %struct.btf_type* %call73, %struct.btf_type** %t, align 8
  %83 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call74 = call zeroext i1 @btf_type_is_ptr(%struct.btf_type* noundef %83) #20
  br i1 %call74, label %if.end76, label %if.then75

if.then75:                                        ; preds = %if.end71
  store i32 -22, i32* %retval, align 4
  br label %return

if.end76:                                         ; preds = %if.end71
  %84 = load %struct.btf*, %struct.btf** %btf, align 8
  %85 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %86 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %85, i32 0, i32 2
  %type77 = bitcast %union.anon.137* %86 to i32*
  %87 = load i32, i32* %type77, align 4
  %call78 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %84, i32 noundef %87) #20
  store %struct.btf_type* %call78, %struct.btf_type** %t, align 8
  %88 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call79 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %88) #20
  br i1 %call79, label %if.end81, label %if.then80

if.then80:                                        ; preds = %if.end76
  store i32 -22, i32* %retval, align 4
  br label %return

if.end81:                                         ; preds = %if.end76
  br label %sw.epilog190

sw.bb82:                                          ; preds = %if.end60
  %89 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call83 = call zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %89) #20
  br i1 %call83, label %if.end85, label %if.then84

if.then84:                                        ; preds = %sw.bb82
  %90 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %91 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %90, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.21, i64 0, i64 0), i32 noundef %91) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end85:                                         ; preds = %sw.bb82
  %92 = load %struct.btf*, %struct.btf** %btf, align 8
  %93 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %94 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %93, i32 0, i32 2
  %type86 = bitcast %union.anon.137* %94 to i32*
  %95 = load i32, i32* %type86, align 4
  %call87 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %92, i32 noundef %95) #20
  store %struct.btf_type* %call87, %struct.btf_type** %t, align 8
  %96 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call88 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %96) #20
  br i1 %call88, label %if.end90, label %if.then89

if.then89:                                        ; preds = %if.end85
  store i32 -22, i32* %retval, align 4
  br label %return

if.end90:                                         ; preds = %if.end85
  %97 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %98 = load %struct.btf*, %struct.btf** %btf, align 8
  %99 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %100 = load i8*, i8** %tname, align 8
  %101 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %fmodel = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %101, i32 0, i32 0
  %call91 = call i32 @btf_distill_func_proto(%struct.bpf_verifier_log* noundef %97, %struct.btf* noundef %98, %struct.btf_type* noundef %99, i8* noundef %100, %struct.btf_func_model* noundef %fmodel) #20
  store i32 %call91, i32* %ret, align 4
  %102 = load i32, i32* %ret, align 4
  %tobool92 = icmp ne i32 %102, 0
  br i1 %tobool92, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.end90
  %103 = load i32, i32* %ret, align 4
  store i32 %103, i32* %retval, align 4
  br label %return

if.end94:                                         ; preds = %if.end90
  br label %sw.epilog190

sw.default:                                       ; preds = %if.end60
  %104 = load i8, i8* %prog_extension, align 1
  %tobool95 = trunc i8 %104 to i1
  br i1 %tobool95, label %if.end97, label %if.then96

if.then96:                                        ; preds = %sw.default
  store i32 -22, i32* %retval, align 4
  br label %return

if.end97:                                         ; preds = %sw.default
  br label %sw.bb98

sw.bb98:                                          ; preds = %if.end60, %if.end60, %if.end60, %if.end60, %if.end60, %if.end97
  %105 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call99 = call zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %105) #20
  br i1 %call99, label %if.end101, label %if.then100

if.then100:                                       ; preds = %sw.bb98
  %106 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %107 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %106, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.21, i64 0, i64 0), i32 noundef %107) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end101:                                        ; preds = %sw.bb98
  %108 = load i8, i8* %prog_extension, align 1
  %tobool102 = trunc i8 %108 to i1
  br i1 %tobool102, label %land.lhs.true103, label %if.end107

land.lhs.true103:                                 ; preds = %if.end101
  %109 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %110 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %111 = load %struct.btf*, %struct.btf** %btf, align 8
  %112 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call104 = call i32 @btf_check_type_match(%struct.bpf_verifier_log* noundef %109, %struct.bpf_prog* noundef %110, %struct.btf* noundef %111, %struct.btf_type* noundef %112) #20
  %tobool105 = icmp ne i32 %call104, 0
  br i1 %tobool105, label %if.then106, label %if.end107

if.then106:                                       ; preds = %land.lhs.true103
  store i32 -22, i32* %retval, align 4
  br label %return

if.end107:                                        ; preds = %land.lhs.true103, %if.end101
  %113 = load %struct.btf*, %struct.btf** %btf, align 8
  %114 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %115 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %114, i32 0, i32 2
  %type108 = bitcast %union.anon.137* %115 to i32*
  %116 = load i32, i32* %type108, align 4
  %call109 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %113, i32 noundef %116) #20
  store %struct.btf_type* %call109, %struct.btf_type** %t, align 8
  %117 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call110 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %117) #20
  br i1 %call110, label %if.end112, label %if.then111

if.then111:                                       ; preds = %if.end107
  store i32 -22, i32* %retval, align 4
  br label %return

if.end112:                                        ; preds = %if.end107
  %118 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux113 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %118, i32 0, i32 10
  %119 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux113, align 8
  %saved_dst_prog_type = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %119, i32 0, i32 19
  %120 = load i32, i32* %saved_dst_prog_type, align 8
  %tobool114 = icmp ne i32 %120, 0
  br i1 %tobool114, label %land.lhs.true118, label %lor.lhs.false115

lor.lhs.false115:                                 ; preds = %if.end112
  %121 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux116 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %121, i32 0, i32 10
  %122 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux116, align 8
  %saved_dst_attach_type = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %122, i32 0, i32 20
  %123 = load i32, i32* %saved_dst_attach_type, align 4
  %tobool117 = icmp ne i32 %123, 0
  br i1 %tobool117, label %land.lhs.true118, label %if.end131

land.lhs.true118:                                 ; preds = %lor.lhs.false115, %if.end112
  %124 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool119 = icmp ne %struct.bpf_prog* %124, null
  br i1 %tobool119, label %lor.lhs.false120, label %if.then130

lor.lhs.false120:                                 ; preds = %land.lhs.true118
  %125 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux121 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %125, i32 0, i32 10
  %126 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux121, align 8
  %saved_dst_prog_type122 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %126, i32 0, i32 19
  %127 = load i32, i32* %saved_dst_prog_type122, align 8
  %128 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %type123 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %128, i32 0, i32 2
  %129 = load i32, i32* %type123, align 4
  %cmp124 = icmp ne i32 %127, %129
  br i1 %cmp124, label %if.then130, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %lor.lhs.false120
  %130 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux126 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %130, i32 0, i32 10
  %131 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux126, align 8
  %saved_dst_attach_type127 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %131, i32 0, i32 20
  %132 = load i32, i32* %saved_dst_attach_type127, align 4
  %133 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %expected_attach_type128 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %133, i32 0, i32 3
  %134 = load i32, i32* %expected_attach_type128, align 8
  %cmp129 = icmp ne i32 %132, %134
  br i1 %cmp129, label %if.then130, label %if.end131

if.then130:                                       ; preds = %lor.lhs.false125, %lor.lhs.false120, %land.lhs.true118
  store i32 -22, i32* %retval, align 4
  br label %return

if.end131:                                        ; preds = %lor.lhs.false125, %lor.lhs.false115
  %135 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool132 = icmp ne %struct.bpf_prog* %135, null
  br i1 %tobool132, label %land.lhs.true133, label %if.end136

land.lhs.true133:                                 ; preds = %if.end131
  %136 = load i8, i8* %conservative, align 1
  %tobool134 = trunc i8 %136 to i1
  br i1 %tobool134, label %if.then135, label %if.end136

if.then135:                                       ; preds = %land.lhs.true133
  store %struct.btf_type* null, %struct.btf_type** %t, align 8
  br label %if.end136

if.end136:                                        ; preds = %if.then135, %land.lhs.true133, %if.end131
  %137 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %138 = load %struct.btf*, %struct.btf** %btf, align 8
  %139 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %140 = load i8*, i8** %tname, align 8
  %141 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %fmodel137 = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %141, i32 0, i32 0
  %call138 = call i32 @btf_distill_func_proto(%struct.bpf_verifier_log* noundef %137, %struct.btf* noundef %138, %struct.btf_type* noundef %139, i8* noundef %140, %struct.btf_func_model* noundef %fmodel137) #20
  store i32 %call138, i32* %ret, align 4
  %142 = load i32, i32* %ret, align 4
  %cmp139 = icmp slt i32 %142, 0
  br i1 %cmp139, label %if.then140, label %if.end141

if.then140:                                       ; preds = %if.end136
  %143 = load i32, i32* %ret, align 4
  store i32 %143, i32* %retval, align 4
  br label %return

if.end141:                                        ; preds = %if.end136
  %144 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool142 = icmp ne %struct.bpf_prog* %144, null
  br i1 %tobool142, label %if.then143, label %if.else152

if.then143:                                       ; preds = %if.end141
  %145 = load i32, i32* %subprog, align 4
  %cmp144 = icmp eq i32 %145, 0
  br i1 %cmp144, label %if.then145, label %if.else146

if.then145:                                       ; preds = %if.then143
  %146 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %bpf_func = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %146, i32 0, i32 9
  %147 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func, align 8
  %148 = ptrtoint i32 (i8*, %struct.bpf_insn*)* %147 to i64
  store i64 %148, i64* %addr, align 8
  br label %if.end151

if.else146:                                       ; preds = %if.then143
  %149 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %aux147 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %149, i32 0, i32 10
  %150 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux147, align 8
  %func = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %150, i32 0, i32 30
  %151 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %152 = load i32, i32* %subprog, align 4
  %idxprom148 = sext i32 %152 to i64
  %arrayidx149 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %151, i64 %idxprom148
  %153 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx149, align 8
  %bpf_func150 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %153, i32 0, i32 9
  %154 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func150, align 8
  %155 = ptrtoint i32 (i8*, %struct.bpf_insn*)* %154 to i64
  store i64 %155, i64* %addr, align 8
  br label %if.end151

if.end151:                                        ; preds = %if.else146, %if.then145
  br label %if.end157

if.else152:                                       ; preds = %if.end141
  %156 = load i8*, i8** %tname, align 8
  %call153 = call i64 @kallsyms_lookup_name(i8* noundef %156) #20
  store i64 %call153, i64* %addr, align 8
  %157 = load i64, i64* %addr, align 8
  %tobool154 = icmp ne i64 %157, 0
  br i1 %tobool154, label %if.end156, label %if.then155

if.then155:                                       ; preds = %if.else152
  %158 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %159 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %158, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.22, i64 0, i64 0), i8* noundef %159) #20
  store i32 -2, i32* %retval, align 4
  br label %return

if.end156:                                        ; preds = %if.else152
  br label %if.end157

if.end157:                                        ; preds = %if.end156, %if.end151
  %160 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux158 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %160, i32 0, i32 10
  %161 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux158, align 8
  %sleepable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %161, i32 0, i32 25
  %162 = load i8, i8* %sleepable, align 4
  %tobool159 = trunc i8 %162 to i1
  br i1 %tobool159, label %if.then160, label %if.else177

if.then160:                                       ; preds = %if.end157
  store i32 -22, i32* %ret, align 4
  %163 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type161 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %163, i32 0, i32 2
  %164 = load i32, i32* %type161, align 4
  switch i32 %164, label %sw.default173 [
    i32 26, label %sw.bb162
    i32 29, label %sw.bb169
  ]

sw.bb162:                                         ; preds = %if.then160
  %165 = load i32, i32* %btf_id.addr, align 4
  %call163 = call i32 @check_non_sleepable_error_inject(i32 noundef %165) #20
  %tobool164 = icmp ne i32 %call163, 0
  br i1 %tobool164, label %if.end168, label %land.lhs.true165

land.lhs.true165:                                 ; preds = %sw.bb162
  %166 = load i64, i64* %addr, align 8
  %call166 = call zeroext i1 @within_error_injection_list(i64 noundef %166) #20
  br i1 %call166, label %if.then167, label %if.end168

if.then167:                                       ; preds = %land.lhs.true165
  store i32 0, i32* %ret, align 4
  br label %if.end168

if.end168:                                        ; preds = %if.then167, %land.lhs.true165, %sw.bb162
  br label %sw.epilog

sw.bb169:                                         ; preds = %if.then160
  %167 = load i32, i32* %btf_id.addr, align 4
  %call170 = call zeroext i1 @bpf_lsm_is_sleepable_hook(i32 noundef %167) #20
  br i1 %call170, label %if.then171, label %if.end172

if.then171:                                       ; preds = %sw.bb169
  store i32 0, i32* %ret, align 4
  br label %if.end172

if.end172:                                        ; preds = %if.then171, %sw.bb169
  br label %sw.epilog

sw.default173:                                    ; preds = %if.then160
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default173, %if.end172, %if.end168
  %168 = load i32, i32* %ret, align 4
  %tobool174 = icmp ne i32 %168, 0
  br i1 %tobool174, label %if.then175, label %if.end176

if.then175:                                       ; preds = %sw.epilog
  %169 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %170 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %169, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.23, i64 0, i64 0), i8* noundef %170) #20
  %171 = load i32, i32* %ret, align 4
  store i32 %171, i32* %retval, align 4
  br label %return

if.end176:                                        ; preds = %sw.epilog
  br label %if.end189

if.else177:                                       ; preds = %if.end157
  %172 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %expected_attach_type178 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %172, i32 0, i32 3
  %173 = load i32, i32* %expected_attach_type178, align 8
  %cmp179 = icmp eq i32 %173, 26
  br i1 %cmp179, label %if.then180, label %if.end188

if.then180:                                       ; preds = %if.else177
  %174 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool181 = icmp ne %struct.bpf_prog* %174, null
  br i1 %tobool181, label %if.then182, label %if.end183

if.then182:                                       ; preds = %if.then180
  %175 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %175, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.24, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end183:                                        ; preds = %if.then180
  %176 = load i64, i64* %addr, align 8
  %177 = load i8*, i8** %tname, align 8
  %call184 = call i32 @check_attach_modify_return(i64 noundef %176, i8* noundef %177) #20
  store i32 %call184, i32* %ret, align 4
  %178 = load i32, i32* %ret, align 4
  %tobool185 = icmp ne i32 %178, 0
  br i1 %tobool185, label %if.then186, label %if.end187

if.then186:                                       ; preds = %if.end183
  %179 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %180 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %179, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.25, i64 0, i64 0), i8* noundef %180) #20
  %181 = load i32, i32* %ret, align 4
  store i32 %181, i32* %retval, align 4
  br label %return

if.end187:                                        ; preds = %if.end183
  br label %if.end188

if.end188:                                        ; preds = %if.end187, %if.else177
  br label %if.end189

if.end189:                                        ; preds = %if.end188, %if.end176
  br label %sw.epilog190

sw.epilog190:                                     ; preds = %if.end189, %if.end94, %if.end81
  %182 = load i64, i64* %addr, align 8
  %183 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %tgt_addr = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %183, i32 0, i32 1
  store i64 %182, i64* %tgt_addr, align 8
  %184 = load i8*, i8** %tname, align 8
  %185 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %tgt_name = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %185, i32 0, i32 2
  store i8* %184, i8** %tgt_name, align 8
  %186 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %187 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %tgt_type = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %187, i32 0, i32 3
  store %struct.btf_type* %186, %struct.btf_type** %tgt_type, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog190, %if.then186, %if.then182, %if.then175, %if.then155, %if.then140, %if.then130, %if.then111, %if.then106, %if.then100, %if.then96, %if.then93, %if.then89, %if.then84, %if.then80, %if.then75, %if.then70, %if.then66, %if.then63, %if.then58, %if.then55, %if.then46, %if.then41, %if.then35, %if.then32, %if.then23, %if.then12, %if.then8, %if.then5, %if.then
  %188 = load i32, i32* %retval, align 4
  ret i32 %188
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_type_by_id(%struct.btf* noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @btf_name_by_offset(%struct.btf* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_typedef(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 8
  ret i1 %cmp
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @strncmp(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_ptr(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 2
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 13
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 12
  ret i1 %cmp
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_distill_func_proto(%struct.bpf_verifier_log* noundef, %struct.btf* noundef, %struct.btf_type* noundef, i8* noundef, %struct.btf_func_model* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_check_type_match(%struct.bpf_verifier_log* noundef, %struct.bpf_prog* noundef, %struct.btf* noundef, %struct.btf_type* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @kallsyms_lookup_name(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_non_sleepable_error_inject(i32 noundef %btf_id) #0 {
entry:
  %btf_id.addr = alloca i32, align 4
  store i32 %btf_id, i32* %btf_id.addr, align 4
  %0 = load i32, i32* %btf_id.addr, align 4
  %call = call zeroext i1 @btf_id_set_contains(%struct.btf_id_set* noundef @btf_non_sleepable_error_inject, i32 noundef %0) #20
  %conv = zext i1 %call to i32
  ret i32 %conv
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @within_error_injection_list(i64 noundef %addr) #0 {
entry:
  %addr.addr = alloca i64, align 8
  store i64 %addr, i64* %addr.addr, align 8
  ret i1 false
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_lsm_is_sleepable_hook(i32 noundef %btf_id) #0 {
entry:
  %btf_id.addr = alloca i32, align 4
  store i32 %btf_id, i32* %btf_id.addr, align 4
  ret i1 false
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_attach_modify_return(i64 noundef %addr, i8* noundef %func_name) #0 {
entry:
  %retval = alloca i32, align 4
  %addr.addr = alloca i64, align 8
  %func_name.addr = alloca i8*, align 8
  store i64 %addr, i64* %addr.addr, align 8
  store i8* %func_name, i8** %func_name.addr, align 8
  %0 = load i64, i64* %addr.addr, align 8
  %call = call zeroext i1 @within_error_injection_list(i64 noundef %0) #20
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8*, i8** %func_name.addr, align 8
  %call1 = call i32 @strncmp(i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.216, i64 0, i64 0), i8* noundef %1, i64 noundef 9) #20
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local %struct.btf* @bpf_get_btf_vmlinux() #0 {
entry:
  %0 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool = icmp ne %struct.btf* %0, null
  br i1 %tobool, label %if.end3, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  br i1 false, label %if.then, label %if.end3

if.then:                                          ; preds = %land.lhs.true
  call void @mutex_lock(%struct.mutex* noundef @bpf_verifier_lock) #20
  %1 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool1 = icmp ne %struct.btf* %1, null
  br i1 %tobool1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  %call = call %struct.btf* @btf_parse_vmlinux() #20
  store %struct.btf* %call, %struct.btf** @btf_vmlinux, align 8
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  call void @mutex_unlock(%struct.mutex* noundef @bpf_verifier_lock) #20
  br label %if.end3

if.end3:                                          ; preds = %if.end, %land.lhs.true, %entry
  %2 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  ret %struct.btf* %2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @mutex_lock(%struct.mutex* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf* @btf_parse_vmlinux() #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @mutex_unlock(%struct.mutex* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @bpf_check(%struct.bpf_prog** noundef %prog, %union.bpf_attr* noundef %attr, i8* %uattr.coerce0, i8 %uattr.coerce1) #0 {
entry:
  %retval = alloca i32, align 4
  %uattr = alloca %struct.sockptr_t, align 8
  %prog.addr = alloca %struct.bpf_prog**, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %start_time = alloca i64, align 8
  %env = alloca %struct.bpf_verifier_env*, align 8
  %log = alloca %struct.bpf_verifier_log*, align 8
  %i = alloca i32, align 4
  %len = alloca i32, align 4
  %ret = alloca i32, align 4
  %is_priv = alloca i8, align 1
  %tmp = alloca %struct.sockptr_t, align 8
  %0 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %uattr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %uattr.coerce1, i8* %2, align 8
  store %struct.bpf_prog** %prog, %struct.bpf_prog*** %prog.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  %call = call i64 @ktime_get_ns() #20
  store i64 %call, i64* %start_time, align 8
  store i32 -22, i32* %ret, align 4
  %call1 = call noalias i8* @kzalloc(i64 noundef 7576, i32 noundef 3264) #24
  %3 = bitcast i8* %call1 to %struct.bpf_verifier_env*
  store %struct.bpf_verifier_env* %3, %struct.bpf_verifier_env** %env, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %tobool = icmp ne %struct.bpf_verifier_env* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 26
  store %struct.bpf_verifier_log* %log2, %struct.bpf_verifier_log** %log, align 8
  %6 = load %struct.bpf_prog**, %struct.bpf_prog*** %prog.addr, align 8
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %6, align 8
  %len3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 4
  %8 = load i32, i32* %len3, align 4
  store i32 %8, i32* %len, align 4
  %9 = load i32, i32* %len, align 4
  %conv = sext i32 %9 to i64
  %call4 = call i64 @size_mul(i64 noundef 56, i64 noundef %conv) #20
  %call5 = call noalias i8* @vzalloc(i64 noundef %call4) #24
  %10 = bitcast i8* %call5 to %struct.bpf_insn_aux_data*
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 24
  store %struct.bpf_insn_aux_data* %10, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store i32 -12, i32* %ret, align 4
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 24
  %13 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data6, align 8
  %tobool7 = icmp ne %struct.bpf_insn_aux_data* %13, null
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %err_free_env

if.end9:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %14 = load i32, i32* %i, align 4
  %15 = load i32, i32* %len, align 4
  %cmp = icmp slt i32 %14, %15
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load i32, i32* %i, align 4
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 24
  %18 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data11, align 8
  %19 = load i32, i32* %i, align 4
  %idxprom = sext i32 %19 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %18, i64 %idxprom
  %orig_idx = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 7
  store i32 %16, i32* %orig_idx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, i32* %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !19

for.end:                                          ; preds = %for.cond
  %21 = load %struct.bpf_prog**, %struct.bpf_prog*** %prog.addr, align 8
  %22 = load %struct.bpf_prog*, %struct.bpf_prog** %21, align 8
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %23, i32 0, i32 2
  store %struct.bpf_prog* %22, %struct.bpf_prog** %prog12, align 8
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog13 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 2
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %prog13, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %25, i32 0, i32 2
  %26 = load i32, i32* %type, align 4
  %idxprom14 = zext i32 %26 to i64
  %arrayidx15 = getelementptr [32 x %struct.bpf_verifier_ops*], [32 x %struct.bpf_verifier_ops*]* @bpf_verifier_ops, i64 0, i64 %idxprom14
  %27 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %arrayidx15, align 8
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 3
  store %struct.bpf_verifier_ops* %27, %struct.bpf_verifier_ops** %ops, align 8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %fd_array = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 41
  %30 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %31 = bitcast %union.bpf_attr* %30 to %struct.anon.144*
  %fd_array16 = getelementptr inbounds %struct.anon.144, %struct.anon.144* %31, i32 0, i32 22
  %32 = load i64, i64* %fd_array16, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %uattr, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  %call17 = call { i8*, i8 } @make_bpfptr(i64 noundef %32, i1 noundef zeroext %bf.cast) #20
  %33 = bitcast %struct.sockptr_t* %tmp to { i8*, i8 }*
  %34 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %33, i32 0, i32 0
  %35 = extractvalue { i8*, i8 } %call17, 0
  store i8* %35, i8** %34, align 8
  %36 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %33, i32 0, i32 1
  %37 = extractvalue { i8*, i8 } %call17, 1
  store i8 %37, i8* %36, align 8
  %38 = bitcast %struct.sockptr_t* %fd_array to i8*
  %39 = bitcast %struct.sockptr_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %38, i8* align 8 %39, i64 16, i1 false)
  %call18 = call zeroext i1 @bpf_capable() #20
  %frombool = zext i1 %call18 to i8
  store i8 %frombool, i8* %is_priv, align 1
  %call19 = call %struct.btf* @bpf_get_btf_vmlinux() #20
  %40 = load i8, i8* %is_priv, align 1
  %tobool20 = trunc i8 %40 to i1
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %for.end
  call void @mutex_lock(%struct.mutex* noundef @bpf_verifier_lock) #20
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %for.end
  %41 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %42 = bitcast %union.bpf_attr* %41 to %struct.anon.144*
  %log_level = getelementptr inbounds %struct.anon.144, %struct.anon.144* %42, i32 0, i32 4
  %43 = load i32, i32* %log_level, align 8
  %tobool23 = icmp ne i32 %43, 0
  br i1 %tobool23, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end22
  %44 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %45 = bitcast %union.bpf_attr* %44 to %struct.anon.144*
  %log_buf = getelementptr inbounds %struct.anon.144, %struct.anon.144* %45, i32 0, i32 6
  %46 = load i64, i64* %log_buf, align 8
  %tobool24 = icmp ne i64 %46, 0
  br i1 %tobool24, label %if.then27, label %lor.lhs.false25

lor.lhs.false25:                                  ; preds = %lor.lhs.false
  %47 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %48 = bitcast %union.bpf_attr* %47 to %struct.anon.144*
  %log_size = getelementptr inbounds %struct.anon.144, %struct.anon.144* %48, i32 0, i32 5
  %49 = load i32, i32* %log_size, align 4
  %tobool26 = icmp ne i32 %49, 0
  br i1 %tobool26, label %if.then27, label %if.end34

if.then27:                                        ; preds = %lor.lhs.false25, %lor.lhs.false, %if.end22
  %50 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %51 = bitcast %union.bpf_attr* %50 to %struct.anon.144*
  %log_level28 = getelementptr inbounds %struct.anon.144, %struct.anon.144* %51, i32 0, i32 4
  %52 = load i32, i32* %log_level28, align 8
  %53 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %53, i32 0, i32 0
  store i32 %52, i32* %level, align 8
  %54 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %55 = bitcast %union.bpf_attr* %54 to %struct.anon.144*
  %log_buf29 = getelementptr inbounds %struct.anon.144, %struct.anon.144* %55, i32 0, i32 6
  %56 = load i64, i64* %log_buf29, align 8
  %57 = inttoptr i64 %56 to i8*
  %58 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %58, i32 0, i32 2
  store i8* %57, i8** %ubuf, align 8
  %59 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %60 = bitcast %union.bpf_attr* %59 to %struct.anon.144*
  %log_size30 = getelementptr inbounds %struct.anon.144, %struct.anon.144* %60, i32 0, i32 5
  %61 = load i32, i32* %log_size30, align 4
  %62 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %62, i32 0, i32 4
  store i32 %61, i32* %len_total, align 4
  %63 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %call31 = call zeroext i1 @bpf_verifier_log_attr_valid(%struct.bpf_verifier_log* noundef %63) #20
  br i1 %call31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %if.then27
  store i32 -22, i32* %ret, align 4
  br label %err_unlock

if.end33:                                         ; preds = %if.then27
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %lor.lhs.false25
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @mark_verifier_state_clean(%struct.bpf_verifier_env* noundef %64) #20
  %65 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %66 = bitcast %struct.btf* %65 to i8*
  %call35 = call zeroext i1 @IS_ERR(i8* noundef %66) #20
  br i1 %call35, label %if.then36, label %if.end39

if.then36:                                        ; preds = %if.end34
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %68 = bitcast %struct.bpf_verifier_env* %67 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %68, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.26, i64 0, i64 0)) #20
  %69 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %70 = bitcast %struct.btf* %69 to i8*
  %call37 = call i64 @PTR_ERR(i8* noundef %70) #20
  %conv38 = trunc i64 %call37 to i32
  store i32 %conv38, i32* %ret, align 4
  br label %skip_full_check

if.end39:                                         ; preds = %if.end34
  %71 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %72 = bitcast %union.bpf_attr* %71 to %struct.anon.144*
  %prog_flags = getelementptr inbounds %struct.anon.144, %struct.anon.144* %72, i32 0, i32 8
  %73 = load i32, i32* %prog_flags, align 4
  %and = and i32 %73, 1
  %tobool40 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool40, true
  %lnot41 = xor i1 %lnot, true
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %strict_alignment = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %74, i32 0, i32 6
  %frombool42 = zext i1 %lnot41 to i8
  store i8 %frombool42, i8* %strict_alignment, align 4
  %75 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %76 = bitcast %union.bpf_attr* %75 to %struct.anon.144*
  %prog_flags43 = getelementptr inbounds %struct.anon.144, %struct.anon.144* %76, i32 0, i32 8
  %77 = load i32, i32* %prog_flags43, align 4
  %and44 = and i32 %77, 2
  %tobool45 = icmp ne i32 %and44, 0
  br i1 %tobool45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %if.end39
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %strict_alignment47 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %78, i32 0, i32 6
  store i8 0, i8* %strict_alignment47, align 4
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %if.end39
  %call49 = call zeroext i1 @bpf_allow_ptr_leaks() #20
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %79, i32 0, i32 17
  %frombool50 = zext i1 %call49 to i8
  store i8 %frombool50, i8* %allow_ptr_leaks, align 1
  %call51 = call zeroext i1 @bpf_allow_uninit_stack() #20
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %allow_uninit_stack = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %80, i32 0, i32 18
  %frombool52 = zext i1 %call51 to i8
  store i8 %frombool52, i8* %allow_uninit_stack, align 2
  %call53 = call zeroext i1 @bpf_allow_ptr_to_map_access() #20
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %allow_ptr_to_map_access = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %81, i32 0, i32 19
  %frombool54 = zext i1 %call53 to i8
  store i8 %frombool54, i8* %allow_ptr_to_map_access, align 1
  %call55 = call zeroext i1 @bpf_bypass_spec_v1() #20
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %82, i32 0, i32 21
  %frombool56 = zext i1 %call55 to i8
  store i8 %frombool56, i8* %bypass_spec_v1, align 1
  %call57 = call zeroext i1 @bpf_bypass_spec_v4() #20
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %bypass_spec_v4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %83, i32 0, i32 22
  %frombool58 = zext i1 %call57 to i8
  store i8 %frombool58, i8* %bypass_spec_v4, align 2
  %call59 = call zeroext i1 @bpf_capable() #20
  %84 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %84, i32 0, i32 20
  %frombool60 = zext i1 %call59 to i8
  store i8 %frombool60, i8* %bpf_capable, align 8
  %85 = load i8, i8* %is_priv, align 1
  %tobool61 = trunc i8 %85 to i1
  br i1 %tobool61, label %if.then62, label %if.end67

if.then62:                                        ; preds = %if.end48
  %86 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %87 = bitcast %union.bpf_attr* %86 to %struct.anon.144*
  %prog_flags63 = getelementptr inbounds %struct.anon.144, %struct.anon.144* %87, i32 0, i32 8
  %88 = load i32, i32* %prog_flags63, align 4
  %and64 = and i32 %88, 8
  %tobool65 = icmp ne i32 %and64, 0
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %test_state_freq = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %89, i32 0, i32 7
  %frombool66 = zext i1 %tobool65 to i8
  store i8 %frombool66, i8* %test_state_freq, align 1
  br label %if.end67

if.end67:                                         ; preds = %if.then62, %if.end48
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call68 = call i32 @state_htab_size(%struct.bpf_verifier_env* noundef %90) #20
  %conv69 = zext i32 %call68 to i64
  %call70 = call noalias i8* @kvcalloc(i64 noundef %conv69, i64 noundef 8, i32 noundef 1051840) #25
  %91 = bitcast i8* %call70 to %struct.bpf_verifier_state_list**
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %explored_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %92, i32 0, i32 9
  store %struct.bpf_verifier_state_list** %91, %struct.bpf_verifier_state_list*** %explored_states, align 8
  store i32 -12, i32* %ret, align 4
  %93 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %explored_states71 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %93, i32 0, i32 9
  %94 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states71, align 8
  %tobool72 = icmp ne %struct.bpf_verifier_state_list** %94, null
  br i1 %tobool72, label %if.end74, label %if.then73

if.then73:                                        ; preds = %if.end67
  br label %skip_full_check

if.end74:                                         ; preds = %if.end67
  %95 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call75 = call i32 @add_subprog_and_kfunc(%struct.bpf_verifier_env* noundef %95) #20
  store i32 %call75, i32* %ret, align 4
  %96 = load i32, i32* %ret, align 4
  %cmp76 = icmp slt i32 %96, 0
  br i1 %cmp76, label %if.then78, label %if.end79

if.then78:                                        ; preds = %if.end74
  br label %skip_full_check

if.end79:                                         ; preds = %if.end74
  %97 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call80 = call i32 @check_subprogs(%struct.bpf_verifier_env* noundef %97) #20
  store i32 %call80, i32* %ret, align 4
  %98 = load i32, i32* %ret, align 4
  %cmp81 = icmp slt i32 %98, 0
  br i1 %cmp81, label %if.then83, label %if.end84

if.then83:                                        ; preds = %if.end79
  br label %skip_full_check

if.end84:                                         ; preds = %if.end79
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %100 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %101 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %102 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %101, i32 0, i32 0
  %103 = load i8*, i8** %102, align 8
  %104 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %101, i32 0, i32 1
  %105 = load i8, i8* %104, align 8
  %call85 = call i32 @check_btf_info(%struct.bpf_verifier_env* noundef %99, %union.bpf_attr* noundef %100, i8* %103, i8 %105) #20
  store i32 %call85, i32* %ret, align 4
  %106 = load i32, i32* %ret, align 4
  %cmp86 = icmp slt i32 %106, 0
  br i1 %cmp86, label %if.then88, label %if.end89

if.then88:                                        ; preds = %if.end84
  br label %skip_full_check

if.end89:                                         ; preds = %if.end84
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call90 = call i32 @check_attach_btf_id(%struct.bpf_verifier_env* noundef %107) #20
  store i32 %call90, i32* %ret, align 4
  %108 = load i32, i32* %ret, align 4
  %tobool91 = icmp ne i32 %108, 0
  br i1 %tobool91, label %if.then92, label %if.end93

if.then92:                                        ; preds = %if.end89
  br label %skip_full_check

if.end93:                                         ; preds = %if.end89
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call94 = call i32 @resolve_pseudo_ldimm64(%struct.bpf_verifier_env* noundef %109) #20
  store i32 %call94, i32* %ret, align 4
  %110 = load i32, i32* %ret, align 4
  %cmp95 = icmp slt i32 %110, 0
  br i1 %cmp95, label %if.then97, label %if.end98

if.then97:                                        ; preds = %if.end93
  br label %skip_full_check

if.end98:                                         ; preds = %if.end93
  %111 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog99 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %111, i32 0, i32 2
  %112 = load %struct.bpf_prog*, %struct.bpf_prog** %prog99, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %112, i32 0, i32 10
  %113 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call100 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %113) #20
  br i1 %call100, label %if.then101, label %if.end107

if.then101:                                       ; preds = %if.end98
  %114 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog102 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %114, i32 0, i32 2
  %115 = load %struct.bpf_prog*, %struct.bpf_prog** %prog102, align 8
  %call103 = call i32 @bpf_prog_offload_verifier_prep(%struct.bpf_prog* noundef %115) #20
  store i32 %call103, i32* %ret, align 4
  %116 = load i32, i32* %ret, align 4
  %tobool104 = icmp ne i32 %116, 0
  br i1 %tobool104, label %if.then105, label %if.end106

if.then105:                                       ; preds = %if.then101
  br label %skip_full_check

if.end106:                                        ; preds = %if.then101
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %if.end98
  %117 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call108 = call i32 @check_cfg(%struct.bpf_verifier_env* noundef %117) #20
  store i32 %call108, i32* %ret, align 4
  %118 = load i32, i32* %ret, align 4
  %cmp109 = icmp slt i32 %118, 0
  br i1 %cmp109, label %if.then111, label %if.end112

if.then111:                                       ; preds = %if.end107
  br label %skip_full_check

if.end112:                                        ; preds = %if.end107
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call113 = call i32 @do_check_subprogs(%struct.bpf_verifier_env* noundef %119) #20
  store i32 %call113, i32* %ret, align 4
  %120 = load i32, i32* %ret, align 4
  %tobool114 = icmp ne i32 %120, 0
  br i1 %tobool114, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end112
  br label %cond.end

cond.false:                                       ; preds = %if.end112
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call115 = call i32 @do_check_main(%struct.bpf_verifier_env* noundef %121) #20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %120, %cond.true ], [ %call115, %cond.false ]
  store i32 %cond, i32* %ret, align 4
  %122 = load i32, i32* %ret, align 4
  %cmp116 = icmp eq i32 %122, 0
  br i1 %cmp116, label %land.lhs.true, label %if.end124

land.lhs.true:                                    ; preds = %cond.end
  %123 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog118 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %123, i32 0, i32 2
  %124 = load %struct.bpf_prog*, %struct.bpf_prog** %prog118, align 8
  %aux119 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %124, i32 0, i32 10
  %125 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux119, align 8
  %call120 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %125) #20
  br i1 %call120, label %if.then122, label %if.end124

if.then122:                                       ; preds = %land.lhs.true
  %126 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call123 = call i32 @bpf_prog_offload_finalize(%struct.bpf_verifier_env* noundef %126) #20
  store i32 %call123, i32* %ret, align 4
  br label %if.end124

if.end124:                                        ; preds = %if.then122, %land.lhs.true, %cond.end
  br label %skip_full_check

skip_full_check:                                  ; preds = %if.end124, %if.then111, %if.then105, %if.then97, %if.then92, %if.then88, %if.then83, %if.then78, %if.then73, %if.then36
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %explored_states125 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %127, i32 0, i32 9
  %128 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states125, align 8
  %129 = bitcast %struct.bpf_verifier_state_list** %128 to i8*
  call void @kvfree(i8* noundef %129) #20
  %130 = load i32, i32* %ret, align 4
  %cmp126 = icmp eq i32 %130, 0
  br i1 %cmp126, label %if.then128, label %if.end130

if.then128:                                       ; preds = %skip_full_check
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call129 = call i32 @check_max_stack_depth(%struct.bpf_verifier_env* noundef %131) #20
  store i32 %call129, i32* %ret, align 4
  br label %if.end130

if.end130:                                        ; preds = %if.then128, %skip_full_check
  %132 = load i32, i32* %ret, align 4
  %cmp131 = icmp eq i32 %132, 0
  br i1 %cmp131, label %if.then133, label %if.end135

if.then133:                                       ; preds = %if.end130
  %133 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call134 = call i32 @optimize_bpf_loop(%struct.bpf_verifier_env* noundef %133) #20
  store i32 %call134, i32* %ret, align 4
  br label %if.end135

if.end135:                                        ; preds = %if.then133, %if.end130
  %134 = load i8, i8* %is_priv, align 1
  %tobool136 = trunc i8 %134 to i1
  br i1 %tobool136, label %if.then137, label %if.else

if.then137:                                       ; preds = %if.end135
  %135 = load i32, i32* %ret, align 4
  %cmp138 = icmp eq i32 %135, 0
  br i1 %cmp138, label %if.then140, label %if.end141

if.then140:                                       ; preds = %if.then137
  %136 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @opt_hard_wire_dead_code_branches(%struct.bpf_verifier_env* noundef %136) #20
  br label %if.end141

if.end141:                                        ; preds = %if.then140, %if.then137
  %137 = load i32, i32* %ret, align 4
  %cmp142 = icmp eq i32 %137, 0
  br i1 %cmp142, label %if.then144, label %if.end146

if.then144:                                       ; preds = %if.end141
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call145 = call i32 @opt_remove_dead_code(%struct.bpf_verifier_env* noundef %138) #20
  store i32 %call145, i32* %ret, align 4
  br label %if.end146

if.end146:                                        ; preds = %if.then144, %if.end141
  %139 = load i32, i32* %ret, align 4
  %cmp147 = icmp eq i32 %139, 0
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %if.end146
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call150 = call i32 @opt_remove_nops(%struct.bpf_verifier_env* noundef %140) #20
  store i32 %call150, i32* %ret, align 4
  br label %if.end151

if.end151:                                        ; preds = %if.then149, %if.end146
  br label %if.end156

if.else:                                          ; preds = %if.end135
  %141 = load i32, i32* %ret, align 4
  %cmp152 = icmp eq i32 %141, 0
  br i1 %cmp152, label %if.then154, label %if.end155

if.then154:                                       ; preds = %if.else
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @sanitize_dead_code(%struct.bpf_verifier_env* noundef %142) #20
  br label %if.end155

if.end155:                                        ; preds = %if.then154, %if.else
  br label %if.end156

if.end156:                                        ; preds = %if.end155, %if.end151
  %143 = load i32, i32* %ret, align 4
  %cmp157 = icmp eq i32 %143, 0
  br i1 %cmp157, label %if.then159, label %if.end161

if.then159:                                       ; preds = %if.end156
  %144 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call160 = call i32 @convert_ctx_accesses(%struct.bpf_verifier_env* noundef %144) #20
  store i32 %call160, i32* %ret, align 4
  br label %if.end161

if.end161:                                        ; preds = %if.then159, %if.end156
  %145 = load i32, i32* %ret, align 4
  %cmp162 = icmp eq i32 %145, 0
  br i1 %cmp162, label %if.then164, label %if.end166

if.then164:                                       ; preds = %if.end161
  %146 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call165 = call i32 @do_misc_fixups(%struct.bpf_verifier_env* noundef %146) #20
  store i32 %call165, i32* %ret, align 4
  br label %if.end166

if.end166:                                        ; preds = %if.then164, %if.end161
  %147 = load i32, i32* %ret, align 4
  %cmp167 = icmp eq i32 %147, 0
  br i1 %cmp167, label %land.lhs.true169, label %if.end187

land.lhs.true169:                                 ; preds = %if.end166
  %148 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog170 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %148, i32 0, i32 2
  %149 = load %struct.bpf_prog*, %struct.bpf_prog** %prog170, align 8
  %aux171 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %149, i32 0, i32 10
  %150 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux171, align 8
  %call172 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %150) #20
  br i1 %call172, label %if.end187, label %if.then173

if.then173:                                       ; preds = %land.lhs.true169
  %151 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %152 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %call174 = call i32 @opt_subreg_zext_lo32_rnd_hi32(%struct.bpf_verifier_env* noundef %151, %union.bpf_attr* noundef %152) #20
  store i32 %call174, i32* %ret, align 4
  %call175 = call zeroext i1 @bpf_jit_needs_zext() #20
  br i1 %call175, label %cond.true177, label %cond.false180

cond.true177:                                     ; preds = %if.then173
  %153 = load i32, i32* %ret, align 4
  %tobool178 = icmp ne i32 %153, 0
  %lnot179 = xor i1 %tobool178, true
  %lnot.ext = zext i1 %lnot179 to i32
  br label %cond.end181

cond.false180:                                    ; preds = %if.then173
  br label %cond.end181

cond.end181:                                      ; preds = %cond.false180, %cond.true177
  %cond182 = phi i32 [ %lnot.ext, %cond.true177 ], [ 0, %cond.false180 ]
  %tobool183 = icmp ne i32 %cond182, 0
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog184 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %154, i32 0, i32 2
  %155 = load %struct.bpf_prog*, %struct.bpf_prog** %prog184, align 8
  %aux185 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %155, i32 0, i32 10
  %156 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux185, align 8
  %verifier_zext = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %156, i32 0, i32 21
  %frombool186 = zext i1 %tobool183 to i8
  store i8 %frombool186, i8* %verifier_zext, align 8
  br label %if.end187

if.end187:                                        ; preds = %cond.end181, %land.lhs.true169, %if.end166
  %157 = load i32, i32* %ret, align 4
  %cmp188 = icmp eq i32 %157, 0
  br i1 %cmp188, label %if.then190, label %if.end192

if.then190:                                       ; preds = %if.end187
  %158 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call191 = call i32 @fixup_call_args(%struct.bpf_verifier_env* noundef %158) #20
  store i32 %call191, i32* %ret, align 4
  br label %if.end192

if.end192:                                        ; preds = %if.then190, %if.end187
  %call193 = call i64 @ktime_get_ns() #20
  %159 = load i64, i64* %start_time, align 8
  %sub = sub i64 %call193, %159
  %160 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %verification_time = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %160, i32 0, i32 36
  store i64 %sub, i64* %verification_time, align 8
  %161 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @print_verification_stats(%struct.bpf_verifier_env* noundef %161) #20
  %162 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %162, i32 0, i32 33
  %163 = load i32, i32* %insn_processed, align 4
  %164 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog194 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %164, i32 0, i32 2
  %165 = load %struct.bpf_prog*, %struct.bpf_prog** %prog194, align 8
  %aux195 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %165, i32 0, i32 10
  %166 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux195, align 8
  %verified_insns = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %166, i32 0, i32 44
  store i32 %163, i32* %verified_insns, align 8
  %167 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level196 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %167, i32 0, i32 0
  %168 = load i32, i32* %level196, align 8
  %tobool197 = icmp ne i32 %168, 0
  br i1 %tobool197, label %land.lhs.true198, label %if.end202

land.lhs.true198:                                 ; preds = %if.end192
  %169 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %call199 = call zeroext i1 @bpf_verifier_log_full(%struct.bpf_verifier_log* noundef %169) #20
  br i1 %call199, label %if.then201, label %if.end202

if.then201:                                       ; preds = %land.lhs.true198
  store i32 -28, i32* %ret, align 4
  br label %if.end202

if.end202:                                        ; preds = %if.then201, %land.lhs.true198, %if.end192
  %170 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level203 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %170, i32 0, i32 0
  %171 = load i32, i32* %level203, align 8
  %tobool204 = icmp ne i32 %171, 0
  br i1 %tobool204, label %land.lhs.true205, label %if.end209

land.lhs.true205:                                 ; preds = %if.end202
  %172 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %ubuf206 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %172, i32 0, i32 2
  %173 = load i8*, i8** %ubuf206, align 8
  %tobool207 = icmp ne i8* %173, null
  br i1 %tobool207, label %if.end209, label %if.then208

if.then208:                                       ; preds = %land.lhs.true205
  store i32 -14, i32* %ret, align 4
  br label %err_release_maps

if.end209:                                        ; preds = %land.lhs.true205, %if.end202
  %174 = load i32, i32* %ret, align 4
  %tobool210 = icmp ne i32 %174, 0
  br i1 %tobool210, label %if.then211, label %if.end212

if.then211:                                       ; preds = %if.end209
  br label %err_release_maps

if.end212:                                        ; preds = %if.end209
  %175 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %175, i32 0, i32 13
  %176 = load i32, i32* %used_map_cnt, align 8
  %tobool213 = icmp ne i32 %176, 0
  br i1 %tobool213, label %if.then214, label %if.end236

if.then214:                                       ; preds = %if.end212
  %177 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt215 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %177, i32 0, i32 13
  %178 = load i32, i32* %used_map_cnt215, align 8
  %conv216 = zext i32 %178 to i64
  %call217 = call noalias i8* @kmalloc_array(i64 noundef %conv216, i64 noundef 8, i32 noundef 3264) #25
  %179 = bitcast i8* %call217 to %struct.bpf_map**
  %180 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog218 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %180, i32 0, i32 2
  %181 = load %struct.bpf_prog*, %struct.bpf_prog** %prog218, align 8
  %aux219 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %181, i32 0, i32 10
  %182 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux219, align 8
  %used_maps = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %182, i32 0, i32 38
  store %struct.bpf_map** %179, %struct.bpf_map*** %used_maps, align 8
  %183 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog220 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %183, i32 0, i32 2
  %184 = load %struct.bpf_prog*, %struct.bpf_prog** %prog220, align 8
  %aux221 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %184, i32 0, i32 10
  %185 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux221, align 8
  %used_maps222 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %185, i32 0, i32 38
  %186 = load %struct.bpf_map**, %struct.bpf_map*** %used_maps222, align 8
  %tobool223 = icmp ne %struct.bpf_map** %186, null
  br i1 %tobool223, label %if.end225, label %if.then224

if.then224:                                       ; preds = %if.then214
  store i32 -12, i32* %ret, align 4
  br label %err_release_maps

if.end225:                                        ; preds = %if.then214
  %187 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog226 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %187, i32 0, i32 2
  %188 = load %struct.bpf_prog*, %struct.bpf_prog** %prog226, align 8
  %aux227 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %188, i32 0, i32 10
  %189 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux227, align 8
  %used_maps228 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %189, i32 0, i32 38
  %190 = load %struct.bpf_map**, %struct.bpf_map*** %used_maps228, align 8
  %191 = bitcast %struct.bpf_map** %190 to i8*
  %192 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_maps229 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %192, i32 0, i32 11
  %arraydecay = getelementptr inbounds [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps229, i64 0, i64 0
  %193 = bitcast %struct.bpf_map** %arraydecay to i8*
  %194 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt230 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %194, i32 0, i32 13
  %195 = load i32, i32* %used_map_cnt230, align 8
  %conv231 = zext i32 %195 to i64
  %mul = mul i64 8, %conv231
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %191, i8* align 8 %193, i64 %mul, i1 false)
  %196 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt232 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %196, i32 0, i32 13
  %197 = load i32, i32* %used_map_cnt232, align 8
  %198 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog233 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %198, i32 0, i32 2
  %199 = load %struct.bpf_prog*, %struct.bpf_prog** %prog233, align 8
  %aux234 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %199, i32 0, i32 10
  %200 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux234, align 8
  %used_map_cnt235 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %200, i32 0, i32 1
  store i32 %197, i32* %used_map_cnt235, align 8
  br label %if.end236

if.end236:                                        ; preds = %if.end225, %if.end212
  %201 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_btf_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %201, i32 0, i32 14
  %202 = load i32, i32* %used_btf_cnt, align 4
  %tobool237 = icmp ne i32 %202, 0
  br i1 %tobool237, label %if.then238, label %if.end262

if.then238:                                       ; preds = %if.end236
  %203 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_btf_cnt239 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %203, i32 0, i32 14
  %204 = load i32, i32* %used_btf_cnt239, align 4
  %conv240 = zext i32 %204 to i64
  %call241 = call noalias i8* @kmalloc_array(i64 noundef %conv240, i64 noundef 16, i32 noundef 3264) #25
  %205 = bitcast i8* %call241 to %struct.btf_mod_pair*
  %206 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog242 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %206, i32 0, i32 2
  %207 = load %struct.bpf_prog*, %struct.bpf_prog** %prog242, align 8
  %aux243 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %207, i32 0, i32 10
  %208 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux243, align 8
  %used_btfs = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %208, i32 0, i32 40
  store %struct.btf_mod_pair* %205, %struct.btf_mod_pair** %used_btfs, align 8
  %209 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog244 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %209, i32 0, i32 2
  %210 = load %struct.bpf_prog*, %struct.bpf_prog** %prog244, align 8
  %aux245 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %210, i32 0, i32 10
  %211 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux245, align 8
  %used_btfs246 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %211, i32 0, i32 40
  %212 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %used_btfs246, align 8
  %tobool247 = icmp ne %struct.btf_mod_pair* %212, null
  br i1 %tobool247, label %if.end249, label %if.then248

if.then248:                                       ; preds = %if.then238
  store i32 -12, i32* %ret, align 4
  br label %err_release_maps

if.end249:                                        ; preds = %if.then238
  %213 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog250 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %213, i32 0, i32 2
  %214 = load %struct.bpf_prog*, %struct.bpf_prog** %prog250, align 8
  %aux251 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %214, i32 0, i32 10
  %215 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux251, align 8
  %used_btfs252 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %215, i32 0, i32 40
  %216 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %used_btfs252, align 8
  %217 = bitcast %struct.btf_mod_pair* %216 to i8*
  %218 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_btfs253 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %218, i32 0, i32 12
  %arraydecay254 = getelementptr inbounds [64 x %struct.btf_mod_pair], [64 x %struct.btf_mod_pair]* %used_btfs253, i64 0, i64 0
  %219 = bitcast %struct.btf_mod_pair* %arraydecay254 to i8*
  %220 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_btf_cnt255 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %220, i32 0, i32 14
  %221 = load i32, i32* %used_btf_cnt255, align 4
  %conv256 = zext i32 %221 to i64
  %mul257 = mul i64 16, %conv256
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %217, i8* align 8 %219, i64 %mul257, i1 false)
  %222 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_btf_cnt258 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %222, i32 0, i32 14
  %223 = load i32, i32* %used_btf_cnt258, align 4
  %224 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog259 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %224, i32 0, i32 2
  %225 = load %struct.bpf_prog*, %struct.bpf_prog** %prog259, align 8
  %aux260 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %225, i32 0, i32 10
  %226 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux260, align 8
  %used_btf_cnt261 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %226, i32 0, i32 2
  store i32 %223, i32* %used_btf_cnt261, align 4
  br label %if.end262

if.end262:                                        ; preds = %if.end249, %if.end236
  %227 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt263 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %227, i32 0, i32 13
  %228 = load i32, i32* %used_map_cnt263, align 8
  %tobool264 = icmp ne i32 %228, 0
  br i1 %tobool264, label %if.then268, label %lor.lhs.false265

lor.lhs.false265:                                 ; preds = %if.end262
  %229 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_btf_cnt266 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %229, i32 0, i32 14
  %230 = load i32, i32* %used_btf_cnt266, align 4
  %tobool267 = icmp ne i32 %230, 0
  br i1 %tobool267, label %if.then268, label %if.end269

if.then268:                                       ; preds = %lor.lhs.false265, %if.end262
  %231 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @convert_pseudo_ld_imm64(%struct.bpf_verifier_env* noundef %231) #20
  br label %if.end269

if.end269:                                        ; preds = %if.then268, %lor.lhs.false265
  %232 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @adjust_btf_func(%struct.bpf_verifier_env* noundef %232) #20
  br label %err_release_maps

err_release_maps:                                 ; preds = %if.end269, %if.then248, %if.then224, %if.then211, %if.then208
  %233 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog270 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %233, i32 0, i32 2
  %234 = load %struct.bpf_prog*, %struct.bpf_prog** %prog270, align 8
  %aux271 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %234, i32 0, i32 10
  %235 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux271, align 8
  %used_maps272 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %235, i32 0, i32 38
  %236 = load %struct.bpf_map**, %struct.bpf_map*** %used_maps272, align 8
  %tobool273 = icmp ne %struct.bpf_map** %236, null
  br i1 %tobool273, label %if.end275, label %if.then274

if.then274:                                       ; preds = %err_release_maps
  %237 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @release_maps(%struct.bpf_verifier_env* noundef %237) #20
  br label %if.end275

if.end275:                                        ; preds = %if.then274, %err_release_maps
  %238 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog276 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %238, i32 0, i32 2
  %239 = load %struct.bpf_prog*, %struct.bpf_prog** %prog276, align 8
  %aux277 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %239, i32 0, i32 10
  %240 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux277, align 8
  %used_btfs278 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %240, i32 0, i32 40
  %241 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %used_btfs278, align 8
  %tobool279 = icmp ne %struct.btf_mod_pair* %241, null
  br i1 %tobool279, label %if.end281, label %if.then280

if.then280:                                       ; preds = %if.end275
  %242 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @release_btfs(%struct.bpf_verifier_env* noundef %242) #20
  br label %if.end281

if.end281:                                        ; preds = %if.then280, %if.end275
  %243 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog282 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %243, i32 0, i32 2
  %244 = load %struct.bpf_prog*, %struct.bpf_prog** %prog282, align 8
  %type283 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %244, i32 0, i32 2
  %245 = load i32, i32* %type283, align 4
  %cmp284 = icmp eq i32 %245, 28
  br i1 %cmp284, label %if.then286, label %if.end288

if.then286:                                       ; preds = %if.end281
  %246 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog287 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %246, i32 0, i32 2
  %247 = load %struct.bpf_prog*, %struct.bpf_prog** %prog287, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %247, i32 0, i32 3
  store i32 0, i32* %expected_attach_type, align 8
  br label %if.end288

if.end288:                                        ; preds = %if.then286, %if.end281
  %248 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog289 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %248, i32 0, i32 2
  %249 = load %struct.bpf_prog*, %struct.bpf_prog** %prog289, align 8
  %250 = load %struct.bpf_prog**, %struct.bpf_prog*** %prog.addr, align 8
  store %struct.bpf_prog* %249, %struct.bpf_prog** %250, align 8
  br label %err_unlock

err_unlock:                                       ; preds = %if.end288, %if.then32
  %251 = load i8, i8* %is_priv, align 1
  %tobool290 = trunc i8 %251 to i1
  br i1 %tobool290, label %if.end292, label %if.then291

if.then291:                                       ; preds = %err_unlock
  call void @mutex_unlock(%struct.mutex* noundef @bpf_verifier_lock) #20
  br label %if.end292

if.end292:                                        ; preds = %if.then291, %err_unlock
  %252 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data293 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %252, i32 0, i32 24
  %253 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data293, align 8
  %254 = bitcast %struct.bpf_insn_aux_data* %253 to i8*
  call void @vfree(i8* noundef %254) #20
  br label %err_free_env

err_free_env:                                     ; preds = %if.end292, %if.then8
  %255 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %256 = bitcast %struct.bpf_verifier_env* %255 to i8*
  call void @kfree(i8* noundef %256) #20
  %257 = load i32, i32* %ret, align 4
  store i32 %257, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free_env, %if.then
  %258 = load i32, i32* %retval, align 4
  ret i32 %258
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @ktime_get_ns() #0 {
entry:
  %call = call i64 @ktime_get() #20
  %call1 = call i64 @ktime_to_ns(i64 noundef %call) #20
  ret i64 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong allocsize(0)
define internal noalias i8* @kzalloc(i64 noundef %size, i32 noundef %flags) #6 {
entry:
  %retval.i8 = alloca i32, align 4
  %flags.addr.i9 = alloca i32, align 4
  %retval.i1 = alloca i32, align 4
  %size.addr.i2 = alloca i64, align 8
  %size_is_constant.addr.i = alloca i8, align 1
  %retval.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %index.i = alloca i32, align 4
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %size.addr, align 8
  %1 = load i32, i32* %flags.addr, align 4
  %or = or i32 %1, 256
  store i64 %0, i64* %size.addr.i, align 8
  store i32 %or, i32* %flags.addr.i, align 4
  %2 = load i64, i64* %size.addr.i, align 8
  %3 = call i1 @llvm.is.constant.i64(i64 %2) #19
  br i1 %3, label %if.then.i, label %if.end9.i

if.then.i:                                        ; preds = %entry
  %4 = load i64, i64* %size.addr.i, align 8
  %cmp.i = icmp ugt i64 %4, 8192
  br i1 %cmp.i, label %if.then1.i, label %if.end.i

if.then1.i:                                       ; preds = %if.then.i
  %5 = load i64, i64* %size.addr.i, align 8
  %6 = load i32, i32* %flags.addr.i, align 4
  %call.i = call noalias align 4096 i8* @kmalloc_large(i64 noundef %5, i32 noundef %6) #26
  store i8* %call.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end.i:                                         ; preds = %if.then.i
  %7 = load i64, i64* %size.addr.i, align 8
  store i64 %7, i64* %size.addr.i2, align 8
  store i8 1, i8* %size_is_constant.addr.i, align 1
  %8 = load i64, i64* %size.addr.i2, align 8
  %tobool.i3 = icmp ne i64 %8, 0
  br i1 %tobool.i3, label %if.end.i6, label %if.then.i4

if.then.i4:                                       ; preds = %if.end.i
  store i32 0, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end.i6:                                        ; preds = %if.end.i
  %9 = load i64, i64* %size.addr.i2, align 8
  %cmp.i5 = icmp ule i64 %9, 8
  br i1 %cmp.i5, label %if.then1.i7, label %if.end2.i

if.then1.i7:                                      ; preds = %if.end.i6
  store i32 3, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end2.i:                                        ; preds = %if.end.i6
  %10 = load i64, i64* %size.addr.i2, align 8
  %cmp3.i = icmp ugt i64 %10, 64
  br i1 %cmp3.i, label %land.lhs.true.i, label %if.end6.i

land.lhs.true.i:                                  ; preds = %if.end2.i
  %11 = load i64, i64* %size.addr.i2, align 8
  %cmp4.i = icmp ule i64 %11, 96
  br i1 %cmp4.i, label %if.then5.i, label %if.end6.i

if.then5.i:                                       ; preds = %land.lhs.true.i
  store i32 1, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end6.i:                                        ; preds = %land.lhs.true.i, %if.end2.i
  %12 = load i64, i64* %size.addr.i2, align 8
  %cmp7.i = icmp ugt i64 %12, 128
  br i1 %cmp7.i, label %land.lhs.true8.i, label %if.end11.i

land.lhs.true8.i:                                 ; preds = %if.end6.i
  %13 = load i64, i64* %size.addr.i2, align 8
  %cmp9.i = icmp ule i64 %13, 192
  br i1 %cmp9.i, label %if.then10.i, label %if.end11.i

if.then10.i:                                      ; preds = %land.lhs.true8.i
  store i32 2, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end11.i:                                       ; preds = %land.lhs.true8.i, %if.end6.i
  %14 = load i64, i64* %size.addr.i2, align 8
  %cmp12.i = icmp ule i64 %14, 8
  br i1 %cmp12.i, label %if.then13.i, label %if.end14.i

if.then13.i:                                      ; preds = %if.end11.i
  store i32 3, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end14.i:                                       ; preds = %if.end11.i
  %15 = load i64, i64* %size.addr.i2, align 8
  %cmp15.i = icmp ule i64 %15, 16
  br i1 %cmp15.i, label %if.then16.i, label %if.end17.i

if.then16.i:                                      ; preds = %if.end14.i
  store i32 4, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end17.i:                                       ; preds = %if.end14.i
  %16 = load i64, i64* %size.addr.i2, align 8
  %cmp18.i = icmp ule i64 %16, 32
  br i1 %cmp18.i, label %if.then19.i, label %if.end20.i

if.then19.i:                                      ; preds = %if.end17.i
  store i32 5, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end20.i:                                       ; preds = %if.end17.i
  %17 = load i64, i64* %size.addr.i2, align 8
  %cmp21.i = icmp ule i64 %17, 64
  br i1 %cmp21.i, label %if.then22.i, label %if.end23.i

if.then22.i:                                      ; preds = %if.end20.i
  store i32 6, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end23.i:                                       ; preds = %if.end20.i
  %18 = load i64, i64* %size.addr.i2, align 8
  %cmp24.i = icmp ule i64 %18, 128
  br i1 %cmp24.i, label %if.then25.i, label %if.end26.i

if.then25.i:                                      ; preds = %if.end23.i
  store i32 7, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end26.i:                                       ; preds = %if.end23.i
  %19 = load i64, i64* %size.addr.i2, align 8
  %cmp27.i = icmp ule i64 %19, 256
  br i1 %cmp27.i, label %if.then28.i, label %if.end29.i

if.then28.i:                                      ; preds = %if.end26.i
  store i32 8, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end29.i:                                       ; preds = %if.end26.i
  %20 = load i64, i64* %size.addr.i2, align 8
  %cmp30.i = icmp ule i64 %20, 512
  br i1 %cmp30.i, label %if.then31.i, label %if.end32.i

if.then31.i:                                      ; preds = %if.end29.i
  store i32 9, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end32.i:                                       ; preds = %if.end29.i
  %21 = load i64, i64* %size.addr.i2, align 8
  %cmp33.i = icmp ule i64 %21, 1024
  br i1 %cmp33.i, label %if.then34.i, label %if.end35.i

if.then34.i:                                      ; preds = %if.end32.i
  store i32 10, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end35.i:                                       ; preds = %if.end32.i
  %22 = load i64, i64* %size.addr.i2, align 8
  %cmp36.i = icmp ule i64 %22, 2048
  br i1 %cmp36.i, label %if.then37.i, label %if.end38.i

if.then37.i:                                      ; preds = %if.end35.i
  store i32 11, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end38.i:                                       ; preds = %if.end35.i
  %23 = load i64, i64* %size.addr.i2, align 8
  %cmp39.i = icmp ule i64 %23, 4096
  br i1 %cmp39.i, label %if.then40.i, label %if.end41.i

if.then40.i:                                      ; preds = %if.end38.i
  store i32 12, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end41.i:                                       ; preds = %if.end38.i
  %24 = load i64, i64* %size.addr.i2, align 8
  %cmp42.i = icmp ule i64 %24, 8192
  br i1 %cmp42.i, label %if.then43.i, label %if.end44.i

if.then43.i:                                      ; preds = %if.end41.i
  store i32 13, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end44.i:                                       ; preds = %if.end41.i
  %25 = load i64, i64* %size.addr.i2, align 8
  %cmp45.i = icmp ule i64 %25, 16384
  br i1 %cmp45.i, label %if.then46.i, label %if.end47.i

if.then46.i:                                      ; preds = %if.end44.i
  store i32 14, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end47.i:                                       ; preds = %if.end44.i
  %26 = load i64, i64* %size.addr.i2, align 8
  %cmp48.i = icmp ule i64 %26, 32768
  br i1 %cmp48.i, label %if.then49.i, label %if.end50.i

if.then49.i:                                      ; preds = %if.end47.i
  store i32 15, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end50.i:                                       ; preds = %if.end47.i
  %27 = load i64, i64* %size.addr.i2, align 8
  %cmp51.i = icmp ule i64 %27, 65536
  br i1 %cmp51.i, label %if.then52.i, label %if.end53.i

if.then52.i:                                      ; preds = %if.end50.i
  store i32 16, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end53.i:                                       ; preds = %if.end50.i
  %28 = load i64, i64* %size.addr.i2, align 8
  %cmp54.i = icmp ule i64 %28, 131072
  br i1 %cmp54.i, label %if.then55.i, label %if.end56.i

if.then55.i:                                      ; preds = %if.end53.i
  store i32 17, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end56.i:                                       ; preds = %if.end53.i
  %29 = load i64, i64* %size.addr.i2, align 8
  %cmp57.i = icmp ule i64 %29, 262144
  br i1 %cmp57.i, label %if.then58.i, label %if.end59.i

if.then58.i:                                      ; preds = %if.end56.i
  store i32 18, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end59.i:                                       ; preds = %if.end56.i
  %30 = load i64, i64* %size.addr.i2, align 8
  %cmp60.i = icmp ule i64 %30, 524288
  br i1 %cmp60.i, label %if.then61.i, label %if.end62.i

if.then61.i:                                      ; preds = %if.end59.i
  store i32 19, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end62.i:                                       ; preds = %if.end59.i
  %31 = load i64, i64* %size.addr.i2, align 8
  %cmp63.i = icmp ule i64 %31, 1048576
  br i1 %cmp63.i, label %if.then64.i, label %if.end65.i

if.then64.i:                                      ; preds = %if.end62.i
  store i32 20, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end65.i:                                       ; preds = %if.end62.i
  %32 = load i64, i64* %size.addr.i2, align 8
  %cmp66.i = icmp ule i64 %32, 2097152
  br i1 %cmp66.i, label %if.then67.i, label %if.end68.i

if.then67.i:                                      ; preds = %if.end65.i
  store i32 21, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.end68.i:                                       ; preds = %if.end65.i
  %33 = load i8, i8* %size_is_constant.addr.i, align 1
  %tobool69.i = trunc i8 %33 to i1
  br i1 %tobool69.i, label %if.then70.i, label %if.else.i

if.then70.i:                                      ; preds = %if.end68.i
  store i32 -1, i32* %retval.i1, align 4
  br label %__kmalloc_index.exit

if.else.i:                                        ; preds = %if.end68.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.217, i64 0, i64 0), i32 434, i32 0, i64 12) #19, !srcloc !20
  unreachable

__kmalloc_index.exit:                             ; preds = %if.then.i4, %if.then1.i7, %if.then5.i, %if.then10.i, %if.then13.i, %if.then16.i, %if.then19.i, %if.then22.i, %if.then25.i, %if.then28.i, %if.then31.i, %if.then34.i, %if.then37.i, %if.then40.i, %if.then43.i, %if.then46.i, %if.then49.i, %if.then52.i, %if.then55.i, %if.then58.i, %if.then61.i, %if.then64.i, %if.then67.i, %if.then70.i
  %34 = load i32, i32* %retval.i1, align 4
  store i32 %34, i32* %index.i, align 4
  %35 = load i32, i32* %index.i, align 4
  %tobool.i = icmp ne i32 %35, 0
  br i1 %tobool.i, label %if.end4.i, label %if.then3.i

if.then3.i:                                       ; preds = %__kmalloc_index.exit
  store i8* inttoptr (i64 16 to i8*), i8** %retval.i, align 8
  br label %kmalloc.exit

if.end4.i:                                        ; preds = %__kmalloc_index.exit
  %36 = load i32, i32* %flags.addr.i, align 4
  store i32 %36, i32* %flags.addr.i9, align 4
  %37 = load i32, i32* %flags.addr.i9, align 4
  %and.i = and i32 %37, 17
  %cmp.i10 = icmp eq i32 %and.i, 0
  %lnot.i = xor i1 %cmp.i10, true
  %lnot.ext.i = zext i1 %cmp.i10 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %cmp.i10, label %if.then.i11, label %if.end.i12

if.then.i11:                                      ; preds = %if.end4.i
  store i32 0, i32* %retval.i8, align 4
  br label %kmalloc_type.exit

if.end.i12:                                       ; preds = %if.end4.i
  %38 = load i32, i32* %flags.addr.i9, align 4
  %and2.i = and i32 %38, 1
  %tobool3.i = icmp ne i32 %and2.i, 0
  br i1 %tobool3.i, label %if.then4.i, label %if.end5.i

if.then4.i:                                       ; preds = %if.end.i12
  store i32 2, i32* %retval.i8, align 4
  br label %kmalloc_type.exit

if.end5.i:                                        ; preds = %if.end.i12
  store i32 1, i32* %retval.i8, align 4
  br label %kmalloc_type.exit

kmalloc_type.exit:                                ; preds = %if.then.i11, %if.then4.i, %if.end5.i
  %39 = load i32, i32* %retval.i8, align 4
  %idxprom.i = zext i32 %39 to i64
  %arrayidx.i = getelementptr [3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 %idxprom.i
  %40 = load i32, i32* %index.i, align 4
  %idxprom6.i = zext i32 %40 to i64
  %arrayidx7.i = getelementptr [14 x %struct.kmem_cache*], [14 x %struct.kmem_cache*]* %arrayidx.i, i64 0, i64 %idxprom6.i
  %41 = load %struct.kmem_cache*, %struct.kmem_cache** %arrayidx7.i, align 8
  %42 = load i32, i32* %flags.addr.i, align 4
  %43 = load i64, i64* %size.addr.i, align 8
  %call8.i = call noalias align 8 i8* @kmalloc_trace(%struct.kmem_cache* noundef %41, i32 noundef %42, i64 noundef %43) #27
  store i8* %call8.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end9.i:                                        ; preds = %entry
  %44 = load i64, i64* %size.addr.i, align 8
  %45 = load i32, i32* %flags.addr.i, align 4
  %call10.i = call noalias align 8 i8* @__kmalloc(i64 noundef %44, i32 noundef %45) #26
  store i8* %call10.i, i8** %retval.i, align 8
  br label %kmalloc.exit

kmalloc.exit:                                     ; preds = %if.then1.i, %if.then3.i, %kmalloc_type.exit, %if.end9.i
  %46 = load i8*, i8** %retval.i, align 8
  ret i8* %46
}

; Function Attrs: noredzone null_pointer_is_valid allocsize(0)
declare dso_local noalias i8* @vzalloc(i64 noundef) #7

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @size_mul(i64 noundef %factor1, i64 noundef %factor2) #0 {
entry:
  %retval = alloca i64, align 8
  %factor1.addr = alloca i64, align 8
  %factor2.addr = alloca i64, align 8
  %bytes = alloca i64, align 8
  store i64 %factor1, i64* %factor1.addr, align 8
  store i64 %factor2, i64* %factor2.addr, align 8
  %0 = load i64, i64* %factor1.addr, align 8
  %1 = load i64, i64* %factor2.addr, align 8
  %2 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %0, i64 %1)
  %3 = extractvalue { i64, i1 } %2, 1
  %4 = extractvalue { i64, i1 } %2, 0
  store i64 %4, i64* %bytes, align 8
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %3) #20
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -1, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %bytes, align 8
  store i64 %5, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i64, i64* %retval, align 8
  ret i64 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { i8*, i8 } @make_bpfptr(i64 noundef %addr, i1 noundef zeroext %is_kernel) #0 {
entry:
  %retval = alloca %struct.sockptr_t, align 8
  %addr.addr = alloca i64, align 8
  %is_kernel.addr = alloca i8, align 1
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %tmp1 = alloca i8*, align 8
  store i64 %addr, i64* %addr.addr, align 8
  %frombool = zext i1 %is_kernel to i8
  store i8 %frombool, i8* %is_kernel.addr, align 1
  %0 = load i8, i8* %is_kernel.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %addr.addr, align 8
  %2 = inttoptr i64 %1 to i8*
  %call = call { i8*, i8 } @KERNEL_BPFPTR(i8* noundef %2) #20
  %3 = bitcast %struct.sockptr_t* %retval to { i8*, i8 }*
  %4 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 0
  %5 = extractvalue { i8*, i8 } %call, 0
  store i8* %5, i8** %4, align 8
  %6 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 1
  %7 = extractvalue { i8*, i8 } %call, 1
  store i8 %7, i8* %6, align 8
  br label %return

if.else:                                          ; preds = %entry
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  store i32 1, i32* %tmp, align 4
  %8 = load i32, i32* %tmp, align 4
  %9 = load i64, i64* %addr.addr, align 8
  %10 = inttoptr i64 %9 to i8*
  store i8* %10, i8** %tmp1, align 8
  %11 = load i8*, i8** %tmp1, align 8
  %call2 = call { i8*, i8 } @USER_BPFPTR(i8* noundef %11) #20
  %12 = bitcast %struct.sockptr_t* %retval to { i8*, i8 }*
  %13 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %12, i32 0, i32 0
  %14 = extractvalue { i8*, i8 } %call2, 0
  store i8* %14, i8** %13, align 8
  %15 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %12, i32 0, i32 1
  %16 = extractvalue { i8*, i8 } %call2, 1
  store i8 %16, i8* %15, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %17 = bitcast %struct.sockptr_t* %retval to { i8*, i8 }*
  %18 = load { i8*, i8 }, { i8*, i8 }* %17, align 8
  ret { i8*, i8 } %18
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_capable() #0 {
entry:
  %call = call zeroext i1 @capable(i32 noundef 39) #20
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %call1 = call zeroext i1 @capable(i32 noundef 21) #20
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %call1, %lor.rhs ]
  ret i1 %0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_verifier_log_attr_valid(%struct.bpf_verifier_log* noundef %log) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %0, i32 0, i32 4
  %1 = load i32, i32* %len_total, align 4
  %cmp = icmp uge i32 %1, 128
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_total1 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %2, i32 0, i32 4
  %3 = load i32, i32* %len_total1, align 4
  %cmp2 = icmp ule i32 %3, 1073741823
  br i1 %cmp2, label %land.lhs.true3, label %land.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %4, i32 0, i32 0
  %5 = load i32, i32* %level, align 8
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %land.lhs.true4, label %land.end

land.lhs.true4:                                   ; preds = %land.lhs.true3
  %6 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %6, i32 0, i32 2
  %7 = load i8*, i8** %ubuf, align 8
  %tobool5 = icmp ne i8* %7, null
  br i1 %tobool5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true4
  %8 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %level6 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %8, i32 0, i32 0
  %9 = load i32, i32* %level6, align 8
  %and = and i32 %9, -8
  %tobool7 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool7, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true4, %land.lhs.true3, %land.lhs.true, %entry
  %10 = phi i1 [ false, %land.lhs.true4 ], [ false, %land.lhs.true3 ], [ false, %land.lhs.true ], [ false, %entry ], [ %lnot, %land.rhs ]
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_verifier_state_clean(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %scratched_regs = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 42
  store i32 0, i32* %scratched_regs, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %scratched_stack_slots = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 43
  store i64 0, i64* %scratched_stack_slots, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @IS_ERR(i8* noundef %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  %2 = inttoptr i64 %1 to i8*
  %3 = ptrtoint i8* %2 to i64
  %cmp = icmp uge i64 %3, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @PTR_ERR(i8* noundef %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  ret i64 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_allow_ptr_leaks() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #20
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_allow_uninit_stack() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #20
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_allow_ptr_to_map_access() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #20
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_bypass_spec_v1() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #20
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_bypass_spec_v4() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #20
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong allocsize(0,1)
define internal noalias i8* @kvcalloc(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #8 {
entry:
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  %1 = load i64, i64* %size.addr, align 8
  %2 = load i32, i32* %flags.addr, align 4
  %or = or i32 %2, 256
  %call = call noalias i8* @kvmalloc_array(i64 noundef %0, i64 noundef %1, i32 noundef %or) #25
  ret i8* %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @state_htab_size(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 4
  %2 = load i32, i32* %len, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @add_subprog_and_kfunc(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %subprog = alloca %struct.bpf_subprog_info*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %insn_cnt = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %subprog, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 12
  %4 = bitcast %union.anon.198* %3 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %4, i32 0, i32 1
  %arraydecay1 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay1, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 4
  %7 = load i32, i32* %len, align 4
  store i32 %7, i32* %insn_cnt, align 4
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @add_subprog(%struct.bpf_verifier_env* noundef %8, i32 noundef 0) #20
  store i32 %call, i32* %ret, align 4
  %9 = load i32, i32* %ret, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load i32, i32* %ret, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call3 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %13) #20
  br i1 %call3, label %if.end8, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call4 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %14) #20
  br i1 %call4, label %if.end8, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call6 = call zeroext i1 @bpf_pseudo_kfunc_call(%struct.bpf_insn* noundef %15) #20
  br i1 %call6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %land.lhs.true5
  br label %for.inc

if.end8:                                          ; preds = %land.lhs.true5, %land.lhs.true, %for.body
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 20
  %17 = load i8, i8* %bpf_capable, align 8
  %tobool9 = trunc i8 %17 to i1
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end8
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([89 x i8], [89 x i8]* @.str.218, i64 0, i64 0)) #20
  store i32 -1, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end8
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call12 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %20) #20
  br i1 %call12, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end11
  %21 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call13 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %21) #20
  br i1 %call13, label %if.then14, label %if.else

if.then14:                                        ; preds = %lor.lhs.false, %if.end11
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load i32, i32* %i, align 4
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 3
  %25 = load i32, i32* %imm, align 4
  %add = add i32 %23, %25
  %add15 = add i32 %add, 1
  %call16 = call i32 @add_subprog(%struct.bpf_verifier_env* noundef %22, i32 noundef %add15) #20
  store i32 %call16, i32* %ret, align 4
  br label %if.end19

if.else:                                          ; preds = %lor.lhs.false
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm17 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %27, i32 0, i32 3
  %28 = load i32, i32* %imm17, align 4
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 2
  %30 = load i16, i16* %off, align 2
  %call18 = call i32 @add_kfunc_call(%struct.bpf_verifier_env* noundef %26, i32 noundef %28, i16 noundef signext %30) #20
  store i32 %call18, i32* %ret, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then14
  %31 = load i32, i32* %ret, align 4
  %cmp20 = icmp slt i32 %31, 0
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end19
  %32 = load i32, i32* %ret, align 4
  store i32 %32, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end19
  br label %for.inc

for.inc:                                          ; preds = %if.end22, %if.then7
  %33 = load i32, i32* %i, align 4
  %inc = add i32 %33, 1
  store i32 %inc, i32* %i, align 4
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %34, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond, !llvm.loop !21

for.end:                                          ; preds = %for.cond
  %35 = load i32, i32* %insn_cnt, align 4
  %36 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %37, i32 0, i32 31
  %38 = load i32, i32* %subprog_cnt, align 4
  %idxprom = zext i32 %38 to i64
  %arrayidx = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %36, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  store i32 %35, i32* %start, align 4
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %39, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %40 = load i32, i32* %level, align 8
  %and = and i32 %40, 2
  %tobool23 = icmp ne i32 %and, 0
  br i1 %tobool23, label %if.then24, label %if.end35

if.then24:                                        ; preds = %for.end
  store i32 0, i32* %i, align 4
  br label %for.cond25

for.cond25:                                       ; preds = %for.inc32, %if.then24
  %41 = load i32, i32* %i, align 4
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt26 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %42, i32 0, i32 31
  %43 = load i32, i32* %subprog_cnt26, align 4
  %cmp27 = icmp ult i32 %41, %43
  br i1 %cmp27, label %for.body28, label %for.end34

for.body28:                                       ; preds = %for.cond25
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = bitcast %struct.bpf_verifier_env* %44 to i8*
  %46 = load i32, i32* %i, align 4
  %47 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %48 = load i32, i32* %i, align 4
  %idxprom29 = sext i32 %48 to i64
  %arrayidx30 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %47, i64 %idxprom29
  %start31 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx30, i32 0, i32 0
  %49 = load i32, i32* %start31, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %45, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.219, i64 0, i64 0), i32 noundef %46, i32 noundef %49) #20
  br label %for.inc32

for.inc32:                                        ; preds = %for.body28
  %50 = load i32, i32* %i, align 4
  %inc33 = add i32 %50, 1
  store i32 %inc33, i32* %i, align 4
  br label %for.cond25, !llvm.loop !22

for.end34:                                        ; preds = %for.cond25
  br label %if.end35

if.end35:                                         ; preds = %for.end34, %for.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end35, %if.then21, %if.then10, %if.then
  %51 = load i32, i32* %retval, align 4
  ret i32 %51
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %i = alloca i32, align 4
  %subprog_start = alloca i32, align 4
  %subprog_end = alloca i32, align 4
  %off = alloca i32, align 4
  %cur_subprog = alloca i32, align 4
  %subprog = alloca %struct.bpf_subprog_info*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %code = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 0, i32* %cur_subprog, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %subprog, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 12
  %4 = bitcast %union.anon.198* %3 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %4, i32 0, i32 1
  %arraydecay1 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay1, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 4
  %7 = load i32, i32* %len, align 4
  store i32 %7, i32* %insn_cnt, align 4
  %8 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %9 = load i32, i32* %cur_subprog, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %8, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %10 = load i32, i32* %start, align 4
  store i32 %10, i32* %subprog_start, align 4
  %11 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %12 = load i32, i32* %cur_subprog, align 4
  %add = add i32 %12, 1
  %idxprom3 = sext i32 %add to i64
  %arrayidx4 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %11, i64 %idxprom3
  %start5 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx4, i32 0, i32 0
  %13 = load i32, i32* %start5, align 4
  store i32 %13, i32* %subprog_end, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %14 = load i32, i32* %i, align 4
  %15 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %14, %15
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %17 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %17 to i64
  %arrayidx7 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %16, i64 %idxprom6
  %code8 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx7, i32 0, i32 0
  %18 = load i8, i8* %code8, align 4
  store i8 %18, i8* %code, align 1
  %19 = load i8, i8* %code, align 1
  %conv = zext i8 %19 to i32
  %cmp9 = icmp eq i32 %conv, 133
  br i1 %cmp9, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %21 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %21 to i64
  %arrayidx12 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %20, i64 %idxprom11
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx12, i32 0, i32 3
  %22 = load i32, i32* %imm, align 4
  %cmp13 = icmp eq i32 %22, 12
  br i1 %cmp13, label %land.lhs.true15, label %if.end

land.lhs.true15:                                  ; preds = %land.lhs.true
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %24 = load i32, i32* %i, align 4
  %idxprom16 = sext i32 %24 to i64
  %arrayidx17 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %23, i64 %idxprom16
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx17, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv18 = zext i8 %bf.lshr to i32
  %cmp19 = icmp ne i32 %conv18, 1
  br i1 %cmp19, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true15
  %25 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %26 = load i32, i32* %cur_subprog, align 4
  %idxprom21 = sext i32 %26 to i64
  %arrayidx22 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %25, i64 %idxprom21
  %has_tail_call = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx22, i32 0, i32 3
  store i8 1, i8* %has_tail_call, align 2
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true15, %land.lhs.true, %for.body
  %27 = load i8, i8* %code, align 1
  %conv23 = zext i8 %27 to i32
  %and = and i32 %conv23, 7
  %cmp24 = icmp eq i32 %and, 0
  br i1 %cmp24, label %land.lhs.true26, label %if.end38

land.lhs.true26:                                  ; preds = %if.end
  %28 = load i8, i8* %code, align 1
  %conv27 = zext i8 %28 to i32
  %and28 = and i32 %conv27, 224
  %cmp29 = icmp eq i32 %and28, 32
  br i1 %cmp29, label %if.then35, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true26
  %29 = load i8, i8* %code, align 1
  %conv31 = zext i8 %29 to i32
  %and32 = and i32 %conv31, 224
  %cmp33 = icmp eq i32 %and32, 64
  br i1 %cmp33, label %if.then35, label %if.end38

if.then35:                                        ; preds = %lor.lhs.false, %land.lhs.true26
  %30 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %31 = load i32, i32* %cur_subprog, align 4
  %idxprom36 = sext i32 %31 to i64
  %arrayidx37 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %30, i64 %idxprom36
  %has_ld_abs = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx37, i32 0, i32 5
  store i8 1, i8* %has_ld_abs, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.then35, %lor.lhs.false, %if.end
  %32 = load i8, i8* %code, align 1
  %conv39 = zext i8 %32 to i32
  %and40 = and i32 %conv39, 7
  %cmp41 = icmp ne i32 %and40, 5
  br i1 %cmp41, label %land.lhs.true43, label %if.end49

land.lhs.true43:                                  ; preds = %if.end38
  %33 = load i8, i8* %code, align 1
  %conv44 = zext i8 %33 to i32
  %and45 = and i32 %conv44, 7
  %cmp46 = icmp ne i32 %and45, 6
  br i1 %cmp46, label %if.then48, label %if.end49

if.then48:                                        ; preds = %land.lhs.true43
  br label %next

if.end49:                                         ; preds = %land.lhs.true43, %if.end38
  %34 = load i8, i8* %code, align 1
  %conv50 = zext i8 %34 to i32
  %and51 = and i32 %conv50, 240
  %cmp52 = icmp eq i32 %and51, 144
  br i1 %cmp52, label %if.then59, label %lor.lhs.false54

lor.lhs.false54:                                  ; preds = %if.end49
  %35 = load i8, i8* %code, align 1
  %conv55 = zext i8 %35 to i32
  %and56 = and i32 %conv55, 240
  %cmp57 = icmp eq i32 %and56, 128
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %lor.lhs.false54, %if.end49
  br label %next

if.end60:                                         ; preds = %lor.lhs.false54
  %36 = load i32, i32* %i, align 4
  %37 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %38 = load i32, i32* %i, align 4
  %idxprom61 = sext i32 %38 to i64
  %arrayidx62 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %37, i64 %idxprom61
  %off63 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx62, i32 0, i32 2
  %39 = load i16, i16* %off63, align 2
  %conv64 = sext i16 %39 to i32
  %add65 = add i32 %36, %conv64
  %add66 = add i32 %add65, 1
  store i32 %add66, i32* %off, align 4
  %40 = load i32, i32* %off, align 4
  %41 = load i32, i32* %subprog_start, align 4
  %cmp67 = icmp slt i32 %40, %41
  br i1 %cmp67, label %if.then72, label %lor.lhs.false69

lor.lhs.false69:                                  ; preds = %if.end60
  %42 = load i32, i32* %off, align 4
  %43 = load i32, i32* %subprog_end, align 4
  %cmp70 = icmp sge i32 %42, %43
  br i1 %cmp70, label %if.then72, label %if.end73

if.then72:                                        ; preds = %lor.lhs.false69, %if.end60
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = bitcast %struct.bpf_verifier_env* %44 to i8*
  %46 = load i32, i32* %i, align 4
  %47 = load i32, i32* %off, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %45, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.232, i64 0, i64 0), i32 noundef %46, i32 noundef %47) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end73:                                         ; preds = %lor.lhs.false69
  br label %next

next:                                             ; preds = %if.end73, %if.then59, %if.then48
  %48 = load i32, i32* %i, align 4
  %49 = load i32, i32* %subprog_end, align 4
  %sub = sub i32 %49, 1
  %cmp74 = icmp eq i32 %48, %sub
  br i1 %cmp74, label %if.then76, label %if.end94

if.then76:                                        ; preds = %next
  %50 = load i8, i8* %code, align 1
  %conv77 = zext i8 %50 to i32
  %cmp78 = icmp ne i32 %conv77, 149
  br i1 %cmp78, label %land.lhs.true80, label %if.end85

land.lhs.true80:                                  ; preds = %if.then76
  %51 = load i8, i8* %code, align 1
  %conv81 = zext i8 %51 to i32
  %cmp82 = icmp ne i32 %conv81, 5
  br i1 %cmp82, label %if.then84, label %if.end85

if.then84:                                        ; preds = %land.lhs.true80
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.233, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end85:                                         ; preds = %land.lhs.true80, %if.then76
  %54 = load i32, i32* %subprog_end, align 4
  store i32 %54, i32* %subprog_start, align 4
  %55 = load i32, i32* %cur_subprog, align 4
  %inc = add i32 %55, 1
  store i32 %inc, i32* %cur_subprog, align 4
  %56 = load i32, i32* %cur_subprog, align 4
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %57, i32 0, i32 31
  %58 = load i32, i32* %subprog_cnt, align 4
  %cmp86 = icmp ult i32 %56, %58
  br i1 %cmp86, label %if.then88, label %if.end93

if.then88:                                        ; preds = %if.end85
  %59 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %60 = load i32, i32* %cur_subprog, align 4
  %add89 = add i32 %60, 1
  %idxprom90 = sext i32 %add89 to i64
  %arrayidx91 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %59, i64 %idxprom90
  %start92 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx91, i32 0, i32 0
  %61 = load i32, i32* %start92, align 4
  store i32 %61, i32* %subprog_end, align 4
  br label %if.end93

if.end93:                                         ; preds = %if.then88, %if.end85
  br label %if.end94

if.end94:                                         ; preds = %if.end93, %next
  br label %for.inc

for.inc:                                          ; preds = %if.end94
  %62 = load i32, i32* %i, align 4
  %inc95 = add i32 %62, 1
  store i32 %inc95, i32* %i, align 4
  br label %for.cond, !llvm.loop !23

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then84, %if.then72
  %63 = load i32, i32* %retval, align 4
  ret i32 %63
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_btf_info(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, i8* %uattr.coerce0, i8 %uattr.coerce1) #0 {
entry:
  %retval = alloca i32, align 4
  %uattr = alloca %struct.sockptr_t, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %btf = alloca %struct.btf*, align 8
  %err = alloca i32, align 4
  %0 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %uattr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %uattr.coerce1, i8* %2, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  %3 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %4 = bitcast %union.bpf_attr* %3 to %struct.anon.144*
  %func_info_cnt = getelementptr inbounds %struct.anon.144, %struct.anon.144* %4, i32 0, i32 15
  %5 = load i32, i32* %func_info_cnt, align 8
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end4, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %6 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %7 = bitcast %union.bpf_attr* %6 to %struct.anon.144*
  %line_info_cnt = getelementptr inbounds %struct.anon.144, %struct.anon.144* %7, i32 0, i32 18
  %8 = load i32, i32* %line_info_cnt, align 8
  %tobool1 = icmp ne i32 %8, 0
  br i1 %tobool1, label %if.end4, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @check_abnormal_return(%struct.bpf_verifier_env* noundef %9) #20
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %entry
  %10 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %11 = bitcast %union.bpf_attr* %10 to %struct.anon.144*
  %prog_btf_fd = getelementptr inbounds %struct.anon.144, %struct.anon.144* %11, i32 0, i32 12
  %12 = load i32, i32* %prog_btf_fd, align 8
  %call5 = call %struct.btf* @btf_get_by_fd(i32 noundef %12) #20
  store %struct.btf* %call5, %struct.btf** %btf, align 8
  %13 = load %struct.btf*, %struct.btf** %btf, align 8
  %14 = bitcast %struct.btf* %13 to i8*
  %call6 = call zeroext i1 @IS_ERR(i8* noundef %14) #20
  br i1 %call6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end4
  %15 = load %struct.btf*, %struct.btf** %btf, align 8
  %16 = bitcast %struct.btf* %15 to i8*
  %call8 = call i64 @PTR_ERR(i8* noundef %16) #20
  %conv = trunc i64 %call8 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end4
  %17 = load %struct.btf*, %struct.btf** %btf, align 8
  %call10 = call zeroext i1 @btf_is_kernel(%struct.btf* noundef %17) #20
  br i1 %call10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  %18 = load %struct.btf*, %struct.btf** %btf, align 8
  call void @btf_put(%struct.btf* noundef %18) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end9
  %19 = load %struct.btf*, %struct.btf** %btf, align 8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 2
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 10
  %22 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf13 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %22, i32 0, i32 50
  store %struct.btf* %19, %struct.btf** %btf13, align 8
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %25 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %26 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %25, i32 0, i32 0
  %27 = load i8*, i8** %26, align 8
  %28 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %25, i32 0, i32 1
  %29 = load i8, i8* %28, align 8
  %call14 = call i32 @check_btf_func(%struct.bpf_verifier_env* noundef %23, %union.bpf_attr* noundef %24, i8* %27, i8 %29) #20
  store i32 %call14, i32* %err, align 4
  %30 = load i32, i32* %err, align 4
  %tobool15 = icmp ne i32 %30, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end12
  %31 = load i32, i32* %err, align 4
  store i32 %31, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end12
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %34 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %35 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %34, i32 0, i32 0
  %36 = load i8*, i8** %35, align 8
  %37 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %34, i32 0, i32 1
  %38 = load i8, i8* %37, align 8
  %call18 = call i32 @check_btf_line(%struct.bpf_verifier_env* noundef %32, %union.bpf_attr* noundef %33, i8* %36, i8 %38) #20
  store i32 %call18, i32* %err, align 4
  %39 = load i32, i32* %err, align 4
  %tobool19 = icmp ne i32 %39, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end17
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %43 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %44 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %43, i32 0, i32 0
  %45 = load i8*, i8** %44, align 8
  %46 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %43, i32 0, i32 1
  %47 = load i8, i8* %46, align 8
  %call22 = call i32 @check_core_relo(%struct.bpf_verifier_env* noundef %41, %union.bpf_attr* noundef %42, i8* %45, i8 %47) #20
  store i32 %call22, i32* %err, align 4
  %48 = load i32, i32* %err, align 4
  %tobool23 = icmp ne i32 %48, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end21
  %49 = load i32, i32* %err, align 4
  store i32 %49, i32* %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.end21
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end25, %if.then24, %if.then20, %if.then16, %if.then11, %if.then7, %if.end, %if.then3
  %50 = load i32, i32* %retval, align 4
  ret i32 %50
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_attach_btf_id(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %tgt_prog = alloca %struct.bpf_prog*, align 8
  %tgt_info = alloca %struct.bpf_attach_target_info, align 8
  %btf_id = alloca i32, align 4
  %tr = alloca %struct.bpf_trampoline*, align 8
  %ret = alloca i32, align 4
  %key = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %dst_prog = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 17
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %dst_prog, align 8
  store %struct.bpf_prog* %4, %struct.bpf_prog** %tgt_prog, align 8
  %5 = bitcast %struct.bpf_attach_target_info* %tgt_info to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %5, i8 0, i64 56, i1 false)
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 10
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux2, align 8
  %attach_btf_id = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 10
  %8 = load i32, i32* %attach_btf_id, align 4
  store i32 %8, i32* %btf_id, align 4
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %9, i32 0, i32 2
  %10 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %10, 31
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %11, i32 0, i32 10
  %12 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %sleepable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %12, i32 0, i32 25
  %13 = load i8, i8* %sleepable, align 4
  %tobool = trunc i8 %13 to i1
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.253, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %entry
  %16 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux6 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %16, i32 0, i32 10
  %17 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux6, align 8
  %sleepable7 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %17, i32 0, i32 25
  %18 = load i8, i8* %sleepable7, align 4
  %tobool8 = trunc i8 %18 to i1
  br i1 %tobool8, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %if.end5
  %19 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type9 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %19, i32 0, i32 2
  %20 = load i32, i32* %type9, align 4
  %cmp10 = icmp ne i32 %20, 26
  br i1 %cmp10, label %land.lhs.true11, label %if.end18

land.lhs.true11:                                  ; preds = %land.lhs.true
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type12 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 2
  %22 = load i32, i32* %type12, align 4
  %cmp13 = icmp ne i32 %22, 29
  br i1 %cmp13, label %land.lhs.true14, label %if.end18

land.lhs.true14:                                  ; preds = %land.lhs.true11
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type15 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %23, i32 0, i32 2
  %24 = load i32, i32* %type15, align 4
  %cmp16 = icmp ne i32 %24, 2
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.lhs.true14
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([78 x i8], [78 x i8]* @.str.254, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %land.lhs.true14, %land.lhs.true11, %land.lhs.true, %if.end5
  %27 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type19 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %27, i32 0, i32 2
  %28 = load i32, i32* %type19, align 4
  %cmp20 = icmp eq i32 %28, 27
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @check_struct_ops_btf_id(%struct.bpf_verifier_env* noundef %29) #20
  store i32 %call, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end18
  %30 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type23 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %30, i32 0, i32 2
  %31 = load i32, i32* %type23, align 4
  %cmp24 = icmp ne i32 %31, 26
  br i1 %cmp24, label %land.lhs.true25, label %if.end32

land.lhs.true25:                                  ; preds = %if.end22
  %32 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type26 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %32, i32 0, i32 2
  %33 = load i32, i32* %type26, align 4
  %cmp27 = icmp ne i32 %33, 29
  br i1 %cmp27, label %land.lhs.true28, label %if.end32

land.lhs.true28:                                  ; preds = %land.lhs.true25
  %34 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type29 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %34, i32 0, i32 2
  %35 = load i32, i32* %type29, align 4
  %cmp30 = icmp ne i32 %35, 28
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %land.lhs.true28
  store i32 0, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %land.lhs.true28, %land.lhs.true25, %if.end22
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %36, i32 0, i32 26
  %37 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %38 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %39 = load i32, i32* %btf_id, align 4
  %call33 = call i32 @bpf_check_attach_target(%struct.bpf_verifier_log* noundef %log, %struct.bpf_prog* noundef %37, %struct.bpf_prog* noundef %38, i32 noundef %39, %struct.bpf_attach_target_info* noundef %tgt_info) #20
  store i32 %call33, i32* %ret, align 4
  %40 = load i32, i32* %ret, align 4
  %tobool34 = icmp ne i32 %40, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end32
  %41 = load i32, i32* %ret, align 4
  store i32 %41, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.end32
  %42 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %tobool37 = icmp ne %struct.bpf_prog* %42, null
  br i1 %tobool37, label %land.lhs.true38, label %if.end44

land.lhs.true38:                                  ; preds = %if.end36
  %43 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type39 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %43, i32 0, i32 2
  %44 = load i32, i32* %type39, align 4
  %cmp40 = icmp eq i32 %44, 28
  br i1 %cmp40, label %if.then41, label %if.end44

if.then41:                                        ; preds = %land.lhs.true38
  %45 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %type42 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %45, i32 0, i32 2
  %46 = load i32, i32* %type42, align 4
  %idxprom = zext i32 %46 to i64
  %arrayidx = getelementptr [32 x %struct.bpf_verifier_ops*], [32 x %struct.bpf_verifier_ops*]* @bpf_verifier_ops, i64 0, i64 %idxprom
  %47 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %arrayidx, align 8
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %48, i32 0, i32 3
  store %struct.bpf_verifier_ops* %47, %struct.bpf_verifier_ops** %ops, align 8
  %49 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %49, i32 0, i32 3
  %50 = load i32, i32* %expected_attach_type, align 8
  %51 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type43 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %51, i32 0, i32 3
  store i32 %50, i32* %expected_attach_type43, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.then41, %land.lhs.true38, %if.end36
  %tgt_type = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %tgt_info, i32 0, i32 3
  %52 = load %struct.btf_type*, %struct.btf_type** %tgt_type, align 8
  %53 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux45 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %53, i32 0, i32 10
  %54 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux45, align 8
  %attach_func_proto = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %54, i32 0, i32 28
  store %struct.btf_type* %52, %struct.btf_type** %attach_func_proto, align 8
  %tgt_name = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %tgt_info, i32 0, i32 2
  %55 = load i8*, i8** %tgt_name, align 8
  %56 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux46 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %56, i32 0, i32 10
  %57 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux46, align 8
  %attach_func_name = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %57, i32 0, i32 29
  store i8* %55, i8** %attach_func_name, align 8
  %58 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %tobool47 = icmp ne %struct.bpf_prog* %58, null
  br i1 %tobool47, label %if.then48, label %if.end53

if.then48:                                        ; preds = %if.end44
  %59 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %type49 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %59, i32 0, i32 2
  %60 = load i32, i32* %type49, align 4
  %61 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux50 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %61, i32 0, i32 10
  %62 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux50, align 8
  %saved_dst_prog_type = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %62, i32 0, i32 19
  store i32 %60, i32* %saved_dst_prog_type, align 8
  %63 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %expected_attach_type51 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %63, i32 0, i32 3
  %64 = load i32, i32* %expected_attach_type51, align 8
  %65 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux52 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %65, i32 0, i32 10
  %66 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux52, align 8
  %saved_dst_attach_type = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %66, i32 0, i32 20
  store i32 %64, i32* %saved_dst_attach_type, align 4
  br label %if.end53

if.end53:                                         ; preds = %if.then48, %if.end44
  %67 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type54 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %67, i32 0, i32 3
  %68 = load i32, i32* %expected_attach_type54, align 8
  %cmp55 = icmp eq i32 %68, 23
  br i1 %cmp55, label %if.then56, label %if.else

if.then56:                                        ; preds = %if.end53
  %69 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux57 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %69, i32 0, i32 10
  %70 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux57, align 8
  %attach_btf_trace = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %70, i32 0, i32 23
  store i8 1, i8* %attach_btf_trace, align 2
  store i32 0, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end53
  %71 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type58 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %71, i32 0, i32 3
  %72 = load i32, i32* %expected_attach_type58, align 8
  %cmp59 = icmp eq i32 %72, 28
  br i1 %cmp59, label %if.then60, label %if.end64

if.then60:                                        ; preds = %if.else
  %73 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call61 = call zeroext i1 @bpf_iter_prog_supported(%struct.bpf_prog* noundef %73) #20
  br i1 %call61, label %if.end63, label %if.then62

if.then62:                                        ; preds = %if.then60
  store i32 -22, i32* %retval, align 4
  br label %return

if.end63:                                         ; preds = %if.then60
  store i32 0, i32* %retval, align 4
  br label %return

if.end64:                                         ; preds = %if.else
  br label %if.end65

if.end65:                                         ; preds = %if.end64
  %74 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type66 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %74, i32 0, i32 2
  %75 = load i32, i32* %type66, align 4
  %cmp67 = icmp eq i32 %75, 29
  br i1 %cmp67, label %if.then68, label %if.else74

if.then68:                                        ; preds = %if.end65
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log69 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %76, i32 0, i32 26
  %77 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call70 = call i32 @bpf_lsm_verify_prog(%struct.bpf_verifier_log* noundef %log69, %struct.bpf_prog* noundef %77) #20
  store i32 %call70, i32* %ret, align 4
  %78 = load i32, i32* %ret, align 4
  %cmp71 = icmp slt i32 %78, 0
  br i1 %cmp71, label %if.then72, label %if.end73

if.then72:                                        ; preds = %if.then68
  %79 = load i32, i32* %ret, align 4
  store i32 %79, i32* %retval, align 4
  br label %return

if.end73:                                         ; preds = %if.then68
  br label %if.end81

if.else74:                                        ; preds = %if.end65
  %80 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type75 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %80, i32 0, i32 2
  %81 = load i32, i32* %type75, align 4
  %cmp76 = icmp eq i32 %81, 26
  br i1 %cmp76, label %land.lhs.true77, label %if.end80

land.lhs.true77:                                  ; preds = %if.else74
  %82 = load i32, i32* %btf_id, align 4
  %call78 = call zeroext i1 @btf_id_set_contains(%struct.btf_id_set* noundef @btf_id_deny, i32 noundef %82) #20
  br i1 %call78, label %if.then79, label %if.end80

if.then79:                                        ; preds = %land.lhs.true77
  store i32 -22, i32* %retval, align 4
  br label %return

if.end80:                                         ; preds = %land.lhs.true77, %if.else74
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %if.end73
  %83 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %84 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux82 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %84, i32 0, i32 10
  %85 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux82, align 8
  %attach_btf = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %85, i32 0, i32 14
  %86 = load %struct.btf*, %struct.btf** %attach_btf, align 8
  %87 = load i32, i32* %btf_id, align 4
  %call83 = call i64 @bpf_trampoline_compute_key(%struct.bpf_prog* noundef %83, %struct.btf* noundef %86, i32 noundef %87) #20
  store i64 %call83, i64* %key, align 8
  %88 = load i64, i64* %key, align 8
  %call84 = call %struct.bpf_trampoline* @bpf_trampoline_get(i64 noundef %88, %struct.bpf_attach_target_info* noundef %tgt_info) #20
  store %struct.bpf_trampoline* %call84, %struct.bpf_trampoline** %tr, align 8
  %89 = load %struct.bpf_trampoline*, %struct.bpf_trampoline** %tr, align 8
  %tobool85 = icmp ne %struct.bpf_trampoline* %89, null
  br i1 %tobool85, label %if.end87, label %if.then86

if.then86:                                        ; preds = %if.end81
  store i32 -12, i32* %retval, align 4
  br label %return

if.end87:                                         ; preds = %if.end81
  %90 = load %struct.bpf_trampoline*, %struct.bpf_trampoline** %tr, align 8
  %91 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux88 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %91, i32 0, i32 10
  %92 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux88, align 8
  %dst_trampoline = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %92, i32 0, i32 18
  store %struct.bpf_trampoline* %90, %struct.bpf_trampoline** %dst_trampoline, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end87, %if.then86, %if.then79, %if.then72, %if.end63, %if.then62, %if.then56, %if.then35, %if.then31, %if.then21, %if.then17, %if.end, %if.then4
  %93 = load i32, i32* %retval, align 4
  ret i32 %93
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @resolve_pseudo_ldimm64(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %err = alloca i32, align 4
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %f = alloca %struct.fd, align 8
  %addr = alloca i64, align 8
  %fd = alloca i32, align 4
  %tmp = alloca %struct.fd, align 8
  %off146 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 12
  %3 = bitcast %union.anon.198* %2 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 2
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 4
  %6 = load i32, i32* %len, align 4
  store i32 %6, i32* %insn_cnt, align 4
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 2
  %8 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %call = call i32 @bpf_prog_calc_tag(%struct.bpf_prog* noundef %8) #20
  store i32 %call, i32* %err, align 4
  %9 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load i32, i32* %err, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc209, %if.end
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end212

for.body:                                         ; preds = %for.cond
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 0
  %14 = load i8, i8* %code, align 4
  %conv = zext i8 %14 to i32
  %and = and i32 %conv, 7
  %cmp3 = icmp eq i32 %and, 1
  br i1 %cmp3, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %for.body
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code5 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 0
  %16 = load i8, i8* %code5, align 4
  %conv6 = zext i8 %16 to i32
  %and7 = and i32 %conv6, 224
  %cmp8 = icmp ne i32 %and7, 96
  br i1 %cmp8, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %17, i32 0, i32 3
  %18 = load i32, i32* %imm, align 4
  %cmp10 = icmp ne i32 %18, 0
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.260, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %lor.lhs.false, %for.body
  %21 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %21, i64 0
  %code14 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 0
  %22 = load i8, i8* %code14, align 4
  %conv15 = zext i8 %22 to i32
  %cmp16 = icmp eq i32 %conv15, 24
  br i1 %cmp16, label %if.then18, label %if.end202

if.then18:                                        ; preds = %if.end13
  %23 = load i32, i32* %i, align 4
  %24 = load i32, i32* %insn_cnt, align 4
  %sub = sub i32 %24, 1
  %cmp19 = icmp eq i32 %23, %sub
  br i1 %cmp19, label %if.then43, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %if.then18
  %25 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx22 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %25, i64 1
  %code23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx22, i32 0, i32 0
  %26 = load i8, i8* %code23, align 4
  %conv24 = zext i8 %26 to i32
  %cmp25 = icmp ne i32 %conv24, 0
  br i1 %cmp25, label %if.then43, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %lor.lhs.false21
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx28 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %27, i64 1
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx28, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv29 = zext i8 %bf.clear to i32
  %cmp30 = icmp ne i32 %conv29, 0
  br i1 %cmp30, label %if.then43, label %lor.lhs.false32

lor.lhs.false32:                                  ; preds = %lor.lhs.false27
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx33 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %28, i64 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx33, i32 0, i32 1
  %bf.load34 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load34, 4
  %conv35 = zext i8 %bf.lshr to i32
  %cmp36 = icmp ne i32 %conv35, 0
  br i1 %cmp36, label %if.then43, label %lor.lhs.false38

lor.lhs.false38:                                  ; preds = %lor.lhs.false32
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx39 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %29, i64 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx39, i32 0, i32 2
  %30 = load i16, i16* %off, align 2
  %conv40 = sext i16 %30 to i32
  %cmp41 = icmp ne i32 %conv40, 0
  br i1 %cmp41, label %if.then43, label %if.end44

if.then43:                                        ; preds = %lor.lhs.false38, %lor.lhs.false32, %lor.lhs.false27, %lor.lhs.false21, %if.then18
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = bitcast %struct.bpf_verifier_env* %31 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %32, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.261, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %lor.lhs.false38
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx45 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %33, i64 0
  %src_reg46 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx45, i32 0, i32 1
  %bf.load47 = load i8, i8* %src_reg46, align 1
  %bf.lshr48 = lshr i8 %bf.load47, 4
  %conv49 = zext i8 %bf.lshr48 to i32
  %cmp50 = icmp eq i32 %conv49, 0
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end44
  br label %next_insn

if.end53:                                         ; preds = %if.end44
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx54 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %34, i64 0
  %src_reg55 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx54, i32 0, i32 1
  %bf.load56 = load i8, i8* %src_reg55, align 1
  %bf.lshr57 = lshr i8 %bf.load56, 4
  %conv58 = zext i8 %bf.lshr57 to i32
  %cmp59 = icmp eq i32 %conv58, 3
  br i1 %cmp59, label %if.then61, label %if.end67

if.then61:                                        ; preds = %if.end53
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 24
  %36 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %37 = load i32, i32* %i, align 4
  %idxprom = sext i32 %37 to i64
  %arrayidx62 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %36, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx62, %struct.bpf_insn_aux_data** %aux, align 8
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %40 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call63 = call i32 @check_pseudo_btf_id(%struct.bpf_verifier_env* noundef %38, %struct.bpf_insn* noundef %39, %struct.bpf_insn_aux_data* noundef %40) #20
  store i32 %call63, i32* %err, align 4
  %41 = load i32, i32* %err, align 4
  %tobool64 = icmp ne i32 %41, 0
  br i1 %tobool64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %if.then61
  %42 = load i32, i32* %err, align 4
  store i32 %42, i32* %retval, align 4
  br label %return

if.end66:                                         ; preds = %if.then61
  br label %next_insn

if.end67:                                         ; preds = %if.end53
  %43 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx68 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %43, i64 0
  %src_reg69 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx68, i32 0, i32 1
  %bf.load70 = load i8, i8* %src_reg69, align 1
  %bf.lshr71 = lshr i8 %bf.load70, 4
  %conv72 = zext i8 %bf.lshr71 to i32
  %cmp73 = icmp eq i32 %conv72, 4
  br i1 %cmp73, label %if.then75, label %if.end79

if.then75:                                        ; preds = %if.end67
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data76 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %44, i32 0, i32 24
  %45 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data76, align 8
  %46 = load i32, i32* %i, align 4
  %idxprom77 = sext i32 %46 to i64
  %arrayidx78 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %45, i64 %idxprom77
  store %struct.bpf_insn_aux_data* %arrayidx78, %struct.bpf_insn_aux_data** %aux, align 8
  %47 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %48 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %47, i32 0, i32 0
  %ptr_type = bitcast %union.anon.210* %48 to i32*
  store i32 19, i32* %ptr_type, align 8
  br label %next_insn

if.end79:                                         ; preds = %if.end67
  %49 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx80 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %49, i64 0
  %src_reg81 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx80, i32 0, i32 1
  %bf.load82 = load i8, i8* %src_reg81, align 1
  %bf.lshr83 = lshr i8 %bf.load82, 4
  %conv84 = zext i8 %bf.lshr83 to i32
  switch i32 %conv84, label %sw.default [
    i32 2, label %sw.bb
    i32 6, label %sw.bb
    i32 1, label %sw.bb85
    i32 5, label %sw.bb85
  ]

sw.bb:                                            ; preds = %if.end79, %if.end79
  br label %sw.epilog

sw.bb85:                                          ; preds = %if.end79, %if.end79
  %50 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx86 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %50, i64 1
  %imm87 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx86, i32 0, i32 3
  %51 = load i32, i32* %imm87, align 4
  %cmp88 = icmp eq i32 %51, 0
  br i1 %cmp88, label %if.then90, label %if.end91

if.then90:                                        ; preds = %sw.bb85
  br label %sw.epilog

if.end91:                                         ; preds = %sw.bb85
  br label %sw.default

sw.default:                                       ; preds = %if.end79, %if.end91
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.262, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %if.then90, %sw.bb
  %54 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx92 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %54, i64 0
  %src_reg93 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx92, i32 0, i32 1
  %bf.load94 = load i8, i8* %src_reg93, align 1
  %bf.lshr95 = lshr i8 %bf.load94, 4
  %conv96 = zext i8 %bf.lshr95 to i32
  switch i32 %conv96, label %sw.default109 [
    i32 6, label %sw.bb97
    i32 5, label %sw.bb97
  ]

sw.bb97:                                          ; preds = %sw.epilog, %sw.epilog
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %fd_array = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %55, i32 0, i32 41
  %56 = bitcast %struct.sockptr_t* %fd_array to { i8*, i8 }*
  %57 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %56, i32 0, i32 0
  %58 = load i8*, i8** %57, align 8
  %59 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %56, i32 0, i32 1
  %60 = load i8, i8* %59, align 8
  %call98 = call zeroext i1 @bpfptr_is_null(i8* %58, i8 %60) #20
  br i1 %call98, label %if.then99, label %if.end100

if.then99:                                        ; preds = %sw.bb97
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %62 = bitcast %struct.bpf_verifier_env* %61 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %62, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.263, i64 0, i64 0)) #20
  store i32 -71, i32* %retval, align 4
  br label %return

if.end100:                                        ; preds = %sw.bb97
  %63 = bitcast i32* %fd to i8*
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %fd_array101 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %64, i32 0, i32 41
  %65 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx102 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %65, i64 0
  %imm103 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx102, i32 0, i32 3
  %66 = load i32, i32* %imm103, align 4
  %conv104 = sext i32 %66 to i64
  %mul = mul i64 %conv104, 4
  %67 = bitcast %struct.sockptr_t* %fd_array101 to { i8*, i8 }*
  %68 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %67, i32 0, i32 0
  %69 = load i8*, i8** %68, align 8
  %70 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %67, i32 0, i32 1
  %71 = load i8, i8* %70, align 8
  %call105 = call i32 @copy_from_bpfptr_offset(i8* noundef %63, i8* %69, i8 %71, i64 noundef %mul, i64 noundef 4) #20
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %if.then107, label %if.end108

if.then107:                                       ; preds = %if.end100
  store i32 -14, i32* %retval, align 4
  br label %return

if.end108:                                        ; preds = %if.end100
  br label %sw.epilog112

sw.default109:                                    ; preds = %sw.epilog
  %72 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx110 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %72, i64 0
  %imm111 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx110, i32 0, i32 3
  %73 = load i32, i32* %imm111, align 4
  store i32 %73, i32* %fd, align 4
  br label %sw.epilog112

sw.epilog112:                                     ; preds = %sw.default109, %if.end108
  %74 = load i32, i32* %fd, align 4
  %call113 = call { %struct.file*, i32 } @fdget(i32 noundef %74) #20
  %75 = bitcast %struct.fd* %tmp to { %struct.file*, i32 }*
  %76 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %75, i32 0, i32 0
  %77 = extractvalue { %struct.file*, i32 } %call113, 0
  store %struct.file* %77, %struct.file** %76, align 8
  %78 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %75, i32 0, i32 1
  %79 = extractvalue { %struct.file*, i32 } %call113, 1
  store i32 %79, i32* %78, align 8
  %80 = bitcast %struct.fd* %f to i8*
  %81 = bitcast %struct.fd* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %80, i8* align 8 %81, i64 16, i1 false)
  %82 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %83 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %82, i32 0, i32 0
  %84 = load %struct.file*, %struct.file** %83, align 8
  %85 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %82, i32 0, i32 1
  %86 = load i32, i32* %85, align 8
  %call114 = call %struct.bpf_map* @__bpf_map_get(%struct.file* %84, i32 %86) #20
  store %struct.bpf_map* %call114, %struct.bpf_map** %map, align 8
  %87 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %88 = bitcast %struct.bpf_map* %87 to i8*
  %call115 = call zeroext i1 @IS_ERR(i8* noundef %88) #20
  br i1 %call115, label %if.then116, label %if.end121

if.then116:                                       ; preds = %sw.epilog112
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %90 = bitcast %struct.bpf_verifier_env* %89 to i8*
  %91 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx117 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %91, i64 0
  %imm118 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx117, i32 0, i32 3
  %92 = load i32, i32* %imm118, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %90, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.264, i64 0, i64 0), i32 noundef %92) #20
  %93 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %94 = bitcast %struct.bpf_map* %93 to i8*
  %call119 = call i64 @PTR_ERR(i8* noundef %94) #20
  %conv120 = trunc i64 %call119 to i32
  store i32 %conv120, i32* %retval, align 4
  br label %return

if.end121:                                        ; preds = %sw.epilog112
  %95 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %96 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %97 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog122 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %97, i32 0, i32 2
  %98 = load %struct.bpf_prog*, %struct.bpf_prog** %prog122, align 8
  %call123 = call i32 @check_map_prog_compatibility(%struct.bpf_verifier_env* noundef %95, %struct.bpf_map* noundef %96, %struct.bpf_prog* noundef %98) #20
  store i32 %call123, i32* %err, align 4
  %99 = load i32, i32* %err, align 4
  %tobool124 = icmp ne i32 %99, 0
  br i1 %tobool124, label %if.then125, label %if.end126

if.then125:                                       ; preds = %if.end121
  %100 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %101 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %100, i32 0, i32 0
  %102 = load %struct.file*, %struct.file** %101, align 8
  %103 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %100, i32 0, i32 1
  %104 = load i32, i32* %103, align 8
  call void @fdput(%struct.file* %102, i32 %104) #20
  %105 = load i32, i32* %err, align 4
  store i32 %105, i32* %retval, align 4
  br label %return

if.end126:                                        ; preds = %if.end121
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data127 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %106, i32 0, i32 24
  %107 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data127, align 8
  %108 = load i32, i32* %i, align 4
  %idxprom128 = sext i32 %108 to i64
  %arrayidx129 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %107, i64 %idxprom128
  store %struct.bpf_insn_aux_data* %arrayidx129, %struct.bpf_insn_aux_data** %aux, align 8
  %109 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx130 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %109, i64 0
  %src_reg131 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx130, i32 0, i32 1
  %bf.load132 = load i8, i8* %src_reg131, align 1
  %bf.lshr133 = lshr i8 %bf.load132, 4
  %conv134 = zext i8 %bf.lshr133 to i32
  %cmp135 = icmp eq i32 %conv134, 1
  br i1 %cmp135, label %if.then145, label %lor.lhs.false137

lor.lhs.false137:                                 ; preds = %if.end126
  %110 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx138 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %110, i64 0
  %src_reg139 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx138, i32 0, i32 1
  %bf.load140 = load i8, i8* %src_reg139, align 1
  %bf.lshr141 = lshr i8 %bf.load140, 4
  %conv142 = zext i8 %bf.lshr141 to i32
  %cmp143 = icmp eq i32 %conv142, 5
  br i1 %cmp143, label %if.then145, label %if.else

if.then145:                                       ; preds = %lor.lhs.false137, %if.end126
  %111 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %112 = ptrtoint %struct.bpf_map* %111 to i64
  store i64 %112, i64* %addr, align 8
  br label %if.end163

if.else:                                          ; preds = %lor.lhs.false137
  %113 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx147 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %113, i64 1
  %imm148 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx147, i32 0, i32 3
  %114 = load i32, i32* %imm148, align 4
  store i32 %114, i32* %off146, align 4
  %115 = load i32, i32* %off146, align 4
  %cmp149 = icmp uge i32 %115, 536870912
  br i1 %cmp149, label %if.then151, label %if.end152

if.then151:                                       ; preds = %if.else
  %116 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %117 = bitcast %struct.bpf_verifier_env* %116 to i8*
  %118 = load i32, i32* %off146, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %117, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.265, i64 0, i64 0), i32 noundef %118) #20
  %119 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %120 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %119, i32 0, i32 0
  %121 = load %struct.file*, %struct.file** %120, align 8
  %122 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %119, i32 0, i32 1
  %123 = load i32, i32* %122, align 8
  call void @fdput(%struct.file* %121, i32 %123) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end152:                                        ; preds = %if.else
  %124 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %124, i32 0, i32 0
  %125 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %125, i32 0, i32 28
  %126 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %tobool153 = icmp ne i32 (%struct.bpf_map*, i64*, i32)* %126, null
  br i1 %tobool153, label %if.end155, label %if.then154

if.then154:                                       ; preds = %if.end152
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %128 = bitcast %struct.bpf_verifier_env* %127 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %128, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.266, i64 0, i64 0)) #20
  %129 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %130 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %129, i32 0, i32 0
  %131 = load %struct.file*, %struct.file** %130, align 8
  %132 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %129, i32 0, i32 1
  %133 = load i32, i32* %132, align 8
  call void @fdput(%struct.file* %131, i32 %133) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end155:                                        ; preds = %if.end152
  %134 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops156 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %134, i32 0, i32 0
  %135 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops156, align 64
  %map_direct_value_addr157 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %135, i32 0, i32 28
  %136 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr157, align 8
  %137 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %138 = load i32, i32* %off146, align 4
  %call158 = call i32 %136(%struct.bpf_map* noundef %137, i64* noundef %addr, i32 noundef %138) #20
  store i32 %call158, i32* %err, align 4
  %139 = load i32, i32* %err, align 4
  %tobool159 = icmp ne i32 %139, 0
  br i1 %tobool159, label %if.then160, label %if.end161

if.then160:                                       ; preds = %if.end155
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %141 = bitcast %struct.bpf_verifier_env* %140 to i8*
  %142 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %142, i32 0, i32 5
  %143 = load i32, i32* %value_size, align 32
  %144 = load i32, i32* %off146, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %141, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.267, i64 0, i64 0), i32 noundef %143, i32 noundef %144) #20
  %145 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %146 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %145, i32 0, i32 0
  %147 = load %struct.file*, %struct.file** %146, align 8
  %148 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %145, i32 0, i32 1
  %149 = load i32, i32* %148, align 8
  call void @fdput(%struct.file* %147, i32 %149) #20
  %150 = load i32, i32* %err, align 4
  store i32 %150, i32* %retval, align 4
  br label %return

if.end161:                                        ; preds = %if.end155
  %151 = load i32, i32* %off146, align 4
  %152 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %153 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %152, i32 0, i32 0
  %154 = bitcast %union.anon.210* %153 to %struct.anon.211*
  %map_off = getelementptr inbounds %struct.anon.211, %struct.anon.211* %154, i32 0, i32 1
  store i32 %151, i32* %map_off, align 4
  %155 = load i32, i32* %off146, align 4
  %conv162 = zext i32 %155 to i64
  %156 = load i64, i64* %addr, align 8
  %add = add i64 %156, %conv162
  store i64 %add, i64* %addr, align 8
  br label %if.end163

if.end163:                                        ; preds = %if.end161, %if.then145
  %157 = load i64, i64* %addr, align 8
  %conv164 = trunc i64 %157 to i32
  %158 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx165 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %158, i64 0
  %imm166 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx165, i32 0, i32 3
  store i32 %conv164, i32* %imm166, align 4
  %159 = load i64, i64* %addr, align 8
  %shr = lshr i64 %159, 32
  %conv167 = trunc i64 %shr to i32
  %160 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx168 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %160, i64 1
  %imm169 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx168, i32 0, i32 3
  store i32 %conv167, i32* %imm169, align 4
  store i32 0, i32* %j, align 4
  br label %for.cond170

for.cond170:                                      ; preds = %for.inc, %if.end163
  %161 = load i32, i32* %j, align 4
  %162 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %162, i32 0, i32 13
  %163 = load i32, i32* %used_map_cnt, align 8
  %cmp171 = icmp ult i32 %161, %163
  br i1 %cmp171, label %for.body173, label %for.end

for.body173:                                      ; preds = %for.cond170
  %164 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %164, i32 0, i32 11
  %165 = load i32, i32* %j, align 4
  %idxprom174 = sext i32 %165 to i64
  %arrayidx175 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps, i64 0, i64 %idxprom174
  %166 = load %struct.bpf_map*, %struct.bpf_map** %arrayidx175, align 8
  %167 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %cmp176 = icmp eq %struct.bpf_map* %166, %167
  br i1 %cmp176, label %if.then178, label %if.end179

if.then178:                                       ; preds = %for.body173
  %168 = load i32, i32* %j, align 4
  %169 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %170 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %169, i32 0, i32 0
  %171 = bitcast %union.anon.210* %170 to %struct.anon.211*
  %map_index = getelementptr inbounds %struct.anon.211, %struct.anon.211* %171, i32 0, i32 0
  store i32 %168, i32* %map_index, align 8
  %172 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %173 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %172, i32 0, i32 0
  %174 = load %struct.file*, %struct.file** %173, align 8
  %175 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %172, i32 0, i32 1
  %176 = load i32, i32* %175, align 8
  call void @fdput(%struct.file* %174, i32 %176) #20
  br label %next_insn

if.end179:                                        ; preds = %for.body173
  br label %for.inc

for.inc:                                          ; preds = %if.end179
  %177 = load i32, i32* %j, align 4
  %inc = add i32 %177, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond170, !llvm.loop !24

for.end:                                          ; preds = %for.cond170
  %178 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt180 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %178, i32 0, i32 13
  %179 = load i32, i32* %used_map_cnt180, align 8
  %cmp181 = icmp uge i32 %179, 64
  br i1 %cmp181, label %if.then183, label %if.end184

if.then183:                                       ; preds = %for.end
  %180 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %181 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %180, i32 0, i32 0
  %182 = load %struct.file*, %struct.file** %181, align 8
  %183 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %180, i32 0, i32 1
  %184 = load i32, i32* %183, align 8
  call void @fdput(%struct.file* %182, i32 %184) #20
  store i32 -7, i32* %retval, align 4
  br label %return

if.end184:                                        ; preds = %for.end
  %185 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  call void @bpf_map_inc(%struct.bpf_map* noundef %185) #20
  %186 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt185 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %186, i32 0, i32 13
  %187 = load i32, i32* %used_map_cnt185, align 8
  %188 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %189 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %188, i32 0, i32 0
  %190 = bitcast %union.anon.210* %189 to %struct.anon.211*
  %map_index186 = getelementptr inbounds %struct.anon.211, %struct.anon.211* %190, i32 0, i32 0
  store i32 %187, i32* %map_index186, align 8
  %191 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %192 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps187 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %192, i32 0, i32 11
  %193 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt188 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %193, i32 0, i32 13
  %194 = load i32, i32* %used_map_cnt188, align 8
  %inc189 = add i32 %194, 1
  store i32 %inc189, i32* %used_map_cnt188, align 8
  %idxprom190 = zext i32 %194 to i64
  %arrayidx191 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps187, i64 0, i64 %idxprom190
  store %struct.bpf_map* %191, %struct.bpf_map** %arrayidx191, align 8
  %195 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call192 = call zeroext i1 @bpf_map_is_cgroup_storage(%struct.bpf_map* noundef %195) #20
  br i1 %call192, label %land.lhs.true194, label %if.end200

land.lhs.true194:                                 ; preds = %if.end184
  %196 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog195 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %196, i32 0, i32 2
  %197 = load %struct.bpf_prog*, %struct.bpf_prog** %prog195, align 8
  %aux196 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %197, i32 0, i32 10
  %198 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux196, align 8
  %199 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call197 = call i32 @bpf_cgroup_storage_assign(%struct.bpf_prog_aux* noundef %198, %struct.bpf_map* noundef %199) #20
  %tobool198 = icmp ne i32 %call197, 0
  br i1 %tobool198, label %if.then199, label %if.end200

if.then199:                                       ; preds = %land.lhs.true194
  %200 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %201 = bitcast %struct.bpf_verifier_env* %200 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %201, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.268, i64 0, i64 0)) #20
  %202 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %203 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %202, i32 0, i32 0
  %204 = load %struct.file*, %struct.file** %203, align 8
  %205 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %202, i32 0, i32 1
  %206 = load i32, i32* %205, align 8
  call void @fdput(%struct.file* %204, i32 %206) #20
  store i32 -16, i32* %retval, align 4
  br label %return

if.end200:                                        ; preds = %land.lhs.true194, %if.end184
  %207 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %208 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %207, i32 0, i32 0
  %209 = load %struct.file*, %struct.file** %208, align 8
  %210 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %207, i32 0, i32 1
  %211 = load i32, i32* %210, align 8
  call void @fdput(%struct.file* %209, i32 %211) #20
  br label %next_insn

next_insn:                                        ; preds = %if.end200, %if.then178, %if.then75, %if.end66, %if.then52
  %212 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %212, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  %213 = load i32, i32* %i, align 4
  %inc201 = add i32 %213, 1
  store i32 %inc201, i32* %i, align 4
  br label %for.inc209

if.end202:                                        ; preds = %if.end13
  %214 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code203 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %214, i32 0, i32 0
  %215 = load i8, i8* %code203, align 4
  %call204 = call zeroext i1 @bpf_opcode_in_insntable(i8 noundef zeroext %215) #20
  br i1 %call204, label %if.end208, label %if.then205

if.then205:                                       ; preds = %if.end202
  %216 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %217 = bitcast %struct.bpf_verifier_env* %216 to i8*
  %218 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code206 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %218, i32 0, i32 0
  %219 = load i8, i8* %code206, align 4
  %conv207 = zext i8 %219 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %217, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.269, i64 0, i64 0), i32 noundef %conv207) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end208:                                        ; preds = %if.end202
  br label %for.inc209

for.inc209:                                       ; preds = %if.end208, %next_insn
  %220 = load i32, i32* %i, align 4
  %inc210 = add i32 %220, 1
  store i32 %inc210, i32* %i, align 4
  %221 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr211 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %221, i32 1
  store %struct.bpf_insn* %incdec.ptr211, %struct.bpf_insn** %insn, align 8
  br label %for.cond, !llvm.loop !25

for.end212:                                       ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end212, %if.then205, %if.then199, %if.then183, %if.then160, %if.then154, %if.then151, %if.then125, %if.then116, %if.then107, %if.then99, %sw.default, %if.then65, %if.then43, %if.then12, %if.then
  %222 = load i32, i32* %retval, align 4
  ret i32 %222
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_prog_aux*, align 8
  store %struct.bpf_prog_aux* %aux, %struct.bpf_prog_aux** %aux.addr, align 8
  %0 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux.addr, align 8
  %offload_requested = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %0, i32 0, i32 22
  %1 = load i8, i8* %offload_requested, align 1
  %tobool = trunc i8 %1 to i1
  ret i1 %tobool
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_offload_verifier_prep(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_cfg(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_cnt = alloca i32, align 4
  %insn_stack = alloca i32*, align 8
  %insn_state = alloca i32*, align 8
  %ret = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 4
  %2 = load i32, i32* %len, align 4
  store i32 %2, i32* %insn_cnt, align 4
  store i32 0, i32* %ret, align 4
  %3 = load i32, i32* %insn_cnt, align 4
  %conv = sext i32 %3 to i64
  %call = call noalias i8* @kvcalloc(i64 noundef %conv, i64 noundef 4, i32 noundef 3264) #25
  %4 = bitcast i8* %call to i32*
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 29
  %insn_state1 = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg, i32 0, i32 0
  store i32* %4, i32** %insn_state1, align 8
  store i32* %4, i32** %insn_state, align 8
  %6 = load i32*, i32** %insn_state, align 8
  %tobool = icmp ne i32* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i32, i32* %insn_cnt, align 4
  %conv2 = sext i32 %7 to i64
  %call3 = call noalias i8* @kvcalloc(i64 noundef %conv2, i64 noundef 4, i32 noundef 3264) #25
  %8 = bitcast i8* %call3 to i32*
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 29
  %insn_stack5 = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg4, i32 0, i32 1
  store i32* %8, i32** %insn_stack5, align 8
  store i32* %8, i32** %insn_stack, align 8
  %10 = load i32*, i32** %insn_stack, align 8
  %tobool6 = icmp ne i32* %10, null
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end
  %11 = load i32*, i32** %insn_state, align 8
  %12 = bitcast i32* %11 to i8*
  call void @kvfree(i8* noundef %12) #20
  store i32 -12, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %13 = load i32*, i32** %insn_state, align 8
  %arrayidx = getelementptr i32, i32* %13, i64 0
  store i32 16, i32* %arrayidx, align 4
  %14 = load i32*, i32** %insn_stack, align 8
  %arrayidx9 = getelementptr i32, i32* %14, i64 0
  store i32 0, i32* %arrayidx9, align 4
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 29
  %cur_stack = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg10, i32 0, i32 2
  store i32 1, i32* %cur_stack, align 8
  br label %while.cond

while.cond:                                       ; preds = %sw.epilog, %if.end8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 29
  %cur_stack12 = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg11, i32 0, i32 2
  %17 = load i32, i32* %cur_stack12, align 8
  %cmp = icmp sgt i32 %17, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %18 = load i32*, i32** %insn_stack, align 8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg14 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 29
  %cur_stack15 = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg14, i32 0, i32 2
  %20 = load i32, i32* %cur_stack15, align 8
  %sub = sub i32 %20, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx16 = getelementptr i32, i32* %18, i64 %idxprom
  %21 = load i32, i32* %arrayidx16, align 4
  store i32 %21, i32* %t, align 4
  %22 = load i32, i32* %t, align 4
  %23 = load i32, i32* %insn_cnt, align 4
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call17 = call i32 @visit_insn(i32 noundef %22, i32 noundef %23, %struct.bpf_verifier_env* noundef %24) #20
  store i32 %call17, i32* %ret, align 4
  %25 = load i32, i32* %ret, align 4
  switch i32 %25, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb22
  ]

sw.bb:                                            ; preds = %while.body
  %26 = load i32*, i32** %insn_state, align 8
  %27 = load i32, i32* %t, align 4
  %idxprom18 = sext i32 %27 to i64
  %arrayidx19 = getelementptr i32, i32* %26, i64 %idxprom18
  store i32 32, i32* %arrayidx19, align 4
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg20 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 29
  %cur_stack21 = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg20, i32 0, i32 2
  %29 = load i32, i32* %cur_stack21, align 8
  %dec = add i32 %29, -1
  store i32 %dec, i32* %cur_stack21, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %while.body
  br label %sw.epilog

sw.default:                                       ; preds = %while.body
  %30 = load i32, i32* %ret, align 4
  %cmp23 = icmp sgt i32 %30, 0
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %sw.default
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = bitcast %struct.bpf_verifier_env* %31 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %32, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.284, i64 0, i64 0)) #20
  store i32 -14, i32* %ret, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %sw.default
  br label %err_free

sw.epilog:                                        ; preds = %sw.bb22, %sw.bb
  br label %while.cond, !llvm.loop !26

while.end:                                        ; preds = %while.cond
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 29
  %cur_stack28 = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg27, i32 0, i32 2
  %34 = load i32, i32* %cur_stack28, align 8
  %cmp29 = icmp slt i32 %34, 0
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %while.end
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.285, i64 0, i64 0)) #20
  store i32 -14, i32* %ret, align 4
  br label %err_free

if.end32:                                         ; preds = %while.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end32
  %37 = load i32, i32* %i, align 4
  %38 = load i32, i32* %insn_cnt, align 4
  %cmp33 = icmp slt i32 %37, %38
  br i1 %cmp33, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %39 = load i32*, i32** %insn_state, align 8
  %40 = load i32, i32* %i, align 4
  %idxprom35 = sext i32 %40 to i64
  %arrayidx36 = getelementptr i32, i32* %39, i64 %idxprom35
  %41 = load i32, i32* %arrayidx36, align 4
  %cmp37 = icmp ne i32 %41, 32
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %for.body
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %43 = bitcast %struct.bpf_verifier_env* %42 to i8*
  %44 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %43, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.286, i64 0, i64 0), i32 noundef %44) #20
  store i32 -22, i32* %ret, align 4
  br label %err_free

if.end40:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end40
  %45 = load i32, i32* %i, align 4
  %inc = add i32 %45, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !27

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %ret, align 4
  br label %err_free

err_free:                                         ; preds = %for.end, %if.then39, %if.then31, %if.end26
  %46 = load i32*, i32** %insn_state, align 8
  %47 = bitcast i32* %46 to i8*
  call void @kvfree(i8* noundef %47) #20
  %48 = load i32*, i32** %insn_stack, align 8
  %49 = bitcast i32* %48 to i8*
  call void @kvfree(i8* noundef %49) #20
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg41 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %50, i32 0, i32 29
  %insn_stack42 = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg41, i32 0, i32 1
  store i32* null, i32** %insn_stack42, align 8
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg43 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %51, i32 0, i32 29
  %insn_state44 = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg43, i32 0, i32 0
  store i32* null, i32** %insn_state44, align 8
  %52 = load i32, i32* %ret, align 4
  store i32 %52, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free, %if.then7, %if.then
  %53 = load i32, i32* %retval, align 4
  ret i32 %53
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux = alloca %struct.bpf_prog_aux*, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1, align 8
  store %struct.bpf_prog_aux* %2, %struct.bpf_prog_aux** %aux, align 8
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 51
  %4 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info, align 8
  %tobool = icmp ne %struct.bpf_func_info* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, i32* %i, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 31
  %7 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %5, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_aux = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %8, i32 0, i32 52
  %9 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %10 = load i32, i32* %i, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %9, i64 %idxprom
  %linkage = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx, i32 0, i32 0
  %11 = load i16, i16* %linkage, align 2
  %conv = zext i16 %11 to i32
  %cmp2 = icmp ne i32 %conv, 1
  br i1 %cmp2, label %if.then4, label %if.end5

if.then4:                                         ; preds = %for.body
  br label %for.inc

if.end5:                                          ; preds = %for.body
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 27
  %13 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom6
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx7, i32 0, i32 0
  %14 = load i32, i32* %start, align 8
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 0
  store i32 %14, i32* %insn_idx, align 8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx8 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 0
  %17 = load i32, i32* %insn_idx8, align 8
  %cmp9 = icmp eq i32 %17, 0
  %lnot = xor i1 %cmp9, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %18 = load i32, i32* %__ret_warn_on, align 4
  %tobool12 = icmp ne i32 %18, 0
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %tobool18 = icmp ne i64 %conv17, 0
  br i1 %tobool18, label %if.then19, label %if.end26

if.then19:                                        ; preds = %if.end5
  br label %do.body

do.body:                                          ; preds = %if.then19
  store i32 2307, i32* %__flags, align 4
  br label %do.body20

do.body20:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body20
  br label %do.body21

do.body21:                                        ; preds = %do.end
  %19 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 16644, i32 %19, i64 12) #19, !srcloc !28
  br label %do.end22

do.end22:                                         ; preds = %do.body21
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  br label %do.end24

do.end24:                                         ; preds = %do.body23
  br label %do.end25

do.end25:                                         ; preds = %do.end24
  br label %if.end26

if.end26:                                         ; preds = %do.end25, %if.end5
  %20 = load i32, i32* %__ret_warn_on, align 4
  %tobool27 = icmp ne i32 %20, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  store i64 %conv32, i64* %tmp, align 8
  %21 = load i64, i64* %tmp, align 8
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load i32, i32* %i, align 4
  %call = call i32 @do_check_common(%struct.bpf_verifier_env* noundef %22, i32 noundef %23) #20
  store i32 %call, i32* %ret, align 4
  %24 = load i32, i32* %ret, align 4
  %tobool33 = icmp ne i32 %24, 0
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.end26
  %25 = load i32, i32* %ret, align 4
  store i32 %25, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end26
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %27 = load i32, i32* %level, align 8
  %and = and i32 %27, 3
  %tobool35 = icmp ne i32 %and, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  %30 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.289, i64 0, i64 0), i32 noundef %30) #20
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %if.else
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  br label %for.inc

for.inc:                                          ; preds = %if.end38, %if.then4
  %31 = load i32, i32* %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !29

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then34, %if.then
  %32 = load i32, i32* %retval, align 4
  ret i32 %32
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check_main(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ret = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 0
  store i32 0, i32* %insn_idx, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @do_check_common(%struct.bpf_verifier_env* noundef %1, i32 noundef 0) #20
  store i32 %call, i32* %ret, align 4
  %2 = load i32, i32* %ret, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 27
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %4 = load i16, i16* %stack_depth, align 8
  %conv = zext i16 %4 to i32
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 10
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %stack_depth1 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 6
  store i32 %conv, i32* %stack_depth1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i32, i32* %ret, align 4
  ret i32 %8
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_offload_finalize(%struct.bpf_verifier_env* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @kvfree(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_max_stack_depth(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %depth = alloca i32, align 4
  %frame = alloca i32, align 4
  %idx = alloca i32, align 4
  %i = alloca i32, align 4
  %subprog_end = alloca i32, align 4
  %subprog = alloca %struct.bpf_subprog_info*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %tail_call_reachable = alloca i8, align 1
  %ret_insn = alloca [8 x i32], align 16
  %ret_prog = alloca [8 x i32], align 16
  %j = alloca i32, align 4
  %__UNIQUE_ID___x561 = alloca i32, align 4
  %__UNIQUE_ID___y562 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %next_insn = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_cond = alloca i8, align 1
  %__ret_once = alloca i8, align 1
  %tmp50 = alloca i64, align 8
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp80 = alloca i64, align 8
  %tmp88 = alloca i64, align 8
  %__UNIQUE_ID___x563 = alloca i32, align 4
  %__UNIQUE_ID___y564 = alloca i32, align 4
  %tmp148 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 0, i32* %depth, align 4
  store i32 0, i32* %frame, align 4
  store i32 0, i32* %idx, align 4
  store i32 0, i32* %i, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %subprog, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 12
  %4 = bitcast %union.anon.198* %3 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %4, i32 0, i32 1
  %arraydecay1 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay1, %struct.bpf_insn** %insn, align 8
  store i8 0, i8* %tail_call_reachable, align 1
  br label %process_func

process_func:                                     ; preds = %if.end116, %entry
  %5 = load i32, i32* %idx, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %process_func
  %6 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %7 = load i32, i32* %idx, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %6, i64 %idxprom
  %has_tail_call = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 3
  %8 = load i8, i8* %has_tail_call, align 2
  %tobool2 = trunc i8 %8 to i1
  br i1 %tobool2, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %9 = load i32, i32* %depth, align 4
  %cmp = icmp sge i32 %9, 256
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true3
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load i32, i32* %depth, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([86 x i8], [86 x i8]* @.str.494, i64 0, i64 0), i32 noundef %12) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %process_func
  %13 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %14 = load i32, i32* %idx, align 4
  %idxprom4 = sext i32 %14 to i64
  %arrayidx5 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %13, i64 %idxprom4
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx5, i32 0, i32 2
  %15 = load i16, i16* %stack_depth, align 4
  %conv = zext i16 %15 to i32
  store i32 %conv, i32* %__UNIQUE_ID___x561, align 4
  store i32 1, i32* %__UNIQUE_ID___y562, align 4
  %16 = load i32, i32* %__UNIQUE_ID___x561, align 4
  %17 = load i32, i32* %__UNIQUE_ID___y562, align 4
  %cmp6 = icmp ugt i32 %16, %17
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %18 = load i32, i32* %__UNIQUE_ID___x561, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %19 = load i32, i32* %__UNIQUE_ID___y562, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %18, %cond.true ], [ %19, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %20 = load i32, i32* %tmp, align 4
  %sub = sub i32 %20, 1
  %or = or i32 %sub, 31
  %add = add i32 %or, 1
  %21 = load i32, i32* %depth, align 4
  %add8 = add i32 %21, %add
  store i32 %add8, i32* %depth, align 4
  %22 = load i32, i32* %depth, align 4
  %cmp9 = icmp sgt i32 %22, 512
  br i1 %cmp9, label %if.then11, label %if.end13

if.then11:                                        ; preds = %cond.end
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  %25 = load i32, i32* %frame, align 4
  %add12 = add i32 %25, 1
  %26 = load i32, i32* %depth, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.495, i64 0, i64 0), i32 noundef %add12, i32 noundef %26) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %cond.end
  br label %continue_func

continue_func:                                    ; preds = %cond.end153, %if.end13
  %27 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %28 = load i32, i32* %idx, align 4
  %add14 = add i32 %28, 1
  %idxprom15 = sext i32 %add14 to i64
  %arrayidx16 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %27, i64 %idxprom15
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx16, i32 0, i32 0
  %29 = load i32, i32* %start, align 4
  store i32 %29, i32* %subprog_end, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %continue_func
  %30 = load i32, i32* %i, align 4
  %31 = load i32, i32* %subprog_end, align 4
  %cmp17 = icmp slt i32 %30, %31
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %33 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %33 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %32, i64 %idx.ext
  %call = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %add.ptr) #20
  br i1 %call, label %if.end24, label %land.lhs.true19

land.lhs.true19:                                  ; preds = %for.body
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %35 = load i32, i32* %i, align 4
  %idx.ext20 = sext i32 %35 to i64
  %add.ptr21 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %34, i64 %idx.ext20
  %call22 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %add.ptr21) #20
  br i1 %call22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %land.lhs.true19
  br label %for.inc

if.end24:                                         ; preds = %land.lhs.true19, %for.body
  %36 = load i32, i32* %i, align 4
  %add25 = add i32 %36, 1
  %37 = load i32, i32* %frame, align 4
  %idxprom26 = sext i32 %37 to i64
  %arrayidx27 = getelementptr [8 x i32], [8 x i32]* %ret_insn, i64 0, i64 %idxprom26
  store i32 %add25, i32* %arrayidx27, align 4
  %38 = load i32, i32* %idx, align 4
  %39 = load i32, i32* %frame, align 4
  %idxprom28 = sext i32 %39 to i64
  %arrayidx29 = getelementptr [8 x i32], [8 x i32]* %ret_prog, i64 0, i64 %idxprom28
  store i32 %38, i32* %arrayidx29, align 4
  %40 = load i32, i32* %i, align 4
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %42 = load i32, i32* %i, align 4
  %idxprom30 = sext i32 %42 to i64
  %arrayidx31 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %41, i64 %idxprom30
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx31, i32 0, i32 3
  %43 = load i32, i32* %imm, align 4
  %add32 = add i32 %40, %43
  %add33 = add i32 %add32, 1
  store i32 %add33, i32* %next_insn, align 4
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load i32, i32* %next_insn, align 4
  %call34 = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %44, i32 noundef %45) #20
  store i32 %call34, i32* %idx, align 4
  %46 = load i32, i32* %idx, align 4
  %cmp35 = icmp slt i32 %46, 0
  br i1 %cmp35, label %if.then37, label %if.end95

if.then37:                                        ; preds = %if.end24
  store i8 1, i8* %__ret_do_once, align 1
  %47 = load i8, i8* %__ret_do_once, align 1
  %tobool38 = trunc i8 %47 to i1
  %lnot = xor i1 %tobool38, true
  %lnot39 = xor i1 %lnot, true
  %frombool = zext i1 %lnot39 to i8
  store i8 %frombool, i8* %__ret_cond, align 1
  store i8 0, i8* %__ret_once, align 1
  %48 = load i8, i8* %__ret_cond, align 1
  %tobool40 = trunc i8 %48 to i1
  br i1 %tobool40, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then37
  %49 = load i8, i8* @check_max_stack_depth.__already_done, align 1
  %tobool42 = trunc i8 %49 to i1
  %lnot43 = xor i1 %tobool42, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then37
  %50 = phi i1 [ false, %if.then37 ], [ %lnot43, %land.rhs ]
  %lnot44 = xor i1 %50, true
  %lnot45 = xor i1 %lnot44, true
  %lnot.ext = zext i1 %lnot45 to i32
  %conv46 = sext i32 %lnot.ext to i64
  %tobool47 = icmp ne i64 %conv46, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %land.end
  store i8 1, i8* @check_max_stack_depth.__already_done, align 1
  store i8 1, i8* %__ret_once, align 1
  br label %if.end49

if.end49:                                         ; preds = %if.then48, %land.end
  %51 = load i8, i8* %__ret_once, align 1
  %tobool51 = trunc i8 %51 to i1
  %lnot52 = xor i1 %tobool51, true
  %lnot54 = xor i1 %lnot52, true
  %lnot.ext55 = zext i1 %lnot54 to i32
  %conv56 = sext i32 %lnot.ext55 to i64
  store i64 %conv56, i64* %tmp50, align 8
  %52 = load i64, i64* %tmp50, align 8
  %tobool57 = icmp ne i64 %52, 0
  br i1 %tobool57, label %if.then58, label %if.end87

if.then58:                                        ; preds = %if.end49
  store i32 1, i32* %__ret_warn_on, align 4
  %53 = load i32, i32* %__ret_warn_on, align 4
  %tobool59 = icmp ne i32 %53, 0
  %lnot60 = xor i1 %tobool59, true
  %lnot62 = xor i1 %lnot60, true
  %lnot.ext63 = zext i1 %lnot62 to i32
  %conv64 = sext i32 %lnot.ext63 to i64
  %tobool65 = icmp ne i64 %conv64, 0
  br i1 %tobool65, label %if.then66, label %if.end79

if.then66:                                        ; preds = %if.then58
  br label %do.body

do.body:                                          ; preds = %if.then66
  br label %do.body67

do.body67:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body67
  %54 = load i32, i32* %next_insn, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.350, i64 0, i64 0), i32 noundef %54) #20
  br label %do.body68

do.body68:                                        ; preds = %do.end
  store i32 2313, i32* %__flags, align 4
  br label %do.body69

do.body69:                                        ; preds = %do.body68
  br label %do.end70

do.end70:                                         ; preds = %do.body69
  br label %do.body71

do.body71:                                        ; preds = %do.end70
  %55 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 4383, i32 %55, i64 12) #19, !srcloc !30
  br label %do.end72

do.end72:                                         ; preds = %do.body71
  br label %do.body73

do.body73:                                        ; preds = %do.end72
  br label %do.end74

do.end74:                                         ; preds = %do.body73
  br label %do.end75

do.end75:                                         ; preds = %do.end74
  br label %do.body76

do.body76:                                        ; preds = %do.end75
  br label %do.end77

do.end77:                                         ; preds = %do.body76
  br label %do.end78

do.end78:                                         ; preds = %do.end77
  br label %if.end79

if.end79:                                         ; preds = %do.end78, %if.then58
  %56 = load i32, i32* %__ret_warn_on, align 4
  %tobool81 = icmp ne i32 %56, 0
  %lnot82 = xor i1 %tobool81, true
  %lnot84 = xor i1 %lnot82, true
  %lnot.ext85 = zext i1 %lnot84 to i32
  %conv86 = sext i32 %lnot.ext85 to i64
  store i64 %conv86, i64* %tmp80, align 8
  %57 = load i64, i64* %tmp80, align 8
  br label %if.end87

if.end87:                                         ; preds = %if.end79, %if.end49
  %58 = load i8, i8* %__ret_do_once, align 1
  %tobool89 = trunc i8 %58 to i1
  %lnot90 = xor i1 %tobool89, true
  %lnot92 = xor i1 %lnot90, true
  %lnot.ext93 = zext i1 %lnot92 to i32
  %conv94 = sext i32 %lnot.ext93 to i64
  store i64 %conv94, i64* %tmp88, align 8
  %59 = load i64, i64* %tmp88, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end95:                                         ; preds = %if.end24
  %60 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %61 = load i32, i32* %idx, align 4
  %idxprom96 = sext i32 %61 to i64
  %arrayidx97 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %60, i64 %idxprom96
  %is_async_cb = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx97, i32 0, i32 6
  %62 = load i8, i8* %is_async_cb, align 1
  %tobool98 = trunc i8 %62 to i1
  br i1 %tobool98, label %if.then99, label %if.end106

if.then99:                                        ; preds = %if.end95
  %63 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %64 = load i32, i32* %idx, align 4
  %idxprom100 = sext i32 %64 to i64
  %arrayidx101 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %63, i64 %idxprom100
  %has_tail_call102 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx101, i32 0, i32 3
  %65 = load i8, i8* %has_tail_call102, align 2
  %tobool103 = trunc i8 %65 to i1
  br i1 %tobool103, label %if.then104, label %if.end105

if.then104:                                       ; preds = %if.then99
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = bitcast %struct.bpf_verifier_env* %66 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %67, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.496, i64 0, i64 0)) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end105:                                        ; preds = %if.then99
  br label %for.inc

if.end106:                                        ; preds = %if.end95
  %68 = load i32, i32* %next_insn, align 4
  store i32 %68, i32* %i, align 4
  %69 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %70 = load i32, i32* %idx, align 4
  %idxprom107 = sext i32 %70 to i64
  %arrayidx108 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %69, i64 %idxprom107
  %has_tail_call109 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx108, i32 0, i32 3
  %71 = load i8, i8* %has_tail_call109, align 2
  %tobool110 = trunc i8 %71 to i1
  br i1 %tobool110, label %if.then111, label %if.end112

if.then111:                                       ; preds = %if.end106
  store i8 1, i8* %tail_call_reachable, align 1
  br label %if.end112

if.end112:                                        ; preds = %if.then111, %if.end106
  %72 = load i32, i32* %frame, align 4
  %inc = add i32 %72, 1
  store i32 %inc, i32* %frame, align 4
  %73 = load i32, i32* %frame, align 4
  %cmp113 = icmp sge i32 %73, 8
  br i1 %cmp113, label %if.then115, label %if.end116

if.then115:                                       ; preds = %if.end112
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = bitcast %struct.bpf_verifier_env* %74 to i8*
  %76 = load i32, i32* %frame, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %75, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.497, i64 0, i64 0), i32 noundef %76) #20
  store i32 -7, i32* %retval, align 4
  br label %return

if.end116:                                        ; preds = %if.end112
  br label %process_func

for.inc:                                          ; preds = %if.end105, %if.then23
  %77 = load i32, i32* %i, align 4
  %inc117 = add i32 %77, 1
  store i32 %inc117, i32* %i, align 4
  br label %for.cond, !llvm.loop !31

for.end:                                          ; preds = %for.cond
  %78 = load i8, i8* %tail_call_reachable, align 1
  %tobool118 = trunc i8 %78 to i1
  br i1 %tobool118, label %if.then119, label %if.end132

if.then119:                                       ; preds = %for.end
  store i32 0, i32* %j, align 4
  br label %for.cond120

for.cond120:                                      ; preds = %for.inc129, %if.then119
  %79 = load i32, i32* %j, align 4
  %80 = load i32, i32* %frame, align 4
  %cmp121 = icmp slt i32 %79, %80
  br i1 %cmp121, label %for.body123, label %for.end131

for.body123:                                      ; preds = %for.cond120
  %81 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %82 = load i32, i32* %j, align 4
  %idxprom124 = sext i32 %82 to i64
  %arrayidx125 = getelementptr [8 x i32], [8 x i32]* %ret_prog, i64 0, i64 %idxprom124
  %83 = load i32, i32* %arrayidx125, align 4
  %idxprom126 = sext i32 %83 to i64
  %arrayidx127 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %81, i64 %idxprom126
  %tail_call_reachable128 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx127, i32 0, i32 4
  store i8 1, i8* %tail_call_reachable128, align 1
  br label %for.inc129

for.inc129:                                       ; preds = %for.body123
  %84 = load i32, i32* %j, align 4
  %inc130 = add i32 %84, 1
  store i32 %inc130, i32* %j, align 4
  br label %for.cond120, !llvm.loop !32

for.end131:                                       ; preds = %for.cond120
  br label %if.end132

if.end132:                                        ; preds = %for.end131, %for.end
  %85 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %arrayidx133 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %85, i64 0
  %tail_call_reachable134 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx133, i32 0, i32 4
  %86 = load i8, i8* %tail_call_reachable134, align 1
  %tobool135 = trunc i8 %86 to i1
  br i1 %tobool135, label %if.then136, label %if.end139

if.then136:                                       ; preds = %if.end132
  %87 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog137 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %87, i32 0, i32 2
  %88 = load %struct.bpf_prog*, %struct.bpf_prog** %prog137, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %88, i32 0, i32 10
  %89 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %tail_call_reachable138 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %89, i32 0, i32 26
  store i8 1, i8* %tail_call_reachable138, align 1
  br label %if.end139

if.end139:                                        ; preds = %if.then136, %if.end132
  %90 = load i32, i32* %frame, align 4
  %cmp140 = icmp eq i32 %90, 0
  br i1 %cmp140, label %if.then142, label %if.end143

if.then142:                                       ; preds = %if.end139
  store i32 0, i32* %retval, align 4
  br label %return

if.end143:                                        ; preds = %if.end139
  %91 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %92 = load i32, i32* %idx, align 4
  %idxprom144 = sext i32 %92 to i64
  %arrayidx145 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %91, i64 %idxprom144
  %stack_depth146 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx145, i32 0, i32 2
  %93 = load i16, i16* %stack_depth146, align 4
  %conv147 = zext i16 %93 to i32
  store i32 %conv147, i32* %__UNIQUE_ID___x563, align 4
  store i32 1, i32* %__UNIQUE_ID___y564, align 4
  %94 = load i32, i32* %__UNIQUE_ID___x563, align 4
  %95 = load i32, i32* %__UNIQUE_ID___y564, align 4
  %cmp149 = icmp ugt i32 %94, %95
  br i1 %cmp149, label %cond.true151, label %cond.false152

cond.true151:                                     ; preds = %if.end143
  %96 = load i32, i32* %__UNIQUE_ID___x563, align 4
  br label %cond.end153

cond.false152:                                    ; preds = %if.end143
  %97 = load i32, i32* %__UNIQUE_ID___y564, align 4
  br label %cond.end153

cond.end153:                                      ; preds = %cond.false152, %cond.true151
  %cond154 = phi i32 [ %96, %cond.true151 ], [ %97, %cond.false152 ]
  store i32 %cond154, i32* %tmp148, align 4
  %98 = load i32, i32* %tmp148, align 4
  %sub155 = sub i32 %98, 1
  %or156 = or i32 %sub155, 31
  %add157 = add i32 %or156, 1
  %99 = load i32, i32* %depth, align 4
  %sub158 = sub i32 %99, %add157
  store i32 %sub158, i32* %depth, align 4
  %100 = load i32, i32* %frame, align 4
  %dec = add i32 %100, -1
  store i32 %dec, i32* %frame, align 4
  %101 = load i32, i32* %frame, align 4
  %idxprom159 = sext i32 %101 to i64
  %arrayidx160 = getelementptr [8 x i32], [8 x i32]* %ret_insn, i64 0, i64 %idxprom159
  %102 = load i32, i32* %arrayidx160, align 4
  store i32 %102, i32* %i, align 4
  %103 = load i32, i32* %frame, align 4
  %idxprom161 = sext i32 %103 to i64
  %arrayidx162 = getelementptr [8 x i32], [8 x i32]* %ret_prog, i64 0, i64 %idxprom161
  %104 = load i32, i32* %arrayidx162, align 4
  store i32 %104, i32* %idx, align 4
  br label %continue_func

return:                                           ; preds = %if.then142, %if.then115, %if.then104, %if.end87, %if.then11, %if.then
  %105 = load i32, i32* %retval, align 4
  ret i32 %105
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @optimize_bpf_loop(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %subprogs = alloca %struct.bpf_subprog_info*, align 8
  %i = alloca i32, align 4
  %cur_subprog = alloca i32, align 4
  %cnt = alloca i32, align 4
  %delta = alloca i32, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %stack_depth = alloca i16, align 2
  %stack_depth_roundup = alloca i16, align 2
  %stack_depth_extra = alloca i16, align 2
  %inline_state = alloca %struct.bpf_loop_inline_state*, align 8
  %new_prog = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %subprogs, align 8
  store i32 0, i32* %cur_subprog, align 4
  store i32 0, i32* %delta, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 12
  %4 = bitcast %union.anon.198* %3 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %4, i32 0, i32 1
  %arraydecay1 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay1, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 4
  %7 = load i32, i32* %len, align 4
  store i32 %7, i32* %insn_cnt, align 4
  %8 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprogs, align 8
  %9 = load i32, i32* %cur_subprog, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %8, i64 %idxprom
  %stack_depth3 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %10 = load i16, i16* %stack_depth3, align 4
  store i16 %10, i16* %stack_depth, align 2
  %11 = load i16, i16* %stack_depth, align 2
  %conv = zext i16 %11 to i32
  %sub = sub i32 %conv, 1
  %or = or i32 %sub, 7
  %add = add i32 %or, 1
  %12 = load i16, i16* %stack_depth, align 2
  %conv4 = zext i16 %12 to i32
  %sub5 = sub i32 %add, %conv4
  %conv6 = trunc i32 %sub5 to i16
  store i16 %conv6, i16* %stack_depth_roundup, align 2
  store i16 0, i16* %stack_depth_extra, align 2
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %13, %14
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 24
  %16 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %17 = load i32, i32* %i, align 4
  %18 = load i32, i32* %delta, align 4
  %add8 = add i32 %17, %18
  %idxprom9 = sext i32 %add8 to i64
  %arrayidx10 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %16, i64 %idxprom9
  %19 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx10, i32 0, i32 0
  %loop_inline_state = bitcast %union.anon.210* %19 to %struct.bpf_loop_inline_state*
  store %struct.bpf_loop_inline_state* %loop_inline_state, %struct.bpf_loop_inline_state** %inline_state, align 8
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call = call zeroext i1 @is_bpf_loop_call(%struct.bpf_insn* noundef %20) #20
  br i1 %call, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %for.body
  %21 = load %struct.bpf_loop_inline_state*, %struct.bpf_loop_inline_state** %inline_state, align 8
  %22 = bitcast %struct.bpf_loop_inline_state* %21 to i8*
  %bf.load = load i8, i8* %22, align 4
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end30

if.then:                                          ; preds = %land.lhs.true
  %23 = load i16, i16* %stack_depth_roundup, align 2
  %conv12 = zext i16 %23 to i32
  %add13 = add i32 24, %conv12
  %conv14 = trunc i32 %add13 to i16
  store i16 %conv14, i16* %stack_depth_extra, align 2
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load i32, i32* %i, align 4
  %26 = load i32, i32* %delta, align 4
  %add15 = add i32 %25, %26
  %27 = load i16, i16* %stack_depth, align 2
  %conv16 = zext i16 %27 to i32
  %28 = load i16, i16* %stack_depth_extra, align 2
  %conv17 = zext i16 %28 to i32
  %add18 = add i32 %conv16, %conv17
  %sub19 = sub i32 0, %add18
  %29 = load %struct.bpf_loop_inline_state*, %struct.bpf_loop_inline_state** %inline_state, align 8
  %callback_subprogno = getelementptr inbounds %struct.bpf_loop_inline_state, %struct.bpf_loop_inline_state* %29, i32 0, i32 1
  %30 = load i32, i32* %callback_subprogno, align 4
  %call20 = call %struct.bpf_prog* @inline_bpf_loop(%struct.bpf_verifier_env* noundef %24, i32 noundef %add15, i32 noundef %sub19, i32 noundef %30, i32* noundef %cnt) #20
  store %struct.bpf_prog* %call20, %struct.bpf_prog** %new_prog, align 8
  %31 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool21 = icmp ne %struct.bpf_prog* %31, null
  br i1 %tobool21, label %if.end, label %if.then22

if.then22:                                        ; preds = %if.then
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %32 = load i32, i32* %cnt, align 4
  %sub23 = sub i32 %32, 1
  %33 = load i32, i32* %delta, align 4
  %add24 = add i32 %33, %sub23
  store i32 %add24, i32* %delta, align 4
  %34 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog25 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 2
  store %struct.bpf_prog* %34, %struct.bpf_prog** %prog25, align 8
  %36 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %37 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %36, i32 0, i32 12
  %38 = bitcast %union.anon.198* %37 to %struct.anon.201*
  %insnsi26 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %38, i32 0, i32 1
  %arraydecay27 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi26, i64 0, i64 0
  %39 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %39 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay27, i64 %idx.ext
  %40 = load i32, i32* %delta, align 4
  %idx.ext28 = sext i32 %40 to i64
  %add.ptr29 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr, i64 %idx.ext28
  store %struct.bpf_insn* %add.ptr29, %struct.bpf_insn** %insn, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.end, %land.lhs.true, %for.body
  %41 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprogs, align 8
  %42 = load i32, i32* %cur_subprog, align 4
  %add31 = add i32 %42, 1
  %idxprom32 = sext i32 %add31 to i64
  %arrayidx33 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %41, i64 %idxprom32
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx33, i32 0, i32 0
  %43 = load i32, i32* %start, align 4
  %44 = load i32, i32* %i, align 4
  %45 = load i32, i32* %delta, align 4
  %add34 = add i32 %44, %45
  %add35 = add i32 %add34, 1
  %cmp36 = icmp eq i32 %43, %add35
  br i1 %cmp36, label %if.then38, label %if.end56

if.then38:                                        ; preds = %if.end30
  %46 = load i16, i16* %stack_depth_extra, align 2
  %conv39 = zext i16 %46 to i32
  %47 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprogs, align 8
  %48 = load i32, i32* %cur_subprog, align 4
  %idxprom40 = sext i32 %48 to i64
  %arrayidx41 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %47, i64 %idxprom40
  %stack_depth42 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx41, i32 0, i32 2
  %49 = load i16, i16* %stack_depth42, align 4
  %conv43 = zext i16 %49 to i32
  %add44 = add i32 %conv43, %conv39
  %conv45 = trunc i32 %add44 to i16
  store i16 %conv45, i16* %stack_depth42, align 4
  %50 = load i32, i32* %cur_subprog, align 4
  %inc = add i32 %50, 1
  store i32 %inc, i32* %cur_subprog, align 4
  %51 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprogs, align 8
  %52 = load i32, i32* %cur_subprog, align 4
  %idxprom46 = sext i32 %52 to i64
  %arrayidx47 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %51, i64 %idxprom46
  %stack_depth48 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx47, i32 0, i32 2
  %53 = load i16, i16* %stack_depth48, align 4
  store i16 %53, i16* %stack_depth, align 2
  %54 = load i16, i16* %stack_depth, align 2
  %conv49 = zext i16 %54 to i32
  %sub50 = sub i32 %conv49, 1
  %or51 = or i32 %sub50, 7
  %add52 = add i32 %or51, 1
  %55 = load i16, i16* %stack_depth, align 2
  %conv53 = zext i16 %55 to i32
  %sub54 = sub i32 %add52, %conv53
  %conv55 = trunc i32 %sub54 to i16
  store i16 %conv55, i16* %stack_depth_roundup, align 2
  store i16 0, i16* %stack_depth_extra, align 2
  br label %if.end56

if.end56:                                         ; preds = %if.then38, %if.end30
  br label %for.inc

for.inc:                                          ; preds = %if.end56
  %56 = load i32, i32* %i, align 4
  %inc57 = add i32 %56, 1
  store i32 %inc57, i32* %i, align 4
  %57 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %57, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond, !llvm.loop !33

for.end:                                          ; preds = %for.cond
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info58 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %58, i32 0, i32 27
  %arrayidx59 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info58, i64 0, i64 0
  %stack_depth60 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx59, i32 0, i32 2
  %59 = load i16, i16* %stack_depth60, align 8
  %conv61 = zext i16 %59 to i32
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog62 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %60, i32 0, i32 2
  %61 = load %struct.bpf_prog*, %struct.bpf_prog** %prog62, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %61, i32 0, i32 10
  %62 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %stack_depth63 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %62, i32 0, i32 6
  store i32 %conv61, i32* %stack_depth63, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then22
  %63 = load i32, i32* %retval, align 4
  ret i32 %63
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @opt_hard_wire_dead_code_branches(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %ja = alloca %struct.bpf_insn, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = bitcast %struct.bpf_insn* %ja to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %2, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.opt_hard_wire_dead_code_branches.ja, i32 0, i32 0), i64 8, i1 false)
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %5 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 12
  %6 = bitcast %union.anon.198* %5 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %6, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 2
  %8 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %8, i32 0, i32 4
  %9 = load i32, i32* %len, align 4
  store i32 %9, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %12, i32 0, i32 0
  %13 = load i8, i8* %code, align 4
  %call = call zeroext i1 @insn_is_cond_jump(i8 noundef zeroext %13) #20
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %14 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %15 = load i32, i32* %i, align 4
  %add = add i32 %15, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %14, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  %16 = load i32, i32* %seen, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.end
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %17, i32 0, i32 2
  %18 = load i16, i16* %off, align 2
  %off3 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %ja, i32 0, i32 2
  store i16 %18, i16* %off3, align 2
  br label %if.end15

if.else:                                          ; preds = %if.end
  %19 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %20 = load i32, i32* %i, align 4
  %add4 = add i32 %20, 1
  %21 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off5 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %21, i32 0, i32 2
  %22 = load i16, i16* %off5, align 2
  %conv = sext i16 %22 to i32
  %add6 = add i32 %add4, %conv
  %idxprom7 = sext i32 %add6 to i64
  %arrayidx8 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %19, i64 %idxprom7
  %seen9 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx8, i32 0, i32 3
  %23 = load i32, i32* %seen9, align 4
  %tobool10 = icmp ne i32 %23, 0
  br i1 %tobool10, label %if.else13, label %if.then11

if.then11:                                        ; preds = %if.else
  %off12 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %ja, i32 0, i32 2
  store i16 0, i16* %off12, align 2
  br label %if.end14

if.else13:                                        ; preds = %if.else
  br label %for.inc

if.end14:                                         ; preds = %if.then11
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then2
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 2
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %prog16, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %25, i32 0, i32 10
  %26 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call17 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %26) #20
  br i1 %call17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load i32, i32* %i, align 4
  call void @bpf_prog_offload_replace_insn(%struct.bpf_verifier_env* noundef %27, i32 noundef %28, %struct.bpf_insn* noundef %ja) #20
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end15
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %30 = bitcast %struct.bpf_insn* %29 to i8*
  %31 = bitcast %struct.bpf_insn* %ja to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %30, i8* align 4 %31, i64 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end19, %if.else13, %if.then
  %32 = load i32, i32* %i, align 4
  %inc = add i32 %32, 1
  store i32 %inc, i32* %i, align 4
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %33, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond, !llvm.loop !34

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @opt_remove_dead_code(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %i, align 4
  %6 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.body
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %j, align 4
  %add = add i32 %7, %8
  %9 = load i32, i32* %insn_cnt, align 4
  %cmp1 = icmp slt i32 %add, %9
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %j, align 4
  %add2 = add i32 %11, %12
  %idxprom = sext i32 %add2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %10, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  %13 = load i32, i32* %seen, align 4
  %tobool = icmp ne i32 %13, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %14 = phi i1 [ false, %while.cond ], [ %lnot, %land.rhs ]
  br i1 %14, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %15 = load i32, i32* %j, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %j, align 4
  br label %while.cond, !llvm.loop !35

while.end:                                        ; preds = %land.end
  %16 = load i32, i32* %j, align 4
  %tobool3 = icmp ne i32 %16, 0
  br i1 %tobool3, label %if.end, label %if.then

if.then:                                          ; preds = %while.end
  br label %for.inc

if.end:                                           ; preds = %while.end
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %i, align 4
  %19 = load i32, i32* %j, align 4
  %call = call i32 @verifier_remove_insns(%struct.bpf_verifier_env* noundef %17, i32 noundef %18, i32 noundef %19) #20
  store i32 %call, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool4 = icmp ne i32 %20, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %21 = load i32, i32* %err, align 4
  store i32 %21, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 2
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %prog7, align 8
  %len8 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %23, i32 0, i32 4
  %24 = load i32, i32* %len8, align 4
  store i32 %24, i32* %insn_cnt, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end6, %if.then
  %25 = load i32, i32* %i, align 4
  %inc9 = add i32 %25, 1
  store i32 %inc9, i32* %i, align 4
  br label %for.cond, !llvm.loop !36

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then5
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @opt_remove_nops(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ja = alloca %struct.bpf_insn, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = bitcast %struct.bpf_insn* %ja to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.opt_remove_nops.ja, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 12
  %4 = bitcast %union.anon.198* %3 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %4, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 4
  %7 = load i32, i32* %len, align 4
  store i32 %7, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, i32* %i, align 4
  %9 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %11 = load i32, i32* %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %10, i64 %idxprom
  %12 = bitcast %struct.bpf_insn* %arrayidx to i8*
  %13 = bitcast %struct.bpf_insn* %ja to i8*
  %call = call i32 @memcmp(i8* noundef %12, i8* noundef %13, i64 noundef 8) #20
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = load i32, i32* %i, align 4
  %call2 = call i32 @verifier_remove_insns(%struct.bpf_verifier_env* noundef %14, i32 noundef %15, i32 noundef 1) #20
  store i32 %call2, i32* %err, align 4
  %16 = load i32, i32* %err, align 4
  %tobool3 = icmp ne i32 %16, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %17 = load i32, i32* %err, align 4
  store i32 %17, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %18 = load i32, i32* %insn_cnt, align 4
  %dec = add i32 %18, -1
  store i32 %dec, i32* %insn_cnt, align 4
  %19 = load i32, i32* %i, align 4
  %dec6 = add i32 %19, -1
  store i32 %dec6, i32* %i, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end5, %if.then
  %20 = load i32, i32* %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !37

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then4
  %21 = load i32, i32* %retval, align 4
  ret i32 %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @sanitize_dead_code(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %trap = alloca %struct.bpf_insn, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = bitcast %struct.bpf_insn* %trap to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %2, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.sanitize_dead_code.trap, i32 0, i32 0), i64 8, i1 false)
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %5 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 12
  %6 = bitcast %union.anon.198* %5 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %6, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 2
  %8 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %8, i32 0, i32 4
  %9 = load i32, i32* %len, align 4
  store i32 %9, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %13 = load i32, i32* %i, align 4
  %idxprom = sext i32 %13 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %12, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  %14 = load i32, i32* %seen, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %16 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %16 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %15, i64 %idx.ext
  %17 = bitcast %struct.bpf_insn* %add.ptr to i8*
  %18 = bitcast %struct.bpf_insn* %trap to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %17, i8* align 4 %18, i64 8, i1 false)
  %19 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %20 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %20 to i64
  %arrayidx3 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %19, i64 %idxprom2
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx3, i32 0, i32 5
  store i8 0, i8* %zext_dst, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !38

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @convert_ctx_accesses(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ops = alloca %struct.bpf_verifier_ops*, align 8
  %i = alloca i32, align 4
  %cnt = alloca i32, align 4
  %size = alloca i32, align 4
  %ctx_field_size = alloca i32, align 4
  %delta = alloca i32, align 4
  %insn_cnt = alloca i32, align 4
  %insn_buf = alloca [16 x %struct.bpf_insn], align 16
  %insn = alloca %struct.bpf_insn*, align 8
  %target_size = alloca i32, align 4
  %size_default = alloca i32, align 4
  %off = alloca i32, align 4
  %new_prog = alloca %struct.bpf_prog*, align 8
  %type = alloca i32, align 4
  %is_narrower_load = alloca i8, align 1
  %convert_ctx_access = alloca i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, align 8
  %ctx_access = alloca i8, align 1
  %patch = alloca [2 x %struct.bpf_insn], align 16
  %__size = alloca i32, align 4
  %bytes = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp206 = alloca i64, align 8
  %tmp213 = alloca i32, align 4
  %size_code = alloca i8, align 1
  %shift = alloca i8, align 1
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %.compoundliteral304 = alloca %struct.bpf_insn, align 4
  %.compoundliteral328 = alloca %struct.bpf_insn, align 4
  %.compoundliteral349 = alloca %struct.bpf_insn, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 3
  %1 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops1, align 8
  store %struct.bpf_verifier_ops* %1, %struct.bpf_verifier_ops** %ops, align 8
  store i32 0, i32* %delta, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  %5 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_prologue = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %5, i32 0, i32 2
  %6 = load i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)** %gen_prologue, align 8
  %tobool = icmp ne i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)* %6, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 23
  %8 = load i8, i8* %seen_direct_write, align 1
  %tobool2 = trunc i8 %8 to i1
  br i1 %tobool2, label %if.then, label %if.end22

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_prologue3 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %9, i32 0, i32 2
  %10 = load i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)** %gen_prologue3, align 8
  %tobool4 = icmp ne i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)* %10, null
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.485, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %13 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_prologue6 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %13, i32 0, i32 2
  %14 = load i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)** %gen_prologue6, align 8
  %arraydecay = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 23
  %16 = load i8, i8* %seen_direct_write7, align 1
  %tobool8 = trunc i8 %16 to i1
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog9 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 2
  %18 = load %struct.bpf_prog*, %struct.bpf_prog** %prog9, align 8
  %call = call i32 %14(%struct.bpf_insn* noundef %arraydecay, i1 noundef zeroext %tobool8, %struct.bpf_prog* noundef %18) #20
  store i32 %call, i32* %cnt, align 4
  %19 = load i32, i32* %cnt, align 4
  %conv = sext i32 %19 to i64
  %cmp = icmp uge i64 %conv, 16
  br i1 %cmp, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.485, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end
  %22 = load i32, i32* %cnt, align 4
  %tobool12 = icmp ne i32 %22, 0
  br i1 %tobool12, label %if.then13, label %if.end20

if.then13:                                        ; preds = %if.else
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %arraydecay14 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %24 = load i32, i32* %cnt, align 4
  %call15 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %23, i32 noundef 0, %struct.bpf_insn* noundef %arraydecay14, i32 noundef %24) #20
  store %struct.bpf_prog* %call15, %struct.bpf_prog** %new_prog, align 8
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool16 = icmp ne %struct.bpf_prog* %25, null
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.then13
  store i32 -12, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.then13
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog19 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 2
  store %struct.bpf_prog* %26, %struct.bpf_prog** %prog19, align 8
  %28 = load i32, i32* %cnt, align 4
  %sub = sub i32 %28, 1
  %29 = load i32, i32* %delta, align 4
  %add = add i32 %29, %sub
  store i32 %add, i32* %delta, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.end18, %if.else
  br label %if.end21

if.end21:                                         ; preds = %if.end20
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %lor.lhs.false
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog23 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 2
  %31 = load %struct.bpf_prog*, %struct.bpf_prog** %prog23, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %31, i32 0, i32 10
  %32 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call24 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %32) #20
  br i1 %call24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end22
  store i32 0, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.end22
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 2
  %34 = load %struct.bpf_prog*, %struct.bpf_prog** %prog27, align 8
  %35 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %34, i32 0, i32 12
  %36 = bitcast %union.anon.198* %35 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %36, i32 0, i32 1
  %arraydecay28 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  %37 = load i32, i32* %delta, align 4
  %idx.ext = sext i32 %37 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay28, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end26
  %38 = load i32, i32* %i, align 4
  %39 = load i32, i32* %insn_cnt, align 4
  %cmp29 = icmp slt i32 %38, %39
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %40, i32 0, i32 0
  %41 = load i8, i8* %code, align 4
  %conv31 = zext i8 %41 to i32
  %cmp32 = icmp eq i32 %conv31, 113
  br i1 %cmp32, label %if.then49, label %lor.lhs.false34

lor.lhs.false34:                                  ; preds = %for.body
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %42, i32 0, i32 0
  %43 = load i8, i8* %code35, align 4
  %conv36 = zext i8 %43 to i32
  %cmp37 = icmp eq i32 %conv36, 105
  br i1 %cmp37, label %if.then49, label %lor.lhs.false39

lor.lhs.false39:                                  ; preds = %lor.lhs.false34
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code40 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 0
  %45 = load i8, i8* %code40, align 4
  %conv41 = zext i8 %45 to i32
  %cmp42 = icmp eq i32 %conv41, 97
  br i1 %cmp42, label %if.then49, label %lor.lhs.false44

lor.lhs.false44:                                  ; preds = %lor.lhs.false39
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code45 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 0
  %47 = load i8, i8* %code45, align 4
  %conv46 = zext i8 %47 to i32
  %cmp47 = icmp eq i32 %conv46, 121
  br i1 %cmp47, label %if.then49, label %if.else50

if.then49:                                        ; preds = %lor.lhs.false44, %lor.lhs.false39, %lor.lhs.false34, %for.body
  store i32 1, i32* %type, align 4
  store i8 1, i8* %ctx_access, align 1
  br label %if.end97

if.else50:                                        ; preds = %lor.lhs.false44
  %48 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code51 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %48, i32 0, i32 0
  %49 = load i8, i8* %code51, align 4
  %conv52 = zext i8 %49 to i32
  %cmp53 = icmp eq i32 %conv52, 115
  br i1 %cmp53, label %if.then90, label %lor.lhs.false55

lor.lhs.false55:                                  ; preds = %if.else50
  %50 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code56 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %50, i32 0, i32 0
  %51 = load i8, i8* %code56, align 4
  %conv57 = zext i8 %51 to i32
  %cmp58 = icmp eq i32 %conv57, 107
  br i1 %cmp58, label %if.then90, label %lor.lhs.false60

lor.lhs.false60:                                  ; preds = %lor.lhs.false55
  %52 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code61 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %52, i32 0, i32 0
  %53 = load i8, i8* %code61, align 4
  %conv62 = zext i8 %53 to i32
  %cmp63 = icmp eq i32 %conv62, 99
  br i1 %cmp63, label %if.then90, label %lor.lhs.false65

lor.lhs.false65:                                  ; preds = %lor.lhs.false60
  %54 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code66 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %54, i32 0, i32 0
  %55 = load i8, i8* %code66, align 4
  %conv67 = zext i8 %55 to i32
  %cmp68 = icmp eq i32 %conv67, 123
  br i1 %cmp68, label %if.then90, label %lor.lhs.false70

lor.lhs.false70:                                  ; preds = %lor.lhs.false65
  %56 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code71 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %56, i32 0, i32 0
  %57 = load i8, i8* %code71, align 4
  %conv72 = zext i8 %57 to i32
  %cmp73 = icmp eq i32 %conv72, 114
  br i1 %cmp73, label %if.then90, label %lor.lhs.false75

lor.lhs.false75:                                  ; preds = %lor.lhs.false70
  %58 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code76 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %58, i32 0, i32 0
  %59 = load i8, i8* %code76, align 4
  %conv77 = zext i8 %59 to i32
  %cmp78 = icmp eq i32 %conv77, 106
  br i1 %cmp78, label %if.then90, label %lor.lhs.false80

lor.lhs.false80:                                  ; preds = %lor.lhs.false75
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code81 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %60, i32 0, i32 0
  %61 = load i8, i8* %code81, align 4
  %conv82 = zext i8 %61 to i32
  %cmp83 = icmp eq i32 %conv82, 98
  br i1 %cmp83, label %if.then90, label %lor.lhs.false85

lor.lhs.false85:                                  ; preds = %lor.lhs.false80
  %62 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code86 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %62, i32 0, i32 0
  %63 = load i8, i8* %code86, align 4
  %conv87 = zext i8 %63 to i32
  %cmp88 = icmp eq i32 %conv87, 122
  br i1 %cmp88, label %if.then90, label %if.else95

if.then90:                                        ; preds = %lor.lhs.false85, %lor.lhs.false80, %lor.lhs.false75, %lor.lhs.false70, %lor.lhs.false65, %lor.lhs.false60, %lor.lhs.false55, %if.else50
  store i32 2, i32* %type, align 4
  %64 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code91 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %64, i32 0, i32 0
  %65 = load i8, i8* %code91, align 4
  %conv92 = zext i8 %65 to i32
  %and = and i32 %conv92, 7
  %cmp93 = icmp eq i32 %and, 3
  %frombool = zext i1 %cmp93 to i8
  store i8 %frombool, i8* %ctx_access, align 1
  br label %if.end96

if.else95:                                        ; preds = %lor.lhs.false85
  br label %for.inc

if.end96:                                         ; preds = %if.then90
  br label %if.end97

if.end97:                                         ; preds = %if.end96, %if.then49
  %66 = load i32, i32* %type, align 4
  %cmp98 = icmp eq i32 %66, 2
  br i1 %cmp98, label %land.lhs.true, label %if.end124

land.lhs.true:                                    ; preds = %if.end97
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %67, i32 0, i32 24
  %68 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %69 = load i32, i32* %i, align 4
  %70 = load i32, i32* %delta, align 4
  %add100 = add i32 %69, %70
  %idxprom = sext i32 %add100 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %68, i64 %idxprom
  %sanitize_stack_spill = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 4
  %71 = load i8, i8* %sanitize_stack_spill, align 8
  %tobool101 = trunc i8 %71 to i1
  br i1 %tobool101, label %if.then103, label %if.end124

if.then103:                                       ; preds = %land.lhs.true
  %arrayinit.begin = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %patch, i64 0, i64 0
  %72 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %73 = bitcast %struct.bpf_insn* %arrayinit.begin to i8*
  %74 = bitcast %struct.bpf_insn* %72 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %73, i8* align 4 %74, i64 8, i1 false)
  %arrayinit.element = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i64 1
  %code104 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 0
  store i8 -62, i8* %code104, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %bf.load105 = load i8, i8* %src_reg, align 1
  %bf.clear106 = and i8 %bf.load105, 15
  %bf.set107 = or i8 %bf.clear106, 0
  store i8 %bf.set107, i8* %src_reg, align 1
  %off108 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 2
  store i16 0, i16* %off108, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  store i32 2, i32* %cnt, align 4
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = load i32, i32* %i, align 4
  %77 = load i32, i32* %delta, align 4
  %add109 = add i32 %76, %77
  %arraydecay110 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %patch, i64 0, i64 0
  %78 = load i32, i32* %cnt, align 4
  %call111 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %75, i32 noundef %add109, %struct.bpf_insn* noundef %arraydecay110, i32 noundef %78) #20
  store %struct.bpf_prog* %call111, %struct.bpf_prog** %new_prog, align 8
  %79 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool112 = icmp ne %struct.bpf_prog* %79, null
  br i1 %tobool112, label %if.end114, label %if.then113

if.then113:                                       ; preds = %if.then103
  store i32 -12, i32* %retval, align 4
  br label %return

if.end114:                                        ; preds = %if.then103
  %80 = load i32, i32* %cnt, align 4
  %sub115 = sub i32 %80, 1
  %81 = load i32, i32* %delta, align 4
  %add116 = add i32 %81, %sub115
  store i32 %add116, i32* %delta, align 4
  %82 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog117 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %83, i32 0, i32 2
  store %struct.bpf_prog* %82, %struct.bpf_prog** %prog117, align 8
  %84 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %85 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %84, i32 0, i32 12
  %86 = bitcast %union.anon.198* %85 to %struct.anon.201*
  %insnsi118 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %86, i32 0, i32 1
  %arraydecay119 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi118, i64 0, i64 0
  %87 = load i32, i32* %i, align 4
  %idx.ext120 = sext i32 %87 to i64
  %add.ptr121 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay119, i64 %idx.ext120
  %88 = load i32, i32* %delta, align 4
  %idx.ext122 = sext i32 %88 to i64
  %add.ptr123 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr121, i64 %idx.ext122
  store %struct.bpf_insn* %add.ptr123, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end124:                                        ; preds = %land.lhs.true, %if.end97
  %89 = load i8, i8* %ctx_access, align 1
  %tobool125 = trunc i8 %89 to i1
  br i1 %tobool125, label %if.end127, label %if.then126

if.then126:                                       ; preds = %if.end124
  br label %for.inc

if.end127:                                        ; preds = %if.end124
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data128 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %90, i32 0, i32 24
  %91 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data128, align 8
  %92 = load i32, i32* %i, align 4
  %93 = load i32, i32* %delta, align 4
  %add129 = add i32 %92, %93
  %idxprom130 = sext i32 %add129 to i64
  %arrayidx131 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %91, i64 %idxprom130
  %94 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx131, i32 0, i32 0
  %ptr_type = bitcast %union.anon.210* %94 to i32*
  %95 = load i32, i32* %ptr_type, align 8
  switch i32 %95, label %sw.default [
    i32 2, label %sw.bb
    i32 11, label %sw.bb137
    i32 12, label %sw.bb137
    i32 13, label %sw.bb138
    i32 15, label %sw.bb139
    i32 16, label %sw.bb140
    i32 16400, label %sw.bb140
  ]

sw.bb:                                            ; preds = %if.end127
  %96 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %convert_ctx_access132 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %96, i32 0, i32 4
  %97 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access132, align 8
  %tobool133 = icmp ne i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* %97, null
  br i1 %tobool133, label %if.end135, label %if.then134

if.then134:                                       ; preds = %sw.bb
  br label %for.inc

if.end135:                                        ; preds = %sw.bb
  %98 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %convert_ctx_access136 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %98, i32 0, i32 4
  %99 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access136, align 8
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* %99, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb137:                                         ; preds = %if.end127, %if.end127
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* @bpf_sock_convert_ctx_access, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb138:                                         ; preds = %if.end127
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* @bpf_tcp_sock_convert_ctx_access, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb139:                                         ; preds = %if.end127
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* @bpf_xdp_sock_convert_ctx_access, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb140:                                         ; preds = %if.end127, %if.end127
  %100 = load i32, i32* %type, align 4
  %cmp141 = icmp eq i32 %100, 1
  br i1 %cmp141, label %if.then143, label %if.end151

if.then143:                                       ; preds = %sw.bb140
  %101 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code144 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %101, i32 0, i32 0
  %102 = load i8, i8* %code144, align 4
  %conv145 = zext i8 %102 to i32
  %and146 = and i32 %conv145, 24
  %or = or i32 33, %and146
  %conv147 = trunc i32 %or to i8
  %103 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code148 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %103, i32 0, i32 0
  store i8 %conv147, i8* %code148, align 4
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog149 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %104, i32 0, i32 2
  %105 = load %struct.bpf_prog*, %struct.bpf_prog** %prog149, align 8
  %aux150 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %105, i32 0, i32 10
  %106 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux150, align 8
  %num_exentries = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %106, i32 0, i32 58
  %107 = load i32, i32* %num_exentries, align 4
  %inc = add i32 %107, 1
  store i32 %inc, i32* %num_exentries, align 4
  br label %if.end151

if.end151:                                        ; preds = %if.then143, %sw.bb140
  br label %for.inc

sw.default:                                       ; preds = %if.end127
  br label %for.inc

sw.epilog:                                        ; preds = %sw.bb139, %sw.bb138, %sw.bb137, %if.end135
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data152 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %108, i32 0, i32 24
  %109 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data152, align 8
  %110 = load i32, i32* %i, align 4
  %111 = load i32, i32* %delta, align 4
  %add153 = add i32 %110, %111
  %idxprom154 = sext i32 %add153 to i64
  %arrayidx155 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %109, i64 %idxprom154
  %ctx_field_size156 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx155, i32 0, i32 2
  %112 = load i32, i32* %ctx_field_size156, align 8
  store i32 %112, i32* %ctx_field_size, align 4
  store i32 -22, i32* %bytes, align 4
  %113 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code157 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %113, i32 0, i32 0
  %114 = load i8, i8* %code157, align 4
  %conv158 = zext i8 %114 to i32
  %and159 = and i32 %conv158, 24
  %cmp160 = icmp eq i32 %and159, 16
  br i1 %cmp160, label %if.then162, label %if.else163

if.then162:                                       ; preds = %sw.epilog
  store i32 1, i32* %bytes, align 4
  br label %if.end187

if.else163:                                       ; preds = %sw.epilog
  %115 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code164 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %115, i32 0, i32 0
  %116 = load i8, i8* %code164, align 4
  %conv165 = zext i8 %116 to i32
  %and166 = and i32 %conv165, 24
  %cmp167 = icmp eq i32 %and166, 8
  br i1 %cmp167, label %if.then169, label %if.else170

if.then169:                                       ; preds = %if.else163
  store i32 2, i32* %bytes, align 4
  br label %if.end186

if.else170:                                       ; preds = %if.else163
  %117 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code171 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %117, i32 0, i32 0
  %118 = load i8, i8* %code171, align 4
  %conv172 = zext i8 %118 to i32
  %and173 = and i32 %conv172, 24
  %cmp174 = icmp eq i32 %and173, 0
  br i1 %cmp174, label %if.then176, label %if.else177

if.then176:                                       ; preds = %if.else170
  store i32 4, i32* %bytes, align 4
  br label %if.end185

if.else177:                                       ; preds = %if.else170
  %119 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code178 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %119, i32 0, i32 0
  %120 = load i8, i8* %code178, align 4
  %conv179 = zext i8 %120 to i32
  %and180 = and i32 %conv179, 24
  %cmp181 = icmp eq i32 %and180, 24
  br i1 %cmp181, label %if.then183, label %if.end184

if.then183:                                       ; preds = %if.else177
  store i32 8, i32* %bytes, align 4
  br label %if.end184

if.end184:                                        ; preds = %if.then183, %if.else177
  br label %if.end185

if.end185:                                        ; preds = %if.end184, %if.then176
  br label %if.end186

if.end186:                                        ; preds = %if.end185, %if.then169
  br label %if.end187

if.end187:                                        ; preds = %if.end186, %if.then162
  %121 = load i32, i32* %bytes, align 4
  store i32 %121, i32* %tmp, align 4
  %122 = load i32, i32* %tmp, align 4
  store i32 %122, i32* %__size, align 4
  %123 = load i32, i32* %__size, align 4
  %cmp188 = icmp slt i32 %123, 0
  %lnot = xor i1 %cmp188, true
  %lnot190 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot190 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %124 = load i32, i32* %__ret_warn_on, align 4
  %tobool191 = icmp ne i32 %124, 0
  %lnot192 = xor i1 %tobool191, true
  %lnot194 = xor i1 %lnot192, true
  %lnot.ext195 = zext i1 %lnot194 to i32
  %conv196 = sext i32 %lnot.ext195 to i64
  %tobool197 = icmp ne i64 %conv196, 0
  br i1 %tobool197, label %if.then198, label %if.end205

if.then198:                                       ; preds = %if.end187
  br label %do.body

do.body:                                          ; preds = %if.then198
  store i32 2305, i32* %__flags, align 4
  br label %do.body199

do.body199:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body199
  br label %do.body200

do.body200:                                       ; preds = %do.end
  %125 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 15470, i32 %125, i64 12) #19, !srcloc !39
  br label %do.end201

do.end201:                                        ; preds = %do.body200
  br label %do.body202

do.body202:                                       ; preds = %do.end201
  br label %do.end203

do.end203:                                        ; preds = %do.body202
  br label %do.end204

do.end204:                                        ; preds = %do.end203
  br label %if.end205

if.end205:                                        ; preds = %do.end204, %if.end187
  %126 = load i32, i32* %__ret_warn_on, align 4
  %tobool207 = icmp ne i32 %126, 0
  %lnot208 = xor i1 %tobool207, true
  %lnot210 = xor i1 %lnot208, true
  %lnot.ext211 = zext i1 %lnot210 to i32
  %conv212 = sext i32 %lnot.ext211 to i64
  store i64 %conv212, i64* %tmp206, align 8
  %127 = load i64, i64* %tmp206, align 8
  %128 = load i32, i32* %__size, align 4
  store i32 %128, i32* %tmp213, align 4
  %129 = load i32, i32* %tmp213, align 4
  store i32 %129, i32* %size, align 4
  %130 = load i32, i32* %size, align 4
  %131 = load i32, i32* %ctx_field_size, align 4
  %cmp214 = icmp slt i32 %130, %131
  %frombool216 = zext i1 %cmp214 to i8
  store i8 %frombool216, i8* %is_narrower_load, align 1
  %132 = load i32, i32* %ctx_field_size, align 4
  %call217 = call i32 @bpf_ctx_off_adjust_machine(i32 noundef %132) #20
  store i32 %call217, i32* %size_default, align 4
  %133 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off218 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %133, i32 0, i32 2
  %134 = load i16, i16* %off218, align 2
  %conv219 = sext i16 %134 to i32
  store i32 %conv219, i32* %off, align 4
  %135 = load i8, i8* %is_narrower_load, align 1
  %tobool220 = trunc i8 %135 to i1
  br i1 %tobool220, label %if.then221, label %if.end243

if.then221:                                       ; preds = %if.end205
  %136 = load i32, i32* %type, align 4
  %cmp222 = icmp eq i32 %136, 2
  br i1 %cmp222, label %if.then224, label %if.end225

if.then224:                                       ; preds = %if.then221
  %137 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %138 = bitcast %struct.bpf_verifier_env* %137 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %138, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.499, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end225:                                        ; preds = %if.then221
  store i8 8, i8* %size_code, align 1
  %139 = load i32, i32* %ctx_field_size, align 4
  %cmp226 = icmp eq i32 %139, 4
  br i1 %cmp226, label %if.then228, label %if.else229

if.then228:                                       ; preds = %if.end225
  store i8 0, i8* %size_code, align 1
  br label %if.end234

if.else229:                                       ; preds = %if.end225
  %140 = load i32, i32* %ctx_field_size, align 4
  %cmp230 = icmp eq i32 %140, 8
  br i1 %cmp230, label %if.then232, label %if.end233

if.then232:                                       ; preds = %if.else229
  store i8 24, i8* %size_code, align 1
  br label %if.end233

if.end233:                                        ; preds = %if.then232, %if.else229
  br label %if.end234

if.end234:                                        ; preds = %if.end233, %if.then228
  %141 = load i32, i32* %off, align 4
  %142 = load i32, i32* %size_default, align 4
  %sub235 = sub i32 %142, 1
  %neg = xor i32 %sub235, -1
  %and236 = and i32 %141, %neg
  %conv237 = trunc i32 %and236 to i16
  %143 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off238 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %143, i32 0, i32 2
  store i16 %conv237, i16* %off238, align 2
  %144 = load i8, i8* %size_code, align 1
  %conv239 = zext i8 %144 to i32
  %or240 = or i32 97, %conv239
  %conv241 = trunc i32 %or240 to i8
  %145 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code242 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %145, i32 0, i32 0
  store i8 %conv241, i8* %code242, align 4
  br label %if.end243

if.end243:                                        ; preds = %if.end234, %if.end205
  store i32 0, i32* %target_size, align 4
  %146 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  %147 = load i32, i32* %type, align 4
  %148 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arraydecay244 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %149 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog245 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %149, i32 0, i32 2
  %150 = load %struct.bpf_prog*, %struct.bpf_prog** %prog245, align 8
  %call246 = call i32 %146(i32 noundef %147, %struct.bpf_insn* noundef %148, %struct.bpf_insn* noundef %arraydecay244, %struct.bpf_prog* noundef %150, i32* noundef %target_size) #20
  store i32 %call246, i32* %cnt, align 4
  %151 = load i32, i32* %cnt, align 4
  %cmp247 = icmp eq i32 %151, 0
  br i1 %cmp247, label %if.then257, label %lor.lhs.false249

lor.lhs.false249:                                 ; preds = %if.end243
  %152 = load i32, i32* %cnt, align 4
  %conv250 = sext i32 %152 to i64
  %cmp251 = icmp uge i64 %conv250, 16
  br i1 %cmp251, label %if.then257, label %lor.lhs.false253

lor.lhs.false253:                                 ; preds = %lor.lhs.false249
  %153 = load i32, i32* %ctx_field_size, align 4
  %tobool254 = icmp ne i32 %153, 0
  br i1 %tobool254, label %land.lhs.true255, label %if.end258

land.lhs.true255:                                 ; preds = %lor.lhs.false253
  %154 = load i32, i32* %target_size, align 4
  %tobool256 = icmp ne i32 %154, 0
  br i1 %tobool256, label %if.end258, label %if.then257

if.then257:                                       ; preds = %land.lhs.true255, %lor.lhs.false249, %if.end243
  %155 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %156 = bitcast %struct.bpf_verifier_env* %155 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %156, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.485, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end258:                                        ; preds = %land.lhs.true255, %lor.lhs.false253
  %157 = load i8, i8* %is_narrower_load, align 1
  %tobool259 = trunc i8 %157 to i1
  br i1 %tobool259, label %land.lhs.true261, label %if.end370

land.lhs.true261:                                 ; preds = %if.end258
  %158 = load i32, i32* %size, align 4
  %159 = load i32, i32* %target_size, align 4
  %cmp262 = icmp ult i32 %158, %159
  br i1 %cmp262, label %if.then264, label %if.end370

if.then264:                                       ; preds = %land.lhs.true261
  %160 = load i32, i32* %off, align 4
  %161 = load i32, i32* %size, align 4
  %162 = load i32, i32* %size_default, align 4
  %call265 = call zeroext i8 @bpf_ctx_narrow_access_offset(i32 noundef %160, i32 noundef %161, i32 noundef %162) #20
  %conv266 = zext i8 %call265 to i32
  %mul = mul i32 %conv266, 8
  %conv267 = trunc i32 %mul to i8
  store i8 %conv267, i8* %shift, align 1
  %163 = load i8, i8* %shift, align 1
  %conv268 = zext i8 %163 to i32
  %tobool269 = icmp ne i32 %conv268, 0
  br i1 %tobool269, label %land.lhs.true270, label %if.end276

land.lhs.true270:                                 ; preds = %if.then264
  %164 = load i32, i32* %cnt, align 4
  %add271 = add i32 %164, 1
  %conv272 = sext i32 %add271 to i64
  %cmp273 = icmp uge i64 %conv272, 16
  br i1 %cmp273, label %if.then275, label %if.end276

if.then275:                                       ; preds = %land.lhs.true270
  %165 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %166 = bitcast %struct.bpf_verifier_env* %165 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %166, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.500, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end276:                                        ; preds = %land.lhs.true270, %if.then264
  %167 = load i32, i32* %ctx_field_size, align 4
  %cmp277 = icmp sle i32 %167, 4
  br i1 %cmp277, label %if.then279, label %if.else322

if.then279:                                       ; preds = %if.end276
  %168 = load i8, i8* %shift, align 1
  %tobool280 = icmp ne i8 %168, 0
  br i1 %tobool280, label %if.then281, label %if.end300

if.then281:                                       ; preds = %if.then279
  %169 = load i32, i32* %cnt, align 4
  %inc282 = add i32 %169, 1
  store i32 %inc282, i32* %cnt, align 4
  %idxprom283 = sext i32 %169 to i64
  %arrayidx284 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom283
  %code285 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 116, i8* %code285, align 4
  %dst_reg286 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %170 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg287 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %170, i32 0, i32 1
  %bf.load288 = load i8, i8* %dst_reg287, align 1
  %bf.clear289 = and i8 %bf.load288, 15
  %bf.load290 = load i8, i8* %dst_reg286, align 1
  %bf.value = and i8 %bf.clear289, 15
  %bf.clear291 = and i8 %bf.load290, -16
  %bf.set292 = or i8 %bf.clear291, %bf.value
  store i8 %bf.set292, i8* %dst_reg286, align 1
  %src_reg293 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load294 = load i8, i8* %src_reg293, align 1
  %bf.clear295 = and i8 %bf.load294, 15
  %bf.set296 = or i8 %bf.clear295, 0
  store i8 %bf.set296, i8* %src_reg293, align 1
  %off297 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off297, align 2
  %imm298 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  %171 = load i8, i8* %shift, align 1
  %conv299 = zext i8 %171 to i32
  store i32 %conv299, i32* %imm298, align 4
  %172 = bitcast %struct.bpf_insn* %arrayidx284 to i8*
  %173 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %172, i8* align 4 %173, i64 8, i1 false)
  br label %if.end300

if.end300:                                        ; preds = %if.then281, %if.then279
  %174 = load i32, i32* %cnt, align 4
  %inc301 = add i32 %174, 1
  store i32 %inc301, i32* %cnt, align 4
  %idxprom302 = sext i32 %174 to i64
  %arrayidx303 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom302
  %code305 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral304, i32 0, i32 0
  store i8 84, i8* %code305, align 4
  %dst_reg306 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral304, i32 0, i32 1
  %175 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg307 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %175, i32 0, i32 1
  %bf.load308 = load i8, i8* %dst_reg307, align 1
  %bf.clear309 = and i8 %bf.load308, 15
  %bf.load310 = load i8, i8* %dst_reg306, align 1
  %bf.value311 = and i8 %bf.clear309, 15
  %bf.clear312 = and i8 %bf.load310, -16
  %bf.set313 = or i8 %bf.clear312, %bf.value311
  store i8 %bf.set313, i8* %dst_reg306, align 1
  %src_reg314 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral304, i32 0, i32 1
  %bf.load315 = load i8, i8* %src_reg314, align 1
  %bf.clear316 = and i8 %bf.load315, 15
  %bf.set317 = or i8 %bf.clear316, 0
  store i8 %bf.set317, i8* %src_reg314, align 1
  %off318 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral304, i32 0, i32 2
  store i16 0, i16* %off318, align 2
  %imm319 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral304, i32 0, i32 3
  %176 = load i32, i32* %size, align 4
  %mul320 = mul i32 %176, 8
  %shl = shl i32 1, %mul320
  %sub321 = sub i32 %shl, 1
  store i32 %sub321, i32* %imm319, align 4
  %177 = bitcast %struct.bpf_insn* %arrayidx303 to i8*
  %178 = bitcast %struct.bpf_insn* %.compoundliteral304 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %177, i8* align 4 %178, i64 8, i1 false)
  br label %if.end369

if.else322:                                       ; preds = %if.end276
  %179 = load i8, i8* %shift, align 1
  %tobool323 = icmp ne i8 %179, 0
  br i1 %tobool323, label %if.then324, label %if.end345

if.then324:                                       ; preds = %if.else322
  %180 = load i32, i32* %cnt, align 4
  %inc325 = add i32 %180, 1
  store i32 %inc325, i32* %cnt, align 4
  %idxprom326 = sext i32 %180 to i64
  %arrayidx327 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom326
  %code329 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral328, i32 0, i32 0
  store i8 119, i8* %code329, align 4
  %dst_reg330 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral328, i32 0, i32 1
  %181 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg331 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %181, i32 0, i32 1
  %bf.load332 = load i8, i8* %dst_reg331, align 1
  %bf.clear333 = and i8 %bf.load332, 15
  %bf.load334 = load i8, i8* %dst_reg330, align 1
  %bf.value335 = and i8 %bf.clear333, 15
  %bf.clear336 = and i8 %bf.load334, -16
  %bf.set337 = or i8 %bf.clear336, %bf.value335
  store i8 %bf.set337, i8* %dst_reg330, align 1
  %src_reg338 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral328, i32 0, i32 1
  %bf.load339 = load i8, i8* %src_reg338, align 1
  %bf.clear340 = and i8 %bf.load339, 15
  %bf.set341 = or i8 %bf.clear340, 0
  store i8 %bf.set341, i8* %src_reg338, align 1
  %off342 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral328, i32 0, i32 2
  store i16 0, i16* %off342, align 2
  %imm343 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral328, i32 0, i32 3
  %182 = load i8, i8* %shift, align 1
  %conv344 = zext i8 %182 to i32
  store i32 %conv344, i32* %imm343, align 4
  %183 = bitcast %struct.bpf_insn* %arrayidx327 to i8*
  %184 = bitcast %struct.bpf_insn* %.compoundliteral328 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %183, i8* align 4 %184, i64 8, i1 false)
  br label %if.end345

if.end345:                                        ; preds = %if.then324, %if.else322
  %185 = load i32, i32* %cnt, align 4
  %inc346 = add i32 %185, 1
  store i32 %inc346, i32* %cnt, align 4
  %idxprom347 = sext i32 %185 to i64
  %arrayidx348 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom347
  %code350 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral349, i32 0, i32 0
  store i8 87, i8* %code350, align 4
  %dst_reg351 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral349, i32 0, i32 1
  %186 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg352 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %186, i32 0, i32 1
  %bf.load353 = load i8, i8* %dst_reg352, align 1
  %bf.clear354 = and i8 %bf.load353, 15
  %bf.load355 = load i8, i8* %dst_reg351, align 1
  %bf.value356 = and i8 %bf.clear354, 15
  %bf.clear357 = and i8 %bf.load355, -16
  %bf.set358 = or i8 %bf.clear357, %bf.value356
  store i8 %bf.set358, i8* %dst_reg351, align 1
  %src_reg359 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral349, i32 0, i32 1
  %bf.load360 = load i8, i8* %src_reg359, align 1
  %bf.clear361 = and i8 %bf.load360, 15
  %bf.set362 = or i8 %bf.clear361, 0
  store i8 %bf.set362, i8* %src_reg359, align 1
  %off363 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral349, i32 0, i32 2
  store i16 0, i16* %off363, align 2
  %imm364 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral349, i32 0, i32 3
  %187 = load i32, i32* %size, align 4
  %mul365 = mul i32 %187, 8
  %sh_prom = zext i32 %mul365 to i64
  %shl366 = shl i64 1, %sh_prom
  %sub367 = sub i64 %shl366, 1
  %conv368 = trunc i64 %sub367 to i32
  store i32 %conv368, i32* %imm364, align 4
  %188 = bitcast %struct.bpf_insn* %arrayidx348 to i8*
  %189 = bitcast %struct.bpf_insn* %.compoundliteral349 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %188, i8* align 4 %189, i64 8, i1 false)
  br label %if.end369

if.end369:                                        ; preds = %if.end345, %if.end300
  br label %if.end370

if.end370:                                        ; preds = %if.end369, %land.lhs.true261, %if.end258
  %190 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %191 = load i32, i32* %i, align 4
  %192 = load i32, i32* %delta, align 4
  %add371 = add i32 %191, %192
  %arraydecay372 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %193 = load i32, i32* %cnt, align 4
  %call373 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %190, i32 noundef %add371, %struct.bpf_insn* noundef %arraydecay372, i32 noundef %193) #20
  store %struct.bpf_prog* %call373, %struct.bpf_prog** %new_prog, align 8
  %194 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool374 = icmp ne %struct.bpf_prog* %194, null
  br i1 %tobool374, label %if.end376, label %if.then375

if.then375:                                       ; preds = %if.end370
  store i32 -12, i32* %retval, align 4
  br label %return

if.end376:                                        ; preds = %if.end370
  %195 = load i32, i32* %cnt, align 4
  %sub377 = sub i32 %195, 1
  %196 = load i32, i32* %delta, align 4
  %add378 = add i32 %196, %sub377
  store i32 %add378, i32* %delta, align 4
  %197 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %198 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog379 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %198, i32 0, i32 2
  store %struct.bpf_prog* %197, %struct.bpf_prog** %prog379, align 8
  %199 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %200 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %199, i32 0, i32 12
  %201 = bitcast %union.anon.198* %200 to %struct.anon.201*
  %insnsi380 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %201, i32 0, i32 1
  %arraydecay381 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi380, i64 0, i64 0
  %202 = load i32, i32* %i, align 4
  %idx.ext382 = sext i32 %202 to i64
  %add.ptr383 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay381, i64 %idx.ext382
  %203 = load i32, i32* %delta, align 4
  %idx.ext384 = sext i32 %203 to i64
  %add.ptr385 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr383, i64 %idx.ext384
  store %struct.bpf_insn* %add.ptr385, %struct.bpf_insn** %insn, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end376, %sw.default, %if.end151, %if.then134, %if.then126, %if.end114, %if.else95
  %204 = load i32, i32* %i, align 4
  %inc386 = add i32 %204, 1
  store i32 %inc386, i32* %i, align 4
  %205 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %205, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond, !llvm.loop !40

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then375, %if.then275, %if.then257, %if.then224, %if.then113, %if.then25, %if.then17, %if.then11, %if.then5
  %206 = load i32, i32* %retval, align 4
  ret i32 %206
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_misc_fixups(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %eatype = alloca i32, align 4
  %prog_type = alloca i32, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %fn = alloca %struct.bpf_func_proto*, align 8
  %insn_cnt = alloca i32, align 4
  %ops = alloca %struct.bpf_map_ops*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %insn_buf = alloca [16 x %struct.bpf_insn], align 16
  %new_prog = alloca %struct.bpf_prog*, align 8
  %map_ptr = alloca %struct.bpf_map*, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %cnt = alloca i32, align 4
  %delta = alloca i32, align 4
  %is64 = alloca i8, align 1
  %isdiv = alloca i8, align 1
  %patchlet = alloca %struct.bpf_insn*, align 8
  %chk_and_div = alloca [4 x %struct.bpf_insn], align 16
  %chk_and_mod = alloca [4 x %struct.bpf_insn], align 16
  %code_add = alloca i8, align 1
  %code_sub = alloca i8, align 1
  %patch = alloca %struct.bpf_insn*, align 8
  %issrc = alloca i8, align 1
  %isneg = alloca i8, align 1
  %isimm = alloca i8, align 1
  %off_reg = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %.compoundliteral267 = alloca %struct.bpf_insn, align 4
  %.compoundliteral283 = alloca %struct.bpf_insn, align 4
  %.compoundliteral297 = alloca %struct.bpf_insn, align 4
  %.compoundliteral313 = alloca %struct.bpf_insn, align 4
  %.compoundliteral329 = alloca %struct.bpf_insn, align 4
  %.compoundliteral342 = alloca %struct.bpf_insn, align 4
  %.compoundliteral355 = alloca %struct.bpf_insn, align 4
  %.compoundliteral374 = alloca %struct.bpf_insn, align 4
  %.compoundliteral420 = alloca %struct.bpf_insn, align 4
  %desc = alloca %struct.bpf_jit_poke_descriptor, align 8
  %.compoundliteral560 = alloca %struct.bpf_insn, align 4
  %.compoundliteral573 = alloca %struct.bpf_insn, align 4
  %__mptr = alloca i8*, align 8
  %tmp = alloca %struct.bpf_array*, align 8
  %ld_addrs = alloca [2 x %struct.bpf_insn], align 16
  %.compoundliteral673 = alloca %struct.bpf_insn, align 4
  %.compoundliteral687 = alloca %struct.bpf_insn, align 4
  %ld_jiffies_addr = alloca [2 x %struct.bpf_insn], align 16
  %.compoundliteral909 = alloca %struct.bpf_insn, align 4
  %.compoundliteral945 = alloca %struct.bpf_insn, align 4
  %.compoundliteral958 = alloca %struct.bpf_insn, align 4
  %.compoundliteral971 = alloca %struct.bpf_insn, align 4
  %.compoundliteral984 = alloca %struct.bpf_insn, align 4
  %.compoundliteral997 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1010 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1023 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1036 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1049 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1091 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1104 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1117 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1130 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1143 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1156 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1170 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1207 = alloca %struct.bpf_insn, align 4
  %.compoundliteral1241 = alloca %struct.bpf_insn, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 3
  %3 = load i32, i32* %expected_attach_type, align 8
  store i32 %3, i32* %eatype, align 4
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %4) #20
  store i32 %call, i32* %prog_type, align 4
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %6 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 12
  %7 = bitcast %union.anon.198* %6 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %7, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %8 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %8, i32 0, i32 4
  %9 = load i32, i32* %len, align 4
  store i32 %9, i32* %insn_cnt, align 4
  store i32 0, i32* %delta, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, i32* %i, align 4
  %11 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %10, %11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %12, i32 0, i32 0
  %13 = load i8, i8* %code, align 4
  %conv = zext i8 %13 to i32
  %cmp2 = icmp eq i32 %conv, 159
  br i1 %cmp2, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code4 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %14, i32 0, i32 0
  %15 = load i8, i8* %code4, align 4
  %conv5 = zext i8 %15 to i32
  %cmp6 = icmp eq i32 %conv5, 63
  br i1 %cmp6, label %if.then, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 0
  %17 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %17 to i32
  %cmp11 = icmp eq i32 %conv10, 156
  br i1 %cmp11, label %if.then, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code14 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 0
  %19 = load i8, i8* %code14, align 4
  %conv15 = zext i8 %19 to i32
  %cmp16 = icmp eq i32 %conv15, 60
  br i1 %cmp16, label %if.then, label %if.end156

if.then:                                          ; preds = %lor.lhs.false13, %lor.lhs.false8, %lor.lhs.false, %for.body
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 0
  %21 = load i8, i8* %code18, align 4
  %conv19 = zext i8 %21 to i32
  %and = and i32 %conv19, 7
  %cmp20 = icmp eq i32 %and, 7
  %frombool = zext i1 %cmp20 to i8
  store i8 %frombool, i8* %is64, align 1
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code22 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 0
  %23 = load i8, i8* %code22, align 4
  %conv23 = zext i8 %23 to i32
  %and24 = and i32 %conv23, 240
  %cmp25 = icmp eq i32 %and24, 48
  %frombool27 = zext i1 %cmp25 to i8
  store i8 %frombool27, i8* %isdiv, align 1
  %arrayinit.begin = getelementptr inbounds [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %chk_and_div, i64 0, i64 0
  %code28 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 0
  %24 = load i8, i8* %is64, align 1
  %tobool = trunc i8 %24 to i1
  %25 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 5, i32 6
  %or = or i32 %cond, 80
  %or30 = or i32 %or, 0
  %conv31 = trunc i32 %or30 to i8
  store i8 %conv31, i8* %code28, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %26, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.load32 = load i8, i8* %dst_reg, align 1
  %bf.value = and i8 %bf.lshr, 15
  %bf.clear = and i8 %bf.load32, -16
  %bf.set = or i8 %bf.clear, %bf.value
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg33 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %bf.load34 = load i8, i8* %src_reg33, align 1
  %bf.clear35 = and i8 %bf.load34, 15
  %bf.set36 = or i8 %bf.clear35, 0
  store i8 %bf.set36, i8* %src_reg33, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 2
  store i16 2, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %arrayinit.element = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i64 1
  %code37 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 0
  store i8 -84, i8* %code37, align 8
  %dst_reg38 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %27, i32 0, i32 1
  %bf.load40 = load i8, i8* %dst_reg39, align 1
  %bf.clear41 = and i8 %bf.load40, 15
  %bf.load42 = load i8, i8* %dst_reg38, align 1
  %bf.value43 = and i8 %bf.clear41, 15
  %bf.clear44 = and i8 %bf.load42, -16
  %bf.set45 = or i8 %bf.clear44, %bf.value43
  store i8 %bf.set45, i8* %dst_reg38, align 1
  %src_reg46 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg47 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %28, i32 0, i32 1
  %bf.load48 = load i8, i8* %dst_reg47, align 1
  %bf.clear49 = and i8 %bf.load48, 15
  %bf.load50 = load i8, i8* %src_reg46, align 1
  %bf.value51 = and i8 %bf.clear49, 15
  %bf.shl = shl i8 %bf.value51, 4
  %bf.clear52 = and i8 %bf.load50, 15
  %bf.set53 = or i8 %bf.clear52, %bf.shl
  store i8 %bf.set53, i8* %src_reg46, align 1
  %off54 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 2
  store i16 0, i16* %off54, align 2
  %imm55 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 3
  store i32 0, i32* %imm55, align 4
  %arrayinit.element56 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i64 1
  %code57 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element56, i32 0, i32 0
  store i8 5, i8* %code57, align 8
  %dst_reg58 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element56, i32 0, i32 1
  %bf.load59 = load i8, i8* %dst_reg58, align 1
  %bf.clear60 = and i8 %bf.load59, -16
  %bf.set61 = or i8 %bf.clear60, 0
  store i8 %bf.set61, i8* %dst_reg58, align 1
  %src_reg62 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element56, i32 0, i32 1
  %bf.load63 = load i8, i8* %src_reg62, align 1
  %bf.clear64 = and i8 %bf.load63, 15
  %bf.set65 = or i8 %bf.clear64, 0
  store i8 %bf.set65, i8* %src_reg62, align 1
  %off66 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element56, i32 0, i32 2
  store i16 1, i16* %off66, align 2
  %imm67 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element56, i32 0, i32 3
  store i32 0, i32* %imm67, align 4
  %arrayinit.element68 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element56, i64 1
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %30 = bitcast %struct.bpf_insn* %arrayinit.element68 to i8*
  %31 = bitcast %struct.bpf_insn* %29 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* align 4 %31, i64 8, i1 false)
  %arrayinit.begin69 = getelementptr inbounds [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %chk_and_mod, i64 0, i64 0
  %code70 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin69, i32 0, i32 0
  %32 = load i8, i8* %is64, align 1
  %tobool71 = trunc i8 %32 to i1
  %33 = zext i1 %tobool71 to i64
  %cond73 = select i1 %tobool71, i32 5, i32 6
  %or74 = or i32 %cond73, 16
  %or75 = or i32 %or74, 0
  %conv76 = trunc i32 %or75 to i8
  store i8 %conv76, i8* %code70, align 8
  %dst_reg77 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin69, i32 0, i32 1
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg78 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %34, i32 0, i32 1
  %bf.load79 = load i8, i8* %src_reg78, align 1
  %bf.lshr80 = lshr i8 %bf.load79, 4
  %bf.load81 = load i8, i8* %dst_reg77, align 1
  %bf.value82 = and i8 %bf.lshr80, 15
  %bf.clear83 = and i8 %bf.load81, -16
  %bf.set84 = or i8 %bf.clear83, %bf.value82
  store i8 %bf.set84, i8* %dst_reg77, align 1
  %src_reg85 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin69, i32 0, i32 1
  %bf.load86 = load i8, i8* %src_reg85, align 1
  %bf.clear87 = and i8 %bf.load86, 15
  %bf.set88 = or i8 %bf.clear87, 0
  store i8 %bf.set88, i8* %src_reg85, align 1
  %off89 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin69, i32 0, i32 2
  %35 = load i8, i8* %is64, align 1
  %tobool90 = trunc i8 %35 to i1
  %36 = zext i1 %tobool90 to i64
  %cond92 = select i1 %tobool90, i32 0, i32 1
  %add = add i32 1, %cond92
  %conv93 = trunc i32 %add to i16
  store i16 %conv93, i16* %off89, align 2
  %imm94 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin69, i32 0, i32 3
  store i32 0, i32* %imm94, align 4
  %arrayinit.element95 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin69, i64 1
  %37 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %38 = bitcast %struct.bpf_insn* %arrayinit.element95 to i8*
  %39 = bitcast %struct.bpf_insn* %37 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %38, i8* align 4 %39, i64 8, i1 false)
  %arrayinit.element96 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element95, i64 1
  %code97 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element96, i32 0, i32 0
  store i8 5, i8* %code97, align 8
  %dst_reg98 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element96, i32 0, i32 1
  %bf.load99 = load i8, i8* %dst_reg98, align 1
  %bf.clear100 = and i8 %bf.load99, -16
  %bf.set101 = or i8 %bf.clear100, 0
  store i8 %bf.set101, i8* %dst_reg98, align 1
  %src_reg102 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element96, i32 0, i32 1
  %bf.load103 = load i8, i8* %src_reg102, align 1
  %bf.clear104 = and i8 %bf.load103, 15
  %bf.set105 = or i8 %bf.clear104, 0
  store i8 %bf.set105, i8* %src_reg102, align 1
  %off106 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element96, i32 0, i32 2
  store i16 1, i16* %off106, align 2
  %imm107 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element96, i32 0, i32 3
  store i32 0, i32* %imm107, align 4
  %arrayinit.element108 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element96, i64 1
  %code109 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element108, i32 0, i32 0
  store i8 -68, i8* %code109, align 8
  %dst_reg110 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element108, i32 0, i32 1
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg111 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %40, i32 0, i32 1
  %bf.load112 = load i8, i8* %dst_reg111, align 1
  %bf.clear113 = and i8 %bf.load112, 15
  %bf.load114 = load i8, i8* %dst_reg110, align 1
  %bf.value115 = and i8 %bf.clear113, 15
  %bf.clear116 = and i8 %bf.load114, -16
  %bf.set117 = or i8 %bf.clear116, %bf.value115
  store i8 %bf.set117, i8* %dst_reg110, align 1
  %src_reg118 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element108, i32 0, i32 1
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg119 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %41, i32 0, i32 1
  %bf.load120 = load i8, i8* %dst_reg119, align 1
  %bf.clear121 = and i8 %bf.load120, 15
  %bf.load122 = load i8, i8* %src_reg118, align 1
  %bf.value123 = and i8 %bf.clear121, 15
  %bf.shl124 = shl i8 %bf.value123, 4
  %bf.clear125 = and i8 %bf.load122, 15
  %bf.set126 = or i8 %bf.clear125, %bf.shl124
  store i8 %bf.set126, i8* %src_reg118, align 1
  %off127 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element108, i32 0, i32 2
  store i16 0, i16* %off127, align 2
  %imm128 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element108, i32 0, i32 3
  store i32 0, i32* %imm128, align 4
  %42 = load i8, i8* %isdiv, align 1
  %tobool129 = trunc i8 %42 to i1
  br i1 %tobool129, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %arraydecay131 = getelementptr inbounds [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %chk_and_div, i64 0, i64 0
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %arraydecay132 = getelementptr inbounds [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %chk_and_mod, i64 0, i64 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond133 = phi %struct.bpf_insn* [ %arraydecay131, %cond.true ], [ %arraydecay132, %cond.false ]
  store %struct.bpf_insn* %cond133, %struct.bpf_insn** %patchlet, align 8
  %43 = load i8, i8* %isdiv, align 1
  %tobool134 = trunc i8 %43 to i1
  br i1 %tobool134, label %cond.true136, label %cond.false137

cond.true136:                                     ; preds = %cond.end
  br label %cond.end142

cond.false137:                                    ; preds = %cond.end
  %44 = load i8, i8* %is64, align 1
  %tobool138 = trunc i8 %44 to i1
  %45 = zext i1 %tobool138 to i64
  %cond140 = select i1 %tobool138, i32 2, i32 0
  %conv141 = sext i32 %cond140 to i64
  %sub = sub i64 4, %conv141
  br label %cond.end142

cond.end142:                                      ; preds = %cond.false137, %cond.true136
  %cond143 = phi i64 [ 4, %cond.true136 ], [ %sub, %cond.false137 ]
  %conv144 = trunc i64 %cond143 to i32
  store i32 %conv144, i32* %cnt, align 4
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = load i32, i32* %i, align 4
  %48 = load i32, i32* %delta, align 4
  %add145 = add i32 %47, %48
  %49 = load %struct.bpf_insn*, %struct.bpf_insn** %patchlet, align 8
  %50 = load i32, i32* %cnt, align 4
  %call146 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %46, i32 noundef %add145, %struct.bpf_insn* noundef %49, i32 noundef %50) #20
  store %struct.bpf_prog* %call146, %struct.bpf_prog** %new_prog, align 8
  %51 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool147 = icmp ne %struct.bpf_prog* %51, null
  br i1 %tobool147, label %if.end, label %if.then148

if.then148:                                       ; preds = %cond.end142
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end142
  %52 = load i32, i32* %cnt, align 4
  %sub149 = sub i32 %52, 1
  %53 = load i32, i32* %delta, align 4
  %add150 = add i32 %53, %sub149
  store i32 %add150, i32* %delta, align 4
  %54 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %54, %struct.bpf_prog** %prog, align 8
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog151 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %55, i32 0, i32 2
  store %struct.bpf_prog* %54, %struct.bpf_prog** %prog151, align 8
  %56 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %57 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %56, i32 0, i32 12
  %58 = bitcast %union.anon.198* %57 to %struct.anon.201*
  %insnsi152 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %58, i32 0, i32 1
  %arraydecay153 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi152, i64 0, i64 0
  %59 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %59 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay153, i64 %idx.ext
  %60 = load i32, i32* %delta, align 4
  %idx.ext154 = sext i32 %60 to i64
  %add.ptr155 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr, i64 %idx.ext154
  store %struct.bpf_insn* %add.ptr155, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end156:                                        ; preds = %lor.lhs.false13
  %61 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code157 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %61, i32 0, i32 0
  %62 = load i8, i8* %code157, align 4
  %conv158 = zext i8 %62 to i32
  %and159 = and i32 %conv158, 7
  %cmp160 = icmp eq i32 %and159, 0
  br i1 %cmp160, label %land.lhs.true, label %if.end200

land.lhs.true:                                    ; preds = %if.end156
  %63 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code162 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %63, i32 0, i32 0
  %64 = load i8, i8* %code162, align 4
  %conv163 = zext i8 %64 to i32
  %and164 = and i32 %conv163, 224
  %cmp165 = icmp eq i32 %and164, 32
  br i1 %cmp165, label %if.then173, label %lor.lhs.false167

lor.lhs.false167:                                 ; preds = %land.lhs.true
  %65 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code168 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %65, i32 0, i32 0
  %66 = load i8, i8* %code168, align 4
  %conv169 = zext i8 %66 to i32
  %and170 = and i32 %conv169, 224
  %cmp171 = icmp eq i32 %and170, 64
  br i1 %cmp171, label %if.then173, label %if.end200

if.then173:                                       ; preds = %lor.lhs.false167, %land.lhs.true
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops174 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %67, i32 0, i32 3
  %68 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops174, align 8
  %gen_ld_abs = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %68, i32 0, i32 3
  %69 = load i32 (%struct.bpf_insn*, %struct.bpf_insn*)*, i32 (%struct.bpf_insn*, %struct.bpf_insn*)** %gen_ld_abs, align 8
  %70 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arraydecay175 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %call176 = call i32 %69(%struct.bpf_insn* noundef %70, %struct.bpf_insn* noundef %arraydecay175) #20
  store i32 %call176, i32* %cnt, align 4
  %71 = load i32, i32* %cnt, align 4
  %cmp177 = icmp eq i32 %71, 0
  br i1 %cmp177, label %if.then183, label %lor.lhs.false179

lor.lhs.false179:                                 ; preds = %if.then173
  %72 = load i32, i32* %cnt, align 4
  %conv180 = sext i32 %72 to i64
  %cmp181 = icmp uge i64 %conv180, 16
  br i1 %cmp181, label %if.then183, label %if.end184

if.then183:                                       ; preds = %lor.lhs.false179, %if.then173
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %74 = bitcast %struct.bpf_verifier_env* %73 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %74, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.485, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end184:                                        ; preds = %lor.lhs.false179
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = load i32, i32* %i, align 4
  %77 = load i32, i32* %delta, align 4
  %add185 = add i32 %76, %77
  %arraydecay186 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %78 = load i32, i32* %cnt, align 4
  %call187 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %75, i32 noundef %add185, %struct.bpf_insn* noundef %arraydecay186, i32 noundef %78) #20
  store %struct.bpf_prog* %call187, %struct.bpf_prog** %new_prog, align 8
  %79 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool188 = icmp ne %struct.bpf_prog* %79, null
  br i1 %tobool188, label %if.end190, label %if.then189

if.then189:                                       ; preds = %if.end184
  store i32 -12, i32* %retval, align 4
  br label %return

if.end190:                                        ; preds = %if.end184
  %80 = load i32, i32* %cnt, align 4
  %sub191 = sub i32 %80, 1
  %81 = load i32, i32* %delta, align 4
  %add192 = add i32 %81, %sub191
  store i32 %add192, i32* %delta, align 4
  %82 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %82, %struct.bpf_prog** %prog, align 8
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog193 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %83, i32 0, i32 2
  store %struct.bpf_prog* %82, %struct.bpf_prog** %prog193, align 8
  %84 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %85 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %84, i32 0, i32 12
  %86 = bitcast %union.anon.198* %85 to %struct.anon.201*
  %insnsi194 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %86, i32 0, i32 1
  %arraydecay195 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi194, i64 0, i64 0
  %87 = load i32, i32* %i, align 4
  %idx.ext196 = sext i32 %87 to i64
  %add.ptr197 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay195, i64 %idx.ext196
  %88 = load i32, i32* %delta, align 4
  %idx.ext198 = sext i32 %88 to i64
  %add.ptr199 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr197, i64 %idx.ext198
  store %struct.bpf_insn* %add.ptr199, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end200:                                        ; preds = %lor.lhs.false167, %if.end156
  %89 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code201 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %89, i32 0, i32 0
  %90 = load i8, i8* %code201, align 4
  %conv202 = zext i8 %90 to i32
  %cmp203 = icmp eq i32 %conv202, 15
  br i1 %cmp203, label %if.then210, label %lor.lhs.false205

lor.lhs.false205:                                 ; preds = %if.end200
  %91 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code206 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %91, i32 0, i32 0
  %92 = load i8, i8* %code206, align 4
  %conv207 = zext i8 %92 to i32
  %cmp208 = icmp eq i32 %conv207, 31
  br i1 %cmp208, label %if.then210, label %if.end452

if.then210:                                       ; preds = %lor.lhs.false205, %if.end200
  store i8 15, i8* %code_add, align 1
  store i8 31, i8* %code_sub, align 1
  %arrayidx = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  store %struct.bpf_insn* %arrayidx, %struct.bpf_insn** %patch, align 8
  %93 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %93, i32 0, i32 24
  %94 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %95 = load i32, i32* %i, align 4
  %96 = load i32, i32* %delta, align 4
  %add211 = add i32 %95, %96
  %idxprom = sext i32 %add211 to i64
  %arrayidx212 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %94, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx212, %struct.bpf_insn_aux_data** %aux, align 8
  %97 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %97, i32 0, i32 6
  %98 = load i8, i8* %alu_state, align 2
  %tobool213 = icmp ne i8 %98, 0
  br i1 %tobool213, label %lor.lhs.false214, label %if.then219

lor.lhs.false214:                                 ; preds = %if.then210
  %99 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state215 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %99, i32 0, i32 6
  %100 = load i8, i8* %alu_state215, align 2
  %conv216 = zext i8 %100 to i32
  %cmp217 = icmp eq i32 %conv216, 8
  br i1 %cmp217, label %if.then219, label %if.end220

if.then219:                                       ; preds = %lor.lhs.false214, %if.then210
  br label %for.inc

if.end220:                                        ; preds = %lor.lhs.false214
  %101 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state221 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %101, i32 0, i32 6
  %102 = load i8, i8* %alu_state221, align 2
  %conv222 = zext i8 %102 to i32
  %and223 = and i32 %conv222, 4
  %tobool224 = icmp ne i32 %and223, 0
  %frombool225 = zext i1 %tobool224 to i8
  store i8 %frombool225, i8* %isneg, align 1
  %103 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state226 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %103, i32 0, i32 6
  %104 = load i8, i8* %alu_state226, align 2
  %conv227 = zext i8 %104 to i32
  %and228 = and i32 %conv227, 3
  %cmp229 = icmp eq i32 %and228, 1
  %frombool231 = zext i1 %cmp229 to i8
  store i8 %frombool231, i8* %issrc, align 1
  %105 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state232 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %105, i32 0, i32 6
  %106 = load i8, i8* %alu_state232, align 2
  %conv233 = zext i8 %106 to i32
  %and234 = and i32 %conv233, 16
  %tobool235 = icmp ne i32 %and234, 0
  %frombool236 = zext i1 %tobool235 to i8
  store i8 %frombool236, i8* %isimm, align 1
  %107 = load i8, i8* %issrc, align 1
  %tobool237 = trunc i8 %107 to i1
  br i1 %tobool237, label %cond.true239, label %cond.false244

cond.true239:                                     ; preds = %if.end220
  %108 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg240 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %108, i32 0, i32 1
  %bf.load241 = load i8, i8* %src_reg240, align 1
  %bf.lshr242 = lshr i8 %bf.load241, 4
  %conv243 = zext i8 %bf.lshr242 to i32
  br label %cond.end249

cond.false244:                                    ; preds = %if.end220
  %109 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg245 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %109, i32 0, i32 1
  %bf.load246 = load i8, i8* %dst_reg245, align 1
  %bf.clear247 = and i8 %bf.load246, 15
  %conv248 = zext i8 %bf.clear247 to i32
  br label %cond.end249

cond.end249:                                      ; preds = %cond.false244, %cond.true239
  %cond250 = phi i32 [ %conv243, %cond.true239 ], [ %conv248, %cond.false244 ]
  store i32 %cond250, i32* %off_reg, align 4
  %110 = load i8, i8* %isimm, align 1
  %tobool251 = trunc i8 %110 to i1
  br i1 %tobool251, label %if.then252, label %if.else

if.then252:                                       ; preds = %cond.end249
  %111 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %111, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %patch, align 8
  %code253 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -76, i8* %code253, align 4
  %dst_reg254 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load255 = load i8, i8* %dst_reg254, align 1
  %bf.clear256 = and i8 %bf.load255, -16
  %bf.set257 = or i8 %bf.clear256, 11
  store i8 %bf.set257, i8* %dst_reg254, align 1
  %src_reg258 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load259 = load i8, i8* %src_reg258, align 1
  %bf.clear260 = and i8 %bf.load259, 15
  %bf.set261 = or i8 %bf.clear260, 0
  store i8 %bf.set261, i8* %src_reg258, align 1
  %off262 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off262, align 2
  %imm263 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  %112 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %113 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %112, i32 0, i32 0
  %alu_limit = bitcast %union.anon.210* %113 to i32*
  %114 = load i32, i32* %alu_limit, align 8
  store i32 %114, i32* %imm263, align 4
  %115 = bitcast %struct.bpf_insn* %111 to i8*
  %116 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %115, i8* align 4 %116, i64 8, i1 false)
  br label %if.end370

if.else:                                          ; preds = %cond.end249
  %117 = load i8, i8* %isneg, align 1
  %tobool264 = trunc i8 %117 to i1
  br i1 %tobool264, label %if.then265, label %if.end281

if.then265:                                       ; preds = %if.else
  %118 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr266 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %118, i32 1
  store %struct.bpf_insn* %incdec.ptr266, %struct.bpf_insn** %patch, align 8
  %code268 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral267, i32 0, i32 0
  store i8 39, i8* %code268, align 4
  %dst_reg269 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral267, i32 0, i32 1
  %119 = load i32, i32* %off_reg, align 4
  %conv270 = trunc i32 %119 to i8
  %bf.load271 = load i8, i8* %dst_reg269, align 1
  %bf.value272 = and i8 %conv270, 15
  %bf.clear273 = and i8 %bf.load271, -16
  %bf.set274 = or i8 %bf.clear273, %bf.value272
  store i8 %bf.set274, i8* %dst_reg269, align 1
  %src_reg275 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral267, i32 0, i32 1
  %bf.load276 = load i8, i8* %src_reg275, align 1
  %bf.clear277 = and i8 %bf.load276, 15
  %bf.set278 = or i8 %bf.clear277, 0
  store i8 %bf.set278, i8* %src_reg275, align 1
  %off279 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral267, i32 0, i32 2
  store i16 0, i16* %off279, align 2
  %imm280 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral267, i32 0, i32 3
  store i32 -1, i32* %imm280, align 4
  %120 = bitcast %struct.bpf_insn* %118 to i8*
  %121 = bitcast %struct.bpf_insn* %.compoundliteral267 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %120, i8* align 4 %121, i64 8, i1 false)
  br label %if.end281

if.end281:                                        ; preds = %if.then265, %if.else
  %122 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr282 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %122, i32 1
  store %struct.bpf_insn* %incdec.ptr282, %struct.bpf_insn** %patch, align 8
  %code284 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral283, i32 0, i32 0
  store i8 -76, i8* %code284, align 4
  %dst_reg285 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral283, i32 0, i32 1
  %bf.load286 = load i8, i8* %dst_reg285, align 1
  %bf.clear287 = and i8 %bf.load286, -16
  %bf.set288 = or i8 %bf.clear287, 11
  store i8 %bf.set288, i8* %dst_reg285, align 1
  %src_reg289 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral283, i32 0, i32 1
  %bf.load290 = load i8, i8* %src_reg289, align 1
  %bf.clear291 = and i8 %bf.load290, 15
  %bf.set292 = or i8 %bf.clear291, 0
  store i8 %bf.set292, i8* %src_reg289, align 1
  %off293 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral283, i32 0, i32 2
  store i16 0, i16* %off293, align 2
  %imm294 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral283, i32 0, i32 3
  %123 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %124 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %123, i32 0, i32 0
  %alu_limit295 = bitcast %union.anon.210* %124 to i32*
  %125 = load i32, i32* %alu_limit295, align 8
  store i32 %125, i32* %imm294, align 4
  %126 = bitcast %struct.bpf_insn* %122 to i8*
  %127 = bitcast %struct.bpf_insn* %.compoundliteral283 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %126, i8* align 4 %127, i64 8, i1 false)
  %128 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr296 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %128, i32 1
  store %struct.bpf_insn* %incdec.ptr296, %struct.bpf_insn** %patch, align 8
  %code298 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral297, i32 0, i32 0
  store i8 31, i8* %code298, align 4
  %dst_reg299 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral297, i32 0, i32 1
  %bf.load300 = load i8, i8* %dst_reg299, align 1
  %bf.clear301 = and i8 %bf.load300, -16
  %bf.set302 = or i8 %bf.clear301, 11
  store i8 %bf.set302, i8* %dst_reg299, align 1
  %src_reg303 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral297, i32 0, i32 1
  %129 = load i32, i32* %off_reg, align 4
  %conv304 = trunc i32 %129 to i8
  %bf.load305 = load i8, i8* %src_reg303, align 1
  %bf.value306 = and i8 %conv304, 15
  %bf.shl307 = shl i8 %bf.value306, 4
  %bf.clear308 = and i8 %bf.load305, 15
  %bf.set309 = or i8 %bf.clear308, %bf.shl307
  store i8 %bf.set309, i8* %src_reg303, align 1
  %off310 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral297, i32 0, i32 2
  store i16 0, i16* %off310, align 2
  %imm311 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral297, i32 0, i32 3
  store i32 0, i32* %imm311, align 4
  %130 = bitcast %struct.bpf_insn* %128 to i8*
  %131 = bitcast %struct.bpf_insn* %.compoundliteral297 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %130, i8* align 4 %131, i64 8, i1 false)
  %132 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr312 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %132, i32 1
  store %struct.bpf_insn* %incdec.ptr312, %struct.bpf_insn** %patch, align 8
  %code314 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral313, i32 0, i32 0
  store i8 79, i8* %code314, align 4
  %dst_reg315 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral313, i32 0, i32 1
  %bf.load316 = load i8, i8* %dst_reg315, align 1
  %bf.clear317 = and i8 %bf.load316, -16
  %bf.set318 = or i8 %bf.clear317, 11
  store i8 %bf.set318, i8* %dst_reg315, align 1
  %src_reg319 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral313, i32 0, i32 1
  %133 = load i32, i32* %off_reg, align 4
  %conv320 = trunc i32 %133 to i8
  %bf.load321 = load i8, i8* %src_reg319, align 1
  %bf.value322 = and i8 %conv320, 15
  %bf.shl323 = shl i8 %bf.value322, 4
  %bf.clear324 = and i8 %bf.load321, 15
  %bf.set325 = or i8 %bf.clear324, %bf.shl323
  store i8 %bf.set325, i8* %src_reg319, align 1
  %off326 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral313, i32 0, i32 2
  store i16 0, i16* %off326, align 2
  %imm327 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral313, i32 0, i32 3
  store i32 0, i32* %imm327, align 4
  %134 = bitcast %struct.bpf_insn* %132 to i8*
  %135 = bitcast %struct.bpf_insn* %.compoundliteral313 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %134, i8* align 4 %135, i64 8, i1 false)
  %136 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr328 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %136, i32 1
  store %struct.bpf_insn* %incdec.ptr328, %struct.bpf_insn** %patch, align 8
  %code330 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral329, i32 0, i32 0
  store i8 -121, i8* %code330, align 4
  %dst_reg331 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral329, i32 0, i32 1
  %bf.load332 = load i8, i8* %dst_reg331, align 1
  %bf.clear333 = and i8 %bf.load332, -16
  %bf.set334 = or i8 %bf.clear333, 11
  store i8 %bf.set334, i8* %dst_reg331, align 1
  %src_reg335 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral329, i32 0, i32 1
  %bf.load336 = load i8, i8* %src_reg335, align 1
  %bf.clear337 = and i8 %bf.load336, 15
  %bf.set338 = or i8 %bf.clear337, 0
  store i8 %bf.set338, i8* %src_reg335, align 1
  %off339 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral329, i32 0, i32 2
  store i16 0, i16* %off339, align 2
  %imm340 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral329, i32 0, i32 3
  store i32 0, i32* %imm340, align 4
  %137 = bitcast %struct.bpf_insn* %136 to i8*
  %138 = bitcast %struct.bpf_insn* %.compoundliteral329 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %137, i8* align 4 %138, i64 8, i1 false)
  %139 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr341 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %139, i32 1
  store %struct.bpf_insn* %incdec.ptr341, %struct.bpf_insn** %patch, align 8
  %code343 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral342, i32 0, i32 0
  store i8 -57, i8* %code343, align 4
  %dst_reg344 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral342, i32 0, i32 1
  %bf.load345 = load i8, i8* %dst_reg344, align 1
  %bf.clear346 = and i8 %bf.load345, -16
  %bf.set347 = or i8 %bf.clear346, 11
  store i8 %bf.set347, i8* %dst_reg344, align 1
  %src_reg348 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral342, i32 0, i32 1
  %bf.load349 = load i8, i8* %src_reg348, align 1
  %bf.clear350 = and i8 %bf.load349, 15
  %bf.set351 = or i8 %bf.clear350, 0
  store i8 %bf.set351, i8* %src_reg348, align 1
  %off352 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral342, i32 0, i32 2
  store i16 0, i16* %off352, align 2
  %imm353 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral342, i32 0, i32 3
  store i32 63, i32* %imm353, align 4
  %140 = bitcast %struct.bpf_insn* %139 to i8*
  %141 = bitcast %struct.bpf_insn* %.compoundliteral342 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %140, i8* align 4 %141, i64 8, i1 false)
  %142 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr354 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %142, i32 1
  store %struct.bpf_insn* %incdec.ptr354, %struct.bpf_insn** %patch, align 8
  %code356 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral355, i32 0, i32 0
  store i8 95, i8* %code356, align 4
  %dst_reg357 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral355, i32 0, i32 1
  %bf.load358 = load i8, i8* %dst_reg357, align 1
  %bf.clear359 = and i8 %bf.load358, -16
  %bf.set360 = or i8 %bf.clear359, 11
  store i8 %bf.set360, i8* %dst_reg357, align 1
  %src_reg361 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral355, i32 0, i32 1
  %143 = load i32, i32* %off_reg, align 4
  %conv362 = trunc i32 %143 to i8
  %bf.load363 = load i8, i8* %src_reg361, align 1
  %bf.value364 = and i8 %conv362, 15
  %bf.shl365 = shl i8 %bf.value364, 4
  %bf.clear366 = and i8 %bf.load363, 15
  %bf.set367 = or i8 %bf.clear366, %bf.shl365
  store i8 %bf.set367, i8* %src_reg361, align 1
  %off368 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral355, i32 0, i32 2
  store i16 0, i16* %off368, align 2
  %imm369 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral355, i32 0, i32 3
  store i32 0, i32* %imm369, align 4
  %144 = bitcast %struct.bpf_insn* %142 to i8*
  %145 = bitcast %struct.bpf_insn* %.compoundliteral355 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %144, i8* align 4 %145, i64 8, i1 false)
  br label %if.end370

if.end370:                                        ; preds = %if.end281, %if.then252
  %146 = load i8, i8* %issrc, align 1
  %tobool371 = trunc i8 %146 to i1
  br i1 %tobool371, label %if.end395, label %if.then372

if.then372:                                       ; preds = %if.end370
  %147 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr373 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %147, i32 1
  store %struct.bpf_insn* %incdec.ptr373, %struct.bpf_insn** %patch, align 8
  %code375 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral374, i32 0, i32 0
  store i8 -65, i8* %code375, align 4
  %dst_reg376 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral374, i32 0, i32 1
  %148 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg377 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %148, i32 0, i32 1
  %bf.load378 = load i8, i8* %dst_reg377, align 1
  %bf.clear379 = and i8 %bf.load378, 15
  %bf.load380 = load i8, i8* %dst_reg376, align 1
  %bf.value381 = and i8 %bf.clear379, 15
  %bf.clear382 = and i8 %bf.load380, -16
  %bf.set383 = or i8 %bf.clear382, %bf.value381
  store i8 %bf.set383, i8* %dst_reg376, align 1
  %src_reg384 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral374, i32 0, i32 1
  %149 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg385 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %149, i32 0, i32 1
  %bf.load386 = load i8, i8* %src_reg385, align 1
  %bf.lshr387 = lshr i8 %bf.load386, 4
  %bf.load388 = load i8, i8* %src_reg384, align 1
  %bf.value389 = and i8 %bf.lshr387, 15
  %bf.shl390 = shl i8 %bf.value389, 4
  %bf.clear391 = and i8 %bf.load388, 15
  %bf.set392 = or i8 %bf.clear391, %bf.shl390
  store i8 %bf.set392, i8* %src_reg384, align 1
  %off393 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral374, i32 0, i32 2
  store i16 0, i16* %off393, align 2
  %imm394 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral374, i32 0, i32 3
  store i32 0, i32* %imm394, align 4
  %150 = bitcast %struct.bpf_insn* %147 to i8*
  %151 = bitcast %struct.bpf_insn* %.compoundliteral374 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %150, i8* align 4 %151, i64 8, i1 false)
  br label %if.end395

if.end395:                                        ; preds = %if.then372, %if.end370
  %152 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg396 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %152, i32 0, i32 1
  %bf.load397 = load i8, i8* %src_reg396, align 1
  %bf.clear398 = and i8 %bf.load397, 15
  %bf.set399 = or i8 %bf.clear398, -80
  store i8 %bf.set399, i8* %src_reg396, align 1
  %153 = load i8, i8* %isneg, align 1
  %tobool400 = trunc i8 %153 to i1
  br i1 %tobool400, label %if.then401, label %if.end409

if.then401:                                       ; preds = %if.end395
  %154 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code402 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %154, i32 0, i32 0
  %155 = load i8, i8* %code402, align 4
  %conv403 = zext i8 %155 to i32
  %cmp404 = icmp eq i32 %conv403, 15
  %156 = zext i1 %cmp404 to i64
  %cond406 = select i1 %cmp404, i32 31, i32 15
  %conv407 = trunc i32 %cond406 to i8
  %157 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code408 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %157, i32 0, i32 0
  store i8 %conv407, i8* %code408, align 4
  br label %if.end409

if.end409:                                        ; preds = %if.then401, %if.end395
  %158 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr410 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %158, i32 1
  store %struct.bpf_insn* %incdec.ptr410, %struct.bpf_insn** %patch, align 8
  %159 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %160 = bitcast %struct.bpf_insn* %158 to i8*
  %161 = bitcast %struct.bpf_insn* %159 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %160, i8* align 4 %161, i64 8, i1 false)
  %162 = load i8, i8* %issrc, align 1
  %tobool411 = trunc i8 %162 to i1
  br i1 %tobool411, label %land.lhs.true413, label %if.end434

land.lhs.true413:                                 ; preds = %if.end409
  %163 = load i8, i8* %isneg, align 1
  %tobool414 = trunc i8 %163 to i1
  br i1 %tobool414, label %land.lhs.true416, label %if.end434

land.lhs.true416:                                 ; preds = %land.lhs.true413
  %164 = load i8, i8* %isimm, align 1
  %tobool417 = trunc i8 %164 to i1
  br i1 %tobool417, label %if.end434, label %if.then418

if.then418:                                       ; preds = %land.lhs.true416
  %165 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr419 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %165, i32 1
  store %struct.bpf_insn* %incdec.ptr419, %struct.bpf_insn** %patch, align 8
  %code421 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral420, i32 0, i32 0
  store i8 39, i8* %code421, align 4
  %dst_reg422 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral420, i32 0, i32 1
  %166 = load i32, i32* %off_reg, align 4
  %conv423 = trunc i32 %166 to i8
  %bf.load424 = load i8, i8* %dst_reg422, align 1
  %bf.value425 = and i8 %conv423, 15
  %bf.clear426 = and i8 %bf.load424, -16
  %bf.set427 = or i8 %bf.clear426, %bf.value425
  store i8 %bf.set427, i8* %dst_reg422, align 1
  %src_reg428 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral420, i32 0, i32 1
  %bf.load429 = load i8, i8* %src_reg428, align 1
  %bf.clear430 = and i8 %bf.load429, 15
  %bf.set431 = or i8 %bf.clear430, 0
  store i8 %bf.set431, i8* %src_reg428, align 1
  %off432 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral420, i32 0, i32 2
  store i16 0, i16* %off432, align 2
  %imm433 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral420, i32 0, i32 3
  store i32 -1, i32* %imm433, align 4
  %167 = bitcast %struct.bpf_insn* %165 to i8*
  %168 = bitcast %struct.bpf_insn* %.compoundliteral420 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %167, i8* align 4 %168, i64 8, i1 false)
  br label %if.end434

if.end434:                                        ; preds = %if.then418, %land.lhs.true416, %land.lhs.true413, %if.end409
  %169 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %arraydecay435 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint %struct.bpf_insn* %169 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.bpf_insn* %arraydecay435 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv436 = trunc i64 %sub.ptr.div to i32
  store i32 %conv436, i32* %cnt, align 4
  %170 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %171 = load i32, i32* %i, align 4
  %172 = load i32, i32* %delta, align 4
  %add437 = add i32 %171, %172
  %arraydecay438 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %173 = load i32, i32* %cnt, align 4
  %call439 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %170, i32 noundef %add437, %struct.bpf_insn* noundef %arraydecay438, i32 noundef %173) #20
  store %struct.bpf_prog* %call439, %struct.bpf_prog** %new_prog, align 8
  %174 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool440 = icmp ne %struct.bpf_prog* %174, null
  br i1 %tobool440, label %if.end442, label %if.then441

if.then441:                                       ; preds = %if.end434
  store i32 -12, i32* %retval, align 4
  br label %return

if.end442:                                        ; preds = %if.end434
  %175 = load i32, i32* %cnt, align 4
  %sub443 = sub i32 %175, 1
  %176 = load i32, i32* %delta, align 4
  %add444 = add i32 %176, %sub443
  store i32 %add444, i32* %delta, align 4
  %177 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %177, %struct.bpf_prog** %prog, align 8
  %178 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog445 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %178, i32 0, i32 2
  store %struct.bpf_prog* %177, %struct.bpf_prog** %prog445, align 8
  %179 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %180 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %179, i32 0, i32 12
  %181 = bitcast %union.anon.198* %180 to %struct.anon.201*
  %insnsi446 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %181, i32 0, i32 1
  %arraydecay447 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi446, i64 0, i64 0
  %182 = load i32, i32* %i, align 4
  %idx.ext448 = sext i32 %182 to i64
  %add.ptr449 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay447, i64 %idx.ext448
  %183 = load i32, i32* %delta, align 4
  %idx.ext450 = sext i32 %183 to i64
  %add.ptr451 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr449, i64 %idx.ext450
  store %struct.bpf_insn* %add.ptr451, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end452:                                        ; preds = %lor.lhs.false205
  %184 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code453 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %184, i32 0, i32 0
  %185 = load i8, i8* %code453, align 4
  %conv454 = zext i8 %185 to i32
  %cmp455 = icmp ne i32 %conv454, 133
  br i1 %cmp455, label %if.then457, label %if.end458

if.then457:                                       ; preds = %if.end452
  br label %for.inc

if.end458:                                        ; preds = %if.end452
  %186 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg459 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %186, i32 0, i32 1
  %bf.load460 = load i8, i8* %src_reg459, align 1
  %bf.lshr461 = lshr i8 %bf.load460, 4
  %conv462 = zext i8 %bf.lshr461 to i32
  %cmp463 = icmp eq i32 %conv462, 1
  br i1 %cmp463, label %if.then465, label %if.end466

if.then465:                                       ; preds = %if.end458
  br label %for.inc

if.end466:                                        ; preds = %if.end458
  %187 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg467 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %187, i32 0, i32 1
  %bf.load468 = load i8, i8* %src_reg467, align 1
  %bf.lshr469 = lshr i8 %bf.load468, 4
  %conv470 = zext i8 %bf.lshr469 to i32
  %cmp471 = icmp eq i32 %conv470, 2
  br i1 %cmp471, label %if.then473, label %if.end478

if.then473:                                       ; preds = %if.end466
  %188 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %189 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call474 = call i32 @fixup_kfunc_call(%struct.bpf_verifier_env* noundef %188, %struct.bpf_insn* noundef %189) #20
  store i32 %call474, i32* %ret, align 4
  %190 = load i32, i32* %ret, align 4
  %tobool475 = icmp ne i32 %190, 0
  br i1 %tobool475, label %if.then476, label %if.end477

if.then476:                                       ; preds = %if.then473
  %191 = load i32, i32* %ret, align 4
  store i32 %191, i32* %retval, align 4
  br label %return

if.end477:                                        ; preds = %if.then473
  br label %for.inc

if.end478:                                        ; preds = %if.end466
  %192 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm479 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %192, i32 0, i32 3
  %193 = load i32, i32* %imm479, align 4
  %cmp480 = icmp eq i32 %193, 24
  br i1 %cmp480, label %if.then482, label %if.end486

if.then482:                                       ; preds = %if.end478
  %194 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %dst_needed = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %194, i32 0, i32 1
  %bf.load483 = load i16, i16* %dst_needed, align 2
  %bf.clear484 = and i16 %bf.load483, -17
  %bf.set485 = or i16 %bf.clear484, 16
  store i16 %bf.set485, i16* %dst_needed, align 2
  br label %if.end486

if.end486:                                        ; preds = %if.then482, %if.end478
  %195 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm487 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %195, i32 0, i32 3
  %196 = load i32, i32* %imm487, align 4
  %cmp488 = icmp eq i32 %196, 7
  br i1 %cmp488, label %if.then490, label %if.end491

if.then490:                                       ; preds = %if.end486
  call void @bpf_user_rnd_init_once() #20
  br label %if.end491

if.end491:                                        ; preds = %if.then490, %if.end486
  %197 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm492 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %197, i32 0, i32 3
  %198 = load i32, i32* %imm492, align 4
  %cmp493 = icmp eq i32 %198, 58
  br i1 %cmp493, label %if.then495, label %if.end499

if.then495:                                       ; preds = %if.end491
  %199 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %kprobe_override = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %199, i32 0, i32 1
  %bf.load496 = load i16, i16* %kprobe_override, align 2
  %bf.clear497 = and i16 %bf.load496, -257
  %bf.set498 = or i16 %bf.clear497, 256
  store i16 %bf.set498, i16* %kprobe_override, align 2
  br label %if.end499

if.end499:                                        ; preds = %if.then495, %if.end491
  %200 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm500 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %200, i32 0, i32 3
  %201 = load i32, i32* %imm500, align 4
  %cmp501 = icmp eq i32 %201, 12
  br i1 %cmp501, label %if.then503, label %if.end602

if.then503:                                       ; preds = %if.end499
  %202 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %cb_access = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %202, i32 0, i32 1
  %bf.load504 = load i16, i16* %cb_access, align 2
  %bf.clear505 = and i16 %bf.load504, -9
  %bf.set506 = or i16 %bf.clear505, 8
  store i16 %bf.set506, i16* %cb_access, align 2
  %203 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call507 = call zeroext i1 @allow_tail_call_in_subprogs(%struct.bpf_verifier_env* noundef %203) #20
  br i1 %call507, label %if.end510, label %if.then508

if.then508:                                       ; preds = %if.then503
  %204 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux509 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %204, i32 0, i32 10
  %205 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux509, align 8
  %stack_depth = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %205, i32 0, i32 6
  store i32 512, i32* %stack_depth, align 4
  br label %if.end510

if.end510:                                        ; preds = %if.then508, %if.then503
  %206 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux511 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %206, i32 0, i32 10
  %207 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux511, align 8
  %max_pkt_offset = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %207, i32 0, i32 4
  store i32 65535, i32* %max_pkt_offset, align 4
  %208 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm512 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %208, i32 0, i32 3
  store i32 0, i32* %imm512, align 4
  %209 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code513 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %209, i32 0, i32 0
  store i8 -11, i8* %code513, align 4
  %210 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data514 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %210, i32 0, i32 24
  %211 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data514, align 8
  %212 = load i32, i32* %i, align 4
  %213 = load i32, i32* %delta, align 4
  %add515 = add i32 %212, %213
  %idxprom516 = sext i32 %add515 to i64
  %arrayidx517 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %211, i64 %idxprom516
  store %struct.bpf_insn_aux_data* %arrayidx517, %struct.bpf_insn_aux_data** %aux, align 8
  %214 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %214, i32 0, i32 20
  %215 = load i8, i8* %bpf_capable, align 8
  %tobool518 = trunc i8 %215 to i1
  br i1 %tobool518, label %land.lhs.true520, label %if.end550

land.lhs.true520:                                 ; preds = %if.end510
  %216 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %blinding_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %216, i32 0, i32 1
  %bf.load521 = load i16, i16* %blinding_requested, align 2
  %bf.lshr522 = lshr i16 %bf.load521, 5
  %bf.clear523 = and i16 %bf.lshr522, 1
  %tobool524 = icmp ne i16 %bf.clear523, 0
  br i1 %tobool524, label %if.end550, label %land.lhs.true525

land.lhs.true525:                                 ; preds = %land.lhs.true520
  %217 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %217, i32 0, i32 1
  %bf.load526 = load i16, i16* %jit_requested, align 2
  %bf.lshr527 = lshr i16 %bf.load526, 1
  %bf.clear528 = and i16 %bf.lshr527, 1
  %conv529 = zext i16 %bf.clear528 to i32
  %tobool530 = icmp ne i32 %conv529, 0
  br i1 %tobool530, label %land.lhs.true531, label %if.end550

land.lhs.true531:                                 ; preds = %land.lhs.true525
  %218 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call532 = call zeroext i1 @bpf_map_key_poisoned(%struct.bpf_insn_aux_data* noundef %218) #20
  br i1 %call532, label %if.end550, label %land.lhs.true533

land.lhs.true533:                                 ; preds = %land.lhs.true531
  %219 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call534 = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %219) #20
  br i1 %call534, label %if.end550, label %land.lhs.true535

land.lhs.true535:                                 ; preds = %land.lhs.true533
  %220 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call536 = call zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %220) #20
  br i1 %call536, label %if.end550, label %if.then537

if.then537:                                       ; preds = %land.lhs.true535
  %tailcall_target = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 0
  store i8* null, i8** %tailcall_target, align 8
  %tailcall_bypass = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 1
  store i8* null, i8** %tailcall_bypass, align 8
  %bypass_addr = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 2
  store i8* null, i8** %bypass_addr, align 8
  %aux538 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 3
  store i8* null, i8** %aux538, align 8
  %221 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 4
  %tail_call = bitcast %union.anon.138* %221 to %struct.anon.139*
  %map = getelementptr inbounds %struct.anon.139, %struct.anon.139* %tail_call, i32 0, i32 0
  %222 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %223 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %222, i32 0, i32 0
  %map_ptr_state = bitcast %union.anon.210* %223 to i64*
  %224 = load i64, i64* %map_ptr_state, align 8
  %and539 = and i64 %224, -2
  %225 = inttoptr i64 %and539 to %struct.bpf_map*
  store %struct.bpf_map* %225, %struct.bpf_map** %map, align 8
  %key = getelementptr inbounds %struct.anon.139, %struct.anon.139* %tail_call, i32 0, i32 1
  %226 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call540 = call i64 @bpf_map_key_immediate(%struct.bpf_insn_aux_data* noundef %226) #20
  %conv541 = trunc i64 %call540 to i32
  store i32 %conv541, i32* %key, align 8
  %tailcall_target_stable = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 5
  store i8 0, i8* %tailcall_target_stable, align 8
  %adj_off = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 6
  store i8 0, i8* %adj_off, align 1
  %reason = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 7
  store i16 0, i16* %reason, align 2
  %insn_idx = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 8
  %227 = load i32, i32* %i, align 4
  %228 = load i32, i32* %delta, align 4
  %add542 = add i32 %227, %228
  store i32 %add542, i32* %insn_idx, align 4
  %229 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call543 = call i32 @bpf_jit_add_poke_descriptor(%struct.bpf_prog* noundef %229, %struct.bpf_jit_poke_descriptor* noundef %desc) #20
  store i32 %call543, i32* %ret, align 4
  %230 = load i32, i32* %ret, align 4
  %cmp544 = icmp slt i32 %230, 0
  br i1 %cmp544, label %if.then546, label %if.end547

if.then546:                                       ; preds = %if.then537
  %231 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %232 = bitcast %struct.bpf_verifier_env* %231 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %232, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.501, i64 0, i64 0)) #20
  %233 = load i32, i32* %ret, align 4
  store i32 %233, i32* %retval, align 4
  br label %return

if.end547:                                        ; preds = %if.then537
  %234 = load i32, i32* %ret, align 4
  %add548 = add i32 %234, 1
  %235 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm549 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %235, i32 0, i32 3
  store i32 %add548, i32* %imm549, align 4
  br label %for.inc

if.end550:                                        ; preds = %land.lhs.true535, %land.lhs.true533, %land.lhs.true531, %land.lhs.true525, %land.lhs.true520, %if.end510
  %236 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call551 = call zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %236) #20
  br i1 %call551, label %if.end553, label %if.then552

if.then552:                                       ; preds = %if.end550
  br label %for.inc

if.end553:                                        ; preds = %if.end550
  %237 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call554 = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %237) #20
  br i1 %call554, label %if.then555, label %if.end556

if.then555:                                       ; preds = %if.end553
  %238 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %239 = bitcast %struct.bpf_verifier_env* %238 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %239, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.453, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end556:                                        ; preds = %if.end553
  %240 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %241 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %240, i32 0, i32 0
  %map_ptr_state557 = bitcast %union.anon.210* %241 to i64*
  %242 = load i64, i64* %map_ptr_state557, align 8
  %and558 = and i64 %242, -2
  %243 = inttoptr i64 %and558 to %struct.bpf_map*
  store %struct.bpf_map* %243, %struct.bpf_map** %map_ptr, align 8
  %arrayidx559 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code561 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral560, i32 0, i32 0
  store i8 53, i8* %code561, align 4
  %dst_reg562 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral560, i32 0, i32 1
  %bf.load563 = load i8, i8* %dst_reg562, align 1
  %bf.clear564 = and i8 %bf.load563, -16
  %bf.set565 = or i8 %bf.clear564, 3
  store i8 %bf.set565, i8* %dst_reg562, align 1
  %src_reg566 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral560, i32 0, i32 1
  %bf.load567 = load i8, i8* %src_reg566, align 1
  %bf.clear568 = and i8 %bf.load567, 15
  %bf.set569 = or i8 %bf.clear568, 0
  store i8 %bf.set569, i8* %src_reg566, align 1
  %off570 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral560, i32 0, i32 2
  store i16 2, i16* %off570, align 2
  %imm571 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral560, i32 0, i32 3
  %244 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %max_entries = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %244, i32 0, i32 6
  %245 = load i32, i32* %max_entries, align 4
  store i32 %245, i32* %imm571, align 4
  %246 = bitcast %struct.bpf_insn* %arrayidx559 to i8*
  %247 = bitcast %struct.bpf_insn* %.compoundliteral560 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %246, i8* align 4 %247, i64 8, i1 false)
  %arrayidx572 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 1
  %code574 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral573, i32 0, i32 0
  store i8 84, i8* %code574, align 4
  %dst_reg575 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral573, i32 0, i32 1
  %bf.load576 = load i8, i8* %dst_reg575, align 1
  %bf.clear577 = and i8 %bf.load576, -16
  %bf.set578 = or i8 %bf.clear577, 3
  store i8 %bf.set578, i8* %dst_reg575, align 1
  %src_reg579 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral573, i32 0, i32 1
  %bf.load580 = load i8, i8* %src_reg579, align 1
  %bf.clear581 = and i8 %bf.load580, 15
  %bf.set582 = or i8 %bf.clear581, 0
  store i8 %bf.set582, i8* %src_reg579, align 1
  %off583 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral573, i32 0, i32 2
  store i16 0, i16* %off583, align 2
  %imm584 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral573, i32 0, i32 3
  %248 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %249 = bitcast %struct.bpf_map* %248 to i8*
  store i8* %249, i8** %__mptr, align 8
  %250 = load i8*, i8** %__mptr, align 8
  %add.ptr585 = getelementptr i8, i8* %250, i64 0
  %251 = bitcast i8* %add.ptr585 to %struct.bpf_array*
  store %struct.bpf_array* %251, %struct.bpf_array** %tmp, align 8
  %252 = load %struct.bpf_array*, %struct.bpf_array** %tmp, align 8
  %index_mask = getelementptr inbounds %struct.bpf_array, %struct.bpf_array* %252, i32 0, i32 2
  %253 = load i32, i32* %index_mask, align 4
  store i32 %253, i32* %imm584, align 4
  %254 = bitcast %struct.bpf_insn* %arrayidx572 to i8*
  %255 = bitcast %struct.bpf_insn* %.compoundliteral573 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %254, i8* align 4 %255, i64 8, i1 false)
  %arrayidx586 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 2
  %256 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %257 = bitcast %struct.bpf_insn* %arrayidx586 to i8*
  %258 = bitcast %struct.bpf_insn* %256 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %257, i8* align 4 %258, i64 8, i1 false)
  store i32 3, i32* %cnt, align 4
  %259 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %260 = load i32, i32* %i, align 4
  %261 = load i32, i32* %delta, align 4
  %add587 = add i32 %260, %261
  %arraydecay588 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %262 = load i32, i32* %cnt, align 4
  %call589 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %259, i32 noundef %add587, %struct.bpf_insn* noundef %arraydecay588, i32 noundef %262) #20
  store %struct.bpf_prog* %call589, %struct.bpf_prog** %new_prog, align 8
  %263 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool590 = icmp ne %struct.bpf_prog* %263, null
  br i1 %tobool590, label %if.end592, label %if.then591

if.then591:                                       ; preds = %if.end556
  store i32 -12, i32* %retval, align 4
  br label %return

if.end592:                                        ; preds = %if.end556
  %264 = load i32, i32* %cnt, align 4
  %sub593 = sub i32 %264, 1
  %265 = load i32, i32* %delta, align 4
  %add594 = add i32 %265, %sub593
  store i32 %add594, i32* %delta, align 4
  %266 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %266, %struct.bpf_prog** %prog, align 8
  %267 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog595 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %267, i32 0, i32 2
  store %struct.bpf_prog* %266, %struct.bpf_prog** %prog595, align 8
  %268 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %269 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %268, i32 0, i32 12
  %270 = bitcast %union.anon.198* %269 to %struct.anon.201*
  %insnsi596 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %270, i32 0, i32 1
  %arraydecay597 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi596, i64 0, i64 0
  %271 = load i32, i32* %i, align 4
  %idx.ext598 = sext i32 %271 to i64
  %add.ptr599 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay597, i64 %idx.ext598
  %272 = load i32, i32* %delta, align 4
  %idx.ext600 = sext i32 %272 to i64
  %add.ptr601 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr599, i64 %idx.ext600
  store %struct.bpf_insn* %add.ptr601, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end602:                                        ; preds = %if.end499
  %273 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm603 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %273, i32 0, i32 3
  %274 = load i32, i32* %imm603, align 4
  %cmp604 = icmp eq i32 %274, 170
  br i1 %cmp604, label %if.then606, label %if.end655

if.then606:                                       ; preds = %if.end602
  %arrayinit.begin607 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_addrs, i64 0, i64 0
  %code608 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin607, i32 0, i32 0
  store i8 24, i8* %code608, align 8
  %dst_reg609 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin607, i32 0, i32 1
  %bf.load610 = load i8, i8* %dst_reg609, align 1
  %bf.clear611 = and i8 %bf.load610, -16
  %bf.set612 = or i8 %bf.clear611, 3
  store i8 %bf.set612, i8* %dst_reg609, align 1
  %src_reg613 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin607, i32 0, i32 1
  %bf.load614 = load i8, i8* %src_reg613, align 1
  %bf.clear615 = and i8 %bf.load614, 15
  %bf.set616 = or i8 %bf.clear615, 0
  store i8 %bf.set616, i8* %src_reg613, align 1
  %off617 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin607, i32 0, i32 2
  store i16 0, i16* %off617, align 2
  %imm618 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin607, i32 0, i32 3
  %275 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux619 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %275, i32 0, i32 10
  %276 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux619, align 8
  %277 = ptrtoint %struct.bpf_prog_aux* %276 to i64
  %conv620 = trunc i64 %277 to i32
  store i32 %conv620, i32* %imm618, align 4
  %arrayinit.element621 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin607, i64 1
  %code622 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element621, i32 0, i32 0
  store i8 0, i8* %code622, align 8
  %dst_reg623 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element621, i32 0, i32 1
  %bf.load624 = load i8, i8* %dst_reg623, align 1
  %bf.clear625 = and i8 %bf.load624, -16
  %bf.set626 = or i8 %bf.clear625, 0
  store i8 %bf.set626, i8* %dst_reg623, align 1
  %src_reg627 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element621, i32 0, i32 1
  %bf.load628 = load i8, i8* %src_reg627, align 1
  %bf.clear629 = and i8 %bf.load628, 15
  %bf.set630 = or i8 %bf.clear629, 0
  store i8 %bf.set630, i8* %src_reg627, align 1
  %off631 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element621, i32 0, i32 2
  store i16 0, i16* %off631, align 2
  %imm632 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element621, i32 0, i32 3
  %278 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux633 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %278, i32 0, i32 10
  %279 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux633, align 8
  %280 = ptrtoint %struct.bpf_prog_aux* %279 to i64
  %shr = lshr i64 %280, 32
  %conv634 = trunc i64 %shr to i32
  store i32 %conv634, i32* %imm632, align 4
  %arrayidx635 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %arrayidx636 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_addrs, i64 0, i64 0
  %281 = bitcast %struct.bpf_insn* %arrayidx635 to i8*
  %282 = bitcast %struct.bpf_insn* %arrayidx636 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %281, i8* align 16 %282, i64 8, i1 false)
  %arrayidx637 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 1
  %arrayidx638 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_addrs, i64 0, i64 1
  %283 = bitcast %struct.bpf_insn* %arrayidx637 to i8*
  %284 = bitcast %struct.bpf_insn* %arrayidx638 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %283, i8* align 8 %284, i64 8, i1 false)
  %arrayidx639 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 2
  %285 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %286 = bitcast %struct.bpf_insn* %arrayidx639 to i8*
  %287 = bitcast %struct.bpf_insn* %285 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %286, i8* align 4 %287, i64 8, i1 false)
  store i32 3, i32* %cnt, align 4
  %288 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %289 = load i32, i32* %i, align 4
  %290 = load i32, i32* %delta, align 4
  %add640 = add i32 %289, %290
  %arraydecay641 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %291 = load i32, i32* %cnt, align 4
  %call642 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %288, i32 noundef %add640, %struct.bpf_insn* noundef %arraydecay641, i32 noundef %291) #20
  store %struct.bpf_prog* %call642, %struct.bpf_prog** %new_prog, align 8
  %292 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool643 = icmp ne %struct.bpf_prog* %292, null
  br i1 %tobool643, label %if.end645, label %if.then644

if.then644:                                       ; preds = %if.then606
  store i32 -12, i32* %retval, align 4
  br label %return

if.end645:                                        ; preds = %if.then606
  %293 = load i32, i32* %cnt, align 4
  %sub646 = sub i32 %293, 1
  %294 = load i32, i32* %delta, align 4
  %add647 = add i32 %294, %sub646
  store i32 %add647, i32* %delta, align 4
  %295 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %295, %struct.bpf_prog** %prog, align 8
  %296 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog648 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %296, i32 0, i32 2
  store %struct.bpf_prog* %295, %struct.bpf_prog** %prog648, align 8
  %297 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %298 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %297, i32 0, i32 12
  %299 = bitcast %union.anon.198* %298 to %struct.anon.201*
  %insnsi649 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %299, i32 0, i32 1
  %arraydecay650 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi649, i64 0, i64 0
  %300 = load i32, i32* %i, align 4
  %idx.ext651 = sext i32 %300 to i64
  %add.ptr652 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay650, i64 %idx.ext651
  %301 = load i32, i32* %delta, align 4
  %idx.ext653 = sext i32 %301 to i64
  %add.ptr654 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr652, i64 %idx.ext653
  store %struct.bpf_insn* %add.ptr654, %struct.bpf_insn** %insn, align 8
  br label %patch_call_imm

if.end655:                                        ; preds = %if.end602
  %302 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm656 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %302, i32 0, i32 3
  %303 = load i32, i32* %imm656, align 4
  %cmp657 = icmp eq i32 %303, 156
  br i1 %cmp657, label %if.then667, label %lor.lhs.false659

lor.lhs.false659:                                 ; preds = %if.end655
  %304 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm660 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %304, i32 0, i32 3
  %305 = load i32, i32* %imm660, align 4
  %cmp661 = icmp eq i32 %305, 107
  br i1 %cmp661, label %if.then667, label %lor.lhs.false663

lor.lhs.false663:                                 ; preds = %lor.lhs.false659
  %306 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm664 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %306, i32 0, i32 3
  %307 = load i32, i32* %imm664, align 4
  %cmp665 = icmp eq i32 %307, 145
  br i1 %cmp665, label %if.then667, label %if.end716

if.then667:                                       ; preds = %lor.lhs.false663, %lor.lhs.false659, %if.end655
  %308 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog668 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %308, i32 0, i32 2
  %309 = load %struct.bpf_prog*, %struct.bpf_prog** %prog668, align 8
  %aux669 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %309, i32 0, i32 10
  %310 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux669, align 8
  %sleepable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %310, i32 0, i32 25
  %311 = load i8, i8* %sleepable, align 4
  %tobool670 = trunc i8 %311 to i1
  br i1 %tobool670, label %if.then671, label %if.else685

if.then671:                                       ; preds = %if.then667
  %arrayidx672 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code674 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral673, i32 0, i32 0
  store i8 -73, i8* %code674, align 4
  %dst_reg675 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral673, i32 0, i32 1
  %bf.load676 = load i8, i8* %dst_reg675, align 1
  %bf.clear677 = and i8 %bf.load676, -16
  %bf.set678 = or i8 %bf.clear677, 5
  store i8 %bf.set678, i8* %dst_reg675, align 1
  %src_reg679 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral673, i32 0, i32 1
  %bf.load680 = load i8, i8* %src_reg679, align 1
  %bf.clear681 = and i8 %bf.load680, 15
  %bf.set682 = or i8 %bf.clear681, 0
  store i8 %bf.set682, i8* %src_reg679, align 1
  %off683 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral673, i32 0, i32 2
  store i16 0, i16* %off683, align 2
  %imm684 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral673, i32 0, i32 3
  store i32 3264, i32* %imm684, align 4
  %312 = bitcast %struct.bpf_insn* %arrayidx672 to i8*
  %313 = bitcast %struct.bpf_insn* %.compoundliteral673 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %312, i8* align 4 %313, i64 8, i1 false)
  br label %if.end699

if.else685:                                       ; preds = %if.then667
  %arrayidx686 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code688 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral687, i32 0, i32 0
  store i8 -73, i8* %code688, align 4
  %dst_reg689 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral687, i32 0, i32 1
  %bf.load690 = load i8, i8* %dst_reg689, align 1
  %bf.clear691 = and i8 %bf.load690, -16
  %bf.set692 = or i8 %bf.clear691, 5
  store i8 %bf.set692, i8* %dst_reg689, align 1
  %src_reg693 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral687, i32 0, i32 1
  %bf.load694 = load i8, i8* %src_reg693, align 1
  %bf.clear695 = and i8 %bf.load694, 15
  %bf.set696 = or i8 %bf.clear695, 0
  store i8 %bf.set696, i8* %src_reg693, align 1
  %off697 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral687, i32 0, i32 2
  store i16 0, i16* %off697, align 2
  %imm698 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral687, i32 0, i32 3
  store i32 2592, i32* %imm698, align 4
  %314 = bitcast %struct.bpf_insn* %arrayidx686 to i8*
  %315 = bitcast %struct.bpf_insn* %.compoundliteral687 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %314, i8* align 4 %315, i64 8, i1 false)
  br label %if.end699

if.end699:                                        ; preds = %if.else685, %if.then671
  %arrayidx700 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 1
  %316 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %317 = bitcast %struct.bpf_insn* %arrayidx700 to i8*
  %318 = bitcast %struct.bpf_insn* %316 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %317, i8* align 4 %318, i64 8, i1 false)
  store i32 2, i32* %cnt, align 4
  %319 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %320 = load i32, i32* %i, align 4
  %321 = load i32, i32* %delta, align 4
  %add701 = add i32 %320, %321
  %arraydecay702 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %322 = load i32, i32* %cnt, align 4
  %call703 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %319, i32 noundef %add701, %struct.bpf_insn* noundef %arraydecay702, i32 noundef %322) #20
  store %struct.bpf_prog* %call703, %struct.bpf_prog** %new_prog, align 8
  %323 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool704 = icmp ne %struct.bpf_prog* %323, null
  br i1 %tobool704, label %if.end706, label %if.then705

if.then705:                                       ; preds = %if.end699
  store i32 -12, i32* %retval, align 4
  br label %return

if.end706:                                        ; preds = %if.end699
  %324 = load i32, i32* %cnt, align 4
  %sub707 = sub i32 %324, 1
  %325 = load i32, i32* %delta, align 4
  %add708 = add i32 %325, %sub707
  store i32 %add708, i32* %delta, align 4
  %326 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %326, %struct.bpf_prog** %prog, align 8
  %327 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog709 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %327, i32 0, i32 2
  store %struct.bpf_prog* %326, %struct.bpf_prog** %prog709, align 8
  %328 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %329 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %328, i32 0, i32 12
  %330 = bitcast %union.anon.198* %329 to %struct.anon.201*
  %insnsi710 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %330, i32 0, i32 1
  %arraydecay711 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi710, i64 0, i64 0
  %331 = load i32, i32* %i, align 4
  %idx.ext712 = sext i32 %331 to i64
  %add.ptr713 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay711, i64 %idx.ext712
  %332 = load i32, i32* %delta, align 4
  %idx.ext714 = sext i32 %332 to i64
  %add.ptr715 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr713, i64 %idx.ext714
  store %struct.bpf_insn* %add.ptr715, %struct.bpf_insn** %insn, align 8
  br label %patch_call_imm

if.end716:                                        ; preds = %lor.lhs.false663
  %333 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested717 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %333, i32 0, i32 1
  %bf.load718 = load i16, i16* %jit_requested717, align 2
  %bf.lshr719 = lshr i16 %bf.load718, 1
  %bf.clear720 = and i16 %bf.lshr719, 1
  %conv721 = zext i16 %bf.clear720 to i32
  %tobool722 = icmp ne i32 %conv721, 0
  br i1 %tobool722, label %land.lhs.true723, label %if.end868

land.lhs.true723:                                 ; preds = %if.end716
  %334 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm724 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %334, i32 0, i32 3
  %335 = load i32, i32* %imm724, align 4
  %cmp725 = icmp eq i32 %335, 1
  br i1 %cmp725, label %if.then759, label %lor.lhs.false727

lor.lhs.false727:                                 ; preds = %land.lhs.true723
  %336 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm728 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %336, i32 0, i32 3
  %337 = load i32, i32* %imm728, align 4
  %cmp729 = icmp eq i32 %337, 2
  br i1 %cmp729, label %if.then759, label %lor.lhs.false731

lor.lhs.false731:                                 ; preds = %lor.lhs.false727
  %338 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm732 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %338, i32 0, i32 3
  %339 = load i32, i32* %imm732, align 4
  %cmp733 = icmp eq i32 %339, 3
  br i1 %cmp733, label %if.then759, label %lor.lhs.false735

lor.lhs.false735:                                 ; preds = %lor.lhs.false731
  %340 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm736 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %340, i32 0, i32 3
  %341 = load i32, i32* %imm736, align 4
  %cmp737 = icmp eq i32 %341, 87
  br i1 %cmp737, label %if.then759, label %lor.lhs.false739

lor.lhs.false739:                                 ; preds = %lor.lhs.false735
  %342 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm740 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %342, i32 0, i32 3
  %343 = load i32, i32* %imm740, align 4
  %cmp741 = icmp eq i32 %343, 88
  br i1 %cmp741, label %if.then759, label %lor.lhs.false743

lor.lhs.false743:                                 ; preds = %lor.lhs.false739
  %344 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm744 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %344, i32 0, i32 3
  %345 = load i32, i32* %imm744, align 4
  %cmp745 = icmp eq i32 %345, 89
  br i1 %cmp745, label %if.then759, label %lor.lhs.false747

lor.lhs.false747:                                 ; preds = %lor.lhs.false743
  %346 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm748 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %346, i32 0, i32 3
  %347 = load i32, i32* %imm748, align 4
  %cmp749 = icmp eq i32 %347, 51
  br i1 %cmp749, label %if.then759, label %lor.lhs.false751

lor.lhs.false751:                                 ; preds = %lor.lhs.false747
  %348 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm752 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %348, i32 0, i32 3
  %349 = load i32, i32* %imm752, align 4
  %cmp753 = icmp eq i32 %349, 164
  br i1 %cmp753, label %if.then759, label %lor.lhs.false755

lor.lhs.false755:                                 ; preds = %lor.lhs.false751
  %350 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm756 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %350, i32 0, i32 3
  %351 = load i32, i32* %imm756, align 4
  %cmp757 = icmp eq i32 %351, 195
  br i1 %cmp757, label %if.then759, label %if.end868

if.then759:                                       ; preds = %lor.lhs.false755, %lor.lhs.false751, %lor.lhs.false747, %lor.lhs.false743, %lor.lhs.false739, %lor.lhs.false735, %lor.lhs.false731, %lor.lhs.false727, %land.lhs.true723
  %352 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data760 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %352, i32 0, i32 24
  %353 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data760, align 8
  %354 = load i32, i32* %i, align 4
  %355 = load i32, i32* %delta, align 4
  %add761 = add i32 %354, %355
  %idxprom762 = sext i32 %add761 to i64
  %arrayidx763 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %353, i64 %idxprom762
  store %struct.bpf_insn_aux_data* %arrayidx763, %struct.bpf_insn_aux_data** %aux, align 8
  %356 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call764 = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %356) #20
  br i1 %call764, label %if.then765, label %if.end766

if.then765:                                       ; preds = %if.then759
  br label %patch_call_imm

if.end766:                                        ; preds = %if.then759
  %357 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %358 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %357, i32 0, i32 0
  %map_ptr_state767 = bitcast %union.anon.210* %358 to i64*
  %359 = load i64, i64* %map_ptr_state767, align 8
  %and768 = and i64 %359, -2
  %360 = inttoptr i64 %and768 to %struct.bpf_map*
  store %struct.bpf_map* %360, %struct.bpf_map** %map_ptr, align 8
  %361 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops769 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %361, i32 0, i32 0
  %362 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops769, align 64
  store %struct.bpf_map_ops* %362, %struct.bpf_map_ops** %ops, align 8
  %363 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm770 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %363, i32 0, i32 3
  %364 = load i32, i32* %imm770, align 4
  %cmp771 = icmp eq i32 %364, 1
  br i1 %cmp771, label %land.lhs.true773, label %if.end806

land.lhs.true773:                                 ; preds = %if.end766
  %365 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_gen_lookup = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %365, i32 0, i32 21
  %366 = load i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)** %map_gen_lookup, align 8
  %tobool774 = icmp ne i32 (%struct.bpf_map*, %struct.bpf_insn*)* %366, null
  br i1 %tobool774, label %if.then775, label %if.end806

if.then775:                                       ; preds = %land.lhs.true773
  %367 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_gen_lookup776 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %367, i32 0, i32 21
  %368 = load i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)** %map_gen_lookup776, align 8
  %369 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %arraydecay777 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %call778 = call i32 %368(%struct.bpf_map* noundef %369, %struct.bpf_insn* noundef %arraydecay777) #20
  store i32 %call778, i32* %cnt, align 4
  %370 = load i32, i32* %cnt, align 4
  %cmp779 = icmp eq i32 %370, -95
  br i1 %cmp779, label %if.then781, label %if.end782

if.then781:                                       ; preds = %if.then775
  br label %patch_map_ops_generic

if.end782:                                        ; preds = %if.then775
  %371 = load i32, i32* %cnt, align 4
  %cmp783 = icmp sle i32 %371, 0
  br i1 %cmp783, label %if.then789, label %lor.lhs.false785

lor.lhs.false785:                                 ; preds = %if.end782
  %372 = load i32, i32* %cnt, align 4
  %conv786 = sext i32 %372 to i64
  %cmp787 = icmp uge i64 %conv786, 16
  br i1 %cmp787, label %if.then789, label %if.end790

if.then789:                                       ; preds = %lor.lhs.false785, %if.end782
  %373 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %374 = bitcast %struct.bpf_verifier_env* %373 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %374, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.485, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end790:                                        ; preds = %lor.lhs.false785
  %375 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %376 = load i32, i32* %i, align 4
  %377 = load i32, i32* %delta, align 4
  %add791 = add i32 %376, %377
  %arraydecay792 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %378 = load i32, i32* %cnt, align 4
  %call793 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %375, i32 noundef %add791, %struct.bpf_insn* noundef %arraydecay792, i32 noundef %378) #20
  store %struct.bpf_prog* %call793, %struct.bpf_prog** %new_prog, align 8
  %379 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool794 = icmp ne %struct.bpf_prog* %379, null
  br i1 %tobool794, label %if.end796, label %if.then795

if.then795:                                       ; preds = %if.end790
  store i32 -12, i32* %retval, align 4
  br label %return

if.end796:                                        ; preds = %if.end790
  %380 = load i32, i32* %cnt, align 4
  %sub797 = sub i32 %380, 1
  %381 = load i32, i32* %delta, align 4
  %add798 = add i32 %381, %sub797
  store i32 %add798, i32* %delta, align 4
  %382 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %382, %struct.bpf_prog** %prog, align 8
  %383 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog799 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %383, i32 0, i32 2
  store %struct.bpf_prog* %382, %struct.bpf_prog** %prog799, align 8
  %384 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %385 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %384, i32 0, i32 12
  %386 = bitcast %union.anon.198* %385 to %struct.anon.201*
  %insnsi800 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %386, i32 0, i32 1
  %arraydecay801 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi800, i64 0, i64 0
  %387 = load i32, i32* %i, align 4
  %idx.ext802 = sext i32 %387 to i64
  %add.ptr803 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay801, i64 %idx.ext802
  %388 = load i32, i32* %delta, align 4
  %idx.ext804 = sext i32 %388 to i64
  %add.ptr805 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr803, i64 %idx.ext804
  store %struct.bpf_insn* %add.ptr805, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end806:                                        ; preds = %land.lhs.true773, %if.end766
  br label %do.body

do.body:                                          ; preds = %if.end806
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body807

do.body807:                                       ; preds = %do.end
  br label %do.end808

do.end808:                                        ; preds = %do.body807
  br label %do.body809

do.body809:                                       ; preds = %do.end808
  br label %do.end810

do.end810:                                        ; preds = %do.body809
  br label %do.body811

do.body811:                                       ; preds = %do.end810
  br label %do.end812

do.end812:                                        ; preds = %do.body811
  br label %do.body813

do.body813:                                       ; preds = %do.end812
  br label %do.end814

do.end814:                                        ; preds = %do.body813
  br label %do.body815

do.body815:                                       ; preds = %do.end814
  br label %do.end816

do.end816:                                        ; preds = %do.body815
  br label %do.body817

do.body817:                                       ; preds = %do.end816
  br label %do.end818

do.end818:                                        ; preds = %do.body817
  br label %do.body819

do.body819:                                       ; preds = %do.end818
  br label %do.end820

do.end820:                                        ; preds = %do.body819
  br label %do.body821

do.body821:                                       ; preds = %do.end820
  br label %do.end822

do.end822:                                        ; preds = %do.body821
  br label %patch_map_ops_generic

patch_map_ops_generic:                            ; preds = %do.end822, %if.then781
  %389 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm823 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %389, i32 0, i32 3
  %390 = load i32, i32* %imm823, align 4
  switch i32 %390, label %sw.epilog [
    i32 1, label %sw.bb
    i32 2, label %sw.bb828
    i32 3, label %sw.bb833
    i32 87, label %sw.bb838
    i32 88, label %sw.bb843
    i32 89, label %sw.bb848
    i32 51, label %sw.bb853
    i32 164, label %sw.bb858
    i32 195, label %sw.bb863
  ]

sw.bb:                                            ; preds = %patch_map_ops_generic
  %391 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_lookup_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %391, i32 0, i32 12
  %392 = load i8* (%struct.bpf_map*, i8*)*, i8* (%struct.bpf_map*, i8*)** %map_lookup_elem, align 8
  %393 = bitcast i8* (%struct.bpf_map*, i8*)* %392 to i8*
  %sub.ptr.lhs.cast824 = ptrtoint i8* %393 to i64
  %sub.ptr.sub825 = sub i64 %sub.ptr.lhs.cast824, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv826 = trunc i64 %sub.ptr.sub825 to i32
  %394 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm827 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %394, i32 0, i32 3
  store i32 %conv826, i32* %imm827, align 4
  br label %for.inc

sw.bb828:                                         ; preds = %patch_map_ops_generic
  %395 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_update_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %395, i32 0, i32 13
  %396 = load i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, i8*, i8*, i64)** %map_update_elem, align 8
  %397 = bitcast i32 (%struct.bpf_map*, i8*, i8*, i64)* %396 to i8*
  %sub.ptr.lhs.cast829 = ptrtoint i8* %397 to i64
  %sub.ptr.sub830 = sub i64 %sub.ptr.lhs.cast829, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv831 = trunc i64 %sub.ptr.sub830 to i32
  %398 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm832 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %398, i32 0, i32 3
  store i32 %conv831, i32* %imm832, align 4
  br label %for.inc

sw.bb833:                                         ; preds = %patch_map_ops_generic
  %399 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_delete_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %399, i32 0, i32 14
  %400 = load i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)** %map_delete_elem, align 8
  %401 = bitcast i32 (%struct.bpf_map*, i8*)* %400 to i8*
  %sub.ptr.lhs.cast834 = ptrtoint i8* %401 to i64
  %sub.ptr.sub835 = sub i64 %sub.ptr.lhs.cast834, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv836 = trunc i64 %sub.ptr.sub835 to i32
  %402 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm837 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %402, i32 0, i32 3
  store i32 %conv836, i32* %imm837, align 4
  br label %for.inc

sw.bb838:                                         ; preds = %patch_map_ops_generic
  %403 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_push_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %403, i32 0, i32 15
  %404 = load i32 (%struct.bpf_map*, i8*, i64)*, i32 (%struct.bpf_map*, i8*, i64)** %map_push_elem, align 8
  %405 = bitcast i32 (%struct.bpf_map*, i8*, i64)* %404 to i8*
  %sub.ptr.lhs.cast839 = ptrtoint i8* %405 to i64
  %sub.ptr.sub840 = sub i64 %sub.ptr.lhs.cast839, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv841 = trunc i64 %sub.ptr.sub840 to i32
  %406 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm842 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %406, i32 0, i32 3
  store i32 %conv841, i32* %imm842, align 4
  br label %for.inc

sw.bb843:                                         ; preds = %patch_map_ops_generic
  %407 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_pop_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %407, i32 0, i32 16
  %408 = load i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)** %map_pop_elem, align 8
  %409 = bitcast i32 (%struct.bpf_map*, i8*)* %408 to i8*
  %sub.ptr.lhs.cast844 = ptrtoint i8* %409 to i64
  %sub.ptr.sub845 = sub i64 %sub.ptr.lhs.cast844, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv846 = trunc i64 %sub.ptr.sub845 to i32
  %410 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm847 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %410, i32 0, i32 3
  store i32 %conv846, i32* %imm847, align 4
  br label %for.inc

sw.bb848:                                         ; preds = %patch_map_ops_generic
  %411 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_peek_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %411, i32 0, i32 17
  %412 = load i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)** %map_peek_elem, align 8
  %413 = bitcast i32 (%struct.bpf_map*, i8*)* %412 to i8*
  %sub.ptr.lhs.cast849 = ptrtoint i8* %413 to i64
  %sub.ptr.sub850 = sub i64 %sub.ptr.lhs.cast849, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv851 = trunc i64 %sub.ptr.sub850 to i32
  %414 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm852 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %414, i32 0, i32 3
  store i32 %conv851, i32* %imm852, align 4
  br label %for.inc

sw.bb853:                                         ; preds = %patch_map_ops_generic
  %415 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_redirect = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %415, i32 0, i32 35
  %416 = load i32 (%struct.bpf_map*, i32, i64)*, i32 (%struct.bpf_map*, i32, i64)** %map_redirect, align 8
  %417 = bitcast i32 (%struct.bpf_map*, i32, i64)* %416 to i8*
  %sub.ptr.lhs.cast854 = ptrtoint i8* %417 to i64
  %sub.ptr.sub855 = sub i64 %sub.ptr.lhs.cast854, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv856 = trunc i64 %sub.ptr.sub855 to i32
  %418 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm857 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %418, i32 0, i32 3
  store i32 %conv856, i32* %imm857, align 4
  br label %for.inc

sw.bb858:                                         ; preds = %patch_map_ops_generic
  %419 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_for_each_callback = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %419, i32 0, i32 38
  %420 = load i32 (%struct.bpf_map*, i64 (i64, i64, i64, i64, i64)*, i8*, i64)*, i32 (%struct.bpf_map*, i64 (i64, i64, i64, i64, i64)*, i8*, i64)** %map_for_each_callback, align 8
  %421 = bitcast i32 (%struct.bpf_map*, i64 (i64, i64, i64, i64, i64)*, i8*, i64)* %420 to i8*
  %sub.ptr.lhs.cast859 = ptrtoint i8* %421 to i64
  %sub.ptr.sub860 = sub i64 %sub.ptr.lhs.cast859, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv861 = trunc i64 %sub.ptr.sub860 to i32
  %422 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm862 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %422, i32 0, i32 3
  store i32 %conv861, i32* %imm862, align 4
  br label %for.inc

sw.bb863:                                         ; preds = %patch_map_ops_generic
  %423 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_lookup_percpu_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %423, i32 0, i32 18
  %424 = load i8* (%struct.bpf_map*, i8*, i32)*, i8* (%struct.bpf_map*, i8*, i32)** %map_lookup_percpu_elem, align 8
  %425 = bitcast i8* (%struct.bpf_map*, i8*, i32)* %424 to i8*
  %sub.ptr.lhs.cast864 = ptrtoint i8* %425 to i64
  %sub.ptr.sub865 = sub i64 %sub.ptr.lhs.cast864, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv866 = trunc i64 %sub.ptr.sub865 to i32
  %426 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm867 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %426, i32 0, i32 3
  store i32 %conv866, i32* %imm867, align 4
  br label %for.inc

sw.epilog:                                        ; preds = %patch_map_ops_generic
  br label %patch_call_imm

if.end868:                                        ; preds = %lor.lhs.false755, %if.end716
  %427 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested869 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %427, i32 0, i32 1
  %bf.load870 = load i16, i16* %jit_requested869, align 2
  %bf.lshr871 = lshr i16 %bf.load870, 1
  %bf.clear872 = and i16 %bf.lshr871, 1
  %conv873 = zext i16 %bf.clear872 to i32
  %tobool874 = icmp ne i32 %conv873, 0
  br i1 %tobool874, label %land.lhs.true875, label %if.end936

land.lhs.true875:                                 ; preds = %if.end868
  %428 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm876 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %428, i32 0, i32 3
  %429 = load i32, i32* %imm876, align 4
  %cmp877 = icmp eq i32 %429, 118
  br i1 %cmp877, label %if.then879, label %if.end936

if.then879:                                       ; preds = %land.lhs.true875
  %arrayinit.begin880 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_jiffies_addr, i64 0, i64 0
  %code881 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin880, i32 0, i32 0
  store i8 24, i8* %code881, align 8
  %dst_reg882 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin880, i32 0, i32 1
  %bf.load883 = load i8, i8* %dst_reg882, align 1
  %bf.clear884 = and i8 %bf.load883, -16
  %bf.set885 = or i8 %bf.clear884, 0
  store i8 %bf.set885, i8* %dst_reg882, align 1
  %src_reg886 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin880, i32 0, i32 1
  %bf.load887 = load i8, i8* %src_reg886, align 1
  %bf.clear888 = and i8 %bf.load887, 15
  %bf.set889 = or i8 %bf.clear888, 0
  store i8 %bf.set889, i8* %src_reg886, align 1
  %off890 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin880, i32 0, i32 2
  store i16 0, i16* %off890, align 2
  %imm891 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin880, i32 0, i32 3
  store i32 ptrtoint (i64* @jiffies to i32), i32* %imm891, align 4
  %arrayinit.element892 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin880, i64 1
  %code893 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element892, i32 0, i32 0
  store i8 0, i8* %code893, align 8
  %dst_reg894 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element892, i32 0, i32 1
  %bf.load895 = load i8, i8* %dst_reg894, align 1
  %bf.clear896 = and i8 %bf.load895, -16
  %bf.set897 = or i8 %bf.clear896, 0
  store i8 %bf.set897, i8* %dst_reg894, align 1
  %src_reg898 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element892, i32 0, i32 1
  %bf.load899 = load i8, i8* %src_reg898, align 1
  %bf.clear900 = and i8 %bf.load899, 15
  %bf.set901 = or i8 %bf.clear900, 0
  store i8 %bf.set901, i8* %src_reg898, align 1
  %off902 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element892, i32 0, i32 2
  store i16 0, i16* %off902, align 2
  %imm903 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element892, i32 0, i32 3
  store i32 trunc (i64 lshr (i64 ptrtoint (i64* @jiffies to i64), i64 32) to i32), i32* %imm903, align 4
  %arrayidx904 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %arrayidx905 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_jiffies_addr, i64 0, i64 0
  %430 = bitcast %struct.bpf_insn* %arrayidx904 to i8*
  %431 = bitcast %struct.bpf_insn* %arrayidx905 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %430, i8* align 16 %431, i64 8, i1 false)
  %arrayidx906 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 1
  %arrayidx907 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_jiffies_addr, i64 0, i64 1
  %432 = bitcast %struct.bpf_insn* %arrayidx906 to i8*
  %433 = bitcast %struct.bpf_insn* %arrayidx907 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %432, i8* align 8 %433, i64 8, i1 false)
  %arrayidx908 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 2
  %code910 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral909, i32 0, i32 0
  store i8 121, i8* %code910, align 4
  %dst_reg911 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral909, i32 0, i32 1
  %bf.load912 = load i8, i8* %dst_reg911, align 1
  %bf.clear913 = and i8 %bf.load912, -16
  %bf.set914 = or i8 %bf.clear913, 0
  store i8 %bf.set914, i8* %dst_reg911, align 1
  %src_reg915 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral909, i32 0, i32 1
  %bf.load916 = load i8, i8* %src_reg915, align 1
  %bf.clear917 = and i8 %bf.load916, 15
  %bf.set918 = or i8 %bf.clear917, 0
  store i8 %bf.set918, i8* %src_reg915, align 1
  %off919 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral909, i32 0, i32 2
  store i16 0, i16* %off919, align 2
  %imm920 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral909, i32 0, i32 3
  store i32 0, i32* %imm920, align 4
  %434 = bitcast %struct.bpf_insn* %arrayidx908 to i8*
  %435 = bitcast %struct.bpf_insn* %.compoundliteral909 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %434, i8* align 4 %435, i64 8, i1 false)
  store i32 3, i32* %cnt, align 4
  %436 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %437 = load i32, i32* %i, align 4
  %438 = load i32, i32* %delta, align 4
  %add921 = add i32 %437, %438
  %arraydecay922 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %439 = load i32, i32* %cnt, align 4
  %call923 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %436, i32 noundef %add921, %struct.bpf_insn* noundef %arraydecay922, i32 noundef %439) #20
  store %struct.bpf_prog* %call923, %struct.bpf_prog** %new_prog, align 8
  %440 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool924 = icmp ne %struct.bpf_prog* %440, null
  br i1 %tobool924, label %if.end926, label %if.then925

if.then925:                                       ; preds = %if.then879
  store i32 -12, i32* %retval, align 4
  br label %return

if.end926:                                        ; preds = %if.then879
  %441 = load i32, i32* %cnt, align 4
  %sub927 = sub i32 %441, 1
  %442 = load i32, i32* %delta, align 4
  %add928 = add i32 %442, %sub927
  store i32 %add928, i32* %delta, align 4
  %443 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %443, %struct.bpf_prog** %prog, align 8
  %444 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog929 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %444, i32 0, i32 2
  store %struct.bpf_prog* %443, %struct.bpf_prog** %prog929, align 8
  %445 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %446 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %445, i32 0, i32 12
  %447 = bitcast %union.anon.198* %446 to %struct.anon.201*
  %insnsi930 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %447, i32 0, i32 1
  %arraydecay931 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi930, i64 0, i64 0
  %448 = load i32, i32* %i, align 4
  %idx.ext932 = sext i32 %448 to i64
  %add.ptr933 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay931, i64 %idx.ext932
  %449 = load i32, i32* %delta, align 4
  %idx.ext934 = sext i32 %449 to i64
  %add.ptr935 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr933, i64 %idx.ext934
  store %struct.bpf_insn* %add.ptr935, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end936:                                        ; preds = %land.lhs.true875, %if.end868
  %450 = load i32, i32* %prog_type, align 4
  %cmp937 = icmp eq i32 %450, 26
  br i1 %cmp937, label %land.lhs.true939, label %if.end1076

land.lhs.true939:                                 ; preds = %if.end936
  %451 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm940 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %451, i32 0, i32 3
  %452 = load i32, i32* %imm940, align 4
  %cmp941 = icmp eq i32 %452, 183
  br i1 %cmp941, label %if.then943, label %if.end1076

if.then943:                                       ; preds = %land.lhs.true939
  %arrayidx944 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code946 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral945, i32 0, i32 0
  store i8 121, i8* %code946, align 4
  %dst_reg947 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral945, i32 0, i32 1
  %bf.load948 = load i8, i8* %dst_reg947, align 1
  %bf.clear949 = and i8 %bf.load948, -16
  %bf.set950 = or i8 %bf.clear949, 0
  store i8 %bf.set950, i8* %dst_reg947, align 1
  %src_reg951 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral945, i32 0, i32 1
  %bf.load952 = load i8, i8* %src_reg951, align 1
  %bf.clear953 = and i8 %bf.load952, 15
  %bf.set954 = or i8 %bf.clear953, 16
  store i8 %bf.set954, i8* %src_reg951, align 1
  %off955 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral945, i32 0, i32 2
  store i16 -8, i16* %off955, align 2
  %imm956 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral945, i32 0, i32 3
  store i32 0, i32* %imm956, align 4
  %453 = bitcast %struct.bpf_insn* %arrayidx944 to i8*
  %454 = bitcast %struct.bpf_insn* %.compoundliteral945 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %453, i8* align 4 %454, i64 8, i1 false)
  %arrayidx957 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 1
  %code959 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral958, i32 0, i32 0
  store i8 62, i8* %code959, align 4
  %dst_reg960 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral958, i32 0, i32 1
  %bf.load961 = load i8, i8* %dst_reg960, align 1
  %bf.clear962 = and i8 %bf.load961, -16
  %bf.set963 = or i8 %bf.clear962, 2
  store i8 %bf.set963, i8* %dst_reg960, align 1
  %src_reg964 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral958, i32 0, i32 1
  %bf.load965 = load i8, i8* %src_reg964, align 1
  %bf.clear966 = and i8 %bf.load965, 15
  %bf.set967 = or i8 %bf.clear966, 0
  store i8 %bf.set967, i8* %src_reg964, align 1
  %off968 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral958, i32 0, i32 2
  store i16 6, i16* %off968, align 2
  %imm969 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral958, i32 0, i32 3
  store i32 0, i32* %imm969, align 4
  %455 = bitcast %struct.bpf_insn* %arrayidx957 to i8*
  %456 = bitcast %struct.bpf_insn* %.compoundliteral958 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %455, i8* align 4 %456, i64 8, i1 false)
  %arrayidx970 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 2
  %code972 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral971, i32 0, i32 0
  store i8 103, i8* %code972, align 4
  %dst_reg973 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral971, i32 0, i32 1
  %bf.load974 = load i8, i8* %dst_reg973, align 1
  %bf.clear975 = and i8 %bf.load974, -16
  %bf.set976 = or i8 %bf.clear975, 2
  store i8 %bf.set976, i8* %dst_reg973, align 1
  %src_reg977 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral971, i32 0, i32 1
  %bf.load978 = load i8, i8* %src_reg977, align 1
  %bf.clear979 = and i8 %bf.load978, 15
  %bf.set980 = or i8 %bf.clear979, 0
  store i8 %bf.set980, i8* %src_reg977, align 1
  %off981 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral971, i32 0, i32 2
  store i16 0, i16* %off981, align 2
  %imm982 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral971, i32 0, i32 3
  store i32 3, i32* %imm982, align 4
  %457 = bitcast %struct.bpf_insn* %arrayidx970 to i8*
  %458 = bitcast %struct.bpf_insn* %.compoundliteral971 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %457, i8* align 4 %458, i64 8, i1 false)
  %arrayidx983 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 3
  %code985 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral984, i32 0, i32 0
  store i8 15, i8* %code985, align 4
  %dst_reg986 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral984, i32 0, i32 1
  %bf.load987 = load i8, i8* %dst_reg986, align 1
  %bf.clear988 = and i8 %bf.load987, -16
  %bf.set989 = or i8 %bf.clear988, 2
  store i8 %bf.set989, i8* %dst_reg986, align 1
  %src_reg990 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral984, i32 0, i32 1
  %bf.load991 = load i8, i8* %src_reg990, align 1
  %bf.clear992 = and i8 %bf.load991, 15
  %bf.set993 = or i8 %bf.clear992, 16
  store i8 %bf.set993, i8* %src_reg990, align 1
  %off994 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral984, i32 0, i32 2
  store i16 0, i16* %off994, align 2
  %imm995 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral984, i32 0, i32 3
  store i32 0, i32* %imm995, align 4
  %459 = bitcast %struct.bpf_insn* %arrayidx983 to i8*
  %460 = bitcast %struct.bpf_insn* %.compoundliteral984 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %459, i8* align 4 %460, i64 8, i1 false)
  %arrayidx996 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 4
  %code998 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral997, i32 0, i32 0
  store i8 121, i8* %code998, align 4
  %dst_reg999 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral997, i32 0, i32 1
  %bf.load1000 = load i8, i8* %dst_reg999, align 1
  %bf.clear1001 = and i8 %bf.load1000, -16
  %bf.set1002 = or i8 %bf.clear1001, 0
  store i8 %bf.set1002, i8* %dst_reg999, align 1
  %src_reg1003 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral997, i32 0, i32 1
  %bf.load1004 = load i8, i8* %src_reg1003, align 1
  %bf.clear1005 = and i8 %bf.load1004, 15
  %bf.set1006 = or i8 %bf.clear1005, 32
  store i8 %bf.set1006, i8* %src_reg1003, align 1
  %off1007 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral997, i32 0, i32 2
  store i16 0, i16* %off1007, align 2
  %imm1008 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral997, i32 0, i32 3
  store i32 0, i32* %imm1008, align 4
  %461 = bitcast %struct.bpf_insn* %arrayidx996 to i8*
  %462 = bitcast %struct.bpf_insn* %.compoundliteral997 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %461, i8* align 4 %462, i64 8, i1 false)
  %arrayidx1009 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 5
  %code1011 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1010, i32 0, i32 0
  store i8 123, i8* %code1011, align 4
  %dst_reg1012 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1010, i32 0, i32 1
  %bf.load1013 = load i8, i8* %dst_reg1012, align 1
  %bf.clear1014 = and i8 %bf.load1013, -16
  %bf.set1015 = or i8 %bf.clear1014, 3
  store i8 %bf.set1015, i8* %dst_reg1012, align 1
  %src_reg1016 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1010, i32 0, i32 1
  %bf.load1017 = load i8, i8* %src_reg1016, align 1
  %bf.clear1018 = and i8 %bf.load1017, 15
  %bf.set1019 = or i8 %bf.clear1018, 0
  store i8 %bf.set1019, i8* %src_reg1016, align 1
  %off1020 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1010, i32 0, i32 2
  store i16 0, i16* %off1020, align 2
  %imm1021 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1010, i32 0, i32 3
  store i32 0, i32* %imm1021, align 4
  %463 = bitcast %struct.bpf_insn* %arrayidx1009 to i8*
  %464 = bitcast %struct.bpf_insn* %.compoundliteral1010 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %463, i8* align 4 %464, i64 8, i1 false)
  %arrayidx1022 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 6
  %code1024 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1023, i32 0, i32 0
  store i8 -73, i8* %code1024, align 4
  %dst_reg1025 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1023, i32 0, i32 1
  %bf.load1026 = load i8, i8* %dst_reg1025, align 1
  %bf.clear1027 = and i8 %bf.load1026, -16
  %bf.set1028 = or i8 %bf.clear1027, 0
  store i8 %bf.set1028, i8* %dst_reg1025, align 1
  %src_reg1029 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1023, i32 0, i32 1
  %bf.load1030 = load i8, i8* %src_reg1029, align 1
  %bf.clear1031 = and i8 %bf.load1030, 15
  %bf.set1032 = or i8 %bf.clear1031, 0
  store i8 %bf.set1032, i8* %src_reg1029, align 1
  %off1033 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1023, i32 0, i32 2
  store i16 0, i16* %off1033, align 2
  %imm1034 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1023, i32 0, i32 3
  store i32 0, i32* %imm1034, align 4
  %465 = bitcast %struct.bpf_insn* %arrayidx1022 to i8*
  %466 = bitcast %struct.bpf_insn* %.compoundliteral1023 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %465, i8* align 4 %466, i64 8, i1 false)
  %arrayidx1035 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 7
  %code1037 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1036, i32 0, i32 0
  store i8 5, i8* %code1037, align 4
  %dst_reg1038 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1036, i32 0, i32 1
  %bf.load1039 = load i8, i8* %dst_reg1038, align 1
  %bf.clear1040 = and i8 %bf.load1039, -16
  %bf.set1041 = or i8 %bf.clear1040, 0
  store i8 %bf.set1041, i8* %dst_reg1038, align 1
  %src_reg1042 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1036, i32 0, i32 1
  %bf.load1043 = load i8, i8* %src_reg1042, align 1
  %bf.clear1044 = and i8 %bf.load1043, 15
  %bf.set1045 = or i8 %bf.clear1044, 0
  store i8 %bf.set1045, i8* %src_reg1042, align 1
  %off1046 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1036, i32 0, i32 2
  store i16 1, i16* %off1046, align 2
  %imm1047 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1036, i32 0, i32 3
  store i32 0, i32* %imm1047, align 4
  %467 = bitcast %struct.bpf_insn* %arrayidx1035 to i8*
  %468 = bitcast %struct.bpf_insn* %.compoundliteral1036 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %467, i8* align 4 %468, i64 8, i1 false)
  %arrayidx1048 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 8
  %code1050 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1049, i32 0, i32 0
  store i8 -73, i8* %code1050, align 4
  %dst_reg1051 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1049, i32 0, i32 1
  %bf.load1052 = load i8, i8* %dst_reg1051, align 1
  %bf.clear1053 = and i8 %bf.load1052, -16
  %bf.set1054 = or i8 %bf.clear1053, 0
  store i8 %bf.set1054, i8* %dst_reg1051, align 1
  %src_reg1055 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1049, i32 0, i32 1
  %bf.load1056 = load i8, i8* %src_reg1055, align 1
  %bf.clear1057 = and i8 %bf.load1056, 15
  %bf.set1058 = or i8 %bf.clear1057, 0
  store i8 %bf.set1058, i8* %src_reg1055, align 1
  %off1059 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1049, i32 0, i32 2
  store i16 0, i16* %off1059, align 2
  %imm1060 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1049, i32 0, i32 3
  store i32 -22, i32* %imm1060, align 4
  %469 = bitcast %struct.bpf_insn* %arrayidx1048 to i8*
  %470 = bitcast %struct.bpf_insn* %.compoundliteral1049 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %469, i8* align 4 %470, i64 8, i1 false)
  store i32 9, i32* %cnt, align 4
  %471 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %472 = load i32, i32* %i, align 4
  %473 = load i32, i32* %delta, align 4
  %add1061 = add i32 %472, %473
  %arraydecay1062 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %474 = load i32, i32* %cnt, align 4
  %call1063 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %471, i32 noundef %add1061, %struct.bpf_insn* noundef %arraydecay1062, i32 noundef %474) #20
  store %struct.bpf_prog* %call1063, %struct.bpf_prog** %new_prog, align 8
  %475 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool1064 = icmp ne %struct.bpf_prog* %475, null
  br i1 %tobool1064, label %if.end1066, label %if.then1065

if.then1065:                                      ; preds = %if.then943
  store i32 -12, i32* %retval, align 4
  br label %return

if.end1066:                                       ; preds = %if.then943
  %476 = load i32, i32* %cnt, align 4
  %sub1067 = sub i32 %476, 1
  %477 = load i32, i32* %delta, align 4
  %add1068 = add i32 %477, %sub1067
  store i32 %add1068, i32* %delta, align 4
  %478 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %478, %struct.bpf_prog** %prog, align 8
  %479 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1069 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %479, i32 0, i32 2
  store %struct.bpf_prog* %478, %struct.bpf_prog** %prog1069, align 8
  %480 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %481 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %480, i32 0, i32 12
  %482 = bitcast %union.anon.198* %481 to %struct.anon.201*
  %insnsi1070 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %482, i32 0, i32 1
  %arraydecay1071 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi1070, i64 0, i64 0
  %483 = load i32, i32* %i, align 4
  %idx.ext1072 = sext i32 %483 to i64
  %add.ptr1073 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay1071, i64 %idx.ext1072
  %484 = load i32, i32* %delta, align 4
  %idx.ext1074 = sext i32 %484 to i64
  %add.ptr1075 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr1073, i64 %idx.ext1074
  store %struct.bpf_insn* %add.ptr1075, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end1076:                                       ; preds = %land.lhs.true939, %if.end936
  %485 = load i32, i32* %prog_type, align 4
  %cmp1077 = icmp eq i32 %485, 26
  br i1 %cmp1077, label %land.lhs.true1079, label %if.end1198

land.lhs.true1079:                                ; preds = %if.end1076
  %486 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm1080 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %486, i32 0, i32 3
  %487 = load i32, i32* %imm1080, align 4
  %cmp1081 = icmp eq i32 %487, 184
  br i1 %cmp1081, label %if.then1083, label %if.end1198

if.then1083:                                      ; preds = %land.lhs.true1079
  %488 = load i32, i32* %eatype, align 4
  %cmp1084 = icmp eq i32 %488, 25
  br i1 %cmp1084, label %if.then1089, label %lor.lhs.false1086

lor.lhs.false1086:                                ; preds = %if.then1083
  %489 = load i32, i32* %eatype, align 4
  %cmp1087 = icmp eq i32 %489, 26
  br i1 %cmp1087, label %if.then1089, label %if.else1168

if.then1089:                                      ; preds = %lor.lhs.false1086, %if.then1083
  %arrayidx1090 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code1092 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1091, i32 0, i32 0
  store i8 121, i8* %code1092, align 4
  %dst_reg1093 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1091, i32 0, i32 1
  %bf.load1094 = load i8, i8* %dst_reg1093, align 1
  %bf.clear1095 = and i8 %bf.load1094, -16
  %bf.set1096 = or i8 %bf.clear1095, 0
  store i8 %bf.set1096, i8* %dst_reg1093, align 1
  %src_reg1097 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1091, i32 0, i32 1
  %bf.load1098 = load i8, i8* %src_reg1097, align 1
  %bf.clear1099 = and i8 %bf.load1098, 15
  %bf.set1100 = or i8 %bf.clear1099, 16
  store i8 %bf.set1100, i8* %src_reg1097, align 1
  %off1101 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1091, i32 0, i32 2
  store i16 -8, i16* %off1101, align 2
  %imm1102 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1091, i32 0, i32 3
  store i32 0, i32* %imm1102, align 4
  %490 = bitcast %struct.bpf_insn* %arrayidx1090 to i8*
  %491 = bitcast %struct.bpf_insn* %.compoundliteral1091 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %490, i8* align 4 %491, i64 8, i1 false)
  %arrayidx1103 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 1
  %code1105 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1104, i32 0, i32 0
  store i8 103, i8* %code1105, align 4
  %dst_reg1106 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1104, i32 0, i32 1
  %bf.load1107 = load i8, i8* %dst_reg1106, align 1
  %bf.clear1108 = and i8 %bf.load1107, -16
  %bf.set1109 = or i8 %bf.clear1108, 0
  store i8 %bf.set1109, i8* %dst_reg1106, align 1
  %src_reg1110 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1104, i32 0, i32 1
  %bf.load1111 = load i8, i8* %src_reg1110, align 1
  %bf.clear1112 = and i8 %bf.load1111, 15
  %bf.set1113 = or i8 %bf.clear1112, 0
  store i8 %bf.set1113, i8* %src_reg1110, align 1
  %off1114 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1104, i32 0, i32 2
  store i16 0, i16* %off1114, align 2
  %imm1115 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1104, i32 0, i32 3
  store i32 3, i32* %imm1115, align 4
  %492 = bitcast %struct.bpf_insn* %arrayidx1103 to i8*
  %493 = bitcast %struct.bpf_insn* %.compoundliteral1104 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %492, i8* align 4 %493, i64 8, i1 false)
  %arrayidx1116 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 2
  %code1118 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1117, i32 0, i32 0
  store i8 15, i8* %code1118, align 4
  %dst_reg1119 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1117, i32 0, i32 1
  %bf.load1120 = load i8, i8* %dst_reg1119, align 1
  %bf.clear1121 = and i8 %bf.load1120, -16
  %bf.set1122 = or i8 %bf.clear1121, 0
  store i8 %bf.set1122, i8* %dst_reg1119, align 1
  %src_reg1123 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1117, i32 0, i32 1
  %bf.load1124 = load i8, i8* %src_reg1123, align 1
  %bf.clear1125 = and i8 %bf.load1124, 15
  %bf.set1126 = or i8 %bf.clear1125, 16
  store i8 %bf.set1126, i8* %src_reg1123, align 1
  %off1127 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1117, i32 0, i32 2
  store i16 0, i16* %off1127, align 2
  %imm1128 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1117, i32 0, i32 3
  store i32 0, i32* %imm1128, align 4
  %494 = bitcast %struct.bpf_insn* %arrayidx1116 to i8*
  %495 = bitcast %struct.bpf_insn* %.compoundliteral1117 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %494, i8* align 4 %495, i64 8, i1 false)
  %arrayidx1129 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 3
  %code1131 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1130, i32 0, i32 0
  store i8 121, i8* %code1131, align 4
  %dst_reg1132 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1130, i32 0, i32 1
  %bf.load1133 = load i8, i8* %dst_reg1132, align 1
  %bf.clear1134 = and i8 %bf.load1133, -16
  %bf.set1135 = or i8 %bf.clear1134, 3
  store i8 %bf.set1135, i8* %dst_reg1132, align 1
  %src_reg1136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1130, i32 0, i32 1
  %bf.load1137 = load i8, i8* %src_reg1136, align 1
  %bf.clear1138 = and i8 %bf.load1137, 15
  %bf.set1139 = or i8 %bf.clear1138, 0
  store i8 %bf.set1139, i8* %src_reg1136, align 1
  %off1140 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1130, i32 0, i32 2
  store i16 0, i16* %off1140, align 2
  %imm1141 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1130, i32 0, i32 3
  store i32 0, i32* %imm1141, align 4
  %496 = bitcast %struct.bpf_insn* %arrayidx1129 to i8*
  %497 = bitcast %struct.bpf_insn* %.compoundliteral1130 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %496, i8* align 4 %497, i64 8, i1 false)
  %arrayidx1142 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 4
  %code1144 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1143, i32 0, i32 0
  store i8 123, i8* %code1144, align 4
  %dst_reg1145 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1143, i32 0, i32 1
  %bf.load1146 = load i8, i8* %dst_reg1145, align 1
  %bf.clear1147 = and i8 %bf.load1146, -16
  %bf.set1148 = or i8 %bf.clear1147, 2
  store i8 %bf.set1148, i8* %dst_reg1145, align 1
  %src_reg1149 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1143, i32 0, i32 1
  %bf.load1150 = load i8, i8* %src_reg1149, align 1
  %bf.clear1151 = and i8 %bf.load1150, 15
  %bf.set1152 = or i8 %bf.clear1151, 48
  store i8 %bf.set1152, i8* %src_reg1149, align 1
  %off1153 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1143, i32 0, i32 2
  store i16 0, i16* %off1153, align 2
  %imm1154 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1143, i32 0, i32 3
  store i32 0, i32* %imm1154, align 4
  %498 = bitcast %struct.bpf_insn* %arrayidx1142 to i8*
  %499 = bitcast %struct.bpf_insn* %.compoundliteral1143 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %498, i8* align 4 %499, i64 8, i1 false)
  %arrayidx1155 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 5
  %code1157 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1156, i32 0, i32 0
  store i8 -73, i8* %code1157, align 4
  %dst_reg1158 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1156, i32 0, i32 1
  %bf.load1159 = load i8, i8* %dst_reg1158, align 1
  %bf.clear1160 = and i8 %bf.load1159, -16
  %bf.set1161 = or i8 %bf.clear1160, 0
  store i8 %bf.set1161, i8* %dst_reg1158, align 1
  %src_reg1162 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1156, i32 0, i32 1
  %bf.load1163 = load i8, i8* %src_reg1162, align 1
  %bf.clear1164 = and i8 %bf.load1163, 15
  %bf.set1165 = or i8 %bf.clear1164, 0
  store i8 %bf.set1165, i8* %src_reg1162, align 1
  %off1166 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1156, i32 0, i32 2
  store i16 0, i16* %off1166, align 2
  %imm1167 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1156, i32 0, i32 3
  store i32 0, i32* %imm1167, align 4
  %500 = bitcast %struct.bpf_insn* %arrayidx1155 to i8*
  %501 = bitcast %struct.bpf_insn* %.compoundliteral1156 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %500, i8* align 4 %501, i64 8, i1 false)
  store i32 6, i32* %cnt, align 4
  br label %if.end1182

if.else1168:                                      ; preds = %lor.lhs.false1086
  %arrayidx1169 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code1171 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1170, i32 0, i32 0
  store i8 -73, i8* %code1171, align 4
  %dst_reg1172 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1170, i32 0, i32 1
  %bf.load1173 = load i8, i8* %dst_reg1172, align 1
  %bf.clear1174 = and i8 %bf.load1173, -16
  %bf.set1175 = or i8 %bf.clear1174, 0
  store i8 %bf.set1175, i8* %dst_reg1172, align 1
  %src_reg1176 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1170, i32 0, i32 1
  %bf.load1177 = load i8, i8* %src_reg1176, align 1
  %bf.clear1178 = and i8 %bf.load1177, 15
  %bf.set1179 = or i8 %bf.clear1178, 0
  store i8 %bf.set1179, i8* %src_reg1176, align 1
  %off1180 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1170, i32 0, i32 2
  store i16 0, i16* %off1180, align 2
  %imm1181 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1170, i32 0, i32 3
  store i32 -95, i32* %imm1181, align 4
  %502 = bitcast %struct.bpf_insn* %arrayidx1169 to i8*
  %503 = bitcast %struct.bpf_insn* %.compoundliteral1170 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %502, i8* align 4 %503, i64 8, i1 false)
  store i32 1, i32* %cnt, align 4
  br label %if.end1182

if.end1182:                                       ; preds = %if.else1168, %if.then1089
  %504 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %505 = load i32, i32* %i, align 4
  %506 = load i32, i32* %delta, align 4
  %add1183 = add i32 %505, %506
  %arraydecay1184 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %507 = load i32, i32* %cnt, align 4
  %call1185 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %504, i32 noundef %add1183, %struct.bpf_insn* noundef %arraydecay1184, i32 noundef %507) #20
  store %struct.bpf_prog* %call1185, %struct.bpf_prog** %new_prog, align 8
  %508 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool1186 = icmp ne %struct.bpf_prog* %508, null
  br i1 %tobool1186, label %if.end1188, label %if.then1187

if.then1187:                                      ; preds = %if.end1182
  store i32 -12, i32* %retval, align 4
  br label %return

if.end1188:                                       ; preds = %if.end1182
  %509 = load i32, i32* %cnt, align 4
  %sub1189 = sub i32 %509, 1
  %510 = load i32, i32* %delta, align 4
  %add1190 = add i32 %510, %sub1189
  store i32 %add1190, i32* %delta, align 4
  %511 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %511, %struct.bpf_prog** %prog, align 8
  %512 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1191 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %512, i32 0, i32 2
  store %struct.bpf_prog* %511, %struct.bpf_prog** %prog1191, align 8
  %513 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %514 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %513, i32 0, i32 12
  %515 = bitcast %union.anon.198* %514 to %struct.anon.201*
  %insnsi1192 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %515, i32 0, i32 1
  %arraydecay1193 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi1192, i64 0, i64 0
  %516 = load i32, i32* %i, align 4
  %idx.ext1194 = sext i32 %516 to i64
  %add.ptr1195 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay1193, i64 %idx.ext1194
  %517 = load i32, i32* %delta, align 4
  %idx.ext1196 = sext i32 %517 to i64
  %add.ptr1197 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr1195, i64 %idx.ext1196
  store %struct.bpf_insn* %add.ptr1197, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end1198:                                       ; preds = %land.lhs.true1079, %if.end1076
  %518 = load i32, i32* %prog_type, align 4
  %cmp1199 = icmp eq i32 %518, 26
  br i1 %cmp1199, label %land.lhs.true1201, label %if.end1232

land.lhs.true1201:                                ; preds = %if.end1198
  %519 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm1202 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %519, i32 0, i32 3
  %520 = load i32, i32* %imm1202, align 4
  %cmp1203 = icmp eq i32 %520, 185
  br i1 %cmp1203, label %if.then1205, label %if.end1232

if.then1205:                                      ; preds = %land.lhs.true1201
  %arrayidx1206 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code1208 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1207, i32 0, i32 0
  store i8 121, i8* %code1208, align 4
  %dst_reg1209 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1207, i32 0, i32 1
  %bf.load1210 = load i8, i8* %dst_reg1209, align 1
  %bf.clear1211 = and i8 %bf.load1210, -16
  %bf.set1212 = or i8 %bf.clear1211, 0
  store i8 %bf.set1212, i8* %dst_reg1209, align 1
  %src_reg1213 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1207, i32 0, i32 1
  %bf.load1214 = load i8, i8* %src_reg1213, align 1
  %bf.clear1215 = and i8 %bf.load1214, 15
  %bf.set1216 = or i8 %bf.clear1215, 16
  store i8 %bf.set1216, i8* %src_reg1213, align 1
  %off1217 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1207, i32 0, i32 2
  store i16 -8, i16* %off1217, align 2
  %imm1218 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1207, i32 0, i32 3
  store i32 0, i32* %imm1218, align 4
  %521 = bitcast %struct.bpf_insn* %arrayidx1206 to i8*
  %522 = bitcast %struct.bpf_insn* %.compoundliteral1207 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %521, i8* align 4 %522, i64 8, i1 false)
  %523 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %524 = load i32, i32* %i, align 4
  %525 = load i32, i32* %delta, align 4
  %add1219 = add i32 %524, %525
  %arraydecay1220 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %call1221 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %523, i32 noundef %add1219, %struct.bpf_insn* noundef %arraydecay1220, i32 noundef 1) #20
  store %struct.bpf_prog* %call1221, %struct.bpf_prog** %new_prog, align 8
  %526 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool1222 = icmp ne %struct.bpf_prog* %526, null
  br i1 %tobool1222, label %if.end1224, label %if.then1223

if.then1223:                                      ; preds = %if.then1205
  store i32 -12, i32* %retval, align 4
  br label %return

if.end1224:                                       ; preds = %if.then1205
  %527 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %527, %struct.bpf_prog** %prog, align 8
  %528 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1225 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %528, i32 0, i32 2
  store %struct.bpf_prog* %527, %struct.bpf_prog** %prog1225, align 8
  %529 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %530 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %529, i32 0, i32 12
  %531 = bitcast %union.anon.198* %530 to %struct.anon.201*
  %insnsi1226 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %531, i32 0, i32 1
  %arraydecay1227 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi1226, i64 0, i64 0
  %532 = load i32, i32* %i, align 4
  %idx.ext1228 = sext i32 %532 to i64
  %add.ptr1229 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay1227, i64 %idx.ext1228
  %533 = load i32, i32* %delta, align 4
  %idx.ext1230 = sext i32 %533 to i64
  %add.ptr1231 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr1229, i64 %idx.ext1230
  store %struct.bpf_insn* %add.ptr1231, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end1232:                                       ; preds = %land.lhs.true1201, %if.end1198
  %534 = load i32, i32* %prog_type, align 4
  %cmp1233 = icmp eq i32 %534, 26
  br i1 %cmp1233, label %land.lhs.true1235, label %if.end1266

land.lhs.true1235:                                ; preds = %if.end1232
  %535 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm1236 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %535, i32 0, i32 3
  %536 = load i32, i32* %imm1236, align 4
  %cmp1237 = icmp eq i32 %536, 173
  br i1 %cmp1237, label %if.then1239, label %if.end1266

if.then1239:                                      ; preds = %land.lhs.true1235
  %arrayidx1240 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code1242 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1241, i32 0, i32 0
  store i8 121, i8* %code1242, align 4
  %dst_reg1243 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1241, i32 0, i32 1
  %bf.load1244 = load i8, i8* %dst_reg1243, align 1
  %bf.clear1245 = and i8 %bf.load1244, -16
  %bf.set1246 = or i8 %bf.clear1245, 0
  store i8 %bf.set1246, i8* %dst_reg1243, align 1
  %src_reg1247 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1241, i32 0, i32 1
  %bf.load1248 = load i8, i8* %src_reg1247, align 1
  %bf.clear1249 = and i8 %bf.load1248, 15
  %bf.set1250 = or i8 %bf.clear1249, 16
  store i8 %bf.set1250, i8* %src_reg1247, align 1
  %off1251 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1241, i32 0, i32 2
  store i16 -16, i16* %off1251, align 2
  %imm1252 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral1241, i32 0, i32 3
  store i32 0, i32* %imm1252, align 4
  %537 = bitcast %struct.bpf_insn* %arrayidx1240 to i8*
  %538 = bitcast %struct.bpf_insn* %.compoundliteral1241 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %537, i8* align 4 %538, i64 8, i1 false)
  %539 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %540 = load i32, i32* %i, align 4
  %541 = load i32, i32* %delta, align 4
  %add1253 = add i32 %540, %541
  %arraydecay1254 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %call1255 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %539, i32 noundef %add1253, %struct.bpf_insn* noundef %arraydecay1254, i32 noundef 1) #20
  store %struct.bpf_prog* %call1255, %struct.bpf_prog** %new_prog, align 8
  %542 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool1256 = icmp ne %struct.bpf_prog* %542, null
  br i1 %tobool1256, label %if.end1258, label %if.then1257

if.then1257:                                      ; preds = %if.then1239
  store i32 -12, i32* %retval, align 4
  br label %return

if.end1258:                                       ; preds = %if.then1239
  %543 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %543, %struct.bpf_prog** %prog, align 8
  %544 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1259 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %544, i32 0, i32 2
  store %struct.bpf_prog* %543, %struct.bpf_prog** %prog1259, align 8
  %545 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %546 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %545, i32 0, i32 12
  %547 = bitcast %union.anon.198* %546 to %struct.anon.201*
  %insnsi1260 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %547, i32 0, i32 1
  %arraydecay1261 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi1260, i64 0, i64 0
  %548 = load i32, i32* %i, align 4
  %idx.ext1262 = sext i32 %548 to i64
  %add.ptr1263 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay1261, i64 %idx.ext1262
  %549 = load i32, i32* %delta, align 4
  %idx.ext1264 = sext i32 %549 to i64
  %add.ptr1265 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr1263, i64 %idx.ext1264
  store %struct.bpf_insn* %add.ptr1265, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end1266:                                       ; preds = %land.lhs.true1235, %if.end1232
  br label %patch_call_imm

patch_call_imm:                                   ; preds = %if.end1266, %sw.epilog, %if.then765, %if.end706, %if.end645
  %550 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops1267 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %550, i32 0, i32 3
  %551 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops1267, align 8
  %get_func_proto = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %551, i32 0, i32 0
  %552 = load %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, %struct.bpf_func_proto* (i32, %struct.bpf_prog*)** %get_func_proto, align 8
  %553 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm1268 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %553, i32 0, i32 3
  %554 = load i32, i32* %imm1268, align 4
  %555 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1269 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %555, i32 0, i32 2
  %556 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1269, align 8
  %call1270 = call %struct.bpf_func_proto* %552(i32 noundef %554, %struct.bpf_prog* noundef %556) #20
  store %struct.bpf_func_proto* %call1270, %struct.bpf_func_proto** %fn, align 8
  %557 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %func = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %557, i32 0, i32 0
  %558 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %func, align 8
  %tobool1271 = icmp ne i64 (i64, i64, i64, i64, i64)* %558, null
  br i1 %tobool1271, label %if.end1276, label %if.then1272

if.then1272:                                      ; preds = %patch_call_imm
  %559 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %560 = bitcast %struct.bpf_verifier_env* %559 to i8*
  %561 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm1273 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %561, i32 0, i32 3
  %562 = load i32, i32* %imm1273, align 4
  %call1274 = call i8* @func_id_name(i32 noundef %562) #20
  %563 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm1275 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %563, i32 0, i32 3
  %564 = load i32, i32* %imm1275, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %560, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.368, i64 0, i64 0), i8* noundef %call1274, i32 noundef %564) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end1276:                                       ; preds = %patch_call_imm
  %565 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %func1277 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %565, i32 0, i32 0
  %566 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %func1277, align 8
  %sub.ptr.lhs.cast1278 = ptrtoint i64 (i64, i64, i64, i64, i64)* %566 to i64
  %sub.ptr.sub1279 = sub i64 %sub.ptr.lhs.cast1278, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv1280 = trunc i64 %sub.ptr.sub1279 to i32
  %567 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm1281 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %567, i32 0, i32 3
  store i32 %conv1280, i32* %imm1281, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end1276, %if.end1258, %if.end1224, %if.end1188, %if.end1066, %if.end926, %sw.bb863, %sw.bb858, %sw.bb853, %sw.bb848, %sw.bb843, %sw.bb838, %sw.bb833, %sw.bb828, %sw.bb, %if.end796, %if.end592, %if.then552, %if.end547, %if.end477, %if.then465, %if.then457, %if.end442, %if.then219, %if.end190, %if.end
  %568 = load i32, i32* %i, align 4
  %inc = add i32 %568, 1
  store i32 %inc, i32* %i, align 4
  %569 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr1282 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %569, i32 1
  store %struct.bpf_insn* %incdec.ptr1282, %struct.bpf_insn** %insn, align 8
  br label %for.cond, !llvm.loop !41

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1283

for.cond1283:                                     ; preds = %for.inc1311, %for.end
  %570 = load i32, i32* %i, align 4
  %571 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux1284 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %571, i32 0, i32 10
  %572 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1284, align 8
  %size_poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %572, i32 0, i32 35
  %573 = load i32, i32* %size_poke_tab, align 8
  %cmp1285 = icmp ult i32 %570, %573
  br i1 %cmp1285, label %for.body1287, label %for.end1313

for.body1287:                                     ; preds = %for.cond1283
  %574 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux1288 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %574, i32 0, i32 10
  %575 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1288, align 8
  %poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %575, i32 0, i32 32
  %576 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab, align 8
  %577 = load i32, i32* %i, align 4
  %idxprom1289 = sext i32 %577 to i64
  %arrayidx1290 = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %576, i64 %idxprom1289
  %578 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %arrayidx1290, i32 0, i32 4
  %tail_call1291 = bitcast %union.anon.138* %578 to %struct.anon.139*
  %map1292 = getelementptr inbounds %struct.anon.139, %struct.anon.139* %tail_call1291, i32 0, i32 0
  %579 = load %struct.bpf_map*, %struct.bpf_map** %map1292, align 8
  store %struct.bpf_map* %579, %struct.bpf_map** %map_ptr, align 8
  %580 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops1293 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %580, i32 0, i32 0
  %581 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops1293, align 64
  %map_poke_track = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %581, i32 0, i32 25
  %582 = load i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)*, i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_track, align 8
  %tobool1294 = icmp ne i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)* %582, null
  br i1 %tobool1294, label %lor.lhs.false1295, label %if.then1301

lor.lhs.false1295:                                ; preds = %for.body1287
  %583 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops1296 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %583, i32 0, i32 0
  %584 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops1296, align 64
  %map_poke_untrack = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %584, i32 0, i32 26
  %585 = load void (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_untrack, align 8
  %tobool1297 = icmp ne void (%struct.bpf_map*, %struct.bpf_prog_aux*)* %585, null
  br i1 %tobool1297, label %lor.lhs.false1298, label %if.then1301

lor.lhs.false1298:                                ; preds = %lor.lhs.false1295
  %586 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops1299 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %586, i32 0, i32 0
  %587 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops1299, align 64
  %map_poke_run = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %587, i32 0, i32 27
  %588 = load void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)*, void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)** %map_poke_run, align 8
  %tobool1300 = icmp ne void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)* %588, null
  br i1 %tobool1300, label %if.end1302, label %if.then1301

if.then1301:                                      ; preds = %lor.lhs.false1298, %lor.lhs.false1295, %for.body1287
  %589 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %590 = bitcast %struct.bpf_verifier_env* %589 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %590, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.485, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end1302:                                       ; preds = %lor.lhs.false1298
  %591 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops1303 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %591, i32 0, i32 0
  %592 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops1303, align 64
  %map_poke_track1304 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %592, i32 0, i32 25
  %593 = load i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)*, i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_track1304, align 8
  %594 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %595 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux1305 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %595, i32 0, i32 10
  %596 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1305, align 8
  %call1306 = call i32 %593(%struct.bpf_map* noundef %594, %struct.bpf_prog_aux* noundef %596) #20
  store i32 %call1306, i32* %ret, align 4
  %597 = load i32, i32* %ret, align 4
  %cmp1307 = icmp slt i32 %597, 0
  br i1 %cmp1307, label %if.then1309, label %if.end1310

if.then1309:                                      ; preds = %if.end1302
  %598 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %599 = bitcast %struct.bpf_verifier_env* %598 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %599, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.502, i64 0, i64 0)) #20
  %600 = load i32, i32* %ret, align 4
  store i32 %600, i32* %retval, align 4
  br label %return

if.end1310:                                       ; preds = %if.end1302
  br label %for.inc1311

for.inc1311:                                      ; preds = %if.end1310
  %601 = load i32, i32* %i, align 4
  %inc1312 = add i32 %601, 1
  store i32 %inc1312, i32* %i, align 4
  br label %for.cond1283, !llvm.loop !42

for.end1313:                                      ; preds = %for.cond1283
  %602 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1314 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %602, i32 0, i32 2
  %603 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1314, align 8
  call void @sort_kfunc_descs_by_imm(%struct.bpf_prog* noundef %603) #20
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end1313, %if.then1309, %if.then1301, %if.then1272, %if.then1257, %if.then1223, %if.then1187, %if.then1065, %if.then925, %if.then795, %if.then789, %if.then705, %if.then644, %if.then591, %if.then555, %if.then546, %if.then476, %if.then441, %if.then189, %if.then183, %if.then148
  %604 = load i32, i32* %retval, align 4
  ret i32 %604
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @opt_subreg_zext_lo32_rnd_hi32(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %patch = alloca %struct.bpf_insn*, align 8
  %zext_patch = alloca [2 x %struct.bpf_insn], align 16
  %rnd_hi32_patch = alloca [4 x %struct.bpf_insn], align 16
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %i = alloca i32, align 4
  %patch_len = alloca i32, align 4
  %delta = alloca i32, align 4
  %len = alloca i32, align 4
  %insns = alloca %struct.bpf_insn*, align 8
  %new_prog = alloca %struct.bpf_prog*, align 8
  %rnd_hi32 = alloca i8, align 1
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %.compoundliteral7 = alloca %struct.bpf_insn, align 4
  %.compoundliteral20 = alloca %struct.bpf_insn, align 4
  %.compoundliteral33 = alloca %struct.bpf_insn, align 4
  %adj_idx = alloca i32, align 4
  %insn = alloca %struct.bpf_insn, align 4
  %load_reg = alloca i32, align 4
  %code49 = alloca i8, align 1
  %class = alloca i8, align 1
  %imm_rnd = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux, align 8
  store i32 0, i32* %delta, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len1, align 4
  store i32 %4, i32* %len, align 4
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %7 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 12
  %8 = bitcast %union.anon.198* %7 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %8, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insns, align 8
  %9 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %10 = bitcast %union.bpf_attr* %9 to %struct.anon.144*
  %prog_flags = getelementptr inbounds %struct.anon.144, %struct.anon.144* %10, i32 0, i32 8
  %11 = load i32, i32* %prog_flags, align 4
  %and = and i32 %11, 4
  %tobool = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* %rnd_hi32, align 1
  %arrayidx = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 1
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -68, i8* %code, align 4
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 0
  store i8 %bf.set5, i8* %src_reg, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 1, i32* %imm, align 4
  %12 = bitcast %struct.bpf_insn* %arrayidx to i8*
  %13 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 4 %13, i64 8, i1 false)
  %arrayidx6 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 1
  %code8 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 0
  store i8 -73, i8* %code8, align 4
  %dst_reg9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 1
  %bf.load10 = load i8, i8* %dst_reg9, align 1
  %bf.clear11 = and i8 %bf.load10, -16
  %bf.set12 = or i8 %bf.clear11, 11
  store i8 %bf.set12, i8* %dst_reg9, align 1
  %src_reg13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 1
  %bf.load14 = load i8, i8* %src_reg13, align 1
  %bf.clear15 = and i8 %bf.load14, 15
  %bf.set16 = or i8 %bf.clear15, 0
  store i8 %bf.set16, i8* %src_reg13, align 1
  %off17 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 2
  store i16 0, i16* %off17, align 2
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 3
  store i32 0, i32* %imm18, align 4
  %14 = bitcast %struct.bpf_insn* %arrayidx6 to i8*
  %15 = bitcast %struct.bpf_insn* %.compoundliteral7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %14, i8* align 4 %15, i64 8, i1 false)
  %arrayidx19 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 2
  %code21 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 0
  store i8 103, i8* %code21, align 4
  %dst_reg22 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 1
  %bf.load23 = load i8, i8* %dst_reg22, align 1
  %bf.clear24 = and i8 %bf.load23, -16
  %bf.set25 = or i8 %bf.clear24, 11
  store i8 %bf.set25, i8* %dst_reg22, align 1
  %src_reg26 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 1
  %bf.load27 = load i8, i8* %src_reg26, align 1
  %bf.clear28 = and i8 %bf.load27, 15
  %bf.set29 = or i8 %bf.clear28, 0
  store i8 %bf.set29, i8* %src_reg26, align 1
  %off30 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 2
  store i16 0, i16* %off30, align 2
  %imm31 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 3
  store i32 32, i32* %imm31, align 4
  %16 = bitcast %struct.bpf_insn* %arrayidx19 to i8*
  %17 = bitcast %struct.bpf_insn* %.compoundliteral20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %16, i8* align 4 %17, i64 8, i1 false)
  %arrayidx32 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 3
  %code34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 0
  store i8 79, i8* %code34, align 4
  %dst_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 1
  %bf.load36 = load i8, i8* %dst_reg35, align 1
  %bf.clear37 = and i8 %bf.load36, -16
  %bf.set38 = or i8 %bf.clear37, 0
  store i8 %bf.set38, i8* %dst_reg35, align 1
  %src_reg39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 1
  %bf.load40 = load i8, i8* %src_reg39, align 1
  %bf.clear41 = and i8 %bf.load40, 15
  %bf.set42 = or i8 %bf.clear41, -80
  store i8 %bf.set42, i8* %src_reg39, align 1
  %off43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 2
  store i16 0, i16* %off43, align 2
  %imm44 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 3
  store i32 0, i32* %imm44, align 4
  %18 = bitcast %struct.bpf_insn* %arrayidx32 to i8*
  %19 = bitcast %struct.bpf_insn* %.compoundliteral33 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %18, i8* align 4 %19, i64 8, i1 false)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %20 = load i32, i32* %i, align 4
  %21 = load i32, i32* %len, align 4
  %cmp = icmp slt i32 %20, %21
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %22 = load i32, i32* %i, align 4
  %23 = load i32, i32* %delta, align 4
  %add = add i32 %22, %23
  store i32 %add, i32* %adj_idx, align 4
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %25 = load i32, i32* %adj_idx, align 4
  %idxprom = sext i32 %25 to i64
  %arrayidx45 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %24, i64 %idxprom
  %26 = bitcast %struct.bpf_insn* %insn to i8*
  %27 = bitcast %struct.bpf_insn* %arrayidx45 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %26, i8* align 4 %27, i64 8, i1 false)
  %call = call i32 @insn_def_regno(%struct.bpf_insn* noundef %insn) #20
  store i32 %call, i32* %load_reg, align 4
  %28 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %29 = load i32, i32* %adj_idx, align 4
  %idxprom46 = sext i32 %29 to i64
  %arrayidx47 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %28, i64 %idxprom46
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx47, i32 0, i32 5
  %30 = load i8, i8* %zext_dst, align 1
  %tobool48 = trunc i8 %30 to i1
  br i1 %tobool48, label %if.end92, label %if.then

if.then:                                          ; preds = %for.body
  %31 = load i8, i8* %rnd_hi32, align 1
  %tobool50 = trunc i8 %31 to i1
  br i1 %tobool50, label %if.end, label %if.then51

if.then51:                                        ; preds = %if.then
  br label %for.inc

if.end:                                           ; preds = %if.then
  %code52 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %32 = load i8, i8* %code52, align 4
  store i8 %32, i8* %code49, align 1
  %33 = load i8, i8* %code49, align 1
  %conv = zext i8 %33 to i32
  %and53 = and i32 %conv, 7
  %conv54 = trunc i32 %and53 to i8
  store i8 %conv54, i8* %class, align 1
  %34 = load i32, i32* %load_reg, align 4
  %cmp55 = icmp eq i32 %34, -1
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.end
  br label %for.inc

if.end58:                                         ; preds = %if.end
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = load i32, i32* %load_reg, align 4
  %call59 = call zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %35, %struct.bpf_insn* noundef %insn, i32 noundef %36, %struct.bpf_reg_state* noundef null, i32 noundef 1) #20
  br i1 %call59, label %if.then60, label %if.end70

if.then60:                                        ; preds = %if.end58
  %37 = load i8, i8* %class, align 1
  %conv61 = zext i8 %37 to i32
  %cmp62 = icmp eq i32 %conv61, 0
  br i1 %cmp62, label %land.lhs.true, label %if.end69

land.lhs.true:                                    ; preds = %if.then60
  %38 = load i8, i8* %code49, align 1
  %conv64 = zext i8 %38 to i32
  %and65 = and i32 %conv64, 224
  %cmp66 = icmp eq i32 %and65, 0
  br i1 %cmp66, label %if.then68, label %if.end69

if.then68:                                        ; preds = %land.lhs.true
  %39 = load i32, i32* %i, align 4
  %inc = add i32 %39, 1
  store i32 %inc, i32* %i, align 4
  br label %if.end69

if.end69:                                         ; preds = %if.then68, %land.lhs.true, %if.then60
  br label %for.inc

if.end70:                                         ; preds = %if.end58
  %40 = load i8, i8* %class, align 1
  %conv71 = zext i8 %40 to i32
  %cmp72 = icmp eq i32 %conv71, 1
  br i1 %cmp72, label %land.lhs.true74, label %if.end80

land.lhs.true74:                                  ; preds = %if.end70
  %41 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %42 = load i32, i32* %adj_idx, align 4
  %idxprom75 = sext i32 %42 to i64
  %arrayidx76 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %41, i64 %idxprom75
  %43 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx76, i32 0, i32 0
  %ptr_type = bitcast %union.anon.210* %43 to i32*
  %44 = load i32, i32* %ptr_type, align 8
  %cmp77 = icmp eq i32 %44, 2
  br i1 %cmp77, label %if.then79, label %if.end80

if.then79:                                        ; preds = %land.lhs.true74
  br label %for.inc

if.end80:                                         ; preds = %land.lhs.true74, %if.end70
  %call81 = call i32 @get_random_u32() #20
  store i32 %call81, i32* %imm_rnd, align 4
  %arrayidx82 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 0
  %45 = bitcast %struct.bpf_insn* %arrayidx82 to i8*
  %46 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %45, i8* align 4 %46, i64 8, i1 false)
  %47 = load i32, i32* %imm_rnd, align 4
  %arrayidx83 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 1
  %imm84 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx83, i32 0, i32 3
  store i32 %47, i32* %imm84, align 4
  %48 = load i32, i32* %load_reg, align 4
  %conv85 = trunc i32 %48 to i8
  %arrayidx86 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 3
  %dst_reg87 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx86, i32 0, i32 1
  %bf.load88 = load i8, i8* %dst_reg87, align 1
  %bf.value = and i8 %conv85, 15
  %bf.clear89 = and i8 %bf.load88, -16
  %bf.set90 = or i8 %bf.clear89, %bf.value
  store i8 %bf.set90, i8* %dst_reg87, align 1
  %arraydecay91 = getelementptr inbounds [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay91, %struct.bpf_insn** %patch, align 8
  store i32 4, i32* %patch_len, align 4
  br label %apply_patch_buffer

if.end92:                                         ; preds = %for.body
  %call93 = call zeroext i1 @bpf_jit_needs_zext() #20
  br i1 %call93, label %if.end97, label %land.lhs.true94

land.lhs.true94:                                  ; preds = %if.end92
  %call95 = call zeroext i1 @is_cmpxchg_insn(%struct.bpf_insn* noundef %insn) #20
  br i1 %call95, label %if.end97, label %if.then96

if.then96:                                        ; preds = %land.lhs.true94
  br label %for.inc

if.end97:                                         ; preds = %land.lhs.true94, %if.end92
  %49 = load i32, i32* %load_reg, align 4
  %cmp98 = icmp eq i32 %49, -1
  %lnot = xor i1 %cmp98, true
  %lnot100 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot100 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %50 = load i32, i32* %__ret_warn_on, align 4
  %tobool101 = icmp ne i32 %50, 0
  %lnot102 = xor i1 %tobool101, true
  %lnot104 = xor i1 %lnot102, true
  %lnot.ext105 = zext i1 %lnot104 to i32
  %conv106 = sext i32 %lnot.ext105 to i64
  %tobool107 = icmp ne i64 %conv106, 0
  br i1 %tobool107, label %if.then108, label %if.end115

if.then108:                                       ; preds = %if.end97
  br label %do.body

do.body:                                          ; preds = %if.then108
  store i32 2305, i32* %__flags, align 4
  br label %do.body109

do.body109:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body109
  br label %do.body110

do.body110:                                       ; preds = %do.end
  %51 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 15332, i32 %51, i64 12) #19, !srcloc !43
  br label %do.end111

do.end111:                                        ; preds = %do.body110
  br label %do.body112

do.body112:                                       ; preds = %do.end111
  br label %do.end113

do.end113:                                        ; preds = %do.body112
  br label %do.end114

do.end114:                                        ; preds = %do.end113
  br label %if.end115

if.end115:                                        ; preds = %do.end114, %if.end97
  %52 = load i32, i32* %__ret_warn_on, align 4
  %tobool116 = icmp ne i32 %52, 0
  %lnot117 = xor i1 %tobool116, true
  %lnot119 = xor i1 %lnot117, true
  %lnot.ext120 = zext i1 %lnot119 to i32
  %conv121 = sext i32 %lnot.ext120 to i64
  store i64 %conv121, i64* %tmp, align 8
  %53 = load i64, i64* %tmp, align 8
  %tobool122 = icmp ne i64 %53, 0
  br i1 %tobool122, label %if.then123, label %if.end124

if.then123:                                       ; preds = %if.end115
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.505, i64 0, i64 0)) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end124:                                        ; preds = %if.end115
  %arrayidx125 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 0
  %56 = bitcast %struct.bpf_insn* %arrayidx125 to i8*
  %57 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %56, i8* align 4 %57, i64 8, i1 false)
  %58 = load i32, i32* %load_reg, align 4
  %conv126 = trunc i32 %58 to i8
  %arrayidx127 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 1
  %dst_reg128 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx127, i32 0, i32 1
  %bf.load129 = load i8, i8* %dst_reg128, align 1
  %bf.value130 = and i8 %conv126, 15
  %bf.clear131 = and i8 %bf.load129, -16
  %bf.set132 = or i8 %bf.clear131, %bf.value130
  store i8 %bf.set132, i8* %dst_reg128, align 1
  %59 = load i32, i32* %load_reg, align 4
  %conv133 = trunc i32 %59 to i8
  %arrayidx134 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 1
  %src_reg135 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx134, i32 0, i32 1
  %bf.load136 = load i8, i8* %src_reg135, align 1
  %bf.value137 = and i8 %conv133, 15
  %bf.shl = shl i8 %bf.value137, 4
  %bf.clear138 = and i8 %bf.load136, 15
  %bf.set139 = or i8 %bf.clear138, %bf.shl
  store i8 %bf.set139, i8* %src_reg135, align 1
  %arraydecay140 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay140, %struct.bpf_insn** %patch, align 8
  store i32 2, i32* %patch_len, align 4
  br label %apply_patch_buffer

apply_patch_buffer:                               ; preds = %if.end124, %if.end80
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = load i32, i32* %adj_idx, align 4
  %62 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %63 = load i32, i32* %patch_len, align 4
  %call141 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %60, i32 noundef %61, %struct.bpf_insn* noundef %62, i32 noundef %63) #20
  store %struct.bpf_prog* %call141, %struct.bpf_prog** %new_prog, align 8
  %64 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool142 = icmp ne %struct.bpf_prog* %64, null
  br i1 %tobool142, label %if.end144, label %if.then143

if.then143:                                       ; preds = %apply_patch_buffer
  store i32 -12, i32* %retval, align 4
  br label %return

if.end144:                                        ; preds = %apply_patch_buffer
  %65 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog145 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %66, i32 0, i32 2
  store %struct.bpf_prog* %65, %struct.bpf_prog** %prog145, align 8
  %67 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %68 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %67, i32 0, i32 12
  %69 = bitcast %union.anon.198* %68 to %struct.anon.201*
  %insnsi146 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %69, i32 0, i32 1
  %arraydecay147 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi146, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay147, %struct.bpf_insn** %insns, align 8
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data148 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %70, i32 0, i32 24
  %71 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data148, align 8
  store %struct.bpf_insn_aux_data* %71, %struct.bpf_insn_aux_data** %aux, align 8
  %72 = load i32, i32* %patch_len, align 4
  %sub = sub i32 %72, 1
  %73 = load i32, i32* %delta, align 4
  %add149 = add i32 %73, %sub
  store i32 %add149, i32* %delta, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end144, %if.then96, %if.then79, %if.end69, %if.then57, %if.then51
  %74 = load i32, i32* %i, align 4
  %inc150 = add i32 %74, 1
  store i32 %inc150, i32* %i, align 4
  br label %for.cond, !llvm.loop !44

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then143, %if.then123
  %75 = load i32, i32* %retval, align 4
  ret i32 %75
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_jit_needs_zext() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @fixup_call_args(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %has_kfunc_call = alloca i8, align 1
  %i = alloca i32, align 4
  %depth = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 12
  %4 = bitcast %union.anon.198* %3 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %4, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call zeroext i1 @bpf_prog_has_kfunc_call(%struct.bpf_prog* noundef %5) #20
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %has_kfunc_call, align 1
  store i32 0, i32* %err, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 1
  %bf.load = load i16, i16* %jit_requested, align 2
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %conv = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 2
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog3, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %9, i32 0, i32 10
  %10 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call4 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %10) #20
  br i1 %call4, label %if.end12, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call5 = call i32 @jit_subprogs(%struct.bpf_verifier_env* noundef %11) #20
  store i32 %call5, i32* %err, align 4
  %12 = load i32, i32* %err, align 4
  %cmp = icmp eq i32 %12, 0
  br i1 %cmp, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %13 = load i32, i32* %err, align 4
  %cmp8 = icmp eq i32 %13, -14
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  %14 = load i32, i32* %err, align 4
  store i32 %14, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %land.lhs.true, %entry
  %15 = load i8, i8* %has_kfunc_call, align 1
  %tobool13 = trunc i8 %15 to i1
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end12
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([64 x i8], [64 x i8]* @.str.506, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end12
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 31
  %19 = load i32, i32* %subprog_cnt, align 4
  %cmp16 = icmp ugt i32 %19, 1
  br i1 %cmp16, label %land.lhs.true18, label %if.end24

land.lhs.true18:                                  ; preds = %if.end15
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog19 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 2
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog19, align 8
  %aux20 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 10
  %22 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux20, align 8
  %tail_call_reachable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %22, i32 0, i32 26
  %23 = load i8, i8* %tail_call_reachable, align 1
  %tobool21 = trunc i8 %23 to i1
  br i1 %tobool21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %land.lhs.true18
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([72 x i8], [72 x i8]* @.str.457, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %land.lhs.true18, %if.end15
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end24
  %26 = load i32, i32* %i, align 4
  %27 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %27, i32 0, i32 4
  %28 = load i32, i32* %len, align 4
  %cmp25 = icmp ult i32 %26, %28
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call27 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %29) #20
  br i1 %call27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %for.body
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.507, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %for.body
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call30 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %32) #20
  br i1 %call30, label %if.end32, label %if.then31

if.then31:                                        ; preds = %if.end29
  br label %for.inc

if.end32:                                         ; preds = %if.end29
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %35 = load i32, i32* %i, align 4
  %call33 = call i32 @get_callee_stack_depth(%struct.bpf_verifier_env* noundef %33, %struct.bpf_insn* noundef %34, i32 noundef %35) #20
  store i32 %call33, i32* %depth, align 4
  %36 = load i32, i32* %depth, align 4
  %cmp34 = icmp slt i32 %36, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end32
  %37 = load i32, i32* %depth, align 4
  store i32 %37, i32* %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end32
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %39 = load i32, i32* %depth, align 4
  call void @bpf_patch_call_args(%struct.bpf_insn* noundef %38, i32 noundef %39) #20
  br label %for.inc

for.inc:                                          ; preds = %if.end37, %if.then31
  %40 = load i32, i32* %i, align 4
  %inc = add i32 %40, 1
  store i32 %inc, i32* %i, align 4
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %41, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond, !llvm.loop !45

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %err, align 4
  %42 = load i32, i32* %err, align 4
  store i32 %42, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then36, %if.then28, %if.then23, %if.then14, %if.then10, %if.then7
  %43 = load i32, i32* %retval, align 4
  ret i32 %43
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_verification_stats(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %i = alloca i32, align 4
  %depth = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %1 = load i32, i32* %level, align 8
  %and = and i32 %1, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %verification_time = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 36
  %5 = load i64, i64* %verification_time, align 8
  %call = call i64 @div_u64(i64 noundef %5, i32 noundef 1000) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.509, i64 0, i64 0), i64 noundef %call) #20
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.510, i64 0, i64 0)) #20
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %8 = load i32, i32* %i, align 4
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 31
  %10 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %8, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 27
  %12 = load i32, i32* %i, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %13 = load i16, i16* %stack_depth, align 8
  %conv = zext i16 %13 to i32
  store i32 %conv, i32* %depth, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load i32, i32* %depth, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.511, i64 0, i64 0), i32 noundef %16) #20
  %17 = load i32, i32* %i, align 4
  %add = add i32 %17, 1
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 31
  %19 = load i32, i32* %subprog_cnt1, align 4
  %cmp2 = icmp ult i32 %add, %19
  br i1 %cmp2, label %if.then4, label %if.end

if.then4:                                         ; preds = %for.body
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.512, i64 0, i64 0)) #20
  br label %if.end

if.end:                                           ; preds = %if.then4, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i32, i32* %i, align 4
  %inc = add i32 %22, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !46

for.end:                                          ; preds = %for.cond
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i64 0, i64 0)) #20
  br label %if.end5

if.end5:                                          ; preds = %for.end, %entry
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 33
  %28 = load i32, i32* %insn_processed, align 4
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %max_states_per_insn = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 37
  %30 = load i32, i32* %max_states_per_insn, align 8
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %total_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 38
  %32 = load i32, i32* %total_states, align 4
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %peak_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 39
  %34 = load i32, i32* %peak_states, align 8
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %longest_mark_read_walk = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 40
  %36 = load i32, i32* %longest_mark_read_walk, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([98 x i8], [98 x i8]* @.str.513, i64 0, i64 0), i32 noundef %28, i32 noundef 1000000, i32 noundef %30, i32 noundef %32, i32 noundef %34, i32 noundef %36) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_verifier_log_full(%struct.bpf_verifier_log* noundef %log) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %0, i32 0, i32 3
  %1 = load i32, i32* %len_used, align 8
  %2 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %2, i32 0, i32 4
  %3 = load i32, i32* %len_total, align 4
  %sub = sub i32 %3, 1
  %cmp = icmp uge i32 %1, %sub
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong allocsize(0,1)
define internal noalias i8* @kmalloc_array(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #8 {
entry:
  %retval.i13 = alloca i32, align 4
  %flags.addr.i14 = alloca i32, align 4
  %retval.i6 = alloca i32, align 4
  %size.addr.i7 = alloca i64, align 8
  %size_is_constant.addr.i = alloca i8, align 1
  %retval.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %index.i = alloca i32, align 4
  %retval = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  %1 = load i64, i64* %size.addr, align 8
  %2 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %0, i64 %1)
  %3 = extractvalue { i64, i1 } %2, 1
  %4 = extractvalue { i64, i1 } %2, 0
  store i64 %4, i64* %bytes, align 8
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %3) #20
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %n.addr, align 8
  %6 = call i1 @llvm.is.constant.i64(i64 %5)
  br i1 %6, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %7 = load i64, i64* %size.addr, align 8
  %8 = call i1 @llvm.is.constant.i64(i64 %7)
  br i1 %8, label %if.then2, label %if.end4

if.then2:                                         ; preds = %land.lhs.true
  %9 = load i64, i64* %bytes, align 8
  %10 = load i32, i32* %flags.addr, align 4
  store i64 %9, i64* %size.addr.i, align 8
  store i32 %10, i32* %flags.addr.i, align 4
  %11 = load i64, i64* %size.addr.i, align 8
  %12 = call i1 @llvm.is.constant.i64(i64 %11) #19
  br i1 %12, label %if.then.i, label %if.end9.i

if.then.i:                                        ; preds = %if.then2
  %13 = load i64, i64* %size.addr.i, align 8
  %cmp.i = icmp ugt i64 %13, 8192
  br i1 %cmp.i, label %if.then1.i, label %if.end.i

if.then1.i:                                       ; preds = %if.then.i
  %14 = load i64, i64* %size.addr.i, align 8
  %15 = load i32, i32* %flags.addr.i, align 4
  %call.i = call noalias align 4096 i8* @kmalloc_large(i64 noundef %14, i32 noundef %15) #26
  store i8* %call.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end.i:                                         ; preds = %if.then.i
  %16 = load i64, i64* %size.addr.i, align 8
  store i64 %16, i64* %size.addr.i7, align 8
  store i8 1, i8* %size_is_constant.addr.i, align 1
  %17 = load i64, i64* %size.addr.i7, align 8
  %tobool.i8 = icmp ne i64 %17, 0
  br i1 %tobool.i8, label %if.end.i11, label %if.then.i9

if.then.i9:                                       ; preds = %if.end.i
  store i32 0, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end.i11:                                       ; preds = %if.end.i
  %18 = load i64, i64* %size.addr.i7, align 8
  %cmp.i10 = icmp ule i64 %18, 8
  br i1 %cmp.i10, label %if.then1.i12, label %if.end2.i

if.then1.i12:                                     ; preds = %if.end.i11
  store i32 3, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end2.i:                                        ; preds = %if.end.i11
  %19 = load i64, i64* %size.addr.i7, align 8
  %cmp3.i = icmp ugt i64 %19, 64
  br i1 %cmp3.i, label %land.lhs.true.i, label %if.end6.i

land.lhs.true.i:                                  ; preds = %if.end2.i
  %20 = load i64, i64* %size.addr.i7, align 8
  %cmp4.i = icmp ule i64 %20, 96
  br i1 %cmp4.i, label %if.then5.i, label %if.end6.i

if.then5.i:                                       ; preds = %land.lhs.true.i
  store i32 1, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end6.i:                                        ; preds = %land.lhs.true.i, %if.end2.i
  %21 = load i64, i64* %size.addr.i7, align 8
  %cmp7.i = icmp ugt i64 %21, 128
  br i1 %cmp7.i, label %land.lhs.true8.i, label %if.end11.i

land.lhs.true8.i:                                 ; preds = %if.end6.i
  %22 = load i64, i64* %size.addr.i7, align 8
  %cmp9.i = icmp ule i64 %22, 192
  br i1 %cmp9.i, label %if.then10.i, label %if.end11.i

if.then10.i:                                      ; preds = %land.lhs.true8.i
  store i32 2, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end11.i:                                       ; preds = %land.lhs.true8.i, %if.end6.i
  %23 = load i64, i64* %size.addr.i7, align 8
  %cmp12.i = icmp ule i64 %23, 8
  br i1 %cmp12.i, label %if.then13.i, label %if.end14.i

if.then13.i:                                      ; preds = %if.end11.i
  store i32 3, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end14.i:                                       ; preds = %if.end11.i
  %24 = load i64, i64* %size.addr.i7, align 8
  %cmp15.i = icmp ule i64 %24, 16
  br i1 %cmp15.i, label %if.then16.i, label %if.end17.i

if.then16.i:                                      ; preds = %if.end14.i
  store i32 4, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end17.i:                                       ; preds = %if.end14.i
  %25 = load i64, i64* %size.addr.i7, align 8
  %cmp18.i = icmp ule i64 %25, 32
  br i1 %cmp18.i, label %if.then19.i, label %if.end20.i

if.then19.i:                                      ; preds = %if.end17.i
  store i32 5, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end20.i:                                       ; preds = %if.end17.i
  %26 = load i64, i64* %size.addr.i7, align 8
  %cmp21.i = icmp ule i64 %26, 64
  br i1 %cmp21.i, label %if.then22.i, label %if.end23.i

if.then22.i:                                      ; preds = %if.end20.i
  store i32 6, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end23.i:                                       ; preds = %if.end20.i
  %27 = load i64, i64* %size.addr.i7, align 8
  %cmp24.i = icmp ule i64 %27, 128
  br i1 %cmp24.i, label %if.then25.i, label %if.end26.i

if.then25.i:                                      ; preds = %if.end23.i
  store i32 7, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end26.i:                                       ; preds = %if.end23.i
  %28 = load i64, i64* %size.addr.i7, align 8
  %cmp27.i = icmp ule i64 %28, 256
  br i1 %cmp27.i, label %if.then28.i, label %if.end29.i

if.then28.i:                                      ; preds = %if.end26.i
  store i32 8, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end29.i:                                       ; preds = %if.end26.i
  %29 = load i64, i64* %size.addr.i7, align 8
  %cmp30.i = icmp ule i64 %29, 512
  br i1 %cmp30.i, label %if.then31.i, label %if.end32.i

if.then31.i:                                      ; preds = %if.end29.i
  store i32 9, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end32.i:                                       ; preds = %if.end29.i
  %30 = load i64, i64* %size.addr.i7, align 8
  %cmp33.i = icmp ule i64 %30, 1024
  br i1 %cmp33.i, label %if.then34.i, label %if.end35.i

if.then34.i:                                      ; preds = %if.end32.i
  store i32 10, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end35.i:                                       ; preds = %if.end32.i
  %31 = load i64, i64* %size.addr.i7, align 8
  %cmp36.i = icmp ule i64 %31, 2048
  br i1 %cmp36.i, label %if.then37.i, label %if.end38.i

if.then37.i:                                      ; preds = %if.end35.i
  store i32 11, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end38.i:                                       ; preds = %if.end35.i
  %32 = load i64, i64* %size.addr.i7, align 8
  %cmp39.i = icmp ule i64 %32, 4096
  br i1 %cmp39.i, label %if.then40.i, label %if.end41.i

if.then40.i:                                      ; preds = %if.end38.i
  store i32 12, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end41.i:                                       ; preds = %if.end38.i
  %33 = load i64, i64* %size.addr.i7, align 8
  %cmp42.i = icmp ule i64 %33, 8192
  br i1 %cmp42.i, label %if.then43.i, label %if.end44.i

if.then43.i:                                      ; preds = %if.end41.i
  store i32 13, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end44.i:                                       ; preds = %if.end41.i
  %34 = load i64, i64* %size.addr.i7, align 8
  %cmp45.i = icmp ule i64 %34, 16384
  br i1 %cmp45.i, label %if.then46.i, label %if.end47.i

if.then46.i:                                      ; preds = %if.end44.i
  store i32 14, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end47.i:                                       ; preds = %if.end44.i
  %35 = load i64, i64* %size.addr.i7, align 8
  %cmp48.i = icmp ule i64 %35, 32768
  br i1 %cmp48.i, label %if.then49.i, label %if.end50.i

if.then49.i:                                      ; preds = %if.end47.i
  store i32 15, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end50.i:                                       ; preds = %if.end47.i
  %36 = load i64, i64* %size.addr.i7, align 8
  %cmp51.i = icmp ule i64 %36, 65536
  br i1 %cmp51.i, label %if.then52.i, label %if.end53.i

if.then52.i:                                      ; preds = %if.end50.i
  store i32 16, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end53.i:                                       ; preds = %if.end50.i
  %37 = load i64, i64* %size.addr.i7, align 8
  %cmp54.i = icmp ule i64 %37, 131072
  br i1 %cmp54.i, label %if.then55.i, label %if.end56.i

if.then55.i:                                      ; preds = %if.end53.i
  store i32 17, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end56.i:                                       ; preds = %if.end53.i
  %38 = load i64, i64* %size.addr.i7, align 8
  %cmp57.i = icmp ule i64 %38, 262144
  br i1 %cmp57.i, label %if.then58.i, label %if.end59.i

if.then58.i:                                      ; preds = %if.end56.i
  store i32 18, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end59.i:                                       ; preds = %if.end56.i
  %39 = load i64, i64* %size.addr.i7, align 8
  %cmp60.i = icmp ule i64 %39, 524288
  br i1 %cmp60.i, label %if.then61.i, label %if.end62.i

if.then61.i:                                      ; preds = %if.end59.i
  store i32 19, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end62.i:                                       ; preds = %if.end59.i
  %40 = load i64, i64* %size.addr.i7, align 8
  %cmp63.i = icmp ule i64 %40, 1048576
  br i1 %cmp63.i, label %if.then64.i, label %if.end65.i

if.then64.i:                                      ; preds = %if.end62.i
  store i32 20, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end65.i:                                       ; preds = %if.end62.i
  %41 = load i64, i64* %size.addr.i7, align 8
  %cmp66.i = icmp ule i64 %41, 2097152
  br i1 %cmp66.i, label %if.then67.i, label %if.end68.i

if.then67.i:                                      ; preds = %if.end65.i
  store i32 21, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.end68.i:                                       ; preds = %if.end65.i
  %42 = load i8, i8* %size_is_constant.addr.i, align 1
  %tobool69.i = trunc i8 %42 to i1
  br i1 %tobool69.i, label %if.then70.i, label %if.else.i

if.then70.i:                                      ; preds = %if.end68.i
  store i32 -1, i32* %retval.i6, align 4
  br label %__kmalloc_index.exit

if.else.i:                                        ; preds = %if.end68.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.217, i64 0, i64 0), i32 434, i32 0, i64 12) #19, !srcloc !20
  unreachable

__kmalloc_index.exit:                             ; preds = %if.then.i9, %if.then1.i12, %if.then5.i, %if.then10.i, %if.then13.i, %if.then16.i, %if.then19.i, %if.then22.i, %if.then25.i, %if.then28.i, %if.then31.i, %if.then34.i, %if.then37.i, %if.then40.i, %if.then43.i, %if.then46.i, %if.then49.i, %if.then52.i, %if.then55.i, %if.then58.i, %if.then61.i, %if.then64.i, %if.then67.i, %if.then70.i
  %43 = load i32, i32* %retval.i6, align 4
  store i32 %43, i32* %index.i, align 4
  %44 = load i32, i32* %index.i, align 4
  %tobool.i = icmp ne i32 %44, 0
  br i1 %tobool.i, label %if.end4.i, label %if.then3.i

if.then3.i:                                       ; preds = %__kmalloc_index.exit
  store i8* inttoptr (i64 16 to i8*), i8** %retval.i, align 8
  br label %kmalloc.exit

if.end4.i:                                        ; preds = %__kmalloc_index.exit
  %45 = load i32, i32* %flags.addr.i, align 4
  store i32 %45, i32* %flags.addr.i14, align 4
  %46 = load i32, i32* %flags.addr.i14, align 4
  %and.i = and i32 %46, 17
  %cmp.i15 = icmp eq i32 %and.i, 0
  %lnot.i = xor i1 %cmp.i15, true
  %lnot.ext.i = zext i1 %cmp.i15 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %cmp.i15, label %if.then.i16, label %if.end.i17

if.then.i16:                                      ; preds = %if.end4.i
  store i32 0, i32* %retval.i13, align 4
  br label %kmalloc_type.exit

if.end.i17:                                       ; preds = %if.end4.i
  %47 = load i32, i32* %flags.addr.i14, align 4
  %and2.i = and i32 %47, 1
  %tobool3.i = icmp ne i32 %and2.i, 0
  br i1 %tobool3.i, label %if.then4.i, label %if.end5.i

if.then4.i:                                       ; preds = %if.end.i17
  store i32 2, i32* %retval.i13, align 4
  br label %kmalloc_type.exit

if.end5.i:                                        ; preds = %if.end.i17
  store i32 1, i32* %retval.i13, align 4
  br label %kmalloc_type.exit

kmalloc_type.exit:                                ; preds = %if.then.i16, %if.then4.i, %if.end5.i
  %48 = load i32, i32* %retval.i13, align 4
  %idxprom.i = zext i32 %48 to i64
  %arrayidx.i = getelementptr [3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 %idxprom.i
  %49 = load i32, i32* %index.i, align 4
  %idxprom6.i = zext i32 %49 to i64
  %arrayidx7.i = getelementptr [14 x %struct.kmem_cache*], [14 x %struct.kmem_cache*]* %arrayidx.i, i64 0, i64 %idxprom6.i
  %50 = load %struct.kmem_cache*, %struct.kmem_cache** %arrayidx7.i, align 8
  %51 = load i32, i32* %flags.addr.i, align 4
  %52 = load i64, i64* %size.addr.i, align 8
  %call8.i = call noalias align 8 i8* @kmalloc_trace(%struct.kmem_cache* noundef %50, i32 noundef %51, i64 noundef %52) #27
  store i8* %call8.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end9.i:                                        ; preds = %if.then2
  %53 = load i64, i64* %size.addr.i, align 8
  %54 = load i32, i32* %flags.addr.i, align 4
  %call10.i = call noalias align 8 i8* @__kmalloc(i64 noundef %53, i32 noundef %54) #26
  store i8* %call10.i, i8** %retval.i, align 8
  br label %kmalloc.exit

kmalloc.exit:                                     ; preds = %if.then1.i, %if.then3.i, %kmalloc_type.exit, %if.end9.i
  %55 = load i8*, i8** %retval.i, align 8
  store i8* %55, i8** %retval, align 8
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %56 = load i64, i64* %bytes, align 8
  %57 = load i32, i32* %flags.addr, align 4
  %call5 = call noalias align 8 i8* @__kmalloc(i64 noundef %56, i32 noundef %57) #24
  store i8* %call5, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %kmalloc.exit, %if.then
  %58 = load i8*, i8** %retval, align 8
  ret i8* %58
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @convert_pseudo_ld_imm64(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 12
  %3 = bitcast %union.anon.198* %2 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 2
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 4
  %6 = load i32, i32* %len, align 4
  store i32 %6, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 0
  %10 = load i8, i8* %code, align 4
  %conv = zext i8 %10 to i32
  %cmp2 = icmp ne i32 %conv, 24
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv4 = zext i8 %bf.lshr to i32
  %cmp5 = icmp eq i32 %conv4, 4
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  br label %for.inc

if.end8:                                          ; preds = %if.end
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %12, i32 0, i32 1
  %bf.load10 = load i8, i8* %src_reg9, align 1
  %bf.clear = and i8 %bf.load10, 15
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, i8* %src_reg9, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end8, %if.then7, %if.then
  %13 = load i32, i32* %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %i, align 4
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %14, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond, !llvm.loop !47

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_btf_func(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux = alloca %struct.bpf_prog_aux*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1, align 8
  store %struct.bpf_prog_aux* %2, %struct.bpf_prog_aux** %aux, align 8
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 51
  %4 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info, align 8
  %tobool = icmp ne %struct.bpf_func_info* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, i32* %i, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 31
  %7 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %5, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 27
  %9 = load i32, i32* %i, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %10 = load i32, i32* %start, align 8
  %11 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %11, i32 0, i32 51
  %12 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info2, align 8
  %13 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %13 to i64
  %arrayidx4 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %12, i64 %idxprom3
  %insn_off = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx4, i32 0, i32 0
  store i32 %10, i32* %insn_off, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !48

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @release_maps(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 11
  %arraydecay = getelementptr inbounds [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps, i64 0, i64 0
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 13
  %5 = load i32, i32* %used_map_cnt, align 8
  call void @__bpf_free_used_maps(%struct.bpf_prog_aux* noundef %2, %struct.bpf_map** noundef %arraydecay, i32 noundef %5) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @release_btfs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btfs = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 12
  %arraydecay = getelementptr inbounds [64 x %struct.btf_mod_pair], [64 x %struct.btf_mod_pair]* %used_btfs, i64 0, i64 0
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btf_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 14
  %5 = load i32, i32* %used_btf_cnt, align 4
  call void @__bpf_free_used_btfs(%struct.bpf_prog_aux* noundef %2, %struct.btf_mod_pair* noundef %arraydecay, i32 noundef %5) #20
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @vfree(i8* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @_copy_to_user(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1 immarg, i1 immarg, i1 immarg) #9

; Function Attrs: convergent nofree nosync nounwind readnone willreturn
declare i1 @llvm.is.constant.i64(i64) #10

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @copy_overflow(i32 noundef %size, i64 noundef %count) #0 {
entry:
  %size.addr = alloca i32, align 4
  %count.addr = alloca i64, align 8
  store i32 %size, i32* %size.addr, align 4
  store i64 %count, i64* %count.addr, align 8
  %0 = load i32, i32* %size.addr, align 4
  %1 = load i64, i64* %count.addr, align 8
  call void @__copy_overflow(i32 noundef %0, i64 noundef %1) #20
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bad_copy_from() #11

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bad_copy_to() #12

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @check_object_size(i8* noundef %ptr, i64 noundef %n, i1 noundef zeroext %to_user) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %to_user.addr = alloca i8, align 1
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  %frombool = zext i1 %to_user to i8
  store i8 %frombool, i8* %to_user.addr, align 1
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__copy_overflow(i32 noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_spilled_reg(%struct.bpf_stack_state* noundef %stack) #0 {
entry:
  %stack.addr = alloca %struct.bpf_stack_state*, align 8
  store %struct.bpf_stack_state* %stack, %struct.bpf_stack_state** %stack.addr, align 8
  %0 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack.addr, align 8
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %0, i32 0, i32 1
  %arrayidx = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 7
  %1 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 1
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @backtrack_insn(%struct.bpf_verifier_env* noundef %env, i32 noundef %idx, i32* noundef %reg_mask, i64* noundef %stack_mask) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %idx.addr = alloca i32, align 4
  %reg_mask.addr = alloca i32*, align 8
  %stack_mask.addr = alloca i64*, align 8
  %cbs = alloca %struct.bpf_insn_cbs, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %class = alloca i8, align 1
  %opcode = alloca i8, align 1
  %mode = alloca i8, align 1
  %dreg = alloca i32, align 4
  %sreg = alloca i32, align 4
  %spi = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_cond = alloca i8, align 1
  %__ret_once = alloca i8, align 1
  %tmp = alloca i64, align 8
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp121 = alloca i64, align 8
  %tmp129 = alloca i64, align 8
  %__ret_do_once168 = alloca i8, align 1
  %__ret_cond169 = alloca i8, align 1
  %__ret_once176 = alloca i8, align 1
  %tmp192 = alloca i64, align 8
  %__ret_warn_on201 = alloca i32, align 4
  %__flags214 = alloca i32, align 4
  %tmp226 = alloca i64, align 8
  %tmp234 = alloca i64, align 8
  %__ret_do_once283 = alloca i8, align 1
  %__ret_cond284 = alloca i8, align 1
  %__ret_once291 = alloca i8, align 1
  %tmp307 = alloca i64, align 8
  %__ret_warn_on316 = alloca i32, align 4
  %__flags329 = alloca i32, align 4
  %tmp341 = alloca i64, align 8
  %tmp349 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i32* %reg_mask, i32** %reg_mask.addr, align 8
  store i64* %stack_mask, i64** %stack_mask.addr, align 8
  %cb_print = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 0
  store void (i8*, i8*, ...)* @verbose, void (i8*, i8*, ...)** %cb_print, align 8
  %cb_call = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 1
  store i8* (i8*, %struct.bpf_insn*)* @disasm_kfunc_name, i8* (i8*, %struct.bpf_insn*)** %cb_call, align 8
  %cb_imm = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 2
  store i8* (i8*, %struct.bpf_insn*, i64)* null, i8* (i8*, %struct.bpf_insn*, i64)** %cb_imm, align 8
  %private_data = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 3
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = bitcast %struct.bpf_verifier_env* %0 to i8*
  store i8* %1, i8** %private_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %4 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 12
  %5 = bitcast %union.anon.198* %4 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %5, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  %6 = load i32, i32* %idx.addr, align 4
  %idx.ext = sext i32 %6 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %insn, align 8
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 0
  %8 = load i8, i8* %code, align 4
  %conv = zext i8 %8 to i32
  %and = and i32 %conv, 7
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %class, align 1
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 0
  %10 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %10 to i32
  %and4 = and i32 %conv3, 240
  %conv5 = trunc i32 %and4 to i8
  store i8 %conv5, i8* %opcode, align 1
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 0
  %12 = load i8, i8* %code6, align 4
  %conv7 = zext i8 %12 to i32
  %and8 = and i32 %conv7, 224
  %conv9 = trunc i32 %and8 to i8
  store i8 %conv9, i8* %mode, align 1
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv10 = zext i8 %bf.clear to i32
  %shl = shl i32 1, %conv10
  store i32 %shl, i32* %dreg, align 4
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %14, i32 0, i32 1
  %bf.load11 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load11, 4
  %conv12 = zext i8 %bf.lshr to i32
  %shl13 = shl i32 1, %conv12
  store i32 %shl13, i32* %sreg, align 4
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code14 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 0
  %16 = load i8, i8* %code14, align 4
  %conv15 = zext i8 %16 to i32
  %cmp = icmp eq i32 %conv15, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %18 = load i32, i32* %level, align 8
  %and17 = and i32 %18, 2
  %tobool = icmp ne i32 %and17, 0
  br i1 %tobool, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  %21 = load i32*, i32** %reg_mask.addr, align 8
  %22 = load i32, i32* %21, align 4
  %23 = load i64*, i64** %stack_mask.addr, align 8
  %24 = load i64, i64* %23, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.36, i64 0, i64 0), i32 noundef %22, i64 noundef %24) #20
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load i32, i32* %idx.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.37, i64 0, i64 0), i32 noundef %27) #20
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 17
  %30 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool19 = trunc i8 %30 to i1
  call void @print_bpf_insn(%struct.bpf_insn_cbs* noundef %cbs, %struct.bpf_insn* noundef %28, i1 noundef zeroext %tobool19) #20
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end
  %31 = load i8, i8* %class, align 1
  %conv21 = zext i8 %31 to i32
  %cmp22 = icmp eq i32 %conv21, 4
  br i1 %cmp22, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end20
  %32 = load i8, i8* %class, align 1
  %conv24 = zext i8 %32 to i32
  %cmp25 = icmp eq i32 %conv24, 7
  br i1 %cmp25, label %if.then27, label %if.else56

if.then27:                                        ; preds = %lor.lhs.false, %if.end20
  %33 = load i32*, i32** %reg_mask.addr, align 8
  %34 = load i32, i32* %33, align 4
  %35 = load i32, i32* %dreg, align 4
  %and28 = and i32 %34, %35
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.then27
  store i32 0, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.then27
  %36 = load i8, i8* %opcode, align 1
  %conv32 = zext i8 %36 to i32
  %cmp33 = icmp eq i32 %conv32, 176
  br i1 %cmp33, label %if.then35, label %if.else46

if.then35:                                        ; preds = %if.end31
  %37 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code36 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %37, i32 0, i32 0
  %38 = load i8, i8* %code36, align 4
  %conv37 = zext i8 %38 to i32
  %and38 = and i32 %conv37, 8
  %cmp39 = icmp eq i32 %and38, 8
  br i1 %cmp39, label %if.then41, label %if.else

if.then41:                                        ; preds = %if.then35
  %39 = load i32, i32* %dreg, align 4
  %neg = xor i32 %39, -1
  %40 = load i32*, i32** %reg_mask.addr, align 8
  %41 = load i32, i32* %40, align 4
  %and42 = and i32 %41, %neg
  store i32 %and42, i32* %40, align 4
  %42 = load i32, i32* %sreg, align 4
  %43 = load i32*, i32** %reg_mask.addr, align 8
  %44 = load i32, i32* %43, align 4
  %or = or i32 %44, %42
  store i32 %or, i32* %43, align 4
  br label %if.end45

if.else:                                          ; preds = %if.then35
  %45 = load i32, i32* %dreg, align 4
  %neg43 = xor i32 %45, -1
  %46 = load i32*, i32** %reg_mask.addr, align 8
  %47 = load i32, i32* %46, align 4
  %and44 = and i32 %47, %neg43
  store i32 %and44, i32* %46, align 4
  br label %if.end45

if.end45:                                         ; preds = %if.else, %if.then41
  br label %if.end55

if.else46:                                        ; preds = %if.end31
  %48 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code47 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %48, i32 0, i32 0
  %49 = load i8, i8* %code47, align 4
  %conv48 = zext i8 %49 to i32
  %and49 = and i32 %conv48, 8
  %cmp50 = icmp eq i32 %and49, 8
  br i1 %cmp50, label %if.then52, label %if.end54

if.then52:                                        ; preds = %if.else46
  %50 = load i32, i32* %sreg, align 4
  %51 = load i32*, i32** %reg_mask.addr, align 8
  %52 = load i32, i32* %51, align 4
  %or53 = or i32 %52, %50
  store i32 %or53, i32* %51, align 4
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %if.else46
  br label %if.end55

if.end55:                                         ; preds = %if.end54, %if.end45
  br label %if.end388

if.else56:                                        ; preds = %lor.lhs.false
  %53 = load i8, i8* %class, align 1
  %conv57 = zext i8 %53 to i32
  %cmp58 = icmp eq i32 %conv57, 1
  br i1 %cmp58, label %if.then60, label %if.else139

if.then60:                                        ; preds = %if.else56
  %54 = load i32*, i32** %reg_mask.addr, align 8
  %55 = load i32, i32* %54, align 4
  %56 = load i32, i32* %dreg, align 4
  %and61 = and i32 %55, %56
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.end64, label %if.then63

if.then63:                                        ; preds = %if.then60
  store i32 0, i32* %retval, align 4
  br label %return

if.end64:                                         ; preds = %if.then60
  %57 = load i32, i32* %dreg, align 4
  %neg65 = xor i32 %57, -1
  %58 = load i32*, i32** %reg_mask.addr, align 8
  %59 = load i32, i32* %58, align 4
  %and66 = and i32 %59, %neg65
  store i32 %and66, i32* %58, align 4
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg67 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %60, i32 0, i32 1
  %bf.load68 = load i8, i8* %src_reg67, align 1
  %bf.lshr69 = lshr i8 %bf.load68, 4
  %conv70 = zext i8 %bf.lshr69 to i32
  %cmp71 = icmp ne i32 %conv70, 10
  br i1 %cmp71, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.end64
  store i32 0, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %if.end64
  %61 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %61, i32 0, i32 2
  %62 = load i16, i16* %off, align 2
  %conv75 = sext i16 %62 to i32
  %sub = sub i32 0, %conv75
  %sub76 = sub i32 %sub, 1
  %div = sdiv i32 %sub76, 8
  store i32 %div, i32* %spi, align 4
  %63 = load i32, i32* %spi, align 4
  %cmp77 = icmp uge i32 %63, 64
  br i1 %cmp77, label %if.then79, label %if.end136

if.then79:                                        ; preds = %if.end74
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = bitcast %struct.bpf_verifier_env* %64 to i8*
  %66 = load i32, i32* %spi, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %65, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.38, i64 0, i64 0), i32 noundef %66) #20
  store i8 1, i8* %__ret_do_once, align 1
  %67 = load i8, i8* %__ret_do_once, align 1
  %tobool80 = trunc i8 %67 to i1
  %lnot = xor i1 %tobool80, true
  %lnot81 = xor i1 %lnot, true
  %frombool = zext i1 %lnot81 to i8
  store i8 %frombool, i8* %__ret_cond, align 1
  store i8 0, i8* %__ret_once, align 1
  %68 = load i8, i8* %__ret_cond, align 1
  %tobool82 = trunc i8 %68 to i1
  br i1 %tobool82, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then79
  %69 = load i8, i8* @backtrack_insn.__already_done, align 1
  %tobool84 = trunc i8 %69 to i1
  %lnot85 = xor i1 %tobool84, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then79
  %70 = phi i1 [ false, %if.then79 ], [ %lnot85, %land.rhs ]
  %lnot86 = xor i1 %70, true
  %lnot87 = xor i1 %lnot86, true
  %lnot.ext = zext i1 %lnot87 to i32
  %conv88 = sext i32 %lnot.ext to i64
  %tobool89 = icmp ne i64 %conv88, 0
  br i1 %tobool89, label %if.then90, label %if.end91

if.then90:                                        ; preds = %land.end
  store i8 1, i8* @backtrack_insn.__already_done, align 1
  store i8 1, i8* %__ret_once, align 1
  br label %if.end91

if.end91:                                         ; preds = %if.then90, %land.end
  %71 = load i8, i8* %__ret_once, align 1
  %tobool92 = trunc i8 %71 to i1
  %lnot93 = xor i1 %tobool92, true
  %lnot95 = xor i1 %lnot93, true
  %lnot.ext96 = zext i1 %lnot95 to i32
  %conv97 = sext i32 %lnot.ext96 to i64
  store i64 %conv97, i64* %tmp, align 8
  %72 = load i64, i64* %tmp, align 8
  %tobool98 = icmp ne i64 %72, 0
  br i1 %tobool98, label %if.then99, label %if.end128

if.then99:                                        ; preds = %if.end91
  store i32 1, i32* %__ret_warn_on, align 4
  %73 = load i32, i32* %__ret_warn_on, align 4
  %tobool100 = icmp ne i32 %73, 0
  %lnot101 = xor i1 %tobool100, true
  %lnot103 = xor i1 %lnot101, true
  %lnot.ext104 = zext i1 %lnot103 to i32
  %conv105 = sext i32 %lnot.ext104 to i64
  %tobool106 = icmp ne i64 %conv105, 0
  br i1 %tobool106, label %if.then107, label %if.end120

if.then107:                                       ; preds = %if.then99
  br label %do.body

do.body:                                          ; preds = %if.then107
  br label %do.body108

do.body108:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body108
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.32, i64 0, i64 0)) #20
  br label %do.body109

do.body109:                                       ; preds = %do.end
  store i32 2313, i32* %__flags, align 4
  br label %do.body110

do.body110:                                       ; preds = %do.body109
  br label %do.end111

do.end111:                                        ; preds = %do.body110
  br label %do.body112

do.body112:                                       ; preds = %do.end111
  %74 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2724, i32 %74, i64 12) #19, !srcloc !49
  br label %do.end113

do.end113:                                        ; preds = %do.body112
  br label %do.body114

do.body114:                                       ; preds = %do.end113
  br label %do.end115

do.end115:                                        ; preds = %do.body114
  br label %do.end116

do.end116:                                        ; preds = %do.end115
  br label %do.body117

do.body117:                                       ; preds = %do.end116
  br label %do.end118

do.end118:                                        ; preds = %do.body117
  br label %do.end119

do.end119:                                        ; preds = %do.end118
  br label %if.end120

if.end120:                                        ; preds = %do.end119, %if.then99
  %75 = load i32, i32* %__ret_warn_on, align 4
  %tobool122 = icmp ne i32 %75, 0
  %lnot123 = xor i1 %tobool122, true
  %lnot125 = xor i1 %lnot123, true
  %lnot.ext126 = zext i1 %lnot125 to i32
  %conv127 = sext i32 %lnot.ext126 to i64
  store i64 %conv127, i64* %tmp121, align 8
  %76 = load i64, i64* %tmp121, align 8
  br label %if.end128

if.end128:                                        ; preds = %if.end120, %if.end91
  %77 = load i8, i8* %__ret_do_once, align 1
  %tobool130 = trunc i8 %77 to i1
  %lnot131 = xor i1 %tobool130, true
  %lnot133 = xor i1 %lnot131, true
  %lnot.ext134 = zext i1 %lnot133 to i32
  %conv135 = sext i32 %lnot.ext134 to i64
  store i64 %conv135, i64* %tmp129, align 8
  %78 = load i64, i64* %tmp129, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end136:                                        ; preds = %if.end74
  %79 = load i32, i32* %spi, align 4
  %sh_prom = zext i32 %79 to i64
  %shl137 = shl i64 1, %sh_prom
  %80 = load i64*, i64** %stack_mask.addr, align 8
  %81 = load i64, i64* %80, align 8
  %or138 = or i64 %81, %shl137
  store i64 %or138, i64* %80, align 8
  br label %if.end387

if.else139:                                       ; preds = %if.else56
  %82 = load i8, i8* %class, align 1
  %conv140 = zext i8 %82 to i32
  %cmp141 = icmp eq i32 %conv140, 3
  br i1 %cmp141, label %if.then147, label %lor.lhs.false143

lor.lhs.false143:                                 ; preds = %if.else139
  %83 = load i8, i8* %class, align 1
  %conv144 = zext i8 %83 to i32
  %cmp145 = icmp eq i32 %conv144, 2
  br i1 %cmp145, label %if.then147, label %if.else258

if.then147:                                       ; preds = %lor.lhs.false143, %if.else139
  %84 = load i32*, i32** %reg_mask.addr, align 8
  %85 = load i32, i32* %84, align 4
  %86 = load i32, i32* %dreg, align 4
  %and148 = and i32 %85, %86
  %tobool149 = icmp ne i32 %and148, 0
  br i1 %tobool149, label %if.then150, label %if.end151

if.then150:                                       ; preds = %if.then147
  store i32 -524, i32* %retval, align 4
  br label %return

if.end151:                                        ; preds = %if.then147
  %87 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg152 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %87, i32 0, i32 1
  %bf.load153 = load i8, i8* %dst_reg152, align 1
  %bf.clear154 = and i8 %bf.load153, 15
  %conv155 = zext i8 %bf.clear154 to i32
  %cmp156 = icmp ne i32 %conv155, 10
  br i1 %cmp156, label %if.then158, label %if.end159

if.then158:                                       ; preds = %if.end151
  store i32 0, i32* %retval, align 4
  br label %return

if.end159:                                        ; preds = %if.end151
  %88 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off160 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %88, i32 0, i32 2
  %89 = load i16, i16* %off160, align 2
  %conv161 = sext i16 %89 to i32
  %sub162 = sub i32 0, %conv161
  %sub163 = sub i32 %sub162, 1
  %div164 = sdiv i32 %sub163, 8
  store i32 %div164, i32* %spi, align 4
  %90 = load i32, i32* %spi, align 4
  %cmp165 = icmp uge i32 %90, 64
  br i1 %cmp165, label %if.then167, label %if.end241

if.then167:                                       ; preds = %if.end159
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %92 = bitcast %struct.bpf_verifier_env* %91 to i8*
  %93 = load i32, i32* %spi, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %92, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.38, i64 0, i64 0), i32 noundef %93) #20
  store i8 1, i8* %__ret_do_once168, align 1
  %94 = load i8, i8* %__ret_do_once168, align 1
  %tobool170 = trunc i8 %94 to i1
  %lnot171 = xor i1 %tobool170, true
  %lnot173 = xor i1 %lnot171, true
  %frombool175 = zext i1 %lnot173 to i8
  store i8 %frombool175, i8* %__ret_cond169, align 1
  store i8 0, i8* %__ret_once176, align 1
  %95 = load i8, i8* %__ret_cond169, align 1
  %tobool177 = trunc i8 %95 to i1
  br i1 %tobool177, label %land.rhs179, label %land.end183

land.rhs179:                                      ; preds = %if.then167
  %96 = load i8, i8* @backtrack_insn.__already_done.39, align 1
  %tobool180 = trunc i8 %96 to i1
  %lnot181 = xor i1 %tobool180, true
  br label %land.end183

land.end183:                                      ; preds = %land.rhs179, %if.then167
  %97 = phi i1 [ false, %if.then167 ], [ %lnot181, %land.rhs179 ]
  %lnot184 = xor i1 %97, true
  %lnot186 = xor i1 %lnot184, true
  %lnot.ext187 = zext i1 %lnot186 to i32
  %conv188 = sext i32 %lnot.ext187 to i64
  %tobool189 = icmp ne i64 %conv188, 0
  br i1 %tobool189, label %if.then190, label %if.end191

if.then190:                                       ; preds = %land.end183
  store i8 1, i8* @backtrack_insn.__already_done.39, align 1
  store i8 1, i8* %__ret_once176, align 1
  br label %if.end191

if.end191:                                        ; preds = %if.then190, %land.end183
  %98 = load i8, i8* %__ret_once176, align 1
  %tobool193 = trunc i8 %98 to i1
  %lnot194 = xor i1 %tobool193, true
  %lnot196 = xor i1 %lnot194, true
  %lnot.ext197 = zext i1 %lnot196 to i32
  %conv198 = sext i32 %lnot.ext197 to i64
  store i64 %conv198, i64* %tmp192, align 8
  %99 = load i64, i64* %tmp192, align 8
  %tobool199 = icmp ne i64 %99, 0
  br i1 %tobool199, label %if.then200, label %if.end233

if.then200:                                       ; preds = %if.end191
  store i32 1, i32* %__ret_warn_on201, align 4
  %100 = load i32, i32* %__ret_warn_on201, align 4
  %tobool202 = icmp ne i32 %100, 0
  %lnot203 = xor i1 %tobool202, true
  %lnot205 = xor i1 %lnot203, true
  %lnot.ext206 = zext i1 %lnot205 to i32
  %conv207 = sext i32 %lnot.ext206 to i64
  %tobool208 = icmp ne i64 %conv207, 0
  br i1 %tobool208, label %if.then209, label %if.end225

if.then209:                                       ; preds = %if.then200
  br label %do.body210

do.body210:                                       ; preds = %if.then209
  br label %do.body211

do.body211:                                       ; preds = %do.body210
  br label %do.end212

do.end212:                                        ; preds = %do.body211
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.32, i64 0, i64 0)) #20
  br label %do.body213

do.body213:                                       ; preds = %do.end212
  store i32 2313, i32* %__flags214, align 4
  br label %do.body215

do.body215:                                       ; preds = %do.body213
  br label %do.end216

do.end216:                                        ; preds = %do.body215
  br label %do.body217

do.body217:                                       ; preds = %do.end216
  %101 = load i32, i32* %__flags214, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2741, i32 %101, i64 12) #19, !srcloc !50
  br label %do.end218

do.end218:                                        ; preds = %do.body217
  br label %do.body219

do.body219:                                       ; preds = %do.end218
  br label %do.end220

do.end220:                                        ; preds = %do.body219
  br label %do.end221

do.end221:                                        ; preds = %do.end220
  br label %do.body222

do.body222:                                       ; preds = %do.end221
  br label %do.end223

do.end223:                                        ; preds = %do.body222
  br label %do.end224

do.end224:                                        ; preds = %do.end223
  br label %if.end225

if.end225:                                        ; preds = %do.end224, %if.then200
  %102 = load i32, i32* %__ret_warn_on201, align 4
  %tobool227 = icmp ne i32 %102, 0
  %lnot228 = xor i1 %tobool227, true
  %lnot230 = xor i1 %lnot228, true
  %lnot.ext231 = zext i1 %lnot230 to i32
  %conv232 = sext i32 %lnot.ext231 to i64
  store i64 %conv232, i64* %tmp226, align 8
  %103 = load i64, i64* %tmp226, align 8
  br label %if.end233

if.end233:                                        ; preds = %if.end225, %if.end191
  %104 = load i8, i8* %__ret_do_once168, align 1
  %tobool235 = trunc i8 %104 to i1
  %lnot236 = xor i1 %tobool235, true
  %lnot238 = xor i1 %lnot236, true
  %lnot.ext239 = zext i1 %lnot238 to i32
  %conv240 = sext i32 %lnot.ext239 to i64
  store i64 %conv240, i64* %tmp234, align 8
  %105 = load i64, i64* %tmp234, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end241:                                        ; preds = %if.end159
  %106 = load i64*, i64** %stack_mask.addr, align 8
  %107 = load i64, i64* %106, align 8
  %108 = load i32, i32* %spi, align 4
  %sh_prom242 = zext i32 %108 to i64
  %shl243 = shl i64 1, %sh_prom242
  %and244 = and i64 %107, %shl243
  %tobool245 = icmp ne i64 %and244, 0
  br i1 %tobool245, label %if.end247, label %if.then246

if.then246:                                       ; preds = %if.end241
  store i32 0, i32* %retval, align 4
  br label %return

if.end247:                                        ; preds = %if.end241
  %109 = load i32, i32* %spi, align 4
  %sh_prom248 = zext i32 %109 to i64
  %shl249 = shl i64 1, %sh_prom248
  %neg250 = xor i64 %shl249, -1
  %110 = load i64*, i64** %stack_mask.addr, align 8
  %111 = load i64, i64* %110, align 8
  %and251 = and i64 %111, %neg250
  store i64 %and251, i64* %110, align 8
  %112 = load i8, i8* %class, align 1
  %conv252 = zext i8 %112 to i32
  %cmp253 = icmp eq i32 %conv252, 3
  br i1 %cmp253, label %if.then255, label %if.end257

if.then255:                                       ; preds = %if.end247
  %113 = load i32, i32* %sreg, align 4
  %114 = load i32*, i32** %reg_mask.addr, align 8
  %115 = load i32, i32* %114, align 4
  %or256 = or i32 %115, %113
  store i32 %or256, i32* %114, align 4
  br label %if.end257

if.end257:                                        ; preds = %if.then255, %if.end247
  br label %if.end386

if.else258:                                       ; preds = %lor.lhs.false143
  %116 = load i8, i8* %class, align 1
  %conv259 = zext i8 %116 to i32
  %cmp260 = icmp eq i32 %conv259, 5
  br i1 %cmp260, label %if.then266, label %lor.lhs.false262

lor.lhs.false262:                                 ; preds = %if.else258
  %117 = load i8, i8* %class, align 1
  %conv263 = zext i8 %117 to i32
  %cmp264 = icmp eq i32 %conv263, 6
  br i1 %cmp264, label %if.then266, label %if.else364

if.then266:                                       ; preds = %lor.lhs.false262, %if.else258
  %118 = load i8, i8* %opcode, align 1
  %conv267 = zext i8 %118 to i32
  %cmp268 = icmp eq i32 %conv267, 128
  br i1 %cmp268, label %if.then270, label %if.else357

if.then270:                                       ; preds = %if.then266
  %119 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg271 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %119, i32 0, i32 1
  %bf.load272 = load i8, i8* %src_reg271, align 1
  %bf.lshr273 = lshr i8 %bf.load272, 4
  %conv274 = zext i8 %bf.lshr273 to i32
  %cmp275 = icmp eq i32 %conv274, 1
  br i1 %cmp275, label %if.then277, label %if.end278

if.then277:                                       ; preds = %if.then270
  store i32 -524, i32* %retval, align 4
  br label %return

if.end278:                                        ; preds = %if.then270
  %120 = load i32*, i32** %reg_mask.addr, align 8
  %121 = load i32, i32* %120, align 4
  %and279 = and i32 %121, -2
  store i32 %and279, i32* %120, align 4
  %122 = load i32*, i32** %reg_mask.addr, align 8
  %123 = load i32, i32* %122, align 4
  %and280 = and i32 %123, 63
  %tobool281 = icmp ne i32 %and280, 0
  br i1 %tobool281, label %if.then282, label %if.end356

if.then282:                                       ; preds = %if.end278
  %124 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %125 = bitcast %struct.bpf_verifier_env* %124 to i8*
  %126 = load i32*, i32** %reg_mask.addr, align 8
  %127 = load i32, i32* %126, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %125, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.40, i64 0, i64 0), i32 noundef %127) #20
  store i8 1, i8* %__ret_do_once283, align 1
  %128 = load i8, i8* %__ret_do_once283, align 1
  %tobool285 = trunc i8 %128 to i1
  %lnot286 = xor i1 %tobool285, true
  %lnot288 = xor i1 %lnot286, true
  %frombool290 = zext i1 %lnot288 to i8
  store i8 %frombool290, i8* %__ret_cond284, align 1
  store i8 0, i8* %__ret_once291, align 1
  %129 = load i8, i8* %__ret_cond284, align 1
  %tobool292 = trunc i8 %129 to i1
  br i1 %tobool292, label %land.rhs294, label %land.end298

land.rhs294:                                      ; preds = %if.then282
  %130 = load i8, i8* @backtrack_insn.__already_done.41, align 1
  %tobool295 = trunc i8 %130 to i1
  %lnot296 = xor i1 %tobool295, true
  br label %land.end298

land.end298:                                      ; preds = %land.rhs294, %if.then282
  %131 = phi i1 [ false, %if.then282 ], [ %lnot296, %land.rhs294 ]
  %lnot299 = xor i1 %131, true
  %lnot301 = xor i1 %lnot299, true
  %lnot.ext302 = zext i1 %lnot301 to i32
  %conv303 = sext i32 %lnot.ext302 to i64
  %tobool304 = icmp ne i64 %conv303, 0
  br i1 %tobool304, label %if.then305, label %if.end306

if.then305:                                       ; preds = %land.end298
  store i8 1, i8* @backtrack_insn.__already_done.41, align 1
  store i8 1, i8* %__ret_once291, align 1
  br label %if.end306

if.end306:                                        ; preds = %if.then305, %land.end298
  %132 = load i8, i8* %__ret_once291, align 1
  %tobool308 = trunc i8 %132 to i1
  %lnot309 = xor i1 %tobool308, true
  %lnot311 = xor i1 %lnot309, true
  %lnot.ext312 = zext i1 %lnot311 to i32
  %conv313 = sext i32 %lnot.ext312 to i64
  store i64 %conv313, i64* %tmp307, align 8
  %133 = load i64, i64* %tmp307, align 8
  %tobool314 = icmp ne i64 %133, 0
  br i1 %tobool314, label %if.then315, label %if.end348

if.then315:                                       ; preds = %if.end306
  store i32 1, i32* %__ret_warn_on316, align 4
  %134 = load i32, i32* %__ret_warn_on316, align 4
  %tobool317 = icmp ne i32 %134, 0
  %lnot318 = xor i1 %tobool317, true
  %lnot320 = xor i1 %lnot318, true
  %lnot.ext321 = zext i1 %lnot320 to i32
  %conv322 = sext i32 %lnot.ext321 to i64
  %tobool323 = icmp ne i64 %conv322, 0
  br i1 %tobool323, label %if.then324, label %if.end340

if.then324:                                       ; preds = %if.then315
  br label %do.body325

do.body325:                                       ; preds = %if.then324
  br label %do.body326

do.body326:                                       ; preds = %do.body325
  br label %do.end327

do.end327:                                        ; preds = %do.body326
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.32, i64 0, i64 0)) #20
  br label %do.body328

do.body328:                                       ; preds = %do.end327
  store i32 2313, i32* %__flags329, align 4
  br label %do.body330

do.body330:                                       ; preds = %do.body328
  br label %do.end331

do.end331:                                        ; preds = %do.body330
  br label %do.body332

do.body332:                                       ; preds = %do.end331
  %135 = load i32, i32* %__flags329, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2760, i32 %135, i64 12) #19, !srcloc !51
  br label %do.end333

do.end333:                                        ; preds = %do.body332
  br label %do.body334

do.body334:                                       ; preds = %do.end333
  br label %do.end335

do.end335:                                        ; preds = %do.body334
  br label %do.end336

do.end336:                                        ; preds = %do.end335
  br label %do.body337

do.body337:                                       ; preds = %do.end336
  br label %do.end338

do.end338:                                        ; preds = %do.body337
  br label %do.end339

do.end339:                                        ; preds = %do.end338
  br label %if.end340

if.end340:                                        ; preds = %do.end339, %if.then315
  %136 = load i32, i32* %__ret_warn_on316, align 4
  %tobool342 = icmp ne i32 %136, 0
  %lnot343 = xor i1 %tobool342, true
  %lnot345 = xor i1 %lnot343, true
  %lnot.ext346 = zext i1 %lnot345 to i32
  %conv347 = sext i32 %lnot.ext346 to i64
  store i64 %conv347, i64* %tmp341, align 8
  %137 = load i64, i64* %tmp341, align 8
  br label %if.end348

if.end348:                                        ; preds = %if.end340, %if.end306
  %138 = load i8, i8* %__ret_do_once283, align 1
  %tobool350 = trunc i8 %138 to i1
  %lnot351 = xor i1 %tobool350, true
  %lnot353 = xor i1 %lnot351, true
  %lnot.ext354 = zext i1 %lnot353 to i32
  %conv355 = sext i32 %lnot.ext354 to i64
  store i64 %conv355, i64* %tmp349, align 8
  %139 = load i64, i64* %tmp349, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end356:                                        ; preds = %if.end278
  br label %if.end363

if.else357:                                       ; preds = %if.then266
  %140 = load i8, i8* %opcode, align 1
  %conv358 = zext i8 %140 to i32
  %cmp359 = icmp eq i32 %conv358, 144
  br i1 %cmp359, label %if.then361, label %if.end362

if.then361:                                       ; preds = %if.else357
  store i32 -524, i32* %retval, align 4
  br label %return

if.end362:                                        ; preds = %if.else357
  br label %if.end363

if.end363:                                        ; preds = %if.end362, %if.end356
  br label %if.end385

if.else364:                                       ; preds = %lor.lhs.false262
  %141 = load i8, i8* %class, align 1
  %conv365 = zext i8 %141 to i32
  %cmp366 = icmp eq i32 %conv365, 0
  br i1 %cmp366, label %if.then368, label %if.end384

if.then368:                                       ; preds = %if.else364
  %142 = load i32*, i32** %reg_mask.addr, align 8
  %143 = load i32, i32* %142, align 4
  %144 = load i32, i32* %dreg, align 4
  %and369 = and i32 %143, %144
  %tobool370 = icmp ne i32 %and369, 0
  br i1 %tobool370, label %if.end372, label %if.then371

if.then371:                                       ; preds = %if.then368
  store i32 0, i32* %retval, align 4
  br label %return

if.end372:                                        ; preds = %if.then368
  %145 = load i32, i32* %dreg, align 4
  %neg373 = xor i32 %145, -1
  %146 = load i32*, i32** %reg_mask.addr, align 8
  %147 = load i32, i32* %146, align 4
  %and374 = and i32 %147, %neg373
  store i32 %and374, i32* %146, align 4
  %148 = load i8, i8* %mode, align 1
  %conv375 = zext i8 %148 to i32
  %cmp376 = icmp eq i32 %conv375, 64
  br i1 %cmp376, label %if.then382, label %lor.lhs.false378

lor.lhs.false378:                                 ; preds = %if.end372
  %149 = load i8, i8* %mode, align 1
  %conv379 = zext i8 %149 to i32
  %cmp380 = icmp eq i32 %conv379, 32
  br i1 %cmp380, label %if.then382, label %if.end383

if.then382:                                       ; preds = %lor.lhs.false378, %if.end372
  store i32 -524, i32* %retval, align 4
  br label %return

if.end383:                                        ; preds = %lor.lhs.false378
  br label %if.end384

if.end384:                                        ; preds = %if.end383, %if.else364
  br label %if.end385

if.end385:                                        ; preds = %if.end384, %if.end363
  br label %if.end386

if.end386:                                        ; preds = %if.end385, %if.end257
  br label %if.end387

if.end387:                                        ; preds = %if.end386, %if.end136
  br label %if.end388

if.end388:                                        ; preds = %if.end387, %if.end55
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end388, %if.then382, %if.then371, %if.then361, %if.end348, %if.then277, %if.then246, %if.end233, %if.then158, %if.then150, %if.end128, %if.then73, %if.then63, %if.then30, %if.then
  %150 = load i32, i32* %retval, align 4
  ret i32 %150
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_all_scalars_precise(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %func = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc30, %entry
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %0, null
  br i1 %tobool, label %for.body, label %for.end31

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc27, %for.body
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %1, %3
  br i1 %cmp, label %for.body2, label %for.end29

for.body2:                                        ; preds = %for.cond1
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 0
  %5 = load i32, i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %6, %struct.bpf_func_state** %func, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %for.body2
  %7 = load i32, i32* %j, align 4
  %cmp4 = icmp slt i32 %7, 10
  br i1 %cmp4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond3
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 0
  %9 = load i32, i32* %j, align 4
  %idxprom6 = sext i32 %9 to i64
  %arrayidx7 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom6
  store %struct.bpf_reg_state* %arrayidx7, %struct.bpf_reg_state** %reg, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 0
  %11 = load i32, i32* %type, align 8
  %cmp8 = icmp ne i32 %11, 1
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body5
  br label %for.inc

if.end:                                           ; preds = %for.body5
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 18
  store i8 1, i8* %precise, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %13 = load i32, i32* %j, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond3, !llvm.loop !52

for.end:                                          ; preds = %for.cond3
  store i32 0, i32* %j, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc24, %for.end
  %14 = load i32, i32* %j, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 10
  %16 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %16, 8
  %cmp10 = icmp slt i32 %14, %div
  br i1 %cmp10, label %for.body11, label %for.end26

for.body11:                                       ; preds = %for.cond9
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 11
  %18 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %19 = load i32, i32* %j, align 4
  %idxprom12 = sext i32 %19 to i64
  %arrayidx13 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %18, i64 %idxprom12
  %call = call zeroext i1 @is_spilled_reg(%struct.bpf_stack_state* noundef %arrayidx13) #20
  br i1 %call, label %if.end15, label %if.then14

if.then14:                                        ; preds = %for.body11
  br label %for.inc24

if.end15:                                         ; preds = %for.body11
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack16 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %20, i32 0, i32 11
  %21 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack16, align 8
  %22 = load i32, i32* %j, align 4
  %idxprom17 = sext i32 %22 to i64
  %arrayidx18 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %21, i64 %idxprom17
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx18, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %reg, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 0
  %24 = load i32, i32* %type19, align 8
  %cmp20 = icmp ne i32 %24, 1
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end15
  br label %for.inc24

if.end22:                                         ; preds = %if.end15
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 18
  store i8 1, i8* %precise23, align 4
  br label %for.inc24

for.inc24:                                        ; preds = %if.end22, %if.then21, %if.then14
  %26 = load i32, i32* %j, align 4
  %inc25 = add i32 %26, 1
  store i32 %inc25, i32* %j, align 4
  br label %for.cond9, !llvm.loop !53

for.end26:                                        ; preds = %for.cond9
  br label %for.inc27

for.inc27:                                        ; preds = %for.end26
  %27 = load i32, i32* %i, align 4
  %inc28 = add i32 %27, 1
  store i32 %inc28, i32* %i, align 4
  br label %for.cond1, !llvm.loop !54

for.end29:                                        ; preds = %for.cond1
  br label %for.inc30

for.inc30:                                        ; preds = %for.end29
  %28 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %28, i32 0, i32 1
  %29 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  store %struct.bpf_verifier_state* %29, %struct.bpf_verifier_state** %st.addr, align 8
  br label %for.cond, !llvm.loop !55

for.end31:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @get_prev_insn_idx(%struct.bpf_verifier_state* noundef %st, i32 noundef %i, i32* noundef %history) #0 {
entry:
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %i.addr = alloca i32, align 4
  %history.addr = alloca i32*, align 8
  %cnt = alloca i32, align 4
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  store i32* %history, i32** %history.addr, align 8
  %0 = load i32*, i32** %history.addr, align 8
  %1 = load i32, i32* %0, align 4
  store i32 %1, i32* %cnt, align 4
  %2 = load i32, i32* %cnt, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  %4 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history, align 8
  %5 = load i32, i32* %cnt, align 4
  %sub = sub i32 %5, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr %struct.bpf_idx_pair, %struct.bpf_idx_pair* %4, i64 %idxprom
  %idx = getelementptr inbounds %struct.bpf_idx_pair, %struct.bpf_idx_pair* %arrayidx, i32 0, i32 1
  %6 = load i32, i32* %idx, align 4
  %7 = load i32, i32* %i.addr, align 4
  %cmp = icmp eq i32 %6, %7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %jmp_history1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 9
  %9 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history1, align 8
  %10 = load i32, i32* %cnt, align 4
  %sub2 = sub i32 %10, 1
  %idxprom3 = zext i32 %sub2 to i64
  %arrayidx4 = getelementptr %struct.bpf_idx_pair, %struct.bpf_idx_pair* %9, i64 %idxprom3
  %prev_idx = getelementptr inbounds %struct.bpf_idx_pair, %struct.bpf_idx_pair* %arrayidx4, i32 0, i32 0
  %11 = load i32, i32* %prev_idx, align 4
  store i32 %11, i32* %i.addr, align 4
  %12 = load i32*, i32** %history.addr, align 8
  %13 = load i32, i32* %12, align 4
  %dec = add i32 %13, -1
  store i32 %dec, i32* %12, align 4
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %14 = load i32, i32* %i.addr, align 4
  %dec5 = add i32 %14, -1
  store i32 %dec5, i32* %i.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %15 = load i32, i32* %i.addr, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bitmap_from_u64(i64* noundef %dst, i64 noundef %mask) #0 {
entry:
  %dst.addr = alloca i64*, align 8
  %mask.addr = alloca i64, align 8
  store i64* %dst, i64** %dst.addr, align 8
  store i64 %mask, i64* %mask.addr, align 8
  %0 = load i64*, i64** %dst.addr, align 8
  call void @bitmap_copy_clear_tail(i64* noundef %0, i64* noundef %mask.addr, i32 noundef 64) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @find_next_bit(i64* noundef %addr, i64 noundef %size, i64 noundef %offset) #0 {
entry:
  %word.addr.i = alloca i64, align 8
  %retval = alloca i64, align 8
  %addr.addr = alloca i64*, align 8
  %size.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %val = alloca i64, align 8
  store i64* %addr, i64** %addr.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  %0 = load i64, i64* %size.addr, align 8
  %1 = call i1 @llvm.is.constant.i64(i64 %0)
  br i1 %1, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %entry
  %2 = load i64, i64* %size.addr, align 8
  %cmp = icmp ule i64 %2, 64
  br i1 %cmp, label %land.lhs.true1, label %if.end16

land.lhs.true1:                                   ; preds = %land.lhs.true
  %3 = load i64, i64* %size.addr, align 8
  %cmp2 = icmp ugt i64 %3, 0
  br i1 %cmp2, label %if.then, label %if.end16

if.then:                                          ; preds = %land.lhs.true1
  %4 = load i64, i64* %offset.addr, align 8
  %5 = load i64, i64* %size.addr, align 8
  %cmp3 = icmp uge i64 %4, %5
  %lnot = xor i1 %cmp3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  %6 = load i64, i64* %size.addr, align 8
  store i64 %6, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %7 = load i64*, i64** %addr.addr, align 8
  %8 = load i64, i64* %7, align 8
  %9 = load i64, i64* %offset.addr, align 8
  %shl = shl i64 1, %9
  %sub = sub i64 -1, %shl
  %add = add i64 %sub, 1
  %10 = load i64, i64* %size.addr, align 8
  %sub6 = sub i64 %10, 1
  %sub7 = sub i64 63, %sub6
  %shr = lshr i64 -1, %sub7
  %and = and i64 %add, %shr
  %add8 = add i64 0, %and
  %and9 = and i64 %8, %add8
  store i64 %and9, i64* %val, align 8
  %11 = load i64, i64* %val, align 8
  %tobool10 = icmp ne i64 %11, 0
  br i1 %tobool10, label %cond.true, label %cond.false13

cond.true:                                        ; preds = %if.end
  %12 = load i64, i64* %val, align 8
  %13 = call i1 @llvm.is.constant.i64(i64 %12)
  br i1 %13, label %cond.true11, label %cond.false

cond.true11:                                      ; preds = %cond.true
  %14 = load i64, i64* %val, align 8
  %15 = call i64 @llvm.cttz.i64(i64 %14, i1 true)
  %cast = trunc i64 %15 to i32
  %conv12 = sext i32 %cast to i64
  br label %cond.end

cond.false:                                       ; preds = %cond.true
  %16 = load i64, i64* %val, align 8
  store i64 %16, i64* %word.addr.i, align 8
  %17 = load i64, i64* %word.addr.i, align 8
  %18 = call i64 asm "rep; bsf $1,$0", "=r,rm,~{dirflag},~{fpsr},~{flags}"(i64 %17) #18, !srcloc !56
  store i64 %18, i64* %word.addr.i, align 8
  %19 = load i64, i64* %word.addr.i, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true11
  %cond = phi i64 [ %conv12, %cond.true11 ], [ %19, %cond.false ]
  br label %cond.end14

cond.false13:                                     ; preds = %if.end
  %20 = load i64, i64* %size.addr, align 8
  br label %cond.end14

cond.end14:                                       ; preds = %cond.false13, %cond.end
  %cond15 = phi i64 [ %cond, %cond.end ], [ %20, %cond.false13 ]
  store i64 %cond15, i64* %retval, align 8
  br label %return

if.end16:                                         ; preds = %land.lhs.true1, %land.lhs.true, %entry
  %21 = load i64*, i64** %addr.addr, align 8
  %22 = load i64, i64* %size.addr, align 8
  %23 = load i64, i64* %offset.addr, align 8
  %call17 = call i64 @_find_next_bit(i64* noundef %21, i64 noundef %22, i64 noundef %23) #20
  store i64 %call17, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end16, %cond.end14, %if.then5
  %24 = load i64, i64* %retval, align 8
  ret i64 %24
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_verifier_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i1 noundef zeroext %print_all) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %print_all.addr = alloca i8, align 1
  %reg = alloca %struct.bpf_reg_state*, align 8
  %t = alloca i32, align 4
  %i = alloca i32, align 4
  %sep = alloca i8*, align 8
  %tmp = alloca i8*, align 8
  %tmp38 = alloca i8*, align 8
  %tmp44 = alloca i8*, align 8
  %tmp48 = alloca i8*, align 8
  %tmp63 = alloca i8*, align 8
  %tmp71 = alloca i8*, align 8
  %tmp81 = alloca i8*, align 8
  %tmp91 = alloca i8*, align 8
  %tmp98 = alloca i8*, align 8
  %tmp105 = alloca i8*, align 8
  %tn_buf = alloca [48 x i8], align 16
  %tmp113 = alloca i8*, align 8
  %tmp125 = alloca i8*, align 8
  %tmp137 = alloca i8*, align 8
  %tmp149 = alloca i8*, align 8
  %tmp161 = alloca i8*, align 8
  %types_buf = alloca [9 x i8], align 1
  %valid = alloca i8, align 1
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %frombool = zext i1 %print_all to i8
  store i8 %frombool, i8* %print_all.addr, align 1
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 2
  %1 = load i32, i32* %frameno, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 2
  %5 = load i32, i32* %frameno1, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.48, i64 0, i64 0), i32 noundef %5) #20
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %6, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 0
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 0
  %10 = load i32, i32* %type, align 8
  store i32 %10, i32* %t, align 4
  %11 = load i32, i32* %t, align 4
  %cmp2 = icmp eq i32 %11, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %for.body
  br label %for.inc

if.end4:                                          ; preds = %for.body
  %12 = load i8, i8* %print_all.addr, align 1
  %tobool5 = trunc i8 %12 to i1
  br i1 %tobool5, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = load i32, i32* %i, align 4
  %call = call zeroext i1 @reg_scratched(%struct.bpf_verifier_env* noundef %13, i32 noundef %14) #20
  br i1 %call, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  br label %for.inc

if.end7:                                          ; preds = %land.lhs.true, %if.end4
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = bitcast %struct.bpf_verifier_env* %15 to i8*
  %17 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %16, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.49, i64 0, i64 0), i32 noundef %17) #20
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 17
  %20 = load i32, i32* %live, align 8
  call void @print_liveness(%struct.bpf_verifier_env* noundef %18, i32 noundef %20) #20
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.50, i64 0, i64 0)) #20
  %23 = load i32, i32* %t, align 4
  %cmp8 = icmp eq i32 %23, 1
  br i1 %cmp8, label %land.lhs.true9, label %if.end12

land.lhs.true9:                                   ; preds = %if.end7
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 18
  %25 = load i8, i8* %precise, align 4
  %tobool10 = trunc i8 %25 to i1
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true9
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.51, i64 0, i64 0)) #20
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %land.lhs.true9, %if.end7
  %28 = load i32, i32* %t, align 4
  %cmp13 = icmp eq i32 %28, 1
  br i1 %cmp13, label %land.lhs.true15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end12
  %29 = load i32, i32* %t, align 4
  %cmp14 = icmp eq i32 %29, 6
  br i1 %cmp14, label %land.lhs.true15, label %if.else

land.lhs.true15:                                  ; preds = %lor.lhs.false, %if.end12
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %31 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = load i64, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = load i64, i64* %34, align 8
  %call16 = call zeroext i1 @tnum_is_const(i64 %33, i64 %35) #20
  br i1 %call16, label %if.then17, label %if.else

if.then17:                                        ; preds = %land.lhs.true15
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  %38 = load i32, i32* %t, align 4
  %cmp18 = icmp eq i32 %38, 1
  br i1 %cmp18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then17
  br label %cond.end

cond.false:                                       ; preds = %if.then17
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load i32, i32* %t, align 4
  %call19 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %39, i32 noundef %40) #20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i64 0, i64 0), %cond.true ], [ %call19, %cond.false ]
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i64 0, i64 0), i8* noundef %cond) #20
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off20, i32 0, i32 0
  %44 = load i64, i64* %value, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 1
  %46 = load i32, i32* %off, align 4
  %conv = sext i32 %46 to i64
  %add = add i64 %44, %conv
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.53, i64 0, i64 0), i64 noundef %add) #20
  br label %if.end164

if.else:                                          ; preds = %land.lhs.true15, %lor.lhs.false
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i64 0, i64 0), i8** %sep, align 8
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = bitcast %struct.bpf_verifier_env* %47 to i8*
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = load i32, i32* %t, align 4
  %call21 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %49, i32 noundef %50) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %48, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i64 0, i64 0), i8* noundef %call21) #20
  %51 = load i32, i32* %t, align 4
  %call22 = call i32 @base_type(i32 noundef %51) #20
  %cmp23 = icmp eq i32 %call22, 16
  br i1 %cmp23, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.else
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %55 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 2
  %56 = bitcast %union.anon.168* %55 to %struct.anon.170*
  %btf = getelementptr inbounds %struct.anon.170, %struct.anon.170* %56, i32 0, i32 0
  %57 = load %struct.btf*, %struct.btf** %btf, align 8
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %58, i32 0, i32 2
  %60 = bitcast %union.anon.168* %59 to %struct.anon.170*
  %btf_id = getelementptr inbounds %struct.anon.170, %struct.anon.170* %60, i32 0, i32 1
  %61 = load i32, i32* %btf_id, align 8
  %call26 = call i8* @kernel_type_name(%struct.btf* noundef %57, i32 noundef %61) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i64 0, i64 0), i8* noundef %call26) #20
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %if.else
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %63 = bitcast %struct.bpf_verifier_env* %62 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %63, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.54, i64 0, i64 0)) #20
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %64, i32 0, i32 3
  %65 = load i32, i32* %id, align 8
  %tobool28 = icmp ne i32 %65, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end27
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = bitcast %struct.bpf_verifier_env* %66 to i8*
  %68 = load i8*, i8** %sep, align 8
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %69, i32 0, i32 3
  %70 = load i32, i32* %id30, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %67, i8* noundef getelementptr inbounds ([8 x i8], [8 x i8]* @.str.55, i64 0, i64 0), i8* noundef %68, i32 noundef %70) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp, align 8
  %71 = load i8*, i8** %tmp, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end27
  %72 = load i32, i32* %t, align 4
  %call32 = call zeroext i1 @reg_type_may_be_refcounted_or_null(i32 noundef %72) #20
  br i1 %call32, label %land.lhs.true34, label %if.end39

land.lhs.true34:                                  ; preds = %if.end31
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %73, i32 0, i32 4
  %74 = load i32, i32* %ref_obj_id, align 4
  %tobool35 = icmp ne i32 %74, 0
  br i1 %tobool35, label %if.then36, label %if.end39

if.then36:                                        ; preds = %land.lhs.true34
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = bitcast %struct.bpf_verifier_env* %75 to i8*
  %77 = load i8*, i8** %sep, align 8
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id37 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %78, i32 0, i32 4
  %79 = load i32, i32* %ref_obj_id37, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %76, i8* noundef getelementptr inbounds ([16 x i8], [16 x i8]* @.str.57, i64 0, i64 0), i8* noundef %77, i32 noundef %79) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp38, align 8
  %80 = load i8*, i8** %tmp38, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %land.lhs.true34, %if.end31
  %81 = load i32, i32* %t, align 4
  %cmp40 = icmp ne i32 %81, 1
  br i1 %cmp40, label %if.then42, label %if.end45

if.then42:                                        ; preds = %if.end39
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %83 = bitcast %struct.bpf_verifier_env* %82 to i8*
  %84 = load i8*, i8** %sep, align 8
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %85, i32 0, i32 1
  %86 = load i32, i32* %off43, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %83, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.58, i64 0, i64 0), i8* noundef %84, i32 noundef %86) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp44, align 8
  %87 = load i8*, i8** %tmp44, align 8
  br label %if.end45

if.end45:                                         ; preds = %if.then42, %if.end39
  %88 = load i32, i32* %t, align 4
  %call46 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %88) #20
  br i1 %call46, label %if.then47, label %if.else49

if.then47:                                        ; preds = %if.end45
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %90 = bitcast %struct.bpf_verifier_env* %89 to i8*
  %91 = load i8*, i8** %sep, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %93 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 2
  %range = bitcast %union.anon.168* %93 to i32*
  %94 = load i32, i32* %range, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %90, i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str.59, i64 0, i64 0), i8* noundef %91, i32 noundef %94) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp48, align 8
  %95 = load i8*, i8** %tmp48, align 8
  br label %if.end65

if.else49:                                        ; preds = %if.end45
  %96 = load i32, i32* %t, align 4
  %call50 = call i32 @base_type(i32 noundef %96) #20
  %cmp51 = icmp eq i32 %call50, 3
  br i1 %cmp51, label %if.then61, label %lor.lhs.false53

lor.lhs.false53:                                  ; preds = %if.else49
  %97 = load i32, i32* %t, align 4
  %call54 = call i32 @base_type(i32 noundef %97) #20
  %cmp55 = icmp eq i32 %call54, 5
  br i1 %cmp55, label %if.then61, label %lor.lhs.false57

lor.lhs.false57:                                  ; preds = %lor.lhs.false53
  %98 = load i32, i32* %t, align 4
  %call58 = call i32 @base_type(i32 noundef %98) #20
  %cmp59 = icmp eq i32 %call58, 4
  br i1 %cmp59, label %if.then61, label %if.end64

if.then61:                                        ; preds = %lor.lhs.false57, %lor.lhs.false53, %if.else49
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %100 = bitcast %struct.bpf_verifier_env* %99 to i8*
  %101 = load i8*, i8** %sep, align 8
  %102 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %102, i32 0, i32 2
  %104 = bitcast %union.anon.168* %103 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %104, i32 0, i32 0
  %105 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %key_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %105, i32 0, i32 4
  %106 = load i32, i32* %key_size, align 4
  %107 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %107, i32 0, i32 2
  %109 = bitcast %union.anon.168* %108 to %struct.anon.169*
  %map_ptr62 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %109, i32 0, i32 0
  %110 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr62, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %110, i32 0, i32 5
  %111 = load i32, i32* %value_size, align 32
  call void (i8*, i8*, ...) @verbose(i8* noundef %100, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.60, i64 0, i64 0), i8* noundef %101, i32 noundef %106, i32 noundef %111) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp63, align 8
  %112 = load i8*, i8** %tmp63, align 8
  br label %if.end64

if.end64:                                         ; preds = %if.then61, %lor.lhs.false57
  br label %if.end65

if.end65:                                         ; preds = %if.end64, %if.then47
  %113 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %113, i32 0, i32 5
  %114 = bitcast %struct.tnum* %var_off66 to { i64, i64 }*
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %114, i32 0, i32 0
  %116 = load i64, i64* %115, align 8
  %117 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %114, i32 0, i32 1
  %118 = load i64, i64* %117, align 8
  %call67 = call zeroext i1 @tnum_is_const(i64 %116, i64 %118) #20
  br i1 %call67, label %if.then68, label %if.else72

if.then68:                                        ; preds = %if.end65
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %120 = bitcast %struct.bpf_verifier_env* %119 to i8*
  %121 = load i8*, i8** %sep, align 8
  %122 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off69 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %122, i32 0, i32 5
  %value70 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off69, i32 0, i32 0
  %123 = load i64, i64* %value70, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %120, i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i64 0, i64 0), i8* noundef %121, i64 noundef %123) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp71, align 8
  %124 = load i8*, i8** %tmp71, align 8
  br label %if.end163

if.else72:                                        ; preds = %if.end65
  %125 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %125, i32 0, i32 6
  %126 = load i64, i64* %smin_value, align 8
  %127 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %127, i32 0, i32 8
  %128 = load i64, i64* %umin_value, align 8
  %cmp73 = icmp ne i64 %126, %128
  br i1 %cmp73, label %land.lhs.true75, label %if.end82

land.lhs.true75:                                  ; preds = %if.else72
  %129 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value76 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %129, i32 0, i32 6
  %130 = load i64, i64* %smin_value76, align 8
  %cmp77 = icmp ne i64 %130, -9223372036854775808
  br i1 %cmp77, label %if.then79, label %if.end82

if.then79:                                        ; preds = %land.lhs.true75
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %132 = bitcast %struct.bpf_verifier_env* %131 to i8*
  %133 = load i8*, i8** %sep, align 8
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %134, i32 0, i32 6
  %135 = load i64, i64* %smin_value80, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %132, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.62, i64 0, i64 0), i8* noundef %133, i64 noundef %135) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp81, align 8
  %136 = load i8*, i8** %tmp81, align 8
  br label %if.end82

if.end82:                                         ; preds = %if.then79, %land.lhs.true75, %if.else72
  %137 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %137, i32 0, i32 7
  %138 = load i64, i64* %smax_value, align 8
  %139 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %139, i32 0, i32 9
  %140 = load i64, i64* %umax_value, align 8
  %cmp83 = icmp ne i64 %138, %140
  br i1 %cmp83, label %land.lhs.true85, label %if.end92

land.lhs.true85:                                  ; preds = %if.end82
  %141 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %141, i32 0, i32 7
  %142 = load i64, i64* %smax_value86, align 8
  %cmp87 = icmp ne i64 %142, 9223372036854775807
  br i1 %cmp87, label %if.then89, label %if.end92

if.then89:                                        ; preds = %land.lhs.true85
  %143 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %144 = bitcast %struct.bpf_verifier_env* %143 to i8*
  %145 = load i8*, i8** %sep, align 8
  %146 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value90 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %146, i32 0, i32 7
  %147 = load i64, i64* %smax_value90, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %144, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.63, i64 0, i64 0), i8* noundef %145, i64 noundef %147) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp91, align 8
  %148 = load i8*, i8** %tmp91, align 8
  br label %if.end92

if.end92:                                         ; preds = %if.then89, %land.lhs.true85, %if.end82
  %149 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value93 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %149, i32 0, i32 8
  %150 = load i64, i64* %umin_value93, align 8
  %cmp94 = icmp ne i64 %150, 0
  br i1 %cmp94, label %if.then96, label %if.end99

if.then96:                                        ; preds = %if.end92
  %151 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %152 = bitcast %struct.bpf_verifier_env* %151 to i8*
  %153 = load i8*, i8** %sep, align 8
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value97 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %154, i32 0, i32 8
  %155 = load i64, i64* %umin_value97, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %152, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.64, i64 0, i64 0), i8* noundef %153, i64 noundef %155) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp98, align 8
  %156 = load i8*, i8** %tmp98, align 8
  br label %if.end99

if.end99:                                         ; preds = %if.then96, %if.end92
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value100 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %157, i32 0, i32 9
  %158 = load i64, i64* %umax_value100, align 8
  %cmp101 = icmp ne i64 %158, -1
  br i1 %cmp101, label %if.then103, label %if.end106

if.then103:                                       ; preds = %if.end99
  %159 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %160 = bitcast %struct.bpf_verifier_env* %159 to i8*
  %161 = load i8*, i8** %sep, align 8
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value104 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %162, i32 0, i32 9
  %163 = load i64, i64* %umax_value104, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %160, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.65, i64 0, i64 0), i8* noundef %161, i64 noundef %163) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp105, align 8
  %164 = load i8*, i8** %tmp105, align 8
  br label %if.end106

if.end106:                                        ; preds = %if.then103, %if.end99
  %165 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off107 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %165, i32 0, i32 5
  %166 = bitcast %struct.tnum* %var_off107 to { i64, i64 }*
  %167 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %166, i32 0, i32 0
  %168 = load i64, i64* %167, align 8
  %169 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %166, i32 0, i32 1
  %170 = load i64, i64* %169, align 8
  %call108 = call zeroext i1 @tnum_is_unknown(i64 %168, i64 %170) #20
  br i1 %call108, label %if.end114, label %if.then109

if.then109:                                       ; preds = %if.end106
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %171 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %171, i32 0, i32 5
  %172 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %173 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %172, i32 0, i32 0
  %174 = load i64, i64* %173, align 8
  %175 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %172, i32 0, i32 1
  %176 = load i64, i64* %175, align 8
  %call111 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %174, i64 %176) #20
  %177 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %178 = bitcast %struct.bpf_verifier_env* %177 to i8*
  %179 = load i8*, i8** %sep, align 8
  %arraydecay112 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %178, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.66, i64 0, i64 0), i8* noundef %179, i8* noundef %arraydecay112) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp113, align 8
  %180 = load i8*, i8** %tmp113, align 8
  br label %if.end114

if.end114:                                        ; preds = %if.then109, %if.end106
  %181 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %181, i32 0, i32 10
  %182 = load i32, i32* %s32_min_value, align 8
  %conv115 = sext i32 %182 to i64
  %183 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value116 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %183, i32 0, i32 6
  %184 = load i64, i64* %smin_value116, align 8
  %cmp117 = icmp ne i64 %conv115, %184
  br i1 %cmp117, label %land.lhs.true119, label %if.end126

land.lhs.true119:                                 ; preds = %if.end114
  %185 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_min_value120 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %185, i32 0, i32 10
  %186 = load i32, i32* %s32_min_value120, align 8
  %cmp121 = icmp ne i32 %186, -2147483648
  br i1 %cmp121, label %if.then123, label %if.end126

if.then123:                                       ; preds = %land.lhs.true119
  %187 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %188 = bitcast %struct.bpf_verifier_env* %187 to i8*
  %189 = load i8*, i8** %sep, align 8
  %190 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_min_value124 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %190, i32 0, i32 10
  %191 = load i32, i32* %s32_min_value124, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %188, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.67, i64 0, i64 0), i8* noundef %189, i32 noundef %191) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp125, align 8
  %192 = load i8*, i8** %tmp125, align 8
  br label %if.end126

if.end126:                                        ; preds = %if.then123, %land.lhs.true119, %if.end114
  %193 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %193, i32 0, i32 11
  %194 = load i32, i32* %s32_max_value, align 4
  %conv127 = sext i32 %194 to i64
  %195 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value128 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %195, i32 0, i32 7
  %196 = load i64, i64* %smax_value128, align 8
  %cmp129 = icmp ne i64 %conv127, %196
  br i1 %cmp129, label %land.lhs.true131, label %if.end138

land.lhs.true131:                                 ; preds = %if.end126
  %197 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_max_value132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %197, i32 0, i32 11
  %198 = load i32, i32* %s32_max_value132, align 4
  %cmp133 = icmp ne i32 %198, 2147483647
  br i1 %cmp133, label %if.then135, label %if.end138

if.then135:                                       ; preds = %land.lhs.true131
  %199 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %200 = bitcast %struct.bpf_verifier_env* %199 to i8*
  %201 = load i8*, i8** %sep, align 8
  %202 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_max_value136 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %202, i32 0, i32 11
  %203 = load i32, i32* %s32_max_value136, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %200, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.68, i64 0, i64 0), i8* noundef %201, i32 noundef %203) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp137, align 8
  %204 = load i8*, i8** %tmp137, align 8
  br label %if.end138

if.end138:                                        ; preds = %if.then135, %land.lhs.true131, %if.end126
  %205 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %205, i32 0, i32 12
  %206 = load i32, i32* %u32_min_value, align 8
  %conv139 = zext i32 %206 to i64
  %207 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value140 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %207, i32 0, i32 8
  %208 = load i64, i64* %umin_value140, align 8
  %cmp141 = icmp ne i64 %conv139, %208
  br i1 %cmp141, label %land.lhs.true143, label %if.end150

land.lhs.true143:                                 ; preds = %if.end138
  %209 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_min_value144 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %209, i32 0, i32 12
  %210 = load i32, i32* %u32_min_value144, align 8
  %cmp145 = icmp ne i32 %210, 0
  br i1 %cmp145, label %if.then147, label %if.end150

if.then147:                                       ; preds = %land.lhs.true143
  %211 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %212 = bitcast %struct.bpf_verifier_env* %211 to i8*
  %213 = load i8*, i8** %sep, align 8
  %214 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_min_value148 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %214, i32 0, i32 12
  %215 = load i32, i32* %u32_min_value148, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %212, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.69, i64 0, i64 0), i8* noundef %213, i32 noundef %215) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp149, align 8
  %216 = load i8*, i8** %tmp149, align 8
  br label %if.end150

if.end150:                                        ; preds = %if.then147, %land.lhs.true143, %if.end138
  %217 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %217, i32 0, i32 13
  %218 = load i32, i32* %u32_max_value, align 4
  %conv151 = zext i32 %218 to i64
  %219 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value152 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %219, i32 0, i32 9
  %220 = load i64, i64* %umax_value152, align 8
  %cmp153 = icmp ne i64 %conv151, %220
  br i1 %cmp153, label %land.lhs.true155, label %if.end162

land.lhs.true155:                                 ; preds = %if.end150
  %221 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_max_value156 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %221, i32 0, i32 13
  %222 = load i32, i32* %u32_max_value156, align 4
  %cmp157 = icmp ne i32 %222, -1
  br i1 %cmp157, label %if.then159, label %if.end162

if.then159:                                       ; preds = %land.lhs.true155
  %223 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %224 = bitcast %struct.bpf_verifier_env* %223 to i8*
  %225 = load i8*, i8** %sep, align 8
  %226 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_max_value160 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %226, i32 0, i32 13
  %227 = load i32, i32* %u32_max_value160, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %224, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.70, i64 0, i64 0), i8* noundef %225, i32 noundef %227) #20
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %sep, align 8
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i64 0, i64 0), i8** %tmp161, align 8
  %228 = load i8*, i8** %tmp161, align 8
  br label %if.end162

if.end162:                                        ; preds = %if.then159, %land.lhs.true155, %if.end150
  br label %if.end163

if.end163:                                        ; preds = %if.end162, %if.then68
  %229 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %230 = bitcast %struct.bpf_verifier_env* %229 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %230, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i64 0, i64 0)) #20
  br label %if.end164

if.end164:                                        ; preds = %if.end163, %cond.end
  br label %for.inc

for.inc:                                          ; preds = %if.end164, %if.then6, %if.then3
  %231 = load i32, i32* %i, align 4
  %inc = add i32 %231, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !57

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond165

for.cond165:                                      ; preds = %for.inc251, %for.end
  %232 = load i32, i32* %i, align 4
  %233 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %233, i32 0, i32 10
  %234 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %234, 8
  %cmp166 = icmp slt i32 %232, %div
  br i1 %cmp166, label %for.body168, label %for.end253

for.body168:                                      ; preds = %for.cond165
  store i8 0, i8* %valid, align 1
  store i32 0, i32* %j, align 4
  br label %for.cond169

for.cond169:                                      ; preds = %for.inc192, %for.body168
  %235 = load i32, i32* %j, align 4
  %cmp170 = icmp slt i32 %235, 8
  br i1 %cmp170, label %for.body172, label %for.end194

for.body172:                                      ; preds = %for.cond169
  %236 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %236, i32 0, i32 11
  %237 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %238 = load i32, i32* %i, align 4
  %idxprom173 = sext i32 %238 to i64
  %arrayidx174 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %237, i64 %idxprom173
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx174, i32 0, i32 1
  %239 = load i32, i32* %j, align 4
  %idxprom175 = sext i32 %239 to i64
  %arrayidx176 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom175
  %240 = load i8, i8* %arrayidx176, align 1
  %conv177 = zext i8 %240 to i32
  %cmp178 = icmp ne i32 %conv177, 0
  br i1 %cmp178, label %if.then180, label %if.end181

if.then180:                                       ; preds = %for.body172
  store i8 1, i8* %valid, align 1
  br label %if.end181

if.end181:                                        ; preds = %if.then180, %for.body172
  %241 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack182 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %241, i32 0, i32 11
  %242 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack182, align 8
  %243 = load i32, i32* %i, align 4
  %idxprom183 = sext i32 %243 to i64
  %arrayidx184 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %242, i64 %idxprom183
  %slot_type185 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx184, i32 0, i32 1
  %244 = load i32, i32* %j, align 4
  %idxprom186 = sext i32 %244 to i64
  %arrayidx187 = getelementptr [8 x i8], [8 x i8]* %slot_type185, i64 0, i64 %idxprom186
  %245 = load i8, i8* %arrayidx187, align 1
  %idxprom188 = zext i8 %245 to i64
  %arrayidx189 = getelementptr [5 x i8], [5 x i8]* @slot_type_char, i64 0, i64 %idxprom188
  %246 = load i8, i8* %arrayidx189, align 1
  %247 = load i32, i32* %j, align 4
  %idxprom190 = sext i32 %247 to i64
  %arrayidx191 = getelementptr [9 x i8], [9 x i8]* %types_buf, i64 0, i64 %idxprom190
  store i8 %246, i8* %arrayidx191, align 1
  br label %for.inc192

for.inc192:                                       ; preds = %if.end181
  %248 = load i32, i32* %j, align 4
  %inc193 = add i32 %248, 1
  store i32 %inc193, i32* %j, align 4
  br label %for.cond169, !llvm.loop !58

for.end194:                                       ; preds = %for.cond169
  %arrayidx195 = getelementptr [9 x i8], [9 x i8]* %types_buf, i64 0, i64 8
  store i8 0, i8* %arrayidx195, align 1
  %249 = load i8, i8* %valid, align 1
  %tobool196 = trunc i8 %249 to i1
  br i1 %tobool196, label %if.end198, label %if.then197

if.then197:                                       ; preds = %for.end194
  br label %for.inc251

if.end198:                                        ; preds = %for.end194
  %250 = load i8, i8* %print_all.addr, align 1
  %tobool199 = trunc i8 %250 to i1
  br i1 %tobool199, label %if.end204, label %land.lhs.true200

land.lhs.true200:                                 ; preds = %if.end198
  %251 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %252 = load i32, i32* %i, align 4
  %conv201 = sext i32 %252 to i64
  %call202 = call zeroext i1 @stack_slot_scratched(%struct.bpf_verifier_env* noundef %251, i64 noundef %conv201) #20
  br i1 %call202, label %if.end204, label %if.then203

if.then203:                                       ; preds = %land.lhs.true200
  br label %for.inc251

if.end204:                                        ; preds = %land.lhs.true200, %if.end198
  %253 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %254 = bitcast %struct.bpf_verifier_env* %253 to i8*
  %255 = load i32, i32* %i, align 4
  %sub = sub i32 0, %255
  %sub205 = sub i32 %sub, 1
  %mul = mul i32 %sub205, 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %254, i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str.72, i64 0, i64 0), i32 noundef %mul) #20
  %256 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %257 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack206 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %257, i32 0, i32 11
  %258 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack206, align 8
  %259 = load i32, i32* %i, align 4
  %idxprom207 = sext i32 %259 to i64
  %arrayidx208 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %258, i64 %idxprom207
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx208, i32 0, i32 0
  %live209 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 17
  %260 = load i32, i32* %live209, align 8
  call void @print_liveness(%struct.bpf_verifier_env* noundef %256, i32 noundef %260) #20
  %261 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack210 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %261, i32 0, i32 11
  %262 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack210, align 8
  %263 = load i32, i32* %i, align 4
  %idxprom211 = sext i32 %263 to i64
  %arrayidx212 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %262, i64 %idxprom211
  %call213 = call zeroext i1 @is_spilled_reg(%struct.bpf_stack_state* noundef %arrayidx212) #20
  br i1 %call213, label %if.then214, label %if.else248

if.then214:                                       ; preds = %if.end204
  %264 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack215 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %264, i32 0, i32 11
  %265 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack215, align 8
  %266 = load i32, i32* %i, align 4
  %idxprom216 = sext i32 %266 to i64
  %arrayidx217 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %265, i64 %idxprom216
  %spilled_ptr218 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx217, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr218, %struct.bpf_reg_state** %reg, align 8
  %267 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type219 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %267, i32 0, i32 0
  %268 = load i32, i32* %type219, align 8
  store i32 %268, i32* %t, align 4
  %269 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %270 = bitcast %struct.bpf_verifier_env* %269 to i8*
  %271 = load i32, i32* %t, align 4
  %cmp220 = icmp eq i32 %271, 1
  br i1 %cmp220, label %cond.true222, label %cond.false223

cond.true222:                                     ; preds = %if.then214
  br label %cond.end225

cond.false223:                                    ; preds = %if.then214
  %272 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %273 = load i32, i32* %t, align 4
  %call224 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %272, i32 noundef %273) #20
  br label %cond.end225

cond.end225:                                      ; preds = %cond.false223, %cond.true222
  %cond226 = phi i8* [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i64 0, i64 0), %cond.true222 ], [ %call224, %cond.false223 ]
  call void (i8*, i8*, ...) @verbose(i8* noundef %270, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i64 0, i64 0), i8* noundef %cond226) #20
  %274 = load i32, i32* %t, align 4
  %cmp227 = icmp eq i32 %274, 1
  br i1 %cmp227, label %land.lhs.true229, label %if.end234

land.lhs.true229:                                 ; preds = %cond.end225
  %275 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise230 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %275, i32 0, i32 18
  %276 = load i8, i8* %precise230, align 4
  %tobool231 = trunc i8 %276 to i1
  br i1 %tobool231, label %if.then233, label %if.end234

if.then233:                                       ; preds = %land.lhs.true229
  %277 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %278 = bitcast %struct.bpf_verifier_env* %277 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %278, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.51, i64 0, i64 0)) #20
  br label %if.end234

if.end234:                                        ; preds = %if.then233, %land.lhs.true229, %cond.end225
  %279 = load i32, i32* %t, align 4
  %cmp235 = icmp eq i32 %279, 1
  br i1 %cmp235, label %land.lhs.true237, label %if.end247

land.lhs.true237:                                 ; preds = %if.end234
  %280 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off238 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %280, i32 0, i32 5
  %281 = bitcast %struct.tnum* %var_off238 to { i64, i64 }*
  %282 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %281, i32 0, i32 0
  %283 = load i64, i64* %282, align 8
  %284 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %281, i32 0, i32 1
  %285 = load i64, i64* %284, align 8
  %call239 = call zeroext i1 @tnum_is_const(i64 %283, i64 %285) #20
  br i1 %call239, label %if.then241, label %if.end247

if.then241:                                       ; preds = %land.lhs.true237
  %286 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %287 = bitcast %struct.bpf_verifier_env* %286 to i8*
  %288 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off242 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %288, i32 0, i32 5
  %value243 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off242, i32 0, i32 0
  %289 = load i64, i64* %value243, align 8
  %290 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off244 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %290, i32 0, i32 1
  %291 = load i32, i32* %off244, align 4
  %conv245 = sext i32 %291 to i64
  %add246 = add i64 %289, %conv245
  call void (i8*, i8*, ...) @verbose(i8* noundef %287, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.53, i64 0, i64 0), i64 noundef %add246) #20
  br label %if.end247

if.end247:                                        ; preds = %if.then241, %land.lhs.true237, %if.end234
  br label %if.end250

if.else248:                                       ; preds = %if.end204
  %292 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %293 = bitcast %struct.bpf_verifier_env* %292 to i8*
  %arraydecay249 = getelementptr inbounds [9 x i8], [9 x i8]* %types_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %293, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.73, i64 0, i64 0), i8* noundef %arraydecay249) #20
  br label %if.end250

if.end250:                                        ; preds = %if.else248, %if.end247
  br label %for.inc251

for.inc251:                                       ; preds = %if.end250, %if.then203, %if.then197
  %294 = load i32, i32* %i, align 4
  %inc252 = add i32 %294, 1
  store i32 %inc252, i32* %i, align 4
  br label %for.cond165, !llvm.loop !59

for.end253:                                       ; preds = %for.cond165
  %295 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %295, i32 0, i32 8
  %296 = load i32, i32* %acquired_refs, align 4
  %tobool254 = icmp ne i32 %296, 0
  br i1 %tobool254, label %land.lhs.true255, label %if.end282

land.lhs.true255:                                 ; preds = %for.end253
  %297 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %297, i32 0, i32 9
  %298 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %arrayidx256 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %298, i64 0
  %id257 = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx256, i32 0, i32 0
  %299 = load i32, i32* %id257, align 4
  %tobool258 = icmp ne i32 %299, 0
  br i1 %tobool258, label %if.then259, label %if.end282

if.then259:                                       ; preds = %land.lhs.true255
  %300 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %301 = bitcast %struct.bpf_verifier_env* %300 to i8*
  %302 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs260 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %302, i32 0, i32 9
  %303 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs260, align 8
  %arrayidx261 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %303, i64 0
  %id262 = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx261, i32 0, i32 0
  %304 = load i32, i32* %id262, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %301, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.74, i64 0, i64 0), i32 noundef %304) #20
  store i32 1, i32* %i, align 4
  br label %for.cond263

for.cond263:                                      ; preds = %for.inc279, %if.then259
  %305 = load i32, i32* %i, align 4
  %306 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs264 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %306, i32 0, i32 8
  %307 = load i32, i32* %acquired_refs264, align 4
  %cmp265 = icmp slt i32 %305, %307
  br i1 %cmp265, label %for.body267, label %for.end281

for.body267:                                      ; preds = %for.cond263
  %308 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs268 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %308, i32 0, i32 9
  %309 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs268, align 8
  %310 = load i32, i32* %i, align 4
  %idxprom269 = sext i32 %310 to i64
  %arrayidx270 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %309, i64 %idxprom269
  %id271 = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx270, i32 0, i32 0
  %311 = load i32, i32* %id271, align 4
  %tobool272 = icmp ne i32 %311, 0
  br i1 %tobool272, label %if.then273, label %if.end278

if.then273:                                       ; preds = %for.body267
  %312 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %313 = bitcast %struct.bpf_verifier_env* %312 to i8*
  %314 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs274 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %314, i32 0, i32 9
  %315 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs274, align 8
  %316 = load i32, i32* %i, align 4
  %idxprom275 = sext i32 %316 to i64
  %arrayidx276 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %315, i64 %idxprom275
  %id277 = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx276, i32 0, i32 0
  %317 = load i32, i32* %id277, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %313, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.75, i64 0, i64 0), i32 noundef %317) #20
  br label %if.end278

if.end278:                                        ; preds = %if.then273, %for.body267
  br label %for.inc279

for.inc279:                                       ; preds = %if.end278
  %318 = load i32, i32* %i, align 4
  %inc280 = add i32 %318, 1
  store i32 %inc280, i32* %i, align 4
  br label %for.cond263, !llvm.loop !60

for.end281:                                       ; preds = %for.cond263
  br label %if.end282

if.end282:                                        ; preds = %for.end281, %land.lhs.true255, %for.end253
  %319 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %in_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %319, i32 0, i32 5
  %320 = load i8, i8* %in_callback_fn, align 8
  %tobool283 = trunc i8 %320 to i1
  br i1 %tobool283, label %if.then284, label %if.end285

if.then284:                                       ; preds = %if.end282
  %321 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %322 = bitcast %struct.bpf_verifier_env* %321 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %322, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.76, i64 0, i64 0)) #20
  br label %if.end285

if.end285:                                        ; preds = %if.then284, %if.end282
  %323 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %in_async_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %323, i32 0, i32 7
  %324 = load i8, i8* %in_async_callback_fn, align 8
  %tobool286 = trunc i8 %324 to i1
  br i1 %tobool286, label %if.then287, label %if.end288

if.then287:                                       ; preds = %if.end285
  %325 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %326 = bitcast %struct.bpf_verifier_env* %325 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %326, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.77, i64 0, i64 0)) #20
  br label %if.end288

if.end288:                                        ; preds = %if.then287, %if.end285
  %327 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %328 = bitcast %struct.bpf_verifier_env* %327 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %328, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i64 0, i64 0)) #20
  %329 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @mark_verifier_state_clean(%struct.bpf_verifier_env* noundef %329) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @disasm_kfunc_name(i8* noundef %data, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i8*, align 8
  %data.addr = alloca i8*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %func = alloca %struct.btf_type*, align 8
  %desc_btf = alloca %struct.btf*, align 8
  store i8* %data, i8** %data.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv = zext i8 %bf.lshr to i32
  %cmp = icmp ne i32 %conv, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8*, i8** %data.addr, align 8
  %2 = bitcast i8* %1 to %struct.bpf_verifier_env*
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %3, i32 0, i32 2
  %4 = load i16, i16* %off, align 2
  %call = call %struct.btf* @find_kfunc_desc_btf(%struct.bpf_verifier_env* noundef %2, i16 noundef signext %4) #20
  store %struct.btf* %call, %struct.btf** %desc_btf, align 8
  %5 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %6 = bitcast %struct.btf* %5 to i8*
  %call2 = call zeroext i1 @IS_ERR(i8* noundef %6) #20
  br i1 %call2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.42, i64 0, i64 0), i8** %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %7 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 3
  %9 = load i32, i32* %imm, align 4
  %call5 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %7, i32 noundef %9) #20
  store %struct.btf_type* %call5, %struct.btf_type** %func, align 8
  %10 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %11 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %11, i32 0, i32 0
  %12 = load i32, i32* %name_off, align 4
  %call6 = call i8* @btf_name_by_offset(%struct.btf* noundef %10, i32 noundef %12) #20
  store i8* %call6, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %13 = load i8*, i8** %retval, align 8
  ret i8* %13
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @print_bpf_insn(%struct.bpf_insn_cbs* noundef, %struct.bpf_insn* noundef, i1 noundef zeroext) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.btf* @find_kfunc_desc_btf(%struct.bpf_verifier_env* noundef %env, i16 noundef signext %offset) #0 {
entry:
  %retval = alloca %struct.btf*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %offset.addr = alloca i16, align 2
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i16 %offset, i16* %offset.addr, align 2
  %0 = load i16, i16* %offset.addr, align 2
  %tobool = icmp ne i16 %0, 0
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %1 = load i16, i16* %offset.addr, align 2
  %conv = sext i16 %1 to i32
  %cmp = icmp slt i32 %conv, 0
  br i1 %cmp, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.43, i64 0, i64 0)) #20
  %call = call i8* @ERR_PTR(i64 noundef -22) #20
  %4 = bitcast i8* %call to %struct.btf*
  store %struct.btf* %4, %struct.btf** %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load i16, i16* %offset.addr, align 2
  %call3 = call %struct.btf* @__find_kfunc_desc_btf(%struct.bpf_verifier_env* noundef %5, i16 noundef signext %6) #20
  store %struct.btf* %call3, %struct.btf** %retval, align 8
  br label %return

if.end4:                                          ; preds = %entry
  %7 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool5 = icmp ne %struct.btf* %7, null
  br i1 %tobool5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end4
  %8 = bitcast %struct.btf* %7 to i8*
  br label %cond.end

cond.false:                                       ; preds = %if.end4
  %call6 = call i8* @ERR_PTR(i64 noundef -2) #20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %8, %cond.true ], [ %call6, %cond.false ]
  %9 = bitcast i8* %cond to %struct.btf*
  store %struct.btf* %9, %struct.btf** %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.end, %if.then2
  %10 = load %struct.btf*, %struct.btf** %retval, align 8
  ret %struct.btf* %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @ERR_PTR(i64 noundef %error) #0 {
entry:
  %error.addr = alloca i64, align 8
  store i64 %error, i64* %error.addr, align 8
  %0 = load i64, i64* %error.addr, align 8
  %1 = inttoptr i64 %0 to i8*
  ret i8* %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.btf* @__find_kfunc_desc_btf(%struct.bpf_verifier_env* noundef %env, i16 noundef signext %offset) #0 {
entry:
  %retval = alloca %struct.btf*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %offset.addr = alloca i16, align 2
  %kf_btf = alloca %struct.bpf_kfunc_btf, align 8
  %tab = alloca %struct.bpf_kfunc_btf_tab*, align 8
  %b = alloca %struct.bpf_kfunc_btf*, align 8
  %mod = alloca %struct.module*, align 8
  %btf = alloca %struct.btf*, align 8
  %btf_fd = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i16 %offset, i16* %offset.addr, align 2
  %0 = bitcast %struct.bpf_kfunc_btf* %kf_btf to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %0, i8 0, i64 24, i1 false)
  %offset1 = getelementptr inbounds %struct.bpf_kfunc_btf, %struct.bpf_kfunc_btf* %kf_btf, i32 0, i32 2
  %1 = load i16, i16* %offset.addr, align 2
  store i16 %1, i16* %offset1, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 10
  %4 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %kfunc_btf_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %4, i32 0, i32 34
  %5 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %kfunc_btf_tab, align 8
  store %struct.bpf_kfunc_btf_tab* %5, %struct.bpf_kfunc_btf_tab** %tab, align 8
  %6 = bitcast %struct.bpf_kfunc_btf* %kf_btf to i8*
  %7 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab, align 8
  %descs = getelementptr inbounds %struct.bpf_kfunc_btf_tab, %struct.bpf_kfunc_btf_tab* %7, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x %struct.bpf_kfunc_btf], [256 x %struct.bpf_kfunc_btf]* %descs, i64 0, i64 0
  %8 = bitcast %struct.bpf_kfunc_btf* %arraydecay to i8*
  %9 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab, align 8
  %nr_descs = getelementptr inbounds %struct.bpf_kfunc_btf_tab, %struct.bpf_kfunc_btf_tab* %9, i32 0, i32 1
  %10 = load i32, i32* %nr_descs, align 8
  %conv = zext i32 %10 to i64
  %call = call i8* @bsearch(i8* noundef %6, i8* noundef %8, i64 noundef %conv, i64 noundef 24, i32 (i8*, i8*)* noundef @kfunc_btf_cmp_by_off) #20
  %11 = bitcast i8* %call to %struct.bpf_kfunc_btf*
  store %struct.bpf_kfunc_btf* %11, %struct.bpf_kfunc_btf** %b, align 8
  %12 = load %struct.bpf_kfunc_btf*, %struct.bpf_kfunc_btf** %b, align 8
  %tobool = icmp ne %struct.bpf_kfunc_btf* %12, null
  br i1 %tobool, label %if.end38, label %if.then

if.then:                                          ; preds = %entry
  %13 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab, align 8
  %nr_descs2 = getelementptr inbounds %struct.bpf_kfunc_btf_tab, %struct.bpf_kfunc_btf_tab* %13, i32 0, i32 1
  %14 = load i32, i32* %nr_descs2, align 8
  %cmp = icmp eq i32 %14, 256
  br i1 %cmp, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = bitcast %struct.bpf_verifier_env* %15 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %16, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.44, i64 0, i64 0)) #20
  %call5 = call i8* @ERR_PTR(i64 noundef -7) #20
  %17 = bitcast i8* %call5 to %struct.btf*
  store %struct.btf* %17, %struct.btf** %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %fd_array = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 41
  %19 = bitcast %struct.sockptr_t* %fd_array to { i8*, i8 }*
  %20 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %19, i32 0, i32 0
  %21 = load i8*, i8** %20, align 8
  %22 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %19, i32 0, i32 1
  %23 = load i8, i8* %22, align 8
  %call6 = call zeroext i1 @bpfptr_is_null(i8* %21, i8 %23) #20
  br i1 %call6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.45, i64 0, i64 0)) #20
  %call8 = call i8* @ERR_PTR(i64 noundef -71) #20
  %26 = bitcast i8* %call8 to %struct.btf*
  store %struct.btf* %26, %struct.btf** %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end
  %27 = bitcast i32* %btf_fd to i8*
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %fd_array10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 41
  %29 = load i16, i16* %offset.addr, align 2
  %conv11 = sext i16 %29 to i64
  %mul = mul i64 %conv11, 4
  %30 = bitcast %struct.sockptr_t* %fd_array10 to { i8*, i8 }*
  %31 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %30, i32 0, i32 0
  %32 = load i8*, i8** %31, align 8
  %33 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %30, i32 0, i32 1
  %34 = load i8, i8* %33, align 8
  %call12 = call i32 @copy_from_bpfptr_offset(i8* noundef %27, i8* %32, i8 %34, i64 noundef %mul, i64 noundef 4) #20
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end9
  %call15 = call i8* @ERR_PTR(i64 noundef -14) #20
  %35 = bitcast i8* %call15 to %struct.btf*
  store %struct.btf* %35, %struct.btf** %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end9
  %36 = load i32, i32* %btf_fd, align 4
  %call17 = call %struct.btf* @btf_get_by_fd(i32 noundef %36) #20
  store %struct.btf* %call17, %struct.btf** %btf, align 8
  %37 = load %struct.btf*, %struct.btf** %btf, align 8
  %38 = bitcast %struct.btf* %37 to i8*
  %call18 = call zeroext i1 @IS_ERR(i8* noundef %38) #20
  br i1 %call18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end16
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = bitcast %struct.bpf_verifier_env* %39 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %40, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.46, i64 0, i64 0)) #20
  %41 = load %struct.btf*, %struct.btf** %btf, align 8
  store %struct.btf* %41, %struct.btf** %retval, align 8
  br label %return

if.end20:                                         ; preds = %if.end16
  %42 = load %struct.btf*, %struct.btf** %btf, align 8
  %call21 = call zeroext i1 @btf_is_module(%struct.btf* noundef %42) #20
  br i1 %call21, label %if.end24, label %if.then22

if.then22:                                        ; preds = %if.end20
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = bitcast %struct.bpf_verifier_env* %43 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %44, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.47, i64 0, i64 0)) #20
  %45 = load %struct.btf*, %struct.btf** %btf, align 8
  call void @btf_put(%struct.btf* noundef %45) #20
  %call23 = call i8* @ERR_PTR(i64 noundef -22) #20
  %46 = bitcast i8* %call23 to %struct.btf*
  store %struct.btf* %46, %struct.btf** %retval, align 8
  br label %return

if.end24:                                         ; preds = %if.end20
  %47 = load %struct.btf*, %struct.btf** %btf, align 8
  %call25 = call %struct.module* @btf_try_get_module(%struct.btf* noundef %47) #20
  store %struct.module* %call25, %struct.module** %mod, align 8
  %48 = load %struct.module*, %struct.module** %mod, align 8
  %tobool26 = icmp ne %struct.module* %48, null
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.end24
  %49 = load %struct.btf*, %struct.btf** %btf, align 8
  call void @btf_put(%struct.btf* noundef %49) #20
  %call28 = call i8* @ERR_PTR(i64 noundef -6) #20
  %50 = bitcast i8* %call28 to %struct.btf*
  store %struct.btf* %50, %struct.btf** %retval, align 8
  br label %return

if.end29:                                         ; preds = %if.end24
  %51 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab, align 8
  %descs30 = getelementptr inbounds %struct.bpf_kfunc_btf_tab, %struct.bpf_kfunc_btf_tab* %51, i32 0, i32 0
  %52 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab, align 8
  %nr_descs31 = getelementptr inbounds %struct.bpf_kfunc_btf_tab, %struct.bpf_kfunc_btf_tab* %52, i32 0, i32 1
  %53 = load i32, i32* %nr_descs31, align 8
  %inc = add i32 %53, 1
  store i32 %inc, i32* %nr_descs31, align 8
  %idxprom = zext i32 %53 to i64
  %arrayidx = getelementptr [256 x %struct.bpf_kfunc_btf], [256 x %struct.bpf_kfunc_btf]* %descs30, i64 0, i64 %idxprom
  store %struct.bpf_kfunc_btf* %arrayidx, %struct.bpf_kfunc_btf** %b, align 8
  %54 = load %struct.btf*, %struct.btf** %btf, align 8
  %55 = load %struct.bpf_kfunc_btf*, %struct.bpf_kfunc_btf** %b, align 8
  %btf32 = getelementptr inbounds %struct.bpf_kfunc_btf, %struct.bpf_kfunc_btf* %55, i32 0, i32 0
  store %struct.btf* %54, %struct.btf** %btf32, align 8
  %56 = load %struct.module*, %struct.module** %mod, align 8
  %57 = load %struct.bpf_kfunc_btf*, %struct.bpf_kfunc_btf** %b, align 8
  %module = getelementptr inbounds %struct.bpf_kfunc_btf, %struct.bpf_kfunc_btf* %57, i32 0, i32 1
  store %struct.module* %56, %struct.module** %module, align 8
  %58 = load i16, i16* %offset.addr, align 2
  %59 = load %struct.bpf_kfunc_btf*, %struct.bpf_kfunc_btf** %b, align 8
  %offset33 = getelementptr inbounds %struct.bpf_kfunc_btf, %struct.bpf_kfunc_btf* %59, i32 0, i32 2
  store i16 %58, i16* %offset33, align 8
  %60 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab, align 8
  %descs34 = getelementptr inbounds %struct.bpf_kfunc_btf_tab, %struct.bpf_kfunc_btf_tab* %60, i32 0, i32 0
  %arraydecay35 = getelementptr inbounds [256 x %struct.bpf_kfunc_btf], [256 x %struct.bpf_kfunc_btf]* %descs34, i64 0, i64 0
  %61 = bitcast %struct.bpf_kfunc_btf* %arraydecay35 to i8*
  %62 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %tab, align 8
  %nr_descs36 = getelementptr inbounds %struct.bpf_kfunc_btf_tab, %struct.bpf_kfunc_btf_tab* %62, i32 0, i32 1
  %63 = load i32, i32* %nr_descs36, align 8
  %conv37 = zext i32 %63 to i64
  call void @sort(i8* noundef %61, i64 noundef %conv37, i64 noundef 24, i32 (i8*, i8*)* noundef @kfunc_btf_cmp_by_off, void (i8*, i8*, i32)* noundef null) #20
  br label %if.end38

if.end38:                                         ; preds = %if.end29, %entry
  %64 = load %struct.bpf_kfunc_btf*, %struct.bpf_kfunc_btf** %b, align 8
  %btf39 = getelementptr inbounds %struct.bpf_kfunc_btf, %struct.bpf_kfunc_btf* %64, i32 0, i32 0
  %65 = load %struct.btf*, %struct.btf** %btf39, align 8
  store %struct.btf* %65, %struct.btf** %retval, align 8
  br label %return

return:                                           ; preds = %if.end38, %if.then27, %if.then22, %if.then19, %if.then14, %if.then7, %if.then4
  %66 = load %struct.btf*, %struct.btf** %retval, align 8
  ret %struct.btf* %66
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @kfunc_btf_cmp_by_off(i8* noundef %a, i8* noundef %b) #0 {
entry:
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  %d0 = alloca %struct.bpf_kfunc_btf*, align 8
  %d1 = alloca %struct.bpf_kfunc_btf*, align 8
  store i8* %a, i8** %a.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  %0 = load i8*, i8** %a.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_kfunc_btf*
  store %struct.bpf_kfunc_btf* %1, %struct.bpf_kfunc_btf** %d0, align 8
  %2 = load i8*, i8** %b.addr, align 8
  %3 = bitcast i8* %2 to %struct.bpf_kfunc_btf*
  store %struct.bpf_kfunc_btf* %3, %struct.bpf_kfunc_btf** %d1, align 8
  %4 = load %struct.bpf_kfunc_btf*, %struct.bpf_kfunc_btf** %d0, align 8
  %offset = getelementptr inbounds %struct.bpf_kfunc_btf, %struct.bpf_kfunc_btf* %4, i32 0, i32 2
  %5 = load i16, i16* %offset, align 8
  %conv = zext i16 %5 to i32
  %6 = load %struct.bpf_kfunc_btf*, %struct.bpf_kfunc_btf** %d1, align 8
  %offset1 = getelementptr inbounds %struct.bpf_kfunc_btf, %struct.bpf_kfunc_btf* %6, i32 0, i32 2
  %7 = load i16, i16* %offset1, align 8
  %conv2 = zext i16 %7 to i32
  %sub = sub i32 %conv, %conv2
  ret i32 %sub
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpfptr_is_null(i8* %bpfptr.coerce0, i8 %bpfptr.coerce1) #0 {
entry:
  %retval = alloca i1, align 1
  %bpfptr = alloca %struct.sockptr_t, align 8
  %0 = bitcast %struct.sockptr_t* %bpfptr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %bpfptr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %bpfptr.coerce1, i8* %2, align 8
  %3 = bitcast %struct.sockptr_t* %bpfptr to { i8*, i8 }*
  %4 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 0
  %5 = load i8*, i8** %4, align 8
  %6 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 1
  %7 = load i8, i8* %6, align 8
  %call = call zeroext i1 @bpfptr_is_kernel(i8* %5, i8 %7) #20
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %bpfptr, i32 0, i32 0
  %kernel = bitcast %union.anon.48* %8 to i8**
  %9 = load i8*, i8** %kernel, align 8
  %tobool = icmp ne i8* %9, null
  %lnot = xor i1 %tobool, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %10 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %bpfptr, i32 0, i32 0
  %user = bitcast %union.anon.48* %10 to i8**
  %11 = load i8*, i8** %user, align 8
  %tobool1 = icmp ne i8* %11, null
  %lnot2 = xor i1 %tobool1, true
  store i1 %lnot2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i1, i1* %retval, align 1
  ret i1 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_from_bpfptr_offset(i8* noundef %dst, i8* %src.coerce0, i8 %src.coerce1, i64 noundef %offset, i64 noundef %size) #0 {
entry:
  %retval.i.i = alloca i1, align 1
  %addr.addr.i.i = alloca i8*, align 8
  %bytes.addr.i.i = alloca i64, align 8
  %is_source.addr.i.i = alloca i8, align 1
  %sz.i.i = alloca i32, align 4
  %__ret_warn_on.i.i = alloca i32, align 4
  %__flags.i.i = alloca i32, align 4
  %tmp.i.i = alloca i64, align 8
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %retval = alloca i32, align 4
  %src = alloca %struct.sockptr_t, align 8
  %dst.addr = alloca i8*, align 8
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %0 = bitcast %struct.sockptr_t* %src to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %src.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %src.coerce1, i8* %2, align 8
  store i8* %dst, i8** %dst.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = bitcast %struct.sockptr_t* %src to { i8*, i8 }*
  %4 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 0
  %5 = load i8*, i8** %4, align 8
  %6 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 1
  %7 = load i8, i8* %6, align 8
  %call = call zeroext i1 @bpfptr_is_kernel(i8* %5, i8 %7) #20
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %8 = load i8*, i8** %dst.addr, align 8
  %9 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %src, i32 0, i32 0
  %user = bitcast %union.anon.48* %9 to i8**
  %10 = load i8*, i8** %user, align 8
  %11 = load i64, i64* %offset.addr, align 8
  %add.ptr = getelementptr i8, i8* %10, i64 %11
  %12 = load i64, i64* %size.addr, align 8
  store i8* %8, i8** %to.addr.i, align 8
  store i8* %add.ptr, i8** %from.addr.i, align 8
  store i64 %12, i64* %n.addr.i, align 8
  %13 = load i8*, i8** %to.addr.i, align 8
  %14 = load i64, i64* %n.addr.i, align 8
  store i8* %13, i8** %addr.addr.i.i, align 8
  store i64 %14, i64* %bytes.addr.i.i, align 8
  store i8 0, i8* %is_source.addr.i.i, align 1
  %15 = load i8*, i8** %addr.addr.i.i, align 8
  %16 = call i64 @llvm.objectsize.i64.p0i8(i8* %15, i1 false, i1 true, i1 false) #19
  %conv.i.i = trunc i64 %16 to i32
  store i32 %conv.i.i, i32* %sz.i.i, align 4
  %17 = load i32, i32* %sz.i.i, align 4
  %cmp.i.i = icmp sge i32 %17, 0
  br i1 %cmp.i.i, label %land.rhs.i.i, label %land.end.i.i

land.rhs.i.i:                                     ; preds = %if.then
  %18 = load i32, i32* %sz.i.i, align 4
  %conv2.i.i = sext i32 %18 to i64
  %19 = load i64, i64* %bytes.addr.i.i, align 8
  %cmp3.i.i = icmp ult i64 %conv2.i.i, %19
  br label %land.end.i.i

land.end.i.i:                                     ; preds = %land.rhs.i.i, %if.then
  %20 = phi i1 [ false, %if.then ], [ %cmp3.i.i, %land.rhs.i.i ]
  %lnot.i.i = xor i1 %20, true
  %lnot.ext.i.i = zext i1 %20 to i32
  %conv6.i.i = sext i32 %lnot.ext.i.i to i64
  br i1 %20, label %if.then.i.i, label %if.end12.i.i

if.then.i.i:                                      ; preds = %land.end.i.i
  %21 = load i64, i64* %bytes.addr.i.i, align 8
  %22 = call i1 @llvm.is.constant.i64(i64 %21) #19
  br i1 %22, label %if.else.i.i, label %if.then7.i.i

if.then7.i.i:                                     ; preds = %if.then.i.i
  %23 = load i32, i32* %sz.i.i, align 4
  %24 = load i64, i64* %bytes.addr.i.i, align 8
  call void @copy_overflow(i32 noundef %23, i64 noundef %24) #22
  br label %if.end11.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %25 = load i8, i8* %is_source.addr.i.i, align 1
  %tobool8.i.i = trunc i8 %25 to i1
  br i1 %tobool8.i.i, label %if.then9.i.i, label %if.else10.i.i

if.then9.i.i:                                     ; preds = %if.else.i.i
  call void @__bad_copy_from() #22, !srcloc !7
  br label %if.end.i.i

if.else10.i.i:                                    ; preds = %if.else.i.i
  call void @__bad_copy_to() #22, !srcloc !8
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.else10.i.i, %if.then9.i.i
  br label %if.end11.i.i

if.end11.i.i:                                     ; preds = %if.end.i.i, %if.then7.i.i
  store i1 false, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

if.end12.i.i:                                     ; preds = %land.end.i.i
  %26 = load i64, i64* %bytes.addr.i.i, align 8
  %cmp13.i.i = icmp ugt i64 %26, 2147483647
  %lnot15.i.i = xor i1 %cmp13.i.i, true
  %lnot.ext18.i.i = zext i1 %cmp13.i.i to i32
  store i32 %lnot.ext18.i.i, i32* %__ret_warn_on.i.i, align 4
  %27 = load i32, i32* %__ret_warn_on.i.i, align 4
  %tobool19.i.i = icmp ne i32 %27, 0
  %lnot20.i.i = xor i1 %tobool19.i.i, true
  %lnot.ext23.i.i = zext i1 %tobool19.i.i to i32
  %conv24.i.i = sext i32 %lnot.ext23.i.i to i64
  br i1 %tobool19.i.i, label %if.then26.i.i, label %if.end33.i.i

if.then26.i.i:                                    ; preds = %if.end12.i.i
  store i32 2307, i32* %__flags.i.i, align 4
  %28 = load i32, i32* %__flags.i.i, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.27, i64 0, i64 0), i32 233, i32 %28, i64 12) #19, !srcloc !9
  br label %if.end33.i.i

if.end33.i.i:                                     ; preds = %if.then26.i.i, %if.end12.i.i
  %29 = load i32, i32* %__ret_warn_on.i.i, align 4
  %tobool34.i.i = icmp ne i32 %29, 0
  %lnot35.i.i = xor i1 %tobool34.i.i, true
  %lnot.ext38.i.i = zext i1 %tobool34.i.i to i32
  %conv39.i.i = sext i32 %lnot.ext38.i.i to i64
  store i64 %conv39.i.i, i64* %tmp.i.i, align 8
  %30 = load i64, i64* %tmp.i.i, align 8
  %tobool40.i.i = icmp ne i64 %30, 0
  br i1 %tobool40.i.i, label %if.then41.i.i, label %if.end42.i.i

if.then41.i.i:                                    ; preds = %if.end33.i.i
  store i1 false, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

if.end42.i.i:                                     ; preds = %if.end33.i.i
  %31 = load i8*, i8** %addr.addr.i.i, align 8
  %32 = load i64, i64* %bytes.addr.i.i, align 8
  %33 = load i8, i8* %is_source.addr.i.i, align 1
  %tobool43.i.i = trunc i8 %33 to i1
  call void @check_object_size(i8* noundef %31, i64 noundef %32, i1 noundef zeroext %tobool43.i.i) #22
  store i1 true, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

check_copy_size.exit.i:                           ; preds = %if.end42.i.i, %if.then41.i.i, %if.end11.i.i
  %34 = load i1, i1* %retval.i.i, align 1
  br i1 %34, label %if.then.i, label %copy_from_user.exit

if.then.i:                                        ; preds = %check_copy_size.exit.i
  %35 = load i8*, i8** %to.addr.i, align 8
  %36 = load i8*, i8** %from.addr.i, align 8
  %37 = load i64, i64* %n.addr.i, align 8
  %call1.i = call i64 @_copy_from_user(i8* noundef %35, i8* noundef %36, i64 noundef %37) #22
  store i64 %call1.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %check_copy_size.exit.i, %if.then.i
  %38 = load i64, i64* %n.addr.i, align 8
  %conv = trunc i64 %38 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %39 = load i8*, i8** %dst.addr, align 8
  %40 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %src, i32 0, i32 0
  %kernel = bitcast %union.anon.48* %40 to i8**
  %41 = load i8*, i8** %kernel, align 8
  %42 = load i64, i64* %offset.addr, align 8
  %add.ptr2 = getelementptr i8, i8* %41, i64 %42
  %43 = load i64, i64* %size.addr, align 8
  %call3 = call i64 @copy_from_kernel_nofault(i8* noundef %39, i8* noundef %add.ptr2, i64 noundef %43) #20
  %conv4 = trunc i64 %call3 to i32
  store i32 %conv4, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %copy_from_user.exit
  %44 = load i32, i32* %retval, align 4
  ret i32 %44
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf* @btf_get_by_fd(i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @btf_is_module(%struct.btf* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.module* @btf_try_get_module(%struct.btf* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @sort(i8* noundef, i64 noundef, i64 noundef, i32 (i8*, i8*)* noundef, void (i8*, i8*, i32)* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpfptr_is_kernel(i8* %bpfptr.coerce0, i8 %bpfptr.coerce1) #0 {
entry:
  %bpfptr = alloca %struct.sockptr_t, align 8
  %0 = bitcast %struct.sockptr_t* %bpfptr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %bpfptr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %bpfptr.coerce1, i8* %2, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %bpfptr, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  ret i1 %bf.cast
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @copy_from_kernel_nofault(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @_copy_from_user(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bitmap_copy_clear_tail(i64* noundef %dst, i64* noundef %src, i32 noundef %nbits) #0 {
entry:
  %dst.addr = alloca i64*, align 8
  %src.addr = alloca i64*, align 8
  %nbits.addr = alloca i32, align 4
  store i64* %dst, i64** %dst.addr, align 8
  store i64* %src, i64** %src.addr, align 8
  store i32 %nbits, i32* %nbits.addr, align 4
  %0 = load i64*, i64** %dst.addr, align 8
  %1 = load i64*, i64** %src.addr, align 8
  %2 = load i32, i32* %nbits.addr, align 4
  call void @bitmap_copy(i64* noundef %0, i64* noundef %1, i32 noundef %2) #20
  %3 = load i32, i32* %nbits.addr, align 4
  %rem = urem i32 %3, 64
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %nbits.addr, align 4
  %sub = sub i32 0, %4
  %and = and i32 %sub, 63
  %sh_prom = zext i32 %and to i64
  %shr = lshr i64 -1, %sh_prom
  %5 = load i64*, i64** %dst.addr, align 8
  %6 = load i32, i32* %nbits.addr, align 4
  %div = udiv i32 %6, 64
  %idxprom = zext i32 %div to i64
  %arrayidx = getelementptr i64, i64* %5, i64 %idxprom
  %7 = load i64, i64* %arrayidx, align 8
  %and1 = and i64 %7, %shr
  store i64 %and1, i64* %arrayidx, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bitmap_copy(i64* noundef %dst, i64* noundef %src, i32 noundef %nbits) #0 {
entry:
  %dst.addr = alloca i64*, align 8
  %src.addr = alloca i64*, align 8
  %nbits.addr = alloca i32, align 4
  %len = alloca i32, align 4
  store i64* %dst, i64** %dst.addr, align 8
  store i64* %src, i64** %src.addr, align 8
  store i32 %nbits, i32* %nbits.addr, align 4
  %0 = load i32, i32* %nbits.addr, align 4
  %conv = zext i32 %0 to i64
  %add = add i64 %conv, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %mul = mul i64 %div, 8
  %conv1 = trunc i64 %mul to i32
  store i32 %conv1, i32* %len, align 4
  %1 = load i32, i32* %nbits.addr, align 4
  %2 = call i1 @llvm.is.constant.i32(i32 %1)
  br i1 %2, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %3 = load i32, i32* %nbits.addr, align 4
  %cmp = icmp ule i32 %3, 64
  br i1 %cmp, label %land.lhs.true3, label %if.else

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load i32, i32* %nbits.addr, align 4
  %cmp4 = icmp ugt i32 %4, 0
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true3
  %5 = load i64*, i64** %src.addr, align 8
  %6 = load i64, i64* %5, align 8
  %7 = load i64*, i64** %dst.addr, align 8
  store i64 %6, i64* %7, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true3, %land.lhs.true, %entry
  %8 = load i64*, i64** %dst.addr, align 8
  %9 = bitcast i64* %8 to i8*
  %10 = load i64*, i64** %src.addr, align 8
  %11 = bitcast i64* %10 to i8*
  %12 = load i32, i32* %len, align 4
  %conv6 = zext i32 %12 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %9, i8* align 8 %11, i64 %conv6, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: convergent nofree nosync nounwind readnone willreturn
declare i1 @llvm.is.constant.i32(i32) #10

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare i64 @llvm.cttz.i64(i64, i1 immarg) #9

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @_find_next_bit(i64* noundef, i64 noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_scratched(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %scratched_regs = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 42
  %1 = load i32, i32* %scratched_regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %shr = lshr i32 %1, %2
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_liveness(%struct.bpf_verifier_env* noundef %env, i32 noundef %live) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %live.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %live, i32* %live.addr, align 4
  %0 = load i32, i32* %live.addr, align 4
  %and = and i32 %0, 15
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = bitcast %struct.bpf_verifier_env* %1 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %2, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i64 0, i64 0)) #20
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, i32* %live.addr, align 4
  %and1 = and i32 %3, 3
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.79, i64 0, i64 0)) #20
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %6 = load i32, i32* %live.addr, align 4
  %and5 = and i32 %6, 4
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = bitcast %struct.bpf_verifier_env* %7 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %8, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.80, i64 0, i64 0)) #20
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end4
  %9 = load i32, i32* %live.addr, align 4
  %and9 = and i32 %9, 8
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.81, i64 0, i64 0)) #20
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @reg_type_str(%struct.bpf_verifier_env* noundef %env, i32 noundef %type) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %type.addr = alloca i32, align 4
  %postfix = alloca [16 x i8], align 16
  %prefix = alloca [32 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = bitcast [16 x i8]* %postfix to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %0, i8 0, i64 16, i1 false)
  %1 = bitcast [32 x i8]* %prefix to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %1, i8 0, i64 32, i1 false)
  %2 = load i32, i32* %type.addr, align 4
  %and = and i32 %2, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %type.addr, align 4
  %call = call i32 @base_type(i32 noundef %3) #20
  %cmp = icmp eq i32 %call, 16
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %postfix, i64 0, i64 0
  %call2 = call i8* @strncpy(i8* noundef %arraydecay, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.103, i64 0, i64 0), i64 noundef 16) #20
  br label %if.end

if.else:                                          ; preds = %if.then
  %arraydecay3 = getelementptr inbounds [16 x i8], [16 x i8]* %postfix, i64 0, i64 0
  %call4 = call i8* @strncpy(i8* noundef %arraydecay3, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.104, i64 0, i64 0), i64 noundef 16) #20
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then1
  br label %if.end5

if.end5:                                          ; preds = %if.end, %entry
  %4 = load i32, i32* %type.addr, align 4
  %and6 = and i32 %4, 512
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then8, label %if.end11

if.then8:                                         ; preds = %if.end5
  %arraydecay9 = getelementptr inbounds [32 x i8], [32 x i8]* %prefix, i64 0, i64 0
  %call10 = call i8* @strncpy(i8* noundef %arraydecay9, i8* noundef getelementptr inbounds ([8 x i8], [8 x i8]* @.str.105, i64 0, i64 0), i64 noundef 32) #20
  br label %if.end11

if.end11:                                         ; preds = %if.then8, %if.end5
  %5 = load i32, i32* %type.addr, align 4
  %and12 = and i32 %5, 1024
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.end11
  %arraydecay15 = getelementptr inbounds [32 x i8], [32 x i8]* %prefix, i64 0, i64 0
  %call16 = call i8* @strncpy(i8* noundef %arraydecay15, i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str.106, i64 0, i64 0), i64 noundef 32) #20
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.end11
  %6 = load i32, i32* %type.addr, align 4
  %and18 = and i32 %6, 2048
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end17
  %arraydecay21 = getelementptr inbounds [32 x i8], [32 x i8]* %prefix, i64 0, i64 0
  %call22 = call i8* @strncpy(i8* noundef %arraydecay21, i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str.107, i64 0, i64 0), i64 noundef 32) #20
  br label %if.end23

if.end23:                                         ; preds = %if.then20, %if.end17
  %7 = load i32, i32* %type.addr, align 4
  %and24 = and i32 %7, 4096
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end23
  %arraydecay27 = getelementptr inbounds [32 x i8], [32 x i8]* %prefix, i64 0, i64 0
  %call28 = call i8* @strncpy(i8* noundef %arraydecay27, i8* noundef getelementptr inbounds ([8 x i8], [8 x i8]* @.str.108, i64 0, i64 0), i64 noundef 32) #20
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %if.end23
  %8 = load i32, i32* %type.addr, align 4
  %and30 = and i32 %8, 16384
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.then32, label %if.end35

if.then32:                                        ; preds = %if.end29
  %arraydecay33 = getelementptr inbounds [32 x i8], [32 x i8]* %prefix, i64 0, i64 0
  %call34 = call i8* @strncpy(i8* noundef %arraydecay33, i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str.109, i64 0, i64 0), i64 noundef 32) #20
  br label %if.end35

if.end35:                                         ; preds = %if.then32, %if.end29
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %type_str_buf = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 46
  %arraydecay36 = getelementptr inbounds [64 x i8], [64 x i8]* %type_str_buf, i64 0, i64 0
  %arraydecay37 = getelementptr inbounds [32 x i8], [32 x i8]* %prefix, i64 0, i64 0
  %10 = load i32, i32* %type.addr, align 4
  %call38 = call i32 @base_type(i32 noundef %10) #20
  %idxprom = zext i32 %call38 to i64
  %arrayidx = getelementptr [21 x i8*], [21 x i8*]* @reg_type_str.str, i64 0, i64 %idxprom
  %11 = load i8*, i8** %arrayidx, align 8
  %arraydecay39 = getelementptr inbounds [16 x i8], [16 x i8]* %postfix, i64 0, i64 0
  %call40 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* noundef %arraydecay36, i64 noundef 64, i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str.110, i64 0, i64 0), i8* noundef %arraydecay37, i8* noundef %11, i8* noundef %arraydecay39) #20
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %type_str_buf41 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 46
  %arraydecay42 = getelementptr inbounds [64 x i8], [64 x i8]* %type_str_buf41, i64 0, i64 0
  ret i8* %arraydecay42
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kernel_type_name(%struct.btf* noundef %btf, i32 noundef %id) #0 {
entry:
  %btf.addr = alloca %struct.btf*, align 8
  %id.addr = alloca i32, align 4
  store %struct.btf* %btf, %struct.btf** %btf.addr, align 8
  store i32 %id, i32* %id.addr, align 4
  %0 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %1 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %2 = load i32, i32* %id.addr, align 4
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %1, i32 noundef %2) #20
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %call, i32 0, i32 0
  %3 = load i32, i32* %name_off, align 4
  %call1 = call i8* @btf_name_by_offset(%struct.btf* noundef %0, i32 noundef %3) #20
  ret i8* %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_may_be_refcounted_or_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %call = call i32 @base_type(i32 noundef %0) #20
  store i32 %call, i32* %type.addr, align 4
  %1 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %1, 11
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %2, 13
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %3 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %3, 17
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false2
  %4 = load i32, i32* %type.addr, align 4
  %cmp4 = icmp eq i32 %4, 16
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false2, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp4, %lor.rhs ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @type_is_pkt_pointer(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %call = call i32 @base_type(i32 noundef %0) #20
  store i32 %call, i32* %type.addr, align 4
  %1 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %1, 8
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %2, 7
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_is_unknown(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %3 = load i64, i64* %mask, align 8
  %neg = xor i64 %3, -1
  %tobool = icmp ne i64 %neg, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @tnum_strn(i8* noundef, i64 noundef, i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @stack_slot_scratched(%struct.bpf_verifier_env* noundef %env, i64 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i64 %regno, i64* %regno.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %scratched_stack_slots = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 43
  %1 = load i64, i64* %scratched_stack_slots, align 8
  %2 = load i64, i64* %regno.addr, align 8
  %shr = lshr i64 %1, %2
  %and = and i64 %shr, 1
  %tobool = icmp ne i64 %and, 0
  ret i1 %tobool
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @strncpy(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @snprintf(i8* noundef, i64 noundef, i8* noundef, ...) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_equals_const(i64 %a.coerce0, i64 %a.coerce1, i64 noundef %b) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %b.addr = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i64 %b, i64* %b.addr, align 8
  %3 = bitcast %struct.tnum* %a to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %5, i64 %7) #20
  br i1 %call, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %8 = load i64, i64* %value, align 8
  %9 = load i64, i64* %b.addr, align 8
  %cmp = icmp eq i64 %8, %9
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %10 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @map_value_has_timer(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %timer_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 11
  %1 = load i32, i32* %timer_off, align 64
  %cmp = icmp sge i32 %1, 0
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_packet_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  %__UNIQUE_ID___x559 = alloca i32, align 4
  %__UNIQUE_ID___y560 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 6
  %4 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = bitcast %struct.bpf_verifier_env* %5 to i8*
  %7 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %6, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.117, i64 0, i64 0), i32 noundef %7) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 2
  %range = bitcast %union.anon.168* %9 to i32*
  %10 = load i32, i32* %range, align 8
  %cmp1 = icmp slt i32 %10, 0
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size.addr, align 4
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 2
  %range2 = bitcast %union.anon.168* %16 to i32*
  %17 = load i32, i32* %range2, align 8
  %18 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %18 to i1
  %call3 = call i32 @__check_mem_access(%struct.bpf_verifier_env* noundef %11, i32 noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %17, i1 noundef zeroext %tobool) #20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -22, %cond.true ], [ %call3, %cond.false ]
  store i32 %cond, i32* %err, align 4
  %19 = load i32, i32* %err, align 4
  %tobool4 = icmp ne i32 %19, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %cond.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  %22 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.118, i64 0, i64 0), i32 noundef %22) #20
  %23 = load i32, i32* %err, align 4
  store i32 %23, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %cond.end
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 2
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %25, i32 0, i32 10
  %26 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_pkt_offset = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %26, i32 0, i32 4
  %27 = load i32, i32* %max_pkt_offset, align 4
  store i32 %27, i32* %__UNIQUE_ID___x559, align 4
  %28 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %28 to i64
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 9
  %30 = load i64, i64* %umax_value, align 8
  %add = add i64 %conv, %30
  %31 = load i32, i32* %size.addr, align 4
  %conv7 = sext i32 %31 to i64
  %add8 = add i64 %add, %conv7
  %sub = sub i64 %add8, 1
  %conv9 = trunc i64 %sub to i32
  store i32 %conv9, i32* %__UNIQUE_ID___y560, align 4
  %32 = load i32, i32* %__UNIQUE_ID___x559, align 4
  %33 = load i32, i32* %__UNIQUE_ID___y560, align 4
  %cmp10 = icmp ugt i32 %32, %33
  br i1 %cmp10, label %cond.true12, label %cond.false13

cond.true12:                                      ; preds = %if.end6
  %34 = load i32, i32* %__UNIQUE_ID___x559, align 4
  br label %cond.end14

cond.false13:                                     ; preds = %if.end6
  %35 = load i32, i32* %__UNIQUE_ID___y560, align 4
  br label %cond.end14

cond.end14:                                       ; preds = %cond.false13, %cond.true12
  %cond15 = phi i32 [ %34, %cond.true12 ], [ %35, %cond.false13 ]
  store i32 %cond15, i32* %tmp, align 4
  %36 = load i32, i32* %tmp, align 4
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %37, i32 0, i32 2
  %38 = load %struct.bpf_prog*, %struct.bpf_prog** %prog16, align 8
  %aux17 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %38, i32 0, i32 10
  %39 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux17, align 8
  %max_pkt_offset18 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %39, i32 0, i32 4
  store i32 %36, i32* %max_pkt_offset18, align 4
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cond.end14, %if.then5, %if.then
  %41 = load i32, i32* %retval, align 4
  ret i32 %41
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %mem_size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %mem_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %mem_size, i32* %mem_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %7 = load i32, i32* %regno.addr, align 4
  %idxprom1 = zext i32 %7 to i64
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom1
  store %struct.bpf_reg_state* %arrayidx2, %struct.bpf_reg_state** %reg, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %9, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  %11 = load i64, i64* %smin_value3, align 8
  %cmp4 = icmp eq i64 %11, -9223372036854775808
  br i1 %cmp4, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %12 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %12 to i64
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 6
  %14 = load i64, i64* %smin_value5, align 8
  %add = add i64 %conv, %14
  %15 = load i32, i32* %off.addr, align 4
  %conv6 = sext i32 %15 to i64
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 6
  %17 = load i64, i64* %smin_value7, align 8
  %add8 = add i64 %conv6, %17
  %conv9 = trunc i64 %add8 to i32
  %conv10 = sext i32 %conv9 to i64
  %cmp11 = icmp ne i64 %add, %conv10
  br i1 %cmp11, label %if.then, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 6
  %19 = load i64, i64* %smin_value14, align 8
  %20 = load i32, i32* %off.addr, align 4
  %conv15 = sext i32 %20 to i64
  %add16 = add i64 %19, %conv15
  %cmp17 = icmp slt i64 %add16, 0
  br i1 %cmp17, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false13, %lor.lhs.false, %land.lhs.true
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  %23 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.117, i64 0, i64 0), i32 noundef %23) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false13, %entry
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load i32, i32* %regno.addr, align 4
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 6
  %27 = load i64, i64* %smin_value19, align 8
  %28 = load i32, i32* %off.addr, align 4
  %conv20 = sext i32 %28 to i64
  %add21 = add i64 %27, %conv20
  %conv22 = trunc i64 %add21 to i32
  %29 = load i32, i32* %size.addr, align 4
  %30 = load i32, i32* %mem_size.addr, align 4
  %31 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %31 to i1
  %call = call i32 @__check_mem_access(%struct.bpf_verifier_env* noundef %24, i32 noundef %25, i32 noundef %conv22, i32 noundef %29, i32 noundef %30, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %err, align 4
  %32 = load i32, i32* %err, align 4
  %tobool23 = icmp ne i32 %32, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  %35 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.123, i64 0, i64 0), i32 noundef %35) #20
  %36 = load i32, i32* %err, align 4
  store i32 %36, i32* %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.end
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 9
  %38 = load i64, i64* %umax_value, align 8
  %cmp26 = icmp uge i64 %38, 536870912
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end25
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = bitcast %struct.bpf_verifier_env* %39 to i8*
  %41 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %40, i8* noundef getelementptr inbounds ([72 x i8], [72 x i8]* @.str.124, i64 0, i64 0), i32 noundef %41) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %if.end25
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %43 = load i32, i32* %regno.addr, align 4
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 9
  %45 = load i64, i64* %umax_value30, align 8
  %46 = load i32, i32* %off.addr, align 4
  %conv31 = sext i32 %46 to i64
  %add32 = add i64 %45, %conv31
  %conv33 = trunc i64 %add32 to i32
  %47 = load i32, i32* %size.addr, align 4
  %48 = load i32, i32* %mem_size.addr, align 4
  %49 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool34 = trunc i8 %49 to i1
  %call35 = call i32 @__check_mem_access(%struct.bpf_verifier_env* noundef %42, i32 noundef %43, i32 noundef %conv33, i32 noundef %47, i32 noundef %48, i1 noundef zeroext %tobool34) #20
  store i32 %call35, i32* %err, align 4
  %50 = load i32, i32* %err, align 4
  %tobool36 = icmp ne i32 %50, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end29
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  %53 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.125, i64 0, i64 0), i32 noundef %53) #20
  %54 = load i32, i32* %err, align 4
  store i32 %54, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.end29
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end38, %if.then37, %if.then28, %if.then24, %if.then
  %55 = load i32, i32* %retval, align 4
  ret i32 %55
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_access_type(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %cap = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 2
  %4 = bitcast %union.anon.168* %3 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %5, %struct.bpf_map** %map, align 8
  %6 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call1 = call i32 @bpf_map_flags_to_cap(%struct.bpf_map* noundef %6) #20
  store i32 %call1, i32* %cap, align 4
  %7 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %7, 2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %8 = load i32, i32* %cap, align 4
  %conv = zext i32 %8 to i64
  %and = and i64 %conv, 2
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  %11 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %11, i32 0, i32 5
  %12 = load i32, i32* %value_size, align 32
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.126, i64 0, i64 0), i32 noundef %12, i32 noundef %13, i32 noundef %14) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %15 = load i32, i32* %type.addr, align 4
  %cmp2 = icmp eq i32 %15, 1
  br i1 %cmp2, label %land.lhs.true4, label %if.end10

land.lhs.true4:                                   ; preds = %if.end
  %16 = load i32, i32* %cap, align 4
  %conv5 = zext i32 %16 to i64
  %and6 = and i64 %conv5, 1
  %tobool7 = icmp ne i64 %and6, 0
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %land.lhs.true4
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  %19 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size9 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %19, i32 0, i32 5
  %20 = load i32, i32* %value_size9, align 32
  %21 = load i32, i32* %off.addr, align 4
  %22 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.127, i64 0, i64 0), i32 noundef %20, i32 noundef %21, i32 noundef %22) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %land.lhs.true4, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then8, %if.then
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed, i32 noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %src.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %err = alloca i32, align 4
  %lock = alloca i32, align 4
  %t = alloca i32, align 4
  %tab = alloca %struct.bpf_map_value_off*, align 8
  %i = alloca i32, align 4
  %p = alloca i32, align 4
  %bytes = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store i32 %src, i32* %src.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %7 = load i32, i32* %regno.addr, align 4
  %idxprom1 = zext i32 %7 to i64
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom1
  store %struct.bpf_reg_state* %arrayidx2, %struct.bpf_reg_state** %reg, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 2
  %10 = bitcast %union.anon.168* %9 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %10, i32 0, i32 0
  %11 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %11, %struct.bpf_map** %map, align 8
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load i32, i32* %regno.addr, align 4
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  %16 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %16, i32 0, i32 5
  %17 = load i32, i32* %value_size, align 32
  %18 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %18 to i1
  %call = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %15, i32 noundef %17, i1 noundef zeroext %tobool) #20
  store i32 %call, i32* %err, align 4
  %19 = load i32, i32* %err, align 4
  %tobool3 = icmp ne i32 %19, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %20 = load i32, i32* %err, align 4
  store i32 %20, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %21 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call4 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %21) #20
  br i1 %call4, label %if.then5, label %if.end18

if.then5:                                         ; preds = %if.end
  %22 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %22, i32 0, i32 9
  %23 = load i32, i32* %spin_lock_off, align 4
  store i32 %23, i32* %lock, align 4
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 6
  %25 = load i64, i64* %smin_value, align 8
  %26 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %26 to i64
  %add = add i64 %25, %conv
  %27 = load i32, i32* %lock, align 4
  %conv6 = zext i32 %27 to i64
  %add7 = add i64 %conv6, 4
  %cmp = icmp ult i64 %add, %add7
  br i1 %cmp, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.then5
  %28 = load i32, i32* %lock, align 4
  %conv9 = zext i32 %28 to i64
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 9
  %30 = load i64, i64* %umax_value, align 8
  %31 = load i32, i32* %off.addr, align 4
  %conv10 = sext i32 %31 to i64
  %add11 = add i64 %30, %conv10
  %32 = load i32, i32* %size.addr, align 4
  %conv12 = sext i32 %32 to i64
  %add13 = add i64 %add11, %conv12
  %cmp14 = icmp ult i64 %conv9, %add13
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([57 x i8], [57 x i8]* @.str.128, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %land.lhs.true, %if.then5
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.end
  %35 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call19 = call zeroext i1 @map_value_has_timer(%struct.bpf_map* noundef %35) #20
  br i1 %call19, label %if.then20, label %if.end39

if.then20:                                        ; preds = %if.end18
  %36 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %timer_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %36, i32 0, i32 11
  %37 = load i32, i32* %timer_off, align 64
  store i32 %37, i32* %t, align 4
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 6
  %39 = load i64, i64* %smin_value21, align 8
  %40 = load i32, i32* %off.addr, align 4
  %conv22 = sext i32 %40 to i64
  %add23 = add i64 %39, %conv22
  %41 = load i32, i32* %t, align 4
  %conv24 = zext i32 %41 to i64
  %add25 = add i64 %conv24, 16
  %cmp26 = icmp ult i64 %add23, %add25
  br i1 %cmp26, label %land.lhs.true28, label %if.end38

land.lhs.true28:                                  ; preds = %if.then20
  %42 = load i32, i32* %t, align 4
  %conv29 = zext i32 %42 to i64
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 9
  %44 = load i64, i64* %umax_value30, align 8
  %45 = load i32, i32* %off.addr, align 4
  %conv31 = sext i32 %45 to i64
  %add32 = add i64 %44, %conv31
  %46 = load i32, i32* %size.addr, align 4
  %conv33 = sext i32 %46 to i64
  %add34 = add i64 %add32, %conv33
  %cmp35 = icmp ult i64 %conv29, %add34
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %land.lhs.true28
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = bitcast %struct.bpf_verifier_env* %47 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %48, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.129, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %land.lhs.true28, %if.then20
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end18
  %49 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call40 = call zeroext i1 @map_value_has_kptrs(%struct.bpf_map* noundef %49) #20
  br i1 %call40, label %if.then41, label %if.end88

if.then41:                                        ; preds = %if.end39
  %50 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %kptr_off_tab = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %50, i32 0, i32 10
  %51 = load %struct.bpf_map_value_off*, %struct.bpf_map_value_off** %kptr_off_tab, align 8
  store %struct.bpf_map_value_off* %51, %struct.bpf_map_value_off** %tab, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then41
  %52 = load i32, i32* %i, align 4
  %53 = load %struct.bpf_map_value_off*, %struct.bpf_map_value_off** %tab, align 8
  %nr_off = getelementptr inbounds %struct.bpf_map_value_off, %struct.bpf_map_value_off* %53, i32 0, i32 0
  %54 = load i32, i32* %nr_off, align 8
  %cmp42 = icmp ult i32 %52, %54
  br i1 %cmp42, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %55 = load %struct.bpf_map_value_off*, %struct.bpf_map_value_off** %tab, align 8
  %off44 = getelementptr inbounds %struct.bpf_map_value_off, %struct.bpf_map_value_off* %55, i32 0, i32 1
  %56 = load i32, i32* %i, align 4
  %idxprom45 = sext i32 %56 to i64
  %arrayidx46 = getelementptr [0 x %struct.bpf_map_value_off_desc], [0 x %struct.bpf_map_value_off_desc]* %off44, i64 0, i64 %idxprom45
  %offset = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %arrayidx46, i32 0, i32 0
  %57 = load i32, i32* %offset, align 8
  store i32 %57, i32* %p, align 4
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value47 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %58, i32 0, i32 6
  %59 = load i64, i64* %smin_value47, align 8
  %60 = load i32, i32* %off.addr, align 4
  %conv48 = sext i32 %60 to i64
  %add49 = add i64 %59, %conv48
  %61 = load i32, i32* %p, align 4
  %conv50 = zext i32 %61 to i64
  %add51 = add i64 %conv50, 8
  %cmp52 = icmp ult i64 %add49, %add51
  br i1 %cmp52, label %land.lhs.true54, label %if.end87

land.lhs.true54:                                  ; preds = %for.body
  %62 = load i32, i32* %p, align 4
  %conv55 = zext i32 %62 to i64
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value56 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %63, i32 0, i32 9
  %64 = load i64, i64* %umax_value56, align 8
  %65 = load i32, i32* %off.addr, align 4
  %conv57 = sext i32 %65 to i64
  %add58 = add i64 %64, %conv57
  %66 = load i32, i32* %size.addr, align 4
  %conv59 = sext i32 %66 to i64
  %add60 = add i64 %add58, %conv59
  %cmp61 = icmp ult i64 %conv55, %add60
  br i1 %cmp61, label %if.then63, label %if.end87

if.then63:                                        ; preds = %land.lhs.true54
  %67 = load i32, i32* %src.addr, align 4
  %cmp64 = icmp ne i32 %67, 1
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.then63
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %69 = bitcast %struct.bpf_verifier_env* %68 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %69, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.130, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.then63
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call68 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #20
  br i1 %call68, label %if.end70, label %if.then69

if.then69:                                        ; preds = %if.end67
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %77 = bitcast %struct.bpf_verifier_env* %76 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %77, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.131, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end70:                                         ; preds = %if.end67
  %78 = load i32, i32* %p, align 4
  %conv71 = zext i32 %78 to i64
  %79 = load i32, i32* %off.addr, align 4
  %conv72 = sext i32 %79 to i64
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off73, i32 0, i32 0
  %81 = load i64, i64* %value, align 8
  %add74 = add i64 %conv72, %81
  %cmp75 = icmp ne i64 %conv71, %add74
  br i1 %cmp75, label %if.then77, label %if.end82

if.then77:                                        ; preds = %if.end70
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %83 = bitcast %struct.bpf_verifier_env* %82 to i8*
  %84 = load i32, i32* %p, align 4
  %85 = load i32, i32* %off.addr, align 4
  %conv78 = sext i32 %85 to i64
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off79 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 5
  %value80 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off79, i32 0, i32 0
  %87 = load i64, i64* %value80, align 8
  %add81 = add i64 %conv78, %87
  call void (i8*, i8*, ...) @verbose(i8* noundef %83, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.132, i64 0, i64 0), i32 noundef %84, i64 noundef %add81) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %if.end70
  %88 = load i32, i32* %size.addr, align 4
  store i32 -22, i32* %bytes, align 4
  store i32 8, i32* %bytes, align 4
  %89 = load i32, i32* %bytes, align 4
  store i32 %89, i32* %tmp, align 4
  %90 = load i32, i32* %tmp, align 4
  %cmp83 = icmp ne i32 %88, %90
  br i1 %cmp83, label %if.then85, label %if.end86

if.then85:                                        ; preds = %if.end82
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %92 = bitcast %struct.bpf_verifier_env* %91 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %92, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.133, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end86:                                         ; preds = %if.end82
  br label %for.end

if.end87:                                         ; preds = %land.lhs.true54, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end87
  %93 = load i32, i32* %i, align 4
  %inc = add i32 %93, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !61

for.end:                                          ; preds = %if.end86, %for.cond
  br label %if.end88

if.end88:                                         ; preds = %for.end, %if.end39
  %94 = load i32, i32* %err, align 4
  store i32 %94, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end88, %if.then85, %if.then77, %if.then69, %if.then66, %if.then37, %if.then16, %if.then
  %95 = load i32, i32* %retval, align 4
  ret i32 %95
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @type_is_rdonly_mem(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %and = and i32 %0, 512
  %tobool = icmp ne i32 %and, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed, i32* noundef %max_access) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %max_access.addr = alloca i32*, align 8
  %buf_info = alloca i8*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store i32* %max_access, i32** %max_access.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %call = call zeroext i1 @type_is_rdonly_mem(i32 noundef %1) #20
  %2 = zext i1 %call to i64
  %cond = select i1 %call, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.134, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.135, i64 0, i64 0)
  store i8* %cond, i8** %buf_info, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = load i8*, i8** %buf_info, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %6 = load i32, i32* %regno.addr, align 4
  %7 = load i32, i32* %off.addr, align 4
  %8 = load i32, i32* %size.addr, align 4
  %call1 = call i32 @__check_buffer_access(%struct.bpf_verifier_env* noundef %3, i8* noundef %4, %struct.bpf_reg_state* noundef %5, i32 noundef %6, i32 noundef %7, i32 noundef %8) #20
  store i32 %call1, i32* %err, align 4
  %9 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load i32, i32* %err, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load i32, i32* %off.addr, align 4
  %12 = load i32, i32* %size.addr, align 4
  %add = add i32 %11, %12
  %13 = load i32*, i32** %max_access.addr, align 8
  %14 = load i32, i32* %13, align 4
  %cmp = icmp ugt i32 %add, %14
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %15 = load i32, i32* %off.addr, align 4
  %16 = load i32, i32* %size.addr, align 4
  %add3 = add i32 %15, %16
  %17 = load i32*, i32** %max_access.addr, align 8
  store i32 %add3, i32* %17, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_range_initialized(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %access_size, i1 noundef zeroext %zero_size_allowed, i32 noundef %type, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %access_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %type.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  %min_off = alloca i32, align 4
  %max_off = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %err_extra = alloca i8*, align 8
  %bounds_check_type = alloca i32, align 4
  %clobber = alloca i8, align 1
  %tn_buf = alloca [48 x i8], align 16
  %stype = alloca i8*, align 8
  %tn_buf121 = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %access_size, i32* %access_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store i32 %type, i32* %type.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3) #20
  store %struct.bpf_func_state* %call1, %struct.bpf_func_state** %state, align 8
  %4 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %4, 2
  %5 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.138, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i64 0, i64 0)
  store i8* %cond, i8** %err_extra, align 8
  store i8 0, i8* %clobber, align 1
  %6 = load i32, i32* %access_size.addr, align 4
  %cmp2 = icmp eq i32 %6, 0
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %7 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %7 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.139, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %10 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %10, 2
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  store i32 2, i32* %bounds_check_type, align 4
  store i8 1, i8* %clobber, align 1
  br label %if.end5

if.else:                                          ; preds = %if.end
  store i32 1, i32* %bounds_check_type, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then4
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %access_size.addr, align 4
  %15 = load i32, i32* %type.addr, align 4
  %16 = load i32, i32* %bounds_check_type, align 4
  %call6 = call i32 @check_stack_access_within_bounds(%struct.bpf_verifier_env* noundef %11, i32 noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %15, i32 noundef %16) #20
  store i32 %call6, i32* %err, align 4
  %17 = load i32, i32* %err, align 4
  %tobool7 = icmp ne i32 %17, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %18 = load i32, i32* %err, align 4
  store i32 %18, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end5
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %20 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = load i64, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = load i64, i64* %23, align 8
  %call10 = call zeroext i1 @tnum_is_const(i64 %22, i64 %24) #20
  br i1 %call10, label %if.then11, label %if.else14

if.then11:                                        ; preds = %if.end9
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off12, i32 0, i32 0
  %26 = load i64, i64* %value, align 8
  %27 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %27 to i64
  %add = add i64 %26, %conv
  %conv13 = trunc i64 %add to i32
  store i32 %conv13, i32* %max_off, align 4
  store i32 %conv13, i32* %min_off, align 4
  br label %if.end33

if.else14:                                        ; preds = %if.end9
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 21
  %29 = load i8, i8* %bypass_spec_v1, align 1
  %tobool15 = trunc i8 %29 to i1
  br i1 %tobool15, label %if.end20, label %if.then16

if.then16:                                        ; preds = %if.else14
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %31 = bitcast %struct.tnum* %var_off17 to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = load i64, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = load i64, i64* %34, align 8
  %call18 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %33, i64 %35) #20
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  %38 = load i32, i32* %regno.addr, align 4
  %39 = load i8*, i8** %err_extra, align 8
  %arraydecay19 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.140, i64 0, i64 0), i32 noundef %38, i8* noundef %39, i8* noundef %arraydecay19) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.else14
  %40 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool21 = icmp ne %struct.bpf_call_arg_meta* %40, null
  br i1 %tobool21, label %land.lhs.true22, label %if.end26

land.lhs.true22:                                  ; preds = %if.end20
  %41 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %41, i32 0, i32 1
  %42 = load i8, i8* %raw_mode, align 8
  %tobool23 = trunc i8 %42 to i1
  br i1 %tobool23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %land.lhs.true22
  store %struct.bpf_call_arg_meta* null, %struct.bpf_call_arg_meta** %meta.addr, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %land.lhs.true22, %if.end20
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 6
  %44 = load i64, i64* %smin_value, align 8
  %45 = load i32, i32* %off.addr, align 4
  %conv27 = sext i32 %45 to i64
  %add28 = add i64 %44, %conv27
  %conv29 = trunc i64 %add28 to i32
  store i32 %conv29, i32* %min_off, align 4
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 7
  %47 = load i64, i64* %smax_value, align 8
  %48 = load i32, i32* %off.addr, align 4
  %conv30 = sext i32 %48 to i64
  %add31 = add i64 %47, %conv30
  %conv32 = trunc i64 %add31 to i32
  store i32 %conv32, i32* %max_off, align 4
  br label %if.end33

if.end33:                                         ; preds = %if.end26, %if.then11
  %49 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool34 = icmp ne %struct.bpf_call_arg_meta* %49, null
  br i1 %tobool34, label %land.lhs.true35, label %if.end42

land.lhs.true35:                                  ; preds = %if.end33
  %50 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode36 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %50, i32 0, i32 1
  %51 = load i8, i8* %raw_mode36, align 8
  %tobool37 = trunc i8 %51 to i1
  br i1 %tobool37, label %if.then39, label %if.end42

if.then39:                                        ; preds = %land.lhs.true35
  %52 = load i32, i32* %access_size.addr, align 4
  %53 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %access_size40 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %53, i32 0, i32 5
  store i32 %52, i32* %access_size40, align 8
  %54 = load i32, i32* %regno.addr, align 4
  %55 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %regno41 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %55, i32 0, i32 4
  store i32 %54, i32* %regno41, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end42:                                         ; preds = %land.lhs.true35, %if.end33
  %56 = load i32, i32* %min_off, align 4
  store i32 %56, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc137, %if.end42
  %57 = load i32, i32* %i, align 4
  %58 = load i32, i32* %max_off, align 4
  %59 = load i32, i32* %access_size.addr, align 4
  %add43 = add i32 %58, %59
  %cmp44 = icmp slt i32 %57, %add43
  br i1 %cmp44, label %for.body, label %for.end139

for.body:                                         ; preds = %for.cond
  %60 = load i32, i32* %i, align 4
  %sub = sub i32 0, %60
  %sub46 = sub i32 %sub, 1
  store i32 %sub46, i32* %slot, align 4
  %61 = load i32, i32* %slot, align 4
  %div = sdiv i32 %61, 8
  store i32 %div, i32* %spi, align 4
  %62 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %62, i32 0, i32 10
  %63 = load i32, i32* %allocated_stack, align 8
  %64 = load i32, i32* %slot, align 4
  %cmp47 = icmp sle i32 %63, %64
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %for.body
  br label %err115

if.end50:                                         ; preds = %for.body
  %65 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %65, i32 0, i32 11
  %66 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %67 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %67 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %66, i64 %idxprom
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 1
  %68 = load i32, i32* %slot, align 4
  %rem = srem i32 %68, 8
  %idxprom51 = sext i32 %rem to i64
  %arrayidx52 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom51
  store i8* %arrayidx52, i8** %stype, align 8
  %69 = load i8*, i8** %stype, align 8
  %70 = load i8, i8* %69, align 1
  %conv53 = zext i8 %70 to i32
  %cmp54 = icmp eq i32 %conv53, 2
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end50
  br label %mark

if.end57:                                         ; preds = %if.end50
  %71 = load i8*, i8** %stype, align 8
  %72 = load i8, i8* %71, align 1
  %conv58 = zext i8 %72 to i32
  %cmp59 = icmp eq i32 %conv58, 3
  br i1 %cmp59, label %if.then61, label %if.end65

if.then61:                                        ; preds = %if.end57
  %73 = load i8, i8* %clobber, align 1
  %tobool62 = trunc i8 %73 to i1
  br i1 %tobool62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.then61
  %74 = load i8*, i8** %stype, align 8
  store i8 2, i8* %74, align 1
  br label %if.end64

if.end64:                                         ; preds = %if.then63, %if.then61
  br label %mark

if.end65:                                         ; preds = %if.end57
  %75 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack66 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %75, i32 0, i32 11
  %76 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack66, align 8
  %77 = load i32, i32* %spi, align 4
  %idxprom67 = sext i32 %77 to i64
  %arrayidx68 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %76, i64 %idxprom67
  %call69 = call zeroext i1 @is_spilled_reg(%struct.bpf_stack_state* noundef %arrayidx68) #20
  br i1 %call69, label %land.lhs.true71, label %if.end80

land.lhs.true71:                                  ; preds = %if.end65
  %78 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack72 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %78, i32 0, i32 11
  %79 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack72, align 8
  %80 = load i32, i32* %spi, align 4
  %idxprom73 = sext i32 %80 to i64
  %arrayidx74 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %79, i64 %idxprom73
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx74, i32 0, i32 0
  %type75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 0
  %81 = load i32, i32* %type75, align 8
  %call76 = call i32 @base_type(i32 noundef %81) #20
  %cmp77 = icmp eq i32 %call76, 16
  br i1 %cmp77, label %if.then79, label %if.end80

if.then79:                                        ; preds = %land.lhs.true71
  br label %mark

if.end80:                                         ; preds = %land.lhs.true71, %if.end65
  %82 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack81 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %82, i32 0, i32 11
  %83 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack81, align 8
  %84 = load i32, i32* %spi, align 4
  %idxprom82 = sext i32 %84 to i64
  %arrayidx83 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %83, i64 %idxprom82
  %call84 = call zeroext i1 @is_spilled_reg(%struct.bpf_stack_state* noundef %arrayidx83) #20
  br i1 %call84, label %land.lhs.true86, label %if.end114

land.lhs.true86:                                  ; preds = %if.end80
  %85 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack87 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %85, i32 0, i32 11
  %86 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack87, align 8
  %87 = load i32, i32* %spi, align 4
  %idxprom88 = sext i32 %87 to i64
  %arrayidx89 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %86, i64 %idxprom88
  %spilled_ptr90 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx89, i32 0, i32 0
  %type91 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr90, i32 0, i32 0
  %88 = load i32, i32* %type91, align 8
  %cmp92 = icmp eq i32 %88, 1
  br i1 %cmp92, label %if.then96, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true86
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %89, i32 0, i32 17
  %90 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool94 = trunc i8 %90 to i1
  br i1 %tobool94, label %if.then96, label %if.end114

if.then96:                                        ; preds = %lor.lhs.false, %land.lhs.true86
  %91 = load i8, i8* %clobber, align 1
  %tobool97 = trunc i8 %91 to i1
  br i1 %tobool97, label %if.then98, label %if.end113

if.then98:                                        ; preds = %if.then96
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %93 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack99 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %93, i32 0, i32 11
  %94 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack99, align 8
  %95 = load i32, i32* %spi, align 4
  %idxprom100 = sext i32 %95 to i64
  %arrayidx101 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %94, i64 %idxprom100
  %spilled_ptr102 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx101, i32 0, i32 0
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %92, %struct.bpf_reg_state* noundef %spilled_ptr102) #20
  store i32 0, i32* %j, align 4
  br label %for.cond103

for.cond103:                                      ; preds = %for.inc, %if.then98
  %96 = load i32, i32* %j, align 4
  %cmp104 = icmp slt i32 %96, 8
  br i1 %cmp104, label %for.body106, label %for.end

for.body106:                                      ; preds = %for.cond103
  %97 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack107 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %97, i32 0, i32 11
  %98 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack107, align 8
  %99 = load i32, i32* %spi, align 4
  %idxprom108 = sext i32 %99 to i64
  %arrayidx109 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %98, i64 %idxprom108
  %slot_type110 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx109, i32 0, i32 1
  %100 = load i32, i32* %j, align 4
  %idxprom111 = sext i32 %100 to i64
  %arrayidx112 = getelementptr [8 x i8], [8 x i8]* %slot_type110, i64 0, i64 %idxprom111
  call void @scrub_spilled_slot(i8* noundef %arrayidx112) #20
  br label %for.inc

for.inc:                                          ; preds = %for.body106
  %101 = load i32, i32* %j, align 4
  %inc = add i32 %101, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond103, !llvm.loop !62

for.end:                                          ; preds = %for.cond103
  br label %if.end113

if.end113:                                        ; preds = %for.end, %if.then96
  br label %mark

if.end114:                                        ; preds = %lor.lhs.false, %if.end80
  br label %err115

err115:                                           ; preds = %if.end114, %if.then49
  %102 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off116 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %102, i32 0, i32 5
  %103 = bitcast %struct.tnum* %var_off116 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = load i64, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = load i64, i64* %106, align 8
  %call117 = call zeroext i1 @tnum_is_const(i64 %105, i64 %107) #20
  br i1 %call117, label %if.then118, label %if.else120

if.then118:                                       ; preds = %err115
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %109 = bitcast %struct.bpf_verifier_env* %108 to i8*
  %110 = load i8*, i8** %err_extra, align 8
  %111 = load i32, i32* %regno.addr, align 4
  %112 = load i32, i32* %min_off, align 4
  %113 = load i32, i32* %i, align 4
  %114 = load i32, i32* %min_off, align 4
  %sub119 = sub i32 %113, %114
  %115 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %109, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.141, i64 0, i64 0), i8* noundef %110, i32 noundef %111, i32 noundef %112, i32 noundef %sub119, i32 noundef %115) #20
  br label %if.end127

if.else120:                                       ; preds = %err115
  %arraydecay122 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf121, i64 0, i64 0
  %116 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off123 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %116, i32 0, i32 5
  %117 = bitcast %struct.tnum* %var_off123 to { i64, i64 }*
  %118 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %117, i32 0, i32 0
  %119 = load i64, i64* %118, align 8
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %117, i32 0, i32 1
  %121 = load i64, i64* %120, align 8
  %call124 = call i32 @tnum_strn(i8* noundef %arraydecay122, i64 noundef 48, i64 %119, i64 %121) #20
  %122 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %123 = bitcast %struct.bpf_verifier_env* %122 to i8*
  %124 = load i8*, i8** %err_extra, align 8
  %125 = load i32, i32* %regno.addr, align 4
  %arraydecay125 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf121, i64 0, i64 0
  %126 = load i32, i32* %i, align 4
  %127 = load i32, i32* %min_off, align 4
  %sub126 = sub i32 %126, %127
  %128 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %123, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.142, i64 0, i64 0), i8* noundef %124, i32 noundef %125, i8* noundef %arraydecay125, i32 noundef %sub126, i32 noundef %128) #20
  br label %if.end127

if.end127:                                        ; preds = %if.else120, %if.then118
  store i32 -13, i32* %retval, align 4
  br label %return

mark:                                             ; preds = %if.end113, %if.then79, %if.end64, %if.then56
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %130 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack128 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %130, i32 0, i32 11
  %131 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack128, align 8
  %132 = load i32, i32* %spi, align 4
  %idxprom129 = sext i32 %132 to i64
  %arrayidx130 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %131, i64 %idxprom129
  %spilled_ptr131 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx130, i32 0, i32 0
  %133 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack132 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %133, i32 0, i32 11
  %134 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack132, align 8
  %135 = load i32, i32* %spi, align 4
  %idxprom133 = sext i32 %135 to i64
  %arrayidx134 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %134, i64 %idxprom133
  %spilled_ptr135 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx134, i32 0, i32 0
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr135, i32 0, i32 14
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %call136 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %129, %struct.bpf_reg_state* noundef %spilled_ptr131, %struct.bpf_reg_state* noundef %136, i8 noundef zeroext 2) #20
  br label %for.inc137

for.inc137:                                       ; preds = %mark
  %137 = load i32, i32* %i, align 4
  %inc138 = add i32 %137, 1
  store i32 %inc138, i32* %i, align 4
  br label %for.cond, !llvm.loop !63

for.end139:                                       ; preds = %for.cond
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %139 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %140 = load i32, i32* %min_off, align 4
  %call140 = call i32 @update_stack_depth(%struct.bpf_verifier_env* noundef %138, %struct.bpf_func_state* noundef %139, i32 noundef %140) #20
  store i32 %call140, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end139, %if.end127, %if.then39, %if.then16, %if.then8, %if.then
  %141 = load i32, i32* %retval, align 4
  ret i32 %141
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_mem_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %regno, i32 noundef %off, i32 noundef %bpf_size, i32 noundef %t, i32 noundef %value_regno, i1 noundef zeroext %strict_alignment_once) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %bpf_size.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %strict_alignment_once.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %size = alloca i32, align 4
  %err = alloca i32, align 4
  %bytes = alloca i32, align 4
  %tmp = alloca i32, align 4
  %kptr_off_desc = alloca %struct.bpf_map_value_off_desc*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %map_off = alloca i32, align 4
  %val = alloca i64, align 8
  %rdonly_mem = alloca i8, align 1
  %reg_type = alloca i32, align 4
  %btf = alloca %struct.btf*, align 8
  %btf_id = alloca i32, align 4
  %rdonly_mem328 = alloca i8, align 1
  %max_access = alloca i32*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %bpf_size, i32* %bpf_size.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  %frombool = zext i1 %strict_alignment_once to i8
  store i8 %frombool, i8* %strict_alignment_once.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %2 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  store i32 0, i32* %err, align 4
  store i32 -22, i32* %bytes, align 4
  %3 = load i32, i32* %bpf_size.addr, align 4
  %cmp = icmp eq i32 %3, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %bytes, align 4
  br label %if.end11

if.else:                                          ; preds = %entry
  %4 = load i32, i32* %bpf_size.addr, align 4
  %cmp1 = icmp eq i32 %4, 8
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  store i32 2, i32* %bytes, align 4
  br label %if.end10

if.else3:                                         ; preds = %if.else
  %5 = load i32, i32* %bpf_size.addr, align 4
  %cmp4 = icmp eq i32 %5, 0
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else3
  store i32 4, i32* %bytes, align 4
  br label %if.end9

if.else6:                                         ; preds = %if.else3
  %6 = load i32, i32* %bpf_size.addr, align 4
  %cmp7 = icmp eq i32 %6, 24
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else6
  store i32 8, i32* %bytes, align 4
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.else6
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then5
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.then2
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then
  %7 = load i32, i32* %bytes, align 4
  store i32 %7, i32* %tmp, align 4
  %8 = load i32, i32* %tmp, align 4
  store i32 %8, i32* %size, align 4
  %9 = load i32, i32* %size, align 4
  %cmp12 = icmp slt i32 %9, 0
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  %10 = load i32, i32* %size, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end11
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size, align 4
  %15 = load i8, i8* %strict_alignment_once.addr, align 1
  %tobool = trunc i8 %15 to i1
  %call15 = call i32 @check_ptr_alignment(%struct.bpf_verifier_env* noundef %11, %struct.bpf_reg_state* noundef %12, i32 noundef %13, i32 noundef %14, i1 noundef zeroext %tobool) #20
  store i32 %call15, i32* %err, align 4
  %16 = load i32, i32* %err, align 4
  %tobool16 = icmp ne i32 %16, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  %17 = load i32, i32* %err, align 4
  store i32 %17, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end14
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 1
  %19 = load i32, i32* %off19, align 4
  %20 = load i32, i32* %off.addr, align 4
  %add = add i32 %20, %19
  store i32 %add, i32* %off.addr, align 4
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  %22 = load i32, i32* %type, align 8
  %cmp20 = icmp eq i32 %22, 5
  br i1 %cmp20, label %if.then21, label %if.else32

if.then21:                                        ; preds = %if.end18
  %23 = load i32, i32* %t.addr, align 4
  %cmp22 = icmp eq i32 %23, 2
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.then21
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  %26 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.150, i64 0, i64 0), i32 noundef %26) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.then21
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load i32, i32* %regno.addr, align 4
  %29 = load i32, i32* %off.addr, align 4
  %30 = load i32, i32* %size, align 4
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %32 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 2
  %33 = bitcast %union.anon.168* %32 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %33, i32 0, i32 0
  %34 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %key_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %34, i32 0, i32 4
  %35 = load i32, i32* %key_size, align 4
  %call25 = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %27, i32 noundef %28, i32 noundef %29, i32 noundef %30, i32 noundef %35, i1 noundef zeroext false) #20
  store i32 %call25, i32* %err, align 4
  %36 = load i32, i32* %err, align 4
  %tobool26 = icmp ne i32 %36, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end24
  %37 = load i32, i32* %err, align 4
  store i32 %37, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end24
  %38 = load i32, i32* %value_regno.addr, align 4
  %cmp29 = icmp sge i32 %38, 0
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end28
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %41 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %39, %struct.bpf_reg_state* noundef %40, i32 noundef %41) #20
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %if.end28
  br label %if.end371

if.else32:                                        ; preds = %if.end18
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 0
  %43 = load i32, i32* %type33, align 8
  %cmp34 = icmp eq i32 %43, 4
  br i1 %cmp34, label %if.then35, label %if.else94

if.then35:                                        ; preds = %if.else32
  store %struct.bpf_map_value_off_desc* null, %struct.bpf_map_value_off_desc** %kptr_off_desc, align 8
  %44 = load i32, i32* %t.addr, align 4
  %cmp36 = icmp eq i32 %44, 2
  br i1 %cmp36, label %land.lhs.true, label %if.end41

land.lhs.true:                                    ; preds = %if.then35
  %45 = load i32, i32* %value_regno.addr, align 4
  %cmp37 = icmp sge i32 %45, 0
  br i1 %cmp37, label %land.lhs.true38, label %if.end41

land.lhs.true38:                                  ; preds = %land.lhs.true
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = load i32, i32* %value_regno.addr, align 4
  %call39 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %46, i32 noundef %47) #20
  br i1 %call39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %land.lhs.true38
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = bitcast %struct.bpf_verifier_env* %48 to i8*
  %50 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %49, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.151, i64 0, i64 0), i32 noundef %50) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %land.lhs.true38, %land.lhs.true, %if.then35
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = load i32, i32* %regno.addr, align 4
  %53 = load i32, i32* %off.addr, align 4
  %54 = load i32, i32* %size, align 4
  %55 = load i32, i32* %t.addr, align 4
  %call42 = call i32 @check_map_access_type(%struct.bpf_verifier_env* noundef %51, i32 noundef %52, i32 noundef %53, i32 noundef %54, i32 noundef %55) #20
  store i32 %call42, i32* %err, align 4
  %56 = load i32, i32* %err, align 4
  %tobool43 = icmp ne i32 %56, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end41
  %57 = load i32, i32* %err, align 4
  store i32 %57, i32* %retval, align 4
  br label %return

if.end45:                                         ; preds = %if.end41
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = load i32, i32* %regno.addr, align 4
  %60 = load i32, i32* %off.addr, align 4
  %61 = load i32, i32* %size, align 4
  %call46 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %58, i32 noundef %59, i32 noundef %60, i32 noundef %61, i1 noundef zeroext false, i32 noundef 1) #20
  store i32 %call46, i32* %err, align 4
  %62 = load i32, i32* %err, align 4
  %tobool47 = icmp ne i32 %62, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.end45
  %63 = load i32, i32* %err, align 4
  store i32 %63, i32* %retval, align 4
  br label %return

if.end49:                                         ; preds = %if.end45
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %64, i32 0, i32 5
  %65 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %66 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %65, i32 0, i32 0
  %67 = load i64, i64* %66, align 8
  %68 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %65, i32 0, i32 1
  %69 = load i64, i64* %68, align 8
  %call50 = call zeroext i1 @tnum_is_const(i64 %67, i64 %69) #20
  br i1 %call50, label %if.then51, label %if.end57

if.then51:                                        ; preds = %if.end49
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 2
  %72 = bitcast %union.anon.168* %71 to %struct.anon.169*
  %map_ptr52 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %72, i32 0, i32 0
  %73 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr52, align 8
  %74 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %74 to i64
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %75, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off53, i32 0, i32 0
  %76 = load i64, i64* %value, align 8
  %add54 = add i64 %conv, %76
  %conv55 = trunc i64 %add54 to i32
  %call56 = call %struct.bpf_map_value_off_desc* @bpf_map_kptr_off_contains(%struct.bpf_map* noundef %73, i32 noundef %conv55) #20
  store %struct.bpf_map_value_off_desc* %call56, %struct.bpf_map_value_off_desc** %kptr_off_desc, align 8
  br label %if.end57

if.end57:                                         ; preds = %if.then51, %if.end49
  %77 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %kptr_off_desc, align 8
  %tobool58 = icmp ne %struct.bpf_map_value_off_desc* %77, null
  br i1 %tobool58, label %if.then59, label %if.else61

if.then59:                                        ; preds = %if.end57
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %79 = load i32, i32* %regno.addr, align 4
  %80 = load i32, i32* %value_regno.addr, align 4
  %81 = load i32, i32* %insn_idx.addr, align 4
  %82 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %kptr_off_desc, align 8
  %call60 = call i32 @check_map_kptr_access(%struct.bpf_verifier_env* noundef %78, i32 noundef %79, i32 noundef %80, i32 noundef %81, %struct.bpf_map_value_off_desc* noundef %82) #20
  store i32 %call60, i32* %err, align 4
  br label %if.end93

if.else61:                                        ; preds = %if.end57
  %83 = load i32, i32* %t.addr, align 4
  %cmp62 = icmp eq i32 %83, 1
  br i1 %cmp62, label %land.lhs.true64, label %if.end92

land.lhs.true64:                                  ; preds = %if.else61
  %84 = load i32, i32* %value_regno.addr, align 4
  %cmp65 = icmp sge i32 %84, 0
  br i1 %cmp65, label %if.then67, label %if.end92

if.then67:                                        ; preds = %land.lhs.true64
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %85, i32 0, i32 2
  %87 = bitcast %union.anon.168* %86 to %struct.anon.169*
  %map_ptr68 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %87, i32 0, i32 0
  %88 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr68, align 8
  store %struct.bpf_map* %88, %struct.bpf_map** %map, align 8
  %89 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off69 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %89, i32 0, i32 5
  %90 = bitcast %struct.tnum* %var_off69 to { i64, i64 }*
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %90, i32 0, i32 0
  %92 = load i64, i64* %91, align 8
  %93 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %90, i32 0, i32 1
  %94 = load i64, i64* %93, align 8
  %call70 = call zeroext i1 @tnum_is_const(i64 %92, i64 %94) #20
  br i1 %call70, label %land.lhs.true72, label %if.else90

land.lhs.true72:                                  ; preds = %if.then67
  %95 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call73 = call zeroext i1 @bpf_map_is_rdonly(%struct.bpf_map* noundef %95) #20
  br i1 %call73, label %land.lhs.true75, label %if.else90

land.lhs.true75:                                  ; preds = %land.lhs.true72
  %96 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %96, i32 0, i32 0
  %97 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %97, i32 0, i32 28
  %98 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %tobool76 = icmp ne i32 (%struct.bpf_map*, i64*, i32)* %98, null
  br i1 %tobool76, label %if.then77, label %if.else90

if.then77:                                        ; preds = %land.lhs.true75
  %99 = load i32, i32* %off.addr, align 4
  %conv78 = sext i32 %99 to i64
  %100 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off79 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %100, i32 0, i32 5
  %value80 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off79, i32 0, i32 0
  %101 = load i64, i64* %value80, align 8
  %add81 = add i64 %conv78, %101
  %conv82 = trunc i64 %add81 to i32
  store i32 %conv82, i32* %map_off, align 4
  store i64 0, i64* %val, align 8
  %102 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %103 = load i32, i32* %map_off, align 4
  %104 = load i32, i32* %size, align 4
  %call83 = call i32 @bpf_map_direct_read(%struct.bpf_map* noundef %102, i32 noundef %103, i32 noundef %104, i64* noundef %val) #20
  store i32 %call83, i32* %err, align 4
  %105 = load i32, i32* %err, align 4
  %tobool84 = icmp ne i32 %105, 0
  br i1 %tobool84, label %if.then85, label %if.end86

if.then85:                                        ; preds = %if.then77
  %106 = load i32, i32* %err, align 4
  store i32 %106, i32* %retval, align 4
  br label %return

if.end86:                                         ; preds = %if.then77
  %107 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %108 = load i32, i32* %value_regno.addr, align 4
  %idxprom = sext i32 %108 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %107, i64 %idxprom
  %type87 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  store i32 1, i32* %type87, align 8
  %109 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %110 = load i32, i32* %value_regno.addr, align 4
  %idxprom88 = sext i32 %110 to i64
  %arrayidx89 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %109, i64 %idxprom88
  %111 = load i64, i64* %val, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %arrayidx89, i64 noundef %111) #20
  br label %if.end91

if.else90:                                        ; preds = %land.lhs.true75, %land.lhs.true72, %if.then67
  %112 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %113 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %114 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %112, %struct.bpf_reg_state* noundef %113, i32 noundef %114) #20
  br label %if.end91

if.end91:                                         ; preds = %if.else90, %if.end86
  br label %if.end92

if.end92:                                         ; preds = %if.end91, %land.lhs.true64, %if.else61
  br label %if.end93

if.end93:                                         ; preds = %if.end92, %if.then59
  br label %if.end370

if.else94:                                        ; preds = %if.else32
  %115 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %115, i32 0, i32 0
  %116 = load i32, i32* %type95, align 8
  %call96 = call i32 @base_type(i32 noundef %116) #20
  %cmp97 = icmp eq i32 %call96, 17
  br i1 %cmp97, label %if.then99, label %if.else140

if.then99:                                        ; preds = %if.else94
  %117 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type100 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %117, i32 0, i32 0
  %118 = load i32, i32* %type100, align 8
  %call101 = call zeroext i1 @type_is_rdonly_mem(i32 noundef %118) #20
  %frombool102 = zext i1 %call101 to i8
  store i8 %frombool102, i8* %rdonly_mem, align 1
  %119 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %119, i32 0, i32 0
  %120 = load i32, i32* %type103, align 8
  %call104 = call zeroext i1 @type_may_be_null(i32 noundef %120) #20
  br i1 %call104, label %if.then105, label %if.end108

if.then105:                                       ; preds = %if.then99
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %122 = bitcast %struct.bpf_verifier_env* %121 to i8*
  %123 = load i32, i32* %regno.addr, align 4
  %124 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %125 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type106 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %125, i32 0, i32 0
  %126 = load i32, i32* %type106, align 8
  %call107 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %124, i32 noundef %126) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %122, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.152, i64 0, i64 0), i32 noundef %123, i8* noundef %call107) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end108:                                        ; preds = %if.then99
  %127 = load i32, i32* %t.addr, align 4
  %cmp109 = icmp eq i32 %127, 2
  br i1 %cmp109, label %land.lhs.true111, label %if.end117

land.lhs.true111:                                 ; preds = %if.end108
  %128 = load i8, i8* %rdonly_mem, align 1
  %tobool112 = trunc i8 %128 to i1
  br i1 %tobool112, label %if.then114, label %if.end117

if.then114:                                       ; preds = %land.lhs.true111
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %130 = bitcast %struct.bpf_verifier_env* %129 to i8*
  %131 = load i32, i32* %regno.addr, align 4
  %132 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %133 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type115 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %133, i32 0, i32 0
  %134 = load i32, i32* %type115, align 8
  %call116 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %132, i32 noundef %134) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %130, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.114, i64 0, i64 0), i32 noundef %131, i8* noundef %call116) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end117:                                        ; preds = %land.lhs.true111, %if.end108
  %135 = load i32, i32* %t.addr, align 4
  %cmp118 = icmp eq i32 %135, 2
  br i1 %cmp118, label %land.lhs.true120, label %if.end127

land.lhs.true120:                                 ; preds = %if.end117
  %136 = load i32, i32* %value_regno.addr, align 4
  %cmp121 = icmp sge i32 %136, 0
  br i1 %cmp121, label %land.lhs.true123, label %if.end127

land.lhs.true123:                                 ; preds = %land.lhs.true120
  %137 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %138 = load i32, i32* %value_regno.addr, align 4
  %call124 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %137, i32 noundef %138) #20
  br i1 %call124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %land.lhs.true123
  %139 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %140 = bitcast %struct.bpf_verifier_env* %139 to i8*
  %141 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %140, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.153, i64 0, i64 0), i32 noundef %141) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end127:                                        ; preds = %land.lhs.true123, %land.lhs.true120, %if.end117
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %143 = load i32, i32* %regno.addr, align 4
  %144 = load i32, i32* %off.addr, align 4
  %145 = load i32, i32* %size, align 4
  %146 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %147 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %146, i32 0, i32 2
  %mem_size = bitcast %union.anon.168* %147 to i32*
  %148 = load i32, i32* %mem_size, align 8
  %call128 = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %142, i32 noundef %143, i32 noundef %144, i32 noundef %145, i32 noundef %148, i1 noundef zeroext false) #20
  store i32 %call128, i32* %err, align 4
  %149 = load i32, i32* %err, align 4
  %tobool129 = icmp ne i32 %149, 0
  br i1 %tobool129, label %if.end139, label %land.lhs.true130

land.lhs.true130:                                 ; preds = %if.end127
  %150 = load i32, i32* %value_regno.addr, align 4
  %cmp131 = icmp sge i32 %150, 0
  br i1 %cmp131, label %land.lhs.true133, label %if.end139

land.lhs.true133:                                 ; preds = %land.lhs.true130
  %151 = load i32, i32* %t.addr, align 4
  %cmp134 = icmp eq i32 %151, 1
  br i1 %cmp134, label %if.then138, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true133
  %152 = load i8, i8* %rdonly_mem, align 1
  %tobool136 = trunc i8 %152 to i1
  br i1 %tobool136, label %if.then138, label %if.end139

if.then138:                                       ; preds = %lor.lhs.false, %land.lhs.true133
  %153 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %155 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %153, %struct.bpf_reg_state* noundef %154, i32 noundef %155) #20
  br label %if.end139

if.end139:                                        ; preds = %if.then138, %lor.lhs.false, %land.lhs.true130, %if.end127
  br label %if.end369

if.else140:                                       ; preds = %if.else94
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type141 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i32 0, i32 0
  %157 = load i32, i32* %type141, align 8
  %cmp142 = icmp eq i32 %157, 2
  br i1 %cmp142, label %if.then144, label %if.else199

if.then144:                                       ; preds = %if.else140
  store i32 1, i32* %reg_type, align 4
  store %struct.btf* null, %struct.btf** %btf, align 8
  store i32 0, i32* %btf_id, align 4
  %158 = load i32, i32* %t.addr, align 4
  %cmp145 = icmp eq i32 %158, 2
  br i1 %cmp145, label %land.lhs.true147, label %if.end154

land.lhs.true147:                                 ; preds = %if.then144
  %159 = load i32, i32* %value_regno.addr, align 4
  %cmp148 = icmp sge i32 %159, 0
  br i1 %cmp148, label %land.lhs.true150, label %if.end154

land.lhs.true150:                                 ; preds = %land.lhs.true147
  %160 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %161 = load i32, i32* %value_regno.addr, align 4
  %call151 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %160, i32 noundef %161) #20
  br i1 %call151, label %if.then153, label %if.end154

if.then153:                                       ; preds = %land.lhs.true150
  %162 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %163 = bitcast %struct.bpf_verifier_env* %162 to i8*
  %164 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %163, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.154, i64 0, i64 0), i32 noundef %164) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end154:                                        ; preds = %land.lhs.true150, %land.lhs.true147, %if.then144
  %165 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %167 = load i32, i32* %regno.addr, align 4
  %call155 = call i32 @check_ptr_off_reg(%struct.bpf_verifier_env* noundef %165, %struct.bpf_reg_state* noundef %166, i32 noundef %167) #20
  store i32 %call155, i32* %err, align 4
  %168 = load i32, i32* %err, align 4
  %cmp156 = icmp slt i32 %168, 0
  br i1 %cmp156, label %if.then158, label %if.end159

if.then158:                                       ; preds = %if.end154
  %169 = load i32, i32* %err, align 4
  store i32 %169, i32* %retval, align 4
  br label %return

if.end159:                                        ; preds = %if.end154
  %170 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %171 = load i32, i32* %insn_idx.addr, align 4
  %172 = load i32, i32* %off.addr, align 4
  %173 = load i32, i32* %size, align 4
  %174 = load i32, i32* %t.addr, align 4
  %call160 = call i32 @check_ctx_access(%struct.bpf_verifier_env* noundef %170, i32 noundef %171, i32 noundef %172, i32 noundef %173, i32 noundef %174, i32* noundef %reg_type, %struct.btf** noundef %btf, i32* noundef %btf_id) #20
  store i32 %call160, i32* %err, align 4
  %175 = load i32, i32* %err, align 4
  %tobool161 = icmp ne i32 %175, 0
  br i1 %tobool161, label %if.then162, label %if.end163

if.then162:                                       ; preds = %if.end159
  %176 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %177 = load i32, i32* %insn_idx.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %176, i32 noundef %177, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.155, i64 0, i64 0)) #20
  br label %if.end163

if.end163:                                        ; preds = %if.then162, %if.end159
  %178 = load i32, i32* %err, align 4
  %tobool164 = icmp ne i32 %178, 0
  br i1 %tobool164, label %if.end198, label %land.lhs.true165

land.lhs.true165:                                 ; preds = %if.end163
  %179 = load i32, i32* %t.addr, align 4
  %cmp166 = icmp eq i32 %179, 1
  br i1 %cmp166, label %land.lhs.true168, label %if.end198

land.lhs.true168:                                 ; preds = %land.lhs.true165
  %180 = load i32, i32* %value_regno.addr, align 4
  %cmp169 = icmp sge i32 %180, 0
  br i1 %cmp169, label %if.then171, label %if.end198

if.then171:                                       ; preds = %land.lhs.true168
  %181 = load i32, i32* %reg_type, align 4
  %cmp172 = icmp eq i32 %181, 1
  br i1 %cmp172, label %if.then174, label %if.else175

if.then174:                                       ; preds = %if.then171
  %182 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %183 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %184 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %182, %struct.bpf_reg_state* noundef %183, i32 noundef %184) #20
  br label %if.end194

if.else175:                                       ; preds = %if.then171
  %185 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %186 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %187 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %185, %struct.bpf_reg_state* noundef %186, i32 noundef %187) #20
  %188 = load i32, i32* %reg_type, align 4
  %call176 = call zeroext i1 @type_may_be_null(i32 noundef %188) #20
  br i1 %call176, label %if.then177, label %if.end180

if.then177:                                       ; preds = %if.else175
  %189 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %189, i32 0, i32 15
  %190 = load i32, i32* %id_gen, align 8
  %inc = add i32 %190, 1
  store i32 %inc, i32* %id_gen, align 8
  %191 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %192 = load i32, i32* %value_regno.addr, align 4
  %idxprom178 = sext i32 %192 to i64
  %arrayidx179 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %191, i64 %idxprom178
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx179, i32 0, i32 3
  store i32 %inc, i32* %id, align 8
  br label %if.end180

if.end180:                                        ; preds = %if.then177, %if.else175
  %193 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %194 = load i32, i32* %value_regno.addr, align 4
  %idxprom181 = sext i32 %194 to i64
  %arrayidx182 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %193, i64 %idxprom181
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx182, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  %195 = load i32, i32* %reg_type, align 4
  %call183 = call i32 @base_type(i32 noundef %195) #20
  %cmp184 = icmp eq i32 %call183, 16
  br i1 %cmp184, label %if.then186, label %if.end193

if.then186:                                       ; preds = %if.end180
  %196 = load %struct.btf*, %struct.btf** %btf, align 8
  %197 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %198 = load i32, i32* %value_regno.addr, align 4
  %idxprom187 = sext i32 %198 to i64
  %arrayidx188 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %197, i64 %idxprom187
  %199 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx188, i32 0, i32 2
  %200 = bitcast %union.anon.168* %199 to %struct.anon.170*
  %btf189 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %200, i32 0, i32 0
  store %struct.btf* %196, %struct.btf** %btf189, align 8
  %201 = load i32, i32* %btf_id, align 4
  %202 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %203 = load i32, i32* %value_regno.addr, align 4
  %idxprom190 = sext i32 %203 to i64
  %arrayidx191 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %202, i64 %idxprom190
  %204 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx191, i32 0, i32 2
  %205 = bitcast %union.anon.168* %204 to %struct.anon.170*
  %btf_id192 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %205, i32 0, i32 1
  store i32 %201, i32* %btf_id192, align 8
  br label %if.end193

if.end193:                                        ; preds = %if.then186, %if.end180
  br label %if.end194

if.end194:                                        ; preds = %if.end193, %if.then174
  %206 = load i32, i32* %reg_type, align 4
  %207 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %208 = load i32, i32* %value_regno.addr, align 4
  %idxprom195 = sext i32 %208 to i64
  %arrayidx196 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %207, i64 %idxprom195
  %type197 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx196, i32 0, i32 0
  store i32 %206, i32* %type197, align 8
  br label %if.end198

if.end198:                                        ; preds = %if.end194, %land.lhs.true168, %land.lhs.true165, %if.end163
  br label %if.end368

if.else199:                                       ; preds = %if.else140
  %209 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type200 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %209, i32 0, i32 0
  %210 = load i32, i32* %type200, align 8
  %cmp201 = icmp eq i32 %210, 6
  br i1 %cmp201, label %if.then203, label %if.else220

if.then203:                                       ; preds = %if.else199
  %211 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %212 = load i32, i32* %regno.addr, align 4
  %213 = load i32, i32* %off.addr, align 4
  %214 = load i32, i32* %size, align 4
  %215 = load i32, i32* %t.addr, align 4
  %call204 = call i32 @check_stack_access_within_bounds(%struct.bpf_verifier_env* noundef %211, i32 noundef %212, i32 noundef %213, i32 noundef %214, i32 noundef 1, i32 noundef %215) #20
  store i32 %call204, i32* %err, align 4
  %216 = load i32, i32* %err, align 4
  %tobool205 = icmp ne i32 %216, 0
  br i1 %tobool205, label %if.then206, label %if.end207

if.then206:                                       ; preds = %if.then203
  %217 = load i32, i32* %err, align 4
  store i32 %217, i32* %retval, align 4
  br label %return

if.end207:                                        ; preds = %if.then203
  %218 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %219 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call208 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %218, %struct.bpf_reg_state* noundef %219) #20
  store %struct.bpf_func_state* %call208, %struct.bpf_func_state** %state, align 8
  %220 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %221 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %222 = load i32, i32* %off.addr, align 4
  %call209 = call i32 @update_stack_depth(%struct.bpf_verifier_env* noundef %220, %struct.bpf_func_state* noundef %221, i32 noundef %222) #20
  store i32 %call209, i32* %err, align 4
  %223 = load i32, i32* %err, align 4
  %tobool210 = icmp ne i32 %223, 0
  br i1 %tobool210, label %if.then211, label %if.end212

if.then211:                                       ; preds = %if.end207
  %224 = load i32, i32* %err, align 4
  store i32 %224, i32* %retval, align 4
  br label %return

if.end212:                                        ; preds = %if.end207
  %225 = load i32, i32* %t.addr, align 4
  %cmp213 = icmp eq i32 %225, 1
  br i1 %cmp213, label %if.then215, label %if.else217

if.then215:                                       ; preds = %if.end212
  %226 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %227 = load i32, i32* %regno.addr, align 4
  %228 = load i32, i32* %off.addr, align 4
  %229 = load i32, i32* %size, align 4
  %230 = load i32, i32* %value_regno.addr, align 4
  %call216 = call i32 @check_stack_read(%struct.bpf_verifier_env* noundef %226, i32 noundef %227, i32 noundef %228, i32 noundef %229, i32 noundef %230) #20
  store i32 %call216, i32* %err, align 4
  br label %if.end219

if.else217:                                       ; preds = %if.end212
  %231 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %232 = load i32, i32* %regno.addr, align 4
  %233 = load i32, i32* %off.addr, align 4
  %234 = load i32, i32* %size, align 4
  %235 = load i32, i32* %value_regno.addr, align 4
  %236 = load i32, i32* %insn_idx.addr, align 4
  %call218 = call i32 @check_stack_write(%struct.bpf_verifier_env* noundef %231, i32 noundef %232, i32 noundef %233, i32 noundef %234, i32 noundef %235, i32 noundef %236) #20
  store i32 %call218, i32* %err, align 4
  br label %if.end219

if.end219:                                        ; preds = %if.else217, %if.then215
  br label %if.end367

if.else220:                                       ; preds = %if.else199
  %237 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call221 = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %237) #20
  br i1 %call221, label %if.then222, label %if.else249

if.then222:                                       ; preds = %if.else220
  %238 = load i32, i32* %t.addr, align 4
  %cmp223 = icmp eq i32 %238, 2
  br i1 %cmp223, label %land.lhs.true225, label %if.end228

land.lhs.true225:                                 ; preds = %if.then222
  %239 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %240 = load i32, i32* %t.addr, align 4
  %call226 = call zeroext i1 @may_access_direct_pkt_data(%struct.bpf_verifier_env* noundef %239, %struct.bpf_call_arg_meta* noundef null, i32 noundef %240) #20
  br i1 %call226, label %if.end228, label %if.then227

if.then227:                                       ; preds = %land.lhs.true225
  %241 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %242 = bitcast %struct.bpf_verifier_env* %241 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %242, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.156, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end228:                                        ; preds = %land.lhs.true225, %if.then222
  %243 = load i32, i32* %t.addr, align 4
  %cmp229 = icmp eq i32 %243, 2
  br i1 %cmp229, label %land.lhs.true231, label %if.end238

land.lhs.true231:                                 ; preds = %if.end228
  %244 = load i32, i32* %value_regno.addr, align 4
  %cmp232 = icmp sge i32 %244, 0
  br i1 %cmp232, label %land.lhs.true234, label %if.end238

land.lhs.true234:                                 ; preds = %land.lhs.true231
  %245 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %246 = load i32, i32* %value_regno.addr, align 4
  %call235 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %245, i32 noundef %246) #20
  br i1 %call235, label %if.then237, label %if.end238

if.then237:                                       ; preds = %land.lhs.true234
  %247 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %248 = bitcast %struct.bpf_verifier_env* %247 to i8*
  %249 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %248, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.157, i64 0, i64 0), i32 noundef %249) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end238:                                        ; preds = %land.lhs.true234, %land.lhs.true231, %if.end228
  %250 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %251 = load i32, i32* %regno.addr, align 4
  %252 = load i32, i32* %off.addr, align 4
  %253 = load i32, i32* %size, align 4
  %call239 = call i32 @check_packet_access(%struct.bpf_verifier_env* noundef %250, i32 noundef %251, i32 noundef %252, i32 noundef %253, i1 noundef zeroext false) #20
  store i32 %call239, i32* %err, align 4
  %254 = load i32, i32* %err, align 4
  %tobool240 = icmp ne i32 %254, 0
  br i1 %tobool240, label %if.end248, label %land.lhs.true241

land.lhs.true241:                                 ; preds = %if.end238
  %255 = load i32, i32* %t.addr, align 4
  %cmp242 = icmp eq i32 %255, 1
  br i1 %cmp242, label %land.lhs.true244, label %if.end248

land.lhs.true244:                                 ; preds = %land.lhs.true241
  %256 = load i32, i32* %value_regno.addr, align 4
  %cmp245 = icmp sge i32 %256, 0
  br i1 %cmp245, label %if.then247, label %if.end248

if.then247:                                       ; preds = %land.lhs.true244
  %257 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %258 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %259 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %257, %struct.bpf_reg_state* noundef %258, i32 noundef %259) #20
  br label %if.end248

if.end248:                                        ; preds = %if.then247, %land.lhs.true244, %land.lhs.true241, %if.end238
  br label %if.end366

if.else249:                                       ; preds = %if.else220
  %260 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type250 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %260, i32 0, i32 0
  %261 = load i32, i32* %type250, align 8
  %cmp251 = icmp eq i32 %261, 10
  br i1 %cmp251, label %if.then253, label %if.else274

if.then253:                                       ; preds = %if.else249
  %262 = load i32, i32* %t.addr, align 4
  %cmp254 = icmp eq i32 %262, 2
  br i1 %cmp254, label %land.lhs.true256, label %if.end263

land.lhs.true256:                                 ; preds = %if.then253
  %263 = load i32, i32* %value_regno.addr, align 4
  %cmp257 = icmp sge i32 %263, 0
  br i1 %cmp257, label %land.lhs.true259, label %if.end263

land.lhs.true259:                                 ; preds = %land.lhs.true256
  %264 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %265 = load i32, i32* %value_regno.addr, align 4
  %call260 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %264, i32 noundef %265) #20
  br i1 %call260, label %if.then262, label %if.end263

if.then262:                                       ; preds = %land.lhs.true259
  %266 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %267 = bitcast %struct.bpf_verifier_env* %266 to i8*
  %268 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %267, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.158, i64 0, i64 0), i32 noundef %268) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end263:                                        ; preds = %land.lhs.true259, %land.lhs.true256, %if.then253
  %269 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %270 = load i32, i32* %off.addr, align 4
  %271 = load i32, i32* %size, align 4
  %call264 = call i32 @check_flow_keys_access(%struct.bpf_verifier_env* noundef %269, i32 noundef %270, i32 noundef %271) #20
  store i32 %call264, i32* %err, align 4
  %272 = load i32, i32* %err, align 4
  %tobool265 = icmp ne i32 %272, 0
  br i1 %tobool265, label %if.end273, label %land.lhs.true266

land.lhs.true266:                                 ; preds = %if.end263
  %273 = load i32, i32* %t.addr, align 4
  %cmp267 = icmp eq i32 %273, 1
  br i1 %cmp267, label %land.lhs.true269, label %if.end273

land.lhs.true269:                                 ; preds = %land.lhs.true266
  %274 = load i32, i32* %value_regno.addr, align 4
  %cmp270 = icmp sge i32 %274, 0
  br i1 %cmp270, label %if.then272, label %if.end273

if.then272:                                       ; preds = %land.lhs.true269
  %275 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %276 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %277 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %275, %struct.bpf_reg_state* noundef %276, i32 noundef %277) #20
  br label %if.end273

if.end273:                                        ; preds = %if.then272, %land.lhs.true269, %land.lhs.true266, %if.end263
  br label %if.end365

if.else274:                                       ; preds = %if.else249
  %278 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type275 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %278, i32 0, i32 0
  %279 = load i32, i32* %type275, align 8
  %call276 = call zeroext i1 @type_is_sk_pointer(i32 noundef %279) #20
  br i1 %call276, label %if.then277, label %if.else291

if.then277:                                       ; preds = %if.else274
  %280 = load i32, i32* %t.addr, align 4
  %cmp278 = icmp eq i32 %280, 2
  br i1 %cmp278, label %if.then280, label %if.end283

if.then280:                                       ; preds = %if.then277
  %281 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %282 = bitcast %struct.bpf_verifier_env* %281 to i8*
  %283 = load i32, i32* %regno.addr, align 4
  %284 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %285 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type281 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %285, i32 0, i32 0
  %286 = load i32, i32* %type281, align 8
  %call282 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %284, i32 noundef %286) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %282, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.114, i64 0, i64 0), i32 noundef %283, i8* noundef %call282) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end283:                                        ; preds = %if.then277
  %287 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %288 = load i32, i32* %insn_idx.addr, align 4
  %289 = load i32, i32* %regno.addr, align 4
  %290 = load i32, i32* %off.addr, align 4
  %291 = load i32, i32* %size, align 4
  %292 = load i32, i32* %t.addr, align 4
  %call284 = call i32 @check_sock_access(%struct.bpf_verifier_env* noundef %287, i32 noundef %288, i32 noundef %289, i32 noundef %290, i32 noundef %291, i32 noundef %292) #20
  store i32 %call284, i32* %err, align 4
  %293 = load i32, i32* %err, align 4
  %tobool285 = icmp ne i32 %293, 0
  br i1 %tobool285, label %if.end290, label %land.lhs.true286

land.lhs.true286:                                 ; preds = %if.end283
  %294 = load i32, i32* %value_regno.addr, align 4
  %cmp287 = icmp sge i32 %294, 0
  br i1 %cmp287, label %if.then289, label %if.end290

if.then289:                                       ; preds = %land.lhs.true286
  %295 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %296 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %297 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %295, %struct.bpf_reg_state* noundef %296, i32 noundef %297) #20
  br label %if.end290

if.end290:                                        ; preds = %if.then289, %land.lhs.true286, %if.end283
  br label %if.end364

if.else291:                                       ; preds = %if.else274
  %298 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type292 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %298, i32 0, i32 0
  %299 = load i32, i32* %type292, align 8
  %cmp293 = icmp eq i32 %299, 14
  br i1 %cmp293, label %if.then295, label %if.else306

if.then295:                                       ; preds = %if.else291
  %300 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %301 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %302 = load i32, i32* %regno.addr, align 4
  %303 = load i32, i32* %off.addr, align 4
  %304 = load i32, i32* %size, align 4
  %call296 = call i32 @check_tp_buffer_access(%struct.bpf_verifier_env* noundef %300, %struct.bpf_reg_state* noundef %301, i32 noundef %302, i32 noundef %303, i32 noundef %304) #20
  store i32 %call296, i32* %err, align 4
  %305 = load i32, i32* %err, align 4
  %tobool297 = icmp ne i32 %305, 0
  br i1 %tobool297, label %if.end305, label %land.lhs.true298

land.lhs.true298:                                 ; preds = %if.then295
  %306 = load i32, i32* %t.addr, align 4
  %cmp299 = icmp eq i32 %306, 1
  br i1 %cmp299, label %land.lhs.true301, label %if.end305

land.lhs.true301:                                 ; preds = %land.lhs.true298
  %307 = load i32, i32* %value_regno.addr, align 4
  %cmp302 = icmp sge i32 %307, 0
  br i1 %cmp302, label %if.then304, label %if.end305

if.then304:                                       ; preds = %land.lhs.true301
  %308 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %309 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %310 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %308, %struct.bpf_reg_state* noundef %309, i32 noundef %310) #20
  br label %if.end305

if.end305:                                        ; preds = %if.then304, %land.lhs.true301, %land.lhs.true298, %if.then295
  br label %if.end363

if.else306:                                       ; preds = %if.else291
  %311 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type307 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %311, i32 0, i32 0
  %312 = load i32, i32* %type307, align 8
  %call308 = call i32 @base_type(i32 noundef %312) #20
  %cmp309 = icmp eq i32 %call308, 16
  br i1 %cmp309, label %land.lhs.true311, label %if.else316

land.lhs.true311:                                 ; preds = %if.else306
  %313 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type312 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %313, i32 0, i32 0
  %314 = load i32, i32* %type312, align 8
  %call313 = call zeroext i1 @type_may_be_null(i32 noundef %314) #20
  br i1 %call313, label %if.else316, label %if.then314

if.then314:                                       ; preds = %land.lhs.true311
  %315 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %316 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %317 = load i32, i32* %regno.addr, align 4
  %318 = load i32, i32* %off.addr, align 4
  %319 = load i32, i32* %size, align 4
  %320 = load i32, i32* %t.addr, align 4
  %321 = load i32, i32* %value_regno.addr, align 4
  %call315 = call i32 @check_ptr_to_btf_access(%struct.bpf_verifier_env* noundef %315, %struct.bpf_reg_state* noundef %316, i32 noundef %317, i32 noundef %318, i32 noundef %319, i32 noundef %320, i32 noundef %321) #20
  store i32 %call315, i32* %err, align 4
  br label %if.end362

if.else316:                                       ; preds = %land.lhs.true311, %if.else306
  %322 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type317 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %322, i32 0, i32 0
  %323 = load i32, i32* %type317, align 8
  %cmp318 = icmp eq i32 %323, 3
  br i1 %cmp318, label %if.then320, label %if.else322

if.then320:                                       ; preds = %if.else316
  %324 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %325 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %326 = load i32, i32* %regno.addr, align 4
  %327 = load i32, i32* %off.addr, align 4
  %328 = load i32, i32* %size, align 4
  %329 = load i32, i32* %t.addr, align 4
  %330 = load i32, i32* %value_regno.addr, align 4
  %call321 = call i32 @check_ptr_to_map_access(%struct.bpf_verifier_env* noundef %324, %struct.bpf_reg_state* noundef %325, i32 noundef %326, i32 noundef %327, i32 noundef %328, i32 noundef %329, i32 noundef %330) #20
  store i32 %call321, i32* %err, align 4
  br label %if.end361

if.else322:                                       ; preds = %if.else316
  %331 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type323 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %331, i32 0, i32 0
  %332 = load i32, i32* %type323, align 8
  %call324 = call i32 @base_type(i32 noundef %332) #20
  %cmp325 = icmp eq i32 %call324, 18
  br i1 %cmp325, label %if.then327, label %if.else357

if.then327:                                       ; preds = %if.else322
  %333 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type329 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %333, i32 0, i32 0
  %334 = load i32, i32* %type329, align 8
  %call330 = call zeroext i1 @type_is_rdonly_mem(i32 noundef %334) #20
  %frombool331 = zext i1 %call330 to i8
  store i8 %frombool331, i8* %rdonly_mem328, align 1
  %335 = load i8, i8* %rdonly_mem328, align 1
  %tobool332 = trunc i8 %335 to i1
  br i1 %tobool332, label %if.then333, label %if.else340

if.then333:                                       ; preds = %if.then327
  %336 = load i32, i32* %t.addr, align 4
  %cmp334 = icmp eq i32 %336, 2
  br i1 %cmp334, label %if.then336, label %if.end339

if.then336:                                       ; preds = %if.then333
  %337 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %338 = bitcast %struct.bpf_verifier_env* %337 to i8*
  %339 = load i32, i32* %regno.addr, align 4
  %340 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %341 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type337 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %341, i32 0, i32 0
  %342 = load i32, i32* %type337, align 8
  %call338 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %340, i32 noundef %342) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %338, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.114, i64 0, i64 0), i32 noundef %339, i8* noundef %call338) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end339:                                        ; preds = %if.then333
  %343 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %343, i32 0, i32 2
  %344 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %344, i32 0, i32 10
  %345 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_rdonly_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %345, i32 0, i32 12
  store i32* %max_rdonly_access, i32** %max_access, align 8
  br label %if.end343

if.else340:                                       ; preds = %if.then327
  %346 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog341 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %346, i32 0, i32 2
  %347 = load %struct.bpf_prog*, %struct.bpf_prog** %prog341, align 8
  %aux342 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %347, i32 0, i32 10
  %348 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux342, align 8
  %max_rdwr_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %348, i32 0, i32 13
  store i32* %max_rdwr_access, i32** %max_access, align 8
  br label %if.end343

if.end343:                                        ; preds = %if.else340, %if.end339
  %349 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %350 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %351 = load i32, i32* %regno.addr, align 4
  %352 = load i32, i32* %off.addr, align 4
  %353 = load i32, i32* %size, align 4
  %354 = load i32*, i32** %max_access, align 8
  %call344 = call i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %349, %struct.bpf_reg_state* noundef %350, i32 noundef %351, i32 noundef %352, i32 noundef %353, i1 noundef zeroext false, i32* noundef %354) #20
  store i32 %call344, i32* %err, align 4
  %355 = load i32, i32* %err, align 4
  %tobool345 = icmp ne i32 %355, 0
  br i1 %tobool345, label %if.end356, label %land.lhs.true346

land.lhs.true346:                                 ; preds = %if.end343
  %356 = load i32, i32* %value_regno.addr, align 4
  %cmp347 = icmp sge i32 %356, 0
  br i1 %cmp347, label %land.lhs.true349, label %if.end356

land.lhs.true349:                                 ; preds = %land.lhs.true346
  %357 = load i8, i8* %rdonly_mem328, align 1
  %tobool350 = trunc i8 %357 to i1
  br i1 %tobool350, label %if.then355, label %lor.lhs.false352

lor.lhs.false352:                                 ; preds = %land.lhs.true349
  %358 = load i32, i32* %t.addr, align 4
  %cmp353 = icmp eq i32 %358, 1
  br i1 %cmp353, label %if.then355, label %if.end356

if.then355:                                       ; preds = %lor.lhs.false352, %land.lhs.true349
  %359 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %360 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %361 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %359, %struct.bpf_reg_state* noundef %360, i32 noundef %361) #20
  br label %if.end356

if.end356:                                        ; preds = %if.then355, %lor.lhs.false352, %land.lhs.true346, %if.end343
  br label %if.end360

if.else357:                                       ; preds = %if.else322
  %362 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %363 = bitcast %struct.bpf_verifier_env* %362 to i8*
  %364 = load i32, i32* %regno.addr, align 4
  %365 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %366 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type358 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %366, i32 0, i32 0
  %367 = load i32, i32* %type358, align 8
  %call359 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %365, i32 noundef %367) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %363, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.152, i64 0, i64 0), i32 noundef %364, i8* noundef %call359) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end360:                                        ; preds = %if.end356
  br label %if.end361

if.end361:                                        ; preds = %if.end360, %if.then320
  br label %if.end362

if.end362:                                        ; preds = %if.end361, %if.then314
  br label %if.end363

if.end363:                                        ; preds = %if.end362, %if.end305
  br label %if.end364

if.end364:                                        ; preds = %if.end363, %if.end290
  br label %if.end365

if.end365:                                        ; preds = %if.end364, %if.end273
  br label %if.end366

if.end366:                                        ; preds = %if.end365, %if.end248
  br label %if.end367

if.end367:                                        ; preds = %if.end366, %if.end219
  br label %if.end368

if.end368:                                        ; preds = %if.end367, %if.end198
  br label %if.end369

if.end369:                                        ; preds = %if.end368, %if.end139
  br label %if.end370

if.end370:                                        ; preds = %if.end369, %if.end93
  br label %if.end371

if.end371:                                        ; preds = %if.end370, %if.end31
  %368 = load i32, i32* %err, align 4
  %tobool372 = icmp ne i32 %368, 0
  br i1 %tobool372, label %if.end391, label %land.lhs.true373

land.lhs.true373:                                 ; preds = %if.end371
  %369 = load i32, i32* %size, align 4
  %cmp374 = icmp slt i32 %369, 8
  br i1 %cmp374, label %land.lhs.true376, label %if.end391

land.lhs.true376:                                 ; preds = %land.lhs.true373
  %370 = load i32, i32* %value_regno.addr, align 4
  %cmp377 = icmp sge i32 %370, 0
  br i1 %cmp377, label %land.lhs.true379, label %if.end391

land.lhs.true379:                                 ; preds = %land.lhs.true376
  %371 = load i32, i32* %t.addr, align 4
  %cmp380 = icmp eq i32 %371, 1
  br i1 %cmp380, label %land.lhs.true382, label %if.end391

land.lhs.true382:                                 ; preds = %land.lhs.true379
  %372 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %373 = load i32, i32* %value_regno.addr, align 4
  %idxprom383 = sext i32 %373 to i64
  %arrayidx384 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %372, i64 %idxprom383
  %type385 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx384, i32 0, i32 0
  %374 = load i32, i32* %type385, align 8
  %cmp386 = icmp eq i32 %374, 1
  br i1 %cmp386, label %if.then388, label %if.end391

if.then388:                                       ; preds = %land.lhs.true382
  %375 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %376 = load i32, i32* %value_regno.addr, align 4
  %idxprom389 = sext i32 %376 to i64
  %arrayidx390 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %375, i64 %idxprom389
  %377 = load i32, i32* %size, align 4
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %arrayidx390, i32 noundef %377) #20
  br label %if.end391

if.end391:                                        ; preds = %if.then388, %land.lhs.true382, %land.lhs.true379, %land.lhs.true376, %land.lhs.true373, %if.end371
  %378 = load i32, i32* %err, align 4
  store i32 %378, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end391, %if.else357, %if.then336, %if.then280, %if.then262, %if.then237, %if.then227, %if.then211, %if.then206, %if.then158, %if.then153, %if.then126, %if.then114, %if.then105, %if.then85, %if.then48, %if.then44, %if.then40, %if.then27, %if.then23, %if.then17, %if.then13
  %379 = load i32, i32* %retval, align 4
  ret i32 %379
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_mem_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %mem_size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %mem_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %size_ok = alloca i8, align 1
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %mem_size, i32* %mem_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load i32, i32* %size.addr, align 4
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %cmp1 = icmp eq i32 %1, 0
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %2 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %2 to i1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %3 = phi i1 [ false, %lor.rhs ], [ %tobool, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %4 = phi i1 [ true, %entry ], [ %3, %land.end ]
  %frombool2 = zext i1 %4 to i8
  store i8 %frombool2, i8* %size_ok, align 1
  %5 = load i32, i32* %off.addr, align 4
  %cmp3 = icmp sge i32 %5, 0
  br i1 %cmp3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.end
  %6 = load i8, i8* %size_ok, align 1
  %tobool4 = trunc i8 %6 to i1
  br i1 %tobool4, label %land.lhs.true5, label %if.end

land.lhs.true5:                                   ; preds = %land.lhs.true
  %7 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %7 to i64
  %8 = load i32, i32* %size.addr, align 4
  %conv6 = sext i32 %8 to i64
  %add = add i64 %conv, %conv6
  %9 = load i32, i32* %mem_size.addr, align 4
  %conv7 = zext i32 %9 to i64
  %cmp8 = icmp ule i64 %add, %conv7
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true5
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true5, %land.lhs.true, %lor.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %10) #20
  %11 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 0
  %13 = load i32, i32* %type, align 8
  switch i32 %13, label %sw.default [
    i32 5, label %sw.bb
    i32 4, label %sw.bb10
    i32 8, label %sw.bb11
    i32 7, label %sw.bb11
    i32 9, label %sw.bb11
    i32 17, label %sw.bb12
  ]

sw.bb:                                            ; preds = %if.end
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load i32, i32* %mem_size.addr, align 4
  %17 = load i32, i32* %off.addr, align 4
  %18 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.119, i64 0, i64 0), i32 noundef %16, i32 noundef %17, i32 noundef %18) #20
  br label %sw.epilog

sw.bb10:                                          ; preds = %if.end
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  %21 = load i32, i32* %mem_size.addr, align 4
  %22 = load i32, i32* %off.addr, align 4
  %23 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.120, i64 0, i64 0), i32 noundef %21, i32 noundef %22, i32 noundef %23) #20
  br label %sw.epilog

sw.bb11:                                          ; preds = %if.end, %if.end, %if.end
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  %26 = load i32, i32* %off.addr, align 4
  %27 = load i32, i32* %size.addr, align 4
  %28 = load i32, i32* %regno.addr, align 4
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 3
  %30 = load i32, i32* %id, align 8
  %31 = load i32, i32* %off.addr, align 4
  %32 = load i32, i32* %mem_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([66 x i8], [66 x i8]* @.str.121, i64 0, i64 0), i32 noundef %26, i32 noundef %27, i32 noundef %28, i32 noundef %30, i32 noundef %31, i32 noundef %32) #20
  br label %sw.epilog

sw.bb12:                                          ; preds = %if.end
  br label %sw.default

sw.default:                                       ; preds = %if.end, %sw.bb12
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  %35 = load i32, i32* %mem_size.addr, align 4
  %36 = load i32, i32* %off.addr, align 4
  %37 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.122, i64 0, i64 0), i32 noundef %35, i32 noundef %36, i32 noundef %37) #20
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb10, %sw.bb
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then
  %38 = load i32, i32* %retval, align 4
  ret i32 %38
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_map_flags_to_cap(%struct.bpf_map* noundef %map) #0 {
entry:
  %retval = alloca i32, align 4
  %map.addr = alloca %struct.bpf_map*, align 8
  %access_flags = alloca i32, align 4
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 8
  %1 = load i32, i32* %map_flags, align 16
  %and = and i32 %1, 384
  store i32 %and, i32* %access_flags, align 4
  %2 = load i32, i32* %access_flags, align 4
  %and1 = and i32 %2, 128
  %tobool = icmp ne i32 %and1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i32, i32* %access_flags, align 4
  %and2 = and i32 %3, 256
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.else
  store i32 2, i32* %retval, align 4
  br label %return

if.else5:                                         ; preds = %if.else
  store i32 3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else5, %if.then4, %if.then
  %4 = load i32, i32* %retval, align 4
  ret i32 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %spin_lock_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 9
  %1 = load i32, i32* %spin_lock_off, align 4
  %cmp = icmp sge i32 %1, 0
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @map_value_has_kptrs(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %kptr_off_tab = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 10
  %1 = load %struct.bpf_map_value_off*, %struct.bpf_map_value_off** %kptr_off_tab, align 8
  %2 = bitcast %struct.bpf_map_value_off* %1 to i8*
  %call = call zeroext i1 @IS_ERR_OR_NULL(i8* noundef %2) #20
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @IS_ERR_OR_NULL(i8* noundef %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %tobool = icmp ne i8* %0, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool3 = icmp ne i64 %conv, 0
  br i1 %tobool3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i8*, i8** %ptr.addr, align 8
  %2 = ptrtoint i8* %1 to i64
  %3 = inttoptr i64 %2 to i8*
  %4 = ptrtoint i8* %3 to i64
  %cmp = icmp uge i64 %4, -4095
  %lnot5 = xor i1 %cmp, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %tobool10 = icmp ne i64 %conv9, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %5 = phi i1 [ true, %entry ], [ %tobool10, %lor.rhs ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_buffer_access(%struct.bpf_verifier_env* noundef %env, i8* noundef %buf_info, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %buf_info.addr = alloca i8*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i8* %buf_info, i8** %buf_info.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = bitcast %struct.bpf_verifier_env* %1 to i8*
  %3 = load i32, i32* %regno.addr, align 4
  %4 = load i8*, i8** %buf_info.addr, align 8
  %5 = load i32, i32* %off.addr, align 4
  %6 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %2, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.136, i64 0, i64 0), i32 noundef %3, i8* noundef %4, i32 noundef %5, i32 noundef %6) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #20
  br i1 %call, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off1, i32 0, i32 0
  %14 = load i64, i64* %value, align 8
  %tobool = icmp ne i64 %14, 0
  br i1 %tobool, label %if.then2, label %if.end6

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %16 = bitcast %struct.tnum* %var_off3 to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call4 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %18, i64 %20) #20
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  %23 = load i32, i32* %regno.addr, align 4
  %24 = load i32, i32* %off.addr, align 4
  %arraydecay5 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.137, i64 0, i64 0), i32 noundef %23, i32 noundef %24, i8* noundef %arraydecay5) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then2, %if.then
  %25 = load i32, i32* %retval, align 4
  ret i32 %25
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  %1 = load i32, i32* %regno.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call, i64 %idx.ext
  ret %struct.bpf_reg_state* %add.ptr
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_access_within_bounds(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %access_size, i32 noundef %src, i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %access_size.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %min_off = alloca i32, align 4
  %max_off = alloca i32, align 4
  %err = alloca i32, align 4
  %err_extra = alloca i8*, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %access_size, i32* %access_size.addr, align 4
  store i32 %src, i32* %src.addr, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %3, %struct.bpf_reg_state* noundef %4) #20
  store %struct.bpf_func_state* %call1, %struct.bpf_func_state** %state, align 8
  %5 = load i32, i32* %src.addr, align 4
  %cmp = icmp eq i32 %5, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.143, i64 0, i64 0), i8** %err_extra, align 8
  br label %if.end5

if.else:                                          ; preds = %entry
  %6 = load i32, i32* %type.addr, align 4
  %cmp2 = icmp eq i32 %6, 1
  br i1 %cmp2, label %if.then3, label %if.else4

if.then3:                                         ; preds = %if.else
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.144, i64 0, i64 0), i8** %err_extra, align 8
  br label %if.end

if.else4:                                         ; preds = %if.else
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.145, i64 0, i64 0), i8** %err_extra, align 8
  br label %if.end

if.end:                                           ; preds = %if.else4, %if.then3
  br label %if.end5

if.end5:                                          ; preds = %if.end, %if.then
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call6 = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #20
  br i1 %call6, label %if.then7, label %if.else16

if.then7:                                         ; preds = %if.end5
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off8, i32 0, i32 0
  %14 = load i64, i64* %value, align 8
  %15 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %15 to i64
  %add = add i64 %14, %conv
  %conv9 = trunc i64 %add to i32
  store i32 %conv9, i32* %min_off, align 4
  %16 = load i32, i32* %access_size.addr, align 4
  %cmp10 = icmp sgt i32 %16, 0
  br i1 %cmp10, label %if.then12, label %if.else14

if.then12:                                        ; preds = %if.then7
  %17 = load i32, i32* %min_off, align 4
  %18 = load i32, i32* %access_size.addr, align 4
  %add13 = add i32 %17, %18
  %sub = sub i32 %add13, 1
  store i32 %sub, i32* %max_off, align 4
  br label %if.end15

if.else14:                                        ; preds = %if.then7
  %19 = load i32, i32* %min_off, align 4
  store i32 %19, i32* %max_off, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.else14, %if.then12
  br label %if.end39

if.else16:                                        ; preds = %if.end5
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 7
  %21 = load i64, i64* %smax_value, align 8
  %cmp17 = icmp sge i64 %21, 536870912
  br i1 %cmp17, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else16
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 6
  %23 = load i64, i64* %smin_value, align 8
  %cmp19 = icmp sle i64 %23, -536870912
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %lor.lhs.false, %if.else16
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  %26 = load i8*, i8** %err_extra, align 8
  %27 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.146, i64 0, i64 0), i8* noundef %26, i32 noundef %27) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %lor.lhs.false
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 6
  %29 = load i64, i64* %smin_value23, align 8
  %30 = load i32, i32* %off.addr, align 4
  %conv24 = sext i32 %30 to i64
  %add25 = add i64 %29, %conv24
  %conv26 = trunc i64 %add25 to i32
  store i32 %conv26, i32* %min_off, align 4
  %31 = load i32, i32* %access_size.addr, align 4
  %cmp27 = icmp sgt i32 %31, 0
  br i1 %cmp27, label %if.then29, label %if.else37

if.then29:                                        ; preds = %if.end22
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 7
  %33 = load i64, i64* %smax_value30, align 8
  %34 = load i32, i32* %off.addr, align 4
  %conv31 = sext i32 %34 to i64
  %add32 = add i64 %33, %conv31
  %35 = load i32, i32* %access_size.addr, align 4
  %conv33 = sext i32 %35 to i64
  %add34 = add i64 %add32, %conv33
  %sub35 = sub i64 %add34, 1
  %conv36 = trunc i64 %sub35 to i32
  store i32 %conv36, i32* %max_off, align 4
  br label %if.end38

if.else37:                                        ; preds = %if.end22
  %36 = load i32, i32* %min_off, align 4
  store i32 %36, i32* %max_off, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.else37, %if.then29
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end15
  %37 = load i32, i32* %min_off, align 4
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %39 = load i32, i32* %type.addr, align 4
  %call40 = call i32 @check_stack_slot_within_bounds(i32 noundef %37, %struct.bpf_func_state* noundef %38, i32 noundef %39) #20
  store i32 %call40, i32* %err, align 4
  %40 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %40, 0
  br i1 %tobool, label %if.end43, label %if.then41

if.then41:                                        ; preds = %if.end39
  %41 = load i32, i32* %max_off, align 4
  %42 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %43 = load i32, i32* %type.addr, align 4
  %call42 = call i32 @check_stack_slot_within_bounds(i32 noundef %41, %struct.bpf_func_state* noundef %42, i32 noundef %43) #20
  store i32 %call42, i32* %err, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %if.end39
  %44 = load i32, i32* %err, align 4
  %tobool44 = icmp ne i32 %44, 0
  br i1 %tobool44, label %if.then45, label %if.end54

if.then45:                                        ; preds = %if.end43
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off46 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 5
  %46 = bitcast %struct.tnum* %var_off46 to { i64, i64 }*
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 0
  %48 = load i64, i64* %47, align 8
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 1
  %50 = load i64, i64* %49, align 8
  %call47 = call zeroext i1 @tnum_is_const(i64 %48, i64 %50) #20
  br i1 %call47, label %if.then48, label %if.else49

if.then48:                                        ; preds = %if.then45
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  %53 = load i8*, i8** %err_extra, align 8
  %54 = load i32, i32* %regno.addr, align 4
  %55 = load i32, i32* %off.addr, align 4
  %56 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.147, i64 0, i64 0), i8* noundef %53, i32 noundef %54, i32 noundef %55, i32 noundef %56) #20
  br label %if.end53

if.else49:                                        ; preds = %if.then45
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off50 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 5
  %58 = bitcast %struct.tnum* %var_off50 to { i64, i64 }*
  %59 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %58, i32 0, i32 0
  %60 = load i64, i64* %59, align 8
  %61 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %58, i32 0, i32 1
  %62 = load i64, i64* %61, align 8
  %call51 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %60, i64 %62) #20
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = bitcast %struct.bpf_verifier_env* %63 to i8*
  %65 = load i8*, i8** %err_extra, align 8
  %66 = load i32, i32* %regno.addr, align 4
  %arraydecay52 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %67 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %64, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.148, i64 0, i64 0), i8* noundef %65, i32 noundef %66, i8* noundef %arraydecay52, i32 noundef %67) #20
  br label %if.end53

if.end53:                                         ; preds = %if.else49, %if.then48
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.end43
  %68 = load i32, i32* %err, align 4
  store i32 %68, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end54, %if.then21
  %69 = load i32, i32* %retval, align 4
  ret i32 %69
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = bitcast %struct.tnum* %var_off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 15
  store i32 0, i32* %frameno, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 31
  %5 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ugt i32 %5, 1
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 20
  %7 = load i8, i8* %bpf_capable, align 8
  %tobool = trunc i8 %7 to i1
  %lnot = xor i1 %tobool, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %8 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 18
  %frombool = zext i1 %8 to i8
  store i8 %frombool, i8* %precise, align 4
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %10) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scrub_spilled_slot(i8* noundef %stype) #0 {
entry:
  %stype.addr = alloca i8*, align 8
  store i8* %stype, i8** %stype.addr, align 8
  %0 = load i8*, i8** %stype.addr, align 8
  %1 = load i8, i8* %0, align 1
  %conv = zext i8 %1 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i8*, i8** %stype.addr, align 8
  store i8 2, i8* %2, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %state, %struct.bpf_reg_state* noundef %parent, i8 noundef zeroext %flag) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_reg_state*, align 8
  %parent.addr = alloca %struct.bpf_reg_state*, align 8
  %flag.addr = alloca i8, align 1
  %writes = alloca i8, align 1
  %cnt = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %state, %struct.bpf_reg_state** %state.addr, align 8
  store %struct.bpf_reg_state* %parent, %struct.bpf_reg_state** %parent.addr, align 8
  store i8 %flag, i8* %flag.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state.addr, align 8
  %parent1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 14
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent1, align 8
  %cmp = icmp eq %struct.bpf_reg_state* %0, %2
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %writes, align 1
  store i32 0, i32* %cnt, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end26, %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %3, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i8, i8* %writes, align 1
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state.addr, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 17
  %6 = load i32, i32* %live, align 8
  %and = and i32 %6, 4
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %while.end

if.end:                                           ; preds = %land.lhs.true, %while.body
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 17
  %8 = load i32, i32* %live4, align 8
  %and5 = and i32 %8, 8
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 0
  %13 = load i32, i32* %type, align 8
  %call = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %11, i32 noundef %13) #20
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %15 = load i64, i64* %value, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 1
  %17 = load i32, i32* %off, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.149, i64 0, i64 0), i8* noundef %call, i64 noundef %15, i32 noundef %17) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 17
  %19 = load i32, i32* %live9, align 8
  %and10 = and i32 %19, 3
  %20 = load i8, i8* %flag.addr, align 1
  %conv = zext i8 %20 to i32
  %cmp11 = icmp eq i32 %and10, %conv
  br i1 %cmp11, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 17
  %22 = load i32, i32* %live13, align 8
  %and14 = and i32 %22, 2
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %if.end8
  br label %while.end

if.end17:                                         ; preds = %lor.lhs.false
  %23 = load i8, i8* %flag.addr, align 1
  %conv18 = zext i8 %23 to i32
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 17
  %25 = load i32, i32* %live19, align 8
  %or = or i32 %25, %conv18
  store i32 %or, i32* %live19, align 8
  %26 = load i8, i8* %flag.addr, align 1
  %conv20 = zext i8 %26 to i32
  %cmp21 = icmp eq i32 %conv20, 2
  br i1 %cmp21, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.end17
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 17
  %28 = load i32, i32* %live24, align 8
  %and25 = and i32 %28, -2
  store i32 %and25, i32* %live24, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %if.end17
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  store %struct.bpf_reg_state* %29, %struct.bpf_reg_state** %state.addr, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state.addr, align 8
  %parent27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 14
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent27, align 8
  store %struct.bpf_reg_state* %31, %struct.bpf_reg_state** %parent.addr, align 8
  store i8 1, i8* %writes, align 1
  %32 = load i32, i32* %cnt, align 4
  %inc = add i32 %32, 1
  store i32 %inc, i32* %cnt, align 4
  br label %while.cond, !llvm.loop !64

while.end:                                        ; preds = %if.then16, %if.then, %while.cond
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %longest_mark_read_walk = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 40
  %34 = load i32, i32* %longest_mark_read_walk, align 4
  %35 = load i32, i32* %cnt, align 4
  %cmp28 = icmp ult i32 %34, %35
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %while.end
  %36 = load i32, i32* %cnt, align 4
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %longest_mark_read_walk31 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %37, i32 0, i32 40
  store i32 %36, i32* %longest_mark_read_walk31, align 4
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %while.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end32, %if.then7
  %38 = load i32, i32* %retval, align 4
  ret i32 %38
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @update_stack_depth(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %func, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %func.addr = alloca %struct.bpf_func_state*, align 8
  %off.addr = alloca i32, align 4
  %stack = alloca i16, align 2
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %func, %struct.bpf_func_state** %func.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 27
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func.addr, align 8
  %subprogno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 3
  %2 = load i32, i32* %subprogno, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %3 = load i16, i16* %stack_depth, align 8
  store i16 %3, i16* %stack, align 2
  %4 = load i16, i16* %stack, align 2
  %conv = zext i16 %4 to i32
  %5 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %5
  %cmp = icmp sge i32 %conv, %sub
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, i32* %off.addr, align 4
  %sub2 = sub i32 0, %6
  %conv3 = trunc i32 %sub2 to i16
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 27
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func.addr, align 8
  %subprogno5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 3
  %9 = load i32, i32* %subprogno5, align 8
  %idxprom6 = zext i32 %9 to i64
  %arrayidx7 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info4, i64 0, i64 %idxprom6
  %stack_depth8 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx7, i32 0, i32 2
  store i16 %conv3, i16* %stack_depth8, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_slot_within_bounds(i32 noundef %off, %struct.bpf_func_state* noundef %state, i32 noundef %t) #0 {
entry:
  %retval = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %t.addr = alloca i32, align 4
  %min_valid_off = alloca i32, align 4
  store i32 %off, i32* %off.addr, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  %0 = load i32, i32* %t.addr, align 4
  %cmp = icmp eq i32 %0, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 -512, i32* %min_valid_off, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 10
  %2 = load i32, i32* %allocated_stack, align 8
  %sub = sub i32 0, %2
  store i32 %sub, i32* %min_valid_off, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %3 = load i32, i32* %off.addr, align 4
  %4 = load i32, i32* %min_valid_off, align 4
  %cmp1 = icmp slt i32 %3, %4
  br i1 %cmp1, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %5 = load i32, i32* %off.addr, align 4
  %cmp2 = icmp sgt i32 %5, -1
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  store i32 -13, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  store i64 0, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 9
  store i64 -1, i64* %umax_value, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 12
  store i32 0, i32* %u32_min_value, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 13
  store i32 -1, i32* %u32_max_value, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ptr_alignment(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %strict_alignment_once) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %strict_alignment_once.addr = alloca i8, align 1
  %strict = alloca i8, align 1
  %pointer_desc = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %strict_alignment_once to i8
  store i8 %frombool, i8* %strict_alignment_once.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %strict_alignment = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 6
  %1 = load i8, i8* %strict_alignment, align 4
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load i8, i8* %strict_alignment_once.addr, align 1
  %tobool1 = trunc i8 %2 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %tobool1, %lor.rhs ]
  %frombool2 = zext i1 %3 to i8
  store i8 %frombool2, i8* %strict, align 1
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i64 0, i64 0), i8** %pointer_desc, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  %5 = load i32, i32* %type, align 8
  switch i32 %5, label %sw.default [
    i32 8, label %sw.bb
    i32 7, label %sw.bb
    i32 10, label %sw.bb4
    i32 5, label %sw.bb5
    i32 4, label %sw.bb6
    i32 2, label %sw.bb7
    i32 6, label %sw.bb8
    i32 11, label %sw.bb9
    i32 12, label %sw.bb10
    i32 13, label %sw.bb11
    i32 15, label %sw.bb12
  ]

sw.bb:                                            ; preds = %lor.end, %lor.end
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %8 = load i32, i32* %off.addr, align 4
  %9 = load i32, i32* %size.addr, align 4
  %10 = load i8, i8* %strict, align 1
  %tobool3 = trunc i8 %10 to i1
  %call = call i32 @check_pkt_ptr_alignment(%struct.bpf_verifier_env* noundef %6, %struct.bpf_reg_state* noundef %7, i32 noundef %8, i32 noundef %9, i1 noundef zeroext %tobool3) #20
  store i32 %call, i32* %retval, align 4
  br label %return

sw.bb4:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.159, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb5:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.160, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.161, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb7:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.162, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb8:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.163, i64 0, i64 0), i8** %pointer_desc, align 8
  store i8 1, i8* %strict, align 1
  br label %sw.epilog

sw.bb9:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.164, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb10:                                          ; preds = %lor.end
  store i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.165, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %lor.end
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.166, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb12:                                          ; preds = %lor.end
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.167, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %lor.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %13 = load i8*, i8** %pointer_desc, align 8
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  %16 = load i8, i8* %strict, align 1
  %tobool13 = trunc i8 %16 to i1
  %call14 = call i32 @check_generic_ptr_alignment(%struct.bpf_verifier_env* noundef %11, %struct.bpf_reg_state* noundef %12, i8* noundef %13, i32 noundef %14, i32 noundef %15, i1 noundef zeroext %tobool13) #20
  store i32 %call14, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb
  %17 = load i32, i32* %retval, align 4
  ret i32 %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %0, 11
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %1, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  store i32 2305, i32* %__flags, align 4
  br label %do.body7

do.body7:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body7
  br label %do.body8

do.body8:                                         ; preds = %do.end
  %2 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1791, i32 %2, i64 12) #19, !srcloc !65
  br label %do.end9

do.end9:                                          ; preds = %do.body8
  br label %do.body10

do.body10:                                        ; preds = %do.end9
  br label %do.end11

do.end11:                                         ; preds = %do.body10
  br label %do.end12

do.end12:                                         ; preds = %do.end11
  br label %if.end

if.end:                                           ; preds = %do.end12, %entry
  %3 = load i32, i32* %__ret_warn_on, align 4
  %tobool13 = icmp ne i32 %3, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  store i64 %conv18, i64* %tmp, align 8
  %4 = load i64, i64* %tmp, align 8
  %tobool19 = icmp ne i64 %4, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = bitcast %struct.bpf_verifier_env* %5 to i8*
  %7 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %6, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.170, i64 0, i64 0), i32 noundef %7) #20
  store i32 0, i32* %regno.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then20
  %8 = load i32, i32* %regno.addr, align 4
  %cmp21 = icmp ult i32 %8, 10
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %11 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i64 %idx.ext
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %9, %struct.bpf_reg_state* noundef %add.ptr) #20
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %regno.addr, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %regno.addr, align 4
  br label %for.cond, !llvm.loop !66

for.end:                                          ; preds = %for.cond
  br label %return

if.end23:                                         ; preds = %if.end
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %15 = load i32, i32* %regno.addr, align 4
  %idx.ext24 = zext i32 %15 to i64
  %add.ptr25 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i64 %idx.ext24
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %13, %struct.bpf_reg_state* noundef %add.ptr25) #20
  br label %return

return:                                           ; preds = %if.end23, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 17
  %1 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool = trunc i8 %1 to i1
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %2, i32 noundef %3) #20
  %call1 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext %tobool, %struct.bpf_reg_state* noundef %call) #20
  ret i1 %call1
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_map_value_off_desc* @bpf_map_kptr_off_contains(%struct.bpf_map* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_kptr_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %value_regno, i32 noundef %insn_idx, %struct.bpf_map_value_off_desc* noundef %off_desc) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %off_desc.addr = alloca %struct.bpf_map_value_off_desc*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %class = alloca i32, align 4
  %val_reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store %struct.bpf_map_value_off_desc* %off_desc, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 12
  %3 = bitcast %union.anon.198* %2 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %3, i32 0, i32 1
  %4 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 %idxprom
  store %struct.bpf_insn* %arrayidx, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %5, i32 0, i32 0
  %6 = load i8, i8* %code, align 4
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 7
  store i32 %and, i32* %class, align 4
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 0
  %8 = load i8, i8* %code1, align 4
  %conv2 = zext i8 %8 to i32
  %and3 = and i32 %conv2, 224
  %cmp = icmp ne i32 %and3, 96
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([65 x i8], [65 x i8]* @.str.171, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load i32, i32* %class, align 4
  %cmp5 = icmp ne i32 %11, 1
  br i1 %cmp5, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %if.end
  %12 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %type = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %12, i32 0, i32 1
  %13 = load i32, i32* %type, align 4
  %cmp7 = icmp eq i32 %13, 1
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %land.lhs.true
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.172, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %land.lhs.true, %if.end
  %16 = load i32, i32* %class, align 4
  %cmp11 = icmp eq i32 %16, 1
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end10
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %value_regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %17, i32 noundef %18) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %val_reg, align 8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call14 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %20) #20
  %21 = load i32, i32* %value_regno.addr, align 4
  %22 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %kptr = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %22, i32 0, i32 2
  %btf = getelementptr inbounds %struct.anon.175, %struct.anon.175* %kptr, i32 0, i32 0
  %23 = load %struct.btf*, %struct.btf** %btf, align 8
  %24 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %kptr15 = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %24, i32 0, i32 2
  %btf_id = getelementptr inbounds %struct.anon.175, %struct.anon.175* %kptr15, i32 0, i32 3
  %25 = load i32, i32* %btf_id, align 8
  call void @mark_btf_ld_reg(%struct.bpf_verifier_env* noundef %19, %struct.bpf_reg_state* noundef %call14, i32 noundef %21, i32 noundef 16, %struct.btf* noundef %23, i32 noundef %25, i32 noundef 16640) #20
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 15
  %27 = load i32, i32* %id_gen, align 8
  %inc = add i32 %27, 1
  store i32 %inc, i32* %id_gen, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %val_reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 3
  store i32 %inc, i32* %id, align 8
  br label %if.end35

if.else:                                          ; preds = %if.end10
  %29 = load i32, i32* %class, align 4
  %cmp16 = icmp eq i32 %29, 3
  br i1 %cmp16, label %if.then18, label %if.else25

if.then18:                                        ; preds = %if.else
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load i32, i32* %value_regno.addr, align 4
  %call19 = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %30, i32 noundef %31) #20
  store %struct.bpf_reg_state* %call19, %struct.bpf_reg_state** %val_reg, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %val_reg, align 8
  %call20 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %32) #20
  br i1 %call20, label %if.end24, label %land.lhs.true21

land.lhs.true21:                                  ; preds = %if.then18
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %val_reg, align 8
  %36 = load i32, i32* %value_regno.addr, align 4
  %call22 = call i32 @map_kptr_match_type(%struct.bpf_verifier_env* noundef %33, %struct.bpf_map_value_off_desc* noundef %34, %struct.bpf_reg_state* noundef %35, i32 noundef %36) #20
  %tobool = icmp ne i32 %call22, 0
  br i1 %tobool, label %if.then23, label %if.end24

if.then23:                                        ; preds = %land.lhs.true21
  store i32 -13, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %land.lhs.true21, %if.then18
  br label %if.end34

if.else25:                                        ; preds = %if.else
  %37 = load i32, i32* %class, align 4
  %cmp26 = icmp eq i32 %37, 2
  br i1 %cmp26, label %if.then28, label %if.else32

if.then28:                                        ; preds = %if.else25
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 3
  %39 = load i32, i32* %imm, align 4
  %tobool29 = icmp ne i32 %39, 0
  br i1 %tobool29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.then28
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = bitcast %struct.bpf_verifier_env* %40 to i8*
  %42 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %offset = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %42, i32 0, i32 0
  %43 = load i32, i32* %offset, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %41, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.173, i64 0, i64 0), i32 noundef %43) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.then28
  br label %if.end33

if.else32:                                        ; preds = %if.else25
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = bitcast %struct.bpf_verifier_env* %44 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %45, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.174, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end31
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.end24
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then13
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end35, %if.else32, %if.then30, %if.then23, %if.then9, %if.then
  %46 = load i32, i32* %retval, align 4
  ret i32 %46
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_is_rdonly(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  %tmp = alloca i8, align 1
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 8
  %1 = load i32, i32* %map_flags, align 16
  %and = and i32 %1, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %land.lhs.true
  br label %do.end

do.end:                                           ; preds = %do.body
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %frozen = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %2, i32 0, i32 28
  %3 = load volatile i8, i8* %frozen, align 1
  %tobool1 = trunc i8 %3 to i1
  %frombool = zext i1 %tobool1 to i8
  store i8 %frombool, i8* %tmp, align 1
  %4 = load i8, i8* %tmp, align 1
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.end
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call = call zeroext i1 @bpf_map_write_active(%struct.bpf_map* noundef %5) #20
  %lnot = xor i1 %call, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.end, %entry
  %6 = phi i1 [ false, %do.end ], [ false, %entry ], [ %lnot, %land.rhs ]
  ret i1 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_map_direct_read(%struct.bpf_map* noundef %map, i32 noundef %off, i32 noundef %size, i64* noundef %val) #0 {
entry:
  %retval = alloca i32, align 4
  %map.addr = alloca %struct.bpf_map*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %val.addr = alloca i64*, align 8
  %ptr = alloca i8*, align 8
  %addr = alloca i64, align 8
  %err = alloca i32, align 4
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i64* %val, i64** %val.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 0
  %1 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %1, i32 0, i32 28
  %2 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %3 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %4 = load i32, i32* %off.addr, align 4
  %call = call i32 %2(%struct.bpf_map* noundef %3, i64* noundef %addr, i32 noundef %4) #20
  store i32 %call, i32* %err, align 4
  %5 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, i32* %err, align 4
  store i32 %6, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i64, i64* %addr, align 8
  %8 = inttoptr i64 %7 to i8*
  %9 = load i32, i32* %off.addr, align 4
  %idx.ext = sext i32 %9 to i64
  %add.ptr = getelementptr i8, i8* %8, i64 %idx.ext
  store i8* %add.ptr, i8** %ptr, align 8
  %10 = load i32, i32* %size.addr, align 4
  switch i32 %10, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb1
    i32 4, label %sw.bb3
    i32 8, label %sw.bb5
  ]

sw.bb:                                            ; preds = %if.end
  %11 = load i8*, i8** %ptr, align 8
  %12 = load i8, i8* %11, align 1
  %conv = zext i8 %12 to i64
  %13 = load i64*, i64** %val.addr, align 8
  store i64 %conv, i64* %13, align 8
  br label %sw.epilog

sw.bb1:                                           ; preds = %if.end
  %14 = load i8*, i8** %ptr, align 8
  %15 = bitcast i8* %14 to i16*
  %16 = load i16, i16* %15, align 2
  %conv2 = zext i16 %16 to i64
  %17 = load i64*, i64** %val.addr, align 8
  store i64 %conv2, i64* %17, align 8
  br label %sw.epilog

sw.bb3:                                           ; preds = %if.end
  %18 = load i8*, i8** %ptr, align 8
  %19 = bitcast i8* %18 to i32*
  %20 = load i32, i32* %19, align 4
  %conv4 = zext i32 %20 to i64
  %21 = load i64*, i64** %val.addr, align 8
  store i64 %conv4, i64* %21, align 8
  br label %sw.epilog

sw.bb5:                                           ; preds = %if.end
  %22 = load i8*, i8** %ptr, align 8
  %23 = bitcast i8* %22 to i64*
  %24 = load i64, i64* %23, align 8
  %25 = load i64*, i64** %val.addr, align 8
  store i64 %24, i64* %25, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb5, %sw.bb3, %sw.bb1, %sw.bb
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %if.then
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_known(%struct.bpf_reg_state* noundef %reg, i64 noundef %imm) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %imm.addr = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %imm, i64* %imm.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %1 = load i64, i64* %imm.addr, align 8
  call void @___mark_reg_known(%struct.bpf_reg_state* noundef %0, i64 noundef %1) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ctx_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %off, i32 noundef %size, i32 noundef %t, i32* noundef %reg_type, %struct.btf** noundef %btf, i32* noundef %btf_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %reg_type.addr = alloca i32*, align 8
  %btf.addr = alloca %struct.btf**, align 8
  %btf_id.addr = alloca i32*, align 8
  %info = alloca %struct.bpf_insn_access_aux, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  store i32* %reg_type, i32** %reg_type.addr, align 8
  store %struct.btf** %btf, %struct.btf*** %btf.addr, align 8
  store i32* %btf_id, i32** %btf_id.addr, align 8
  %reg_type1 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 0
  %0 = load i32*, i32** %reg_type.addr, align 8
  %1 = load i32, i32* %0, align 4
  store i32 %1, i32* %reg_type1, align 8
  %2 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %3 = bitcast %union.anon.208* %2 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %3, i8 0, i64 16, i1 false)
  %log = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 2
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 26
  store %struct.bpf_verifier_log* %log2, %struct.bpf_verifier_log** %log, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 3
  %6 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %is_valid_access = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %6, i32 0, i32 1
  %7 = load i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)*, i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)** %is_valid_access, align 8
  %tobool = icmp ne i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)* %7, null
  br i1 %tobool, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 3
  %9 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops3, align 8
  %is_valid_access4 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %9, i32 0, i32 1
  %10 = load i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)*, i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)** %is_valid_access4, align 8
  %11 = load i32, i32* %off.addr, align 4
  %12 = load i32, i32* %size.addr, align 4
  %13 = load i32, i32* %t.addr, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 2
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call zeroext i1 %10(i32 noundef %11, i32 noundef %12, i32 noundef %13, %struct.bpf_prog* noundef %15, %struct.bpf_insn_access_aux* noundef %info) #20
  br i1 %call, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true
  %reg_type5 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 0
  %16 = load i32, i32* %reg_type5, align 8
  %17 = load i32*, i32** %reg_type.addr, align 8
  store i32 %16, i32* %17, align 4
  %18 = load i32*, i32** %reg_type.addr, align 8
  %19 = load i32, i32* %18, align 4
  %call6 = call i32 @base_type(i32 noundef %19) #20
  %cmp = icmp eq i32 %call6, 16
  br i1 %cmp, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.then
  %20 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %21 = bitcast %union.anon.208* %20 to %struct.anon.209*
  %btf8 = getelementptr inbounds %struct.anon.209, %struct.anon.209* %21, i32 0, i32 0
  %22 = load %struct.btf*, %struct.btf** %btf8, align 8
  %23 = load %struct.btf**, %struct.btf*** %btf.addr, align 8
  store %struct.btf* %22, %struct.btf** %23, align 8
  %24 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %25 = bitcast %union.anon.208* %24 to %struct.anon.209*
  %btf_id9 = getelementptr inbounds %struct.anon.209, %struct.anon.209* %25, i32 0, i32 1
  %26 = load i32, i32* %btf_id9, align 8
  %27 = load i32*, i32** %btf_id.addr, align 8
  store i32 %26, i32* %27, align 4
  br label %if.end

if.else:                                          ; preds = %if.then
  %28 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %ctx_field_size = bitcast %union.anon.208* %28 to i32*
  %29 = load i32, i32* %ctx_field_size, align 8
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 24
  %31 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %32 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %32 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %31, i64 %idxprom
  %ctx_field_size10 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 2
  store i32 %29, i32* %ctx_field_size10, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then7
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 2
  %34 = load %struct.bpf_prog*, %struct.bpf_prog** %prog11, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %34, i32 0, i32 10
  %35 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_ctx_offset = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %35, i32 0, i32 3
  %36 = load i32, i32* %max_ctx_offset, align 8
  %37 = load i32, i32* %off.addr, align 4
  %38 = load i32, i32* %size.addr, align 4
  %add = add i32 %37, %38
  %cmp12 = icmp ult i32 %36, %add
  br i1 %cmp12, label %if.then13, label %if.end18

if.then13:                                        ; preds = %if.end
  %39 = load i32, i32* %off.addr, align 4
  %40 = load i32, i32* %size.addr, align 4
  %add14 = add i32 %39, %40
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog15 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %41, i32 0, i32 2
  %42 = load %struct.bpf_prog*, %struct.bpf_prog** %prog15, align 8
  %aux16 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %42, i32 0, i32 10
  %43 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux16, align 8
  %max_ctx_offset17 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %43, i32 0, i32 3
  store i32 %add14, i32* %max_ctx_offset17, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then13, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end19:                                         ; preds = %land.lhs.true, %entry
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = bitcast %struct.bpf_verifier_env* %44 to i8*
  %46 = load i32, i32* %off.addr, align 4
  %47 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %45, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.179, i64 0, i64 0), i32 noundef %46, i32 noundef %47) #20
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end19, %if.end18
  %48 = load i32, i32* %retval, align 4
  ret i32 %48
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @verbose_linfo(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_off, i8* noundef %prefix_fmt, ...) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_off.addr = alloca i32, align 4
  %prefix_fmt.addr = alloca i8*, align 8
  %linfo = alloca %struct.bpf_line_info*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_off, i32* %insn_off.addr, align 4
  store i8* %prefix_fmt, i8** %prefix_fmt.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 26
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #20
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load i32, i32* %insn_off.addr, align 4
  %call1 = call %struct.bpf_line_info* @find_linfo(%struct.bpf_verifier_env* noundef %1, i32 noundef %2) #20
  store %struct.bpf_line_info* %call1, %struct.bpf_line_info** %linfo, align 8
  %3 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %tobool = icmp ne %struct.bpf_line_info* %3, null
  br i1 %tobool, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %4 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_linfo = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 25
  %6 = load %struct.bpf_line_info*, %struct.bpf_line_info** %prev_linfo, align 8
  %cmp = icmp eq %struct.bpf_line_info* %4, %6
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %7 = load i8*, i8** %prefix_fmt.addr, align 8
  %tobool4 = icmp ne i8* %7, null
  br i1 %tobool4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %if.end3
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay6 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay6)
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 26
  %9 = load i8*, i8** %prefix_fmt.addr, align 8
  %arraydecay8 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log7, i8* noundef %9, %struct.__va_list_tag* noundef %arraydecay8) #20
  %arraydecay9 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay910 = bitcast %struct.__va_list_tag* %arraydecay9 to i8*
  call void @llvm.va_end(i8* %arraydecay910)
  br label %if.end11

if.end11:                                         ; preds = %if.then5, %if.end3
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 2
  %13 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %13, i32 0, i32 10
  %14 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %14, i32 0, i32 50
  %15 = load %struct.btf*, %struct.btf** %btf, align 8
  %16 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %line_off = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %16, i32 0, i32 2
  %17 = load i32, i32* %line_off, align 4
  %call12 = call i8* @btf_name_by_offset(%struct.btf* noundef %15, i32 noundef %17) #20
  %call13 = call i8* @ltrim(i8* noundef %call12) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.180, i64 0, i64 0), i8* noundef %call13) #20
  %18 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_linfo14 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 25
  store %struct.bpf_line_info* %18, %struct.bpf_line_info** %prev_linfo14, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then2, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %0, 11
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %1, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  store i32 2305, i32* %__flags, align 4
  br label %do.body7

do.body7:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body7
  br label %do.body8

do.body8:                                         ; preds = %do.end
  %2 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1466, i32 %2, i64 12) #19, !srcloc !67
  br label %do.end9

do.end9:                                          ; preds = %do.body8
  br label %do.body10

do.body10:                                        ; preds = %do.end9
  br label %do.end11

do.end11:                                         ; preds = %do.body10
  br label %do.end12

do.end12:                                         ; preds = %do.end11
  br label %if.end

if.end:                                           ; preds = %do.end12, %entry
  %3 = load i32, i32* %__ret_warn_on, align 4
  %tobool13 = icmp ne i32 %3, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  store i64 %conv18, i64* %tmp, align 8
  %4 = load i64, i64* %tmp, align 8
  %tobool19 = icmp ne i64 %4, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = bitcast %struct.bpf_verifier_env* %5 to i8*
  %7 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %6, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.181, i64 0, i64 0), i32 noundef %7) #20
  store i32 0, i32* %regno.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then20
  %8 = load i32, i32* %regno.addr, align 4
  %cmp21 = icmp ult i32 %8, 11
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %11 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i64 %idx.ext
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %9, %struct.bpf_reg_state* noundef %add.ptr) #20
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %regno.addr, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %regno.addr, align 4
  br label %for.cond, !llvm.loop !68

for.end:                                          ; preds = %for.cond
  br label %return

if.end23:                                         ; preds = %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %14 = load i32, i32* %regno.addr, align 4
  %idx.ext24 = zext i32 %14 to i64
  %add.ptr25 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i64 %idx.ext24
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %add.ptr25) #20
  br label %return

return:                                           ; preds = %if.end23, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_read(%struct.bpf_verifier_env* noundef %env, i32 noundef %ptr_regno, i32 noundef %off, i32 noundef %size, i32 noundef %dst_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ptr_regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %dst_regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  %var_off = alloca i8, align 1
  %tn_buf = alloca [48 x i8], align 16
  %tn_buf11 = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %ptr_regno, i32* %ptr_regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %dst_regno, i32* %dst_regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %ptr_regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3) #20
  store %struct.bpf_func_state* %call1, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %5 = bitcast %struct.tnum* %var_off2 to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = load i64, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %call3 = call zeroext i1 @tnum_is_const(i64 %7, i64 %9) #20
  %lnot = xor i1 %call3, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %var_off, align 1
  %10 = load i32, i32* %dst_regno.addr, align 4
  %cmp = icmp slt i32 %10, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %11 = load i8, i8* %var_off, align 1
  %tobool = trunc i8 %11 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %13 = bitcast %struct.tnum* %var_off4 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call5 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %15, i64 %17) #20
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %arraydecay6 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %20 = load i32, i32* %off.addr, align 4
  %21 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([96 x i8], [96 x i8]* @.str.182, i64 0, i64 0), i8* noundef %arraydecay6, i32 noundef %20, i32 noundef %21) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 21
  %23 = load i8, i8* %bypass_spec_v1, align 1
  %tobool7 = trunc i8 %23 to i1
  br i1 %tobool7, label %if.end16, label %land.lhs.true8

land.lhs.true8:                                   ; preds = %if.end
  %24 = load i8, i8* %var_off, align 1
  %tobool9 = trunc i8 %24 to i1
  br i1 %tobool9, label %if.then10, label %if.end16

if.then10:                                        ; preds = %land.lhs.true8
  %arraydecay12 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf11, i64 0, i64 0
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 5
  %26 = bitcast %struct.tnum* %var_off13 to { i64, i64 }*
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 0
  %28 = load i64, i64* %27, align 8
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 1
  %30 = load i64, i64* %29, align 8
  %call14 = call i32 @tnum_strn(i8* noundef %arraydecay12, i64 noundef 48, i64 %28, i64 %30) #20
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = bitcast %struct.bpf_verifier_env* %31 to i8*
  %33 = load i32, i32* %ptr_regno.addr, align 4
  %arraydecay15 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf11, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %32, i8* noundef getelementptr inbounds ([67 x i8], [67 x i8]* @.str.183, i64 0, i64 0), i32 noundef %33, i8* noundef %arraydecay15) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %land.lhs.true8, %if.end
  %34 = load i8, i8* %var_off, align 1
  %tobool17 = trunc i8 %34 to i1
  br i1 %tobool17, label %if.else, label %if.then18

if.then18:                                        ; preds = %if.end16
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off19, i32 0, i32 0
  %36 = load i64, i64* %value, align 8
  %37 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %37 to i64
  %add = add i64 %conv, %36
  %conv20 = trunc i64 %add to i32
  store i32 %conv20, i32* %off.addr, align 4
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %40 = load i32, i32* %off.addr, align 4
  %41 = load i32, i32* %size.addr, align 4
  %42 = load i32, i32* %dst_regno.addr, align 4
  %call21 = call i32 @check_stack_read_fixed_off(%struct.bpf_verifier_env* noundef %38, %struct.bpf_func_state* noundef %39, i32 noundef %40, i32 noundef %41, i32 noundef %42) #20
  store i32 %call21, i32* %err, align 4
  br label %if.end23

if.else:                                          ; preds = %if.end16
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = load i32, i32* %ptr_regno.addr, align 4
  %45 = load i32, i32* %off.addr, align 4
  %46 = load i32, i32* %size.addr, align 4
  %47 = load i32, i32* %dst_regno.addr, align 4
  %call22 = call i32 @check_stack_read_var_off(%struct.bpf_verifier_env* noundef %43, i32 noundef %44, i32 noundef %45, i32 noundef %46, i32 noundef %47) #20
  store i32 %call22, i32* %err, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.then18
  %48 = load i32, i32* %err, align 4
  store i32 %48, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end23, %if.then10, %if.then
  %49 = load i32, i32* %retval, align 4
  ret i32 %49
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_write(%struct.bpf_verifier_env* noundef %env, i32 noundef %ptr_regno, i32 noundef %off, i32 noundef %size, i32 noundef %value_regno, i32 noundef %insn_idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ptr_regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %ptr_regno, i32* %ptr_regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %ptr_regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3) #20
  store %struct.bpf_func_state* %call1, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %5 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = load i64, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %7, i64 %9) #20
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off3, i32 0, i32 0
  %11 = load i64, i64* %value, align 8
  %12 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %12 to i64
  %add = add i64 %conv, %11
  %conv4 = trunc i64 %add to i32
  store i32 %conv4, i32* %off.addr, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %15 = load i32, i32* %off.addr, align 4
  %16 = load i32, i32* %size.addr, align 4
  %17 = load i32, i32* %value_regno.addr, align 4
  %18 = load i32, i32* %insn_idx.addr, align 4
  %call5 = call i32 @check_stack_write_fixed_off(%struct.bpf_verifier_env* noundef %13, %struct.bpf_func_state* noundef %14, i32 noundef %15, i32 noundef %16, i32 noundef %17, i32 noundef %18) #20
  store i32 %call5, i32* %err, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %21 = load i32, i32* %ptr_regno.addr, align 4
  %22 = load i32, i32* %off.addr, align 4
  %23 = load i32, i32* %size.addr, align 4
  %24 = load i32, i32* %value_regno.addr, align 4
  %25 = load i32, i32* %insn_idx.addr, align 4
  %call6 = call i32 @check_stack_write_var_off(%struct.bpf_verifier_env* noundef %19, %struct.bpf_func_state* noundef %20, i32 noundef %21, i32 noundef %22, i32 noundef %23, i32 noundef %24, i32 noundef %25) #20
  store i32 %call6, i32* %err, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %26 = load i32, i32* %err, align 4
  ret i32 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %call = call zeroext i1 @type_is_pkt_pointer(i32 noundef %1) #20
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_access_direct_pkt_data(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %t) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %t.addr = alloca i32, align 4
  %prog_type = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %1) #20
  store i32 %call, i32* %prog_type, align 4
  %2 = load i32, i32* %prog_type, align 4
  switch i32 %2, label %sw.default [
    i32 10, label %sw.bb
    i32 11, label %sw.bb
    i32 19, label %sw.bb
    i32 21, label %sw.bb
    i32 22, label %sw.bb
    i32 8, label %sw.bb
    i32 3, label %sw.bb1
    i32 4, label %sw.bb1
    i32 6, label %sw.bb1
    i32 12, label %sw.bb1
    i32 14, label %sw.bb1
    i32 16, label %sw.bb1
    i32 25, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry
  %3 = load i32, i32* %t.addr, align 4
  %cmp = icmp eq i32 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.bb1

sw.bb1:                                           ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %if.end
  %4 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool = icmp ne %struct.bpf_call_arg_meta* %4, null
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %sw.bb1
  %5 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %pkt_access = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %5, i32 0, i32 2
  %6 = load i8, i8* %pkt_access, align 1
  %tobool3 = trunc i8 %6 to i1
  store i1 %tobool3, i1* %retval, align 1
  br label %return

if.end4:                                          ; preds = %sw.bb1
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 23
  store i8 1, i8* %seen_direct_write, align 1
  store i1 true, i1* %retval, align 1
  br label %return

sw.bb5:                                           ; preds = %entry
  %8 = load i32, i32* %t.addr, align 4
  %cmp6 = icmp eq i32 %8, 2
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %sw.bb5
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write8 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 23
  store i8 1, i8* %seen_direct_write8, align 1
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %sw.bb5
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %if.end9, %if.end4, %if.then2, %if.then
  %10 = load i1, i1* %retval, align 1
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_flow_keys_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load i32, i32* %size.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp slt i32 %1, 0
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %2 to i64
  %3 = load i32, i32* %size.addr, align 4
  %conv3 = sext i32 %3 to i64
  %add = add i64 %conv, %conv3
  %cmp4 = icmp ugt i64 %add, 56
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %off.addr, align 4
  %7 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.192, i64 0, i64 0), i32 noundef %6, i32 noundef %7) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @type_is_sk_pointer(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 11
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 12
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 13
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp4 = icmp eq i32 %3, 15
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false2, %lor.lhs.false, %entry
  %4 = phi i1 [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp4, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_sock_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %t) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %info = alloca %struct.bpf_insn_access_aux, align 8
  %valid = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = bitcast %struct.bpf_insn_access_aux* %info to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %3, i8 0, i64 32, i1 false)
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 6
  %5 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  %8 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.117, i64 0, i64 0), i32 noundef %8) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 0
  %10 = load i32, i32* %type, align 8
  switch i32 %10, label %sw.default [
    i32 12, label %sw.bb
    i32 11, label %sw.bb2
    i32 13, label %sw.bb5
    i32 15, label %sw.bb8
  ]

sw.bb:                                            ; preds = %if.end
  %11 = load i32, i32* %off.addr, align 4
  %12 = load i32, i32* %size.addr, align 4
  %13 = load i32, i32* %t.addr, align 4
  %call1 = call zeroext i1 @bpf_sock_common_is_valid_access(i32 noundef %11, i32 noundef %12, i32 noundef %13, %struct.bpf_insn_access_aux* noundef %info) #20
  %frombool = zext i1 %call1 to i8
  store i8 %frombool, i8* %valid, align 1
  br label %sw.epilog

sw.bb2:                                           ; preds = %if.end
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  %16 = load i32, i32* %t.addr, align 4
  %call3 = call zeroext i1 @bpf_sock_is_valid_access(i32 noundef %14, i32 noundef %15, i32 noundef %16, %struct.bpf_insn_access_aux* noundef %info) #20
  %frombool4 = zext i1 %call3 to i8
  store i8 %frombool4, i8* %valid, align 1
  br label %sw.epilog

sw.bb5:                                           ; preds = %if.end
  %17 = load i32, i32* %off.addr, align 4
  %18 = load i32, i32* %size.addr, align 4
  %19 = load i32, i32* %t.addr, align 4
  %call6 = call zeroext i1 @bpf_tcp_sock_is_valid_access(i32 noundef %17, i32 noundef %18, i32 noundef %19, %struct.bpf_insn_access_aux* noundef %info) #20
  %frombool7 = zext i1 %call6 to i8
  store i8 %frombool7, i8* %valid, align 1
  br label %sw.epilog

sw.bb8:                                           ; preds = %if.end
  %20 = load i32, i32* %off.addr, align 4
  %21 = load i32, i32* %size.addr, align 4
  %22 = load i32, i32* %t.addr, align 4
  %call9 = call zeroext i1 @bpf_xdp_sock_is_valid_access(i32 noundef %20, i32 noundef %21, i32 noundef %22, %struct.bpf_insn_access_aux* noundef %info) #20
  %frombool10 = zext i1 %call9 to i8
  store i8 %frombool10, i8* %valid, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  store i8 0, i8* %valid, align 1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb8, %sw.bb5, %sw.bb2, %sw.bb
  %23 = load i8, i8* %valid, align 1
  %tobool = trunc i8 %23 to i1
  br i1 %tobool, label %if.then11, label %if.end15

if.then11:                                        ; preds = %sw.epilog
  %24 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %ctx_field_size = bitcast %union.anon.208* %24 to i32*
  %25 = load i32, i32* %ctx_field_size, align 8
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 24
  %27 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %28 = load i32, i32* %insn_idx.addr, align 4
  %idxprom12 = sext i32 %28 to i64
  %arrayidx13 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %27, i64 %idxprom12
  %ctx_field_size14 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx13, i32 0, i32 2
  store i32 %25, i32* %ctx_field_size14, align 8
  store i32 0, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %sw.epilog
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load i32, i32* %regno.addr, align 4
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 0
  %34 = load i32, i32* %type16, align 8
  %call17 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %32, i32 noundef %34) #20
  %35 = load i32, i32* %off.addr, align 4
  %36 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.193, i64 0, i64 0), i32 noundef %31, i8* noundef %call17, i32 noundef %35, i32 noundef %36) #20
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then11, %if.then
  %37 = load i32, i32* %retval, align 4
  ret i32 %37
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_tp_buffer_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %3 = load i32, i32* %off.addr, align 4
  %4 = load i32, i32* %size.addr, align 4
  %call = call i32 @__check_buffer_access(%struct.bpf_verifier_env* noundef %0, i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str.194, i64 0, i64 0), %struct.bpf_reg_state* noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) #20
  store i32 %call, i32* %err, align 4
  %5 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, i32* %err, align 4
  store i32 %6, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i32, i32* %off.addr, align 4
  %8 = load i32, i32* %size.addr, align 4
  %add = add i32 %7, %8
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 2
  %10 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %10, i32 0, i32 10
  %11 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_tp_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %11, i32 0, i32 5
  %12 = load i32, i32* %max_tp_access, align 8
  %cmp = icmp ugt i32 %add, %12
  br i1 %cmp, label %if.then1, label %if.end6

if.then1:                                         ; preds = %if.end
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size.addr, align 4
  %add2 = add i32 %13, %14
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 2
  %16 = load %struct.bpf_prog*, %struct.bpf_prog** %prog3, align 8
  %aux4 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %16, i32 0, i32 10
  %17 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux4, align 8
  %max_tp_access5 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %17, i32 0, i32 5
  store i32 %add2, i32* %max_tp_access5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then1, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ptr_to_btf_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %atype, i32 noundef %value_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %atype.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %t = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %flag = alloca i32, align 4
  %btf_id3 = alloca i32, align 4
  %ret = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %atype, i32* %atype.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 2
  %4 = bitcast %union.anon.168* %3 to %struct.anon.170*
  %btf = getelementptr inbounds %struct.anon.170, %struct.anon.170* %4, i32 0, i32 0
  %5 = load %struct.btf*, %struct.btf** %btf, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 2
  %8 = bitcast %union.anon.168* %7 to %struct.anon.170*
  %btf_id = getelementptr inbounds %struct.anon.170, %struct.anon.170* %8, i32 0, i32 1
  %9 = load i32, i32* %btf_id, align 8
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %5, i32 noundef %9) #20
  store %struct.btf_type* %call, %struct.btf_type** %t, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 2
  %12 = bitcast %union.anon.168* %11 to %struct.anon.170*
  %btf1 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %12, i32 0, i32 0
  %13 = load %struct.btf*, %struct.btf** %btf1, align 8
  %14 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %14, i32 0, i32 0
  %15 = load i32, i32* %name_off, align 4
  %call2 = call i8* @btf_name_by_offset(%struct.btf* noundef %13, i32 noundef %15) #20
  store i8* %call2, i8** %tname, align 8
  store i32 0, i32* %flag, align 4
  %16 = load i32, i32* %off.addr, align 4
  %cmp = icmp slt i32 %16, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  %19 = load i32, i32* %regno.addr, align 4
  %20 = load i8*, i8** %tname, align 8
  %21 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.195, i64 0, i64 0), i32 noundef %19, i8* noundef %20, i32 noundef %21) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 5
  %23 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  %call4 = call zeroext i1 @tnum_is_const(i64 %25, i64 %27) #20
  br i1 %call4, label %lor.lhs.false, label %if.then6

lor.lhs.false:                                    ; preds = %if.end
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %29 = load i64, i64* %value, align 8
  %tobool = icmp ne i64 %29, 0
  br i1 %tobool, label %if.then6, label %if.end10

if.then6:                                         ; preds = %lor.lhs.false, %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %31 = bitcast %struct.tnum* %var_off7 to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = load i64, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = load i64, i64* %34, align 8
  %call8 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %33, i64 %35) #20
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  %38 = load i32, i32* %regno.addr, align 4
  %39 = load i8*, i8** %tname, align 8
  %40 = load i32, i32* %off.addr, align 4
  %arraydecay9 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.196, i64 0, i64 0), i32 noundef %38, i8* noundef %39, i32 noundef %40, i8* noundef %arraydecay9) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %lor.lhs.false
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type, align 8
  %and = and i32 %42, 2048
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = bitcast %struct.bpf_verifier_env* %43 to i8*
  %45 = load i32, i32* %regno.addr, align 4
  %46 = load i8*, i8** %tname, align 8
  %47 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %44, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.197, i64 0, i64 0), i32 noundef %45, i8* noundef %46, i32 noundef %47) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end10
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 0
  %49 = load i32, i32* %type14, align 8
  %and15 = and i32 %49, 4096
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end13
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = bitcast %struct.bpf_verifier_env* %50 to i8*
  %52 = load i32, i32* %regno.addr, align 4
  %53 = load i8*, i8** %tname, align 8
  %54 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %51, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.198, i64 0, i64 0), i32 noundef %52, i8* noundef %53, i32 noundef %54) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end13
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %55, i32 0, i32 3
  %56 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %btf_struct_access = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %56, i32 0, i32 5
  %57 = load i32 (%struct.bpf_verifier_log*, %struct.btf*, %struct.btf_type*, i32, i32, i32, i32*, i32*)*, i32 (%struct.bpf_verifier_log*, %struct.btf*, %struct.btf_type*, i32, i32, i32, i32*, i32*)** %btf_struct_access, align 8
  %tobool19 = icmp ne i32 (%struct.bpf_verifier_log*, %struct.btf*, %struct.btf_type*, i32, i32, i32, i32*, i32*)* %57, null
  br i1 %tobool19, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.end18
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops21 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %58, i32 0, i32 3
  %59 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops21, align 8
  %btf_struct_access22 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %59, i32 0, i32 5
  %60 = load i32 (%struct.bpf_verifier_log*, %struct.btf*, %struct.btf_type*, i32, i32, i32, i32*, i32*)*, i32 (%struct.bpf_verifier_log*, %struct.btf*, %struct.btf_type*, i32, i32, i32, i32*, i32*)** %btf_struct_access22, align 8
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %61, i32 0, i32 26
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %63 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 2
  %64 = bitcast %union.anon.168* %63 to %struct.anon.170*
  %btf23 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %64, i32 0, i32 0
  %65 = load %struct.btf*, %struct.btf** %btf23, align 8
  %66 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %67 = load i32, i32* %off.addr, align 4
  %68 = load i32, i32* %size.addr, align 4
  %69 = load i32, i32* %atype.addr, align 4
  %call24 = call i32 %60(%struct.bpf_verifier_log* noundef %log, %struct.btf* noundef %65, %struct.btf_type* noundef %66, i32 noundef %67, i32 noundef %68, i32 noundef %69, i32* noundef %btf_id3, i32* noundef %flag) #20
  store i32 %call24, i32* %ret, align 4
  br label %if.end31

if.else:                                          ; preds = %if.end18
  %70 = load i32, i32* %atype.addr, align 4
  %cmp25 = icmp ne i32 %70, 1
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.else
  %71 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %72 = bitcast %struct.bpf_verifier_env* %71 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %72, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.199, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.else
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log28 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %73, i32 0, i32 26
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 2
  %76 = bitcast %union.anon.168* %75 to %struct.anon.170*
  %btf29 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %76, i32 0, i32 0
  %77 = load %struct.btf*, %struct.btf** %btf29, align 8
  %78 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %79 = load i32, i32* %off.addr, align 4
  %80 = load i32, i32* %size.addr, align 4
  %81 = load i32, i32* %atype.addr, align 4
  %call30 = call i32 @btf_struct_access(%struct.bpf_verifier_log* noundef %log28, %struct.btf* noundef %77, %struct.btf_type* noundef %78, i32 noundef %79, i32 noundef %80, i32 noundef %81, i32* noundef %btf_id3, i32* noundef %flag) #20
  store i32 %call30, i32* %ret, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.end27, %if.then20
  %82 = load i32, i32* %ret, align 4
  %cmp32 = icmp slt i32 %82, 0
  br i1 %cmp32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end31
  %83 = load i32, i32* %ret, align 4
  store i32 %83, i32* %retval, align 4
  br label %return

if.end34:                                         ; preds = %if.end31
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %84, i32 0, i32 0
  %85 = load i32, i32* %type35, align 8
  %call36 = call i32 @type_flag(i32 noundef %85) #20
  %and37 = and i32 %call36, 16384
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end34
  %86 = load i32, i32* %flag, align 4
  %or = or i32 %86, 16384
  store i32 %or, i32* %flag, align 4
  br label %if.end40

if.end40:                                         ; preds = %if.then39, %if.end34
  %87 = load i32, i32* %atype.addr, align 4
  %cmp41 = icmp eq i32 %87, 1
  br i1 %cmp41, label %land.lhs.true, label %if.end45

land.lhs.true:                                    ; preds = %if.end40
  %88 = load i32, i32* %value_regno.addr, align 4
  %cmp42 = icmp sge i32 %88, 0
  br i1 %cmp42, label %if.then43, label %if.end45

if.then43:                                        ; preds = %land.lhs.true
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %91 = load i32, i32* %value_regno.addr, align 4
  %92 = load i32, i32* %ret, align 4
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %94 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %93, i32 0, i32 2
  %95 = bitcast %union.anon.168* %94 to %struct.anon.170*
  %btf44 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %95, i32 0, i32 0
  %96 = load %struct.btf*, %struct.btf** %btf44, align 8
  %97 = load i32, i32* %btf_id3, align 4
  %98 = load i32, i32* %flag, align 4
  call void @mark_btf_ld_reg(%struct.bpf_verifier_env* noundef %89, %struct.bpf_reg_state* noundef %90, i32 noundef %91, i32 noundef %92, %struct.btf* noundef %96, i32 noundef %97, i32 noundef %98) #20
  br label %if.end45

if.end45:                                         ; preds = %if.then43, %land.lhs.true, %if.end40
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end45, %if.then33, %if.then26, %if.then17, %if.then12, %if.then6, %if.then
  %99 = load i32, i32* %retval, align 4
  ret i32 %99
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ptr_to_map_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %atype, i32 noundef %value_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %atype.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %flag = alloca i32, align 4
  %t = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %btf_id = alloca i32, align 4
  %ret = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %atype, i32* %atype.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 2
  %4 = bitcast %union.anon.168* %3 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %5, %struct.bpf_map** %map, align 8
  store i32 0, i32* %flag, align 4
  %6 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool = icmp ne %struct.btf* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = bitcast %struct.bpf_verifier_env* %7 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %8, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.200, i64 0, i64 0)) #20
  store i32 -524, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %9, i32 0, i32 0
  %10 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_btf_id = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %10, i32 0, i32 39
  %11 = load i32*, i32** %map_btf_id, align 8
  %tobool1 = icmp ne i32* %11, null
  br i1 %tobool1, label %lor.lhs.false, label %if.then5

lor.lhs.false:                                    ; preds = %if.end
  %12 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops2 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %12, i32 0, i32 0
  %13 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops2, align 64
  %map_btf_id3 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %13, i32 0, i32 39
  %14 = load i32*, i32** %map_btf_id3, align 8
  %15 = load i32, i32* %14, align 4
  %tobool4 = icmp ne i32 %15, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %18, i32 0, i32 3
  %19 = load i32, i32* %map_type, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.201, i64 0, i64 0), i32 noundef %19) #20
  store i32 -524, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  %20 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %21 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops7 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %21, i32 0, i32 0
  %22 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops7, align 64
  %map_btf_id8 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %22, i32 0, i32 39
  %23 = load i32*, i32** %map_btf_id8, align 8
  %24 = load i32, i32* %23, align 4
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %20, i32 noundef %24) #20
  store %struct.btf_type* %call, %struct.btf_type** %t, align 8
  %25 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %26 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %26, i32 0, i32 0
  %27 = load i32, i32* %name_off, align 4
  %call9 = call i8* @btf_name_by_offset(%struct.btf* noundef %25, i32 noundef %27) #20
  store i8* %call9, i8** %tname, align 8
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_to_map_access = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 19
  %29 = load i8, i8* %allow_ptr_to_map_access, align 1
  %tobool10 = trunc i8 %29 to i1
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end6
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load i8*, i8** %tname, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.202, i64 0, i64 0), i8* noundef %32) #20
  store i32 -1, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end6
  %33 = load i32, i32* %off.addr, align 4
  %cmp = icmp slt i32 %33, 0
  br i1 %cmp, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end12
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load i32, i32* %regno.addr, align 4
  %37 = load i8*, i8** %tname, align 8
  %38 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.203, i64 0, i64 0), i32 noundef %36, i8* noundef %37, i32 noundef %38) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end12
  %39 = load i32, i32* %atype.addr, align 4
  %cmp15 = icmp ne i32 %39, 1
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end14
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = bitcast %struct.bpf_verifier_env* %40 to i8*
  %42 = load i8*, i8** %tname, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %41, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.204, i64 0, i64 0), i8* noundef %42) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end14
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %43, i32 0, i32 26
  %44 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %45 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %46 = load i32, i32* %off.addr, align 4
  %47 = load i32, i32* %size.addr, align 4
  %48 = load i32, i32* %atype.addr, align 4
  %call18 = call i32 @btf_struct_access(%struct.bpf_verifier_log* noundef %log, %struct.btf* noundef %44, %struct.btf_type* noundef %45, i32 noundef %46, i32 noundef %47, i32 noundef %48, i32* noundef %btf_id, i32* noundef %flag) #20
  store i32 %call18, i32* %ret, align 4
  %49 = load i32, i32* %ret, align 4
  %cmp19 = icmp slt i32 %49, 0
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  %50 = load i32, i32* %ret, align 4
  store i32 %50, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end17
  %51 = load i32, i32* %value_regno.addr, align 4
  %cmp22 = icmp sge i32 %51, 0
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end21
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %54 = load i32, i32* %value_regno.addr, align 4
  %55 = load i32, i32* %ret, align 4
  %56 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %57 = load i32, i32* %btf_id, align 4
  %58 = load i32, i32* %flag, align 4
  call void @mark_btf_ld_reg(%struct.bpf_verifier_env* noundef %52, %struct.bpf_reg_state* noundef %53, i32 noundef %54, i32 noundef %55, %struct.btf* noundef %56, i32 noundef %57, i32 noundef %58) #20
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.end21
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end24, %if.then20, %if.then16, %if.then13, %if.then11, %if.then5, %if.then
  %59 = load i32, i32* %retval, align 4
  ret i32 %59
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %reg, i32 noundef %size) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %size.addr = alloca i32, align 4
  %mask = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = load i32, i32* %size.addr, align 4
  %conv = trunc i32 %2 to i8
  %3 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_cast(i64 %5, i64 %7, i8 noundef zeroext %conv) #20
  %8 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %13 = bitcast %struct.tnum* %var_off to i8*
  %14 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 %14, i64 16, i1 false)
  %15 = load i32, i32* %size.addr, align 4
  %mul = mul i32 %15, 8
  %sh_prom = zext i32 %mul to i64
  %shl = shl i64 1, %sh_prom
  %sub = sub i64 %shl, 1
  store i64 %sub, i64* %mask, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 8
  %17 = load i64, i64* %umin_value, align 8
  %18 = load i64, i64* %mask, align 8
  %neg = xor i64 %18, -1
  %and = and i64 %17, %neg
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 9
  %20 = load i64, i64* %umax_value, align 8
  %21 = load i64, i64* %mask, align 8
  %neg2 = xor i64 %21, -1
  %and3 = and i64 %20, %neg2
  %cmp = icmp eq i64 %and, %and3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %22 = load i64, i64* %mask, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 8
  %24 = load i64, i64* %umin_value5, align 8
  %and6 = and i64 %24, %22
  store i64 %and6, i64* %umin_value5, align 8
  %25 = load i64, i64* %mask, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  %27 = load i64, i64* %umax_value7, align 8
  %and8 = and i64 %27, %25
  store i64 %and8, i64* %umax_value7, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 8
  store i64 0, i64* %umin_value9, align 8
  %29 = load i64, i64* %mask, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 9
  store i64 %29, i64* %umax_value10, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 8
  %32 = load i64, i64* %umin_value11, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 6
  store i64 %32, i64* %smin_value, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 9
  %35 = load i64, i64* %umax_value12, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 7
  store i64 %35, i64* %smax_value, align 8
  %37 = load i32, i32* %size.addr, align 4
  %cmp13 = icmp sge i32 %37, 4
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end
  br label %return

if.end16:                                         ; preds = %if.end
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_combine_64_into_32(%struct.bpf_reg_state* noundef %38) #20
  br label %return

return:                                           ; preds = %if.end16, %if.then15
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_pkt_ptr_alignment(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %strict) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %strict.addr = alloca i8, align 1
  %reg_off = alloca %struct.tnum, align 8
  %ip_align = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %strict to i8
  store i8 %frombool, i8* %strict.addr, align 1
  %0 = load i8, i8* %strict.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i32 2, i32* %ip_align, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = load i32, i32* %ip_align, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 1
  %5 = load i32, i32* %off1, align 4
  %add = add i32 %3, %5
  %6 = load i32, i32* %off.addr, align 4
  %add2 = add i32 %add, %6
  %conv = sext i32 %add2 to i64
  %call = call { i64, i64 } @tnum_const(i64 noundef %conv) #20
  %7 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = extractvalue { i64, i64 } %call, 0
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = extractvalue { i64, i64 } %call, 1
  store i64 %11, i64* %10, align 8
  %12 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = load i64, i64* %13, align 8
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %17 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = load i64, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = load i64, i64* %20, align 8
  %call3 = call { i64, i64 } @tnum_add(i64 %14, i64 %16, i64 %19, i64 %21) #20
  %22 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %22, i32 0, i32 0
  %24 = extractvalue { i64, i64 } %call3, 0
  store i64 %24, i64* %23, align 8
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %22, i32 0, i32 1
  %26 = extractvalue { i64, i64 } %call3, 1
  store i64 %26, i64* %25, align 8
  %27 = bitcast %struct.tnum* %reg_off to i8*
  %28 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %27, i8* align 8 %28, i64 16, i1 false)
  %29 = load i32, i32* %size.addr, align 4
  %conv4 = sext i32 %29 to i64
  %30 = bitcast %struct.tnum* %reg_off to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call5 = call zeroext i1 @tnum_is_aligned(i64 %32, i64 %34, i64 noundef %conv4) #20
  br i1 %call5, label %if.end11, label %if.then6

if.then6:                                         ; preds = %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off7 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call8 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %38, i64 %40) #20
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load i32, i32* %ip_align, align 4
  %arraydecay9 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 1
  %45 = load i32, i32* %off10, align 4
  %46 = load i32, i32* %off.addr, align 4
  %47 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.168, i64 0, i64 0), i32 noundef %43, i8* noundef %arraydecay9, i32 noundef %45, i32 noundef %46, i32 noundef %47) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then6, %if.then
  %48 = load i32, i32* %retval, align 4
  ret i32 %48
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_generic_ptr_alignment(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i8* noundef %pointer_desc, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %strict) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %pointer_desc.addr = alloca i8*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %strict.addr = alloca i8, align 1
  %reg_off = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i8* %pointer_desc, i8** %pointer_desc.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %strict to i8
  store i8 %frombool, i8* %strict.addr, align 1
  %0 = load i8, i8* %strict.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 1
  %4 = load i32, i32* %off1, align 4
  %5 = load i32, i32* %off.addr, align 4
  %add = add i32 %4, %5
  %conv = sext i32 %add to i64
  %call = call { i64, i64 } @tnum_const(i64 noundef %conv) #20
  %6 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %16 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call2 = call { i64, i64 } @tnum_add(i64 %13, i64 %15, i64 %18, i64 %20) #20
  %21 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 0
  %23 = extractvalue { i64, i64 } %call2, 0
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 1
  %25 = extractvalue { i64, i64 } %call2, 1
  store i64 %25, i64* %24, align 8
  %26 = bitcast %struct.tnum* %reg_off to i8*
  %27 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %26, i8* align 8 %27, i64 16, i1 false)
  %28 = load i32, i32* %size.addr, align 4
  %conv3 = sext i32 %28 to i64
  %29 = bitcast %struct.tnum* %reg_off to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call4 = call zeroext i1 @tnum_is_aligned(i64 %31, i64 %33, i64 noundef %conv3) #20
  br i1 %call4, label %if.end10, label %if.then5

if.then5:                                         ; preds = %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 5
  %35 = bitcast %struct.tnum* %var_off6 to { i64, i64 }*
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 0
  %37 = load i64, i64* %36, align 8
  %38 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 1
  %39 = load i64, i64* %38, align 8
  %call7 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %37, i64 %39) #20
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = bitcast %struct.bpf_verifier_env* %40 to i8*
  %42 = load i8*, i8** %pointer_desc.addr, align 8
  %arraydecay8 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 1
  %44 = load i32, i32* %off9, align 4
  %45 = load i32, i32* %off.addr, align 4
  %46 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %41, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.169, i64 0, i64 0), i8* noundef %42, i8* noundef %arraydecay8, i32 noundef %44, i32 noundef %45, i32 noundef %46) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then5, %if.then
  %47 = load i32, i32* %retval, align 4
  ret i32 %47
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_add(i64, i64, i64, i64) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_const(i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @tnum_is_aligned(i64, i64, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__is_pointer_value(i1 noundef zeroext %allow_ptr_leaks, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %retval = alloca i1, align 1
  %allow_ptr_leaks.addr = alloca i8, align 1
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %frombool = zext i1 %allow_ptr_leaks to i8
  store i8 %frombool, i8* %allow_ptr_leaks.addr, align 1
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load i8, i8* %allow_ptr_leaks.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  %2 = load i32, i32* %type, align 8
  %cmp = icmp ne i32 %2, 1
  store i1 %cmp, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i1, i1* %retval, align 1
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_btf_ld_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno, i32 noundef %reg_type, %struct.btf* noundef %btf, i32 noundef %btf_id, i32 noundef %flag) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %reg_type.addr = alloca i32, align 4
  %btf.addr = alloca %struct.btf*, align 8
  %btf_id.addr = alloca i32, align 4
  %flag.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %reg_type, i32* %reg_type.addr, align 4
  store %struct.btf* %btf, %struct.btf** %btf.addr, align 8
  store i32 %btf_id, i32* %btf_id.addr, align 4
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load i32, i32* %reg_type.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %3 = load i32, i32* %regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %1, %struct.bpf_reg_state* noundef %2, i32 noundef %3) #20
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %6 = load i32, i32* %regno.addr, align 4
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %4, %struct.bpf_reg_state* noundef %5, i32 noundef %6) #20
  %7 = load i32, i32* %flag.addr, align 4
  %or = or i32 16, %7
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %9 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i64 %idxprom
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  store i32 %or, i32* %type, align 8
  %10 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %idxprom1 = zext i32 %12 to i64
  %arrayidx2 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i64 %idxprom1
  %13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx2, i32 0, i32 2
  %14 = bitcast %union.anon.168* %13 to %struct.anon.170*
  %btf3 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %14, i32 0, i32 0
  store %struct.btf* %10, %struct.btf** %btf3, align 8
  %15 = load i32, i32* %btf_id.addr, align 4
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %17 = load i32, i32* %regno.addr, align 4
  %idxprom4 = zext i32 %17 to i64
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i64 %idxprom4
  %18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx5, i32 0, i32 2
  %19 = bitcast %union.anon.168* %18 to %struct.anon.170*
  %btf_id6 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %19, i32 0, i32 1
  store i32 %15, i32* %btf_id6, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @map_kptr_match_type(%struct.bpf_verifier_env* noundef %env, %struct.bpf_map_value_off_desc* noundef %off_desc, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off_desc.addr = alloca %struct.bpf_map_value_off_desc*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %targ_name = alloca i8*, align 8
  %perm_flags = alloca i32, align 4
  %reg_name = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_map_value_off_desc* %off_desc, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %kptr = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %0, i32 0, i32 2
  %btf = getelementptr inbounds %struct.anon.175, %struct.anon.175* %kptr, i32 0, i32 0
  %1 = load %struct.btf*, %struct.btf** %btf, align 8
  %2 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %kptr1 = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %2, i32 0, i32 2
  %btf_id = getelementptr inbounds %struct.anon.175, %struct.anon.175* %kptr1, i32 0, i32 3
  %3 = load i32, i32* %btf_id, align 8
  %call = call i8* @kernel_type_name(%struct.btf* noundef %1, i32 noundef %3) #20
  store i8* %call, i8** %targ_name, align 8
  store i32 256, i32* %perm_flags, align 4
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i64 0, i64 0), i8** %reg_name, align 8
  %4 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %type = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %4, i32 0, i32 1
  %5 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, i32* %perm_flags, align 4
  %or = or i32 %6, 16384
  store i32 %or, i32* %perm_flags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 0
  %8 = load i32, i32* %type2, align 8
  %call3 = call i32 @base_type(i32 noundef %8) #20
  %cmp4 = icmp ne i32 %call3, 16
  br i1 %cmp4, label %if.then7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 0
  %10 = load i32, i32* %type5, align 8
  %call6 = call i32 @type_flag(i32 noundef %10) #20
  %11 = load i32, i32* %perm_flags, align 4
  %neg = xor i32 %11, -1
  %and = and i32 %call6, %neg
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then7, label %if.end8

if.then7:                                         ; preds = %lor.lhs.false, %if.end
  br label %bad_type

if.end8:                                          ; preds = %lor.lhs.false
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 2
  %14 = bitcast %union.anon.168* %13 to %struct.anon.170*
  %btf9 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %14, i32 0, i32 0
  %15 = load %struct.btf*, %struct.btf** %btf9, align 8
  %call10 = call zeroext i1 @btf_is_kernel(%struct.btf* noundef %15) #20
  br i1 %call10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.175, i64 0, i64 0), i32 noundef %18) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 2
  %21 = bitcast %union.anon.168* %20 to %struct.anon.170*
  %btf13 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %21, i32 0, i32 0
  %22 = load %struct.btf*, %struct.btf** %btf13, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 2
  %25 = bitcast %union.anon.168* %24 to %struct.anon.170*
  %btf_id14 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %25, i32 0, i32 1
  %26 = load i32, i32* %btf_id14, align 8
  %call15 = call i8* @kernel_type_name(%struct.btf* noundef %22, i32 noundef %26) #20
  store i8* %call15, i8** %reg_name, align 8
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %29 = load i32, i32* %regno.addr, align 4
  %call16 = call i32 @__check_ptr_off_reg(%struct.bpf_verifier_env* noundef %27, %struct.bpf_reg_state* noundef %28, i32 noundef %29, i1 noundef zeroext true) #20
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end12
  store i32 -13, i32* %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end12
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 26
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %32 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 2
  %33 = bitcast %union.anon.168* %32 to %struct.anon.170*
  %btf20 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %33, i32 0, i32 0
  %34 = load %struct.btf*, %struct.btf** %btf20, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %36 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 2
  %37 = bitcast %union.anon.168* %36 to %struct.anon.170*
  %btf_id21 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %37, i32 0, i32 1
  %38 = load i32, i32* %btf_id21, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 1
  %40 = load i32, i32* %off, align 4
  %41 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %kptr22 = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %41, i32 0, i32 2
  %btf23 = getelementptr inbounds %struct.anon.175, %struct.anon.175* %kptr22, i32 0, i32 0
  %42 = load %struct.btf*, %struct.btf** %btf23, align 8
  %43 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %kptr24 = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %43, i32 0, i32 2
  %btf_id25 = getelementptr inbounds %struct.anon.175, %struct.anon.175* %kptr24, i32 0, i32 3
  %44 = load i32, i32* %btf_id25, align 8
  %45 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %type26 = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %45, i32 0, i32 1
  %46 = load i32, i32* %type26, align 4
  %cmp27 = icmp eq i32 %46, 1
  %call28 = call zeroext i1 @btf_struct_ids_match(%struct.bpf_verifier_log* noundef %log, %struct.btf* noundef %34, i32 noundef %38, i32 noundef %40, %struct.btf* noundef %42, i32 noundef %44, i1 noundef zeroext %cmp27) #20
  br i1 %call28, label %if.end30, label %if.then29

if.then29:                                        ; preds = %if.end19
  br label %bad_type

if.end30:                                         ; preds = %if.end19
  store i32 0, i32* %retval, align 4
  br label %return

bad_type:                                         ; preds = %if.then29, %if.then7
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = bitcast %struct.bpf_verifier_env* %47 to i8*
  %49 = load i32, i32* %regno.addr, align 4
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %51, i32 0, i32 0
  %52 = load i32, i32* %type31, align 8
  %call32 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %50, i32 noundef %52) #20
  %53 = load i8*, i8** %reg_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %48, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.176, i64 0, i64 0), i32 noundef %49, i8* noundef %call32, i8* noundef %53) #20
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call33 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %56, i32 noundef 16) #20
  %57 = load i8*, i8** %targ_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.177, i64 0, i64 0), i8* noundef %call33, i8* noundef %57) #20
  %58 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc.addr, align 8
  %type34 = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %58, i32 0, i32 1
  %59 = load i32, i32* %type34, align 4
  %cmp35 = icmp eq i32 %59, 0
  br i1 %cmp35, label %if.then36, label %if.else

if.then36:                                        ; preds = %bad_type
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = bitcast %struct.bpf_verifier_env* %60 to i8*
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call37 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %62, i32 noundef 16400) #20
  %63 = load i8*, i8** %targ_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %61, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.178, i64 0, i64 0), i8* noundef %call37, i8* noundef %63) #20
  br label %if.end38

if.else:                                          ; preds = %bad_type
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = bitcast %struct.bpf_verifier_env* %64 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %65, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.4, i64 0, i64 0)) #20
  br label %if.end38

if.end38:                                         ; preds = %if.else, %if.then36
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end38, %if.end30, %if.then18, %if.then11
  %66 = load i32, i32* %retval, align 4
  ret i32 %66
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @type_flag(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %conv = zext i32 %0 to i64
  %and = and i64 %conv, -256
  %conv1 = trunc i64 %and to i32
  ret i32 %conv1
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @btf_is_kernel(%struct.btf* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @btf_struct_ids_match(%struct.bpf_verifier_log* noundef, %struct.btf* noundef, i32 noundef, i32 noundef, %struct.btf* noundef, i32 noundef, i1 noundef zeroext) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_map_write_active(%struct.bpf_map* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @___mark_reg_known(%struct.bpf_reg_state* noundef %reg, i64 noundef %imm) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %imm.addr = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %imm, i64* %imm.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load i64, i64* %imm.addr, align 8
  %call = call { i64, i64 } @tnum_const(i64 noundef %1) #20
  %2 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call, 1
  store i64 %6, i64* %5, align 8
  %7 = bitcast %struct.tnum* %var_off to i8*
  %8 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %8, i64 16, i1 false)
  %9 = load i64, i64* %imm.addr, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  store i64 %9, i64* %smin_value, align 8
  %11 = load i64, i64* %imm.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  store i64 %11, i64* %smax_value, align 8
  %13 = load i64, i64* %imm.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 8
  store i64 %13, i64* %umin_value, align 8
  %15 = load i64, i64* %imm.addr, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 9
  store i64 %15, i64* %umax_value, align 8
  %17 = load i64, i64* %imm.addr, align 8
  %conv = trunc i64 %17 to i32
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 10
  store i32 %conv, i32* %s32_min_value, align 8
  %19 = load i64, i64* %imm.addr, align 8
  %conv1 = trunc i64 %19 to i32
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 11
  store i32 %conv1, i32* %s32_max_value, align 4
  %21 = load i64, i64* %imm.addr, align 8
  %conv2 = trunc i64 %21 to i32
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 12
  store i32 %conv2, i32* %u32_min_value, align 8
  %23 = load i64, i64* %imm.addr, align 8
  %conv3 = trunc i64 %23 to i32
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 13
  store i32 %conv3, i32* %u32_max_value, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_line_info* @find_linfo(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_off) #0 {
entry:
  %retval = alloca %struct.bpf_line_info*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_off.addr = alloca i32, align 4
  %linfo = alloca %struct.bpf_line_info*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %i = alloca i32, align 4
  %nr_linfo = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_off, i32* %insn_off.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %nr_linfo2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 56
  %4 = load i32, i32* %nr_linfo2, align 4
  store i32 %4, i32* %nr_linfo, align 4
  %5 = load i32, i32* %nr_linfo, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %6 = load i32, i32* %insn_off.addr, align 4
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 4
  %8 = load i32, i32* %len, align 4
  %cmp = icmp uge i32 %6, %8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store %struct.bpf_line_info* null, %struct.bpf_line_info** %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %9, i32 0, i32 10
  %10 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %linfo4 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %10, i32 0, i32 53
  %11 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo4, align 8
  store %struct.bpf_line_info* %11, %struct.bpf_line_info** %linfo, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %12 = load i32, i32* %i, align 4
  %13 = load i32, i32* %nr_linfo, align 4
  %cmp5 = icmp ult i32 %12, %13
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load i32, i32* %insn_off.addr, align 4
  %15 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom = zext i32 %16 to i64
  %arrayidx = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %15, i64 %idxprom
  %insn_off6 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx, i32 0, i32 0
  %17 = load i32, i32* %insn_off6, align 4
  %cmp7 = icmp ult i32 %14, %17
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.body
  br label %for.end

if.end9:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !69

for.end:                                          ; preds = %if.then8, %for.cond
  %19 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %20 = load i32, i32* %i, align 4
  %sub = sub i32 %20, 1
  %idxprom10 = zext i32 %sub to i64
  %arrayidx11 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %19, i64 %idxprom10
  store %struct.bpf_line_info* %arrayidx11, %struct.bpf_line_info** %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  %21 = load %struct.bpf_line_info*, %struct.bpf_line_info** %retval, align 8
  ret %struct.bpf_line_info* %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @ltrim(i8* noundef %s) #0 {
entry:
  %s.addr = alloca i8*, align 8
  store i8* %s, i8** %s.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i8*, i8** %s.addr, align 8
  %1 = load i8, i8* %0, align 1
  %conv = zext i8 %1 to i32
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1
  %conv1 = zext i8 %2 to i32
  %and = and i32 %conv1, 32
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i8*, i8** %s.addr, align 8
  %incdec.ptr = getelementptr i8, i8* %3, i32 1
  store i8* %incdec.ptr, i8** %s.addr, align 8
  br label %while.cond, !llvm.loop !70

while.end:                                        ; preds = %while.cond
  %4 = load i8*, i8** %s.addr, align 8
  ret i8* %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_read_fixed_off(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %reg_state, i32 noundef %off, i32 noundef %size, i32 noundef %dst_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg_state.addr = alloca %struct.bpf_func_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %dst_regno.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %stype = alloca i8*, align 8
  %type = alloca i8, align 1
  %spill_size = alloca i8, align 1
  %subreg_def = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %reg_state, %struct.bpf_func_state** %reg_state.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %dst_regno, i32* %dst_regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %6
  %sub1 = sub i32 %sub, 1
  store i32 %sub1, i32* %slot, align 4
  %7 = load i32, i32* %slot, align 4
  %div = sdiv i32 %7, 8
  store i32 %div, i32* %spi, align 4
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 11
  %9 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %10 = load i32, i32* %spi, align 4
  %idxprom2 = sext i32 %10 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %9, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  store i8* %arraydecay, i8** %stype, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %stack4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 11
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack4, align 8
  %13 = load i32, i32* %spi, align 4
  %idxprom5 = sext i32 %13 to i64
  %arrayidx6 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom5
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx6, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %reg, align 8
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %stack7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 11
  %15 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack7, align 8
  %16 = load i32, i32* %spi, align 4
  %idxprom8 = sext i32 %16 to i64
  %arrayidx9 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %15, i64 %idxprom8
  %call = call zeroext i1 @is_spilled_reg(%struct.bpf_stack_state* noundef %arrayidx9) #20
  br i1 %call, label %if.then, label %if.else91

if.then:                                          ; preds = %entry
  store i8 1, i8* %spill_size, align 1
  store i32 7, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %17 = load i32, i32* %i, align 4
  %cmp = icmp sgt i32 %17, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %18 = load i8*, i8** %stype, align 8
  %19 = load i32, i32* %i, align 4
  %sub10 = sub i32 %19, 1
  %idxprom11 = sext i32 %sub10 to i64
  %arrayidx12 = getelementptr i8, i8* %18, i64 %idxprom11
  %20 = load i8, i8* %arrayidx12, align 1
  %conv = zext i8 %20 to i32
  %cmp13 = icmp eq i32 %conv, 1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %21 = phi i1 [ false, %for.cond ], [ %cmp13, %land.rhs ]
  br i1 %21, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %22 = load i8, i8* %spill_size, align 1
  %inc = add i8 %22, 1
  store i8 %inc, i8* %spill_size, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, i32* %i, align 4
  %dec = add i32 %23, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond, !llvm.loop !71

for.end:                                          ; preds = %land.end
  %24 = load i32, i32* %size.addr, align 4
  %cmp15 = icmp ne i32 %24, 8
  br i1 %cmp15, label %if.then20, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end
  %25 = load i8, i8* %spill_size, align 1
  %conv17 = zext i8 %25 to i32
  %cmp18 = icmp ne i32 %conv17, 8
  br i1 %cmp18, label %if.then20, label %if.end71

if.then20:                                        ; preds = %lor.lhs.false, %for.end
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 0
  %27 = load i32, i32* %type21, align 8
  %cmp22 = icmp ne i32 %27, 1
  br i1 %cmp22, label %if.then24, label %if.end

if.then24:                                        ; preds = %if.then20
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 0
  %30 = load i32, i32* %insn_idx, align 8
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %28, i32 noundef %30, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.155, i64 0, i64 0)) #20
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = bitcast %struct.bpf_verifier_env* %31 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %32, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.184, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then20
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 14
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %call25 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %33, %struct.bpf_reg_state* noundef %34, %struct.bpf_reg_state* noundef %36, i8 noundef zeroext 2) #20
  %37 = load i32, i32* %dst_regno.addr, align 4
  %cmp26 = icmp slt i32 %37, 0
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %if.end
  %38 = load i32, i32* %off.addr, align 4
  %rem = srem i32 %38, 8
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end29
  %39 = load i32, i32* %size.addr, align 4
  %40 = load i8, i8* %spill_size, align 1
  %conv30 = zext i8 %40 to i32
  %cmp31 = icmp eq i32 %39, %conv30
  br i1 %cmp31, label %if.then33, label %if.else

if.then33:                                        ; preds = %land.lhs.true
  %41 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %41, i32 0, i32 0
  %42 = load i32, i32* %dst_regno.addr, align 4
  %idxprom34 = sext i32 %42 to i64
  %arrayidx35 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom34
  %subreg_def36 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx35, i32 0, i32 16
  %43 = load i32, i32* %subreg_def36, align 4
  store i32 %43, i32* %subreg_def, align 4
  %44 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs37 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %44, i32 0, i32 0
  %45 = load i32, i32* %dst_regno.addr, align 4
  %idxprom38 = sext i32 %45 to i64
  %arrayidx39 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs37, i64 0, i64 %idxprom38
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %47 = bitcast %struct.bpf_reg_state* %arrayidx39 to i8*
  %48 = bitcast %struct.bpf_reg_state* %46 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %47, i8* align 8 %48, i64 120, i1 false)
  %49 = load i32, i32* %subreg_def, align 4
  %50 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs40 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %50, i32 0, i32 0
  %51 = load i32, i32* %dst_regno.addr, align 4
  %idxprom41 = sext i32 %51 to i64
  %arrayidx42 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs40, i64 0, i64 %idxprom41
  %subreg_def43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx42, i32 0, i32 16
  store i32 %49, i32* %subreg_def43, align 4
  br label %if.end67

if.else:                                          ; preds = %land.lhs.true, %if.end29
  store i32 0, i32* %i, align 4
  br label %for.cond44

for.cond44:                                       ; preds = %for.inc62, %if.else
  %52 = load i32, i32* %i, align 4
  %53 = load i32, i32* %size.addr, align 4
  %cmp45 = icmp slt i32 %52, %53
  br i1 %cmp45, label %for.body47, label %for.end64

for.body47:                                       ; preds = %for.cond44
  %54 = load i8*, i8** %stype, align 8
  %55 = load i32, i32* %slot, align 4
  %56 = load i32, i32* %i, align 4
  %sub48 = sub i32 %55, %56
  %rem49 = srem i32 %sub48, 8
  %idxprom50 = sext i32 %rem49 to i64
  %arrayidx51 = getelementptr i8, i8* %54, i64 %idxprom50
  %57 = load i8, i8* %arrayidx51, align 1
  store i8 %57, i8* %type, align 1
  %58 = load i8, i8* %type, align 1
  %conv52 = zext i8 %58 to i32
  %cmp53 = icmp eq i32 %conv52, 1
  br i1 %cmp53, label %if.then55, label %if.end56

if.then55:                                        ; preds = %for.body47
  br label %for.inc62

if.end56:                                         ; preds = %for.body47
  %59 = load i8, i8* %type, align 1
  %conv57 = zext i8 %59 to i32
  %cmp58 = icmp eq i32 %conv57, 2
  br i1 %cmp58, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.end56
  br label %for.inc62

if.end61:                                         ; preds = %if.end56
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = bitcast %struct.bpf_verifier_env* %60 to i8*
  %62 = load i32, i32* %off.addr, align 4
  %63 = load i32, i32* %i, align 4
  %64 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %61, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.185, i64 0, i64 0), i32 noundef %62, i32 noundef %63, i32 noundef %64) #20
  store i32 -13, i32* %retval, align 4
  br label %return

for.inc62:                                        ; preds = %if.then60, %if.then55
  %65 = load i32, i32* %i, align 4
  %inc63 = add i32 %65, 1
  store i32 %inc63, i32* %i, align 4
  br label %for.cond44, !llvm.loop !72

for.end64:                                        ; preds = %for.cond44
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs65 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %67, i32 0, i32 0
  %arraydecay66 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs65, i64 0, i64 0
  %68 = load i32, i32* %dst_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %66, %struct.bpf_reg_state* noundef %arraydecay66, i32 noundef %68) #20
  br label %if.end67

if.end67:                                         ; preds = %for.end64, %if.then33
  %69 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs68 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %69, i32 0, i32 0
  %70 = load i32, i32* %dst_regno.addr, align 4
  %idxprom69 = sext i32 %70 to i64
  %arrayidx70 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs68, i64 0, i64 %idxprom69
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx70, i32 0, i32 17
  %71 = load i32, i32* %live, align 8
  %or = or i32 %71, 4
  store i32 %or, i32* %live, align 8
  store i32 0, i32* %retval, align 4
  br label %return

if.end71:                                         ; preds = %lor.lhs.false
  %72 = load i32, i32* %dst_regno.addr, align 4
  %cmp72 = icmp sge i32 %72, 0
  br i1 %cmp72, label %if.then74, label %if.else83

if.then74:                                        ; preds = %if.end71
  %73 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs75 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %73, i32 0, i32 0
  %74 = load i32, i32* %dst_regno.addr, align 4
  %idxprom76 = sext i32 %74 to i64
  %arrayidx77 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs75, i64 0, i64 %idxprom76
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %76 = bitcast %struct.bpf_reg_state* %arrayidx77 to i8*
  %77 = bitcast %struct.bpf_reg_state* %75 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %76, i8* align 8 %77, i64 120, i1 false)
  %78 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs78 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %78, i32 0, i32 0
  %79 = load i32, i32* %dst_regno.addr, align 4
  %idxprom79 = sext i32 %79 to i64
  %arrayidx80 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs78, i64 0, i64 %idxprom79
  %live81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx80, i32 0, i32 17
  %80 = load i32, i32* %live81, align 8
  %or82 = or i32 %80, 4
  store i32 %or82, i32* %live81, align 8
  br label %if.end88

if.else83:                                        ; preds = %if.end71
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %81, i32 0, i32 17
  %82 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool84 = trunc i8 %82 to i1
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call85 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext %tobool84, %struct.bpf_reg_state* noundef %83) #20
  br i1 %call85, label %if.then86, label %if.end87

if.then86:                                        ; preds = %if.else83
  %84 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %85 = bitcast %struct.bpf_verifier_env* %84 to i8*
  %86 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %85, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.186, i64 0, i64 0), i32 noundef %86) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end87:                                         ; preds = %if.else83
  br label %if.end88

if.end88:                                         ; preds = %if.end87, %if.then74
  %87 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %89 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent89 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %89, i32 0, i32 14
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent89, align 8
  %call90 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %87, %struct.bpf_reg_state* noundef %88, %struct.bpf_reg_state* noundef %90, i8 noundef zeroext 2) #20
  br label %if.end119

if.else91:                                        ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond92

for.cond92:                                       ; preds = %for.inc110, %if.else91
  %91 = load i32, i32* %i, align 4
  %92 = load i32, i32* %size.addr, align 4
  %cmp93 = icmp slt i32 %91, %92
  br i1 %cmp93, label %for.body95, label %for.end112

for.body95:                                       ; preds = %for.cond92
  %93 = load i8*, i8** %stype, align 8
  %94 = load i32, i32* %slot, align 4
  %95 = load i32, i32* %i, align 4
  %sub96 = sub i32 %94, %95
  %rem97 = srem i32 %sub96, 8
  %idxprom98 = sext i32 %rem97 to i64
  %arrayidx99 = getelementptr i8, i8* %93, i64 %idxprom98
  %96 = load i8, i8* %arrayidx99, align 1
  store i8 %96, i8* %type, align 1
  %97 = load i8, i8* %type, align 1
  %conv100 = zext i8 %97 to i32
  %cmp101 = icmp eq i32 %conv100, 2
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %for.body95
  br label %for.inc110

if.end104:                                        ; preds = %for.body95
  %98 = load i8, i8* %type, align 1
  %conv105 = zext i8 %98 to i32
  %cmp106 = icmp eq i32 %conv105, 3
  br i1 %cmp106, label %if.then108, label %if.end109

if.then108:                                       ; preds = %if.end104
  br label %for.inc110

if.end109:                                        ; preds = %if.end104
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %100 = bitcast %struct.bpf_verifier_env* %99 to i8*
  %101 = load i32, i32* %off.addr, align 4
  %102 = load i32, i32* %i, align 4
  %103 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %100, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.185, i64 0, i64 0), i32 noundef %101, i32 noundef %102, i32 noundef %103) #20
  store i32 -13, i32* %retval, align 4
  br label %return

for.inc110:                                       ; preds = %if.then108, %if.then103
  %104 = load i32, i32* %i, align 4
  %inc111 = add i32 %104, 1
  store i32 %inc111, i32* %i, align 4
  br label %for.cond92, !llvm.loop !73

for.end112:                                       ; preds = %for.cond92
  %105 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %106 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %107 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent113 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %107, i32 0, i32 14
  %108 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent113, align 8
  %call114 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %105, %struct.bpf_reg_state* noundef %106, %struct.bpf_reg_state* noundef %108, i8 noundef zeroext 2) #20
  %109 = load i32, i32* %dst_regno.addr, align 4
  %cmp115 = icmp sge i32 %109, 0
  br i1 %cmp115, label %if.then117, label %if.end118

if.then117:                                       ; preds = %for.end112
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %111 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %112 = load i32, i32* %off.addr, align 4
  %113 = load i32, i32* %off.addr, align 4
  %114 = load i32, i32* %size.addr, align 4
  %add = add i32 %113, %114
  %115 = load i32, i32* %dst_regno.addr, align 4
  call void @mark_reg_stack_read(%struct.bpf_verifier_env* noundef %110, %struct.bpf_func_state* noundef %111, i32 noundef %112, i32 noundef %add, i32 noundef %115) #20
  br label %if.end118

if.end118:                                        ; preds = %if.then117, %for.end112
  br label %if.end119

if.end119:                                        ; preds = %if.end118, %if.end88
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end119, %if.end109, %if.then86, %if.end67, %if.end61, %if.then28, %if.then24
  %116 = load i32, i32* %retval, align 4
  ret i32 %116
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_read_var_off(%struct.bpf_verifier_env* noundef %env, i32 noundef %ptr_regno, i32 noundef %off, i32 noundef %size, i32 noundef %dst_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ptr_regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %dst_regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %ptr_state = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  %min_off = alloca i32, align 4
  %max_off = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %ptr_regno, i32* %ptr_regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %dst_regno, i32* %dst_regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %ptr_regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3) #20
  store %struct.bpf_func_state* %call1, %struct.bpf_func_state** %ptr_state, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = load i32, i32* %ptr_regno.addr, align 4
  %6 = load i32, i32* %off.addr, align 4
  %7 = load i32, i32* %size.addr, align 4
  %call2 = call i32 @check_stack_range_initialized(%struct.bpf_verifier_env* noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %7, i1 noundef zeroext false, i32 noundef 1, %struct.bpf_call_arg_meta* noundef null) #20
  store i32 %call2, i32* %err, align 4
  %8 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load i32, i32* %err, align 4
  store i32 %9, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  %11 = load i64, i64* %smin_value, align 8
  %12 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %12 to i64
  %add = add i64 %11, %conv
  %conv3 = trunc i64 %add to i32
  store i32 %conv3, i32* %min_off, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 7
  %14 = load i64, i64* %smax_value, align 8
  %15 = load i32, i32* %off.addr, align 4
  %conv4 = sext i32 %15 to i64
  %add5 = add i64 %14, %conv4
  %conv6 = trunc i64 %add5 to i32
  store i32 %conv6, i32* %max_off, align 4
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %ptr_state, align 8
  %18 = load i32, i32* %min_off, align 4
  %19 = load i32, i32* %max_off, align 4
  %20 = load i32, i32* %size.addr, align 4
  %add7 = add i32 %19, %20
  %21 = load i32, i32* %dst_regno.addr, align 4
  call void @mark_reg_stack_read(%struct.bpf_verifier_env* noundef %16, %struct.bpf_func_state* noundef %17, i32 noundef %18, i32 noundef %add7, i32 noundef %21) #20
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_stack_read(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %ptr_state, i32 noundef %min_off, i32 noundef %max_off, i32 noundef %dst_regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ptr_state.addr = alloca %struct.bpf_func_state*, align 8
  %min_off.addr = alloca i32, align 4
  %max_off.addr = alloca i32, align 4
  %dst_regno.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %stype = alloca i8*, align 8
  %zeros = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %ptr_state, %struct.bpf_func_state** %ptr_state.addr, align 8
  store i32 %min_off, i32* %min_off.addr, align 4
  store i32 %max_off, i32* %max_off.addr, align 4
  store i32 %dst_regno, i32* %dst_regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  store i32 0, i32* %zeros, align 4
  %6 = load i32, i32* %min_off.addr, align 4
  store i32 %6, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %max_off.addr, align 4
  %cmp = icmp slt i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %sub = sub i32 0, %9
  %sub1 = sub i32 %sub, 1
  store i32 %sub1, i32* %slot, align 4
  %10 = load i32, i32* %slot, align 4
  %div = sdiv i32 %10, 8
  store i32 %div, i32* %spi, align 4
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %ptr_state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 11
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %13 = load i32, i32* %spi, align 4
  %idxprom2 = sext i32 %13 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  store i8* %arraydecay, i8** %stype, align 8
  %14 = load i8*, i8** %stype, align 8
  %15 = load i32, i32* %slot, align 4
  %rem = srem i32 %15, 8
  %idxprom4 = sext i32 %rem to i64
  %arrayidx5 = getelementptr i8, i8* %14, i64 %idxprom4
  %16 = load i8, i8* %arrayidx5, align 1
  %conv = zext i8 %16 to i32
  %cmp6 = icmp ne i32 %conv, 3
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  %17 = load i32, i32* %zeros, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %zeros, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %18 = load i32, i32* %i, align 4
  %inc8 = add i32 %18, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond, !llvm.loop !74

for.end:                                          ; preds = %if.then, %for.cond
  %19 = load i32, i32* %zeros, align 4
  %20 = load i32, i32* %max_off.addr, align 4
  %21 = load i32, i32* %min_off.addr, align 4
  %sub9 = sub i32 %20, %21
  %cmp10 = icmp eq i32 %19, %sub9
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %for.end
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 0
  %23 = load i32, i32* %dst_regno.addr, align 4
  %idxprom13 = sext i32 %23 to i64
  %arrayidx14 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom13
  call void @__mark_reg_const_zero(%struct.bpf_reg_state* noundef %arrayidx14) #20
  %24 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %24, i32 0, i32 0
  %25 = load i32, i32* %dst_regno.addr, align 4
  %idxprom16 = sext i32 %25 to i64
  %arrayidx17 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs15, i64 0, i64 %idxprom16
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx17, i32 0, i32 18
  store i8 1, i8* %precise, align 4
  br label %if.end20

if.else:                                          ; preds = %for.end
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs18 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 0
  %arraydecay19 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs18, i64 0, i64 0
  %28 = load i32, i32* %dst_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %26, %struct.bpf_reg_state* noundef %arraydecay19, i32 noundef %28) #20
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then12
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs21 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 0
  %30 = load i32, i32* %dst_regno.addr, align 4
  %idxprom22 = sext i32 %30 to i64
  %arrayidx23 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs21, i64 0, i64 %idxprom22
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx23, i32 0, i32 17
  %31 = load i32, i32* %live, align 8
  %or = or i32 %31, 4
  store i32 %or, i32* %live, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_const_zero(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %0, i64 noundef 0) #20
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_write_fixed_off(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %off, i32 noundef %size, i32 noundef %value_regno, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %cur = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %err = alloca i32, align 4
  %dst_reg = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %sanitize = alloca i8, align 1
  %type88 = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %0
  %sub1 = sub i32 %sub, 1
  store i32 %sub1, i32* %slot, align 4
  %1 = load i32, i32* %slot, align 4
  %div = sdiv i32 %1, 8
  store i32 %div, i32* %spi, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %4 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 12
  %5 = bitcast %union.anon.198* %4 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %5, i32 0, i32 1
  %6 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 %idxprom
  %dst_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg2, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv = zext i8 %bf.clear to i32
  store i32 %conv, i32* %dst_reg, align 4
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %reg, align 8
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %8 = load i32, i32* %slot, align 4
  %add = add i32 %8, 1
  %sub3 = sub i32 %add, 1
  %or = or i32 %sub3, 7
  %add4 = add i32 %or, 1
  %call = call i32 @grow_stack_state(%struct.bpf_func_state* noundef %7, i32 noundef %add4) #20
  store i32 %call, i32* %err, align 4
  %9 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load i32, i32* %err, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 17
  %12 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool5 = trunc i8 %12 to i1
  br i1 %tobool5, label %if.end15, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 11
  %14 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %15 = load i32, i32* %spi, align 4
  %idxprom6 = sext i32 %15 to i64
  %arrayidx7 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %14, i64 %idxprom6
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx7, i32 0, i32 1
  %arrayidx8 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %16 = load i8, i8* %arrayidx8, align 8
  %conv9 = zext i8 %16 to i32
  %cmp = icmp eq i32 %conv9, 1
  br i1 %cmp, label %land.lhs.true11, label %if.end15

land.lhs.true11:                                  ; preds = %land.lhs.true
  %17 = load i32, i32* %size.addr, align 4
  %cmp12 = icmp ne i32 %17, 8
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true11
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.187, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %land.lhs.true11, %land.lhs.true, %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 8
  %21 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %21, i32 0, i32 0
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 8
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state16, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 4
  %24 = load i32, i32* %curframe, align 8
  %idxprom17 = zext i32 %24 to i64
  %arrayidx18 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom17
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx18, align 8
  store %struct.bpf_func_state* %25, %struct.bpf_func_state** %cur, align 8
  %26 = load i32, i32* %value_regno.addr, align 4
  %cmp19 = icmp sge i32 %26, 0
  br i1 %cmp19, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end15
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 0
  %28 = load i32, i32* %value_regno.addr, align 4
  %idxprom22 = sext i32 %28 to i64
  %arrayidx23 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom22
  store %struct.bpf_reg_state* %arrayidx23, %struct.bpf_reg_state** %reg, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end15
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 22
  %30 = load i8, i8* %bypass_spec_v4, align 2
  %tobool25 = trunc i8 %30 to i1
  br i1 %tobool25, label %if.end48, label %if.then26

if.then26:                                        ; preds = %if.end24
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool27 = icmp ne %struct.bpf_reg_state* %31, null
  br i1 %tobool27, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then26
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 0
  %33 = load i32, i32* %type, align 8
  %call28 = call zeroext i1 @is_spillable_regtype(i32 noundef %33) #20
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then26
  %34 = phi i1 [ false, %if.then26 ], [ %call28, %land.rhs ]
  %frombool = zext i1 %34 to i8
  store i8 %frombool, i8* %sanitize, align 1
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %land.end
  %35 = load i32, i32* %i, align 4
  %36 = load i32, i32* %size.addr, align 4
  %cmp30 = icmp slt i32 %35, %36
  br i1 %cmp30, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack32 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %37, i32 0, i32 11
  %38 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack32, align 8
  %39 = load i32, i32* %spi, align 4
  %idxprom33 = sext i32 %39 to i64
  %arrayidx34 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %38, i64 %idxprom33
  %slot_type35 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx34, i32 0, i32 1
  %40 = load i32, i32* %i, align 4
  %idxprom36 = sext i32 %40 to i64
  %arrayidx37 = getelementptr [8 x i8], [8 x i8]* %slot_type35, i64 0, i64 %idxprom36
  %41 = load i8, i8* %arrayidx37, align 1
  %conv38 = zext i8 %41 to i32
  %cmp39 = icmp eq i32 %conv38, 0
  br i1 %cmp39, label %if.then41, label %if.end42

if.then41:                                        ; preds = %for.body
  store i8 1, i8* %sanitize, align 1
  br label %for.end

if.end42:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end42
  %42 = load i32, i32* %i, align 4
  %inc = add i32 %42, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !75

for.end:                                          ; preds = %if.then41, %for.cond
  %43 = load i8, i8* %sanitize, align 1
  %tobool43 = trunc i8 %43 to i1
  br i1 %tobool43, label %if.then44, label %if.end47

if.then44:                                        ; preds = %for.end
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %44, i32 0, i32 24
  %45 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %46 = load i32, i32* %insn_idx.addr, align 4
  %idxprom45 = sext i32 %46 to i64
  %arrayidx46 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %45, i64 %idxprom45
  %sanitize_stack_spill = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx46, i32 0, i32 4
  store i8 1, i8* %sanitize_stack_spill, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.then44, %for.end
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.end24
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = load i32, i32* %spi, align 4
  call void @mark_stack_slot_scratched(%struct.bpf_verifier_env* noundef %47, i32 noundef %48) #20
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool49 = icmp ne %struct.bpf_reg_state* %49, null
  br i1 %tobool49, label %land.lhs.true50, label %if.else

land.lhs.true50:                                  ; preds = %if.end48
  %50 = load i32, i32* %off.addr, align 4
  %rem = srem i32 %50, 8
  %tobool51 = icmp ne i32 %rem, 0
  br i1 %tobool51, label %if.else, label %land.lhs.true52

land.lhs.true52:                                  ; preds = %land.lhs.true50
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call53 = call zeroext i1 @register_is_bounded(%struct.bpf_reg_state* noundef %51) #20
  br i1 %call53, label %land.lhs.true55, label %if.else

land.lhs.true55:                                  ; preds = %land.lhs.true52
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call56 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %52) #20
  br i1 %call56, label %if.else, label %land.lhs.true57

land.lhs.true57:                                  ; preds = %land.lhs.true55
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %53, i32 0, i32 20
  %54 = load i8, i8* %bpf_capable, align 8
  %tobool58 = trunc i8 %54 to i1
  br i1 %tobool58, label %if.then60, label %if.else

if.then60:                                        ; preds = %land.lhs.true57
  %55 = load i32, i32* %dst_reg, align 4
  %cmp61 = icmp ne i32 %55, 10
  br i1 %cmp61, label %if.then63, label %if.end68

if.then63:                                        ; preds = %if.then60
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = load i32, i32* %value_regno.addr, align 4
  %call64 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %56, i32 noundef %57) #20
  store i32 %call64, i32* %err, align 4
  %58 = load i32, i32* %err, align 4
  %tobool65 = icmp ne i32 %58, 0
  br i1 %tobool65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.then63
  %59 = load i32, i32* %err, align 4
  store i32 %59, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.then63
  br label %if.end68

if.end68:                                         ; preds = %if.end67, %if.then60
  %60 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %61 = load i32, i32* %spi, align 4
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %63 = load i32, i32* %size.addr, align 4
  call void @save_register_state(%struct.bpf_func_state* noundef %60, i32 noundef %61, %struct.bpf_reg_state* noundef %62, i32 noundef %63) #20
  br label %if.end147

if.else:                                          ; preds = %land.lhs.true57, %land.lhs.true55, %land.lhs.true52, %land.lhs.true50, %if.end48
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool69 = icmp ne %struct.bpf_reg_state* %64, null
  br i1 %tobool69, label %land.lhs.true70, label %if.else87

land.lhs.true70:                                  ; preds = %if.else
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 0
  %66 = load i32, i32* %type71, align 8
  %call72 = call zeroext i1 @is_spillable_regtype(i32 noundef %66) #20
  br i1 %call72, label %if.then74, label %if.else87

if.then74:                                        ; preds = %land.lhs.true70
  %67 = load i32, i32* %size.addr, align 4
  %cmp75 = icmp ne i32 %67, 8
  br i1 %cmp75, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.then74
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %69 = load i32, i32* %insn_idx.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %68, i32 noundef %69, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.155, i64 0, i64 0)) #20
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = bitcast %struct.bpf_verifier_env* %70 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %71, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.188, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end78:                                         ; preds = %if.then74
  %72 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %73 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur, align 8
  %cmp79 = icmp ne %struct.bpf_func_state* %72, %73
  br i1 %cmp79, label %land.lhs.true81, label %if.end86

land.lhs.true81:                                  ; preds = %if.end78
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type82 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 0
  %75 = load i32, i32* %type82, align 8
  %cmp83 = icmp eq i32 %75, 6
  br i1 %cmp83, label %if.then85, label %if.end86

if.then85:                                        ; preds = %land.lhs.true81
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %77 = bitcast %struct.bpf_verifier_env* %76 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %77, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.189, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end86:                                         ; preds = %land.lhs.true81, %if.end78
  %78 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %79 = load i32, i32* %spi, align 4
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %81 = load i32, i32* %size.addr, align 4
  call void @save_register_state(%struct.bpf_func_state* noundef %78, i32 noundef %79, %struct.bpf_reg_state* noundef %80, i32 noundef %81) #20
  br label %if.end146

if.else87:                                        ; preds = %land.lhs.true70, %if.else
  store i8 2, i8* %type88, align 1
  %82 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack89 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %82, i32 0, i32 11
  %83 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack89, align 8
  %84 = load i32, i32* %spi, align 4
  %idxprom90 = sext i32 %84 to i64
  %arrayidx91 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %83, i64 %idxprom90
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx91, i32 0, i32 0
  %type92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 0
  store i32 0, i32* %type92, align 8
  %85 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack93 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %85, i32 0, i32 11
  %86 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack93, align 8
  %87 = load i32, i32* %spi, align 4
  %idxprom94 = sext i32 %87 to i64
  %arrayidx95 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %86, i64 %idxprom94
  %call96 = call zeroext i1 @is_spilled_reg(%struct.bpf_stack_state* noundef %arrayidx95) #20
  br i1 %call96, label %if.then97, label %if.end111

if.then97:                                        ; preds = %if.else87
  store i32 0, i32* %i, align 4
  br label %for.cond98

for.cond98:                                       ; preds = %for.inc108, %if.then97
  %88 = load i32, i32* %i, align 4
  %cmp99 = icmp slt i32 %88, 8
  br i1 %cmp99, label %for.body101, label %for.end110

for.body101:                                      ; preds = %for.cond98
  %89 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack102 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %89, i32 0, i32 11
  %90 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack102, align 8
  %91 = load i32, i32* %spi, align 4
  %idxprom103 = sext i32 %91 to i64
  %arrayidx104 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %90, i64 %idxprom103
  %slot_type105 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx104, i32 0, i32 1
  %92 = load i32, i32* %i, align 4
  %idxprom106 = sext i32 %92 to i64
  %arrayidx107 = getelementptr [8 x i8], [8 x i8]* %slot_type105, i64 0, i64 %idxprom106
  call void @scrub_spilled_slot(i8* noundef %arrayidx107) #20
  br label %for.inc108

for.inc108:                                       ; preds = %for.body101
  %93 = load i32, i32* %i, align 4
  %inc109 = add i32 %93, 1
  store i32 %inc109, i32* %i, align 4
  br label %for.cond98, !llvm.loop !76

for.end110:                                       ; preds = %for.cond98
  br label %if.end111

if.end111:                                        ; preds = %for.end110, %if.else87
  %94 = load i32, i32* %size.addr, align 4
  %cmp112 = icmp eq i32 %94, 8
  br i1 %cmp112, label %if.then114, label %if.end120

if.then114:                                       ; preds = %if.end111
  %95 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack115 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %95, i32 0, i32 11
  %96 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack115, align 8
  %97 = load i32, i32* %spi, align 4
  %idxprom116 = sext i32 %97 to i64
  %arrayidx117 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %96, i64 %idxprom116
  %spilled_ptr118 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx117, i32 0, i32 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr118, i32 0, i32 17
  %98 = load i32, i32* %live, align 8
  %or119 = or i32 %98, 4
  store i32 %or119, i32* %live, align 8
  br label %if.end120

if.end120:                                        ; preds = %if.then114, %if.end111
  %99 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool121 = icmp ne %struct.bpf_reg_state* %99, null
  br i1 %tobool121, label %land.lhs.true122, label %if.end130

land.lhs.true122:                                 ; preds = %if.end120
  %100 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call123 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %100) #20
  br i1 %call123, label %if.then125, label %if.end130

if.then125:                                       ; preds = %land.lhs.true122
  %101 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %102 = load i32, i32* %value_regno.addr, align 4
  %call126 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %101, i32 noundef %102) #20
  store i32 %call126, i32* %err, align 4
  %103 = load i32, i32* %err, align 4
  %tobool127 = icmp ne i32 %103, 0
  br i1 %tobool127, label %if.then128, label %if.end129

if.then128:                                       ; preds = %if.then125
  %104 = load i32, i32* %err, align 4
  store i32 %104, i32* %retval, align 4
  br label %return

if.end129:                                        ; preds = %if.then125
  store i8 3, i8* %type88, align 1
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true122, %if.end120
  store i32 0, i32* %i, align 4
  br label %for.cond131

for.cond131:                                      ; preds = %for.inc143, %if.end130
  %105 = load i32, i32* %i, align 4
  %106 = load i32, i32* %size.addr, align 4
  %cmp132 = icmp slt i32 %105, %106
  br i1 %cmp132, label %for.body134, label %for.end145

for.body134:                                      ; preds = %for.cond131
  %107 = load i8, i8* %type88, align 1
  %108 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack135 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %108, i32 0, i32 11
  %109 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack135, align 8
  %110 = load i32, i32* %spi, align 4
  %idxprom136 = sext i32 %110 to i64
  %arrayidx137 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %109, i64 %idxprom136
  %slot_type138 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx137, i32 0, i32 1
  %111 = load i32, i32* %slot, align 4
  %112 = load i32, i32* %i, align 4
  %sub139 = sub i32 %111, %112
  %rem140 = srem i32 %sub139, 8
  %idxprom141 = sext i32 %rem140 to i64
  %arrayidx142 = getelementptr [8 x i8], [8 x i8]* %slot_type138, i64 0, i64 %idxprom141
  store i8 %107, i8* %arrayidx142, align 1
  br label %for.inc143

for.inc143:                                       ; preds = %for.body134
  %113 = load i32, i32* %i, align 4
  %inc144 = add i32 %113, 1
  store i32 %inc144, i32* %i, align 4
  br label %for.cond131, !llvm.loop !77

for.end145:                                       ; preds = %for.cond131
  br label %if.end146

if.end146:                                        ; preds = %for.end145, %if.end86
  br label %if.end147

if.end147:                                        ; preds = %if.end146, %if.end68
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end147, %if.then128, %if.then85, %if.then77, %if.then66, %if.then14, %if.then
  %114 = load i32, i32* %retval, align 4
  ret i32 %114
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_write_var_off(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %ptr_regno, i32 noundef %off, i32 noundef %size, i32 noundef %value_regno, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %ptr_regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %cur = alloca %struct.bpf_func_state*, align 8
  %min_off = alloca i32, align 4
  %max_off = alloca i32, align 4
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %ptr_reg = alloca %struct.bpf_reg_state*, align 8
  %value_reg = alloca %struct.bpf_reg_state*, align 8
  %writing_zero = alloca i8, align 1
  %zero_used = alloca i8, align 1
  %new_type = alloca i8, align 1
  %stype = alloca i8*, align 8
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %ptr_regno, i32* %ptr_regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %ptr_reg, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %value_reg, align 8
  store i8 0, i8* %writing_zero, align 1
  store i8 0, i8* %zero_used, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 0
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 8
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state1, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %cur, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %7 = load i32, i32* %ptr_regno.addr, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom2
  store %struct.bpf_reg_state* %arrayidx3, %struct.bpf_reg_state** %ptr_reg, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  %10 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %10 to i64
  %add = add i64 %9, %conv
  %conv4 = trunc i64 %add to i32
  store i32 %conv4, i32* %min_off, align 4
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 7
  %12 = load i64, i64* %smax_value, align 8
  %13 = load i32, i32* %off.addr, align 4
  %conv5 = sext i32 %13 to i64
  %add6 = add i64 %12, %conv5
  %14 = load i32, i32* %size.addr, align 4
  %conv7 = sext i32 %14 to i64
  %add8 = add i64 %add6, %conv7
  %conv9 = trunc i64 %add8 to i32
  store i32 %conv9, i32* %max_off, align 4
  %15 = load i32, i32* %value_regno.addr, align 4
  %cmp = icmp sge i32 %15, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur, align 8
  %regs11 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %16, i32 0, i32 0
  %17 = load i32, i32* %value_regno.addr, align 4
  %idxprom12 = sext i32 %17 to i64
  %arrayidx13 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs11, i64 0, i64 %idxprom12
  store %struct.bpf_reg_state* %arrayidx13, %struct.bpf_reg_state** %value_reg, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %value_reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %18, null
  br i1 %tobool, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.end
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %value_reg, align 8
  %call = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %19) #20
  br i1 %call, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true
  store i8 1, i8* %writing_zero, align 1
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %land.lhs.true, %if.end
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %21 = load i32, i32* %min_off, align 4
  %sub = sub i32 0, %21
  %sub17 = sub i32 %sub, 1
  %or = or i32 %sub17, 7
  %add18 = add i32 %or, 1
  %call19 = call i32 @grow_stack_state(%struct.bpf_func_state* noundef %20, i32 noundef %add18) #20
  store i32 %call19, i32* %err, align 4
  %22 = load i32, i32* %err, align 4
  %tobool20 = icmp ne i32 %22, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end16
  %23 = load i32, i32* %err, align 4
  store i32 %23, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end16
  %24 = load i32, i32* %min_off, align 4
  store i32 %24, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end22
  %25 = load i32, i32* %i, align 4
  %26 = load i32, i32* %max_off, align 4
  %cmp23 = icmp slt i32 %25, %26
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %27 = load i32, i32* %i, align 4
  %sub25 = sub i32 0, %27
  %sub26 = sub i32 %sub25, 1
  store i32 %sub26, i32* %slot, align 4
  %28 = load i32, i32* %slot, align 4
  %div = sdiv i32 %28, 8
  store i32 %div, i32* %spi, align 4
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 11
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %31 = load i32, i32* %spi, align 4
  %idxprom27 = sext i32 %31 to i64
  %arrayidx28 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom27
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx28, i32 0, i32 1
  %32 = load i32, i32* %slot, align 4
  %rem = srem i32 %32, 8
  %idxprom29 = sext i32 %rem to i64
  %arrayidx30 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom29
  store i8* %arrayidx30, i8** %stype, align 8
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load i32, i32* %spi, align 4
  call void @mark_stack_slot_scratched(%struct.bpf_verifier_env* noundef %33, i32 noundef %34) #20
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 17
  %36 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool31 = trunc i8 %36 to i1
  br i1 %tobool31, label %if.end41, label %land.lhs.true32

land.lhs.true32:                                  ; preds = %for.body
  %37 = load i8*, i8** %stype, align 8
  %38 = load i8, i8* %37, align 1
  %conv33 = zext i8 %38 to i32
  %cmp34 = icmp ne i32 %conv33, 0
  br i1 %cmp34, label %land.lhs.true36, label %if.end41

land.lhs.true36:                                  ; preds = %land.lhs.true32
  %39 = load i8*, i8** %stype, align 8
  %40 = load i8, i8* %39, align 1
  %conv37 = zext i8 %40 to i32
  %cmp38 = icmp ne i32 %conv37, 1
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %land.lhs.true36
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load i32, i32* %insn_idx.addr, align 4
  %44 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.190, i64 0, i64 0), i32 noundef %43, i32 noundef %44) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %land.lhs.true36, %land.lhs.true32, %for.body
  %45 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack42 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %45, i32 0, i32 11
  %46 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack42, align 8
  %47 = load i32, i32* %spi, align 4
  %idxprom43 = sext i32 %47 to i64
  %arrayidx44 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %46, i64 %idxprom43
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx44, i32 0, i32 0
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 0
  store i32 0, i32* %type, align 8
  store i8 2, i8* %new_type, align 1
  %48 = load i8, i8* %writing_zero, align 1
  %tobool45 = trunc i8 %48 to i1
  br i1 %tobool45, label %land.lhs.true47, label %if.end52

land.lhs.true47:                                  ; preds = %if.end41
  %49 = load i8*, i8** %stype, align 8
  %50 = load i8, i8* %49, align 1
  %conv48 = zext i8 %50 to i32
  %cmp49 = icmp eq i32 %conv48, 3
  br i1 %cmp49, label %if.then51, label %if.end52

if.then51:                                        ; preds = %land.lhs.true47
  store i8 3, i8* %new_type, align 1
  store i8 1, i8* %zero_used, align 1
  br label %if.end52

if.end52:                                         ; preds = %if.then51, %land.lhs.true47, %if.end41
  %51 = load i8*, i8** %stype, align 8
  %52 = load i8, i8* %51, align 1
  %conv53 = zext i8 %52 to i32
  %cmp54 = icmp eq i32 %conv53, 0
  br i1 %cmp54, label %land.lhs.true56, label %if.end59

land.lhs.true56:                                  ; preds = %if.end52
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_uninit_stack = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %53, i32 0, i32 18
  %54 = load i8, i8* %allow_uninit_stack, align 2
  %tobool57 = trunc i8 %54 to i1
  br i1 %tobool57, label %if.end59, label %if.then58

if.then58:                                        ; preds = %land.lhs.true56
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = bitcast %struct.bpf_verifier_env* %55 to i8*
  %57 = load i32, i32* %insn_idx.addr, align 4
  %58 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %56, i8* noundef getelementptr inbounds ([81 x i8], [81 x i8]* @.str.191, i64 0, i64 0), i32 noundef %57, i32 noundef %58) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end59:                                         ; preds = %land.lhs.true56, %if.end52
  %59 = load i8, i8* %new_type, align 1
  %60 = load i8*, i8** %stype, align 8
  store i8 %59, i8* %60, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end59
  %61 = load i32, i32* %i, align 4
  %inc = add i32 %61, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !78

for.end:                                          ; preds = %for.cond
  %62 = load i8, i8* %zero_used, align 1
  %tobool60 = trunc i8 %62 to i1
  br i1 %tobool60, label %if.then61, label %if.end66

if.then61:                                        ; preds = %for.end
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = load i32, i32* %value_regno.addr, align 4
  %call62 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %63, i32 noundef %64) #20
  store i32 %call62, i32* %err, align 4
  %65 = load i32, i32* %err, align 4
  %tobool63 = icmp ne i32 %65, 0
  br i1 %tobool63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.then61
  %66 = load i32, i32* %err, align 4
  store i32 %66, i32* %retval, align 4
  br label %return

if.end65:                                         ; preds = %if.then61
  br label %if.end66

if.end66:                                         ; preds = %if.end65, %for.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end66, %if.then64, %if.then58, %if.then40, %if.then21
  %67 = load i32, i32* %retval, align 4
  ret i32 %67
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @grow_stack_state(%struct.bpf_func_state* noundef %state, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %size.addr = alloca i32, align 4
  %old_n = alloca i64, align 8
  %n = alloca i64, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 10
  %1 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %1, 8
  %conv = sext i32 %div to i64
  store i64 %conv, i64* %old_n, align 8
  %2 = load i32, i32* %size.addr, align 4
  %div1 = sdiv i32 %2, 8
  %conv2 = sext i32 %div1 to i64
  store i64 %conv2, i64* %n, align 8
  %3 = load i64, i64* %old_n, align 8
  %4 = load i64, i64* %n, align 8
  %cmp = icmp uge i64 %3, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 11
  %6 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %7 = bitcast %struct.bpf_stack_state* %6 to i8*
  %8 = load i64, i64* %old_n, align 8
  %9 = load i64, i64* %n, align 8
  %call = call i8* @realloc_array(i8* noundef %7, i64 noundef %8, i64 noundef %9, i64 noundef 128) #20
  %10 = bitcast i8* %call to %struct.bpf_stack_state*
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 11
  store %struct.bpf_stack_state* %10, %struct.bpf_stack_state** %stack4, align 8
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 11
  %13 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack5, align 8
  %tobool = icmp ne %struct.bpf_stack_state* %13, null
  br i1 %tobool, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %14 = load i32, i32* %size.addr, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack8 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 10
  store i32 %14, i32* %allocated_stack8, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then
  %16 = load i32, i32* %retval, align 4
  ret i32 %16
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_spillable_regtype(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %call = call i32 @base_type(i32 noundef %0) #20
  switch i32 %call, label %sw.default [
    i32 4, label %sw.bb
    i32 6, label %sw.bb
    i32 2, label %sw.bb
    i32 8, label %sw.bb
    i32 7, label %sw.bb
    i32 9, label %sw.bb
    i32 10, label %sw.bb
    i32 3, label %sw.bb
    i32 11, label %sw.bb
    i32 12, label %sw.bb
    i32 13, label %sw.bb
    i32 15, label %sw.bb
    i32 16, label %sw.bb
    i32 18, label %sw.bb
    i32 17, label %sw.bb
    i32 19, label %sw.bb
    i32 5, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_stack_slot_scratched(%struct.bpf_verifier_env* noundef %env, i32 noundef %spi) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %spi.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %spi, i32* %spi.addr, align 4
  %0 = load i32, i32* %spi.addr, align 4
  %sh_prom = zext i32 %0 to i64
  %shl = shl i64 1, %sh_prom
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %scratched_stack_slots = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 43
  %2 = load i64, i64* %scratched_stack_slots, align 8
  %or = or i64 %2, %shl
  store i64 %or, i64* %scratched_stack_slots, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @register_is_bounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call zeroext i1 @__is_scalar_unbounded(%struct.bpf_reg_state* noundef %2) #20
  %lnot = xor i1 %call, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @save_register_state(%struct.bpf_func_state* noundef %state, i32 noundef %spi, %struct.bpf_reg_state* noundef %reg, i32 noundef %size) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %spi.addr = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %size.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %spi, i32* %spi.addr, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 11
  %1 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %2 = load i32, i32* %spi.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %1, i64 %idxprom
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 0
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %4 = bitcast %struct.bpf_reg_state* %spilled_ptr to i8*
  %5 = bitcast %struct.bpf_reg_state* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %4, i8* align 8 %5, i64 120, i1 false)
  %6 = load i32, i32* %size.addr, align 4
  %cmp = icmp eq i32 %6, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 11
  %8 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack1, align 8
  %9 = load i32, i32* %spi.addr, align 4
  %idxprom2 = sext i32 %9 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %8, i64 %idxprom2
  %spilled_ptr4 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr4, i32 0, i32 17
  %10 = load i32, i32* %live, align 8
  %or = or i32 %10, 4
  store i32 %or, i32* %live, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 8, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %size.addr, align 4
  %sub = sub i32 8, %12
  %cmp5 = icmp sgt i32 %11, %sub
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack6 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 11
  %14 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack6, align 8
  %15 = load i32, i32* %spi.addr, align 4
  %idxprom7 = sext i32 %15 to i64
  %arrayidx8 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %14, i64 %idxprom7
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx8, i32 0, i32 1
  %16 = load i32, i32* %i, align 4
  %sub9 = sub i32 %16, 1
  %idxprom10 = sext i32 %sub9 to i64
  %arrayidx11 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom10
  store i8 1, i8* %arrayidx11, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, i32* %i, align 4
  %dec = add i32 %17, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond, !llvm.loop !79

for.end:                                          ; preds = %for.cond
  br label %for.cond12

for.cond12:                                       ; preds = %for.inc21, %for.end
  %18 = load i32, i32* %i, align 4
  %tobool = icmp ne i32 %18, 0
  br i1 %tobool, label %for.body13, label %for.end23

for.body13:                                       ; preds = %for.cond12
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 11
  %20 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack14, align 8
  %21 = load i32, i32* %spi.addr, align 4
  %idxprom15 = sext i32 %21 to i64
  %arrayidx16 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %20, i64 %idxprom15
  %slot_type17 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx16, i32 0, i32 1
  %22 = load i32, i32* %i, align 4
  %sub18 = sub i32 %22, 1
  %idxprom19 = sext i32 %sub18 to i64
  %arrayidx20 = getelementptr [8 x i8], [8 x i8]* %slot_type17, i64 0, i64 %idxprom19
  call void @scrub_spilled_slot(i8* noundef %arrayidx20) #20
  br label %for.inc21

for.inc21:                                        ; preds = %for.body13
  %23 = load i32, i32* %i, align 4
  %dec22 = add i32 %23, -1
  store i32 %dec22, i32* %i, align 4
  br label %for.cond12, !llvm.loop !80

for.end23:                                        ; preds = %for.cond12
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @realloc_array(i8* noundef %arr, i64 noundef %old_n, i64 noundef %new_n, i64 noundef %size) #0 {
entry:
  %retval = alloca i8*, align 8
  %arr.addr = alloca i8*, align 8
  %old_n.addr = alloca i64, align 8
  %new_n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %new_arr = alloca i8*, align 8
  store i8* %arr, i8** %arr.addr, align 8
  store i64 %old_n, i64* %old_n.addr, align 8
  store i64 %new_n, i64* %new_n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %0 = load i64, i64* %new_n.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, i64* %old_n.addr, align 8
  %2 = load i64, i64* %new_n.addr, align 8
  %cmp = icmp eq i64 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %out

if.end:                                           ; preds = %lor.lhs.false
  %3 = load i8*, i8** %arr.addr, align 8
  %4 = load i64, i64* %new_n.addr, align 8
  %5 = load i64, i64* %size.addr, align 8
  %call = call i8* @krealloc_array(i8* noundef %3, i64 noundef %4, i64 noundef %5, i32 noundef 3264) #28
  store i8* %call, i8** %new_arr, align 8
  %6 = load i8*, i8** %new_arr, align 8
  %tobool1 = icmp ne i8* %6, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  %7 = load i8*, i8** %arr.addr, align 8
  call void @kfree(i8* noundef %7) #20
  store i8* null, i8** %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %8 = load i8*, i8** %new_arr, align 8
  store i8* %8, i8** %arr.addr, align 8
  %9 = load i64, i64* %new_n.addr, align 8
  %10 = load i64, i64* %old_n.addr, align 8
  %cmp4 = icmp ugt i64 %9, %10
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  %11 = load i8*, i8** %arr.addr, align 8
  %12 = load i64, i64* %old_n.addr, align 8
  %13 = load i64, i64* %size.addr, align 8
  %mul = mul i64 %12, %13
  %add.ptr = getelementptr i8, i8* %11, i64 %mul
  %14 = load i64, i64* %new_n.addr, align 8
  %15 = load i64, i64* %old_n.addr, align 8
  %sub = sub i64 %14, %15
  %16 = load i64, i64* %size.addr, align 8
  %mul6 = mul i64 %sub, %16
  call void @llvm.memset.p0i8.i64(i8* align 1 %add.ptr, i8 0, i64 %mul6, i1 false)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3
  br label %out

out:                                              ; preds = %if.end7, %if.then
  %17 = load i8*, i8** %arr.addr, align 8
  %tobool8 = icmp ne i8* %17, null
  br i1 %tobool8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %out
  %18 = load i8*, i8** %arr.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %out
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %18, %cond.true ], [ inttoptr (i64 16 to i8*), %cond.false ]
  store i8* %cond, i8** %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.then2
  %19 = load i8*, i8** %retval, align 8
  ret i8* %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong allocsize(1,2)
define internal i8* @krealloc_array(i8* noundef %p, i64 noundef %new_n, i64 noundef %new_size, i32 noundef %flags) #13 {
entry:
  %retval = alloca i8*, align 8
  %p.addr = alloca i8*, align 8
  %new_n.addr = alloca i64, align 8
  %new_size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca i64, align 8
  store i8* %p, i8** %p.addr, align 8
  store i64 %new_n, i64* %new_n.addr, align 8
  store i64 %new_size, i64* %new_size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %new_n.addr, align 8
  %1 = load i64, i64* %new_size.addr, align 8
  %2 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %0, i64 %1)
  %3 = extractvalue { i64, i1 } %2, 1
  %4 = extractvalue { i64, i1 } %2, 0
  store i64 %4, i64* %bytes, align 8
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %3) #20
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i8*, i8** %p.addr, align 8
  %6 = load i64, i64* %bytes, align 8
  %7 = load i32, i32* %flags.addr, align 4
  %call2 = call i8* @krealloc(i8* noundef %5, i64 noundef %6, i32 noundef %7) #29
  store i8* %call2, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i8*, i8** %retval, align 8
  ret i8* %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__must_check_overflow(i1 noundef zeroext %overflow) #0 {
entry:
  %overflow.addr = alloca i8, align 1
  %frombool = zext i1 %overflow to i8
  store i8 %frombool, i8* %overflow.addr, align 1
  %0 = load i8, i8* %overflow.addr, align 1
  %tobool = trunc i8 %0 to i1
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  ret i1 %tobool2
}

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare { i64, i1 } @llvm.umul.with.overflow.i64(i64, i64) #9

; Function Attrs: noredzone null_pointer_is_valid allocsize(1)
declare dso_local i8* @krealloc(i8* noundef, i64 noundef, i32 noundef) #14

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__is_scalar_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_unknown(i64 %3, i64 %5) #20
  br i1 %call, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 6
  %7 = load i64, i64* %smin_value, align 8
  %cmp = icmp eq i64 %7, -9223372036854775808
  br i1 %cmp, label %land.lhs.true1, label %land.end

land.lhs.true1:                                   ; preds = %land.lhs.true
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 7
  %9 = load i64, i64* %smax_value, align 8
  %cmp2 = icmp eq i64 %9, 9223372036854775807
  br i1 %cmp2, label %land.lhs.true3, label %land.end

land.lhs.true3:                                   ; preds = %land.lhs.true1
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 8
  %11 = load i64, i64* %umin_value, align 8
  %cmp4 = icmp eq i64 %11, 0
  br i1 %cmp4, label %land.lhs.true5, label %land.end

land.lhs.true5:                                   ; preds = %land.lhs.true3
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 9
  %13 = load i64, i64* %umax_value, align 8
  %cmp6 = icmp eq i64 %13, -1
  br i1 %cmp6, label %land.lhs.true7, label %land.end

land.lhs.true7:                                   ; preds = %land.lhs.true5
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  %15 = load i32, i32* %s32_min_value, align 8
  %cmp8 = icmp eq i32 %15, -2147483648
  br i1 %cmp8, label %land.lhs.true9, label %land.end

land.lhs.true9:                                   ; preds = %land.lhs.true7
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 11
  %17 = load i32, i32* %s32_max_value, align 4
  %cmp10 = icmp eq i32 %17, 2147483647
  br i1 %cmp10, label %land.lhs.true11, label %land.end

land.lhs.true11:                                  ; preds = %land.lhs.true9
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 12
  %19 = load i32, i32* %u32_min_value, align 8
  %cmp12 = icmp eq i32 %19, 0
  br i1 %cmp12, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true11
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 13
  %21 = load i32, i32* %u32_max_value, align 4
  %cmp13 = icmp eq i32 %21, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true11, %land.lhs.true9, %land.lhs.true7, %land.lhs.true5, %land.lhs.true3, %land.lhs.true1, %land.lhs.true, %entry
  %22 = phi i1 [ false, %land.lhs.true11 ], [ false, %land.lhs.true9 ], [ false, %land.lhs.true7 ], [ false, %land.lhs.true5 ], [ false, %land.lhs.true3 ], [ false, %land.lhs.true1 ], [ false, %land.lhs.true ], [ false, %entry ], [ %cmp13, %land.rhs ]
  ret i1 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @resolve_prog_type(%struct.bpf_prog* noundef %prog) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 2
  %1 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %1, 28
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %dst_prog = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 17
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %dst_prog, align 8
  %type1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 2
  %5 = load i32, i32* %type1, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 2
  %7 = load i32, i32* %type2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %5, %cond.true ], [ %7, %cond.false ]
  ret i32 %cond
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_sock_common_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.bpf_insn_access_aux* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_sock_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.bpf_insn_access_aux* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_tcp_sock_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.bpf_insn_access_aux* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_xdp_sock_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.bpf_insn_access_aux* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_struct_access(%struct.bpf_verifier_log* noundef, %struct.btf* noundef, %struct.btf_type* noundef, i32 noundef, i32 noundef, i32 noundef, i32* noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_cast(i64, i64, i8 noundef zeroext) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_combine_64_into_32(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %0) #20
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 6
  %2 = load i64, i64* %smin_value, align 8
  %call = call zeroext i1 @__reg64_bound_s32(i64 noundef %2) #20
  br i1 %call, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 7
  %4 = load i64, i64* %smax_value, align 8
  %call1 = call zeroext i1 @__reg64_bound_s32(i64 noundef %4) #20
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 6
  %6 = load i64, i64* %smin_value2, align 8
  %conv = trunc i64 %6 to i32
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 10
  store i32 %conv, i32* %s32_min_value, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 7
  %9 = load i64, i64* %smax_value3, align 8
  %conv4 = trunc i64 %9 to i32
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 11
  store i32 %conv4, i32* %s32_max_value, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 8
  %12 = load i64, i64* %umin_value, align 8
  %call5 = call zeroext i1 @__reg64_bound_u32(i64 noundef %12) #20
  br i1 %call5, label %land.lhs.true7, label %if.end15

land.lhs.true7:                                   ; preds = %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 9
  %14 = load i64, i64* %umax_value, align 8
  %call8 = call zeroext i1 @__reg64_bound_u32(i64 noundef %14) #20
  br i1 %call8, label %if.then10, label %if.end15

if.then10:                                        ; preds = %land.lhs.true7
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 8
  %16 = load i64, i64* %umin_value11, align 8
  %conv12 = trunc i64 %16 to i32
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 12
  store i32 %conv12, i32* %u32_min_value, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 9
  %19 = load i64, i64* %umax_value13, align 8
  %conv14 = trunc i64 %19 to i32
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 13
  store i32 %conv14, i32* %u32_max_value, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then10, %land.lhs.true7, %if.end
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @reg_bounds_sync(%struct.bpf_reg_state* noundef %21) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 12
  store i32 0, i32* %u32_min_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 13
  store i32 -1, i32* %u32_max_value, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__reg64_bound_s32(i64 noundef %a) #0 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %cmp = icmp sge i64 %0, -2147483648
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp sle i64 %1, 2147483647
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__reg64_bound_u32(i64 noundef %a) #0 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %cmp = icmp uge i64 %0, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp ule i64 %1, 4294967295
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  ret %struct.bpf_func_state* %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__update_reg_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %0) #20
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg64_bounds(%struct.bpf_reg_state* noundef %1) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg32_deduce_bounds(%struct.bpf_reg_state* noundef %0) #20
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg64_deduce_bounds(%struct.bpf_reg_state* noundef %1) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_bound_offset(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %var64_off = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %var32_off = alloca %struct.tnum, align 8
  %agg.tmp2 = alloca %struct.tnum, align 8
  %agg.tmp5 = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp10 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 8
  %2 = load i64, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 9
  %4 = load i64, i64* %umax_value, align 8
  %call = call { i64, i64 } @tnum_range(i64 noundef %2, i64 noundef %4) #20
  %5 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %15 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = load i64, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = load i64, i64* %18, align 8
  %call1 = call { i64, i64 } @tnum_intersect(i64 %12, i64 %14, i64 %17, i64 %19) #20
  %20 = bitcast %struct.tnum* %var64_off to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = extractvalue { i64, i64 } %call1, 0
  store i64 %22, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = extractvalue { i64, i64 } %call1, 1
  store i64 %24, i64* %23, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 5
  %26 = bitcast %struct.tnum* %var_off3 to { i64, i64 }*
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 0
  %28 = load i64, i64* %27, align 8
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 1
  %30 = load i64, i64* %29, align 8
  %call4 = call { i64, i64 } @tnum_subreg(i64 %28, i64 %30) #20
  %31 = bitcast %struct.tnum* %agg.tmp2 to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = extractvalue { i64, i64 } %call4, 0
  store i64 %33, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = extractvalue { i64, i64 } %call4, 1
  store i64 %35, i64* %34, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 12
  %37 = load i32, i32* %u32_min_value, align 8
  %conv = zext i32 %37 to i64
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 13
  %39 = load i32, i32* %u32_max_value, align 4
  %conv6 = zext i32 %39 to i64
  %call7 = call { i64, i64 } @tnum_range(i64 noundef %conv, i64 noundef %conv6) #20
  %40 = bitcast %struct.tnum* %agg.tmp5 to { i64, i64 }*
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %40, i32 0, i32 0
  %42 = extractvalue { i64, i64 } %call7, 0
  store i64 %42, i64* %41, align 8
  %43 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %40, i32 0, i32 1
  %44 = extractvalue { i64, i64 } %call7, 1
  store i64 %44, i64* %43, align 8
  %45 = bitcast %struct.tnum* %agg.tmp2 to { i64, i64 }*
  %46 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %45, i32 0, i32 0
  %47 = load i64, i64* %46, align 8
  %48 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %45, i32 0, i32 1
  %49 = load i64, i64* %48, align 8
  %50 = bitcast %struct.tnum* %agg.tmp5 to { i64, i64 }*
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 0
  %52 = load i64, i64* %51, align 8
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 1
  %54 = load i64, i64* %53, align 8
  %call8 = call { i64, i64 } @tnum_intersect(i64 %47, i64 %49, i64 %52, i64 %54) #20
  %55 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 0
  %57 = extractvalue { i64, i64 } %call8, 0
  store i64 %57, i64* %56, align 8
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 1
  %59 = extractvalue { i64, i64 } %call8, 1
  store i64 %59, i64* %58, align 8
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i32 0, i32 5
  %61 = bitcast %struct.tnum* %var64_off to { i64, i64 }*
  %62 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 0
  %63 = load i64, i64* %62, align 8
  %64 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 1
  %65 = load i64, i64* %64, align 8
  %call11 = call { i64, i64 } @tnum_clear_subreg(i64 %63, i64 %65) #20
  %66 = bitcast %struct.tnum* %agg.tmp10 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = extractvalue { i64, i64 } %call11, 0
  store i64 %68, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = extractvalue { i64, i64 } %call11, 1
  store i64 %70, i64* %69, align 8
  %71 = bitcast %struct.tnum* %agg.tmp10 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %76 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %77 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 0
  %78 = load i64, i64* %77, align 8
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 1
  %80 = load i64, i64* %79, align 8
  %call12 = call { i64, i64 } @tnum_or(i64 %73, i64 %75, i64 %78, i64 %80) #20
  %81 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %82 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 0
  %83 = extractvalue { i64, i64 } %call12, 0
  store i64 %83, i64* %82, align 8
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 1
  %85 = extractvalue { i64, i64 } %call12, 1
  store i64 %85, i64* %84, align 8
  %86 = bitcast %struct.tnum* %var_off9 to i8*
  %87 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %86, i8* align 8 %87, i64 16, i1 false)
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %var32_off = alloca %struct.tnum, align 8
  %__UNIQUE_ID___x527 = alloca i32, align 4
  %__UNIQUE_ID___y528 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__UNIQUE_ID___x529 = alloca i32, align 4
  %__UNIQUE_ID___y530 = alloca i32, align 4
  %tmp8 = alloca i32, align 4
  %__UNIQUE_ID___x531 = alloca i32, align 4
  %__UNIQUE_ID___y532 = alloca i32, align 4
  %tmp18 = alloca i32, align 4
  %__UNIQUE_ID___x533 = alloca i32, align 4
  %__UNIQUE_ID___y534 = alloca i32, align 4
  %tmp30 = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %3, i64 %5) #20
  %6 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 10
  %12 = load i32, i32* %s32_min_value, align 8
  store i32 %12, i32* %__UNIQUE_ID___x527, align 4
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %13 = load i64, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %14 = load i64, i64* %mask, align 8
  %and = and i64 %14, -2147483648
  %or = or i64 %13, %and
  %conv = trunc i64 %or to i32
  store i32 %conv, i32* %__UNIQUE_ID___y528, align 4
  %15 = load i32, i32* %__UNIQUE_ID___x527, align 4
  %16 = load i32, i32* %__UNIQUE_ID___y528, align 4
  %cmp = icmp sgt i32 %15, %16
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %17 = load i32, i32* %__UNIQUE_ID___x527, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %18 = load i32, i32* %__UNIQUE_ID___y528, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %17, %cond.true ], [ %18, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %19 = load i32, i32* %tmp, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 10
  store i32 %19, i32* %s32_min_value2, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 11
  %22 = load i32, i32* %s32_max_value, align 4
  store i32 %22, i32* %__UNIQUE_ID___x529, align 4
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %23 = load i64, i64* %value3, align 8
  %mask4 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %24 = load i64, i64* %mask4, align 8
  %and5 = and i64 %24, 2147483647
  %or6 = or i64 %23, %and5
  %conv7 = trunc i64 %or6 to i32
  store i32 %conv7, i32* %__UNIQUE_ID___y530, align 4
  %25 = load i32, i32* %__UNIQUE_ID___x529, align 4
  %26 = load i32, i32* %__UNIQUE_ID___y530, align 4
  %cmp9 = icmp slt i32 %25, %26
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.end
  %27 = load i32, i32* %__UNIQUE_ID___x529, align 4
  br label %cond.end13

cond.false12:                                     ; preds = %cond.end
  %28 = load i32, i32* %__UNIQUE_ID___y530, align 4
  br label %cond.end13

cond.end13:                                       ; preds = %cond.false12, %cond.true11
  %cond14 = phi i32 [ %27, %cond.true11 ], [ %28, %cond.false12 ]
  store i32 %cond14, i32* %tmp8, align 4
  %29 = load i32, i32* %tmp8, align 4
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 11
  store i32 %29, i32* %s32_max_value15, align 4
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 12
  %32 = load i32, i32* %u32_min_value, align 8
  store i32 %32, i32* %__UNIQUE_ID___x531, align 4
  %value16 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %33 = load i64, i64* %value16, align 8
  %conv17 = trunc i64 %33 to i32
  store i32 %conv17, i32* %__UNIQUE_ID___y532, align 4
  %34 = load i32, i32* %__UNIQUE_ID___x531, align 4
  %35 = load i32, i32* %__UNIQUE_ID___y532, align 4
  %cmp19 = icmp ugt i32 %34, %35
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.end13
  %36 = load i32, i32* %__UNIQUE_ID___x531, align 4
  br label %cond.end23

cond.false22:                                     ; preds = %cond.end13
  %37 = load i32, i32* %__UNIQUE_ID___y532, align 4
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false22, %cond.true21
  %cond24 = phi i32 [ %36, %cond.true21 ], [ %37, %cond.false22 ]
  store i32 %cond24, i32* %tmp18, align 4
  %38 = load i32, i32* %tmp18, align 4
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 12
  store i32 %38, i32* %u32_min_value25, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 13
  %41 = load i32, i32* %u32_max_value, align 4
  store i32 %41, i32* %__UNIQUE_ID___x533, align 4
  %value26 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %42 = load i64, i64* %value26, align 8
  %mask27 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %43 = load i64, i64* %mask27, align 8
  %or28 = or i64 %42, %43
  %conv29 = trunc i64 %or28 to i32
  store i32 %conv29, i32* %__UNIQUE_ID___y534, align 4
  %44 = load i32, i32* %__UNIQUE_ID___x533, align 4
  %45 = load i32, i32* %__UNIQUE_ID___y534, align 4
  %cmp31 = icmp ult i32 %44, %45
  br i1 %cmp31, label %cond.true33, label %cond.false34

cond.true33:                                      ; preds = %cond.end23
  %46 = load i32, i32* %__UNIQUE_ID___x533, align 4
  br label %cond.end35

cond.false34:                                     ; preds = %cond.end23
  %47 = load i32, i32* %__UNIQUE_ID___y534, align 4
  br label %cond.end35

cond.end35:                                       ; preds = %cond.false34, %cond.true33
  %cond36 = phi i32 [ %46, %cond.true33 ], [ %47, %cond.false34 ]
  store i32 %cond36, i32* %tmp30, align 4
  %48 = load i32, i32* %tmp30, align 4
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value37 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 13
  store i32 %48, i32* %u32_max_value37, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__update_reg64_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x535 = alloca i64, align 8
  %__UNIQUE_ID___y536 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__UNIQUE_ID___x537 = alloca i64, align 8
  %__UNIQUE_ID___y538 = alloca i64, align 8
  %tmp9 = alloca i64, align 8
  %__UNIQUE_ID___x539 = alloca i64, align 8
  %__UNIQUE_ID___y540 = alloca i64, align 8
  %tmp18 = alloca i64, align 8
  %__UNIQUE_ID___x541 = alloca i64, align 8
  %__UNIQUE_ID___y542 = alloca i64, align 8
  %tmp30 = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %__UNIQUE_ID___x535, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %3 = load i64, i64* %value, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off1, i32 0, i32 1
  %5 = load i64, i64* %mask, align 8
  %and = and i64 %5, -9223372036854775808
  %or = or i64 %3, %and
  store i64 %or, i64* %__UNIQUE_ID___y536, align 8
  %6 = load i64, i64* %__UNIQUE_ID___x535, align 8
  %7 = load i64, i64* %__UNIQUE_ID___y536, align 8
  %cmp = icmp sgt i64 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i64, i64* %__UNIQUE_ID___x535, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i64, i64* %__UNIQUE_ID___y536, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %8, %cond.true ], [ %9, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %10 = load i64, i64* %tmp, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 6
  store i64 %10, i64* %smin_value2, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  store i64 %13, i64* %__UNIQUE_ID___x537, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %value4 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off3, i32 0, i32 0
  %15 = load i64, i64* %value4, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 5
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 1
  %17 = load i64, i64* %mask6, align 8
  %and7 = and i64 %17, 9223372036854775807
  %or8 = or i64 %15, %and7
  store i64 %or8, i64* %__UNIQUE_ID___y538, align 8
  %18 = load i64, i64* %__UNIQUE_ID___x537, align 8
  %19 = load i64, i64* %__UNIQUE_ID___y538, align 8
  %cmp10 = icmp slt i64 %18, %19
  br i1 %cmp10, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.end
  %20 = load i64, i64* %__UNIQUE_ID___x537, align 8
  br label %cond.end13

cond.false12:                                     ; preds = %cond.end
  %21 = load i64, i64* %__UNIQUE_ID___y538, align 8
  br label %cond.end13

cond.end13:                                       ; preds = %cond.false12, %cond.true11
  %cond14 = phi i64 [ %20, %cond.true11 ], [ %21, %cond.false12 ]
  store i64 %cond14, i64* %tmp9, align 8
  %22 = load i64, i64* %tmp9, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 7
  store i64 %22, i64* %smax_value15, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 8
  %25 = load i64, i64* %umin_value, align 8
  store i64 %25, i64* %__UNIQUE_ID___x539, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 5
  %value17 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off16, i32 0, i32 0
  %27 = load i64, i64* %value17, align 8
  store i64 %27, i64* %__UNIQUE_ID___y540, align 8
  %28 = load i64, i64* %__UNIQUE_ID___x539, align 8
  %29 = load i64, i64* %__UNIQUE_ID___y540, align 8
  %cmp19 = icmp ugt i64 %28, %29
  br i1 %cmp19, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %cond.end13
  %30 = load i64, i64* %__UNIQUE_ID___x539, align 8
  br label %cond.end22

cond.false21:                                     ; preds = %cond.end13
  %31 = load i64, i64* %__UNIQUE_ID___y540, align 8
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false21, %cond.true20
  %cond23 = phi i64 [ %30, %cond.true20 ], [ %31, %cond.false21 ]
  store i64 %cond23, i64* %tmp18, align 8
  %32 = load i64, i64* %tmp18, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 8
  store i64 %32, i64* %umin_value24, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 9
  %35 = load i64, i64* %umax_value, align 8
  store i64 %35, i64* %__UNIQUE_ID___x541, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 5
  %value26 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off25, i32 0, i32 0
  %37 = load i64, i64* %value26, align 8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 5
  %mask28 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off27, i32 0, i32 1
  %39 = load i64, i64* %mask28, align 8
  %or29 = or i64 %37, %39
  store i64 %or29, i64* %__UNIQUE_ID___y542, align 8
  %40 = load i64, i64* %__UNIQUE_ID___x541, align 8
  %41 = load i64, i64* %__UNIQUE_ID___y542, align 8
  %cmp31 = icmp ult i64 %40, %41
  br i1 %cmp31, label %cond.true32, label %cond.false33

cond.true32:                                      ; preds = %cond.end22
  %42 = load i64, i64* %__UNIQUE_ID___x541, align 8
  br label %cond.end34

cond.false33:                                     ; preds = %cond.end22
  %43 = load i64, i64* %__UNIQUE_ID___y542, align 8
  br label %cond.end34

cond.end34:                                       ; preds = %cond.false33, %cond.true32
  %cond35 = phi i64 [ %42, %cond.true32 ], [ %43, %cond.false33 ]
  store i64 %cond35, i64* %tmp30, align 8
  %44 = load i64, i64* %tmp30, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value36 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 9
  store i64 %44, i64* %umax_value36, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg32_deduce_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x543 = alloca i32, align 4
  %__UNIQUE_ID___y544 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__UNIQUE_ID___x545 = alloca i32, align 4
  %__UNIQUE_ID___y546 = alloca i32, align 4
  %tmp7 = alloca i32, align 4
  %__UNIQUE_ID___x547 = alloca i32, align 4
  %__UNIQUE_ID___y548 = alloca i32, align 4
  %tmp22 = alloca i32, align 4
  %__UNIQUE_ID___x549 = alloca i32, align 4
  %__UNIQUE_ID___y550 = alloca i32, align 4
  %tmp35 = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  %1 = load i32, i32* %s32_min_value, align 8
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 11
  %3 = load i32, i32* %s32_max_value, align 4
  %cmp1 = icmp slt i32 %3, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 10
  %5 = load i32, i32* %s32_min_value2, align 8
  store i32 %5, i32* %__UNIQUE_ID___x543, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 12
  %7 = load i32, i32* %u32_min_value, align 8
  store i32 %7, i32* %__UNIQUE_ID___y544, align 4
  %8 = load i32, i32* %__UNIQUE_ID___x543, align 4
  %9 = load i32, i32* %__UNIQUE_ID___y544, align 4
  %cmp3 = icmp ugt i32 %8, %9
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %10 = load i32, i32* %__UNIQUE_ID___x543, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %11 = load i32, i32* %__UNIQUE_ID___y544, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %12 = load i32, i32* %tmp, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 12
  store i32 %12, i32* %u32_min_value4, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  store i32 %12, i32* %s32_min_value5, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 11
  %16 = load i32, i32* %s32_max_value6, align 4
  store i32 %16, i32* %__UNIQUE_ID___x545, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 13
  %18 = load i32, i32* %u32_max_value, align 4
  store i32 %18, i32* %__UNIQUE_ID___y546, align 4
  %19 = load i32, i32* %__UNIQUE_ID___x545, align 4
  %20 = load i32, i32* %__UNIQUE_ID___y546, align 4
  %cmp8 = icmp ult i32 %19, %20
  br i1 %cmp8, label %cond.true9, label %cond.false10

cond.true9:                                       ; preds = %cond.end
  %21 = load i32, i32* %__UNIQUE_ID___x545, align 4
  br label %cond.end11

cond.false10:                                     ; preds = %cond.end
  %22 = load i32, i32* %__UNIQUE_ID___y546, align 4
  br label %cond.end11

cond.end11:                                       ; preds = %cond.false10, %cond.true9
  %cond12 = phi i32 [ %21, %cond.true9 ], [ %22, %cond.false10 ]
  store i32 %cond12, i32* %tmp7, align 4
  %23 = load i32, i32* %tmp7, align 4
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 13
  store i32 %23, i32* %u32_max_value13, align 4
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 11
  store i32 %23, i32* %s32_max_value14, align 4
  br label %if.end46

if.end:                                           ; preds = %lor.lhs.false
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 13
  %27 = load i32, i32* %u32_max_value15, align 4
  %cmp16 = icmp sge i32 %27, 0
  br i1 %cmp16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 12
  %29 = load i32, i32* %u32_min_value18, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 10
  store i32 %29, i32* %s32_min_value19, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 11
  %32 = load i32, i32* %s32_max_value20, align 4
  store i32 %32, i32* %__UNIQUE_ID___x547, align 4
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 13
  %34 = load i32, i32* %u32_max_value21, align 4
  store i32 %34, i32* %__UNIQUE_ID___y548, align 4
  %35 = load i32, i32* %__UNIQUE_ID___x547, align 4
  %36 = load i32, i32* %__UNIQUE_ID___y548, align 4
  %cmp23 = icmp ult i32 %35, %36
  br i1 %cmp23, label %cond.true24, label %cond.false25

cond.true24:                                      ; preds = %if.then17
  %37 = load i32, i32* %__UNIQUE_ID___x547, align 4
  br label %cond.end26

cond.false25:                                     ; preds = %if.then17
  %38 = load i32, i32* %__UNIQUE_ID___y548, align 4
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false25, %cond.true24
  %cond27 = phi i32 [ %37, %cond.true24 ], [ %38, %cond.false25 ]
  store i32 %cond27, i32* %tmp22, align 4
  %39 = load i32, i32* %tmp22, align 4
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 13
  store i32 %39, i32* %u32_max_value28, align 4
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 11
  store i32 %39, i32* %s32_max_value29, align 4
  br label %if.end46

if.else:                                          ; preds = %if.end
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 12
  %43 = load i32, i32* %u32_min_value30, align 8
  %cmp31 = icmp slt i32 %43, 0
  br i1 %cmp31, label %if.then32, label %if.end45

if.then32:                                        ; preds = %if.else
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 10
  %45 = load i32, i32* %s32_min_value33, align 8
  store i32 %45, i32* %__UNIQUE_ID___x549, align 4
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 12
  %47 = load i32, i32* %u32_min_value34, align 8
  store i32 %47, i32* %__UNIQUE_ID___y550, align 4
  %48 = load i32, i32* %__UNIQUE_ID___x549, align 4
  %49 = load i32, i32* %__UNIQUE_ID___y550, align 4
  %cmp36 = icmp ugt i32 %48, %49
  br i1 %cmp36, label %cond.true37, label %cond.false38

cond.true37:                                      ; preds = %if.then32
  %50 = load i32, i32* %__UNIQUE_ID___x549, align 4
  br label %cond.end39

cond.false38:                                     ; preds = %if.then32
  %51 = load i32, i32* %__UNIQUE_ID___y550, align 4
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true37
  %cond40 = phi i32 [ %50, %cond.true37 ], [ %51, %cond.false38 ]
  store i32 %cond40, i32* %tmp35, align 4
  %52 = load i32, i32* %tmp35, align 4
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 12
  store i32 %52, i32* %u32_min_value41, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 10
  store i32 %52, i32* %s32_min_value42, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 13
  %56 = load i32, i32* %u32_max_value43, align 4
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 11
  store i32 %56, i32* %s32_max_value44, align 4
  br label %if.end45

if.end45:                                         ; preds = %cond.end39, %if.else
  br label %if.end46

if.end46:                                         ; preds = %cond.end11, %if.end45, %cond.end26
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg64_deduce_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x551 = alloca i64, align 8
  %__UNIQUE_ID___y552 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__UNIQUE_ID___x553 = alloca i64, align 8
  %__UNIQUE_ID___y554 = alloca i64, align 8
  %tmp7 = alloca i64, align 8
  %__UNIQUE_ID___x555 = alloca i64, align 8
  %__UNIQUE_ID___y556 = alloca i64, align 8
  %tmp22 = alloca i64, align 8
  %__UNIQUE_ID___x557 = alloca i64, align 8
  %__UNIQUE_ID___y558 = alloca i64, align 8
  %tmp35 = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  %cmp = icmp sge i64 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 7
  %3 = load i64, i64* %smax_value, align 8
  %cmp1 = icmp slt i64 %3, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 6
  %5 = load i64, i64* %smin_value2, align 8
  store i64 %5, i64* %__UNIQUE_ID___x551, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 8
  %7 = load i64, i64* %umin_value, align 8
  store i64 %7, i64* %__UNIQUE_ID___y552, align 8
  %8 = load i64, i64* %__UNIQUE_ID___x551, align 8
  %9 = load i64, i64* %__UNIQUE_ID___y552, align 8
  %cmp3 = icmp ugt i64 %8, %9
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %10 = load i64, i64* %__UNIQUE_ID___x551, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %11 = load i64, i64* %__UNIQUE_ID___y552, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %10, %cond.true ], [ %11, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %12 = load i64, i64* %tmp, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 8
  store i64 %12, i64* %umin_value4, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 %12, i64* %smin_value5, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  %16 = load i64, i64* %smax_value6, align 8
  store i64 %16, i64* %__UNIQUE_ID___x553, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 9
  %18 = load i64, i64* %umax_value, align 8
  store i64 %18, i64* %__UNIQUE_ID___y554, align 8
  %19 = load i64, i64* %__UNIQUE_ID___x553, align 8
  %20 = load i64, i64* %__UNIQUE_ID___y554, align 8
  %cmp8 = icmp ult i64 %19, %20
  br i1 %cmp8, label %cond.true9, label %cond.false10

cond.true9:                                       ; preds = %cond.end
  %21 = load i64, i64* %__UNIQUE_ID___x553, align 8
  br label %cond.end11

cond.false10:                                     ; preds = %cond.end
  %22 = load i64, i64* %__UNIQUE_ID___y554, align 8
  br label %cond.end11

cond.end11:                                       ; preds = %cond.false10, %cond.true9
  %cond12 = phi i64 [ %21, %cond.true9 ], [ %22, %cond.false10 ]
  store i64 %cond12, i64* %tmp7, align 8
  %23 = load i64, i64* %tmp7, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 9
  store i64 %23, i64* %umax_value13, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 7
  store i64 %23, i64* %smax_value14, align 8
  br label %if.end46

if.end:                                           ; preds = %lor.lhs.false
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  %27 = load i64, i64* %umax_value15, align 8
  %cmp16 = icmp sge i64 %27, 0
  br i1 %cmp16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 8
  %29 = load i64, i64* %umin_value18, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 6
  store i64 %29, i64* %smin_value19, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 7
  %32 = load i64, i64* %smax_value20, align 8
  store i64 %32, i64* %__UNIQUE_ID___x555, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 9
  %34 = load i64, i64* %umax_value21, align 8
  store i64 %34, i64* %__UNIQUE_ID___y556, align 8
  %35 = load i64, i64* %__UNIQUE_ID___x555, align 8
  %36 = load i64, i64* %__UNIQUE_ID___y556, align 8
  %cmp23 = icmp ult i64 %35, %36
  br i1 %cmp23, label %cond.true24, label %cond.false25

cond.true24:                                      ; preds = %if.then17
  %37 = load i64, i64* %__UNIQUE_ID___x555, align 8
  br label %cond.end26

cond.false25:                                     ; preds = %if.then17
  %38 = load i64, i64* %__UNIQUE_ID___y556, align 8
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false25, %cond.true24
  %cond27 = phi i64 [ %37, %cond.true24 ], [ %38, %cond.false25 ]
  store i64 %cond27, i64* %tmp22, align 8
  %39 = load i64, i64* %tmp22, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 9
  store i64 %39, i64* %umax_value28, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 7
  store i64 %39, i64* %smax_value29, align 8
  br label %if.end46

if.else:                                          ; preds = %if.end
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 8
  %43 = load i64, i64* %umin_value30, align 8
  %cmp31 = icmp slt i64 %43, 0
  br i1 %cmp31, label %if.then32, label %if.end45

if.then32:                                        ; preds = %if.else
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 6
  %45 = load i64, i64* %smin_value33, align 8
  store i64 %45, i64* %__UNIQUE_ID___x557, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 8
  %47 = load i64, i64* %umin_value34, align 8
  store i64 %47, i64* %__UNIQUE_ID___y558, align 8
  %48 = load i64, i64* %__UNIQUE_ID___x557, align 8
  %49 = load i64, i64* %__UNIQUE_ID___y558, align 8
  %cmp36 = icmp ugt i64 %48, %49
  br i1 %cmp36, label %cond.true37, label %cond.false38

cond.true37:                                      ; preds = %if.then32
  %50 = load i64, i64* %__UNIQUE_ID___x557, align 8
  br label %cond.end39

cond.false38:                                     ; preds = %if.then32
  %51 = load i64, i64* %__UNIQUE_ID___y558, align 8
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true37
  %cond40 = phi i64 [ %50, %cond.true37 ], [ %51, %cond.false38 ]
  store i64 %cond40, i64* %tmp35, align 8
  %52 = load i64, i64* %tmp35, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 8
  store i64 %52, i64* %umin_value41, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 6
  store i64 %52, i64* %smin_value42, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 9
  %56 = load i64, i64* %umax_value43, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 7
  store i64 %56, i64* %smax_value44, align 8
  br label %if.end45

if.end45:                                         ; preds = %cond.end39, %if.else
  br label %if.end46

if.end46:                                         ; preds = %cond.end11, %if.end45, %cond.end26
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_intersect(i64, i64, i64, i64) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_range(i64 noundef, i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_or(i64, i64, i64, i64) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_clear_subreg(i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_subreg_is_const(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %a to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %5, i64 %7) #20
  %8 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 1
  %13 = load i64, i64* %mask, align 8
  %tobool = icmp ne i64 %13, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @sanitize_needed(i8 noundef zeroext %opcode) #0 {
entry:
  %opcode.addr = alloca i8, align 1
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i8, i8* %opcode.addr, align 1
  %conv2 = zext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 16
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp3, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @sanitize_val_alu(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_insn_aux_data* %call, %struct.bpf_insn_aux_data** %aux, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call1 = call zeroext i1 @can_skip_alu_sanitation(%struct.bpf_verifier_env* noundef %1, %struct.bpf_insn* noundef %2) #20
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call2 = call i32 @update_alu_sanitation_state(%struct.bpf_insn_aux_data* noundef %3, i32 noundef 8, i32 noundef 0) #20
  store i32 %call2, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, i32* %retval, align 4
  ret i32 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @sanitize_err(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32 noundef %reason, %struct.bpf_reg_state* noundef %off_reg, %struct.bpf_reg_state* noundef %dst_reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %reason.addr = alloca i32, align 4
  %off_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %op = alloca i8*, align 8
  %dst = alloca i32, align 4
  %src = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32 %reason, i32* %reason.addr, align 4
  store %struct.bpf_reg_state* %off_reg, %struct.bpf_reg_state** %off_reg.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 240
  %cmp = icmp eq i32 %and, 0
  %2 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.208, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.209, i64 0, i64 0)
  store i8* %cond, i8** %op, align 8
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %3, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg2, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv3 = zext i8 %bf.clear to i32
  store i32 %conv3, i32* %dst, align 4
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 1
  %bf.load4 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load4, 4
  %conv5 = zext i8 %bf.lshr to i32
  store i32 %conv5, i32* %src, align 4
  %5 = load i32, i32* %reason.addr, align 4
  switch i32 %5, label %sw.default [
    i32 -1, label %sw.bb
    i32 -2, label %sw.bb9
    i32 -3, label %sw.bb16
    i32 -4, label %sw.bb17
    i32 -5, label %sw.bb18
  ]

sw.bb:                                            ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %cmp6 = icmp eq %struct.bpf_reg_state* %8, %9
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb
  %10 = load i32, i32* %dst, align 4
  br label %cond.end

cond.false:                                       ; preds = %sw.bb
  %11 = load i32, i32* %src, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond8 = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  %12 = load i8*, i8** @sanitize_err.err, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.210, i64 0, i64 0), i32 noundef %cond8, i8* noundef %12) #20
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %cmp10 = icmp eq %struct.bpf_reg_state* %15, %16
  br i1 %cmp10, label %cond.true12, label %cond.false13

cond.true12:                                      ; preds = %sw.bb9
  %17 = load i32, i32* %src, align 4
  br label %cond.end14

cond.false13:                                     ; preds = %sw.bb9
  %18 = load i32, i32* %dst, align 4
  br label %cond.end14

cond.end14:                                       ; preds = %cond.false13, %cond.true12
  %cond15 = phi i32 [ %17, %cond.true12 ], [ %18, %cond.false13 ]
  %19 = load i8*, i8** @sanitize_err.err, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.211, i64 0, i64 0), i32 noundef %cond15, i8* noundef %19) #20
  br label %sw.epilog

sw.bb16:                                          ; preds = %entry
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  %22 = load i32, i32* %dst, align 4
  %23 = load i8*, i8** %op, align 8
  %24 = load i8*, i8** @sanitize_err.err, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.212, i64 0, i64 0), i32 noundef %22, i8* noundef %23, i8* noundef %24) #20
  br label %sw.epilog

sw.bb17:                                          ; preds = %entry
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load i32, i32* %dst, align 4
  %28 = load i8*, i8** %op, align 8
  %29 = load i8*, i8** @sanitize_err.err, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.213, i64 0, i64 0), i32 noundef %27, i8* noundef %28, i8* noundef %29) #20
  br label %sw.epilog

sw.bb18:                                          ; preds = %entry
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load i32, i32* %dst, align 4
  %33 = load i8*, i8** @sanitize_err.err, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([58 x i8], [58 x i8]* @.str.214, i64 0, i64 0), i32 noundef %32, i8* noundef %33) #20
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load i32, i32* %reason.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.215, i64 0, i64 0), i32 noundef %36) #20
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb18, %sw.bb17, %sw.bb16, %cond.end14, %cond.end
  ret i32 -13
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_add(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i32, align 4
  %smax_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %umax_val = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  %1 = load i32, i32* %s32_min_value, align 8
  store i32 %1, i32* %smin_val, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 11
  %3 = load i32, i32* %s32_max_value, align 4
  store i32 %3, i32* %smax_val, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 12
  %5 = load i32, i32* %u32_min_value, align 8
  store i32 %5, i32* %umin_val, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 13
  %7 = load i32, i32* %u32_max_value, align 4
  store i32 %7, i32* %umax_val, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 10
  %9 = load i32, i32* %s32_min_value1, align 8
  %10 = load i32, i32* %smin_val, align 4
  %call = call zeroext i1 @signed_add32_overflows(i32 noundef %9, i32 noundef %10) #20
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 11
  %12 = load i32, i32* %s32_max_value2, align 4
  %13 = load i32, i32* %smax_val, align 4
  %call3 = call zeroext i1 @signed_add32_overflows(i32 noundef %12, i32 noundef %13) #20
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value4, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value5, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %16 = load i32, i32* %smin_val, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 10
  %18 = load i32, i32* %s32_min_value6, align 8
  %add = add i32 %18, %16
  store i32 %add, i32* %s32_min_value6, align 8
  %19 = load i32, i32* %smax_val, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 11
  %21 = load i32, i32* %s32_max_value7, align 4
  %add8 = add i32 %21, %19
  store i32 %add8, i32* %s32_max_value7, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 12
  %23 = load i32, i32* %u32_min_value9, align 8
  %24 = load i32, i32* %umin_val, align 4
  %add10 = add i32 %23, %24
  %25 = load i32, i32* %umin_val, align 4
  %cmp = icmp ult i32 %add10, %25
  br i1 %cmp, label %if.then15, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %if.end
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 13
  %27 = load i32, i32* %u32_max_value12, align 4
  %28 = load i32, i32* %umax_val, align 4
  %add13 = add i32 %27, %28
  %29 = load i32, i32* %umax_val, align 4
  %cmp14 = icmp ult i32 %add13, %29
  br i1 %cmp14, label %if.then15, label %if.else18

if.then15:                                        ; preds = %lor.lhs.false11, %if.end
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 12
  store i32 0, i32* %u32_min_value16, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 13
  store i32 -1, i32* %u32_max_value17, align 4
  br label %if.end23

if.else18:                                        ; preds = %lor.lhs.false11
  %32 = load i32, i32* %umin_val, align 4
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 12
  %34 = load i32, i32* %u32_min_value19, align 8
  %add20 = add i32 %34, %32
  store i32 %add20, i32* %u32_min_value19, align 8
  %35 = load i32, i32* %umax_val, align 4
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 13
  %37 = load i32, i32* %u32_max_value21, align 4
  %add22 = add i32 %37, %35
  store i32 %add22, i32* %u32_max_value21, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.else18, %if.then15
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_add(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %smin_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 7
  %3 = load i64, i64* %smax_value, align 8
  store i64 %3, i64* %smax_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 8
  %5 = load i64, i64* %umin_value, align 8
  store i64 %5, i64* %umin_val, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 9
  %7 = load i64, i64* %umax_value, align 8
  store i64 %7, i64* %umax_val, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value1, align 8
  %10 = load i64, i64* %smin_val, align 8
  %call = call zeroext i1 @signed_add_overflows(i64 noundef %9, i64 noundef %10) #20
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 7
  %12 = load i64, i64* %smax_value2, align 8
  %13 = load i64, i64* %smax_val, align 8
  %call3 = call zeroext i1 @signed_add_overflows(i64 noundef %12, i64 noundef %13) #20
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value4, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value5, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %16 = load i64, i64* %smin_val, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value6, align 8
  %add = add i64 %18, %16
  store i64 %add, i64* %smin_value6, align 8
  %19 = load i64, i64* %smax_val, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 7
  %21 = load i64, i64* %smax_value7, align 8
  %add8 = add i64 %21, %19
  store i64 %add8, i64* %smax_value7, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 8
  %23 = load i64, i64* %umin_value9, align 8
  %24 = load i64, i64* %umin_val, align 8
  %add10 = add i64 %23, %24
  %25 = load i64, i64* %umin_val, align 8
  %cmp = icmp ult i64 %add10, %25
  br i1 %cmp, label %if.then15, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %if.end
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  %27 = load i64, i64* %umax_value12, align 8
  %28 = load i64, i64* %umax_val, align 8
  %add13 = add i64 %27, %28
  %29 = load i64, i64* %umax_val, align 8
  %cmp14 = icmp ult i64 %add13, %29
  br i1 %cmp14, label %if.then15, label %if.else18

if.then15:                                        ; preds = %lor.lhs.false11, %if.end
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 8
  store i64 0, i64* %umin_value16, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 9
  store i64 -1, i64* %umax_value17, align 8
  br label %if.end23

if.else18:                                        ; preds = %lor.lhs.false11
  %32 = load i64, i64* %umin_val, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 8
  %34 = load i64, i64* %umin_value19, align 8
  %add20 = add i64 %34, %32
  store i64 %add20, i64* %umin_value19, align 8
  %35 = load i64, i64* %umax_val, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 9
  %37 = load i64, i64* %umax_value21, align 8
  %add22 = add i64 %37, %35
  store i64 %add22, i64* %umax_value21, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.else18, %if.then15
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_sub(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i32, align 4
  %smax_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %umax_val = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  %1 = load i32, i32* %s32_min_value, align 8
  store i32 %1, i32* %smin_val, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 11
  %3 = load i32, i32* %s32_max_value, align 4
  store i32 %3, i32* %smax_val, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 12
  %5 = load i32, i32* %u32_min_value, align 8
  store i32 %5, i32* %umin_val, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 13
  %7 = load i32, i32* %u32_max_value, align 4
  store i32 %7, i32* %umax_val, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 10
  %9 = load i32, i32* %s32_min_value1, align 8
  %10 = load i32, i32* %smax_val, align 4
  %call = call zeroext i1 @signed_sub32_overflows(i32 noundef %9, i32 noundef %10) #20
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 11
  %12 = load i32, i32* %s32_max_value2, align 4
  %13 = load i32, i32* %smin_val, align 4
  %call3 = call zeroext i1 @signed_sub32_overflows(i32 noundef %12, i32 noundef %13) #20
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value4, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value5, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %16 = load i32, i32* %smax_val, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 10
  %18 = load i32, i32* %s32_min_value6, align 8
  %sub = sub i32 %18, %16
  store i32 %sub, i32* %s32_min_value6, align 8
  %19 = load i32, i32* %smin_val, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 11
  %21 = load i32, i32* %s32_max_value7, align 4
  %sub8 = sub i32 %21, %19
  store i32 %sub8, i32* %s32_max_value7, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 12
  %23 = load i32, i32* %u32_min_value9, align 8
  %24 = load i32, i32* %umax_val, align 4
  %cmp = icmp ult i32 %23, %24
  br i1 %cmp, label %if.then10, label %if.else13

if.then10:                                        ; preds = %if.end
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 12
  store i32 0, i32* %u32_min_value11, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 13
  store i32 -1, i32* %u32_max_value12, align 4
  br label %if.end18

if.else13:                                        ; preds = %if.end
  %27 = load i32, i32* %umax_val, align 4
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 12
  %29 = load i32, i32* %u32_min_value14, align 8
  %sub15 = sub i32 %29, %27
  store i32 %sub15, i32* %u32_min_value14, align 8
  %30 = load i32, i32* %umin_val, align 4
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 13
  %32 = load i32, i32* %u32_max_value16, align 4
  %sub17 = sub i32 %32, %30
  store i32 %sub17, i32* %u32_max_value16, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.else13, %if.then10
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_sub(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %smin_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 7
  %3 = load i64, i64* %smax_value, align 8
  store i64 %3, i64* %smax_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 8
  %5 = load i64, i64* %umin_value, align 8
  store i64 %5, i64* %umin_val, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 9
  %7 = load i64, i64* %umax_value, align 8
  store i64 %7, i64* %umax_val, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value1, align 8
  %10 = load i64, i64* %smax_val, align 8
  %call = call zeroext i1 @signed_sub_overflows(i64 noundef %9, i64 noundef %10) #20
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 7
  %12 = load i64, i64* %smax_value2, align 8
  %13 = load i64, i64* %smin_val, align 8
  %call3 = call zeroext i1 @signed_sub_overflows(i64 noundef %12, i64 noundef %13) #20
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value4, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value5, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %16 = load i64, i64* %smax_val, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value6, align 8
  %sub = sub i64 %18, %16
  store i64 %sub, i64* %smin_value6, align 8
  %19 = load i64, i64* %smin_val, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 7
  %21 = load i64, i64* %smax_value7, align 8
  %sub8 = sub i64 %21, %19
  store i64 %sub8, i64* %smax_value7, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 8
  %23 = load i64, i64* %umin_value9, align 8
  %24 = load i64, i64* %umax_val, align 8
  %cmp = icmp ult i64 %23, %24
  br i1 %cmp, label %if.then10, label %if.else13

if.then10:                                        ; preds = %if.end
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 8
  store i64 0, i64* %umin_value11, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  store i64 -1, i64* %umax_value12, align 8
  br label %if.end18

if.else13:                                        ; preds = %if.end
  %27 = load i64, i64* %umax_val, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 8
  %29 = load i64, i64* %umin_value14, align 8
  %sub15 = sub i64 %29, %27
  store i64 %sub15, i64* %umin_value14, align 8
  %30 = load i64, i64* %umin_val, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 9
  %32 = load i64, i64* %umax_value16, align 8
  %sub17 = sub i64 %32, %30
  store i64 %sub17, i64* %umax_value16, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.else13, %if.then10
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_sub(i64, i64, i64, i64) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_mul(i64, i64, i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_mul(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %umax_val = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  %1 = load i32, i32* %s32_min_value, align 8
  store i32 %1, i32* %smin_val, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 12
  %3 = load i32, i32* %u32_min_value, align 8
  store i32 %3, i32* %umin_val, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 13
  %5 = load i32, i32* %u32_max_value, align 4
  store i32 %5, i32* %umax_val, align 4
  %6 = load i32, i32* %smin_val, align 4
  %cmp = icmp slt i32 %6, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 10
  %8 = load i32, i32* %s32_min_value1, align 8
  %cmp2 = icmp slt i32 %8, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %9) #20
  br label %if.end20

if.end:                                           ; preds = %lor.lhs.false
  %10 = load i32, i32* %umax_val, align 4
  %cmp3 = icmp ugt i32 %10, 65535
  br i1 %cmp3, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 13
  %12 = load i32, i32* %u32_max_value5, align 4
  %cmp6 = icmp ugt i32 %12, 65535
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %lor.lhs.false4, %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %13) #20
  br label %if.end20

if.end8:                                          ; preds = %lor.lhs.false4
  %14 = load i32, i32* %umin_val, align 4
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 12
  %16 = load i32, i32* %u32_min_value9, align 8
  %mul = mul i32 %16, %14
  store i32 %mul, i32* %u32_min_value9, align 8
  %17 = load i32, i32* %umax_val, align 4
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 13
  %19 = load i32, i32* %u32_max_value10, align 4
  %mul11 = mul i32 %19, %17
  store i32 %mul11, i32* %u32_max_value10, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 13
  %21 = load i32, i32* %u32_max_value12, align 4
  %cmp13 = icmp ugt i32 %21, 2147483647
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value15, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  br label %if.end20

if.else:                                          ; preds = %if.end8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 12
  %25 = load i32, i32* %u32_min_value16, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 10
  store i32 %25, i32* %s32_min_value17, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 13
  %28 = load i32, i32* %u32_max_value18, align 4
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 11
  store i32 %28, i32* %s32_max_value19, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.then, %if.then7, %if.else, %if.then14
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_mul(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %smin_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value, align 8
  store i64 %3, i64* %umin_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 9
  %5 = load i64, i64* %umax_value, align 8
  store i64 %5, i64* %umax_val, align 8
  %6 = load i64, i64* %smin_val, align 8
  %cmp = icmp slt i64 %6, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 6
  %8 = load i64, i64* %smin_value1, align 8
  %cmp2 = icmp slt i64 %8, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %9) #20
  br label %if.end20

if.end:                                           ; preds = %lor.lhs.false
  %10 = load i64, i64* %umax_val, align 8
  %cmp3 = icmp ugt i64 %10, 4294967295
  br i1 %cmp3, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 9
  %12 = load i64, i64* %umax_value5, align 8
  %cmp6 = icmp ugt i64 %12, 4294967295
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %lor.lhs.false4, %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %13) #20
  br label %if.end20

if.end8:                                          ; preds = %lor.lhs.false4
  %14 = load i64, i64* %umin_val, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 8
  %16 = load i64, i64* %umin_value9, align 8
  %mul = mul i64 %16, %14
  store i64 %mul, i64* %umin_value9, align 8
  %17 = load i64, i64* %umax_val, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 9
  %19 = load i64, i64* %umax_value10, align 8
  %mul11 = mul i64 %19, %17
  store i64 %mul11, i64* %umax_value10, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  %21 = load i64, i64* %umax_value12, align 8
  %cmp13 = icmp ugt i64 %21, 9223372036854775807
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value15, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  br label %if.end20

if.else:                                          ; preds = %if.end8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 8
  %25 = load i64, i64* %umin_value16, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 6
  store i64 %25, i64* %smin_value17, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 9
  %28 = load i64, i64* %umax_value18, align 8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 7
  store i64 %28, i64* %smax_value19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.then, %if.then7, %if.else, %if.then14
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_and(i64, i64, i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_and(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %var32_off = alloca %struct.tnum, align 8
  %smin_val = alloca i32, align 4
  %umax_val = alloca i32, align 4
  %__UNIQUE_ID___x566 = alloca i32, align 4
  %__UNIQUE_ID___y567 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_subreg_is_const(i64 %3, i64 %5) #20
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_subreg_is_const(i64 %9, i64 %11) #20
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %13 = bitcast %struct.tnum* %var_off4 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call5 = call { i64, i64 } @tnum_subreg(i64 %15, i64 %17) #20
  %18 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call5, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call5, 1
  store i64 %22, i64* %21, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 10
  %24 = load i32, i32* %s32_min_value, align 8
  store i32 %24, i32* %smin_val, align 4
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 13
  %26 = load i32, i32* %u32_max_value, align 4
  store i32 %26, i32* %umax_val, align 4
  %27 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %27 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %28 = load i8, i8* %dst_known, align 1
  %tobool6 = trunc i8 %28 to i1
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %30 = load i64, i64* %value, align 8
  call void @__mark_reg32_known(%struct.bpf_reg_state* noundef %29, i64 noundef %30) #20
  br label %if.end22

if.end:                                           ; preds = %land.lhs.true, %entry
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %31 = load i64, i64* %value7, align 8
  %conv = trunc i64 %31 to i32
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 12
  store i32 %conv, i32* %u32_min_value, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 13
  %34 = load i32, i32* %u32_max_value8, align 4
  store i32 %34, i32* %__UNIQUE_ID___x566, align 4
  %35 = load i32, i32* %umax_val, align 4
  store i32 %35, i32* %__UNIQUE_ID___y567, align 4
  %36 = load i32, i32* %__UNIQUE_ID___x566, align 4
  %37 = load i32, i32* %__UNIQUE_ID___y567, align 4
  %cmp = icmp ult i32 %36, %37
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %38 = load i32, i32* %__UNIQUE_ID___x566, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %39 = load i32, i32* %__UNIQUE_ID___y567, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %38, %cond.true ], [ %39, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %40 = load i32, i32* %tmp, align 4
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 13
  store i32 %40, i32* %u32_max_value10, align 4
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 10
  %43 = load i32, i32* %s32_min_value11, align 8
  %cmp12 = icmp slt i32 %43, 0
  br i1 %cmp12, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %44 = load i32, i32* %smin_val, align 4
  %cmp14 = icmp slt i32 %44, 0
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %lor.lhs.false, %cond.end
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value17, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  br label %if.end22

if.else:                                          ; preds = %lor.lhs.false
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 12
  %48 = load i32, i32* %u32_min_value18, align 8
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 10
  store i32 %48, i32* %s32_min_value19, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 13
  %51 = load i32, i32* %u32_max_value20, align 4
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 11
  store i32 %51, i32* %s32_max_value21, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.then, %if.else, %if.then16
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_and(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  %__UNIQUE_ID___x568 = alloca i64, align 8
  %__UNIQUE_ID___y569 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #20
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %9, i64 %11) #20
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value, align 8
  store i64 %13, i64* %smin_val, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 9
  %15 = load i64, i64* %umax_value, align 8
  store i64 %15, i64* %umax_val, align 8
  %16 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %17 = load i8, i8* %dst_known, align 1
  %tobool4 = trunc i8 %17 to i1
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %20 = load i64, i64* %value, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %18, i64 noundef %20) #20
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 5
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off6, i32 0, i32 0
  %22 = load i64, i64* %value7, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 8
  store i64 %22, i64* %umin_value, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 9
  %25 = load i64, i64* %umax_value8, align 8
  store i64 %25, i64* %__UNIQUE_ID___x568, align 8
  %26 = load i64, i64* %umax_val, align 8
  store i64 %26, i64* %__UNIQUE_ID___y569, align 8
  %27 = load i64, i64* %__UNIQUE_ID___x568, align 8
  %28 = load i64, i64* %__UNIQUE_ID___y569, align 8
  %cmp = icmp ult i64 %27, %28
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %29 = load i64, i64* %__UNIQUE_ID___x568, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %30 = load i64, i64* %__UNIQUE_ID___y569, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %29, %cond.true ], [ %30, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %31 = load i64, i64* %tmp, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 9
  store i64 %31, i64* %umax_value9, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 6
  %34 = load i64, i64* %smin_value10, align 8
  %cmp11 = icmp slt i64 %34, 0
  br i1 %cmp11, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %35 = load i64, i64* %smin_val, align 8
  %cmp12 = icmp slt i64 %35, 0
  br i1 %cmp12, label %if.then13, label %if.else

if.then13:                                        ; preds = %lor.lhs.false, %cond.end
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value14, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  br label %if.end19

if.else:                                          ; preds = %lor.lhs.false
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 8
  %39 = load i64, i64* %umin_value15, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 6
  store i64 %39, i64* %smin_value16, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 9
  %42 = load i64, i64* %umax_value17, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 7
  store i64 %42, i64* %smax_value18, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then13
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %44) #20
  br label %return

return:                                           ; preds = %if.end19, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_or(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %var32_off = alloca %struct.tnum, align 8
  %smin_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %__UNIQUE_ID___x570 = alloca i32, align 4
  %__UNIQUE_ID___y571 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_subreg_is_const(i64 %3, i64 %5) #20
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_subreg_is_const(i64 %9, i64 %11) #20
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %13 = bitcast %struct.tnum* %var_off4 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call5 = call { i64, i64 } @tnum_subreg(i64 %15, i64 %17) #20
  %18 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call5, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call5, 1
  store i64 %22, i64* %21, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 10
  %24 = load i32, i32* %s32_min_value, align 8
  store i32 %24, i32* %smin_val, align 4
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 12
  %26 = load i32, i32* %u32_min_value, align 8
  store i32 %26, i32* %umin_val, align 4
  %27 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %27 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %28 = load i8, i8* %dst_known, align 1
  %tobool6 = trunc i8 %28 to i1
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %30 = load i64, i64* %value, align 8
  call void @__mark_reg32_known(%struct.bpf_reg_state* noundef %29, i64 noundef %30) #20
  br label %if.end21

if.end:                                           ; preds = %land.lhs.true, %entry
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 12
  %32 = load i32, i32* %u32_min_value7, align 8
  store i32 %32, i32* %__UNIQUE_ID___x570, align 4
  %33 = load i32, i32* %umin_val, align 4
  store i32 %33, i32* %__UNIQUE_ID___y571, align 4
  %34 = load i32, i32* %__UNIQUE_ID___x570, align 4
  %35 = load i32, i32* %__UNIQUE_ID___y571, align 4
  %cmp = icmp ugt i32 %34, %35
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %36 = load i32, i32* %__UNIQUE_ID___x570, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %37 = load i32, i32* %__UNIQUE_ID___y571, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %36, %cond.true ], [ %37, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %38 = load i32, i32* %tmp, align 4
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 12
  store i32 %38, i32* %u32_min_value8, align 8
  %value9 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %40 = load i64, i64* %value9, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %41 = load i64, i64* %mask, align 8
  %or = or i64 %40, %41
  %conv = trunc i64 %or to i32
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 13
  store i32 %conv, i32* %u32_max_value, align 4
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 10
  %44 = load i32, i32* %s32_min_value10, align 8
  %cmp11 = icmp slt i32 %44, 0
  br i1 %cmp11, label %if.then15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %45 = load i32, i32* %smin_val, align 4
  %cmp13 = icmp slt i32 %45, 0
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %lor.lhs.false, %cond.end
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value16, align 8
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  br label %if.end21

if.else:                                          ; preds = %lor.lhs.false
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 12
  %49 = load i32, i32* %u32_min_value17, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 10
  store i32 %49, i32* %s32_min_value18, align 8
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %51, i32 0, i32 13
  %52 = load i32, i32* %u32_max_value19, align 4
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 11
  store i32 %52, i32* %s32_max_value20, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then, %if.else, %if.then15
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_or(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %__UNIQUE_ID___x572 = alloca i64, align 8
  %__UNIQUE_ID___y573 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #20
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %9, i64 %11) #20
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value, align 8
  store i64 %13, i64* %smin_val, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 8
  %15 = load i64, i64* %umin_value, align 8
  store i64 %15, i64* %umin_val, align 8
  %16 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %17 = load i8, i8* %dst_known, align 1
  %tobool4 = trunc i8 %17 to i1
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %20 = load i64, i64* %value, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %18, i64 noundef %20) #20
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 8
  %22 = load i64, i64* %umin_value6, align 8
  store i64 %22, i64* %__UNIQUE_ID___x572, align 8
  %23 = load i64, i64* %umin_val, align 8
  store i64 %23, i64* %__UNIQUE_ID___y573, align 8
  %24 = load i64, i64* %__UNIQUE_ID___x572, align 8
  %25 = load i64, i64* %__UNIQUE_ID___y573, align 8
  %cmp = icmp ugt i64 %24, %25
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %26 = load i64, i64* %__UNIQUE_ID___x572, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %27 = load i64, i64* %__UNIQUE_ID___y573, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %26, %cond.true ], [ %27, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %28 = load i64, i64* %tmp, align 8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 8
  store i64 %28, i64* %umin_value7, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %value9 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off8, i32 0, i32 0
  %31 = load i64, i64* %value9, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off10, i32 0, i32 1
  %33 = load i64, i64* %mask, align 8
  %or = or i64 %31, %33
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 9
  store i64 %or, i64* %umax_value, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 6
  %36 = load i64, i64* %smin_value11, align 8
  %cmp12 = icmp slt i64 %36, 0
  br i1 %cmp12, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %37 = load i64, i64* %smin_val, align 8
  %cmp13 = icmp slt i64 %37, 0
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %lor.lhs.false, %cond.end
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value15, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  br label %if.end20

if.else:                                          ; preds = %lor.lhs.false
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 8
  %41 = load i64, i64* %umin_value16, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 6
  store i64 %41, i64* %smin_value17, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 9
  %44 = load i64, i64* %umax_value18, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 7
  store i64 %44, i64* %smax_value19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then14
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %46) #20
  br label %return

return:                                           ; preds = %if.end20, %if.then
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_xor(i64, i64, i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_xor(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %var32_off = alloca %struct.tnum, align 8
  %smin_val = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_subreg_is_const(i64 %3, i64 %5) #20
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_subreg_is_const(i64 %9, i64 %11) #20
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %13 = bitcast %struct.tnum* %var_off4 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call5 = call { i64, i64 } @tnum_subreg(i64 %15, i64 %17) #20
  %18 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call5, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call5, 1
  store i64 %22, i64* %21, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 10
  %24 = load i32, i32* %s32_min_value, align 8
  store i32 %24, i32* %smin_val, align 4
  %25 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %25 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %26 = load i8, i8* %dst_known, align 1
  %tobool6 = trunc i8 %26 to i1
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %28 = load i64, i64* %value, align 8
  call void @__mark_reg32_known(%struct.bpf_reg_state* noundef %27, i64 noundef %28) #20
  br label %if.end21

if.end:                                           ; preds = %land.lhs.true, %entry
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %29 = load i64, i64* %value7, align 8
  %conv = trunc i64 %29 to i32
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 12
  store i32 %conv, i32* %u32_min_value, align 8
  %value8 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %31 = load i64, i64* %value8, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %32 = load i64, i64* %mask, align 8
  %or = or i64 %31, %32
  %conv9 = trunc i64 %or to i32
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 13
  store i32 %conv9, i32* %u32_max_value, align 4
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 10
  %35 = load i32, i32* %s32_min_value10, align 8
  %cmp = icmp sge i32 %35, 0
  br i1 %cmp, label %land.lhs.true12, label %if.else

land.lhs.true12:                                  ; preds = %if.end
  %36 = load i32, i32* %smin_val, align 4
  %cmp13 = icmp sge i32 %36, 0
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %land.lhs.true12
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 12
  %38 = load i32, i32* %u32_min_value16, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 10
  store i32 %38, i32* %s32_min_value17, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 13
  %41 = load i32, i32* %u32_max_value18, align 4
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 11
  store i32 %41, i32* %s32_max_value, align 4
  br label %if.end21

if.else:                                          ; preds = %land.lhs.true12, %if.end
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value19, align 8
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value20, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then, %if.else, %if.then15
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_xor(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #20
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %9, i64 %11) #20
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value, align 8
  store i64 %13, i64* %smin_val, align 8
  %14 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %14 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %15 = load i8, i8* %dst_known, align 1
  %tobool4 = trunc i8 %15 to i1
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %18 = load i64, i64* %value, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %16, i64 noundef %18) #20
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off6, i32 0, i32 0
  %20 = load i64, i64* %value7, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 8
  store i64 %20, i64* %umin_value, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 5
  %value9 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off8, i32 0, i32 0
  %23 = load i64, i64* %value9, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off10, i32 0, i32 1
  %25 = load i64, i64* %mask, align 8
  %or = or i64 %23, %25
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  store i64 %or, i64* %umax_value, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 6
  %28 = load i64, i64* %smin_value11, align 8
  %cmp = icmp sge i64 %28, 0
  br i1 %cmp, label %land.lhs.true12, label %if.else

land.lhs.true12:                                  ; preds = %if.end
  %29 = load i64, i64* %smin_val, align 8
  %cmp13 = icmp sge i64 %29, 0
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %land.lhs.true12
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 8
  %31 = load i64, i64* %umin_value15, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 6
  store i64 %31, i64* %smin_value16, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 9
  %34 = load i64, i64* %umax_value17, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 7
  store i64 %34, i64* %smax_value, align 8
  br label %if.end20

if.else:                                          ; preds = %land.lhs.true12, %if.end
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value18, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then14
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %38) #20
  br label %return

return:                                           ; preds = %if.end20, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = bitcast %struct.tnum* %var_off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %3) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umax_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %subreg = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 13
  %1 = load i32, i32* %u32_max_value, align 4
  store i32 %1, i32* %umax_val, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 12
  %3 = load i32, i32* %u32_min_value, align 8
  store i32 %3, i32* %umin_val, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %5 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = load i64, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %7, i64 %9) #20
  %10 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = extractvalue { i64, i64 } %call, 0
  store i64 %12, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = extractvalue { i64, i64 } %call, 1
  store i64 %14, i64* %13, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %16 = load i32, i32* %umin_val, align 4
  %conv = zext i32 %16 to i64
  %17 = load i32, i32* %umax_val, align 4
  %conv1 = zext i32 %17 to i64
  call void @__scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %15, i64 noundef %conv, i64 noundef %conv1) #20
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = load i32, i32* %umin_val, align 4
  %conv3 = trunc i32 %19 to i8
  %20 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = load i64, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = load i64, i64* %23, align 8
  %call4 = call { i64, i64 } @tnum_lshift(i64 %22, i64 %24, i8 noundef zeroext %conv3) #20
  %25 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 0
  %27 = extractvalue { i64, i64 } %call4, 0
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 1
  %29 = extractvalue { i64, i64 } %call4, 1
  store i64 %29, i64* %28, align 8
  %30 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call5 = call { i64, i64 } @tnum_subreg(i64 %32, i64 %34) #20
  %35 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 0
  %37 = extractvalue { i64, i64 } %call5, 0
  store i64 %37, i64* %36, align 8
  %38 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 1
  %39 = extractvalue { i64, i64 } %call5, 1
  store i64 %39, i64* %38, align 8
  %40 = bitcast %struct.tnum* %var_off2 to i8*
  %41 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %40, i8* align 8 %41, i64 16, i1 false)
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %42) #20
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %43) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_lsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 9
  %1 = load i64, i64* %umax_value, align 8
  store i64 %1, i64* %umax_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value, align 8
  store i64 %3, i64* %umin_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %5 = load i64, i64* %umin_val, align 8
  %6 = load i64, i64* %umax_val, align 8
  call void @__scalar64_min_max_lsh(%struct.bpf_reg_state* noundef %4, i64 noundef %5, i64 noundef %6) #20
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %8 = load i64, i64* %umin_val, align 8
  %9 = load i64, i64* %umax_val, align 8
  call void @__scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %7, i64 noundef %8, i64 noundef %9) #20
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 5
  %12 = load i64, i64* %umin_val, align 8
  %conv = trunc i64 %12 to i8
  %13 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call = call { i64, i64 } @tnum_lshift(i64 %15, i64 %17, i8 noundef zeroext %conv) #20
  %18 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call, 1
  store i64 %22, i64* %21, align 8
  %23 = bitcast %struct.tnum* %var_off to i8*
  %24 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %23, i8* align 8 %24, i64 16, i1 false)
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %25) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_rsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %subreg = alloca %struct.tnum, align 8
  %umax_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %3, i64 %5) #20
  %6 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 13
  %12 = load i32, i32* %u32_max_value, align 4
  store i32 %12, i32* %umax_val, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 12
  %14 = load i32, i32* %u32_min_value, align 8
  store i32 %14, i32* %umin_val, align 4
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = load i32, i32* %umin_val, align 4
  %conv = trunc i32 %18 to i8
  %19 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call2 = call { i64, i64 } @tnum_rshift(i64 %21, i64 %23, i8 noundef zeroext %conv) #20
  %24 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call2, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call2, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %var_off1 to i8*
  %30 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %29, i8* align 8 %30, i64 16, i1 false)
  %31 = load i32, i32* %umax_val, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 12
  %33 = load i32, i32* %u32_min_value3, align 8
  %shr = lshr i32 %33, %31
  store i32 %shr, i32* %u32_min_value3, align 8
  %34 = load i32, i32* %umin_val, align 4
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 13
  %36 = load i32, i32* %u32_max_value4, align 4
  %shr5 = lshr i32 %36, %34
  store i32 %shr5, i32* %u32_max_value4, align 4
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %37) #20
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %38) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_rsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 9
  %1 = load i64, i64* %umax_value, align 8
  store i64 %1, i64* %umax_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value, align 8
  store i64 %3, i64* %umin_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = load i64, i64* %umin_val, align 8
  %conv = trunc i64 %8 to i8
  %9 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %9, i32 0, i32 0
  %11 = load i64, i64* %10, align 8
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %9, i32 0, i32 1
  %13 = load i64, i64* %12, align 8
  %call = call { i64, i64 } @tnum_rshift(i64 %11, i64 %13, i8 noundef zeroext %conv) #20
  %14 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 0
  %16 = extractvalue { i64, i64 } %call, 0
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 1
  %18 = extractvalue { i64, i64 } %call, 1
  store i64 %18, i64* %17, align 8
  %19 = bitcast %struct.tnum* %var_off to i8*
  %20 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 %20, i64 16, i1 false)
  %21 = load i64, i64* %umax_val, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 8
  %23 = load i64, i64* %umin_value2, align 8
  %shr = lshr i64 %23, %21
  store i64 %shr, i64* %umin_value2, align 8
  %24 = load i64, i64* %umin_val, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 9
  %26 = load i64, i64* %umax_value3, align 8
  %shr4 = lshr i64 %26, %24
  store i64 %shr4, i64* %umax_value3, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %27) #20
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %28) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_arsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umin_val = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 12
  %1 = load i32, i32* %u32_min_value, align 8
  %conv = zext i32 %1 to i64
  store i64 %conv, i64* %umin_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 10
  %3 = load i32, i32* %s32_min_value, align 8
  %4 = load i64, i64* %umin_val, align 8
  %sh_prom = trunc i64 %4 to i32
  %shr = ashr i32 %3, %sh_prom
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 10
  store i32 %shr, i32* %s32_min_value1, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 11
  %7 = load i32, i32* %s32_max_value, align 4
  %8 = load i64, i64* %umin_val, align 8
  %sh_prom2 = trunc i64 %8 to i32
  %shr3 = ashr i32 %7, %sh_prom2
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 11
  store i32 %shr3, i32* %s32_max_value4, align 4
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 5
  %12 = bitcast %struct.tnum* %var_off5 to { i64, i64 }*
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = load i64, i64* %13, align 8
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %14, i64 %16) #20
  %17 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i64, i64 } %call, 0
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i64, i64 } %call, 1
  store i64 %21, i64* %20, align 8
  %22 = load i64, i64* %umin_val, align 8
  %conv6 = trunc i64 %22 to i8
  %23 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  %call7 = call { i64, i64 } @tnum_arshift(i64 %25, i64 %27, i8 noundef zeroext %conv6, i8 noundef zeroext 32) #20
  %28 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %28, i32 0, i32 0
  %30 = extractvalue { i64, i64 } %call7, 0
  store i64 %30, i64* %29, align 8
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %28, i32 0, i32 1
  %32 = extractvalue { i64, i64 } %call7, 1
  store i64 %32, i64* %31, align 8
  %33 = bitcast %struct.tnum* %var_off to i8*
  %34 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %33, i8* align 8 %34, i64 16, i1 false)
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 12
  store i32 0, i32* %u32_min_value8, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 13
  store i32 -1, i32* %u32_max_value, align 4
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %37) #20
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %38) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_arsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umin_val = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 8
  %1 = load i64, i64* %umin_value, align 8
  store i64 %1, i64* %umin_val, align 8
  %2 = load i64, i64* %umin_val, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 6
  %4 = load i64, i64* %smin_value, align 8
  %shr = ashr i64 %4, %2
  store i64 %shr, i64* %smin_value, align 8
  %5 = load i64, i64* %umin_val, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 7
  %7 = load i64, i64* %smax_value, align 8
  %shr1 = ashr i64 %7, %5
  store i64 %shr1, i64* %smax_value, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 5
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 5
  %10 = load i64, i64* %umin_val, align 8
  %conv = trunc i64 %10 to i8
  %11 = bitcast %struct.tnum* %var_off2 to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call = call { i64, i64 } @tnum_arshift(i64 %13, i64 %15, i8 noundef zeroext %conv, i8 noundef zeroext 64) #20
  %16 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call, 1
  store i64 %20, i64* %19, align 8
  %21 = bitcast %struct.tnum* %var_off to i8*
  %22 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %22, i64 16, i1 false)
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 8
  store i64 0, i64* %umin_value3, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 9
  store i64 -1, i64* %umax_value, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %25) #20
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %26) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @zext_32_to_64(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = load i64, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = load i64, i64* %5, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %4, i64 %6) #20
  %7 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = extractvalue { i64, i64 } %call, 0
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = extractvalue { i64, i64 } %call, 1
  store i64 %11, i64* %10, align 8
  %12 = bitcast %struct.tnum* %var_off to i8*
  %13 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 8 %13, i64 16, i1 false)
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_assign_32_into_64(%struct.bpf_reg_state* noundef %14) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 0
  %3 = load i32, i32* %insn_idx, align 8
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  ret %struct.bpf_insn_aux_data* %arrayidx
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @can_skip_alu_sanitation(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 21
  %1 = load i8, i8* %bypass_spec_v1, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code, align 4
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 8
  %cmp = icmp eq i32 %and, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @update_alu_sanitation_state(%struct.bpf_insn_aux_data* noundef %aux, i32 noundef %alu_state, i32 noundef %alu_limit) #0 {
entry:
  %retval = alloca i32, align 4
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %alu_state.addr = alloca i32, align 4
  %alu_limit.addr = alloca i32, align 4
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store i32 %alu_state, i32* %alu_state.addr, align 4
  store i32 %alu_limit, i32* %alu_limit.addr, align 4
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %alu_state1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 6
  %1 = load i8, i8* %alu_state1, align 2
  %conv = zext i8 %1 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %alu_state2 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %2, i32 0, i32 6
  %3 = load i8, i8* %alu_state2, align 2
  %conv3 = zext i8 %3 to i32
  %4 = load i32, i32* %alu_state.addr, align 4
  %cmp = icmp ne i32 %conv3, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %5 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %6 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %5, i32 0, i32 0
  %alu_limit5 = bitcast %union.anon.210* %6 to i32*
  %7 = load i32, i32* %alu_limit5, align 8
  %8 = load i32, i32* %alu_limit.addr, align 4
  %cmp6 = icmp ne i32 %7, %8
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  store i32 -3, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %9 = load i32, i32* %alu_state.addr, align 4
  %conv8 = trunc i32 %9 to i8
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %alu_state9 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %10, i32 0, i32 6
  store i8 %conv8, i8* %alu_state9, align 2
  %11 = load i32, i32* %alu_limit.addr, align 4
  %12 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %13 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %12, i32 0, i32 0
  %alu_limit10 = bitcast %union.anon.210* %13 to i32*
  store i32 %11, i32* %alu_limit10, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_add32_overflows(i32 noundef %a, i32 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  %0 = load i32, i32* %a.addr, align 4
  %1 = load i32, i32* %b.addr, align 4
  %add = add i32 %0, %1
  store i32 %add, i32* %res, align 4
  %2 = load i32, i32* %b.addr, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %res, align 4
  %4 = load i32, i32* %a.addr, align 4
  %cmp1 = icmp sgt i32 %3, %4
  store i1 %cmp1, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, i32* %res, align 4
  %6 = load i32, i32* %a.addr, align 4
  %cmp2 = icmp slt i32 %5, %6
  store i1 %cmp2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_add_overflows(i64 noundef %a, i64 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %1 = load i64, i64* %b.addr, align 8
  %add = add i64 %0, %1
  store i64 %add, i64* %res, align 8
  %2 = load i64, i64* %b.addr, align 8
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %res, align 8
  %4 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp sgt i64 %3, %4
  store i1 %cmp1, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %res, align 8
  %6 = load i64, i64* %a.addr, align 8
  %cmp2 = icmp slt i64 %5, %6
  store i1 %cmp2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_sub32_overflows(i32 noundef %a, i32 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  %0 = load i32, i32* %a.addr, align 4
  %1 = load i32, i32* %b.addr, align 4
  %sub = sub i32 %0, %1
  store i32 %sub, i32* %res, align 4
  %2 = load i32, i32* %b.addr, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %res, align 4
  %4 = load i32, i32* %a.addr, align 4
  %cmp1 = icmp slt i32 %3, %4
  store i1 %cmp1, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, i32* %res, align 4
  %6 = load i32, i32* %a.addr, align 4
  %cmp2 = icmp sgt i32 %5, %6
  store i1 %cmp2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_sub_overflows(i64 noundef %a, i64 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %1 = load i64, i64* %b.addr, align 8
  %sub = sub i64 %0, %1
  store i64 %sub, i64* %res, align 8
  %2 = load i64, i64* %b.addr, align 8
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %res, align 8
  %4 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp slt i64 %3, %4
  store i1 %cmp1, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %res, align 8
  %6 = load i64, i64* %a.addr, align 8
  %cmp2 = icmp sgt i64 %5, %6
  store i1 %cmp2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  store i64 0, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 9
  store i64 -1, i64* %umax_value, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg32_known(%struct.bpf_reg_state* noundef %reg, i64 noundef %imm) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %imm.addr = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %imm, i64* %imm.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = load i64, i64* %imm.addr, align 8
  %conv = trunc i64 %2 to i32
  %3 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_const_subreg(i64 %5, i64 %7, i32 noundef %conv) #20
  %8 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %13 = bitcast %struct.tnum* %var_off to i8*
  %14 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 %14, i64 16, i1 false)
  %15 = load i64, i64* %imm.addr, align 8
  %conv2 = trunc i64 %15 to i32
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 10
  store i32 %conv2, i32* %s32_min_value, align 8
  %17 = load i64, i64* %imm.addr, align 8
  %conv3 = trunc i64 %17 to i32
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 11
  store i32 %conv3, i32* %s32_max_value, align 4
  %19 = load i64, i64* %imm.addr, align 8
  %conv4 = trunc i64 %19 to i32
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 12
  store i32 %conv4, i32* %u32_min_value, align 8
  %21 = load i64, i64* %imm.addr, align 8
  %conv5 = trunc i64 %21 to i32
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 13
  store i32 %conv5, i32* %u32_max_value, align 4
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_const_subreg(i64, i64, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %dst_reg, i64 noundef %umin_val, i64 noundef %umax_val) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umin_val.addr = alloca i64, align 8
  %umax_val.addr = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i64 %umin_val, i64* %umin_val.addr, align 8
  store i64 %umax_val, i64* %umax_val.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  %2 = load i64, i64* %umax_val.addr, align 8
  %cmp = icmp ugt i64 %2, 31
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 13
  %4 = load i32, i32* %u32_max_value, align 4
  %conv = zext i32 %4 to i64
  %5 = load i64, i64* %umax_val.addr, align 8
  %sub = sub i64 31, %5
  %shl = shl i64 1, %sub
  %cmp1 = icmp ugt i64 %conv, %shl
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 12
  store i32 0, i32* %u32_min_value, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 13
  store i32 -1, i32* %u32_max_value3, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %8 = load i64, i64* %umin_val.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 12
  %10 = load i32, i32* %u32_min_value4, align 8
  %sh_prom = trunc i64 %8 to i32
  %shl5 = shl i32 %10, %sh_prom
  store i32 %shl5, i32* %u32_min_value4, align 8
  %11 = load i64, i64* %umax_val.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 13
  %13 = load i32, i32* %u32_max_value6, align 4
  %sh_prom7 = trunc i64 %11 to i32
  %shl8 = shl i32 %13, %sh_prom7
  store i32 %shl8, i32* %u32_max_value6, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_lshift(i64, i64, i8 noundef zeroext) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__scalar64_min_max_lsh(%struct.bpf_reg_state* noundef %dst_reg, i64 noundef %umin_val, i64 noundef %umax_val) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umin_val.addr = alloca i64, align 8
  %umax_val.addr = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i64 %umin_val, i64* %umin_val.addr, align 8
  store i64 %umax_val, i64* %umax_val.addr, align 8
  %0 = load i64, i64* %umin_val.addr, align 8
  %cmp = icmp eq i64 %0, 32
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %umax_val.addr, align 8
  %cmp1 = icmp eq i64 %1, 32
  br i1 %cmp1, label %land.lhs.true2, label %if.else

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 11
  %3 = load i32, i32* %s32_max_value, align 4
  %cmp3 = icmp sge i32 %3, 0
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true2
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 11
  %5 = load i32, i32* %s32_max_value4, align 4
  %conv = sext i32 %5 to i64
  %shl = shl i64 %conv, 32
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 7
  store i64 %shl, i64* %smax_value, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true2, %land.lhs.true, %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value5, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %8 = load i64, i64* %umin_val.addr, align 8
  %cmp6 = icmp eq i64 %8, 32
  br i1 %cmp6, label %land.lhs.true8, label %if.else18

land.lhs.true8:                                   ; preds = %if.end
  %9 = load i64, i64* %umax_val.addr, align 8
  %cmp9 = icmp eq i64 %9, 32
  br i1 %cmp9, label %land.lhs.true11, label %if.else18

land.lhs.true11:                                  ; preds = %land.lhs.true8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 10
  %11 = load i32, i32* %s32_min_value, align 8
  %cmp12 = icmp sge i32 %11, 0
  br i1 %cmp12, label %if.then14, label %if.else18

if.then14:                                        ; preds = %land.lhs.true11
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 10
  %13 = load i32, i32* %s32_min_value15, align 8
  %conv16 = sext i32 %13 to i64
  %shl17 = shl i64 %conv16, 32
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 %shl17, i64* %smin_value, align 8
  br label %if.end20

if.else18:                                        ; preds = %land.lhs.true11, %land.lhs.true8, %if.end
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else18, %if.then14
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 9
  %17 = load i64, i64* %umax_value, align 8
  %18 = load i64, i64* %umax_val.addr, align 8
  %sub = sub i64 63, %18
  %shl21 = shl i64 1, %sub
  %cmp22 = icmp ugt i64 %17, %shl21
  br i1 %cmp22, label %if.then24, label %if.else26

if.then24:                                        ; preds = %if.end20
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 8
  store i64 0, i64* %umin_value, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  store i64 -1, i64* %umax_value25, align 8
  br label %if.end31

if.else26:                                        ; preds = %if.end20
  %21 = load i64, i64* %umin_val.addr, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 8
  %23 = load i64, i64* %umin_value27, align 8
  %shl28 = shl i64 %23, %21
  store i64 %shl28, i64* %umin_value27, align 8
  %24 = load i64, i64* %umax_val.addr, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 9
  %26 = load i64, i64* %umax_value29, align 8
  %shl30 = shl i64 %26, %24
  store i64 %shl30, i64* %umax_value29, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.else26, %if.then24
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_rshift(i64, i64, i8 noundef zeroext) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local { i64, i64 } @tnum_arshift(i64, i64, i8 noundef zeroext, i8 noundef zeroext) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_assign_32_into_64(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 12
  %1 = load i32, i32* %u32_min_value, align 8
  %conv = zext i32 %1 to i64
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  store i64 %conv, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 13
  %4 = load i32, i32* %u32_max_value, align 4
  %conv1 = zext i32 %4 to i64
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 9
  store i64 %conv1, i64* %umax_value, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 10
  %7 = load i32, i32* %s32_min_value, align 8
  %call = call zeroext i1 @__reg32_bound_s64(i32 noundef %7) #20
  br i1 %call, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 11
  %9 = load i32, i32* %s32_max_value, align 4
  %call3 = call zeroext i1 @__reg32_bound_s64(i32 noundef %9) #20
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 10
  %11 = load i32, i32* %s32_min_value5, align 8
  %conv6 = sext i32 %11 to i64
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  store i64 %conv6, i64* %smin_value, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 11
  %14 = load i32, i32* %s32_max_value7, align 4
  %conv8 = sext i32 %14 to i64
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  store i64 %conv8, i64* %smax_value, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 6
  store i64 0, i64* %smin_value9, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 7
  store i64 4294967295, i64* %smax_value10, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__reg32_bound_s64(i32 noundef %a) #0 {
entry:
  %a.addr = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  %0 = load i32, i32* %a.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i32, i32* %a.addr, align 4
  %cmp1 = icmp sle i32 %1, 2147483647
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_not_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 11
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 13
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 4
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp5 = icmp eq i32 %3, 5
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false4
  %4 = load i32, i32* %type.addr, align 4
  %cmp6 = icmp eq i32 %4, 12
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp6, %lor.rhs ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_branch32_taken(%struct.bpf_reg_state* noundef %reg, i32 noundef %val, i8 noundef zeroext %opcode) #0 {
entry:
  %retval = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i32, align 4
  %opcode.addr = alloca i8, align 1
  %subreg = alloca %struct.tnum, align 8
  %sval = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %val, i32* %val.addr, align 4
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %3, i64 %5) #20
  %6 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = load i32, i32* %val.addr, align 4
  store i32 %11, i32* %sval, align 4
  %12 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %12 to i32
  switch i32 %conv, label %sw.epilog [
    i32 16, label %sw.bb
    i32 80, label %sw.bb5
    i32 64, label %sw.bb13
    i32 32, label %sw.bb25
    i32 96, label %sw.bb33
    i32 160, label %sw.bb43
    i32 192, label %sw.bb55
    i32 48, label %sw.bb67
    i32 112, label %sw.bb79
    i32 176, label %sw.bb91
    i32 208, label %sw.bb103
  ]

sw.bb:                                            ; preds = %entry
  %13 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call1 = call zeroext i1 @tnum_is_const(i64 %15, i64 %17) #20
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %18 = load i32, i32* %val.addr, align 4
  %conv2 = zext i32 %18 to i64
  %19 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call3 = call zeroext i1 @tnum_equals_const(i64 %21, i64 %23, i64 noundef %conv2) #20
  %lnot = xor i1 %call3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  store i32 %lnot.ext, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %24 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = load i64, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = load i64, i64* %27, align 8
  %call6 = call zeroext i1 @tnum_is_const(i64 %26, i64 %28) #20
  br i1 %call6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %sw.bb5
  %29 = load i32, i32* %val.addr, align 4
  %conv8 = zext i32 %29 to i64
  %30 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call9 = call zeroext i1 @tnum_equals_const(i64 %32, i64 %34, i64 noundef %conv8) #20
  %lnot10 = xor i1 %call9, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  store i32 %lnot.ext11, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %sw.bb5
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %subreg, i32 0, i32 1
  %35 = load i64, i64* %mask, align 8
  %neg = xor i64 %35, -1
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %subreg, i32 0, i32 0
  %36 = load i64, i64* %value, align 8
  %and = and i64 %neg, %36
  %37 = load i32, i32* %val.addr, align 4
  %conv14 = zext i32 %37 to i64
  %and15 = and i64 %and, %conv14
  %tobool = icmp ne i64 %and15, 0
  br i1 %tobool, label %if.then16, label %if.end17

if.then16:                                        ; preds = %sw.bb13
  store i32 1, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %sw.bb13
  %mask18 = getelementptr inbounds %struct.tnum, %struct.tnum* %subreg, i32 0, i32 1
  %38 = load i64, i64* %mask18, align 8
  %value19 = getelementptr inbounds %struct.tnum, %struct.tnum* %subreg, i32 0, i32 0
  %39 = load i64, i64* %value19, align 8
  %or = or i64 %38, %39
  %40 = load i32, i32* %val.addr, align 4
  %conv20 = zext i32 %40 to i64
  %and21 = and i64 %or, %conv20
  %tobool22 = icmp ne i64 %and21, 0
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end17
  store i32 0, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end17
  br label %sw.epilog

sw.bb25:                                          ; preds = %entry
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 12
  %42 = load i32, i32* %u32_min_value, align 8
  %43 = load i32, i32* %val.addr, align 4
  %cmp = icmp ugt i32 %42, %43
  br i1 %cmp, label %if.then27, label %if.else

if.then27:                                        ; preds = %sw.bb25
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %sw.bb25
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 13
  %45 = load i32, i32* %u32_max_value, align 4
  %46 = load i32, i32* %val.addr, align 4
  %cmp28 = icmp ule i32 %45, %46
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.else
  br label %if.end32

if.end32:                                         ; preds = %if.end31
  br label %sw.epilog

sw.bb33:                                          ; preds = %entry
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 10
  %48 = load i32, i32* %s32_min_value, align 8
  %49 = load i32, i32* %sval, align 4
  %cmp34 = icmp sgt i32 %48, %49
  br i1 %cmp34, label %if.then36, label %if.else37

if.then36:                                        ; preds = %sw.bb33
  store i32 1, i32* %retval, align 4
  br label %return

if.else37:                                        ; preds = %sw.bb33
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 11
  %51 = load i32, i32* %s32_max_value, align 4
  %52 = load i32, i32* %sval, align 4
  %cmp38 = icmp sle i32 %51, %52
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.else37
  store i32 0, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.else37
  br label %if.end42

if.end42:                                         ; preds = %if.end41
  br label %sw.epilog

sw.bb43:                                          ; preds = %entry
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 13
  %54 = load i32, i32* %u32_max_value44, align 4
  %55 = load i32, i32* %val.addr, align 4
  %cmp45 = icmp ult i32 %54, %55
  br i1 %cmp45, label %if.then47, label %if.else48

if.then47:                                        ; preds = %sw.bb43
  store i32 1, i32* %retval, align 4
  br label %return

if.else48:                                        ; preds = %sw.bb43
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 12
  %57 = load i32, i32* %u32_min_value49, align 8
  %58 = load i32, i32* %val.addr, align 4
  %cmp50 = icmp uge i32 %57, %58
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.else48
  store i32 0, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.else48
  br label %if.end54

if.end54:                                         ; preds = %if.end53
  br label %sw.epilog

sw.bb55:                                          ; preds = %entry
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value56 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 11
  %60 = load i32, i32* %s32_max_value56, align 4
  %61 = load i32, i32* %sval, align 4
  %cmp57 = icmp slt i32 %60, %61
  br i1 %cmp57, label %if.then59, label %if.else60

if.then59:                                        ; preds = %sw.bb55
  store i32 1, i32* %retval, align 4
  br label %return

if.else60:                                        ; preds = %sw.bb55
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value61 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 10
  %63 = load i32, i32* %s32_min_value61, align 8
  %64 = load i32, i32* %sval, align 4
  %cmp62 = icmp sge i32 %63, %64
  br i1 %cmp62, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.else60
  store i32 0, i32* %retval, align 4
  br label %return

if.end65:                                         ; preds = %if.else60
  br label %if.end66

if.end66:                                         ; preds = %if.end65
  br label %sw.epilog

sw.bb67:                                          ; preds = %entry
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value68 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 12
  %66 = load i32, i32* %u32_min_value68, align 8
  %67 = load i32, i32* %val.addr, align 4
  %cmp69 = icmp uge i32 %66, %67
  br i1 %cmp69, label %if.then71, label %if.else72

if.then71:                                        ; preds = %sw.bb67
  store i32 1, i32* %retval, align 4
  br label %return

if.else72:                                        ; preds = %sw.bb67
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 13
  %69 = load i32, i32* %u32_max_value73, align 4
  %70 = load i32, i32* %val.addr, align 4
  %cmp74 = icmp ult i32 %69, %70
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.else72
  store i32 0, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %if.else72
  br label %if.end78

if.end78:                                         ; preds = %if.end77
  br label %sw.epilog

sw.bb79:                                          ; preds = %entry
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 10
  %72 = load i32, i32* %s32_min_value80, align 8
  %73 = load i32, i32* %sval, align 4
  %cmp81 = icmp sge i32 %72, %73
  br i1 %cmp81, label %if.then83, label %if.else84

if.then83:                                        ; preds = %sw.bb79
  store i32 1, i32* %retval, align 4
  br label %return

if.else84:                                        ; preds = %sw.bb79
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 11
  %75 = load i32, i32* %s32_max_value85, align 4
  %76 = load i32, i32* %sval, align 4
  %cmp86 = icmp slt i32 %75, %76
  br i1 %cmp86, label %if.then88, label %if.end89

if.then88:                                        ; preds = %if.else84
  store i32 0, i32* %retval, align 4
  br label %return

if.end89:                                         ; preds = %if.else84
  br label %if.end90

if.end90:                                         ; preds = %if.end89
  br label %sw.epilog

sw.bb91:                                          ; preds = %entry
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 13
  %78 = load i32, i32* %u32_max_value92, align 4
  %79 = load i32, i32* %val.addr, align 4
  %cmp93 = icmp ule i32 %78, %79
  br i1 %cmp93, label %if.then95, label %if.else96

if.then95:                                        ; preds = %sw.bb91
  store i32 1, i32* %retval, align 4
  br label %return

if.else96:                                        ; preds = %sw.bb91
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value97 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 12
  %81 = load i32, i32* %u32_min_value97, align 8
  %82 = load i32, i32* %val.addr, align 4
  %cmp98 = icmp ugt i32 %81, %82
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %if.else96
  store i32 0, i32* %retval, align 4
  br label %return

if.end101:                                        ; preds = %if.else96
  br label %if.end102

if.end102:                                        ; preds = %if.end101
  br label %sw.epilog

sw.bb103:                                         ; preds = %entry
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value104 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 11
  %84 = load i32, i32* %s32_max_value104, align 4
  %85 = load i32, i32* %sval, align 4
  %cmp105 = icmp sle i32 %84, %85
  br i1 %cmp105, label %if.then107, label %if.else108

if.then107:                                       ; preds = %sw.bb103
  store i32 1, i32* %retval, align 4
  br label %return

if.else108:                                       ; preds = %sw.bb103
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 10
  %87 = load i32, i32* %s32_min_value109, align 8
  %88 = load i32, i32* %sval, align 4
  %cmp110 = icmp sgt i32 %87, %88
  br i1 %cmp110, label %if.then112, label %if.end113

if.then112:                                       ; preds = %if.else108
  store i32 0, i32* %retval, align 4
  br label %return

if.end113:                                        ; preds = %if.else108
  br label %if.end114

if.end114:                                        ; preds = %if.end113
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %if.end114, %if.end102, %if.end90, %if.end78, %if.end66, %if.end54, %if.end42, %if.end32, %if.end24, %if.end12, %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then112, %if.then107, %if.then100, %if.then95, %if.then88, %if.then83, %if.then76, %if.then71, %if.then64, %if.then59, %if.then52, %if.then47, %if.then40, %if.then36, %if.then30, %if.then27, %if.then23, %if.then16, %if.then7, %if.then
  %89 = load i32, i32* %retval, align 4
  ret i32 %89
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_branch64_taken(%struct.bpf_reg_state* noundef %reg, i64 noundef %val, i8 noundef zeroext %opcode) #0 {
entry:
  %retval = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %opcode.addr = alloca i8, align 1
  %sval = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load i64, i64* %val.addr, align 8
  store i64 %0, i64* %sval, align 8
  %1 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %1 to i32
  switch i32 %conv, label %sw.epilog [
    i32 16, label %sw.bb
    i32 80, label %sw.bb4
    i32 64, label %sw.bb13
    i32 32, label %sw.bb27
    i32 96, label %sw.bb35
    i32 160, label %sw.bb45
    i32 192, label %sw.bb57
    i32 48, label %sw.bb69
    i32 112, label %sw.bb81
    i32 176, label %sw.bb93
    i32 208, label %sw.bb105
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %5, i64 %7) #20
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 5
  %9 = load i64, i64* %val.addr, align 8
  %10 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %call2 = call zeroext i1 @tnum_equals_const(i64 %12, i64 %14, i64 noundef %9) #20
  %lnot = xor i1 %call2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  store i32 %lnot.ext, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %16 = bitcast %struct.tnum* %var_off5 to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call6 = call zeroext i1 @tnum_is_const(i64 %18, i64 %20) #20
  br i1 %call6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %sw.bb4
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 5
  %22 = load i64, i64* %val.addr, align 8
  %23 = bitcast %struct.tnum* %var_off8 to { i64, i64 }*
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  %call9 = call zeroext i1 @tnum_equals_const(i64 %25, i64 %27, i64 noundef %22) #20
  %lnot10 = xor i1 %call9, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  store i32 %lnot.ext11, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %sw.bb4
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off14, i32 0, i32 1
  %29 = load i64, i64* %mask, align 8
  %neg = xor i64 %29, -1
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off15, i32 0, i32 0
  %31 = load i64, i64* %value, align 8
  %and = and i64 %neg, %31
  %32 = load i64, i64* %val.addr, align 8
  %and16 = and i64 %and, %32
  %tobool = icmp ne i64 %and16, 0
  br i1 %tobool, label %if.then17, label %if.end18

if.then17:                                        ; preds = %sw.bb13
  store i32 1, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %sw.bb13
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 5
  %mask20 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off19, i32 0, i32 1
  %34 = load i64, i64* %mask20, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %value22 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off21, i32 0, i32 0
  %36 = load i64, i64* %value22, align 8
  %or = or i64 %34, %36
  %37 = load i64, i64* %val.addr, align 8
  %and23 = and i64 %or, %37
  %tobool24 = icmp ne i64 %and23, 0
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end18
  store i32 0, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.end18
  br label %sw.epilog

sw.bb27:                                          ; preds = %entry
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 8
  %39 = load i64, i64* %umin_value, align 8
  %40 = load i64, i64* %val.addr, align 8
  %cmp = icmp ugt i64 %39, %40
  br i1 %cmp, label %if.then29, label %if.else

if.then29:                                        ; preds = %sw.bb27
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %sw.bb27
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 9
  %42 = load i64, i64* %umax_value, align 8
  %43 = load i64, i64* %val.addr, align 8
  %cmp30 = icmp ule i64 %42, %43
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.else
  br label %if.end34

if.end34:                                         ; preds = %if.end33
  br label %sw.epilog

sw.bb35:                                          ; preds = %entry
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 6
  %45 = load i64, i64* %smin_value, align 8
  %46 = load i64, i64* %sval, align 8
  %cmp36 = icmp sgt i64 %45, %46
  br i1 %cmp36, label %if.then38, label %if.else39

if.then38:                                        ; preds = %sw.bb35
  store i32 1, i32* %retval, align 4
  br label %return

if.else39:                                        ; preds = %sw.bb35
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 7
  %48 = load i64, i64* %smax_value, align 8
  %49 = load i64, i64* %sval, align 8
  %cmp40 = icmp sle i64 %48, %49
  br i1 %cmp40, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.else39
  store i32 0, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.else39
  br label %if.end44

if.end44:                                         ; preds = %if.end43
  br label %sw.epilog

sw.bb45:                                          ; preds = %entry
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value46 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 9
  %51 = load i64, i64* %umax_value46, align 8
  %52 = load i64, i64* %val.addr, align 8
  %cmp47 = icmp ult i64 %51, %52
  br i1 %cmp47, label %if.then49, label %if.else50

if.then49:                                        ; preds = %sw.bb45
  store i32 1, i32* %retval, align 4
  br label %return

if.else50:                                        ; preds = %sw.bb45
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value51 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 8
  %54 = load i64, i64* %umin_value51, align 8
  %55 = load i64, i64* %val.addr, align 8
  %cmp52 = icmp uge i64 %54, %55
  br i1 %cmp52, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.else50
  store i32 0, i32* %retval, align 4
  br label %return

if.end55:                                         ; preds = %if.else50
  br label %if.end56

if.end56:                                         ; preds = %if.end55
  br label %sw.epilog

sw.bb57:                                          ; preds = %entry
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 7
  %57 = load i64, i64* %smax_value58, align 8
  %58 = load i64, i64* %sval, align 8
  %cmp59 = icmp slt i64 %57, %58
  br i1 %cmp59, label %if.then61, label %if.else62

if.then61:                                        ; preds = %sw.bb57
  store i32 1, i32* %retval, align 4
  br label %return

if.else62:                                        ; preds = %sw.bb57
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value63 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 6
  %60 = load i64, i64* %smin_value63, align 8
  %61 = load i64, i64* %sval, align 8
  %cmp64 = icmp sge i64 %60, %61
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.else62
  store i32 0, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.else62
  br label %if.end68

if.end68:                                         ; preds = %if.end67
  br label %sw.epilog

sw.bb69:                                          ; preds = %entry
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 8
  %63 = load i64, i64* %umin_value70, align 8
  %64 = load i64, i64* %val.addr, align 8
  %cmp71 = icmp uge i64 %63, %64
  br i1 %cmp71, label %if.then73, label %if.else74

if.then73:                                        ; preds = %sw.bb69
  store i32 1, i32* %retval, align 4
  br label %return

if.else74:                                        ; preds = %sw.bb69
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 9
  %66 = load i64, i64* %umax_value75, align 8
  %67 = load i64, i64* %val.addr, align 8
  %cmp76 = icmp ult i64 %66, %67
  br i1 %cmp76, label %if.then78, label %if.end79

if.then78:                                        ; preds = %if.else74
  store i32 0, i32* %retval, align 4
  br label %return

if.end79:                                         ; preds = %if.else74
  br label %if.end80

if.end80:                                         ; preds = %if.end79
  br label %sw.epilog

sw.bb81:                                          ; preds = %entry
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value82 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 6
  %69 = load i64, i64* %smin_value82, align 8
  %70 = load i64, i64* %sval, align 8
  %cmp83 = icmp sge i64 %69, %70
  br i1 %cmp83, label %if.then85, label %if.else86

if.then85:                                        ; preds = %sw.bb81
  store i32 1, i32* %retval, align 4
  br label %return

if.else86:                                        ; preds = %sw.bb81
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value87 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 7
  %72 = load i64, i64* %smax_value87, align 8
  %73 = load i64, i64* %sval, align 8
  %cmp88 = icmp slt i64 %72, %73
  br i1 %cmp88, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.else86
  store i32 0, i32* %retval, align 4
  br label %return

if.end91:                                         ; preds = %if.else86
  br label %if.end92

if.end92:                                         ; preds = %if.end91
  br label %sw.epilog

sw.bb93:                                          ; preds = %entry
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value94 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 9
  %75 = load i64, i64* %umax_value94, align 8
  %76 = load i64, i64* %val.addr, align 8
  %cmp95 = icmp ule i64 %75, %76
  br i1 %cmp95, label %if.then97, label %if.else98

if.then97:                                        ; preds = %sw.bb93
  store i32 1, i32* %retval, align 4
  br label %return

if.else98:                                        ; preds = %sw.bb93
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value99 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 8
  %78 = load i64, i64* %umin_value99, align 8
  %79 = load i64, i64* %val.addr, align 8
  %cmp100 = icmp ugt i64 %78, %79
  br i1 %cmp100, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.else98
  store i32 0, i32* %retval, align 4
  br label %return

if.end103:                                        ; preds = %if.else98
  br label %if.end104

if.end104:                                        ; preds = %if.end103
  br label %sw.epilog

sw.bb105:                                         ; preds = %entry
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value106 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 7
  %81 = load i64, i64* %smax_value106, align 8
  %82 = load i64, i64* %sval, align 8
  %cmp107 = icmp sle i64 %81, %82
  br i1 %cmp107, label %if.then109, label %if.else110

if.then109:                                       ; preds = %sw.bb105
  store i32 1, i32* %retval, align 4
  br label %return

if.else110:                                       ; preds = %sw.bb105
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value111 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 6
  %84 = load i64, i64* %smin_value111, align 8
  %85 = load i64, i64* %sval, align 8
  %cmp112 = icmp sgt i64 %84, %85
  br i1 %cmp112, label %if.then114, label %if.end115

if.then114:                                       ; preds = %if.else110
  store i32 0, i32* %retval, align 4
  br label %return

if.end115:                                        ; preds = %if.else110
  br label %if.end116

if.end116:                                        ; preds = %if.end115
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %if.end116, %if.end104, %if.end92, %if.end80, %if.end68, %if.end56, %if.end44, %if.end34, %if.end26, %if.end12, %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then114, %if.then109, %if.then102, %if.then97, %if.then90, %if.then85, %if.then78, %if.then73, %if.then66, %if.then61, %if.then54, %if.then49, %if.then42, %if.then38, %if.then32, %if.then29, %if.then25, %if.then17, %if.then7, %if.then
  %86 = load i32, i32* %retval, align 4
  ret i32 %86
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn
define internal zeroext i1 @is_power_of_2(i64 noundef %n) #15 {
entry:
  %n.addr = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load i64, i64* %n.addr, align 8
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i64, i64* %n.addr, align 8
  %2 = load i64, i64* %n.addr, align 8
  %sub = sub i64 %2, 1
  %and = and i64 %1, %sub
  %cmp1 = icmp eq i64 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_combine_32_into_64(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_clear_subreg(i64 %3, i64 %5) #20
  %6 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call1 = call zeroext i1 @tnum_equals_const(i64 %13, i64 %15, i64 noundef 0) #20
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_assign_32_into_64(%struct.bpf_reg_state* noundef %16) #20
  br label %if.end

if.else:                                          ; preds = %entry
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %17) #20
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @reg_bounds_sync(%struct.bpf_reg_state* noundef %18) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @flip_opcode(i32 noundef %opcode) #0 {
entry:
  %opcode.addr = alloca i32, align 4
  store i32 %opcode, i32* %opcode.addr, align 4
  %0 = load i32, i32* %opcode.addr, align 4
  %shr = lshr i32 %0, 4
  %idxprom = zext i32 %shr to i64
  %arrayidx = getelementptr [16 x i8], [16 x i8]* @flip_opcode.opcode_flip, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %1 to i32
  ret i32 %conv
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_combine_min_max(%struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %dst_reg) #0 {
entry:
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x608 = alloca i64, align 8
  %__UNIQUE_ID___y609 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__UNIQUE_ID___x610 = alloca i64, align 8
  %__UNIQUE_ID___y611 = alloca i64, align 8
  %tmp5 = alloca i64, align 8
  %__UNIQUE_ID___x612 = alloca i64, align 8
  %__UNIQUE_ID___y613 = alloca i64, align 8
  %tmp14 = alloca i64, align 8
  %__UNIQUE_ID___x614 = alloca i64, align 8
  %__UNIQUE_ID___y615 = alloca i64, align 8
  %tmp23 = alloca i64, align 8
  %tmp32 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 8
  %1 = load i64, i64* %umin_value, align 8
  store i64 %1, i64* %__UNIQUE_ID___x608, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value1, align 8
  store i64 %3, i64* %__UNIQUE_ID___y609, align 8
  %4 = load i64, i64* %__UNIQUE_ID___x608, align 8
  %5 = load i64, i64* %__UNIQUE_ID___y609, align 8
  %cmp = icmp ugt i64 %4, %5
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load i64, i64* %__UNIQUE_ID___x608, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load i64, i64* %__UNIQUE_ID___y609, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %6, %cond.true ], [ %7, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 8
  store i64 %8, i64* %umin_value2, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 8
  store i64 %8, i64* %umin_value3, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 9
  %12 = load i64, i64* %umax_value, align 8
  store i64 %12, i64* %__UNIQUE_ID___x610, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 9
  %14 = load i64, i64* %umax_value4, align 8
  store i64 %14, i64* %__UNIQUE_ID___y611, align 8
  %15 = load i64, i64* %__UNIQUE_ID___x610, align 8
  %16 = load i64, i64* %__UNIQUE_ID___y611, align 8
  %cmp6 = icmp ult i64 %15, %16
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.end
  %17 = load i64, i64* %__UNIQUE_ID___x610, align 8
  br label %cond.end9

cond.false8:                                      ; preds = %cond.end
  %18 = load i64, i64* %__UNIQUE_ID___y611, align 8
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false8, %cond.true7
  %cond10 = phi i64 [ %17, %cond.true7 ], [ %18, %cond.false8 ]
  store i64 %cond10, i64* %tmp5, align 8
  %19 = load i64, i64* %tmp5, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  store i64 %19, i64* %umax_value11, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 9
  store i64 %19, i64* %umax_value12, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 6
  %23 = load i64, i64* %smin_value, align 8
  store i64 %23, i64* %__UNIQUE_ID___x612, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 6
  %25 = load i64, i64* %smin_value13, align 8
  store i64 %25, i64* %__UNIQUE_ID___y613, align 8
  %26 = load i64, i64* %__UNIQUE_ID___x612, align 8
  %27 = load i64, i64* %__UNIQUE_ID___y613, align 8
  %cmp15 = icmp sgt i64 %26, %27
  br i1 %cmp15, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.end9
  %28 = load i64, i64* %__UNIQUE_ID___x612, align 8
  br label %cond.end18

cond.false17:                                     ; preds = %cond.end9
  %29 = load i64, i64* %__UNIQUE_ID___y613, align 8
  br label %cond.end18

cond.end18:                                       ; preds = %cond.false17, %cond.true16
  %cond19 = phi i64 [ %28, %cond.true16 ], [ %29, %cond.false17 ]
  store i64 %cond19, i64* %tmp14, align 8
  %30 = load i64, i64* %tmp14, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 6
  store i64 %30, i64* %smin_value20, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 6
  store i64 %30, i64* %smin_value21, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 7
  %34 = load i64, i64* %smax_value, align 8
  store i64 %34, i64* %__UNIQUE_ID___x614, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 7
  %36 = load i64, i64* %smax_value22, align 8
  store i64 %36, i64* %__UNIQUE_ID___y615, align 8
  %37 = load i64, i64* %__UNIQUE_ID___x614, align 8
  %38 = load i64, i64* %__UNIQUE_ID___y615, align 8
  %cmp24 = icmp slt i64 %37, %38
  br i1 %cmp24, label %cond.true25, label %cond.false26

cond.true25:                                      ; preds = %cond.end18
  %39 = load i64, i64* %__UNIQUE_ID___x614, align 8
  br label %cond.end27

cond.false26:                                     ; preds = %cond.end18
  %40 = load i64, i64* %__UNIQUE_ID___y615, align 8
  br label %cond.end27

cond.end27:                                       ; preds = %cond.false26, %cond.true25
  %cond28 = phi i64 [ %39, %cond.true25 ], [ %40, %cond.false26 ]
  store i64 %cond28, i64* %tmp23, align 8
  %41 = load i64, i64* %tmp23, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 7
  store i64 %41, i64* %smax_value29, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 7
  store i64 %41, i64* %smax_value30, align 8
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 5
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 5
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 5
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 5
  %48 = bitcast %struct.tnum* %var_off33 to { i64, i64 }*
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %48, i32 0, i32 0
  %50 = load i64, i64* %49, align 8
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %48, i32 0, i32 1
  %52 = load i64, i64* %51, align 8
  %53 = bitcast %struct.tnum* %var_off34 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call = call { i64, i64 } @tnum_intersect(i64 %50, i64 %52, i64 %55, i64 %57) #20
  %58 = bitcast %struct.tnum* %tmp32 to { i64, i64 }*
  %59 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %58, i32 0, i32 0
  %60 = extractvalue { i64, i64 } %call, 0
  store i64 %60, i64* %59, align 8
  %61 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %58, i32 0, i32 1
  %62 = extractvalue { i64, i64 } %call, 1
  store i64 %62, i64* %61, align 8
  %63 = bitcast %struct.tnum* %var_off31 to i8*
  %64 = bitcast %struct.tnum* %tmp32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %63, i8* align 8 %64, i64 16, i1 false)
  %65 = bitcast %struct.tnum* %var_off to i8*
  %66 = bitcast %struct.tnum* %var_off31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %65, i8* align 8 %66, i64 16, i1 false)
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @reg_bounds_sync(%struct.bpf_reg_state* noundef %67) #20
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @reg_bounds_sync(%struct.bpf_reg_state* noundef %68) #20
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @btf_id_set_contains(%struct.btf_id_set* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @ktime_to_ns(i64 noundef %kt) #0 {
entry:
  %kt.addr = alloca i64, align 8
  store i64 %kt, i64* %kt.addr, align 8
  %0 = load i64, i64* %kt.addr, align 8
  ret i64 %0
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @ktime_get() #1

; Function Attrs: noredzone null_pointer_is_valid allocsize(0)
declare dso_local noalias i8* @kmalloc_large(i64 noundef, i32 noundef) #7

; Function Attrs: noredzone null_pointer_is_valid allocsize(2)
declare dso_local noalias i8* @kmalloc_trace(%struct.kmem_cache* noundef, i32 noundef, i64 noundef) #16

; Function Attrs: noredzone null_pointer_is_valid allocsize(0)
declare dso_local noalias i8* @__kmalloc(i64 noundef, i32 noundef) #7

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { i8*, i8 } @KERNEL_BPFPTR(i8* noundef %p) #0 {
entry:
  %retval = alloca %struct.sockptr_t, align 8
  %p.addr = alloca i8*, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %retval, i32 0, i32 0
  %kernel = bitcast %union.anon.48* %0 to i8**
  %1 = load i8*, i8** %p.addr, align 8
  store i8* %1, i8** %kernel, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %retval, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %is_kernel, align 8
  %2 = bitcast %struct.sockptr_t* %retval to { i8*, i8 }*
  %3 = load { i8*, i8 }, { i8*, i8 }* %2, align 8
  ret { i8*, i8 } %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { i8*, i8 } @USER_BPFPTR(i8* noundef %p) #0 {
entry:
  %retval = alloca %struct.sockptr_t, align 8
  %p.addr = alloca i8*, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %retval, i32 0, i32 0
  %user = bitcast %union.anon.48* %0 to i8**
  %1 = load i8*, i8** %p.addr, align 8
  store i8* %1, i8** %user, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %retval, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, -2
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, i8* %is_kernel, align 8
  %2 = bitcast %struct.sockptr_t* %retval to { i8*, i8 }*
  %3 = load { i8*, i8 }, { i8*, i8 }* %2, align 8
  ret { i8*, i8 } %3
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @capable(i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @perfmon_capable() #0 {
entry:
  %call = call zeroext i1 @capable(i32 noundef 38) #20
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %call1 = call zeroext i1 @capable(i32 noundef 21) #20
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %call1, %lor.rhs ]
  ret i1 %0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong allocsize(0,1)
define internal noalias i8* @kvmalloc_array(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #8 {
entry:
  %retval = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  %1 = load i64, i64* %size.addr, align 8
  %2 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %0, i64 %1)
  %3 = extractvalue { i64, i1 } %2, 1
  %4 = extractvalue { i64, i1 } %2, 0
  store i64 %4, i64* %bytes, align 8
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %3) #20
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %bytes, align 8
  %6 = load i32, i32* %flags.addr, align 4
  %call2 = call noalias i8* @kvmalloc(i64 noundef %5, i32 noundef %6) #24
  store i8* %call2, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i8*, i8** %retval, align 8
  ret i8* %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong allocsize(0)
define internal noalias i8* @kvmalloc(i64 noundef %size, i32 noundef %flags) #6 {
entry:
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %size.addr, align 8
  %1 = load i32, i32* %flags.addr, align 4
  %call = call noalias i8* @kvmalloc_node(i64 noundef %0, i32 noundef %1, i32 noundef -1) #24
  ret i8* %call
}

; Function Attrs: noredzone null_pointer_is_valid allocsize(0)
declare dso_local noalias i8* @kvmalloc_node(i64 noundef, i32 noundef, i32 noundef) #7

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @add_subprog(%struct.bpf_verifier_env* noundef %env, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %insn_cnt = alloca i32, align 4
  %ret = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 4
  %2 = load i32, i32* %len, align 4
  store i32 %2, i32* %insn_cnt, align 4
  %3 = load i32, i32* %off.addr, align 4
  %4 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp sge i32 %3, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp slt i32 %5, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.220, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load i32, i32* %off.addr, align 4
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %8, i32 noundef %9) #20
  store i32 %call, i32* %ret, align 4
  %10 = load i32, i32* %ret, align 4
  %cmp2 = icmp sge i32 %10, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %11 = load i32, i32* %ret, align 4
  store i32 %11, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 31
  %13 = load i32, i32* %subprog_cnt, align 4
  %cmp5 = icmp uge i32 %13, 256
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.221, i64 0, i64 0)) #20
  store i32 -7, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end4
  %16 = load i32, i32* %off.addr, align 4
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 27
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt8 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 31
  %19 = load i32, i32* %subprog_cnt8, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %subprog_cnt8, align 4
  %idxprom = zext i32 %19 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  store i32 %16, i32* %start, align 8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info9 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info9, i64 0, i64 0
  %21 = bitcast %struct.bpf_subprog_info* %arraydecay to i8*
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 31
  %23 = load i32, i32* %subprog_cnt10, align 4
  %conv = zext i32 %23 to i64
  call void @sort(i8* noundef %21, i64 noundef %conv, i64 noundef 16, i32 (i8*, i8*)* noundef @cmp_subprogs, void (i8*, i8*, i32)* noundef null) #20
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 31
  %25 = load i32, i32* %subprog_cnt11, align 4
  %sub = sub i32 %25, 1
  store i32 %sub, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then3, %if.then
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 24
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv2 = zext i8 %bf.lshr to i32
  %cmp3 = icmp eq i32 %conv2, 4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp3, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 133
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv2 = zext i8 %bf.lshr to i32
  %cmp3 = icmp eq i32 %conv2, 1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp3, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_pseudo_kfunc_call(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 133
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv2 = zext i8 %bf.lshr to i32
  %cmp3 = icmp eq i32 %conv2, 2
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp3, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @add_kfunc_call(%struct.bpf_verifier_env* noundef %env, i32 noundef %func_id, i16 noundef signext %offset) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %func_id.addr = alloca i32, align 4
  %offset.addr = alloca i16, align 2
  %func = alloca %struct.btf_type*, align 8
  %func_proto = alloca %struct.btf_type*, align 8
  %btf_tab = alloca %struct.bpf_kfunc_btf_tab*, align 8
  %tab = alloca %struct.bpf_kfunc_desc_tab*, align 8
  %prog_aux = alloca %struct.bpf_prog_aux*, align 8
  %desc = alloca %struct.bpf_kfunc_desc*, align 8
  %func_name = alloca i8*, align 8
  %desc_btf = alloca %struct.btf*, align 8
  %call_imm = alloca i64, align 8
  %addr = alloca i64, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i16 %offset, i16* %offset.addr, align 2
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  store %struct.bpf_prog_aux* %2, %struct.bpf_prog_aux** %prog_aux, align 8
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %prog_aux, align 8
  %kfunc_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 33
  %4 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %kfunc_tab, align 8
  store %struct.bpf_kfunc_desc_tab* %4, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %5 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %prog_aux, align 8
  %kfunc_btf_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %5, i32 0, i32 34
  %6 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %kfunc_btf_tab, align 8
  store %struct.bpf_kfunc_btf_tab* %6, %struct.bpf_kfunc_btf_tab** %btf_tab, align 8
  %7 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %tobool = icmp ne %struct.bpf_kfunc_desc_tab* %7, null
  br i1 %tobool, label %if.end21, label %if.then

if.then:                                          ; preds = %entry
  %8 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool1 = icmp ne %struct.btf* %8, null
  br i1 %tobool1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([72 x i8], [72 x i8]* @.str.222, i64 0, i64 0)) #20
  store i32 -524, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 2
  %12 = load %struct.bpf_prog*, %struct.bpf_prog** %prog3, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %12, i32 0, i32 1
  %bf.load = load i16, i16* %jit_requested, align 2
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %tobool4 = icmp ne i16 %bf.clear, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.223, i64 0, i64 0)) #20
  store i32 -524, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %call = call zeroext i1 @bpf_jit_supports_kfunc_call() #20
  br i1 %call, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end6
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = bitcast %struct.bpf_verifier_env* %15 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %16, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.224, i64 0, i64 0)) #20
  store i32 -524, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end6
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog9 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 2
  %18 = load %struct.bpf_prog*, %struct.bpf_prog** %prog9, align 8
  %gpl_compatible = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %18, i32 0, i32 1
  %bf.load10 = load i16, i16* %gpl_compatible, align 2
  %bf.lshr11 = lshr i16 %bf.load10, 2
  %bf.clear12 = and i16 %bf.lshr11, 1
  %tobool13 = icmp ne i16 %bf.clear12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([61 x i8], [61 x i8]* @.str.225, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end8
  %call16 = call noalias i8* @kzalloc(i64 noundef 10244, i32 noundef 3264) #24
  %21 = bitcast i8* %call16 to %struct.bpf_kfunc_desc_tab*
  store %struct.bpf_kfunc_desc_tab* %21, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %22 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %tobool17 = icmp ne %struct.bpf_kfunc_desc_tab* %22, null
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end15
  store i32 -12, i32* %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end15
  %23 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %24 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %prog_aux, align 8
  %kfunc_tab20 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %24, i32 0, i32 33
  store %struct.bpf_kfunc_desc_tab* %23, %struct.bpf_kfunc_desc_tab** %kfunc_tab20, align 8
  br label %if.end21

if.end21:                                         ; preds = %if.end19, %entry
  %25 = load i32, i32* %func_id.addr, align 4
  %tobool22 = icmp ne i32 %25, 0
  br i1 %tobool22, label %if.end25, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end21
  %26 = load i16, i16* %offset.addr, align 2
  %tobool23 = icmp ne i16 %26, 0
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %land.lhs.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end25:                                         ; preds = %land.lhs.true, %if.end21
  %27 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %btf_tab, align 8
  %tobool26 = icmp ne %struct.bpf_kfunc_btf_tab* %27, null
  br i1 %tobool26, label %if.end35, label %land.lhs.true27

land.lhs.true27:                                  ; preds = %if.end25
  %28 = load i16, i16* %offset.addr, align 2
  %conv = sext i16 %28 to i32
  %tobool28 = icmp ne i32 %conv, 0
  br i1 %tobool28, label %if.then29, label %if.end35

if.then29:                                        ; preds = %land.lhs.true27
  %call30 = call noalias i8* @kzalloc(i64 noundef 6152, i32 noundef 3264) #24
  %29 = bitcast i8* %call30 to %struct.bpf_kfunc_btf_tab*
  store %struct.bpf_kfunc_btf_tab* %29, %struct.bpf_kfunc_btf_tab** %btf_tab, align 8
  %30 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %btf_tab, align 8
  %tobool31 = icmp ne %struct.bpf_kfunc_btf_tab* %30, null
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %if.then29
  store i32 -12, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.then29
  %31 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %btf_tab, align 8
  %32 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %prog_aux, align 8
  %kfunc_btf_tab34 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %32, i32 0, i32 34
  store %struct.bpf_kfunc_btf_tab* %31, %struct.bpf_kfunc_btf_tab** %kfunc_btf_tab34, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.end33, %land.lhs.true27, %if.end25
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load i16, i16* %offset.addr, align 2
  %call36 = call %struct.btf* @find_kfunc_desc_btf(%struct.bpf_verifier_env* noundef %33, i16 noundef signext %34) #20
  store %struct.btf* %call36, %struct.btf** %desc_btf, align 8
  %35 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %36 = bitcast %struct.btf* %35 to i8*
  %call37 = call zeroext i1 @IS_ERR(i8* noundef %36) #20
  br i1 %call37, label %if.then38, label %if.end41

if.then38:                                        ; preds = %if.end35
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = bitcast %struct.bpf_verifier_env* %37 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %38, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.226, i64 0, i64 0)) #20
  %39 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %40 = bitcast %struct.btf* %39 to i8*
  %call39 = call i64 @PTR_ERR(i8* noundef %40) #20
  %conv40 = trunc i64 %call39 to i32
  store i32 %conv40, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end35
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog42 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %41, i32 0, i32 2
  %42 = load %struct.bpf_prog*, %struct.bpf_prog** %prog42, align 8
  %43 = load i32, i32* %func_id.addr, align 4
  %44 = load i16, i16* %offset.addr, align 2
  %call43 = call %struct.bpf_kfunc_desc* @find_kfunc_desc(%struct.bpf_prog* noundef %42, i32 noundef %43, i16 noundef zeroext %44) #20
  %tobool44 = icmp ne %struct.bpf_kfunc_desc* %call43, null
  br i1 %tobool44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.end41
  store i32 0, i32* %retval, align 4
  br label %return

if.end46:                                         ; preds = %if.end41
  %45 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %nr_descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %45, i32 0, i32 1
  %46 = load i32, i32* %nr_descs, align 4
  %cmp = icmp eq i32 %46, 256
  br i1 %cmp, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.end46
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = bitcast %struct.bpf_verifier_env* %47 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %48, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.227, i64 0, i64 0)) #20
  store i32 -7, i32* %retval, align 4
  br label %return

if.end49:                                         ; preds = %if.end46
  %49 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %50 = load i32, i32* %func_id.addr, align 4
  %call50 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %49, i32 noundef %50) #20
  store %struct.btf_type* %call50, %struct.btf_type** %func, align 8
  %51 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %tobool51 = icmp ne %struct.btf_type* %51, null
  br i1 %tobool51, label %lor.lhs.false, label %if.then53

lor.lhs.false:                                    ; preds = %if.end49
  %52 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %call52 = call zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %52) #20
  br i1 %call52, label %if.end54, label %if.then53

if.then53:                                        ; preds = %lor.lhs.false, %if.end49
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = bitcast %struct.bpf_verifier_env* %53 to i8*
  %55 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %54, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.228, i64 0, i64 0), i32 noundef %55) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %lor.lhs.false
  %56 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %57 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %58 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %57, i32 0, i32 2
  %type = bitcast %union.anon.137* %58 to i32*
  %59 = load i32, i32* %type, align 4
  %call55 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %56, i32 noundef %59) #20
  store %struct.btf_type* %call55, %struct.btf_type** %func_proto, align 8
  %60 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %tobool56 = icmp ne %struct.btf_type* %60, null
  br i1 %tobool56, label %lor.lhs.false57, label %if.then59

lor.lhs.false57:                                  ; preds = %if.end54
  %61 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %call58 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %61) #20
  br i1 %call58, label %if.end60, label %if.then59

if.then59:                                        ; preds = %lor.lhs.false57, %if.end54
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %63 = bitcast %struct.bpf_verifier_env* %62 to i8*
  %64 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %63, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.229, i64 0, i64 0), i32 noundef %64) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end60:                                         ; preds = %lor.lhs.false57
  %65 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %66 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %66, i32 0, i32 0
  %67 = load i32, i32* %name_off, align 4
  %call61 = call i8* @btf_name_by_offset(%struct.btf* noundef %65, i32 noundef %67) #20
  store i8* %call61, i8** %func_name, align 8
  %68 = load i8*, i8** %func_name, align 8
  %call62 = call i64 @kallsyms_lookup_name(i8* noundef %68) #20
  store i64 %call62, i64* %addr, align 8
  %69 = load i64, i64* %addr, align 8
  %tobool63 = icmp ne i64 %69, 0
  br i1 %tobool63, label %if.end65, label %if.then64

if.then64:                                        ; preds = %if.end60
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = bitcast %struct.bpf_verifier_env* %70 to i8*
  %72 = load i8*, i8** %func_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %71, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.230, i64 0, i64 0), i8* noundef %72) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end65:                                         ; preds = %if.end60
  %73 = load i64, i64* %addr, align 8
  %74 = inttoptr i64 %73 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %74 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  store i64 %sub.ptr.sub, i64* %call_imm, align 8
  %75 = load i64, i64* %call_imm, align 8
  %conv66 = trunc i64 %75 to i32
  %conv67 = sext i32 %conv66 to i64
  %76 = load i64, i64* %call_imm, align 8
  %cmp68 = icmp ne i64 %conv67, %76
  br i1 %cmp68, label %if.then70, label %if.end71

if.then70:                                        ; preds = %if.end65
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %78 = bitcast %struct.bpf_verifier_env* %77 to i8*
  %79 = load i8*, i8** %func_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %78, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.231, i64 0, i64 0), i8* noundef %79) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end71:                                         ; preds = %if.end65
  %80 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %80, i32 0, i32 0
  %81 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %nr_descs72 = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %81, i32 0, i32 1
  %82 = load i32, i32* %nr_descs72, align 4
  %inc = add i32 %82, 1
  store i32 %inc, i32* %nr_descs72, align 4
  %idxprom = zext i32 %82 to i64
  %arrayidx = getelementptr [256 x %struct.bpf_kfunc_desc], [256 x %struct.bpf_kfunc_desc]* %descs, i64 0, i64 %idxprom
  store %struct.bpf_kfunc_desc* %arrayidx, %struct.bpf_kfunc_desc** %desc, align 8
  %83 = load i32, i32* %func_id.addr, align 4
  %84 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %desc, align 8
  %func_id73 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %84, i32 0, i32 1
  store i32 %83, i32* %func_id73, align 4
  %85 = load i64, i64* %call_imm, align 8
  %conv74 = trunc i64 %85 to i32
  %86 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %desc, align 8
  %imm = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %86, i32 0, i32 2
  store i32 %conv74, i32* %imm, align 4
  %87 = load i16, i16* %offset.addr, align 2
  %88 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %desc, align 8
  %offset75 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %88, i32 0, i32 3
  store i16 %87, i16* %offset75, align 4
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %89, i32 0, i32 26
  %90 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %91 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %92 = load i8*, i8** %func_name, align 8
  %93 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %desc, align 8
  %func_model = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %93, i32 0, i32 0
  %call76 = call i32 @btf_distill_func_proto(%struct.bpf_verifier_log* noundef %log, %struct.btf* noundef %90, %struct.btf_type* noundef %91, i8* noundef %92, %struct.btf_func_model* noundef %func_model) #20
  store i32 %call76, i32* %err, align 4
  %94 = load i32, i32* %err, align 4
  %tobool77 = icmp ne i32 %94, 0
  br i1 %tobool77, label %if.end82, label %if.then78

if.then78:                                        ; preds = %if.end71
  %95 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %descs79 = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %95, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x %struct.bpf_kfunc_desc], [256 x %struct.bpf_kfunc_desc]* %descs79, i64 0, i64 0
  %96 = bitcast %struct.bpf_kfunc_desc* %arraydecay to i8*
  %97 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %nr_descs80 = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %97, i32 0, i32 1
  %98 = load i32, i32* %nr_descs80, align 4
  %conv81 = zext i32 %98 to i64
  call void @sort(i8* noundef %96, i64 noundef %conv81, i64 noundef 40, i32 (i8*, i8*)* noundef @kfunc_desc_cmp_by_id_off, void (i8*, i8*, i32)* noundef null) #20
  br label %if.end82

if.end82:                                         ; preds = %if.then78, %if.end71
  %99 = load i32, i32* %err, align 4
  store i32 %99, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end82, %if.then70, %if.then64, %if.then59, %if.then53, %if.then48, %if.then45, %if.then38, %if.then32, %if.then24, %if.then18, %if.then14, %if.then7, %if.then5, %if.then2
  %100 = load i32, i32* %retval, align 4
  ret i32 %100
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @find_subprog(%struct.bpf_verifier_env* noundef %env, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %p = alloca %struct.bpf_subprog_info*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = bitcast i32* %off.addr to i8*
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  %2 = bitcast %struct.bpf_subprog_info* %arraydecay to i8*
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 31
  %4 = load i32, i32* %subprog_cnt, align 4
  %conv = zext i32 %4 to i64
  %call = call i8* @bsearch(i8* noundef %0, i8* noundef %2, i64 noundef %conv, i64 noundef 16, i32 (i8*, i8*)* noundef @cmp_subprogs) #20
  %5 = bitcast i8* %call to %struct.bpf_subprog_info*
  store %struct.bpf_subprog_info* %5, %struct.bpf_subprog_info** %p, align 8
  %6 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %p, align 8
  %tobool = icmp ne %struct.bpf_subprog_info* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -2, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %p, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 27
  %arraydecay2 = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info1, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint %struct.bpf_subprog_info* %7 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.bpf_subprog_info* %arraydecay2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %conv3 = trunc i64 %sub.ptr.div to i32
  store i32 %conv3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @cmp_subprogs(i8* noundef %a, i8* noundef %b) #0 {
entry:
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  store i8* %a, i8** %a.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  %0 = load i8*, i8** %a.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_subprog_info*
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %1, i32 0, i32 0
  %2 = load i32, i32* %start, align 4
  %3 = load i8*, i8** %b.addr, align 8
  %4 = bitcast i8* %3 to %struct.bpf_subprog_info*
  %start1 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %4, i32 0, i32 0
  %5 = load i32, i32* %start1, align 4
  %sub = sub i32 %2, %5
  ret i32 %sub
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_jit_supports_kfunc_call() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_kfunc_desc* @find_kfunc_desc(%struct.bpf_prog* noundef %prog, i32 noundef %func_id, i16 noundef zeroext %offset) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %func_id.addr = alloca i32, align 4
  %offset.addr = alloca i16, align 2
  %desc = alloca %struct.bpf_kfunc_desc, align 4
  %tab = alloca %struct.bpf_kfunc_desc_tab*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i16 %offset, i16* %offset.addr, align 2
  %0 = bitcast %struct.bpf_kfunc_desc* %desc to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %0, i8 0, i64 40, i1 false)
  %func_id1 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %desc, i32 0, i32 1
  %1 = load i32, i32* %func_id.addr, align 4
  store i32 %1, i32* %func_id1, align 4
  %offset2 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %desc, i32 0, i32 3
  %2 = load i16, i16* %offset.addr, align 2
  store i16 %2, i16* %offset2, align 4
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 10
  %4 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %kfunc_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %4, i32 0, i32 33
  %5 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %kfunc_tab, align 8
  store %struct.bpf_kfunc_desc_tab* %5, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %6 = bitcast %struct.bpf_kfunc_desc* %desc to i8*
  %7 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %7, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x %struct.bpf_kfunc_desc], [256 x %struct.bpf_kfunc_desc]* %descs, i64 0, i64 0
  %8 = bitcast %struct.bpf_kfunc_desc* %arraydecay to i8*
  %9 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %nr_descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %9, i32 0, i32 1
  %10 = load i32, i32* %nr_descs, align 4
  %conv = zext i32 %10 to i64
  %call = call i8* @bsearch(i8* noundef %6, i8* noundef %8, i64 noundef %conv, i64 noundef 40, i32 (i8*, i8*)* noundef @kfunc_desc_cmp_by_id_off) #20
  %11 = bitcast i8* %call to %struct.bpf_kfunc_desc*
  ret %struct.bpf_kfunc_desc* %11
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @__bpf_call_base(i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @kfunc_desc_cmp_by_id_off(i8* noundef %a, i8* noundef %b) #0 {
entry:
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  %d0 = alloca %struct.bpf_kfunc_desc*, align 8
  %d1 = alloca %struct.bpf_kfunc_desc*, align 8
  store i8* %a, i8** %a.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  %0 = load i8*, i8** %a.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_kfunc_desc*
  store %struct.bpf_kfunc_desc* %1, %struct.bpf_kfunc_desc** %d0, align 8
  %2 = load i8*, i8** %b.addr, align 8
  %3 = bitcast i8* %2 to %struct.bpf_kfunc_desc*
  store %struct.bpf_kfunc_desc* %3, %struct.bpf_kfunc_desc** %d1, align 8
  %4 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d0, align 8
  %func_id = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %4, i32 0, i32 1
  %5 = load i32, i32* %func_id, align 4
  %6 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d1, align 8
  %func_id1 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %6, i32 0, i32 1
  %7 = load i32, i32* %func_id1, align 4
  %sub = sub i32 %5, %7
  %tobool = icmp ne i32 %sub, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %8 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d0, align 8
  %offset = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %8, i32 0, i32 3
  %9 = load i16, i16* %offset, align 4
  %conv = zext i16 %9 to i32
  %10 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %d1, align 8
  %offset2 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %10, i32 0, i32 3
  %11 = load i16, i16* %offset2, align 4
  %conv3 = zext i16 %11 to i32
  %sub4 = sub i32 %conv, %conv3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ %sub4, %cond.false ]
  ret i32 %cond
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_abnormal_return(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 31
  %2 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 27
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %has_ld_abs = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 5
  %5 = load i8, i8* %has_ld_abs, align 4
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.234, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 27
  %9 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %9 to i64
  %arrayidx3 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info1, i64 0, i64 %idxprom2
  %has_tail_call = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx3, i32 0, i32 3
  %10 = load i8, i8* %has_tail_call, align 2
  %tobool4 = trunc i8 %10 to i1
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.235, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %13 = load i32, i32* %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !81

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then5, %if.then
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_btf_func(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, i8* %uattr.coerce0, i8 %uattr.coerce1) #0 {
entry:
  %retval = alloca i32, align 4
  %uattr = alloca %struct.sockptr_t, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %type = alloca %struct.btf_type*, align 8
  %func_proto = alloca %struct.btf_type*, align 8
  %ret_type = alloca %struct.btf_type*, align 8
  %i = alloca i32, align 4
  %nfuncs = alloca i32, align 4
  %urec_size = alloca i32, align 4
  %min_size = alloca i32, align 4
  %krec_size = alloca i32, align 4
  %krecord = alloca %struct.bpf_func_info*, align 8
  %info_aux = alloca %struct.bpf_func_info_aux*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %btf = alloca %struct.btf*, align 8
  %urecord = alloca %struct.sockptr_t, align 8
  %prev_offset = alloca i32, align 4
  %scalar_return = alloca i8, align 1
  %ret = alloca i32, align 4
  %tmp = alloca %struct.sockptr_t, align 8
  %__UNIQUE_ID___x616 = alloca i32, align 4
  %__UNIQUE_ID___y617 = alloca i32, align 4
  %tmp15 = alloca i32, align 4
  %0 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %uattr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %uattr.coerce1, i8* %2, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  store i32 8, i32* %krec_size, align 4
  store %struct.bpf_func_info_aux* null, %struct.bpf_func_info_aux** %info_aux, align 8
  store i32 0, i32* %prev_offset, align 4
  store i32 -12, i32* %ret, align 4
  %3 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %4 = bitcast %union.bpf_attr* %3 to %struct.anon.144*
  %func_info_cnt = getelementptr inbounds %struct.anon.144, %struct.anon.144* %4, i32 0, i32 15
  %5 = load i32, i32* %func_info_cnt, align 8
  store i32 %5, i32* %nfuncs, align 4
  %6 = load i32, i32* %nfuncs, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.end3, label %if.then

if.then:                                          ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @check_abnormal_return(%struct.bpf_verifier_env* noundef %7) #20
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %entry
  %8 = load i32, i32* %nfuncs, align 4
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 31
  %10 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ne i32 %8, %10
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end3
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.236, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end3
  %13 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %14 = bitcast %union.bpf_attr* %13 to %struct.anon.144*
  %func_info_rec_size = getelementptr inbounds %struct.anon.144, %struct.anon.144* %14, i32 0, i32 13
  %15 = load i32, i32* %func_info_rec_size, align 4
  store i32 %15, i32* %urec_size, align 4
  %16 = load i32, i32* %urec_size, align 4
  %cmp6 = icmp ult i32 %16, 8
  br i1 %cmp6, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %17 = load i32, i32* %urec_size, align 4
  %cmp7 = icmp ugt i32 %17, 252
  br i1 %cmp7, label %if.then10, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false
  %18 = load i32, i32* %urec_size, align 4
  %conv = zext i32 %18 to i64
  %rem = urem i64 %conv, 4
  %tobool9 = icmp ne i64 %rem, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %lor.lhs.false8, %lor.lhs.false, %if.end5
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  %21 = load i32, i32* %urec_size, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.237, i64 0, i64 0), i32 noundef %21) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %lor.lhs.false8
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 2
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %prog12, align 8
  store %struct.bpf_prog* %23, %struct.bpf_prog** %prog, align 8
  %24 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %24, i32 0, i32 10
  %25 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf13 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %25, i32 0, i32 50
  %26 = load %struct.btf*, %struct.btf** %btf13, align 8
  store %struct.btf* %26, %struct.btf** %btf, align 8
  %27 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %28 = bitcast %union.bpf_attr* %27 to %struct.anon.144*
  %func_info = getelementptr inbounds %struct.anon.144, %struct.anon.144* %28, i32 0, i32 14
  %29 = load i64, i64* %func_info, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %uattr, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  %call14 = call { i8*, i8 } @make_bpfptr(i64 noundef %29, i1 noundef zeroext %bf.cast) #20
  %30 = bitcast %struct.sockptr_t* %tmp to { i8*, i8 }*
  %31 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %30, i32 0, i32 0
  %32 = extractvalue { i8*, i8 } %call14, 0
  store i8* %32, i8** %31, align 8
  %33 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %30, i32 0, i32 1
  %34 = extractvalue { i8*, i8 } %call14, 1
  store i8 %34, i8* %33, align 8
  %35 = bitcast %struct.sockptr_t* %urecord to i8*
  %36 = bitcast %struct.sockptr_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %35, i8* align 8 %36, i64 16, i1 false)
  %37 = load i32, i32* %krec_size, align 4
  store i32 %37, i32* %__UNIQUE_ID___x616, align 4
  %38 = load i32, i32* %urec_size, align 4
  store i32 %38, i32* %__UNIQUE_ID___y617, align 4
  %39 = load i32, i32* %__UNIQUE_ID___x616, align 4
  %40 = load i32, i32* %__UNIQUE_ID___y617, align 4
  %cmp16 = icmp ult i32 %39, %40
  br i1 %cmp16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end11
  %41 = load i32, i32* %__UNIQUE_ID___x616, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end11
  %42 = load i32, i32* %__UNIQUE_ID___y617, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %41, %cond.true ], [ %42, %cond.false ]
  store i32 %cond, i32* %tmp15, align 4
  %43 = load i32, i32* %tmp15, align 4
  store i32 %43, i32* %min_size, align 4
  %44 = load i32, i32* %nfuncs, align 4
  %conv18 = zext i32 %44 to i64
  %45 = load i32, i32* %krec_size, align 4
  %conv19 = zext i32 %45 to i64
  %call20 = call noalias i8* @kvcalloc(i64 noundef %conv18, i64 noundef %conv19, i32 noundef 11456) #25
  %46 = bitcast i8* %call20 to %struct.bpf_func_info*
  store %struct.bpf_func_info* %46, %struct.bpf_func_info** %krecord, align 8
  %47 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %tobool21 = icmp ne %struct.bpf_func_info* %47, null
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %cond.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %cond.end
  %48 = load i32, i32* %nfuncs, align 4
  %conv24 = zext i32 %48 to i64
  %call25 = call noalias i8* @kcalloc(i64 noundef %conv24, i64 noundef 4, i32 noundef 11456) #25
  %49 = bitcast i8* %call25 to %struct.bpf_func_info_aux*
  store %struct.bpf_func_info_aux* %49, %struct.bpf_func_info_aux** %info_aux, align 8
  %50 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %info_aux, align 8
  %tobool26 = icmp ne %struct.bpf_func_info_aux* %50, null
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end23
  br label %err_free

if.end28:                                         ; preds = %if.end23
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end28
  %51 = load i32, i32* %i, align 4
  %52 = load i32, i32* %nfuncs, align 4
  %cmp29 = icmp ult i32 %51, %52
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %53 = load i32, i32* %krec_size, align 4
  %conv31 = zext i32 %53 to i64
  %54 = load i32, i32* %urec_size, align 4
  %conv32 = zext i32 %54 to i64
  %55 = bitcast %struct.sockptr_t* %urecord to { i8*, i8 }*
  %56 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %55, i32 0, i32 0
  %57 = load i8*, i8** %56, align 8
  %58 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %55, i32 0, i32 1
  %59 = load i8, i8* %58, align 8
  %call33 = call i32 @bpf_check_uarg_tail_zero(i8* %57, i8 %59, i64 noundef %conv31, i64 noundef %conv32) #20
  store i32 %call33, i32* %ret, align 4
  %60 = load i32, i32* %ret, align 4
  %tobool34 = icmp ne i32 %60, 0
  br i1 %tobool34, label %if.then35, label %if.end44

if.then35:                                        ; preds = %for.body
  %61 = load i32, i32* %ret, align 4
  %cmp36 = icmp eq i32 %61, -7
  br i1 %cmp36, label %if.then38, label %if.end43

if.then38:                                        ; preds = %if.then35
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %63 = bitcast %struct.bpf_verifier_env* %62 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %63, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.238, i64 0, i64 0)) #20
  %64 = bitcast i32* %min_size to i8*
  %65 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %66 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %65, i32 0, i32 0
  %67 = load i8*, i8** %66, align 8
  %68 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %65, i32 0, i32 1
  %69 = load i8, i8* %68, align 8
  %call39 = call i32 @copy_to_bpfptr_offset(i8* %67, i8 %69, i64 noundef 76, i8* noundef %64, i64 noundef 4) #20
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.then38
  store i32 -14, i32* %ret, align 4
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %if.then38
  br label %if.end43

if.end43:                                         ; preds = %if.end42, %if.then35
  br label %err_free

if.end44:                                         ; preds = %for.body
  %70 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %71 = load i32, i32* %i, align 4
  %idxprom = zext i32 %71 to i64
  %arrayidx = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %70, i64 %idxprom
  %72 = bitcast %struct.bpf_func_info* %arrayidx to i8*
  %73 = load i32, i32* %min_size, align 4
  %conv45 = zext i32 %73 to i64
  %74 = bitcast %struct.sockptr_t* %urecord to { i8*, i8 }*
  %75 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %74, i32 0, i32 0
  %76 = load i8*, i8** %75, align 8
  %77 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %74, i32 0, i32 1
  %78 = load i8, i8* %77, align 8
  %call46 = call i32 @copy_from_bpfptr(i8* noundef %72, i8* %76, i8 %78, i64 noundef %conv45) #20
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.end44
  store i32 -14, i32* %ret, align 4
  br label %err_free

if.end49:                                         ; preds = %if.end44
  store i32 -22, i32* %ret, align 4
  %79 = load i32, i32* %i, align 4
  %cmp50 = icmp eq i32 %79, 0
  br i1 %cmp50, label %if.then52, label %if.else

if.then52:                                        ; preds = %if.end49
  %80 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %81 = load i32, i32* %i, align 4
  %idxprom53 = zext i32 %81 to i64
  %arrayidx54 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %80, i64 %idxprom53
  %insn_off = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx54, i32 0, i32 0
  %82 = load i32, i32* %insn_off, align 4
  %tobool55 = icmp ne i32 %82, 0
  br i1 %tobool55, label %if.then56, label %if.end60

if.then56:                                        ; preds = %if.then52
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %84 = bitcast %struct.bpf_verifier_env* %83 to i8*
  %85 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %86 = load i32, i32* %i, align 4
  %idxprom57 = zext i32 %86 to i64
  %arrayidx58 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %85, i64 %idxprom57
  %insn_off59 = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx58, i32 0, i32 0
  %87 = load i32, i32* %insn_off59, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %84, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.239, i64 0, i64 0), i32 noundef %87) #20
  br label %err_free

if.end60:                                         ; preds = %if.then52
  br label %if.end71

if.else:                                          ; preds = %if.end49
  %88 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %89 = load i32, i32* %i, align 4
  %idxprom61 = zext i32 %89 to i64
  %arrayidx62 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %88, i64 %idxprom61
  %insn_off63 = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx62, i32 0, i32 0
  %90 = load i32, i32* %insn_off63, align 4
  %91 = load i32, i32* %prev_offset, align 4
  %cmp64 = icmp ule i32 %90, %91
  br i1 %cmp64, label %if.then66, label %if.end70

if.then66:                                        ; preds = %if.else
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %93 = bitcast %struct.bpf_verifier_env* %92 to i8*
  %94 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %95 = load i32, i32* %i, align 4
  %idxprom67 = zext i32 %95 to i64
  %arrayidx68 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %94, i64 %idxprom67
  %insn_off69 = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx68, i32 0, i32 0
  %96 = load i32, i32* %insn_off69, align 4
  %97 = load i32, i32* %prev_offset, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %93, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.240, i64 0, i64 0), i32 noundef %96, i32 noundef %97) #20
  br label %err_free

if.end70:                                         ; preds = %if.else
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.end60
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %98, i32 0, i32 27
  %99 = load i32, i32* %i, align 4
  %idxprom72 = zext i32 %99 to i64
  %arrayidx73 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom72
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx73, i32 0, i32 0
  %100 = load i32, i32* %start, align 8
  %101 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %102 = load i32, i32* %i, align 4
  %idxprom74 = zext i32 %102 to i64
  %arrayidx75 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %101, i64 %idxprom74
  %insn_off76 = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx75, i32 0, i32 0
  %103 = load i32, i32* %insn_off76, align 4
  %cmp77 = icmp ne i32 %100, %103
  br i1 %cmp77, label %if.then79, label %if.end80

if.then79:                                        ; preds = %if.end71
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %105 = bitcast %struct.bpf_verifier_env* %104 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %105, i8* noundef getelementptr inbounds ([67 x i8], [67 x i8]* @.str.241, i64 0, i64 0)) #20
  br label %err_free

if.end80:                                         ; preds = %if.end71
  %106 = load %struct.btf*, %struct.btf** %btf, align 8
  %107 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %108 = load i32, i32* %i, align 4
  %idxprom81 = zext i32 %108 to i64
  %arrayidx82 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %107, i64 %idxprom81
  %type_id = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx82, i32 0, i32 1
  %109 = load i32, i32* %type_id, align 4
  %call83 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %106, i32 noundef %109) #20
  store %struct.btf_type* %call83, %struct.btf_type** %type, align 8
  %110 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %tobool84 = icmp ne %struct.btf_type* %110, null
  br i1 %tobool84, label %lor.lhs.false85, label %if.then87

lor.lhs.false85:                                  ; preds = %if.end80
  %111 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %call86 = call zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %111) #20
  br i1 %call86, label %if.end91, label %if.then87

if.then87:                                        ; preds = %lor.lhs.false85, %if.end80
  %112 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %113 = bitcast %struct.bpf_verifier_env* %112 to i8*
  %114 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %115 = load i32, i32* %i, align 4
  %idxprom88 = zext i32 %115 to i64
  %arrayidx89 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %114, i64 %idxprom88
  %type_id90 = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx89, i32 0, i32 1
  %116 = load i32, i32* %type_id90, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %113, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.242, i64 0, i64 0), i32 noundef %116) #20
  br label %err_free

if.end91:                                         ; preds = %lor.lhs.false85
  %117 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %117, i32 0, i32 1
  %118 = load i32, i32* %info, align 4
  %and = and i32 %118, 65535
  %conv92 = trunc i32 %and to i16
  %119 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %info_aux, align 8
  %120 = load i32, i32* %i, align 4
  %idxprom93 = zext i32 %120 to i64
  %arrayidx94 = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %119, i64 %idxprom93
  %linkage = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx94, i32 0, i32 0
  store i16 %conv92, i16* %linkage, align 2
  %121 = load %struct.btf*, %struct.btf** %btf, align 8
  %122 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %123 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %122, i32 0, i32 2
  %type95 = bitcast %union.anon.137* %123 to i32*
  %124 = load i32, i32* %type95, align 4
  %call96 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %121, i32 noundef %124) #20
  store %struct.btf_type* %call96, %struct.btf_type** %func_proto, align 8
  %125 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %tobool97 = icmp ne %struct.btf_type* %125, null
  br i1 %tobool97, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.end91
  %126 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %call98 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %126) #20
  %lnot = xor i1 %call98, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end91
  %127 = phi i1 [ true, %if.end91 ], [ %lnot, %lor.rhs ]
  %lnot99 = xor i1 %127, true
  %lnot100 = xor i1 %lnot99, true
  %lnot.ext = zext i1 %lnot100 to i32
  %conv101 = sext i32 %lnot.ext to i64
  %tobool102 = icmp ne i64 %conv101, 0
  br i1 %tobool102, label %if.then103, label %if.end104

if.then103:                                       ; preds = %lor.end
  br label %err_free

if.end104:                                        ; preds = %lor.end
  %128 = load %struct.btf*, %struct.btf** %btf, align 8
  %129 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %130 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %129, i32 0, i32 2
  %type105 = bitcast %union.anon.137* %130 to i32*
  %131 = load i32, i32* %type105, align 4
  %call106 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %128, i32 noundef %131, i32* noundef null) #20
  store %struct.btf_type* %call106, %struct.btf_type** %ret_type, align 8
  %132 = load %struct.btf_type*, %struct.btf_type** %ret_type, align 8
  %call107 = call zeroext i1 @btf_type_is_small_int(%struct.btf_type* noundef %132) #20
  br i1 %call107, label %lor.end112, label %lor.rhs109

lor.rhs109:                                       ; preds = %if.end104
  %133 = load %struct.btf_type*, %struct.btf_type** %ret_type, align 8
  %call110 = call zeroext i1 @btf_is_any_enum(%struct.btf_type* noundef %133) #20
  br label %lor.end112

lor.end112:                                       ; preds = %lor.rhs109, %if.end104
  %134 = phi i1 [ true, %if.end104 ], [ %call110, %lor.rhs109 ]
  %frombool = zext i1 %134 to i8
  store i8 %frombool, i8* %scalar_return, align 1
  %135 = load i32, i32* %i, align 4
  %tobool113 = icmp ne i32 %135, 0
  br i1 %tobool113, label %land.lhs.true, label %if.end122

land.lhs.true:                                    ; preds = %lor.end112
  %136 = load i8, i8* %scalar_return, align 1
  %tobool114 = trunc i8 %136 to i1
  br i1 %tobool114, label %if.end122, label %land.lhs.true115

land.lhs.true115:                                 ; preds = %land.lhs.true
  %137 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info116 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %137, i32 0, i32 27
  %138 = load i32, i32* %i, align 4
  %idxprom117 = zext i32 %138 to i64
  %arrayidx118 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info116, i64 0, i64 %idxprom117
  %has_ld_abs = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx118, i32 0, i32 5
  %139 = load i8, i8* %has_ld_abs, align 4
  %tobool119 = trunc i8 %139 to i1
  br i1 %tobool119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %land.lhs.true115
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %141 = bitcast %struct.bpf_verifier_env* %140 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %141, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.243, i64 0, i64 0)) #20
  br label %err_free

if.end122:                                        ; preds = %land.lhs.true115, %land.lhs.true, %lor.end112
  %142 = load i32, i32* %i, align 4
  %tobool123 = icmp ne i32 %142, 0
  br i1 %tobool123, label %land.lhs.true124, label %if.end133

land.lhs.true124:                                 ; preds = %if.end122
  %143 = load i8, i8* %scalar_return, align 1
  %tobool125 = trunc i8 %143 to i1
  br i1 %tobool125, label %if.end133, label %land.lhs.true126

land.lhs.true126:                                 ; preds = %land.lhs.true124
  %144 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info127 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %144, i32 0, i32 27
  %145 = load i32, i32* %i, align 4
  %idxprom128 = zext i32 %145 to i64
  %arrayidx129 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info127, i64 0, i64 %idxprom128
  %has_tail_call = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx129, i32 0, i32 3
  %146 = load i8, i8* %has_tail_call, align 2
  %tobool130 = trunc i8 %146 to i1
  br i1 %tobool130, label %if.then132, label %if.end133

if.then132:                                       ; preds = %land.lhs.true126
  %147 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %148 = bitcast %struct.bpf_verifier_env* %147 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %148, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.244, i64 0, i64 0)) #20
  br label %err_free

if.end133:                                        ; preds = %land.lhs.true126, %land.lhs.true124, %if.end122
  %149 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %150 = load i32, i32* %i, align 4
  %idxprom134 = zext i32 %150 to i64
  %arrayidx135 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %149, i64 %idxprom134
  %insn_off136 = getelementptr inbounds %struct.bpf_func_info, %struct.bpf_func_info* %arrayidx135, i32 0, i32 0
  %151 = load i32, i32* %insn_off136, align 4
  store i32 %151, i32* %prev_offset, align 4
  %152 = load i32, i32* %urec_size, align 4
  %conv137 = zext i32 %152 to i64
  call void @bpfptr_add(%struct.sockptr_t* noundef %urecord, i64 noundef %conv137) #20
  br label %for.inc

for.inc:                                          ; preds = %if.end133
  %153 = load i32, i32* %i, align 4
  %inc = add i32 %153, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !82

for.end:                                          ; preds = %for.cond
  %154 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %155 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux138 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %155, i32 0, i32 10
  %156 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux138, align 8
  %func_info139 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %156, i32 0, i32 51
  store %struct.bpf_func_info* %154, %struct.bpf_func_info** %func_info139, align 8
  %157 = load i32, i32* %nfuncs, align 4
  %158 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux140 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %158, i32 0, i32 10
  %159 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux140, align 8
  %func_info_cnt141 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %159, i32 0, i32 55
  store i32 %157, i32* %func_info_cnt141, align 8
  %160 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %info_aux, align 8
  %161 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux142 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %161, i32 0, i32 10
  %162 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux142, align 8
  %func_info_aux = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %162, i32 0, i32 52
  store %struct.bpf_func_info_aux* %160, %struct.bpf_func_info_aux** %func_info_aux, align 8
  store i32 0, i32* %retval, align 4
  br label %return

err_free:                                         ; preds = %if.then132, %if.then121, %if.then103, %if.then87, %if.then79, %if.then66, %if.then56, %if.then48, %if.end43, %if.then27
  %163 = load %struct.bpf_func_info*, %struct.bpf_func_info** %krecord, align 8
  %164 = bitcast %struct.bpf_func_info* %163 to i8*
  call void @kvfree(i8* noundef %164) #20
  %165 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %info_aux, align 8
  %166 = bitcast %struct.bpf_func_info_aux* %165 to i8*
  call void @kfree(i8* noundef %166) #20
  %167 = load i32, i32* %ret, align 4
  store i32 %167, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free, %for.end, %if.then22, %if.then10, %if.then4, %if.end, %if.then2
  %168 = load i32, i32* %retval, align 4
  ret i32 %168
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_btf_line(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, i8* %uattr.coerce0, i8 %uattr.coerce1) #0 {
entry:
  %retval = alloca i32, align 4
  %uattr = alloca %struct.sockptr_t, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %i = alloca i32, align 4
  %s = alloca i32, align 4
  %nr_linfo = alloca i32, align 4
  %ncopy = alloca i32, align 4
  %expected_size = alloca i32, align 4
  %rec_size = alloca i32, align 4
  %prev_offset = alloca i32, align 4
  %sub = alloca %struct.bpf_subprog_info*, align 8
  %linfo = alloca %struct.bpf_line_info*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %btf = alloca %struct.btf*, align 8
  %ulinfo = alloca %struct.sockptr_t, align 8
  %err = alloca i32, align 4
  %tmp = alloca %struct.sockptr_t, align 8
  %__UNIQUE_ID___x618 = alloca i32, align 4
  %__UNIQUE_ID___y619 = alloca i32, align 4
  %tmp21 = alloca i32, align 4
  %0 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %uattr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %uattr.coerce1, i8* %2, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  store i32 0, i32* %prev_offset, align 4
  %3 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %4 = bitcast %union.bpf_attr* %3 to %struct.anon.144*
  %line_info_cnt = getelementptr inbounds %struct.anon.144, %struct.anon.144* %4, i32 0, i32 18
  %5 = load i32, i32* %line_info_cnt, align 8
  store i32 %5, i32* %nr_linfo, align 4
  %6 = load i32, i32* %nr_linfo, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i32, i32* %nr_linfo, align 4
  %conv = zext i32 %7 to i64
  %cmp = icmp ugt i64 %conv, 134217727
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %8 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %9 = bitcast %union.bpf_attr* %8 to %struct.anon.144*
  %line_info_rec_size = getelementptr inbounds %struct.anon.144, %struct.anon.144* %9, i32 0, i32 16
  %10 = load i32, i32* %line_info_rec_size, align 4
  store i32 %10, i32* %rec_size, align 4
  %11 = load i32, i32* %rec_size, align 4
  %conv4 = zext i32 %11 to i64
  %cmp5 = icmp ult i64 %conv4, 16
  br i1 %cmp5, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end3
  %12 = load i32, i32* %rec_size, align 4
  %cmp7 = icmp ugt i32 %12, 252
  br i1 %cmp7, label %if.then12, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  %13 = load i32, i32* %rec_size, align 4
  %conv10 = zext i32 %13 to i64
  %and = and i64 %conv10, 3
  %tobool11 = icmp ne i64 %and, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %lor.lhs.false9, %lor.lhs.false, %if.end3
  store i32 -22, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %lor.lhs.false9
  %14 = load i32, i32* %nr_linfo, align 4
  %conv14 = zext i32 %14 to i64
  %call = call noalias i8* @kvcalloc(i64 noundef %conv14, i64 noundef 16, i32 noundef 11456) #25
  %15 = bitcast i8* %call to %struct.bpf_line_info*
  store %struct.bpf_line_info* %15, %struct.bpf_line_info** %linfo, align 8
  %16 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %tobool15 = icmp ne %struct.bpf_line_info* %16, null
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %if.end13
  store i32 -12, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end13
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog18 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 2
  %18 = load %struct.bpf_prog*, %struct.bpf_prog** %prog18, align 8
  store %struct.bpf_prog* %18, %struct.bpf_prog** %prog, align 8
  %19 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %19, i32 0, i32 10
  %20 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf19 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %20, i32 0, i32 50
  %21 = load %struct.btf*, %struct.btf** %btf19, align 8
  store %struct.btf* %21, %struct.btf** %btf, align 8
  store i32 0, i32* %s, align 4
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %sub, align 8
  %23 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %24 = bitcast %union.bpf_attr* %23 to %struct.anon.144*
  %line_info = getelementptr inbounds %struct.anon.144, %struct.anon.144* %24, i32 0, i32 17
  %25 = load i64, i64* %line_info, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %uattr, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  %call20 = call { i8*, i8 } @make_bpfptr(i64 noundef %25, i1 noundef zeroext %bf.cast) #20
  %26 = bitcast %struct.sockptr_t* %tmp to { i8*, i8 }*
  %27 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %26, i32 0, i32 0
  %28 = extractvalue { i8*, i8 } %call20, 0
  store i8* %28, i8** %27, align 8
  %29 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %26, i32 0, i32 1
  %30 = extractvalue { i8*, i8 } %call20, 1
  store i8 %30, i8* %29, align 8
  %31 = bitcast %struct.sockptr_t* %ulinfo to i8*
  %32 = bitcast %struct.sockptr_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %31, i8* align 8 %32, i64 16, i1 false)
  store i32 16, i32* %expected_size, align 4
  %33 = load i32, i32* %expected_size, align 4
  store i32 %33, i32* %__UNIQUE_ID___x618, align 4
  %34 = load i32, i32* %rec_size, align 4
  store i32 %34, i32* %__UNIQUE_ID___y619, align 4
  %35 = load i32, i32* %__UNIQUE_ID___x618, align 4
  %36 = load i32, i32* %__UNIQUE_ID___y619, align 4
  %cmp22 = icmp ult i32 %35, %36
  br i1 %cmp22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end17
  %37 = load i32, i32* %__UNIQUE_ID___x618, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end17
  %38 = load i32, i32* %__UNIQUE_ID___y619, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %37, %cond.true ], [ %38, %cond.false ]
  store i32 %cond, i32* %tmp21, align 4
  %39 = load i32, i32* %tmp21, align 4
  store i32 %39, i32* %ncopy, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %40 = load i32, i32* %i, align 4
  %41 = load i32, i32* %nr_linfo, align 4
  %cmp24 = icmp ult i32 %40, %41
  br i1 %cmp24, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %42 = load i32, i32* %expected_size, align 4
  %conv26 = zext i32 %42 to i64
  %43 = load i32, i32* %rec_size, align 4
  %conv27 = zext i32 %43 to i64
  %44 = bitcast %struct.sockptr_t* %ulinfo to { i8*, i8 }*
  %45 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %44, i32 0, i32 0
  %46 = load i8*, i8** %45, align 8
  %47 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %44, i32 0, i32 1
  %48 = load i8, i8* %47, align 8
  %call28 = call i32 @bpf_check_uarg_tail_zero(i8* %46, i8 %48, i64 noundef %conv26, i64 noundef %conv27) #20
  store i32 %call28, i32* %err, align 4
  %49 = load i32, i32* %err, align 4
  %tobool29 = icmp ne i32 %49, 0
  br i1 %tobool29, label %if.then30, label %if.end39

if.then30:                                        ; preds = %for.body
  %50 = load i32, i32* %err, align 4
  %cmp31 = icmp eq i32 %50, -7
  br i1 %cmp31, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.then30
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.245, i64 0, i64 0)) #20
  %53 = bitcast i32* %expected_size to i8*
  %54 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %55 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %54, i32 0, i32 0
  %56 = load i8*, i8** %55, align 8
  %57 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %54, i32 0, i32 1
  %58 = load i8, i8* %57, align 8
  %call34 = call i32 @copy_to_bpfptr_offset(i8* %56, i8 %58, i64 noundef 92, i8* noundef %53, i64 noundef 4) #20
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.then33
  store i32 -14, i32* %err, align 4
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %if.then33
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then30
  br label %err_free

if.end39:                                         ; preds = %for.body
  %59 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %60 = load i32, i32* %i, align 4
  %idxprom = zext i32 %60 to i64
  %arrayidx = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %59, i64 %idxprom
  %61 = bitcast %struct.bpf_line_info* %arrayidx to i8*
  %62 = load i32, i32* %ncopy, align 4
  %conv40 = zext i32 %62 to i64
  %63 = bitcast %struct.sockptr_t* %ulinfo to { i8*, i8 }*
  %64 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %63, i32 0, i32 0
  %65 = load i8*, i8** %64, align 8
  %66 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %63, i32 0, i32 1
  %67 = load i8, i8* %66, align 8
  %call41 = call i32 @copy_from_bpfptr(i8* noundef %61, i8* %65, i8 %67, i64 noundef %conv40) #20
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end39
  store i32 -14, i32* %err, align 4
  br label %err_free

if.end44:                                         ; preds = %if.end39
  %68 = load i32, i32* %i, align 4
  %tobool45 = icmp ne i32 %68, 0
  br i1 %tobool45, label %land.lhs.true, label %lor.lhs.false50

land.lhs.true:                                    ; preds = %if.end44
  %69 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %70 = load i32, i32* %i, align 4
  %idxprom46 = zext i32 %70 to i64
  %arrayidx47 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %69, i64 %idxprom46
  %insn_off = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx47, i32 0, i32 0
  %71 = load i32, i32* %insn_off, align 4
  %72 = load i32, i32* %prev_offset, align 4
  %cmp48 = icmp ule i32 %71, %72
  br i1 %cmp48, label %if.then56, label %lor.lhs.false50

lor.lhs.false50:                                  ; preds = %land.lhs.true, %if.end44
  %73 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %74 = load i32, i32* %i, align 4
  %idxprom51 = zext i32 %74 to i64
  %arrayidx52 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %73, i64 %idxprom51
  %insn_off53 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx52, i32 0, i32 0
  %75 = load i32, i32* %insn_off53, align 4
  %76 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %76, i32 0, i32 4
  %77 = load i32, i32* %len, align 4
  %cmp54 = icmp uge i32 %75, %77
  br i1 %cmp54, label %if.then56, label %if.end61

if.then56:                                        ; preds = %lor.lhs.false50, %land.lhs.true
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %79 = bitcast %struct.bpf_verifier_env* %78 to i8*
  %80 = load i32, i32* %i, align 4
  %81 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %82 = load i32, i32* %i, align 4
  %idxprom57 = zext i32 %82 to i64
  %arrayidx58 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %81, i64 %idxprom57
  %insn_off59 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx58, i32 0, i32 0
  %83 = load i32, i32* %insn_off59, align 4
  %84 = load i32, i32* %prev_offset, align 4
  %85 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len60 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %85, i32 0, i32 4
  %86 = load i32, i32* %len60, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %79, i8* noundef getelementptr inbounds ([65 x i8], [65 x i8]* @.str.246, i64 0, i64 0), i32 noundef %80, i32 noundef %83, i32 noundef %84, i32 noundef %86) #20
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end61:                                         ; preds = %lor.lhs.false50
  %87 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %88 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %87, i32 0, i32 12
  %89 = bitcast %union.anon.198* %88 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %89, i32 0, i32 1
  %90 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %91 = load i32, i32* %i, align 4
  %idxprom62 = zext i32 %91 to i64
  %arrayidx63 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %90, i64 %idxprom62
  %insn_off64 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx63, i32 0, i32 0
  %92 = load i32, i32* %insn_off64, align 4
  %idxprom65 = zext i32 %92 to i64
  %arrayidx66 = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 %idxprom65
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx66, i32 0, i32 0
  %93 = load i8, i8* %code, align 8
  %tobool67 = icmp ne i8 %93, 0
  br i1 %tobool67, label %if.end69, label %if.then68

if.then68:                                        ; preds = %if.end61
  %94 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %95 = bitcast %struct.bpf_verifier_env* %94 to i8*
  %96 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %95, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.247, i64 0, i64 0), i32 noundef %96) #20
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end69:                                         ; preds = %if.end61
  %97 = load %struct.btf*, %struct.btf** %btf, align 8
  %98 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %99 = load i32, i32* %i, align 4
  %idxprom70 = zext i32 %99 to i64
  %arrayidx71 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %98, i64 %idxprom70
  %line_off = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx71, i32 0, i32 2
  %100 = load i32, i32* %line_off, align 4
  %call72 = call i8* @btf_name_by_offset(%struct.btf* noundef %97, i32 noundef %100) #20
  %tobool73 = icmp ne i8* %call72, null
  br i1 %tobool73, label %lor.lhs.false74, label %if.then79

lor.lhs.false74:                                  ; preds = %if.end69
  %101 = load %struct.btf*, %struct.btf** %btf, align 8
  %102 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %103 = load i32, i32* %i, align 4
  %idxprom75 = zext i32 %103 to i64
  %arrayidx76 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %102, i64 %idxprom75
  %file_name_off = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx76, i32 0, i32 1
  %104 = load i32, i32* %file_name_off, align 4
  %call77 = call i8* @btf_name_by_offset(%struct.btf* noundef %101, i32 noundef %104) #20
  %tobool78 = icmp ne i8* %call77, null
  br i1 %tobool78, label %if.end80, label %if.then79

if.then79:                                        ; preds = %lor.lhs.false74, %if.end69
  %105 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %106 = bitcast %struct.bpf_verifier_env* %105 to i8*
  %107 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %106, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.248, i64 0, i64 0), i32 noundef %107) #20
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end80:                                         ; preds = %lor.lhs.false74
  %108 = load i32, i32* %s, align 4
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %109, i32 0, i32 31
  %110 = load i32, i32* %subprog_cnt, align 4
  %cmp81 = icmp ne i32 %108, %110
  br i1 %cmp81, label %if.then83, label %if.end105

if.then83:                                        ; preds = %if.end80
  %111 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %112 = load i32, i32* %i, align 4
  %idxprom84 = zext i32 %112 to i64
  %arrayidx85 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %111, i64 %idxprom84
  %insn_off86 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx85, i32 0, i32 0
  %113 = load i32, i32* %insn_off86, align 4
  %114 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %sub, align 8
  %115 = load i32, i32* %s, align 4
  %idxprom87 = zext i32 %115 to i64
  %arrayidx88 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %114, i64 %idxprom87
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx88, i32 0, i32 0
  %116 = load i32, i32* %start, align 4
  %cmp89 = icmp eq i32 %113, %116
  br i1 %cmp89, label %if.then91, label %if.else

if.then91:                                        ; preds = %if.then83
  %117 = load i32, i32* %i, align 4
  %118 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %sub, align 8
  %119 = load i32, i32* %s, align 4
  %idxprom92 = zext i32 %119 to i64
  %arrayidx93 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %118, i64 %idxprom92
  %linfo_idx = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx93, i32 0, i32 1
  store i32 %117, i32* %linfo_idx, align 4
  %120 = load i32, i32* %s, align 4
  %inc = add i32 %120, 1
  store i32 %inc, i32* %s, align 4
  br label %if.end104

if.else:                                          ; preds = %if.then83
  %121 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %sub, align 8
  %122 = load i32, i32* %s, align 4
  %idxprom94 = zext i32 %122 to i64
  %arrayidx95 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %121, i64 %idxprom94
  %start96 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx95, i32 0, i32 0
  %123 = load i32, i32* %start96, align 4
  %124 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %125 = load i32, i32* %i, align 4
  %idxprom97 = zext i32 %125 to i64
  %arrayidx98 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %124, i64 %idxprom97
  %insn_off99 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx98, i32 0, i32 0
  %126 = load i32, i32* %insn_off99, align 4
  %cmp100 = icmp ult i32 %123, %126
  br i1 %cmp100, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.else
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %128 = bitcast %struct.bpf_verifier_env* %127 to i8*
  %129 = load i32, i32* %s, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %128, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.249, i64 0, i64 0), i32 noundef %129) #20
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end103:                                        ; preds = %if.else
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %if.then91
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %if.end80
  %130 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %131 = load i32, i32* %i, align 4
  %idxprom106 = zext i32 %131 to i64
  %arrayidx107 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %130, i64 %idxprom106
  %insn_off108 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx107, i32 0, i32 0
  %132 = load i32, i32* %insn_off108, align 4
  store i32 %132, i32* %prev_offset, align 4
  %133 = load i32, i32* %rec_size, align 4
  %conv109 = zext i32 %133 to i64
  call void @bpfptr_add(%struct.sockptr_t* noundef %ulinfo, i64 noundef %conv109) #20
  br label %for.inc

for.inc:                                          ; preds = %if.end105
  %134 = load i32, i32* %i, align 4
  %inc110 = add i32 %134, 1
  store i32 %inc110, i32* %i, align 4
  br label %for.cond, !llvm.loop !83

for.end:                                          ; preds = %for.cond
  %135 = load i32, i32* %s, align 4
  %136 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt111 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %136, i32 0, i32 31
  %137 = load i32, i32* %subprog_cnt111, align 4
  %cmp112 = icmp ne i32 %135, %137
  br i1 %cmp112, label %if.then114, label %if.end117

if.then114:                                       ; preds = %for.end
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %139 = bitcast %struct.bpf_verifier_env* %138 to i8*
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt115 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %140, i32 0, i32 31
  %141 = load i32, i32* %subprog_cnt115, align 4
  %142 = load i32, i32* %s, align 4
  %sub116 = sub i32 %141, %142
  %143 = load i32, i32* %s, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %139, i8* noundef getelementptr inbounds ([58 x i8], [58 x i8]* @.str.250, i64 0, i64 0), i32 noundef %sub116, i32 noundef %143) #20
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end117:                                        ; preds = %for.end
  %144 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %145 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux118 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %145, i32 0, i32 10
  %146 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux118, align 8
  %linfo119 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %146, i32 0, i32 53
  store %struct.bpf_line_info* %144, %struct.bpf_line_info** %linfo119, align 8
  %147 = load i32, i32* %nr_linfo, align 4
  %148 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux120 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %148, i32 0, i32 10
  %149 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux120, align 8
  %nr_linfo121 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %149, i32 0, i32 56
  store i32 %147, i32* %nr_linfo121, align 4
  store i32 0, i32* %retval, align 4
  br label %return

err_free:                                         ; preds = %if.then114, %if.then102, %if.then79, %if.then68, %if.then56, %if.then43, %if.end38
  %150 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %151 = bitcast %struct.bpf_line_info* %150 to i8*
  call void @kvfree(i8* noundef %151) #20
  %152 = load i32, i32* %err, align 4
  store i32 %152, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free, %if.end117, %if.then16, %if.then12, %if.then2, %if.then
  %153 = load i32, i32* %retval, align 4
  ret i32 %153
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_core_relo(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, i8* %uattr.coerce0, i8 %uattr.coerce1) #0 {
entry:
  %retval = alloca i32, align 4
  %uattr = alloca %struct.sockptr_t, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %i = alloca i32, align 4
  %nr_core_relo = alloca i32, align 4
  %ncopy = alloca i32, align 4
  %expected_size = alloca i32, align 4
  %rec_size = alloca i32, align 4
  %core_relo = alloca %struct.bpf_core_relo, align 4
  %prog = alloca %struct.bpf_prog*, align 8
  %btf = alloca %struct.btf*, align 8
  %ctx = alloca %struct.bpf_core_ctx, align 8
  %u_core_relo = alloca %struct.sockptr_t, align 8
  %err = alloca i32, align 4
  %tmp = alloca %struct.sockptr_t, align 8
  %__UNIQUE_ID___x620 = alloca i32, align 4
  %__UNIQUE_ID___y621 = alloca i32, align 4
  %tmp18 = alloca i32, align 4
  %0 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %uattr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %uattr.coerce1, i8* %2, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  %3 = bitcast %struct.bpf_core_relo* %core_relo to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %3, i8 0, i64 16, i1 false)
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 2
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %5, %struct.bpf_prog** %prog, align 8
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 10
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 50
  %8 = load %struct.btf*, %struct.btf** %btf2, align 8
  store %struct.btf* %8, %struct.btf** %btf, align 8
  %log = getelementptr inbounds %struct.bpf_core_ctx, %struct.bpf_core_ctx* %ctx, i32 0, i32 0
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 26
  store %struct.bpf_verifier_log* %log3, %struct.bpf_verifier_log** %log, align 8
  %btf4 = getelementptr inbounds %struct.bpf_core_ctx, %struct.bpf_core_ctx* %ctx, i32 0, i32 1
  %10 = load %struct.btf*, %struct.btf** %btf, align 8
  store %struct.btf* %10, %struct.btf** %btf4, align 8
  %11 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %12 = bitcast %union.bpf_attr* %11 to %struct.anon.144*
  %core_relo_cnt = getelementptr inbounds %struct.anon.144, %struct.anon.144* %12, i32 0, i32 21
  %13 = load i32, i32* %core_relo_cnt, align 4
  store i32 %13, i32* %nr_core_relo, align 4
  %14 = load i32, i32* %nr_core_relo, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %15 = load i32, i32* %nr_core_relo, align 4
  %conv = zext i32 %15 to i64
  %cmp = icmp ugt i64 %conv, 134217727
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %16 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %17 = bitcast %union.bpf_attr* %16 to %struct.anon.144*
  %core_relo_rec_size = getelementptr inbounds %struct.anon.144, %struct.anon.144* %17, i32 0, i32 24
  %18 = load i32, i32* %core_relo_rec_size, align 8
  store i32 %18, i32* %rec_size, align 4
  %19 = load i32, i32* %rec_size, align 4
  %conv8 = zext i32 %19 to i64
  %cmp9 = icmp ult i64 %conv8, 16
  br i1 %cmp9, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %20 = load i32, i32* %rec_size, align 4
  %cmp11 = icmp ugt i32 %20, 252
  br i1 %cmp11, label %if.then16, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false
  %21 = load i32, i32* %rec_size, align 4
  %conv14 = zext i32 %21 to i64
  %rem = urem i64 %conv14, 4
  %tobool15 = icmp ne i64 %rem, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false13, %lor.lhs.false, %if.end7
  store i32 -22, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %lor.lhs.false13
  %22 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %23 = bitcast %union.bpf_attr* %22 to %struct.anon.144*
  %core_relos = getelementptr inbounds %struct.anon.144, %struct.anon.144* %23, i32 0, i32 23
  %24 = load i64, i64* %core_relos, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %uattr, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  %call = call { i8*, i8 } @make_bpfptr(i64 noundef %24, i1 noundef zeroext %bf.cast) #20
  %25 = bitcast %struct.sockptr_t* %tmp to { i8*, i8 }*
  %26 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %25, i32 0, i32 0
  %27 = extractvalue { i8*, i8 } %call, 0
  store i8* %27, i8** %26, align 8
  %28 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %25, i32 0, i32 1
  %29 = extractvalue { i8*, i8 } %call, 1
  store i8 %29, i8* %28, align 8
  %30 = bitcast %struct.sockptr_t* %u_core_relo to i8*
  %31 = bitcast %struct.sockptr_t* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* align 8 %31, i64 16, i1 false)
  store i32 16, i32* %expected_size, align 4
  %32 = load i32, i32* %expected_size, align 4
  store i32 %32, i32* %__UNIQUE_ID___x620, align 4
  %33 = load i32, i32* %rec_size, align 4
  store i32 %33, i32* %__UNIQUE_ID___y621, align 4
  %34 = load i32, i32* %__UNIQUE_ID___x620, align 4
  %35 = load i32, i32* %__UNIQUE_ID___y621, align 4
  %cmp19 = icmp ult i32 %34, %35
  br i1 %cmp19, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end17
  %36 = load i32, i32* %__UNIQUE_ID___x620, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end17
  %37 = load i32, i32* %__UNIQUE_ID___y621, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %36, %cond.true ], [ %37, %cond.false ]
  store i32 %cond, i32* %tmp18, align 4
  %38 = load i32, i32* %tmp18, align 4
  store i32 %38, i32* %ncopy, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %39 = load i32, i32* %i, align 4
  %40 = load i32, i32* %nr_core_relo, align 4
  %cmp21 = icmp ult i32 %39, %40
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %41 = load i32, i32* %expected_size, align 4
  %conv23 = zext i32 %41 to i64
  %42 = load i32, i32* %rec_size, align 4
  %conv24 = zext i32 %42 to i64
  %43 = bitcast %struct.sockptr_t* %u_core_relo to { i8*, i8 }*
  %44 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %43, i32 0, i32 0
  %45 = load i8*, i8** %44, align 8
  %46 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %43, i32 0, i32 1
  %47 = load i8, i8* %46, align 8
  %call25 = call i32 @bpf_check_uarg_tail_zero(i8* %45, i8 %47, i64 noundef %conv23, i64 noundef %conv24) #20
  store i32 %call25, i32* %err, align 4
  %48 = load i32, i32* %err, align 4
  %tobool26 = icmp ne i32 %48, 0
  br i1 %tobool26, label %if.then27, label %if.end36

if.then27:                                        ; preds = %for.body
  %49 = load i32, i32* %err, align 4
  %cmp28 = icmp eq i32 %49, -7
  br i1 %cmp28, label %if.then30, label %if.end35

if.then30:                                        ; preds = %if.then27
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = bitcast %struct.bpf_verifier_env* %50 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %51, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.251, i64 0, i64 0)) #20
  %52 = bitcast i32* %expected_size to i8*
  %53 = bitcast %struct.sockptr_t* %uattr to { i8*, i8 }*
  %54 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %53, i32 0, i32 0
  %55 = load i8*, i8** %54, align 8
  %56 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %53, i32 0, i32 1
  %57 = load i8, i8* %56, align 8
  %call31 = call i32 @copy_to_bpfptr_offset(i8* %55, i8 %57, i64 noundef 136, i8* noundef %52, i64 noundef 4) #20
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.then30
  store i32 -14, i32* %err, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.then30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then27
  br label %for.end

if.end36:                                         ; preds = %for.body
  %58 = bitcast %struct.bpf_core_relo* %core_relo to i8*
  %59 = load i32, i32* %ncopy, align 4
  %conv37 = zext i32 %59 to i64
  %60 = bitcast %struct.sockptr_t* %u_core_relo to { i8*, i8 }*
  %61 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %60, i32 0, i32 0
  %62 = load i8*, i8** %61, align 8
  %63 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %60, i32 0, i32 1
  %64 = load i8, i8* %63, align 8
  %call38 = call i32 @copy_from_bpfptr(i8* noundef %58, i8* %62, i8 %64, i64 noundef %conv37) #20
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end36
  store i32 -14, i32* %err, align 4
  br label %for.end

if.end41:                                         ; preds = %if.end36
  %insn_off = getelementptr inbounds %struct.bpf_core_relo, %struct.bpf_core_relo* %core_relo, i32 0, i32 0
  %65 = load i32, i32* %insn_off, align 4
  %rem42 = urem i32 %65, 8
  %tobool43 = icmp ne i32 %rem42, 0
  br i1 %tobool43, label %if.then48, label %lor.lhs.false44

lor.lhs.false44:                                  ; preds = %if.end41
  %insn_off45 = getelementptr inbounds %struct.bpf_core_relo, %struct.bpf_core_relo* %core_relo, i32 0, i32 0
  %66 = load i32, i32* %insn_off45, align 4
  %div = udiv i32 %66, 8
  %67 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %67, i32 0, i32 4
  %68 = load i32, i32* %len, align 4
  %cmp46 = icmp uge i32 %div, %68
  br i1 %cmp46, label %if.then48, label %if.end51

if.then48:                                        ; preds = %lor.lhs.false44, %if.end41
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = bitcast %struct.bpf_verifier_env* %69 to i8*
  %71 = load i32, i32* %i, align 4
  %insn_off49 = getelementptr inbounds %struct.bpf_core_relo, %struct.bpf_core_relo* %core_relo, i32 0, i32 0
  %72 = load i32, i32* %insn_off49, align 4
  %73 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len50 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %73, i32 0, i32 4
  %74 = load i32, i32* %len50, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %70, i8* noundef getelementptr inbounds ([48 x i8], [48 x i8]* @.str.252, i64 0, i64 0), i32 noundef %71, i32 noundef %72, i32 noundef %74) #20
  store i32 -22, i32* %err, align 4
  br label %for.end

if.end51:                                         ; preds = %lor.lhs.false44
  %75 = load i32, i32* %i, align 4
  %76 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %77 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %76, i32 0, i32 12
  %78 = bitcast %union.anon.198* %77 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %78, i32 0, i32 1
  %insn_off52 = getelementptr inbounds %struct.bpf_core_relo, %struct.bpf_core_relo* %core_relo, i32 0, i32 0
  %79 = load i32, i32* %insn_off52, align 4
  %div53 = udiv i32 %79, 8
  %idxprom = zext i32 %div53 to i64
  %arrayidx = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 %idxprom
  %80 = bitcast %struct.bpf_insn* %arrayidx to i8*
  %call54 = call i32 @bpf_core_apply(%struct.bpf_core_ctx* noundef %ctx, %struct.bpf_core_relo* noundef %core_relo, i32 noundef %75, i8* noundef %80) #20
  store i32 %call54, i32* %err, align 4
  %81 = load i32, i32* %err, align 4
  %tobool55 = icmp ne i32 %81, 0
  br i1 %tobool55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end51
  br label %for.end

if.end57:                                         ; preds = %if.end51
  %82 = load i32, i32* %rec_size, align 4
  %conv58 = zext i32 %82 to i64
  call void @bpfptr_add(%struct.sockptr_t* noundef %u_core_relo, i64 noundef %conv58) #20
  br label %for.inc

for.inc:                                          ; preds = %if.end57
  %83 = load i32, i32* %i, align 4
  %inc = add i32 %83, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !84

for.end:                                          ; preds = %if.then56, %if.then48, %if.then40, %if.end35, %for.cond
  %84 = load i32, i32* %err, align 4
  store i32 %84, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then16, %if.then6, %if.then
  %85 = load i32, i32* %retval, align 4
  ret i32 %85
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong allocsize(0,1)
define internal noalias i8* @kcalloc(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #8 {
entry:
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  %1 = load i64, i64* %size.addr, align 8
  %2 = load i32, i32* %flags.addr, align 4
  %or = or i32 %2, 256
  %call = call noalias i8* @kmalloc_array(i64 noundef %0, i64 noundef %1, i32 noundef %or) #25
  ret i8* %call
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_check_uarg_tail_zero(i8*, i8, i64 noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_to_bpfptr_offset(i8* %dst.coerce0, i8 %dst.coerce1, i64 noundef %offset, i8* noundef %src, i64 noundef %size) #0 {
entry:
  %dst = alloca %struct.sockptr_t, align 8
  %offset.addr = alloca i64, align 8
  %src.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %agg.tmp = alloca %struct.sockptr_t, align 8
  %0 = bitcast %struct.sockptr_t* %dst to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %dst.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %dst.coerce1, i8* %2, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i8* %src, i8** %src.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = bitcast %struct.sockptr_t* %agg.tmp to i8*
  %4 = bitcast %struct.sockptr_t* %dst to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 %4, i64 16, i1 false)
  %5 = load i64, i64* %offset.addr, align 8
  %6 = load i8*, i8** %src.addr, align 8
  %7 = load i64, i64* %size.addr, align 8
  %8 = bitcast %struct.sockptr_t* %agg.tmp to { i8*, i8 }*
  %9 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %8, i32 0, i32 0
  %10 = load i8*, i8** %9, align 8
  %11 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %8, i32 0, i32 1
  %12 = load i8, i8* %11, align 8
  %call = call i32 @copy_to_sockptr_offset(i8* %10, i8 %12, i64 noundef %5, i8* noundef %6, i64 noundef %7) #20
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_from_bpfptr(i8* noundef %dst, i8* %src.coerce0, i8 %src.coerce1, i64 noundef %size) #0 {
entry:
  %src = alloca %struct.sockptr_t, align 8
  %dst.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %0 = bitcast %struct.sockptr_t* %src to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %src.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %src.coerce1, i8* %2, align 8
  store i8* %dst, i8** %dst.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = load i8*, i8** %dst.addr, align 8
  %4 = load i64, i64* %size.addr, align 8
  %5 = bitcast %struct.sockptr_t* %src to { i8*, i8 }*
  %6 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %5, i32 0, i32 0
  %7 = load i8*, i8** %6, align 8
  %8 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %5, i32 0, i32 1
  %9 = load i8, i8* %8, align 8
  %call = call i32 @copy_from_bpfptr_offset(i8* noundef %3, i8* %7, i8 %9, i64 noundef 0, i64 noundef %4) #20
  ret i32 %call
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef, i32 noundef, i32* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_small_int(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %call = call zeroext i1 @btf_type_is_int(%struct.btf_type* noundef %0) #20
  br i1 %call, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %2 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %1, i32 0, i32 2
  %size = bitcast %union.anon.137* %2 to i32*
  %3 = load i32, i32* %size, align 4
  %conv = zext i32 %3 to i64
  %cmp = icmp ule i64 %conv, 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_is_any_enum(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 6
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info1 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %2, i32 0, i32 1
  %3 = load i32, i32* %info1, align 4
  %shr2 = lshr i32 %3, 24
  %and3 = and i32 %shr2, 31
  %cmp4 = icmp eq i32 %and3, 19
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp4, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpfptr_add(%struct.sockptr_t* noundef %bpfptr, i64 noundef %val) #0 {
entry:
  %bpfptr.addr = alloca %struct.sockptr_t*, align 8
  %val.addr = alloca i64, align 8
  store %struct.sockptr_t* %bpfptr, %struct.sockptr_t** %bpfptr.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load %struct.sockptr_t*, %struct.sockptr_t** %bpfptr.addr, align 8
  %1 = bitcast %struct.sockptr_t* %0 to { i8*, i8 }*
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %1, i32 0, i32 0
  %3 = load i8*, i8** %2, align 8
  %4 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %1, i32 0, i32 1
  %5 = load i8, i8* %4, align 8
  %call = call zeroext i1 @bpfptr_is_kernel(i8* %3, i8 %5) #20
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load i64, i64* %val.addr, align 8
  %7 = load %struct.sockptr_t*, %struct.sockptr_t** %bpfptr.addr, align 8
  %8 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %7, i32 0, i32 0
  %kernel = bitcast %union.anon.48* %8 to i8**
  %9 = load i8*, i8** %kernel, align 8
  %add.ptr = getelementptr i8, i8* %9, i64 %6
  store i8* %add.ptr, i8** %kernel, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %10 = load i64, i64* %val.addr, align 8
  %11 = load %struct.sockptr_t*, %struct.sockptr_t** %bpfptr.addr, align 8
  %12 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %11, i32 0, i32 0
  %user = bitcast %union.anon.48* %12 to i8**
  %13 = load i8*, i8** %user, align 8
  %add.ptr1 = getelementptr i8, i8* %13, i64 %10
  store i8* %add.ptr1, i8** %user, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_to_sockptr_offset(i8* %dst.coerce0, i8 %dst.coerce1, i64 noundef %offset, i8* noundef %src, i64 noundef %size) #0 {
entry:
  %retval.i = alloca i1, align 1
  %addr.addr.i = alloca i8*, align 8
  %bytes.addr.i = alloca i64, align 8
  %is_source.addr.i = alloca i8, align 1
  %sz.i = alloca i32, align 4
  %__ret_warn_on.i = alloca i32, align 4
  %__flags.i = alloca i32, align 4
  %tmp.i = alloca i64, align 8
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %retval = alloca i32, align 4
  %dst = alloca %struct.sockptr_t, align 8
  %offset.addr = alloca i64, align 8
  %src.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %0 = bitcast %struct.sockptr_t* %dst to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %dst.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %dst.coerce1, i8* %2, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i8* %src, i8** %src.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = bitcast %struct.sockptr_t* %dst to { i8*, i8 }*
  %4 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 0
  %5 = load i8*, i8** %4, align 8
  %6 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %3, i32 0, i32 1
  %7 = load i8, i8* %6, align 8
  %call = call zeroext i1 @sockptr_is_kernel(i8* %5, i8 %7) #20
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %8 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %dst, i32 0, i32 0
  %user = bitcast %union.anon.48* %8 to i8**
  %9 = load i8*, i8** %user, align 8
  %10 = load i64, i64* %offset.addr, align 8
  %add.ptr = getelementptr i8, i8* %9, i64 %10
  %11 = load i8*, i8** %src.addr, align 8
  %12 = load i64, i64* %size.addr, align 8
  store i8* %add.ptr, i8** %to.addr.i, align 8
  store i8* %11, i8** %from.addr.i, align 8
  store i64 %12, i64* %n.addr.i, align 8
  %13 = load i8*, i8** %from.addr.i, align 8
  %14 = load i64, i64* %n.addr.i, align 8
  store i8* %13, i8** %addr.addr.i, align 8
  store i64 %14, i64* %bytes.addr.i, align 8
  store i8 1, i8* %is_source.addr.i, align 1
  %15 = load i8*, i8** %addr.addr.i, align 8
  %16 = call i64 @llvm.objectsize.i64.p0i8(i8* %15, i1 false, i1 true, i1 false) #19
  %conv.i = trunc i64 %16 to i32
  store i32 %conv.i, i32* %sz.i, align 4
  %17 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp sge i32 %17, 0
  br i1 %cmp.i, label %land.rhs.i, label %land.end.i

land.rhs.i:                                       ; preds = %if.then
  %18 = load i32, i32* %sz.i, align 4
  %conv2.i = sext i32 %18 to i64
  %19 = load i64, i64* %bytes.addr.i, align 8
  %cmp3.i = icmp ult i64 %conv2.i, %19
  br label %land.end.i

land.end.i:                                       ; preds = %land.rhs.i, %if.then
  %20 = phi i1 [ false, %if.then ], [ %cmp3.i, %land.rhs.i ]
  %lnot.i = xor i1 %20, true
  %lnot.ext.i = zext i1 %20 to i32
  %conv6.i = sext i32 %lnot.ext.i to i64
  br i1 %20, label %if.then.i3, label %if.end12.i

if.then.i3:                                       ; preds = %land.end.i
  %21 = load i64, i64* %bytes.addr.i, align 8
  %22 = call i1 @llvm.is.constant.i64(i64 %21) #19
  br i1 %22, label %if.else.i, label %if.then7.i

if.then7.i:                                       ; preds = %if.then.i3
  %23 = load i32, i32* %sz.i, align 4
  %24 = load i64, i64* %bytes.addr.i, align 8
  call void @copy_overflow(i32 noundef %23, i64 noundef %24) #22
  br label %if.end11.i

if.else.i:                                        ; preds = %if.then.i3
  %25 = load i8, i8* %is_source.addr.i, align 1
  %tobool8.i = trunc i8 %25 to i1
  br i1 %tobool8.i, label %if.then9.i, label %if.else10.i

if.then9.i:                                       ; preds = %if.else.i
  call void @__bad_copy_from() #22, !srcloc !7
  br label %if.end.i

if.else10.i:                                      ; preds = %if.else.i
  call void @__bad_copy_to() #22, !srcloc !8
  br label %if.end.i

if.end.i:                                         ; preds = %if.else10.i, %if.then9.i
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.end.i, %if.then7.i
  store i1 false, i1* %retval.i, align 1
  br label %check_copy_size.exit

if.end12.i:                                       ; preds = %land.end.i
  %26 = load i64, i64* %bytes.addr.i, align 8
  %cmp13.i = icmp ugt i64 %26, 2147483647
  %lnot15.i = xor i1 %cmp13.i, true
  %lnot.ext18.i = zext i1 %cmp13.i to i32
  store i32 %lnot.ext18.i, i32* %__ret_warn_on.i, align 4
  %27 = load i32, i32* %__ret_warn_on.i, align 4
  %tobool19.i = icmp ne i32 %27, 0
  %lnot20.i = xor i1 %tobool19.i, true
  %lnot.ext23.i = zext i1 %tobool19.i to i32
  %conv24.i = sext i32 %lnot.ext23.i to i64
  br i1 %tobool19.i, label %if.then26.i, label %if.end33.i

if.then26.i:                                      ; preds = %if.end12.i
  store i32 2307, i32* %__flags.i, align 4
  %28 = load i32, i32* %__flags.i, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.27, i64 0, i64 0), i32 233, i32 %28, i64 12) #19, !srcloc !9
  br label %if.end33.i

if.end33.i:                                       ; preds = %if.then26.i, %if.end12.i
  %29 = load i32, i32* %__ret_warn_on.i, align 4
  %tobool34.i = icmp ne i32 %29, 0
  %lnot35.i = xor i1 %tobool34.i, true
  %lnot.ext38.i = zext i1 %tobool34.i to i32
  %conv39.i = sext i32 %lnot.ext38.i to i64
  store i64 %conv39.i, i64* %tmp.i, align 8
  %30 = load i64, i64* %tmp.i, align 8
  %tobool40.i = icmp ne i64 %30, 0
  br i1 %tobool40.i, label %if.then41.i, label %if.end42.i

if.then41.i:                                      ; preds = %if.end33.i
  store i1 false, i1* %retval.i, align 1
  br label %check_copy_size.exit

if.end42.i:                                       ; preds = %if.end33.i
  %31 = load i8*, i8** %addr.addr.i, align 8
  %32 = load i64, i64* %bytes.addr.i, align 8
  %33 = load i8, i8* %is_source.addr.i, align 1
  %tobool43.i = trunc i8 %33 to i1
  call void @check_object_size(i8* noundef %31, i64 noundef %32, i1 noundef zeroext %tobool43.i) #22
  store i1 true, i1* %retval.i, align 1
  br label %check_copy_size.exit

check_copy_size.exit:                             ; preds = %if.end11.i, %if.then41.i, %if.end42.i
  %34 = load i1, i1* %retval.i, align 1
  br i1 %34, label %if.then.i, label %copy_to_user.exit

if.then.i:                                        ; preds = %check_copy_size.exit
  %35 = load i8*, i8** %to.addr.i, align 8
  %36 = load i8*, i8** %from.addr.i, align 8
  %37 = load i64, i64* %n.addr.i, align 8
  %call1.i = call i64 @_copy_to_user(i8* noundef %35, i8* noundef %36, i64 noundef %37) #22
  store i64 %call1.i, i64* %n.addr.i, align 8
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %check_copy_size.exit, %if.then.i
  %38 = load i64, i64* %n.addr.i, align 8
  %conv = trunc i64 %38 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %39 = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %dst, i32 0, i32 0
  %kernel = bitcast %union.anon.48* %39 to i8**
  %40 = load i8*, i8** %kernel, align 8
  %41 = load i64, i64* %offset.addr, align 8
  %add.ptr2 = getelementptr i8, i8* %40, i64 %41
  %42 = load i8*, i8** %src.addr, align 8
  %43 = load i64, i64* %size.addr, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %add.ptr2, i8* align 1 %42, i64 %43, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %copy_to_user.exit
  %44 = load i32, i32* %retval, align 4
  ret i32 %44
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @sockptr_is_kernel(i8* %sockptr.coerce0, i8 %sockptr.coerce1) #0 {
entry:
  %sockptr = alloca %struct.sockptr_t, align 8
  %0 = bitcast %struct.sockptr_t* %sockptr to { i8*, i8 }*
  %1 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 0
  store i8* %sockptr.coerce0, i8** %1, align 8
  %2 = getelementptr inbounds { i8*, i8 }, { i8*, i8 }* %0, i32 0, i32 1
  store i8 %sockptr.coerce1, i8* %2, align 8
  %is_kernel = getelementptr inbounds %struct.sockptr_t, %struct.sockptr_t* %sockptr, i32 0, i32 1
  %bf.load = load i8, i8* %is_kernel, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  ret i1 %bf.cast
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_int(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 1
  ret i1 %cmp
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_core_apply(%struct.bpf_core_ctx* noundef, %struct.bpf_core_relo* noundef, i32 noundef, i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_struct_ops_btf_id(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %t = alloca %struct.btf_type*, align 8
  %func_proto = alloca %struct.btf_type*, align 8
  %st_ops = alloca %struct.bpf_struct_ops*, align 8
  %member = alloca %struct.btf_member*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %btf_id = alloca i32, align 4
  %member_idx = alloca i32, align 4
  %mname = alloca i8*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %gpl_compatible = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 1
  %bf.load = load i16, i16* %gpl_compatible, align 2
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %tobool = icmp ne i16 %bf.clear, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = bitcast %struct.bpf_verifier_env* %3 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %4, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.255, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 10
  %6 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %attach_btf_id = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %6, i32 0, i32 10
  %7 = load i32, i32* %attach_btf_id, align 4
  store i32 %7, i32* %btf_id, align 4
  %8 = load i32, i32* %btf_id, align 4
  %call = call %struct.bpf_struct_ops* @bpf_struct_ops_find(i32 noundef %8) #20
  store %struct.bpf_struct_ops* %call, %struct.bpf_struct_ops** %st_ops, align 8
  %9 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %tobool2 = icmp ne %struct.bpf_struct_ops* %9, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load i32, i32* %btf_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.256, i64 0, i64 0), i32 noundef %12) #20
  store i32 -524, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %13 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %type = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %13, i32 0, i32 6
  %14 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  store %struct.btf_type* %14, %struct.btf_type** %t, align 8
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %15, i32 0, i32 3
  %16 = load i32, i32* %expected_attach_type, align 8
  store i32 %16, i32* %member_idx, align 4
  %17 = load i32, i32* %member_idx, align 4
  %18 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call5 = call zeroext i16 @btf_type_vlen(%struct.btf_type* noundef %18) #20
  %conv = zext i16 %call5 to i32
  %cmp = icmp uge i32 %17, %conv
  br i1 %cmp, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  %21 = load i32, i32* %member_idx, align 4
  %22 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %name = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %22, i32 0, i32 8
  %23 = load i8*, i8** %name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.257, i64 0, i64 0), i32 noundef %21, i8* noundef %23) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end4
  %24 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call9 = call %struct.btf_member* @btf_type_member(%struct.btf_type* noundef %24) #20
  %25 = load i32, i32* %member_idx, align 4
  %idxprom = zext i32 %25 to i64
  %arrayidx = getelementptr %struct.btf_member, %struct.btf_member* %call9, i64 %idxprom
  store %struct.btf_member* %arrayidx, %struct.btf_member** %member, align 8
  %26 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %27 = load %struct.btf_member*, %struct.btf_member** %member, align 8
  %name_off = getelementptr inbounds %struct.btf_member, %struct.btf_member* %27, i32 0, i32 0
  %28 = load i32, i32* %name_off, align 4
  %call10 = call i8* @btf_name_by_offset(%struct.btf* noundef %26, i32 noundef %28) #20
  store i8* %call10, i8** %mname, align 8
  %29 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %30 = load %struct.btf_member*, %struct.btf_member** %member, align 8
  %type11 = getelementptr inbounds %struct.btf_member, %struct.btf_member* %30, i32 0, i32 1
  %31 = load i32, i32* %type11, align 4
  %call12 = call %struct.btf_type* @btf_type_resolve_func_ptr(%struct.btf* noundef %29, i32 noundef %31, i32* noundef null) #20
  store %struct.btf_type* %call12, %struct.btf_type** %func_proto, align 8
  %32 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %tobool13 = icmp ne %struct.btf_type* %32, null
  br i1 %tobool13, label %if.end16, label %if.then14

if.then14:                                        ; preds = %if.end8
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  %35 = load i8*, i8** %mname, align 8
  %36 = load i32, i32* %member_idx, align 4
  %37 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %name15 = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %37, i32 0, i32 8
  %38 = load i8*, i8** %name15, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.258, i64 0, i64 0), i8* noundef %35, i32 noundef %36, i8* noundef %38) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end8
  %39 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %check_member = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %39, i32 0, i32 2
  %40 = load i32 (%struct.btf_type*, %struct.btf_member*)*, i32 (%struct.btf_type*, %struct.btf_member*)** %check_member, align 8
  %tobool17 = icmp ne i32 (%struct.btf_type*, %struct.btf_member*)* %40, null
  br i1 %tobool17, label %if.then18, label %if.end25

if.then18:                                        ; preds = %if.end16
  %41 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %check_member19 = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %41, i32 0, i32 2
  %42 = load i32 (%struct.btf_type*, %struct.btf_member*)*, i32 (%struct.btf_type*, %struct.btf_member*)** %check_member19, align 8
  %43 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %44 = load %struct.btf_member*, %struct.btf_member** %member, align 8
  %call20 = call i32 %42(%struct.btf_type* noundef %43, %struct.btf_member* noundef %44) #20
  store i32 %call20, i32* %err, align 4
  %45 = load i32, i32* %err, align 4
  %tobool21 = icmp ne i32 %45, 0
  br i1 %tobool21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.then18
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = bitcast %struct.bpf_verifier_env* %46 to i8*
  %48 = load i8*, i8** %mname, align 8
  %49 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %name23 = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %49, i32 0, i32 8
  %50 = load i8*, i8** %name23, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %47, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.259, i64 0, i64 0), i8* noundef %48, i8* noundef %50) #20
  %51 = load i32, i32* %err, align 4
  store i32 %51, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.then18
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end16
  %52 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %53 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux26 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %53, i32 0, i32 10
  %54 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux26, align 8
  %attach_func_proto = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %54, i32 0, i32 28
  store %struct.btf_type* %52, %struct.btf_type** %attach_func_proto, align 8
  %55 = load i8*, i8** %mname, align 8
  %56 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux27 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %56, i32 0, i32 10
  %57 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux27, align 8
  %attach_func_name = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %57, i32 0, i32 29
  store i8* %55, i8** %attach_func_name, align 8
  %58 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %verifier_ops = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %58, i32 0, i32 0
  %59 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %verifier_ops, align 8
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %60, i32 0, i32 3
  store %struct.bpf_verifier_ops* %59, %struct.bpf_verifier_ops** %ops, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end25, %if.then22, %if.then14, %if.then7, %if.then3, %if.then
  %61 = load i32, i32* %retval, align 4
  ret i32 %61
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_iter_prog_supported(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_lsm_verify_prog(%struct.bpf_verifier_log* noundef %vlog, %struct.bpf_prog* noundef %prog) #0 {
entry:
  %vlog.addr = alloca %struct.bpf_verifier_log*, align 8
  %prog.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_verifier_log* %vlog, %struct.bpf_verifier_log** %vlog.addr, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  ret i32 -95
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @bpf_trampoline_compute_key(%struct.bpf_prog* noundef %tgt_prog, %struct.btf* noundef %btf, i32 noundef %btf_id) #0 {
entry:
  %retval = alloca i64, align 8
  %tgt_prog.addr = alloca %struct.bpf_prog*, align 8
  %btf.addr = alloca %struct.btf*, align 8
  %btf_id.addr = alloca i32, align 4
  store %struct.bpf_prog* %tgt_prog, %struct.bpf_prog** %tgt_prog.addr, align 8
  store %struct.btf* %btf, %struct.btf** %btf.addr, align 8
  store i32 %btf_id, i32* %btf_id.addr, align 4
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool = icmp ne %struct.bpf_prog* %0, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 10
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %id = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %2, i32 0, i32 7
  %3 = load i32, i32* %id, align 8
  %conv = zext i32 %3 to i64
  %shl = shl i64 %conv, 32
  %4 = load i32, i32* %btf_id.addr, align 4
  %conv1 = zext i32 %4 to i64
  %or = or i64 %shl, %conv1
  store i64 %or, i64* %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %5 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %call = call i32 @btf_obj_id(%struct.btf* noundef %5) #20
  %conv2 = zext i32 %call to i64
  %shl3 = shl i64 %conv2, 32
  %or4 = or i64 %shl3, 2147483648
  %6 = load i32, i32* %btf_id.addr, align 4
  %conv5 = zext i32 %6 to i64
  %or6 = or i64 %or4, %conv5
  store i64 %or6, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %7 = load i64, i64* %retval, align 8
  ret i64 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_trampoline* @bpf_trampoline_get(i64 noundef %key, %struct.bpf_attach_target_info* noundef %tgt_info) #0 {
entry:
  %key.addr = alloca i64, align 8
  %tgt_info.addr = alloca %struct.bpf_attach_target_info*, align 8
  store i64 %key, i64* %key.addr, align 8
  store %struct.bpf_attach_target_info* %tgt_info, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %call = call i8* @ERR_PTR(i64 noundef -95) #20
  %0 = bitcast i8* %call to %struct.bpf_trampoline*
  ret %struct.bpf_trampoline* %0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_struct_ops* @bpf_struct_ops_find(i32 noundef %type_id) #0 {
entry:
  %type_id.addr = alloca i32, align 4
  store i32 %type_id, i32* %type_id.addr, align 4
  ret %struct.bpf_struct_ops* null
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i16 @btf_type_vlen(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %and = and i32 %1, 65535
  %conv = trunc i32 %and to i16
  ret i16 %conv
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.btf_member* @btf_type_member(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %add.ptr = getelementptr %struct.btf_type, %struct.btf_type* %0, i64 1
  %1 = bitcast %struct.btf_type* %add.ptr to %struct.btf_member*
  ret %struct.btf_member* %1
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_type_resolve_func_ptr(%struct.btf* noundef, i32 noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_obj_id(%struct.btf* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_calc_tag(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_pseudo_btf_id(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %vsi = alloca %struct.btf_var_secinfo*, align 8
  %datasec = alloca %struct.btf_type*, align 8
  %btf_mod = alloca %struct.btf_mod_pair*, align 8
  %t = alloca %struct.btf_type*, align 8
  %sym_name = alloca i8*, align 8
  %percpu = alloca i8, align 1
  %type = alloca i32, align 4
  %id = alloca i32, align 4
  %btf = alloca %struct.btf*, align 8
  %datasec_id = alloca i32, align 4
  %addr = alloca i64, align 8
  %i = alloca i32, align 4
  %btf_fd = alloca i32, align 4
  %err = alloca i32, align 4
  %ret = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %tsize = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store i8 0, i8* %percpu, align 1
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 3
  %1 = load i32, i32* %imm, align 4
  store i32 %1, i32* %id, align 4
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %2, i64 1
  %imm1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 3
  %3 = load i32, i32* %imm1, align 4
  store i32 %3, i32* %btf_fd, align 4
  %4 = load i32, i32* %btf_fd, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load i32, i32* %btf_fd, align 4
  %call = call %struct.btf* @btf_get_by_fd(i32 noundef %5) #20
  store %struct.btf* %call, %struct.btf** %btf, align 8
  %6 = load %struct.btf*, %struct.btf** %btf, align 8
  %7 = bitcast %struct.btf* %6 to i8*
  %call2 = call zeroext i1 @IS_ERR(i8* noundef %7) #20
  br i1 %call2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.270, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end7

if.else:                                          ; preds = %entry
  %10 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool4 = icmp ne %struct.btf* %10, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.else
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([83 x i8], [83 x i8]* @.str.271, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.else
  %13 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  store %struct.btf* %13, %struct.btf** %btf, align 8
  %14 = load %struct.btf*, %struct.btf** %btf, align 8
  call void @btf_get(%struct.btf* noundef %14) #20
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %if.end
  %15 = load %struct.btf*, %struct.btf** %btf, align 8
  %16 = load i32, i32* %id, align 4
  %call8 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %15, i32 noundef %16) #20
  store %struct.btf_type* %call8, %struct.btf_type** %t, align 8
  %17 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %tobool9 = icmp ne %struct.btf_type* %17, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end7
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.272, i64 0, i64 0), i32 noundef %20) #20
  store i32 -2, i32* %err, align 4
  br label %err_put

if.end11:                                         ; preds = %if.end7
  %21 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call12 = call zeroext i1 @btf_type_is_var(%struct.btf_type* noundef %21) #20
  br i1 %call12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end11
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  %24 = load i32, i32* %id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.273, i64 0, i64 0), i32 noundef %24) #20
  store i32 -22, i32* %err, align 4
  br label %err_put

if.end14:                                         ; preds = %if.end11
  %25 = load %struct.btf*, %struct.btf** %btf, align 8
  %26 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %26, i32 0, i32 0
  %27 = load i32, i32* %name_off, align 4
  %call15 = call i8* @btf_name_by_offset(%struct.btf* noundef %25, i32 noundef %27) #20
  store i8* %call15, i8** %sym_name, align 8
  %28 = load i8*, i8** %sym_name, align 8
  %call16 = call i64 @kallsyms_lookup_name(i8* noundef %28) #20
  store i64 %call16, i64* %addr, align 8
  %29 = load i64, i64* %addr, align 8
  %tobool17 = icmp ne i64 %29, 0
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end14
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load i8*, i8** %sym_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.274, i64 0, i64 0), i8* noundef %32) #20
  store i32 -2, i32* %err, align 4
  br label %err_put

if.end19:                                         ; preds = %if.end14
  %33 = load %struct.btf*, %struct.btf** %btf, align 8
  %call20 = call i32 @find_btf_percpu_datasec(%struct.btf* noundef %33) #20
  store i32 %call20, i32* %datasec_id, align 4
  %34 = load i32, i32* %datasec_id, align 4
  %cmp = icmp sgt i32 %34, 0
  br i1 %cmp, label %if.then21, label %if.end32

if.then21:                                        ; preds = %if.end19
  %35 = load %struct.btf*, %struct.btf** %btf, align 8
  %36 = load i32, i32* %datasec_id, align 4
  %call22 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %35, i32 noundef %36) #20
  store %struct.btf_type* %call22, %struct.btf_type** %datasec, align 8
  store i32 0, i32* %i, align 4
  %37 = load %struct.btf_type*, %struct.btf_type** %datasec, align 8
  %call23 = call %struct.btf_var_secinfo* @btf_type_var_secinfo(%struct.btf_type* noundef %37) #20
  store %struct.btf_var_secinfo* %call23, %struct.btf_var_secinfo** %vsi, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then21
  %38 = load i32, i32* %i, align 4
  %39 = load %struct.btf_type*, %struct.btf_type** %datasec, align 8
  %call24 = call zeroext i16 @btf_type_vlen(%struct.btf_type* noundef %39) #20
  %conv = zext i16 %call24 to i32
  %cmp25 = icmp slt i32 %38, %conv
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %40 = load %struct.btf_var_secinfo*, %struct.btf_var_secinfo** %vsi, align 8
  %type27 = getelementptr inbounds %struct.btf_var_secinfo, %struct.btf_var_secinfo* %40, i32 0, i32 0
  %41 = load i32, i32* %type27, align 4
  %42 = load i32, i32* %id, align 4
  %cmp28 = icmp eq i32 %41, %42
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %for.body
  store i8 1, i8* %percpu, align 1
  br label %for.end

if.end31:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end31
  %43 = load i32, i32* %i, align 4
  %inc = add i32 %43, 1
  store i32 %inc, i32* %i, align 4
  %44 = load %struct.btf_var_secinfo*, %struct.btf_var_secinfo** %vsi, align 8
  %incdec.ptr = getelementptr %struct.btf_var_secinfo, %struct.btf_var_secinfo* %44, i32 1
  store %struct.btf_var_secinfo* %incdec.ptr, %struct.btf_var_secinfo** %vsi, align 8
  br label %for.cond, !llvm.loop !85

for.end:                                          ; preds = %if.then30, %for.cond
  br label %if.end32

if.end32:                                         ; preds = %for.end, %if.end19
  %45 = load i64, i64* %addr, align 8
  %conv33 = trunc i64 %45 to i32
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %arrayidx34 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %46, i64 0
  %imm35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx34, i32 0, i32 3
  store i32 %conv33, i32* %imm35, align 4
  %47 = load i64, i64* %addr, align 8
  %shr = lshr i64 %47, 32
  %conv36 = trunc i64 %shr to i32
  %48 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %arrayidx37 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %48, i64 1
  %imm38 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx37, i32 0, i32 3
  store i32 %conv36, i32* %imm38, align 4
  %49 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %50 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %49, i32 0, i32 2
  %type39 = bitcast %union.anon.137* %50 to i32*
  %51 = load i32, i32* %type39, align 4
  store i32 %51, i32* %type, align 4
  %52 = load %struct.btf*, %struct.btf** %btf, align 8
  %53 = load i32, i32* %type, align 4
  %call40 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %52, i32 noundef %53, i32* noundef null) #20
  store %struct.btf_type* %call40, %struct.btf_type** %t, align 8
  %54 = load i8, i8* %percpu, align 1
  %tobool41 = trunc i8 %54 to i1
  br i1 %tobool41, label %if.then42, label %if.else46

if.then42:                                        ; preds = %if.end32
  %55 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %56 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %55, i32 0, i32 0
  %btf_var = bitcast %union.anon.210* %56 to %struct.anon.212*
  %reg_type = getelementptr inbounds %struct.anon.212, %struct.anon.212* %btf_var, i32 0, i32 0
  store i32 4112, i32* %reg_type, align 8
  %57 = load %struct.btf*, %struct.btf** %btf, align 8
  %58 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %59 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %58, i32 0, i32 0
  %btf_var43 = bitcast %union.anon.210* %59 to %struct.anon.212*
  %60 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %btf_var43, i32 0, i32 1
  %61 = bitcast %union.anon.213* %60 to %struct.anon.214*
  %btf44 = getelementptr inbounds %struct.anon.214, %struct.anon.214* %61, i32 0, i32 0
  store %struct.btf* %57, %struct.btf** %btf44, align 8
  %62 = load i32, i32* %type, align 4
  %63 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %64 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %63, i32 0, i32 0
  %btf_var45 = bitcast %union.anon.210* %64 to %struct.anon.212*
  %65 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %btf_var45, i32 0, i32 1
  %66 = bitcast %union.anon.213* %65 to %struct.anon.214*
  %btf_id = getelementptr inbounds %struct.anon.214, %struct.anon.214* %66, i32 0, i32 1
  store i32 %62, i32* %btf_id, align 8
  br label %if.end67

if.else46:                                        ; preds = %if.end32
  %67 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call47 = call zeroext i1 @btf_type_is_struct(%struct.btf_type* noundef %67) #20
  br i1 %call47, label %if.else59, label %if.then48

if.then48:                                        ; preds = %if.else46
  %68 = load %struct.btf*, %struct.btf** %btf, align 8
  %69 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call49 = call %struct.btf_type* @btf_resolve_size(%struct.btf* noundef %68, %struct.btf_type* noundef %69, i32* noundef %tsize) #20
  store %struct.btf_type* %call49, %struct.btf_type** %ret, align 8
  %70 = load %struct.btf_type*, %struct.btf_type** %ret, align 8
  %71 = bitcast %struct.btf_type* %70 to i8*
  %call50 = call zeroext i1 @IS_ERR(i8* noundef %71) #20
  br i1 %call50, label %if.then51, label %if.end55

if.then51:                                        ; preds = %if.then48
  %72 = load %struct.btf*, %struct.btf** %btf, align 8
  %73 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off52 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %73, i32 0, i32 0
  %74 = load i32, i32* %name_off52, align 4
  %call53 = call i8* @btf_name_by_offset(%struct.btf* noundef %72, i32 noundef %74) #20
  store i8* %call53, i8** %tname, align 8
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = bitcast %struct.bpf_verifier_env* %75 to i8*
  %77 = load i8*, i8** %tname, align 8
  %78 = load %struct.btf_type*, %struct.btf_type** %ret, align 8
  %79 = bitcast %struct.btf_type* %78 to i8*
  %call54 = call i64 @PTR_ERR(i8* noundef %79) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %76, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.275, i64 0, i64 0), i8* noundef %77, i64 noundef %call54) #20
  store i32 -22, i32* %err, align 4
  br label %err_put

if.end55:                                         ; preds = %if.then48
  %80 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %81 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %80, i32 0, i32 0
  %btf_var56 = bitcast %union.anon.210* %81 to %struct.anon.212*
  %reg_type57 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %btf_var56, i32 0, i32 0
  store i32 529, i32* %reg_type57, align 8
  %82 = load i32, i32* %tsize, align 4
  %83 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %84 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %83, i32 0, i32 0
  %btf_var58 = bitcast %union.anon.210* %84 to %struct.anon.212*
  %85 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %btf_var58, i32 0, i32 1
  %mem_size = bitcast %union.anon.213* %85 to i32*
  store i32 %82, i32* %mem_size, align 8
  br label %if.end66

if.else59:                                        ; preds = %if.else46
  %86 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %87 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %86, i32 0, i32 0
  %btf_var60 = bitcast %union.anon.210* %87 to %struct.anon.212*
  %reg_type61 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %btf_var60, i32 0, i32 0
  store i32 16, i32* %reg_type61, align 8
  %88 = load %struct.btf*, %struct.btf** %btf, align 8
  %89 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %90 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %89, i32 0, i32 0
  %btf_var62 = bitcast %union.anon.210* %90 to %struct.anon.212*
  %91 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %btf_var62, i32 0, i32 1
  %92 = bitcast %union.anon.213* %91 to %struct.anon.214*
  %btf63 = getelementptr inbounds %struct.anon.214, %struct.anon.214* %92, i32 0, i32 0
  store %struct.btf* %88, %struct.btf** %btf63, align 8
  %93 = load i32, i32* %type, align 4
  %94 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %95 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %94, i32 0, i32 0
  %btf_var64 = bitcast %union.anon.210* %95 to %struct.anon.212*
  %96 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %btf_var64, i32 0, i32 1
  %97 = bitcast %union.anon.213* %96 to %struct.anon.214*
  %btf_id65 = getelementptr inbounds %struct.anon.214, %struct.anon.214* %97, i32 0, i32 1
  store i32 %93, i32* %btf_id65, align 8
  br label %if.end66

if.end66:                                         ; preds = %if.else59, %if.end55
  br label %if.end67

if.end67:                                         ; preds = %if.end66, %if.then42
  store i32 0, i32* %i, align 4
  br label %for.cond68

for.cond68:                                       ; preds = %for.inc78, %if.end67
  %98 = load i32, i32* %i, align 4
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btf_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %99, i32 0, i32 14
  %100 = load i32, i32* %used_btf_cnt, align 4
  %cmp69 = icmp ult i32 %98, %100
  br i1 %cmp69, label %for.body71, label %for.end80

for.body71:                                       ; preds = %for.cond68
  %101 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btfs = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %101, i32 0, i32 12
  %102 = load i32, i32* %i, align 4
  %idxprom = sext i32 %102 to i64
  %arrayidx72 = getelementptr [64 x %struct.btf_mod_pair], [64 x %struct.btf_mod_pair]* %used_btfs, i64 0, i64 %idxprom
  %btf73 = getelementptr inbounds %struct.btf_mod_pair, %struct.btf_mod_pair* %arrayidx72, i32 0, i32 0
  %103 = load %struct.btf*, %struct.btf** %btf73, align 8
  %104 = load %struct.btf*, %struct.btf** %btf, align 8
  %cmp74 = icmp eq %struct.btf* %103, %104
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %for.body71
  %105 = load %struct.btf*, %struct.btf** %btf, align 8
  call void @btf_put(%struct.btf* noundef %105) #20
  store i32 0, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %for.body71
  br label %for.inc78

for.inc78:                                        ; preds = %if.end77
  %106 = load i32, i32* %i, align 4
  %inc79 = add i32 %106, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond68, !llvm.loop !86

for.end80:                                        ; preds = %for.cond68
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btf_cnt81 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %107, i32 0, i32 14
  %108 = load i32, i32* %used_btf_cnt81, align 4
  %cmp82 = icmp uge i32 %108, 64
  br i1 %cmp82, label %if.then84, label %if.end85

if.then84:                                        ; preds = %for.end80
  store i32 -7, i32* %err, align 4
  br label %err_put

if.end85:                                         ; preds = %for.end80
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btfs86 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %109, i32 0, i32 12
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btf_cnt87 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %110, i32 0, i32 14
  %111 = load i32, i32* %used_btf_cnt87, align 4
  %idxprom88 = zext i32 %111 to i64
  %arrayidx89 = getelementptr [64 x %struct.btf_mod_pair], [64 x %struct.btf_mod_pair]* %used_btfs86, i64 0, i64 %idxprom88
  store %struct.btf_mod_pair* %arrayidx89, %struct.btf_mod_pair** %btf_mod, align 8
  %112 = load %struct.btf*, %struct.btf** %btf, align 8
  %113 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %btf_mod, align 8
  %btf90 = getelementptr inbounds %struct.btf_mod_pair, %struct.btf_mod_pair* %113, i32 0, i32 0
  store %struct.btf* %112, %struct.btf** %btf90, align 8
  %114 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %btf_mod, align 8
  %module = getelementptr inbounds %struct.btf_mod_pair, %struct.btf_mod_pair* %114, i32 0, i32 1
  store %struct.module* null, %struct.module** %module, align 8
  %115 = load %struct.btf*, %struct.btf** %btf, align 8
  %call91 = call zeroext i1 @btf_is_module(%struct.btf* noundef %115) #20
  br i1 %call91, label %if.then92, label %if.end99

if.then92:                                        ; preds = %if.end85
  %116 = load %struct.btf*, %struct.btf** %btf, align 8
  %call93 = call %struct.module* @btf_try_get_module(%struct.btf* noundef %116) #20
  %117 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %btf_mod, align 8
  %module94 = getelementptr inbounds %struct.btf_mod_pair, %struct.btf_mod_pair* %117, i32 0, i32 1
  store %struct.module* %call93, %struct.module** %module94, align 8
  %118 = load %struct.btf_mod_pair*, %struct.btf_mod_pair** %btf_mod, align 8
  %module95 = getelementptr inbounds %struct.btf_mod_pair, %struct.btf_mod_pair* %118, i32 0, i32 1
  %119 = load %struct.module*, %struct.module** %module95, align 8
  %tobool96 = icmp ne %struct.module* %119, null
  br i1 %tobool96, label %if.end98, label %if.then97

if.then97:                                        ; preds = %if.then92
  store i32 -6, i32* %err, align 4
  br label %err_put

if.end98:                                         ; preds = %if.then92
  br label %if.end99

if.end99:                                         ; preds = %if.end98, %if.end85
  %120 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_btf_cnt100 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %120, i32 0, i32 14
  %121 = load i32, i32* %used_btf_cnt100, align 4
  %inc101 = add i32 %121, 1
  store i32 %inc101, i32* %used_btf_cnt100, align 4
  store i32 0, i32* %retval, align 4
  br label %return

err_put:                                          ; preds = %if.then97, %if.then84, %if.then51, %if.then18, %if.then13, %if.then10
  %122 = load %struct.btf*, %struct.btf** %btf, align 8
  call void @btf_put(%struct.btf* noundef %122) #20
  %123 = load i32, i32* %err, align 4
  store i32 %123, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_put, %if.end99, %if.then76, %if.then5, %if.then3
  %124 = load i32, i32* %retval, align 4
  ret i32 %124
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { %struct.file*, i32 } @fdget(i32 noundef %fd) #0 {
entry:
  %retval = alloca %struct.fd, align 8
  %fd.addr = alloca i32, align 4
  store i32 %fd, i32* %fd.addr, align 4
  %0 = load i32, i32* %fd.addr, align 4
  %call = call i64 @__fdget(i32 noundef %0) #20
  %call1 = call { %struct.file*, i32 } @__to_fd(i64 noundef %call) #20
  %1 = bitcast %struct.fd* %retval to { %struct.file*, i32 }*
  %2 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %1, i32 0, i32 0
  %3 = extractvalue { %struct.file*, i32 } %call1, 0
  store %struct.file* %3, %struct.file** %2, align 8
  %4 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %1, i32 0, i32 1
  %5 = extractvalue { %struct.file*, i32 } %call1, 1
  store i32 %5, i32* %4, align 8
  %6 = bitcast %struct.fd* %retval to { %struct.file*, i32 }*
  %7 = load { %struct.file*, i32 }, { %struct.file*, i32 }* %6, align 8
  ret { %struct.file*, i32 } %7
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_map* @__bpf_map_get(%struct.file*, i32) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_prog_compatibility(%struct.bpf_verifier_env* noundef %env, %struct.bpf_map* noundef %map, %struct.bpf_prog* noundef %prog) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %prog_type = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %0) #20
  store i32 %call, i32* %prog_type, align 4
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call1 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %1) #20
  br i1 %call1, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %prog_type, align 4
  %cmp = icmp eq i32 %2, 1
  br i1 %cmp, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = bitcast %struct.bpf_verifier_env* %3 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %4, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.277, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %5 = load i32, i32* %prog_type, align 4
  %call3 = call zeroext i1 @is_tracing_prog_type(i32 noundef %5) #20
  br i1 %call3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.278, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %8 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %8, i32 0, i32 10
  %9 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %sleepable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %9, i32 0, i32 25
  %10 = load i8, i8* %sleepable, align 4
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end5
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.279, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end5
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %entry
  %13 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call9 = call zeroext i1 @map_value_has_timer(%struct.bpf_map* noundef %13) #20
  br i1 %call9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end8
  %14 = load i32, i32* %prog_type, align 4
  %call11 = call zeroext i1 @is_tracing_prog_type(i32 noundef %14) #20
  br i1 %call11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.then10
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = bitcast %struct.bpf_verifier_env* %15 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %16, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.280, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.then10
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %if.end8
  %17 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux15 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %17, i32 0, i32 10
  %18 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux15, align 8
  %call16 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %18) #20
  br i1 %call16, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end14
  %19 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call17 = call zeroext i1 @bpf_map_is_dev_bound(%struct.bpf_map* noundef %19) #20
  br i1 %call17, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.end14
  %20 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %21 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call18 = call zeroext i1 @bpf_offload_prog_map_match(%struct.bpf_prog* noundef %20, %struct.bpf_map* noundef %21) #20
  br i1 %call18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %land.lhs.true
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.281, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %land.lhs.true, %lor.lhs.false
  %24 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %24, i32 0, i32 3
  %25 = load i32, i32* %map_type, align 8
  %cmp21 = icmp eq i32 %25, 26
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end20
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.282, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %if.end20
  %28 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux24 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %28, i32 0, i32 10
  %29 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux24, align 8
  %sleepable25 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %29, i32 0, i32 25
  %30 = load i8, i8* %sleepable25, align 4
  %tobool26 = trunc i8 %30 to i1
  br i1 %tobool26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %if.end23
  %31 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type28 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %31, i32 0, i32 3
  %32 = load i32, i32* %map_type28, align 8
  switch i32 %32, label %sw.default [
    i32 1, label %sw.bb
    i32 9, label %sw.bb
    i32 2, label %sw.bb
    i32 5, label %sw.bb
    i32 6, label %sw.bb
    i32 10, label %sw.bb
    i32 12, label %sw.bb
    i32 13, label %sw.bb
    i32 27, label %sw.bb
    i32 31, label %sw.bb
    i32 28, label %sw.bb
    i32 24, label %sw.bb
    i32 29, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.then27, %if.then27, %if.then27, %if.then27, %if.then27, %if.then27, %if.then27, %if.then27, %if.then27, %if.then27, %if.then27, %if.then27, %if.then27
  br label %sw.epilog

sw.default:                                       ; preds = %if.then27
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.283, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb
  br label %if.end29

if.end29:                                         ; preds = %sw.epilog, %if.end23
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end29, %sw.default, %if.then22, %if.then19, %if.then12, %if.then6, %if.then4, %if.then2
  %35 = load i32, i32* %retval, align 4
  ret i32 %35
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @fdput(%struct.file* %fd.coerce0, i32 %fd.coerce1) #0 {
entry:
  %fd = alloca %struct.fd, align 8
  %0 = bitcast %struct.fd* %fd to { %struct.file*, i32 }*
  %1 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %0, i32 0, i32 0
  store %struct.file* %fd.coerce0, %struct.file** %1, align 8
  %2 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %0, i32 0, i32 1
  store i32 %fd.coerce1, i32* %2, align 8
  %flags = getelementptr inbounds %struct.fd, %struct.fd* %fd, i32 0, i32 1
  %3 = load i32, i32* %flags, align 8
  %and = and i32 %3, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %file = getelementptr inbounds %struct.fd, %struct.fd* %fd, i32 0, i32 0
  %4 = load %struct.file*, %struct.file** %file, align 8
  call void @fput(%struct.file* noundef %4) #20
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_map_inc(%struct.bpf_map* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_is_cgroup_storage(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 3
  %1 = load i32, i32* %map_type, align 8
  %cmp = icmp eq i32 %1, 19
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %2, i32 0, i32 3
  %3 = load i32, i32* %map_type1, align 8
  %cmp2 = icmp eq i32 %3, 21
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_cgroup_storage_assign(%struct.bpf_prog_aux* noundef %aux, %struct.bpf_map* noundef %map) #0 {
entry:
  %aux.addr = alloca %struct.bpf_prog_aux*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_prog_aux* %aux, %struct.bpf_prog_aux** %aux.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  ret i32 0
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_opcode_in_insntable(i8 noundef zeroext) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @btf_get(%struct.btf* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_var(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 14
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @find_btf_percpu_datasec(%struct.btf* noundef %btf) #0 {
entry:
  %retval = alloca i32, align 4
  %btf.addr = alloca %struct.btf*, align 8
  %t = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.btf* %btf, %struct.btf** %btf.addr, align 8
  %0 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %call = call i32 @btf_nr_types(%struct.btf* noundef %0) #20
  store i32 %call, i32* %n, align 4
  %1 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %call1 = call zeroext i1 @btf_is_module(%struct.btf* noundef %1) #20
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %call2 = call i32 @btf_nr_types(%struct.btf* noundef %2) #20
  store i32 %call2, i32* %i, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 1, i32* %i, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %i, align 4
  %4 = load i32, i32* %n, align 4
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %6 = load i32, i32* %i, align 4
  %call3 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %5, i32 noundef %6) #20
  store %struct.btf_type* %call3, %struct.btf_type** %t, align 8
  %7 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %7, i32 0, i32 1
  %8 = load i32, i32* %info, align 4
  %shr = lshr i32 %8, 24
  %and = and i32 %shr, 31
  %cmp4 = icmp ne i32 %and, 15
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %for.body
  br label %for.inc

if.end6:                                          ; preds = %for.body
  %9 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %10 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %10, i32 0, i32 0
  %11 = load i32, i32* %name_off, align 4
  %call7 = call i8* @btf_name_by_offset(%struct.btf* noundef %9, i32 noundef %11) #20
  store i8* %call7, i8** %tname, align 8
  %12 = load i8*, i8** %tname, align 8
  %call8 = call i32 @strcmp(i8* noundef %12, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.276, i64 0, i64 0)) #20
  %tobool = icmp ne i32 %call8, 0
  br i1 %tobool, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end6
  %13 = load i32, i32* %i, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  br label %for.inc

for.inc:                                          ; preds = %if.end10, %if.then5
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !87

for.end:                                          ; preds = %for.cond
  store i32 -2, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then9
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.btf_var_secinfo* @btf_type_var_secinfo(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %add.ptr = getelementptr %struct.btf_type, %struct.btf_type* %0, i64 1
  %1 = bitcast %struct.btf_type* %add.ptr to %struct.btf_var_secinfo*
  ret %struct.btf_var_secinfo* %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_struct(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  %kind = alloca i8, align 1
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %conv = trunc i32 %and to i8
  store i8 %conv, i8* %kind, align 1
  %2 = load i8, i8* %kind, align 1
  %conv1 = zext i8 %2 to i32
  %cmp = icmp eq i32 %conv1, 4
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %3 = load i8, i8* %kind, align 1
  %conv3 = zext i8 %3 to i32
  %cmp4 = icmp eq i32 %conv3, 5
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp4, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_resolve_size(%struct.btf* noundef, %struct.btf_type* noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_nr_types(%struct.btf* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @strcmp(i8* noundef, i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { %struct.file*, i32 } @__to_fd(i64 noundef %v) #0 {
entry:
  %retval = alloca %struct.fd, align 8
  %v.addr = alloca i64, align 8
  store i64 %v, i64* %v.addr, align 8
  %file = getelementptr inbounds %struct.fd, %struct.fd* %retval, i32 0, i32 0
  %0 = load i64, i64* %v.addr, align 8
  %and = and i64 %0, -4
  %1 = inttoptr i64 %and to %struct.file*
  store %struct.file* %1, %struct.file** %file, align 8
  %flags = getelementptr inbounds %struct.fd, %struct.fd* %retval, i32 0, i32 1
  %2 = load i64, i64* %v.addr, align 8
  %and1 = and i64 %2, 3
  %conv = trunc i64 %and1 to i32
  store i32 %conv, i32* %flags, align 8
  %3 = bitcast %struct.fd* %retval to { %struct.file*, i32 }*
  %4 = load { %struct.file*, i32 }, { %struct.file*, i32 }* %3, align 8
  ret { %struct.file*, i32 } %4
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @__fdget(i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_tracing_prog_type(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 2, label %sw.bb
    i32 5, label %sw.bb
    i32 7, label %sw.bb
    i32 17, label %sw.bb
    i32 24, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_is_dev_bound(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 0
  %1 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %cmp = icmp eq %struct.bpf_map_ops* %1, @bpf_map_offload_ops
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  ret i1 %tobool
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_offload_prog_map_match(%struct.bpf_prog* noundef, %struct.bpf_map* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @fput(%struct.file* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @visit_insn(i32 noundef %t, i32 noundef %insn_cnt, %struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %insn_cnt.addr = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insns = alloca %struct.bpf_insn*, align 8
  %ret = alloca i32, align 4
  store i32 %t, i32* %t.addr, align 4
  store i32 %insn_cnt, i32* %insn_cnt.addr, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 12
  %3 = bitcast %union.anon.198* %2 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insns, align 8
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %5 = load i32, i32* %t.addr, align 4
  %idx.ext = sext i32 %5 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %4, i64 %idx.ext
  %call = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %add.ptr) #20
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, i32* %t.addr, align 4
  %7 = load i32, i32* %insn_cnt.addr, align 4
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call1 = call i32 @visit_func_call_insn(i32 noundef %6, i32 noundef %7, %struct.bpf_insn* noundef %8, %struct.bpf_verifier_env* noundef %9, i1 noundef zeroext true) #20
  store i32 %call1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %11 = load i32, i32* %t.addr, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %10, i64 %idxprom
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 0
  %12 = load i8, i8* %code, align 4
  %conv = zext i8 %12 to i32
  %and = and i32 %conv, 7
  %cmp = icmp ne i32 %and, 5
  br i1 %cmp, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %if.end
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %14 = load i32, i32* %t.addr, align 4
  %idxprom3 = sext i32 %14 to i64
  %arrayidx4 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %13, i64 %idxprom3
  %code5 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx4, i32 0, i32 0
  %15 = load i8, i8* %code5, align 4
  %conv6 = zext i8 %15 to i32
  %and7 = and i32 %conv6, 7
  %cmp8 = icmp ne i32 %and7, 6
  br i1 %cmp8, label %if.then10, label %if.end12

if.then10:                                        ; preds = %land.lhs.true
  %16 = load i32, i32* %t.addr, align 4
  %17 = load i32, i32* %t.addr, align 4
  %add = add i32 %17, 1
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call11 = call i32 @push_insn(i32 noundef %16, i32 noundef %add, i32 noundef 1, %struct.bpf_verifier_env* noundef %18, i1 noundef zeroext false) #20
  store i32 %call11, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %land.lhs.true, %if.end
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %20 = load i32, i32* %t.addr, align 4
  %idxprom13 = sext i32 %20 to i64
  %arrayidx14 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %19, i64 %idxprom13
  %code15 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx14, i32 0, i32 0
  %21 = load i8, i8* %code15, align 4
  %conv16 = zext i8 %21 to i32
  %and17 = and i32 %conv16, 240
  switch i32 %and17, label %sw.default [
    i32 144, label %sw.bb
    i32 128, label %sw.bb18
    i32 0, label %sw.bb31
  ]

sw.bb:                                            ; preds = %if.end12
  store i32 0, i32* %retval, align 4
  br label %return

sw.bb18:                                          ; preds = %if.end12
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %23 = load i32, i32* %t.addr, align 4
  %idxprom19 = sext i32 %23 to i64
  %arrayidx20 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %22, i64 %idxprom19
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx20, i32 0, i32 3
  %24 = load i32, i32* %imm, align 4
  %cmp21 = icmp eq i32 %24, 170
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %sw.bb18
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load i32, i32* %t.addr, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %25, i32 noundef %26) #20
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %sw.bb18
  %27 = load i32, i32* %t.addr, align 4
  %28 = load i32, i32* %insn_cnt.addr, align 4
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %32 = load i32, i32* %t.addr, align 4
  %idxprom25 = sext i32 %32 to i64
  %arrayidx26 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %31, i64 %idxprom25
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx26, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv27 = zext i8 %bf.lshr to i32
  %cmp28 = icmp eq i32 %conv27, 1
  %call30 = call i32 @visit_func_call_insn(i32 noundef %27, i32 noundef %28, %struct.bpf_insn* noundef %29, %struct.bpf_verifier_env* noundef %30, i1 noundef zeroext %cmp28) #20
  store i32 %call30, i32* %retval, align 4
  br label %return

sw.bb31:                                          ; preds = %if.end12
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %34 = load i32, i32* %t.addr, align 4
  %idxprom32 = sext i32 %34 to i64
  %arrayidx33 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %33, i64 %idxprom32
  %code34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx33, i32 0, i32 0
  %35 = load i8, i8* %code34, align 4
  %conv35 = zext i8 %35 to i32
  %and36 = and i32 %conv35, 8
  %cmp37 = icmp ne i32 %and36, 0
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %sw.bb31
  store i32 -22, i32* %retval, align 4
  br label %return

if.end40:                                         ; preds = %sw.bb31
  %36 = load i32, i32* %t.addr, align 4
  %37 = load i32, i32* %t.addr, align 4
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %39 = load i32, i32* %t.addr, align 4
  %idxprom41 = sext i32 %39 to i64
  %arrayidx42 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %38, i64 %idxprom41
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx42, i32 0, i32 2
  %40 = load i16, i16* %off, align 2
  %conv43 = sext i16 %40 to i32
  %add44 = add i32 %37, %conv43
  %add45 = add i32 %add44, 1
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call46 = call i32 @push_insn(i32 noundef %36, i32 noundef %add45, i32 noundef 1, %struct.bpf_verifier_env* noundef %41, i1 noundef zeroext true) #20
  store i32 %call46, i32* %ret, align 4
  %42 = load i32, i32* %ret, align 4
  %tobool = icmp ne i32 %42, 0
  br i1 %tobool, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end40
  %43 = load i32, i32* %ret, align 4
  store i32 %43, i32* %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.end40
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load i32, i32* %t.addr, align 4
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %47 = load i32, i32* %t.addr, align 4
  %idxprom49 = sext i32 %47 to i64
  %arrayidx50 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %46, i64 %idxprom49
  %off51 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx50, i32 0, i32 2
  %48 = load i16, i16* %off51, align 2
  %conv52 = sext i16 %48 to i32
  %add53 = add i32 %45, %conv52
  %add54 = add i32 %add53, 1
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %44, i32 noundef %add54) #20
  %49 = load i32, i32* %t.addr, align 4
  %add55 = add i32 %49, 1
  %50 = load i32, i32* %insn_cnt.addr, align 4
  %cmp56 = icmp slt i32 %add55, %50
  br i1 %cmp56, label %if.then58, label %if.end60

if.then58:                                        ; preds = %if.end48
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = load i32, i32* %t.addr, align 4
  %add59 = add i32 %52, 1
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %51, i32 noundef %add59) #20
  br label %if.end60

if.end60:                                         ; preds = %if.then58, %if.end48
  %53 = load i32, i32* %ret, align 4
  store i32 %53, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end12
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = load i32, i32* %t.addr, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %54, i32 noundef %55) #20
  %56 = load i32, i32* %t.addr, align 4
  %57 = load i32, i32* %t.addr, align 4
  %add61 = add i32 %57, 1
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call62 = call i32 @push_insn(i32 noundef %56, i32 noundef %add61, i32 noundef 1, %struct.bpf_verifier_env* noundef %58, i1 noundef zeroext true) #20
  store i32 %call62, i32* %ret, align 4
  %59 = load i32, i32* %ret, align 4
  %tobool63 = icmp ne i32 %59, 0
  br i1 %tobool63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %sw.default
  %60 = load i32, i32* %ret, align 4
  store i32 %60, i32* %retval, align 4
  br label %return

if.end65:                                         ; preds = %sw.default
  %61 = load i32, i32* %t.addr, align 4
  %62 = load i32, i32* %t.addr, align 4
  %63 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %64 = load i32, i32* %t.addr, align 4
  %idxprom66 = sext i32 %64 to i64
  %arrayidx67 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %63, i64 %idxprom66
  %off68 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx67, i32 0, i32 2
  %65 = load i16, i16* %off68, align 2
  %conv69 = sext i16 %65 to i32
  %add70 = add i32 %62, %conv69
  %add71 = add i32 %add70, 1
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call72 = call i32 @push_insn(i32 noundef %61, i32 noundef %add71, i32 noundef 2, %struct.bpf_verifier_env* noundef %66, i1 noundef zeroext true) #20
  store i32 %call72, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end65, %if.then64, %if.end60, %if.then47, %if.then39, %if.end24, %sw.bb, %if.then10, %if.then
  %67 = load i32, i32* %retval, align 4
  ret i32 %67
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @visit_func_call_insn(i32 noundef %t, i32 noundef %insn_cnt, %struct.bpf_insn* noundef %insns, %struct.bpf_verifier_env* noundef %env, i1 noundef zeroext %visit_callee) #0 {
entry:
  %retval = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %insn_cnt.addr = alloca i32, align 4
  %insns.addr = alloca %struct.bpf_insn*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %visit_callee.addr = alloca i8, align 1
  %ret = alloca i32, align 4
  store i32 %t, i32* %t.addr, align 4
  store i32 %insn_cnt, i32* %insn_cnt.addr, align 4
  store %struct.bpf_insn* %insns, %struct.bpf_insn** %insns.addr, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %frombool = zext i1 %visit_callee to i8
  store i8 %frombool, i8* %visit_callee.addr, align 1
  %0 = load i32, i32* %t.addr, align 4
  %1 = load i32, i32* %t.addr, align 4
  %add = add i32 %1, 1
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @push_insn(i32 noundef %0, i32 noundef %add, i32 noundef 1, %struct.bpf_verifier_env* noundef %2, i1 noundef zeroext false) #20
  store i32 %call, i32* %ret, align 4
  %3 = load i32, i32* %ret, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %ret, align 4
  store i32 %4, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, i32* %t.addr, align 4
  %add1 = add i32 %5, 1
  %6 = load i32, i32* %insn_cnt.addr, align 4
  %cmp = icmp slt i32 %add1, %6
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = load i32, i32* %t.addr, align 4
  %add3 = add i32 %8, 1
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %7, i32 noundef %add3) #20
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %9 = load i8, i8* %visit_callee.addr, align 1
  %tobool5 = trunc i8 %9 to i1
  br i1 %tobool5, label %if.then6, label %if.end11

if.then6:                                         ; preds = %if.end4
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load i32, i32* %t.addr, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %10, i32 noundef %11) #20
  %12 = load i32, i32* %t.addr, align 4
  %13 = load i32, i32* %t.addr, align 4
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insns.addr, align 8
  %15 = load i32, i32* %t.addr, align 4
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %14, i64 %idxprom
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 3
  %16 = load i32, i32* %imm, align 4
  %add7 = add i32 %13, %16
  %add8 = add i32 %add7, 1
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insns.addr, align 8
  %19 = load i32, i32* %t.addr, align 4
  %idx.ext = sext i32 %19 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %18, i64 %idx.ext
  %call9 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %add.ptr) #20
  %call10 = call i32 @push_insn(i32 noundef %12, i32 noundef %add8, i32 noundef 2, %struct.bpf_verifier_env* noundef %17, i1 noundef zeroext %call9) #20
  store i32 %call10, i32* %ret, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then6, %if.end4
  %20 = load i32, i32* %ret, align 4
  store i32 %20, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then
  %21 = load i32, i32* %retval, align 4
  ret i32 %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @push_insn(i32 noundef %t, i32 noundef %w, i32 noundef %e, %struct.bpf_verifier_env* noundef %env, i1 noundef zeroext %loop_ok) #0 {
entry:
  %retval = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %e.addr = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %loop_ok.addr = alloca i8, align 1
  %insn_stack = alloca i32*, align 8
  %insn_state = alloca i32*, align 8
  store i32 %t, i32* %t.addr, align 4
  store i32 %w, i32* %w.addr, align 4
  store i32 %e, i32* %e.addr, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %frombool = zext i1 %loop_ok to i8
  store i8 %frombool, i8* %loop_ok.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 29
  %insn_stack1 = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg, i32 0, i32 1
  %1 = load i32*, i32** %insn_stack1, align 8
  store i32* %1, i32** %insn_stack, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 29
  %insn_state3 = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg2, i32 0, i32 0
  %3 = load i32*, i32** %insn_state3, align 8
  store i32* %3, i32** %insn_state, align 8
  %4 = load i32, i32* %e.addr, align 4
  %cmp = icmp eq i32 %4, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load i32*, i32** %insn_state, align 8
  %6 = load i32, i32* %t.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr i32, i32* %5, i64 %idxprom
  %7 = load i32, i32* %arrayidx, align 4
  %cmp4 = icmp sge i32 %7, 17
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %8 = load i32, i32* %e.addr, align 4
  %cmp5 = icmp eq i32 %8, 2
  br i1 %cmp5, label %land.lhs.true6, label %if.end11

land.lhs.true6:                                   ; preds = %if.end
  %9 = load i32*, i32** %insn_state, align 8
  %10 = load i32, i32* %t.addr, align 4
  %idxprom7 = sext i32 %10 to i64
  %arrayidx8 = getelementptr i32, i32* %9, i64 %idxprom7
  %11 = load i32, i32* %arrayidx8, align 4
  %cmp9 = icmp sge i32 %11, 18
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %land.lhs.true6
  store i32 0, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %land.lhs.true6, %if.end
  %12 = load i32, i32* %w.addr, align 4
  %cmp12 = icmp slt i32 %12, 0
  br i1 %cmp12, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end11
  %13 = load i32, i32* %w.addr, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 2
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %15, i32 0, i32 4
  %16 = load i32, i32* %len, align 4
  %cmp13 = icmp uge i32 %13, %16
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %lor.lhs.false, %if.end11
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %t.addr, align 4
  %19 = load i32, i32* %t.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %17, i32 noundef %18, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.37, i64 0, i64 0), i32 noundef %19) #20
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  %22 = load i32, i32* %t.addr, align 4
  %23 = load i32, i32* %w.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.232, i64 0, i64 0), i32 noundef %22, i32 noundef %23) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %lor.lhs.false
  %24 = load i32, i32* %e.addr, align 4
  %cmp16 = icmp eq i32 %24, 2
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end15
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load i32, i32* %w.addr, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %25, i32 noundef %26) #20
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end15
  %27 = load i32*, i32** %insn_state, align 8
  %28 = load i32, i32* %w.addr, align 4
  %idxprom19 = sext i32 %28 to i64
  %arrayidx20 = getelementptr i32, i32* %27, i64 %idxprom19
  %29 = load i32, i32* %arrayidx20, align 4
  %cmp21 = icmp eq i32 %29, 0
  br i1 %cmp21, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.end18
  %30 = load i32, i32* %e.addr, align 4
  %or = or i32 16, %30
  %31 = load i32*, i32** %insn_state, align 8
  %32 = load i32, i32* %t.addr, align 4
  %idxprom23 = sext i32 %32 to i64
  %arrayidx24 = getelementptr i32, i32* %31, i64 %idxprom23
  store i32 %or, i32* %arrayidx24, align 4
  %33 = load i32*, i32** %insn_state, align 8
  %34 = load i32, i32* %w.addr, align 4
  %idxprom25 = sext i32 %34 to i64
  %arrayidx26 = getelementptr i32, i32* %33, i64 %idxprom25
  store i32 16, i32* %arrayidx26, align 4
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 29
  %cur_stack = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg27, i32 0, i32 2
  %36 = load i32, i32* %cur_stack, align 8
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog28 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %37, i32 0, i32 2
  %38 = load %struct.bpf_prog*, %struct.bpf_prog** %prog28, align 8
  %len29 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %38, i32 0, i32 4
  %39 = load i32, i32* %len29, align 4
  %cmp30 = icmp uge i32 %36, %39
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.then22
  store i32 -7, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.then22
  %40 = load i32, i32* %w.addr, align 4
  %41 = load i32*, i32** %insn_stack, align 8
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg33 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %42, i32 0, i32 29
  %cur_stack34 = getelementptr inbounds %struct.anon.215, %struct.anon.215* %cfg33, i32 0, i32 2
  %43 = load i32, i32* %cur_stack34, align 8
  %inc = add i32 %43, 1
  store i32 %inc, i32* %cur_stack34, align 8
  %idxprom35 = sext i32 %43 to i64
  %arrayidx36 = getelementptr i32, i32* %41, i64 %idxprom35
  store i32 %40, i32* %arrayidx36, align 4
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end18
  %44 = load i32*, i32** %insn_state, align 8
  %45 = load i32, i32* %w.addr, align 4
  %idxprom37 = sext i32 %45 to i64
  %arrayidx38 = getelementptr i32, i32* %44, i64 %idxprom37
  %46 = load i32, i32* %arrayidx38, align 4
  %and = and i32 %46, 240
  %cmp39 = icmp eq i32 %and, 16
  br i1 %cmp39, label %if.then40, label %if.else45

if.then40:                                        ; preds = %if.else
  %47 = load i8, i8* %loop_ok.addr, align 1
  %tobool = trunc i8 %47 to i1
  br i1 %tobool, label %land.lhs.true41, label %if.end44

land.lhs.true41:                                  ; preds = %if.then40
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %48, i32 0, i32 20
  %49 = load i8, i8* %bpf_capable, align 8
  %tobool42 = trunc i8 %49 to i1
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %land.lhs.true41
  store i32 0, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %land.lhs.true41, %if.then40
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = load i32, i32* %t.addr, align 4
  %52 = load i32, i32* %t.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %50, i32 noundef %51, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.37, i64 0, i64 0), i32 noundef %52) #20
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = load i32, i32* %w.addr, align 4
  %55 = load i32, i32* %w.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %53, i32 noundef %54, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.37, i64 0, i64 0), i32 noundef %55) #20
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = bitcast %struct.bpf_verifier_env* %56 to i8*
  %58 = load i32, i32* %t.addr, align 4
  %59 = load i32, i32* %w.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %57, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.287, i64 0, i64 0), i32 noundef %58, i32 noundef %59) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.else45:                                        ; preds = %if.else
  %60 = load i32*, i32** %insn_state, align 8
  %61 = load i32, i32* %w.addr, align 4
  %idxprom46 = sext i32 %61 to i64
  %arrayidx47 = getelementptr i32, i32* %60, i64 %idxprom46
  %62 = load i32, i32* %arrayidx47, align 4
  %cmp48 = icmp eq i32 %62, 32
  br i1 %cmp48, label %if.then49, label %if.else53

if.then49:                                        ; preds = %if.else45
  %63 = load i32, i32* %e.addr, align 4
  %or50 = or i32 16, %63
  %64 = load i32*, i32** %insn_state, align 8
  %65 = load i32, i32* %t.addr, align 4
  %idxprom51 = sext i32 %65 to i64
  %arrayidx52 = getelementptr i32, i32* %64, i64 %idxprom51
  store i32 %or50, i32* %arrayidx52, align 4
  br label %if.end54

if.else53:                                        ; preds = %if.else45
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = bitcast %struct.bpf_verifier_env* %66 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %67, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.288, i64 0, i64 0)) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.then49
  br label %if.end55

if.end55:                                         ; preds = %if.end54
  br label %if.end56

if.end56:                                         ; preds = %if.end55
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end56, %if.else53, %if.end44, %if.then43, %if.end32, %if.then31, %if.then14, %if.then10, %if.then
  %68 = load i32, i32* %retval, align 4
  ret i32 %68
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @init_explored_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %idx.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  %prune_point = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 8
  store i8 1, i8* %prune_point, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check_common(%struct.bpf_verifier_env* noundef %env, i32 noundef %subprog) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %subprog.addr = alloca i32, align 4
  %pop_log = alloca i8, align 1
  %state = alloca %struct.bpf_verifier_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %ret = alloca i32, align 4
  %i = alloca i32, align 4
  %mem_size = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %subprog, i32* %subprog.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %1 = load i32, i32* %level, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %pop_log, align 1
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_linfo = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 25
  store %struct.bpf_line_info* null, %struct.bpf_line_info** %prev_linfo, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %pass_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 30
  %4 = load i32, i32* %pass_cnt, align 8
  %inc = add i32 %4, 1
  store i32 %inc, i32* %pass_cnt, align 8
  %call = call noalias i8* @kzalloc(i64 noundef 120, i32 noundef 3264) #24
  %5 = bitcast i8* %call to %struct.bpf_verifier_state*
  store %struct.bpf_verifier_state* %5, %struct.bpf_verifier_state** %state, align 8
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %tobool1 = icmp ne %struct.bpf_verifier_state* %6, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 4
  store i32 0, i32* %curframe, align 8
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 6
  store i8 0, i8* %speculative, align 8
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %9, i32 0, i32 2
  store i32 1, i32* %branches, align 8
  %call2 = call noalias i8* @kzalloc(i64 noundef 1392, i32 noundef 3264) #24
  %10 = bitcast i8* %call2 to %struct.bpf_func_state*
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 0
  store %struct.bpf_func_state* %10, %struct.bpf_func_state** %arrayidx, align 8
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 0
  %arrayidx4 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame3, i64 0, i64 0
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx4, align 8
  %tobool5 = icmp ne %struct.bpf_func_state* %13, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %15 = bitcast %struct.bpf_verifier_state* %14 to i8*
  call void @kfree(i8* noundef %15) #20
  store i32 -12, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %16 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 8
  store %struct.bpf_verifier_state* %16, %struct.bpf_verifier_state** %cur_state, align 8
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 0
  %arrayidx9 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame8, i64 0, i64 0
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx9, align 8
  %21 = load i32, i32* %subprog.addr, align 4
  call void @init_func_state(%struct.bpf_verifier_env* noundef %18, %struct.bpf_func_state* noundef %20, i32 noundef -1, i32 noundef 0, i32 noundef %21) #20
  %22 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %22, i32 0, i32 0
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe11 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 4
  %24 = load i32, i32* %curframe11, align 8
  %idxprom = zext i32 %24 to i64
  %arrayidx12 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame10, i64 0, i64 %idxprom
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx12, align 8
  %regs13 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs13, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %26 = load i32, i32* %subprog.addr, align 4
  %tobool14 = icmp ne i32 %26, 0
  br i1 %tobool14, label %if.then15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 2
  %28 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %28, i32 0, i32 2
  %29 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %29, 28
  br i1 %cmp, label %if.then15, label %if.else51

if.then15:                                        ; preds = %lor.lhs.false, %if.end7
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load i32, i32* %subprog.addr, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %call16 = call i32 @btf_prepare_func_args(%struct.bpf_verifier_env* noundef %30, i32 noundef %31, %struct.bpf_reg_state* noundef %32) #20
  store i32 %call16, i32* %ret, align 4
  %33 = load i32, i32* %ret, align 4
  %tobool17 = icmp ne i32 %33, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then15
  br label %out

if.end19:                                         ; preds = %if.then15
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %34 = load i32, i32* %i, align 4
  %cmp20 = icmp sle i32 %34, 5
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %36 = load i32, i32* %i, align 4
  %idxprom21 = sext i32 %36 to i64
  %arrayidx22 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i64 %idxprom21
  %type23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx22, i32 0, i32 0
  %37 = load i32, i32* %type23, align 8
  %cmp24 = icmp eq i32 %37, 2
  br i1 %cmp24, label %if.then25, label %if.else

if.then25:                                        ; preds = %for.body
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %40 = load i32, i32* %i, align 4
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %38, %struct.bpf_reg_state* noundef %39, i32 noundef %40) #20
  br label %if.end49

if.else:                                          ; preds = %for.body
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %42 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %42 to i64
  %arrayidx27 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i64 %idxprom26
  %type28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx27, i32 0, i32 0
  %43 = load i32, i32* %type28, align 8
  %cmp29 = icmp eq i32 %43, 1
  br i1 %cmp29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %46 = load i32, i32* %i, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %44, %struct.bpf_reg_state* noundef %45, i32 noundef %46) #20
  br label %if.end48

if.else31:                                        ; preds = %if.else
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %48 = load i32, i32* %i, align 4
  %idxprom32 = sext i32 %48 to i64
  %arrayidx33 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i64 %idxprom32
  %type34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx33, i32 0, i32 0
  %49 = load i32, i32* %type34, align 8
  %call35 = call i32 @base_type(i32 noundef %49) #20
  %cmp36 = icmp eq i32 %call35, 17
  br i1 %cmp36, label %if.then37, label %if.end47

if.then37:                                        ; preds = %if.else31
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %51 = load i32, i32* %i, align 4
  %idxprom38 = sext i32 %51 to i64
  %arrayidx39 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i64 %idxprom38
  %52 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx39, i32 0, i32 2
  %mem_size40 = bitcast %union.anon.168* %52 to i32*
  %53 = load i32, i32* %mem_size40, align 8
  store i32 %53, i32* %mem_size, align 4
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %56 = load i32, i32* %i, align 4
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %54, %struct.bpf_reg_state* noundef %55, i32 noundef %56) #20
  %57 = load i32, i32* %mem_size, align 4
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %59 = load i32, i32* %i, align 4
  %idxprom41 = sext i32 %59 to i64
  %arrayidx42 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %58, i64 %idxprom41
  %60 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx42, i32 0, i32 2
  %mem_size43 = bitcast %union.anon.168* %60 to i32*
  store i32 %57, i32* %mem_size43, align 8
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %61, i32 0, i32 15
  %62 = load i32, i32* %id_gen, align 8
  %inc44 = add i32 %62, 1
  store i32 %inc44, i32* %id_gen, align 8
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %64 = load i32, i32* %i, align 4
  %idxprom45 = sext i32 %64 to i64
  %arrayidx46 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %63, i64 %idxprom45
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx46, i32 0, i32 3
  store i32 %inc44, i32* %id, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.then37, %if.else31
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.then30
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.then25
  br label %for.inc

for.inc:                                          ; preds = %if.end49
  %65 = load i32, i32* %i, align 4
  %inc50 = add i32 %65, 1
  store i32 %inc50, i32* %i, align 4
  br label %for.cond, !llvm.loop !88

for.end:                                          ; preds = %for.cond
  br label %if.end58

if.else51:                                        ; preds = %lor.lhs.false
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx52 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i64 1
  %type53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx52, i32 0, i32 0
  store i32 2, i32* %type53, align 8
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %67, %struct.bpf_reg_state* noundef %68, i32 noundef 1) #20
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = load i32, i32* %subprog.addr, align 4
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %call54 = call i32 @btf_check_subprog_arg_match(%struct.bpf_verifier_env* noundef %69, i32 noundef %70, %struct.bpf_reg_state* noundef %71) #20
  store i32 %call54, i32* %ret, align 4
  %72 = load i32, i32* %ret, align 4
  %cmp55 = icmp eq i32 %72, -14
  br i1 %cmp55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.else51
  br label %out

if.end57:                                         ; preds = %if.else51
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %for.end
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call59 = call i32 @do_check(%struct.bpf_verifier_env* noundef %73) #20
  store i32 %call59, i32* %ret, align 4
  br label %out

out:                                              ; preds = %if.end58, %if.then56, %if.then18
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state60 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %74, i32 0, i32 8
  %75 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state60, align 8
  %tobool61 = icmp ne %struct.bpf_verifier_state* %75, null
  br i1 %tobool61, label %if.then62, label %if.end65

if.then62:                                        ; preds = %out
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state63 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %76, i32 0, i32 8
  %77 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state63, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %77, i1 noundef zeroext true) #20
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state64 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %78, i32 0, i32 8
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %cur_state64, align 8
  br label %if.end65

if.end65:                                         ; preds = %if.then62, %out
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end65
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call66 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %79, i32* noundef null, i32* noundef null, i1 noundef zeroext false) #20
  %tobool67 = icmp ne i32 %call66, 0
  %lnot68 = xor i1 %tobool67, true
  br i1 %lnot68, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond, !llvm.loop !89

while.end:                                        ; preds = %while.cond
  %80 = load i32, i32* %ret, align 4
  %tobool69 = icmp ne i32 %80, 0
  br i1 %tobool69, label %if.end73, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.end
  %81 = load i8, i8* %pop_log, align 1
  %tobool70 = trunc i8 %81 to i1
  br i1 %tobool70, label %if.then71, label %if.end73

if.then71:                                        ; preds = %land.lhs.true
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log72 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %82, i32 0, i32 26
  call void @bpf_vlog_reset(%struct.bpf_verifier_log* noundef %log72, i32 noundef 0) #20
  br label %if.end73

if.end73:                                         ; preds = %if.then71, %land.lhs.true, %while.end
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @free_states(%struct.bpf_verifier_env* noundef %83) #20
  %84 = load i32, i32* %ret, align 4
  store i32 %84, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end73, %if.then6, %if.then
  %85 = load i32, i32* %retval, align 4
  ret i32 %85
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @init_func_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %callsite, i32 noundef %frameno, i32 noundef %subprogno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %callsite.addr = alloca i32, align 4
  %frameno.addr = alloca i32, align 4
  %subprogno.addr = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %callsite, i32* %callsite.addr, align 4
  store i32 %frameno, i32* %frameno.addr, align 4
  store i32 %subprogno, i32* %subprogno.addr, align 4
  %0 = load i32, i32* %callsite.addr, align 4
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %callsite1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 1
  store i32 %0, i32* %callsite1, align 8
  %2 = load i32, i32* %frameno.addr, align 4
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 2
  store i32 %2, i32* %frameno2, align 4
  %4 = load i32, i32* %subprogno.addr, align 4
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %subprogno3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 3
  store i32 %4, i32* %subprogno3, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %callback_ret_range = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 6
  %call = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 0) #20
  %7 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = extractvalue { i64, i64 } %call, 0
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = extractvalue { i64, i64 } %call, 1
  store i64 %11, i64* %10, align 8
  %12 = bitcast %struct.tnum* %callback_ret_range to i8*
  %13 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 8 %13, i64 16, i1 false)
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  call void @init_reg_state(%struct.bpf_verifier_env* noundef %14, %struct.bpf_func_state* noundef %15) #20
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @mark_verifier_state_scratched(%struct.bpf_verifier_env* noundef %16) #20
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_prepare_func_args(%struct.bpf_verifier_env* noundef, i32 noundef, %struct.bpf_reg_state* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_check_subprog_arg_match(%struct.bpf_verifier_env* noundef, i32 noundef, %struct.bpf_reg_state* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %tmp.i569 = alloca i32 ()*, align 8
  %pscr_ret__.i.i = alloca %struct.task_struct*, align 8
  %__vpp_verify.i.i = alloca i8*, align 8
  %pfo_val__.i.i = alloca i64, align 8
  %tmp.i.i = alloca %struct.task_struct*, align 8
  %tmp1.i.i = alloca %struct.task_struct*, align 8
  %pscr_ret__.i = alloca %struct.task_struct*, align 8
  %__vpp_verify.i = alloca i8*, align 8
  %pfo_val__.i = alloca i64, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %tmp1.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %pop_log = alloca i8, align 1
  %state = alloca %struct.bpf_verifier_state*, align 8
  %insns = alloca %struct.bpf_insn*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %insn_cnt = alloca i32, align 4
  %do_print_state = alloca i8, align 1
  %prev_insn_idx = alloca i32, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %class = alloca i8, align 1
  %err = alloca i32, align 4
  %tmp = alloca i32, align 4
  %cbs = alloca %struct.bpf_insn_cbs, align 8
  %prev_src_type = alloca i32*, align 8
  %src_reg_type = alloca i32, align 4
  %prev_dst_type = alloca i32*, align 8
  %dst_reg_type = alloca i32, align 4
  %opcode = alloca i8, align 1
  %mode = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %1 = load i32, i32* %level, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %pop_log, align 1
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 8
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %3, %struct.bpf_verifier_state** %state, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 2
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %6 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 12
  %7 = bitcast %union.anon.198* %6 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %7, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insns, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 2
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %9, i32 0, i32 4
  %10 = load i32, i32* %len, align 4
  store i32 %10, i32* %insn_cnt, align 4
  store i8 0, i8* %do_print_state, align 1
  store i32 -1, i32* %prev_insn_idx, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end566, %if.else514, %if.end497, %if.end442, %if.end172, %entry
  %11 = load i32, i32* %prev_insn_idx, align 4
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 1
  store i32 %11, i32* %prev_insn_idx2, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 0
  %14 = load i32, i32* %insn_idx, align 8
  %15 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp uge i32 %14, %15
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 0
  %19 = load i32, i32* %insn_idx3, align 8
  %20 = load i32, i32* %insn_cnt, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.291, i64 0, i64 0), i32 noundef %19, i32 noundef %20) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.cond
  %21 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 0
  %23 = load i32, i32* %insn_idx4, align 8
  %idxprom = zext i32 %23 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %21, i64 %idxprom
  store %struct.bpf_insn* %arrayidx, %struct.bpf_insn** %insn, align 8
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 0
  %25 = load i8, i8* %code, align 4
  %conv = zext i8 %25 to i32
  %and5 = and i32 %conv, 7
  %conv6 = trunc i32 %and5 to i8
  store i8 %conv6, i8* %class, align 1
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 33
  %27 = load i32, i32* %insn_processed, align 4
  %inc = add i32 %27, 1
  store i32 %inc, i32* %insn_processed, align 4
  %cmp7 = icmp ugt i32 %inc, 1000000
  br i1 %cmp7, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 33
  %31 = load i32, i32* %insn_processed10, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.292, i64 0, i64 0), i32 noundef %31) #20
  store i32 -7, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 0
  %34 = load i32, i32* %insn_idx12, align 8
  %call = call i32 @is_state_visited(%struct.bpf_verifier_env* noundef %32, i32 noundef %34) #20
  store i32 %call, i32* %err, align 4
  %35 = load i32, i32* %err, align 4
  %cmp13 = icmp slt i32 %35, 0
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end11
  %36 = load i32, i32* %err, align 4
  store i32 %36, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end11
  %37 = load i32, i32* %err, align 4
  %cmp17 = icmp eq i32 %37, 1
  br i1 %cmp17, label %if.then19, label %if.end35

if.then19:                                        ; preds = %if.end16
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log20 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %38, i32 0, i32 26
  %level21 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log20, i32 0, i32 0
  %39 = load i32, i32* %level21, align 8
  %and22 = and i32 %39, 3
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end34

if.then24:                                        ; preds = %if.then19
  %40 = load i8, i8* %do_print_state, align 1
  %tobool25 = trunc i8 %40 to i1
  br i1 %tobool25, label %if.then26, label %if.else

if.then26:                                        ; preds = %if.then24
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %43, i32 0, i32 1
  %44 = load i32, i32* %prev_insn_idx27, align 4
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx28 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %45, i32 0, i32 0
  %46 = load i32, i32* %insn_idx28, align 8
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %47, i32 0, i32 8
  %48 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state29, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %48, i32 0, i32 6
  %49 = load i8, i8* %speculative, align 8
  %tobool30 = trunc i8 %49 to i1
  %50 = zext i1 %tobool30 to i64
  %cond = select i1 %tobool30, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.294, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i64 0, i64 0)
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.293, i64 0, i64 0), i32 noundef %44, i32 noundef %46, i8* noundef %cond) #20
  br label %if.end33

if.else:                                          ; preds = %if.then24
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx32 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %53, i32 0, i32 0
  %54 = load i32, i32* %insn_idx32, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.295, i64 0, i64 0), i32 noundef %54) #20
  br label %if.end33

if.end33:                                         ; preds = %if.else, %if.then26
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.then19
  br label %process_bpf_exit

if.end35:                                         ; preds = %if.end16
  store i8* null, i8** %__vpp_verify.i, align 8
  %55 = load i8*, i8** %__vpp_verify.i, align 8
  %56 = call i64 asm "movq %gs:${1:P}, $0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #30, !srcloc !90
  store i64 %56, i64* %pfo_val__.i, align 8
  %57 = load i64, i64* %pfo_val__.i, align 8
  %58 = inttoptr i64 %57 to %struct.task_struct*
  store %struct.task_struct* %58, %struct.task_struct** %tmp.i, align 8
  %59 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  store %struct.task_struct* %59, %struct.task_struct** %pscr_ret__.i, align 8
  %60 = load %struct.task_struct*, %struct.task_struct** %pscr_ret__.i, align 8
  store %struct.task_struct* %60, %struct.task_struct** %tmp1.i, align 8
  %61 = load %struct.task_struct*, %struct.task_struct** %tmp1.i, align 8
  %call37 = call i32 @signal_pending(%struct.task_struct* noundef %61) #20
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end35
  store i32 -11, i32* %retval, align 4
  br label %return

if.end40:                                         ; preds = %if.end35
  store i8* null, i8** %__vpp_verify.i.i, align 8
  %62 = load i8*, i8** %__vpp_verify.i.i, align 8
  %63 = call i64 asm "movq %gs:${1:P}, $0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #30, !srcloc !90
  store i64 %63, i64* %pfo_val__.i.i, align 8
  %64 = load i64, i64* %pfo_val__.i.i, align 8
  %65 = inttoptr i64 %64 to %struct.task_struct*
  store %struct.task_struct* %65, %struct.task_struct** %tmp.i.i, align 8
  %66 = load %struct.task_struct*, %struct.task_struct** %tmp.i.i, align 8
  store %struct.task_struct* %66, %struct.task_struct** %pscr_ret__.i.i, align 8
  %67 = load %struct.task_struct*, %struct.task_struct** %pscr_ret__.i.i, align 8
  store %struct.task_struct* %67, %struct.task_struct** %tmp1.i.i, align 8
  %68 = load %struct.task_struct*, %struct.task_struct** %tmp1.i.i, align 8
  %69 = bitcast %struct.task_struct* %68 to %struct.thread_info*
  %call1.i = call i32 @test_ti_thread_flag(%struct.thread_info* noundef %69, i32 noundef 3) #22
  %tobool.i = icmp ne i32 %call1.i, 0
  %lnot.i = xor i1 %tobool.i, true
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %tobool.i, label %if.then42, label %if.end44

if.then42:                                        ; preds = %if.end40
  call void @__might_resched(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 noundef 14153, i32 noundef 0) #20
  store i32 ()* @__SCT__cond_resched, i32 ()** %tmp.i569, align 8
  %70 = load i32 ()*, i32 ()** %tmp.i569, align 8
  %call.i = call i32 %70() #22
  store i32 %call.i, i32* %tmp, align 4
  %71 = load i32, i32* %tmp, align 4
  br label %if.end44

if.end44:                                         ; preds = %if.then42, %if.end40
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log45 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %72, i32 0, i32 26
  %level46 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log45, i32 0, i32 0
  %73 = load i32, i32* %level46, align 8
  %and47 = and i32 %73, 2
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %land.lhs.true, label %if.end61

land.lhs.true:                                    ; preds = %if.end44
  %74 = load i8, i8* %do_print_state, align 1
  %tobool49 = trunc i8 %74 to i1
  br i1 %tobool49, label %if.then51, label %if.end61

if.then51:                                        ; preds = %land.lhs.true
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = bitcast %struct.bpf_verifier_env* %75 to i8*
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx52 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %77, i32 0, i32 1
  %78 = load i32, i32* %prev_insn_idx52, align 4
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx53 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %79, i32 0, i32 0
  %80 = load i32, i32* %insn_idx53, align 8
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state54 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %81, i32 0, i32 8
  %82 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state54, align 8
  %speculative55 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %82, i32 0, i32 6
  %83 = load i8, i8* %speculative55, align 8
  %tobool56 = trunc i8 %83 to i1
  %84 = zext i1 %tobool56 to i64
  %cond58 = select i1 %tobool56, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.294, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i64 0, i64 0)
  call void (i8*, i8*, ...) @verbose(i8* noundef %76, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.296, i64 0, i64 0), i32 noundef %78, i32 noundef %80, i8* noundef %cond58) #20
  %85 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %86 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %86, i32 0, i32 0
  %87 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %87, i32 0, i32 4
  %88 = load i32, i32* %curframe, align 8
  %idxprom59 = zext i32 %88 to i64
  %arrayidx60 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom59
  %89 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx60, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %85, %struct.bpf_func_state* noundef %89, i1 noundef zeroext true) #20
  store i8 0, i8* %do_print_state, align 1
  br label %if.end61

if.end61:                                         ; preds = %if.then51, %land.lhs.true, %if.end44
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log62 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %90, i32 0, i32 26
  %level63 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log62, i32 0, i32 0
  %91 = load i32, i32* %level63, align 8
  %and64 = and i32 %91, 3
  %tobool65 = icmp ne i32 %and64, 0
  br i1 %tobool65, label %if.then66, label %if.end84

if.then66:                                        ; preds = %if.end61
  %cb_print = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 0
  store void (i8*, i8*, ...)* @verbose, void (i8*, i8*, ...)** %cb_print, align 8
  %cb_call = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 1
  store i8* (i8*, %struct.bpf_insn*)* @disasm_kfunc_name, i8* (i8*, %struct.bpf_insn*)** %cb_call, align 8
  %cb_imm = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 2
  store i8* (i8*, %struct.bpf_insn*, i64)* null, i8* (i8*, %struct.bpf_insn*, i64)** %cb_imm, align 8
  %private_data = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 3
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %93 = bitcast %struct.bpf_verifier_env* %92 to i8*
  store i8* %93, i8** %private_data, align 8
  %94 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call67 = call zeroext i1 @verifier_state_scratched(%struct.bpf_verifier_env* noundef %94) #20
  br i1 %call67, label %if.then68, label %if.end73

if.then68:                                        ; preds = %if.then66
  %95 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %96 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame69 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %96, i32 0, i32 0
  %97 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe70 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %97, i32 0, i32 4
  %98 = load i32, i32* %curframe70, align 8
  %idxprom71 = zext i32 %98 to i64
  %arrayidx72 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame69, i64 0, i64 %idxprom71
  %99 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx72, align 8
  call void @print_insn_state(%struct.bpf_verifier_env* noundef %95, %struct.bpf_func_state* noundef %99) #20
  br label %if.end73

if.end73:                                         ; preds = %if.then68, %if.then66
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %101 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx74 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %101, i32 0, i32 0
  %102 = load i32, i32* %insn_idx74, align 8
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %100, i32 noundef %102, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.155, i64 0, i64 0)) #20
  %103 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log75 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %103, i32 0, i32 26
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log75, i32 0, i32 3
  %104 = load i32, i32* %len_used, align 8
  %105 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_log_len = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %105, i32 0, i32 44
  store i32 %104, i32* %prev_log_len, align 8
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %107 = bitcast %struct.bpf_verifier_env* %106 to i8*
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx76 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %108, i32 0, i32 0
  %109 = load i32, i32* %insn_idx76, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %107, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.37, i64 0, i64 0), i32 noundef %109) #20
  %110 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %111 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %111, i32 0, i32 17
  %112 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool77 = trunc i8 %112 to i1
  call void @print_bpf_insn(%struct.bpf_insn_cbs* noundef %cbs, %struct.bpf_insn* noundef %110, i1 noundef zeroext %tobool77) #20
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log78 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %113, i32 0, i32 26
  %len_used79 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log78, i32 0, i32 3
  %114 = load i32, i32* %len_used79, align 8
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_log_len80 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %115, i32 0, i32 44
  %116 = load i32, i32* %prev_log_len80, align 8
  %sub = sub i32 %114, %116
  %117 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_print_len = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %117, i32 0, i32 45
  store i32 %sub, i32* %prev_insn_print_len, align 4
  %118 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log81 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %118, i32 0, i32 26
  %len_used82 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log81, i32 0, i32 3
  %119 = load i32, i32* %len_used82, align 8
  %120 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_log_len83 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %120, i32 0, i32 44
  store i32 %119, i32* %prev_log_len83, align 8
  br label %if.end84

if.end84:                                         ; preds = %if.end73, %if.end61
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog85 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %121, i32 0, i32 2
  %122 = load %struct.bpf_prog*, %struct.bpf_prog** %prog85, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %122, i32 0, i32 10
  %123 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call86 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %123) #20
  br i1 %call86, label %if.then87, label %if.end94

if.then87:                                        ; preds = %if.end84
  %124 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx88 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %125, i32 0, i32 0
  %126 = load i32, i32* %insn_idx88, align 8
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx89 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %127, i32 0, i32 1
  %128 = load i32, i32* %prev_insn_idx89, align 4
  %call90 = call i32 @bpf_prog_offload_verify_insn(%struct.bpf_verifier_env* noundef %124, i32 noundef %126, i32 noundef %128) #20
  store i32 %call90, i32* %err, align 4
  %129 = load i32, i32* %err, align 4
  %tobool91 = icmp ne i32 %129, 0
  br i1 %tobool91, label %if.then92, label %if.end93

if.then92:                                        ; preds = %if.then87
  %130 = load i32, i32* %err, align 4
  store i32 %130, i32* %retval, align 4
  br label %return

if.end93:                                         ; preds = %if.then87
  br label %if.end94

if.end94:                                         ; preds = %if.end93, %if.end84
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call95 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %131) #20
  store %struct.bpf_reg_state* %call95, %struct.bpf_reg_state** %regs, align 8
  %132 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @sanitize_mark_insn_seen(%struct.bpf_verifier_env* noundef %132) #20
  %133 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx96 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %133, i32 0, i32 0
  %134 = load i32, i32* %insn_idx96, align 8
  store i32 %134, i32* %prev_insn_idx, align 4
  %135 = load i8, i8* %class, align 1
  %conv97 = zext i8 %135 to i32
  %cmp98 = icmp eq i32 %conv97, 4
  br i1 %cmp98, label %if.then103, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end94
  %136 = load i8, i8* %class, align 1
  %conv100 = zext i8 %136 to i32
  %cmp101 = icmp eq i32 %conv100, 7
  br i1 %cmp101, label %if.then103, label %if.else108

if.then103:                                       ; preds = %lor.lhs.false, %if.end94
  %137 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %138 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call104 = call i32 @check_alu_op(%struct.bpf_verifier_env* noundef %137, %struct.bpf_insn* noundef %138) #20
  store i32 %call104, i32* %err, align 4
  %139 = load i32, i32* %err, align 4
  %tobool105 = icmp ne i32 %139, 0
  br i1 %tobool105, label %if.then106, label %if.end107

if.then106:                                       ; preds = %if.then103
  %140 = load i32, i32* %err, align 4
  store i32 %140, i32* %retval, align 4
  br label %return

if.end107:                                        ; preds = %if.then103
  br label %if.end566

if.else108:                                       ; preds = %lor.lhs.false
  %141 = load i8, i8* %class, align 1
  %conv109 = zext i8 %141 to i32
  %cmp110 = icmp eq i32 %conv109, 1
  br i1 %cmp110, label %if.then112, label %if.else157

if.then112:                                       ; preds = %if.else108
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %143 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %143, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv113 = zext i8 %bf.lshr to i32
  %call114 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %142, i32 noundef %conv113, i32 noundef 0) #20
  store i32 %call114, i32* %err, align 4
  %144 = load i32, i32* %err, align 4
  %tobool115 = icmp ne i32 %144, 0
  br i1 %tobool115, label %if.then116, label %if.end117

if.then116:                                       ; preds = %if.then112
  %145 = load i32, i32* %err, align 4
  store i32 %145, i32* %retval, align 4
  br label %return

if.end117:                                        ; preds = %if.then112
  %146 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %147 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %147, i32 0, i32 1
  %bf.load118 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load118, 15
  %conv119 = zext i8 %bf.clear to i32
  %call120 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %146, i32 noundef %conv119, i32 noundef 2) #20
  store i32 %call120, i32* %err, align 4
  %148 = load i32, i32* %err, align 4
  %tobool121 = icmp ne i32 %148, 0
  br i1 %tobool121, label %if.then122, label %if.end123

if.then122:                                       ; preds = %if.end117
  %149 = load i32, i32* %err, align 4
  store i32 %149, i32* %retval, align 4
  br label %return

if.end123:                                        ; preds = %if.end117
  %150 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %151 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg124 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %151, i32 0, i32 1
  %bf.load125 = load i8, i8* %src_reg124, align 1
  %bf.lshr126 = lshr i8 %bf.load125, 4
  %idxprom127 = zext i8 %bf.lshr126 to i64
  %arrayidx128 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %150, i64 %idxprom127
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx128, i32 0, i32 0
  %152 = load i32, i32* %type, align 8
  store i32 %152, i32* %src_reg_type, align 4
  %153 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx129 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %154, i32 0, i32 0
  %155 = load i32, i32* %insn_idx129, align 8
  %156 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg130 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %156, i32 0, i32 1
  %bf.load131 = load i8, i8* %src_reg130, align 1
  %bf.lshr132 = lshr i8 %bf.load131, 4
  %conv133 = zext i8 %bf.lshr132 to i32
  %157 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %157, i32 0, i32 2
  %158 = load i16, i16* %off, align 2
  %conv134 = sext i16 %158 to i32
  %159 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code135 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %159, i32 0, i32 0
  %160 = load i8, i8* %code135, align 4
  %conv136 = zext i8 %160 to i32
  %and137 = and i32 %conv136, 24
  %161 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %161, i32 0, i32 1
  %bf.load139 = load i8, i8* %dst_reg138, align 1
  %bf.clear140 = and i8 %bf.load139, 15
  %conv141 = zext i8 %bf.clear140 to i32
  %call142 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %153, i32 noundef %155, i32 noundef %conv133, i32 noundef %conv134, i32 noundef %and137, i32 noundef 1, i32 noundef %conv141, i1 noundef zeroext false) #20
  store i32 %call142, i32* %err, align 4
  %162 = load i32, i32* %err, align 4
  %tobool143 = icmp ne i32 %162, 0
  br i1 %tobool143, label %if.then144, label %if.end145

if.then144:                                       ; preds = %if.end123
  %163 = load i32, i32* %err, align 4
  store i32 %163, i32* %retval, align 4
  br label %return

if.end145:                                        ; preds = %if.end123
  %164 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %164, i32 0, i32 24
  %165 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %166 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx146 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %166, i32 0, i32 0
  %167 = load i32, i32* %insn_idx146, align 8
  %idxprom147 = zext i32 %167 to i64
  %arrayidx148 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %165, i64 %idxprom147
  %168 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx148, i32 0, i32 0
  %ptr_type = bitcast %union.anon.210* %168 to i32*
  store i32* %ptr_type, i32** %prev_src_type, align 8
  %169 = load i32*, i32** %prev_src_type, align 8
  %170 = load i32, i32* %169, align 4
  %cmp149 = icmp eq i32 %170, 0
  br i1 %cmp149, label %if.then151, label %if.else152

if.then151:                                       ; preds = %if.end145
  %171 = load i32, i32* %src_reg_type, align 4
  %172 = load i32*, i32** %prev_src_type, align 8
  store i32 %171, i32* %172, align 4
  br label %if.end156

if.else152:                                       ; preds = %if.end145
  %173 = load i32, i32* %src_reg_type, align 4
  %174 = load i32*, i32** %prev_src_type, align 8
  %175 = load i32, i32* %174, align 4
  %call153 = call zeroext i1 @reg_type_mismatch(i32 noundef %173, i32 noundef %175) #20
  br i1 %call153, label %if.then154, label %if.end155

if.then154:                                       ; preds = %if.else152
  %176 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %177 = bitcast %struct.bpf_verifier_env* %176 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %177, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.297, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end155:                                        ; preds = %if.else152
  br label %if.end156

if.end156:                                        ; preds = %if.end155, %if.then151
  br label %if.end565

if.else157:                                       ; preds = %if.else108
  %178 = load i8, i8* %class, align 1
  %conv158 = zext i8 %178 to i32
  %cmp159 = icmp eq i32 %conv158, 3
  br i1 %cmp159, label %if.then161, label %if.else239

if.then161:                                       ; preds = %if.else157
  %179 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code162 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %179, i32 0, i32 0
  %180 = load i8, i8* %code162, align 4
  %conv163 = zext i8 %180 to i32
  %and164 = and i32 %conv163, 224
  %cmp165 = icmp eq i32 %and164, 192
  br i1 %cmp165, label %if.then167, label %if.end175

if.then167:                                       ; preds = %if.then161
  %181 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %182 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx168 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %182, i32 0, i32 0
  %183 = load i32, i32* %insn_idx168, align 8
  %184 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call169 = call i32 @check_atomic(%struct.bpf_verifier_env* noundef %181, i32 noundef %183, %struct.bpf_insn* noundef %184) #20
  store i32 %call169, i32* %err, align 4
  %185 = load i32, i32* %err, align 4
  %tobool170 = icmp ne i32 %185, 0
  br i1 %tobool170, label %if.then171, label %if.end172

if.then171:                                       ; preds = %if.then167
  %186 = load i32, i32* %err, align 4
  store i32 %186, i32* %retval, align 4
  br label %return

if.end172:                                        ; preds = %if.then167
  %187 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx173 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %187, i32 0, i32 0
  %188 = load i32, i32* %insn_idx173, align 8
  %inc174 = add i32 %188, 1
  store i32 %inc174, i32* %insn_idx173, align 8
  br label %for.cond

if.end175:                                        ; preds = %if.then161
  %189 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code176 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %189, i32 0, i32 0
  %190 = load i8, i8* %code176, align 4
  %conv177 = zext i8 %190 to i32
  %and178 = and i32 %conv177, 224
  %cmp179 = icmp ne i32 %and178, 96
  br i1 %cmp179, label %if.then184, label %lor.lhs.false181

lor.lhs.false181:                                 ; preds = %if.end175
  %191 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %191, i32 0, i32 3
  %192 = load i32, i32* %imm, align 4
  %cmp182 = icmp ne i32 %192, 0
  br i1 %cmp182, label %if.then184, label %if.end185

if.then184:                                       ; preds = %lor.lhs.false181, %if.end175
  %193 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %194 = bitcast %struct.bpf_verifier_env* %193 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %194, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.298, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end185:                                        ; preds = %lor.lhs.false181
  %195 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %196 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg186 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %196, i32 0, i32 1
  %bf.load187 = load i8, i8* %src_reg186, align 1
  %bf.lshr188 = lshr i8 %bf.load187, 4
  %conv189 = zext i8 %bf.lshr188 to i32
  %call190 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %195, i32 noundef %conv189, i32 noundef 0) #20
  store i32 %call190, i32* %err, align 4
  %197 = load i32, i32* %err, align 4
  %tobool191 = icmp ne i32 %197, 0
  br i1 %tobool191, label %if.then192, label %if.end193

if.then192:                                       ; preds = %if.end185
  %198 = load i32, i32* %err, align 4
  store i32 %198, i32* %retval, align 4
  br label %return

if.end193:                                        ; preds = %if.end185
  %199 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %200 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg194 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %200, i32 0, i32 1
  %bf.load195 = load i8, i8* %dst_reg194, align 1
  %bf.clear196 = and i8 %bf.load195, 15
  %conv197 = zext i8 %bf.clear196 to i32
  %call198 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %199, i32 noundef %conv197, i32 noundef 0) #20
  store i32 %call198, i32* %err, align 4
  %201 = load i32, i32* %err, align 4
  %tobool199 = icmp ne i32 %201, 0
  br i1 %tobool199, label %if.then200, label %if.end201

if.then200:                                       ; preds = %if.end193
  %202 = load i32, i32* %err, align 4
  store i32 %202, i32* %retval, align 4
  br label %return

if.end201:                                        ; preds = %if.end193
  %203 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %204 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg202 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %204, i32 0, i32 1
  %bf.load203 = load i8, i8* %dst_reg202, align 1
  %bf.clear204 = and i8 %bf.load203, 15
  %idxprom205 = zext i8 %bf.clear204 to i64
  %arrayidx206 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %203, i64 %idxprom205
  %type207 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx206, i32 0, i32 0
  %205 = load i32, i32* %type207, align 8
  store i32 %205, i32* %dst_reg_type, align 4
  %206 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %207 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx208 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %207, i32 0, i32 0
  %208 = load i32, i32* %insn_idx208, align 8
  %209 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg209 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %209, i32 0, i32 1
  %bf.load210 = load i8, i8* %dst_reg209, align 1
  %bf.clear211 = and i8 %bf.load210, 15
  %conv212 = zext i8 %bf.clear211 to i32
  %210 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off213 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %210, i32 0, i32 2
  %211 = load i16, i16* %off213, align 2
  %conv214 = sext i16 %211 to i32
  %212 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code215 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %212, i32 0, i32 0
  %213 = load i8, i8* %code215, align 4
  %conv216 = zext i8 %213 to i32
  %and217 = and i32 %conv216, 24
  %214 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg218 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %214, i32 0, i32 1
  %bf.load219 = load i8, i8* %src_reg218, align 1
  %bf.lshr220 = lshr i8 %bf.load219, 4
  %conv221 = zext i8 %bf.lshr220 to i32
  %call222 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %206, i32 noundef %208, i32 noundef %conv212, i32 noundef %conv214, i32 noundef %and217, i32 noundef 2, i32 noundef %conv221, i1 noundef zeroext false) #20
  store i32 %call222, i32* %err, align 4
  %215 = load i32, i32* %err, align 4
  %tobool223 = icmp ne i32 %215, 0
  br i1 %tobool223, label %if.then224, label %if.end225

if.then224:                                       ; preds = %if.end201
  %216 = load i32, i32* %err, align 4
  store i32 %216, i32* %retval, align 4
  br label %return

if.end225:                                        ; preds = %if.end201
  %217 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data226 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %217, i32 0, i32 24
  %218 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data226, align 8
  %219 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx227 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %219, i32 0, i32 0
  %220 = load i32, i32* %insn_idx227, align 8
  %idxprom228 = zext i32 %220 to i64
  %arrayidx229 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %218, i64 %idxprom228
  %221 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx229, i32 0, i32 0
  %ptr_type230 = bitcast %union.anon.210* %221 to i32*
  store i32* %ptr_type230, i32** %prev_dst_type, align 8
  %222 = load i32*, i32** %prev_dst_type, align 8
  %223 = load i32, i32* %222, align 4
  %cmp231 = icmp eq i32 %223, 0
  br i1 %cmp231, label %if.then233, label %if.else234

if.then233:                                       ; preds = %if.end225
  %224 = load i32, i32* %dst_reg_type, align 4
  %225 = load i32*, i32** %prev_dst_type, align 8
  store i32 %224, i32* %225, align 4
  br label %if.end238

if.else234:                                       ; preds = %if.end225
  %226 = load i32, i32* %dst_reg_type, align 4
  %227 = load i32*, i32** %prev_dst_type, align 8
  %228 = load i32, i32* %227, align 4
  %call235 = call zeroext i1 @reg_type_mismatch(i32 noundef %226, i32 noundef %228) #20
  br i1 %call235, label %if.then236, label %if.end237

if.then236:                                       ; preds = %if.else234
  %229 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %230 = bitcast %struct.bpf_verifier_env* %229 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %230, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.297, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end237:                                        ; preds = %if.else234
  br label %if.end238

if.end238:                                        ; preds = %if.end237, %if.then233
  br label %if.end564

if.else239:                                       ; preds = %if.else157
  %231 = load i8, i8* %class, align 1
  %conv240 = zext i8 %231 to i32
  %cmp241 = icmp eq i32 %conv240, 2
  br i1 %cmp241, label %if.then243, label %if.else298

if.then243:                                       ; preds = %if.else239
  %232 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code244 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %232, i32 0, i32 0
  %233 = load i8, i8* %code244, align 4
  %conv245 = zext i8 %233 to i32
  %and246 = and i32 %conv245, 224
  %cmp247 = icmp ne i32 %and246, 96
  br i1 %cmp247, label %if.then256, label %lor.lhs.false249

lor.lhs.false249:                                 ; preds = %if.then243
  %234 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg250 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %234, i32 0, i32 1
  %bf.load251 = load i8, i8* %src_reg250, align 1
  %bf.lshr252 = lshr i8 %bf.load251, 4
  %conv253 = zext i8 %bf.lshr252 to i32
  %cmp254 = icmp ne i32 %conv253, 0
  br i1 %cmp254, label %if.then256, label %if.end257

if.then256:                                       ; preds = %lor.lhs.false249, %if.then243
  %235 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %236 = bitcast %struct.bpf_verifier_env* %235 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %236, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.299, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end257:                                        ; preds = %lor.lhs.false249
  %237 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %238 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg258 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %238, i32 0, i32 1
  %bf.load259 = load i8, i8* %dst_reg258, align 1
  %bf.clear260 = and i8 %bf.load259, 15
  %conv261 = zext i8 %bf.clear260 to i32
  %call262 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %237, i32 noundef %conv261, i32 noundef 0) #20
  store i32 %call262, i32* %err, align 4
  %239 = load i32, i32* %err, align 4
  %tobool263 = icmp ne i32 %239, 0
  br i1 %tobool263, label %if.then264, label %if.end265

if.then264:                                       ; preds = %if.end257
  %240 = load i32, i32* %err, align 4
  store i32 %240, i32* %retval, align 4
  br label %return

if.end265:                                        ; preds = %if.end257
  %241 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %242 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg266 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %242, i32 0, i32 1
  %bf.load267 = load i8, i8* %dst_reg266, align 1
  %bf.clear268 = and i8 %bf.load267, 15
  %conv269 = zext i8 %bf.clear268 to i32
  %call270 = call zeroext i1 @is_ctx_reg(%struct.bpf_verifier_env* noundef %241, i32 noundef %conv269) #20
  br i1 %call270, label %if.then271, label %if.end283

if.then271:                                       ; preds = %if.end265
  %243 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %244 = bitcast %struct.bpf_verifier_env* %243 to i8*
  %245 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg272 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %245, i32 0, i32 1
  %bf.load273 = load i8, i8* %dst_reg272, align 1
  %bf.clear274 = and i8 %bf.load273, 15
  %conv275 = zext i8 %bf.clear274 to i32
  %246 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %247 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %248 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg276 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %248, i32 0, i32 1
  %bf.load277 = load i8, i8* %dst_reg276, align 1
  %bf.clear278 = and i8 %bf.load277, 15
  %conv279 = zext i8 %bf.clear278 to i32
  %call280 = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %247, i32 noundef %conv279) #20
  %type281 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %call280, i32 0, i32 0
  %249 = load i32, i32* %type281, align 8
  %call282 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %246, i32 noundef %249) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %244, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.300, i64 0, i64 0), i32 noundef %conv275, i8* noundef %call282) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end283:                                        ; preds = %if.end265
  %250 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %251 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx284 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %251, i32 0, i32 0
  %252 = load i32, i32* %insn_idx284, align 8
  %253 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg285 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %253, i32 0, i32 1
  %bf.load286 = load i8, i8* %dst_reg285, align 1
  %bf.clear287 = and i8 %bf.load286, 15
  %conv288 = zext i8 %bf.clear287 to i32
  %254 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off289 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %254, i32 0, i32 2
  %255 = load i16, i16* %off289, align 2
  %conv290 = sext i16 %255 to i32
  %256 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code291 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %256, i32 0, i32 0
  %257 = load i8, i8* %code291, align 4
  %conv292 = zext i8 %257 to i32
  %and293 = and i32 %conv292, 24
  %call294 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %250, i32 noundef %252, i32 noundef %conv288, i32 noundef %conv290, i32 noundef %and293, i32 noundef 2, i32 noundef -1, i1 noundef zeroext false) #20
  store i32 %call294, i32* %err, align 4
  %258 = load i32, i32* %err, align 4
  %tobool295 = icmp ne i32 %258, 0
  br i1 %tobool295, label %if.then296, label %if.end297

if.then296:                                       ; preds = %if.end283
  %259 = load i32, i32* %err, align 4
  store i32 %259, i32* %retval, align 4
  br label %return

if.end297:                                        ; preds = %if.end283
  br label %if.end563

if.else298:                                       ; preds = %if.else239
  %260 = load i8, i8* %class, align 1
  %conv299 = zext i8 %260 to i32
  %cmp300 = icmp eq i32 %conv299, 5
  br i1 %cmp300, label %if.then306, label %lor.lhs.false302

lor.lhs.false302:                                 ; preds = %if.else298
  %261 = load i8, i8* %class, align 1
  %conv303 = zext i8 %261 to i32
  %cmp304 = icmp eq i32 %conv303, 6
  br i1 %cmp304, label %if.then306, label %if.else524

if.then306:                                       ; preds = %lor.lhs.false302, %if.else298
  %262 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code307 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %262, i32 0, i32 0
  %263 = load i8, i8* %code307, align 4
  %conv308 = zext i8 %263 to i32
  %and309 = and i32 %conv308, 240
  %conv310 = trunc i32 %and309 to i8
  store i8 %conv310, i8* %opcode, align 1
  %264 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %264, i32 0, i32 35
  %265 = load i32, i32* %jmps_processed, align 4
  %inc311 = add i32 %265, 1
  store i32 %inc311, i32* %jmps_processed, align 4
  %266 = load i8, i8* %opcode, align 1
  %conv312 = zext i8 %266 to i32
  %cmp313 = icmp eq i32 %conv312, 128
  br i1 %cmp313, label %if.then315, label %if.else409

if.then315:                                       ; preds = %if.then306
  %267 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code316 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %267, i32 0, i32 0
  %268 = load i8, i8* %code316, align 4
  %conv317 = zext i8 %268 to i32
  %and318 = and i32 %conv317, 8
  %cmp319 = icmp ne i32 %and318, 0
  br i1 %cmp319, label %if.then365, label %lor.lhs.false321

lor.lhs.false321:                                 ; preds = %if.then315
  %269 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg322 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %269, i32 0, i32 1
  %bf.load323 = load i8, i8* %src_reg322, align 1
  %bf.lshr324 = lshr i8 %bf.load323, 4
  %conv325 = zext i8 %bf.lshr324 to i32
  %cmp326 = icmp ne i32 %conv325, 2
  br i1 %cmp326, label %land.lhs.true328, label %lor.lhs.false333

land.lhs.true328:                                 ; preds = %lor.lhs.false321
  %270 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off329 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %270, i32 0, i32 2
  %271 = load i16, i16* %off329, align 2
  %conv330 = sext i16 %271 to i32
  %cmp331 = icmp ne i32 %conv330, 0
  br i1 %cmp331, label %if.then365, label %lor.lhs.false333

lor.lhs.false333:                                 ; preds = %land.lhs.true328, %lor.lhs.false321
  %272 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg334 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %272, i32 0, i32 1
  %bf.load335 = load i8, i8* %src_reg334, align 1
  %bf.lshr336 = lshr i8 %bf.load335, 4
  %conv337 = zext i8 %bf.lshr336 to i32
  %cmp338 = icmp ne i32 %conv337, 0
  br i1 %cmp338, label %land.lhs.true340, label %lor.lhs.false354

land.lhs.true340:                                 ; preds = %lor.lhs.false333
  %273 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg341 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %273, i32 0, i32 1
  %bf.load342 = load i8, i8* %src_reg341, align 1
  %bf.lshr343 = lshr i8 %bf.load342, 4
  %conv344 = zext i8 %bf.lshr343 to i32
  %cmp345 = icmp ne i32 %conv344, 1
  br i1 %cmp345, label %land.lhs.true347, label %lor.lhs.false354

land.lhs.true347:                                 ; preds = %land.lhs.true340
  %274 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg348 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %274, i32 0, i32 1
  %bf.load349 = load i8, i8* %src_reg348, align 1
  %bf.lshr350 = lshr i8 %bf.load349, 4
  %conv351 = zext i8 %bf.lshr350 to i32
  %cmp352 = icmp ne i32 %conv351, 2
  br i1 %cmp352, label %if.then365, label %lor.lhs.false354

lor.lhs.false354:                                 ; preds = %land.lhs.true347, %land.lhs.true340, %lor.lhs.false333
  %275 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg355 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %275, i32 0, i32 1
  %bf.load356 = load i8, i8* %dst_reg355, align 1
  %bf.clear357 = and i8 %bf.load356, 15
  %conv358 = zext i8 %bf.clear357 to i32
  %cmp359 = icmp ne i32 %conv358, 0
  br i1 %cmp359, label %if.then365, label %lor.lhs.false361

lor.lhs.false361:                                 ; preds = %lor.lhs.false354
  %276 = load i8, i8* %class, align 1
  %conv362 = zext i8 %276 to i32
  %cmp363 = icmp eq i32 %conv362, 6
  br i1 %cmp363, label %if.then365, label %if.end366

if.then365:                                       ; preds = %lor.lhs.false361, %lor.lhs.false354, %land.lhs.true347, %land.lhs.true328, %if.then315
  %277 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %278 = bitcast %struct.bpf_verifier_env* %277 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %278, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.301, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end366:                                        ; preds = %lor.lhs.false361
  %279 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state367 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %279, i32 0, i32 8
  %280 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state367, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %280, i32 0, i32 5
  %281 = load i32, i32* %active_spin_lock, align 4
  %tobool368 = icmp ne i32 %281, 0
  br i1 %tobool368, label %land.lhs.true369, label %if.end381

land.lhs.true369:                                 ; preds = %if.end366
  %282 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg370 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %282, i32 0, i32 1
  %bf.load371 = load i8, i8* %src_reg370, align 1
  %bf.lshr372 = lshr i8 %bf.load371, 4
  %conv373 = zext i8 %bf.lshr372 to i32
  %cmp374 = icmp eq i32 %conv373, 1
  br i1 %cmp374, label %if.then380, label %lor.lhs.false376

lor.lhs.false376:                                 ; preds = %land.lhs.true369
  %283 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm377 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %283, i32 0, i32 3
  %284 = load i32, i32* %imm377, align 4
  %cmp378 = icmp ne i32 %284, 94
  br i1 %cmp378, label %if.then380, label %if.end381

if.then380:                                       ; preds = %lor.lhs.false376, %land.lhs.true369
  %285 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %286 = bitcast %struct.bpf_verifier_env* %285 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %286, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.302, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end381:                                        ; preds = %lor.lhs.false376, %if.end366
  %287 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg382 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %287, i32 0, i32 1
  %bf.load383 = load i8, i8* %src_reg382, align 1
  %bf.lshr384 = lshr i8 %bf.load383, 4
  %conv385 = zext i8 %bf.lshr384 to i32
  %cmp386 = icmp eq i32 %conv385, 1
  br i1 %cmp386, label %if.then388, label %if.else391

if.then388:                                       ; preds = %if.end381
  %288 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %289 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %290 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx389 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %290, i32 0, i32 0
  %call390 = call i32 @check_func_call(%struct.bpf_verifier_env* noundef %288, %struct.bpf_insn* noundef %289, i32* noundef %insn_idx389) #20
  store i32 %call390, i32* %err, align 4
  br label %if.end405

if.else391:                                       ; preds = %if.end381
  %291 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg392 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %291, i32 0, i32 1
  %bf.load393 = load i8, i8* %src_reg392, align 1
  %bf.lshr394 = lshr i8 %bf.load393, 4
  %conv395 = zext i8 %bf.lshr394 to i32
  %cmp396 = icmp eq i32 %conv395, 2
  br i1 %cmp396, label %if.then398, label %if.else401

if.then398:                                       ; preds = %if.else391
  %292 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %293 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %294 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx399 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %294, i32 0, i32 0
  %call400 = call i32 @check_kfunc_call(%struct.bpf_verifier_env* noundef %292, %struct.bpf_insn* noundef %293, i32* noundef %insn_idx399) #20
  store i32 %call400, i32* %err, align 4
  br label %if.end404

if.else401:                                       ; preds = %if.else391
  %295 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %296 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %297 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx402 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %297, i32 0, i32 0
  %call403 = call i32 @check_helper_call(%struct.bpf_verifier_env* noundef %295, %struct.bpf_insn* noundef %296, i32* noundef %insn_idx402) #20
  store i32 %call403, i32* %err, align 4
  br label %if.end404

if.end404:                                        ; preds = %if.else401, %if.then398
  br label %if.end405

if.end405:                                        ; preds = %if.end404, %if.then388
  %298 = load i32, i32* %err, align 4
  %tobool406 = icmp ne i32 %298, 0
  br i1 %tobool406, label %if.then407, label %if.end408

if.then407:                                       ; preds = %if.end405
  %299 = load i32, i32* %err, align 4
  store i32 %299, i32* %retval, align 4
  br label %return

if.end408:                                        ; preds = %if.end405
  br label %if.end523

if.else409:                                       ; preds = %if.then306
  %300 = load i8, i8* %opcode, align 1
  %conv410 = zext i8 %300 to i32
  %cmp411 = icmp eq i32 %conv410, 0
  br i1 %cmp411, label %if.then413, label %if.else447

if.then413:                                       ; preds = %if.else409
  %301 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code414 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %301, i32 0, i32 0
  %302 = load i8, i8* %code414, align 4
  %conv415 = zext i8 %302 to i32
  %and416 = and i32 %conv415, 8
  %cmp417 = icmp ne i32 %and416, 0
  br i1 %cmp417, label %if.then441, label %lor.lhs.false419

lor.lhs.false419:                                 ; preds = %if.then413
  %303 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm420 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %303, i32 0, i32 3
  %304 = load i32, i32* %imm420, align 4
  %cmp421 = icmp ne i32 %304, 0
  br i1 %cmp421, label %if.then441, label %lor.lhs.false423

lor.lhs.false423:                                 ; preds = %lor.lhs.false419
  %305 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg424 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %305, i32 0, i32 1
  %bf.load425 = load i8, i8* %src_reg424, align 1
  %bf.lshr426 = lshr i8 %bf.load425, 4
  %conv427 = zext i8 %bf.lshr426 to i32
  %cmp428 = icmp ne i32 %conv427, 0
  br i1 %cmp428, label %if.then441, label %lor.lhs.false430

lor.lhs.false430:                                 ; preds = %lor.lhs.false423
  %306 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg431 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %306, i32 0, i32 1
  %bf.load432 = load i8, i8* %dst_reg431, align 1
  %bf.clear433 = and i8 %bf.load432, 15
  %conv434 = zext i8 %bf.clear433 to i32
  %cmp435 = icmp ne i32 %conv434, 0
  br i1 %cmp435, label %if.then441, label %lor.lhs.false437

lor.lhs.false437:                                 ; preds = %lor.lhs.false430
  %307 = load i8, i8* %class, align 1
  %conv438 = zext i8 %307 to i32
  %cmp439 = icmp eq i32 %conv438, 6
  br i1 %cmp439, label %if.then441, label %if.end442

if.then441:                                       ; preds = %lor.lhs.false437, %lor.lhs.false430, %lor.lhs.false423, %lor.lhs.false419, %if.then413
  %308 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %309 = bitcast %struct.bpf_verifier_env* %308 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %309, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.303, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end442:                                        ; preds = %lor.lhs.false437
  %310 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off443 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %310, i32 0, i32 2
  %311 = load i16, i16* %off443, align 2
  %conv444 = sext i16 %311 to i32
  %add = add i32 %conv444, 1
  %312 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx445 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %312, i32 0, i32 0
  %313 = load i32, i32* %insn_idx445, align 8
  %add446 = add i32 %313, %add
  store i32 %add446, i32* %insn_idx445, align 8
  br label %for.cond

if.else447:                                       ; preds = %if.else409
  %314 = load i8, i8* %opcode, align 1
  %conv448 = zext i8 %314 to i32
  %cmp449 = icmp eq i32 %conv448, 144
  br i1 %cmp449, label %if.then451, label %if.else515

if.then451:                                       ; preds = %if.else447
  %315 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code452 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %315, i32 0, i32 0
  %316 = load i8, i8* %code452, align 4
  %conv453 = zext i8 %316 to i32
  %and454 = and i32 %conv453, 8
  %cmp455 = icmp ne i32 %and454, 0
  br i1 %cmp455, label %if.then479, label %lor.lhs.false457

lor.lhs.false457:                                 ; preds = %if.then451
  %317 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm458 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %317, i32 0, i32 3
  %318 = load i32, i32* %imm458, align 4
  %cmp459 = icmp ne i32 %318, 0
  br i1 %cmp459, label %if.then479, label %lor.lhs.false461

lor.lhs.false461:                                 ; preds = %lor.lhs.false457
  %319 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg462 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %319, i32 0, i32 1
  %bf.load463 = load i8, i8* %src_reg462, align 1
  %bf.lshr464 = lshr i8 %bf.load463, 4
  %conv465 = zext i8 %bf.lshr464 to i32
  %cmp466 = icmp ne i32 %conv465, 0
  br i1 %cmp466, label %if.then479, label %lor.lhs.false468

lor.lhs.false468:                                 ; preds = %lor.lhs.false461
  %320 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg469 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %320, i32 0, i32 1
  %bf.load470 = load i8, i8* %dst_reg469, align 1
  %bf.clear471 = and i8 %bf.load470, 15
  %conv472 = zext i8 %bf.clear471 to i32
  %cmp473 = icmp ne i32 %conv472, 0
  br i1 %cmp473, label %if.then479, label %lor.lhs.false475

lor.lhs.false475:                                 ; preds = %lor.lhs.false468
  %321 = load i8, i8* %class, align 1
  %conv476 = zext i8 %321 to i32
  %cmp477 = icmp eq i32 %conv476, 6
  br i1 %cmp477, label %if.then479, label %if.end480

if.then479:                                       ; preds = %lor.lhs.false475, %lor.lhs.false468, %lor.lhs.false461, %lor.lhs.false457, %if.then451
  %322 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %323 = bitcast %struct.bpf_verifier_env* %322 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %323, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.304, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end480:                                        ; preds = %lor.lhs.false475
  %324 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state481 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %324, i32 0, i32 8
  %325 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state481, align 8
  %active_spin_lock482 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %325, i32 0, i32 5
  %326 = load i32, i32* %active_spin_lock482, align 4
  %tobool483 = icmp ne i32 %326, 0
  br i1 %tobool483, label %if.then484, label %if.end485

if.then484:                                       ; preds = %if.end480
  %327 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %328 = bitcast %struct.bpf_verifier_env* %327 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %328, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.305, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end485:                                        ; preds = %if.end480
  %329 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call486 = call i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %329) #20
  store i32 %call486, i32* %err, align 4
  %330 = load i32, i32* %err, align 4
  %tobool487 = icmp ne i32 %330, 0
  br i1 %tobool487, label %if.then488, label %if.end489

if.then488:                                       ; preds = %if.end485
  %331 = load i32, i32* %err, align 4
  store i32 %331, i32* %retval, align 4
  br label %return

if.end489:                                        ; preds = %if.end485
  %332 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe490 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %332, i32 0, i32 4
  %333 = load i32, i32* %curframe490, align 8
  %tobool491 = icmp ne i32 %333, 0
  br i1 %tobool491, label %if.then492, label %if.end498

if.then492:                                       ; preds = %if.end489
  %334 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %335 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx493 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %335, i32 0, i32 0
  %call494 = call i32 @prepare_func_exit(%struct.bpf_verifier_env* noundef %334, i32* noundef %insn_idx493) #20
  store i32 %call494, i32* %err, align 4
  %336 = load i32, i32* %err, align 4
  %tobool495 = icmp ne i32 %336, 0
  br i1 %tobool495, label %if.then496, label %if.end497

if.then496:                                       ; preds = %if.then492
  %337 = load i32, i32* %err, align 4
  store i32 %337, i32* %retval, align 4
  br label %return

if.end497:                                        ; preds = %if.then492
  store i8 1, i8* %do_print_state, align 1
  br label %for.cond

if.end498:                                        ; preds = %if.end489
  %338 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call499 = call i32 @check_return_code(%struct.bpf_verifier_env* noundef %338) #20
  store i32 %call499, i32* %err, align 4
  %339 = load i32, i32* %err, align 4
  %tobool500 = icmp ne i32 %339, 0
  br i1 %tobool500, label %if.then501, label %if.end502

if.then501:                                       ; preds = %if.end498
  %340 = load i32, i32* %err, align 4
  store i32 %340, i32* %retval, align 4
  br label %return

if.end502:                                        ; preds = %if.end498
  br label %process_bpf_exit

process_bpf_exit:                                 ; preds = %if.end502, %if.end34
  %341 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @mark_verifier_state_scratched(%struct.bpf_verifier_env* noundef %341) #20
  %342 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %343 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state503 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %343, i32 0, i32 8
  %344 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state503, align 8
  call void @update_branch_counts(%struct.bpf_verifier_env* noundef %342, %struct.bpf_verifier_state* noundef %344) #20
  %345 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %346 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx504 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %346, i32 0, i32 0
  %347 = load i8, i8* %pop_log, align 1
  %tobool505 = trunc i8 %347 to i1
  %call506 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %345, i32* noundef %prev_insn_idx, i32* noundef %insn_idx504, i1 noundef zeroext %tobool505) #20
  store i32 %call506, i32* %err, align 4
  %348 = load i32, i32* %err, align 4
  %cmp507 = icmp slt i32 %348, 0
  br i1 %cmp507, label %if.then509, label %if.else514

if.then509:                                       ; preds = %process_bpf_exit
  %349 = load i32, i32* %err, align 4
  %cmp510 = icmp ne i32 %349, -2
  br i1 %cmp510, label %if.then512, label %if.end513

if.then512:                                       ; preds = %if.then509
  %350 = load i32, i32* %err, align 4
  store i32 %350, i32* %retval, align 4
  br label %return

if.end513:                                        ; preds = %if.then509
  br label %for.end

if.else514:                                       ; preds = %process_bpf_exit
  store i8 1, i8* %do_print_state, align 1
  br label %for.cond

if.else515:                                       ; preds = %if.else447
  %351 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %352 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %353 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx516 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %353, i32 0, i32 0
  %call517 = call i32 @check_cond_jmp_op(%struct.bpf_verifier_env* noundef %351, %struct.bpf_insn* noundef %352, i32* noundef %insn_idx516) #20
  store i32 %call517, i32* %err, align 4
  %354 = load i32, i32* %err, align 4
  %tobool518 = icmp ne i32 %354, 0
  br i1 %tobool518, label %if.then519, label %if.end520

if.then519:                                       ; preds = %if.else515
  %355 = load i32, i32* %err, align 4
  store i32 %355, i32* %retval, align 4
  br label %return

if.end520:                                        ; preds = %if.else515
  br label %if.end521

if.end521:                                        ; preds = %if.end520
  br label %if.end522

if.end522:                                        ; preds = %if.end521
  br label %if.end523

if.end523:                                        ; preds = %if.end522, %if.end408
  br label %if.end562

if.else524:                                       ; preds = %lor.lhs.false302
  %356 = load i8, i8* %class, align 1
  %conv525 = zext i8 %356 to i32
  %cmp526 = icmp eq i32 %conv525, 0
  br i1 %cmp526, label %if.then528, label %if.else559

if.then528:                                       ; preds = %if.else524
  %357 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code529 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %357, i32 0, i32 0
  %358 = load i8, i8* %code529, align 4
  %conv530 = zext i8 %358 to i32
  %and531 = and i32 %conv530, 224
  %conv532 = trunc i32 %and531 to i8
  store i8 %conv532, i8* %mode, align 1
  %359 = load i8, i8* %mode, align 1
  %conv533 = zext i8 %359 to i32
  %cmp534 = icmp eq i32 %conv533, 32
  br i1 %cmp534, label %if.then540, label %lor.lhs.false536

lor.lhs.false536:                                 ; preds = %if.then528
  %360 = load i8, i8* %mode, align 1
  %conv537 = zext i8 %360 to i32
  %cmp538 = icmp eq i32 %conv537, 64
  br i1 %cmp538, label %if.then540, label %if.else545

if.then540:                                       ; preds = %lor.lhs.false536, %if.then528
  %361 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %362 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call541 = call i32 @check_ld_abs(%struct.bpf_verifier_env* noundef %361, %struct.bpf_insn* noundef %362) #20
  store i32 %call541, i32* %err, align 4
  %363 = load i32, i32* %err, align 4
  %tobool542 = icmp ne i32 %363, 0
  br i1 %tobool542, label %if.then543, label %if.end544

if.then543:                                       ; preds = %if.then540
  %364 = load i32, i32* %err, align 4
  store i32 %364, i32* %retval, align 4
  br label %return

if.end544:                                        ; preds = %if.then540
  br label %if.end558

if.else545:                                       ; preds = %lor.lhs.false536
  %365 = load i8, i8* %mode, align 1
  %conv546 = zext i8 %365 to i32
  %cmp547 = icmp eq i32 %conv546, 0
  br i1 %cmp547, label %if.then549, label %if.else556

if.then549:                                       ; preds = %if.else545
  %366 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %367 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call550 = call i32 @check_ld_imm(%struct.bpf_verifier_env* noundef %366, %struct.bpf_insn* noundef %367) #20
  store i32 %call550, i32* %err, align 4
  %368 = load i32, i32* %err, align 4
  %tobool551 = icmp ne i32 %368, 0
  br i1 %tobool551, label %if.then552, label %if.end553

if.then552:                                       ; preds = %if.then549
  %369 = load i32, i32* %err, align 4
  store i32 %369, i32* %retval, align 4
  br label %return

if.end553:                                        ; preds = %if.then549
  %370 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx554 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %370, i32 0, i32 0
  %371 = load i32, i32* %insn_idx554, align 8
  %inc555 = add i32 %371, 1
  store i32 %inc555, i32* %insn_idx554, align 8
  %372 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @sanitize_mark_insn_seen(%struct.bpf_verifier_env* noundef %372) #20
  br label %if.end557

if.else556:                                       ; preds = %if.else545
  %373 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %374 = bitcast %struct.bpf_verifier_env* %373 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %374, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.306, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end557:                                        ; preds = %if.end553
  br label %if.end558

if.end558:                                        ; preds = %if.end557, %if.end544
  br label %if.end561

if.else559:                                       ; preds = %if.else524
  %375 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %376 = bitcast %struct.bpf_verifier_env* %375 to i8*
  %377 = load i8, i8* %class, align 1
  %conv560 = zext i8 %377 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %376, i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str.307, i64 0, i64 0), i32 noundef %conv560) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end561:                                        ; preds = %if.end558
  br label %if.end562

if.end562:                                        ; preds = %if.end561, %if.end523
  br label %if.end563

if.end563:                                        ; preds = %if.end562, %if.end297
  br label %if.end564

if.end564:                                        ; preds = %if.end563, %if.end238
  br label %if.end565

if.end565:                                        ; preds = %if.end564, %if.end156
  br label %if.end566

if.end566:                                        ; preds = %if.end565, %if.end107
  %378 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx567 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %378, i32 0, i32 0
  %379 = load i32, i32* %insn_idx567, align 8
  %inc568 = add i32 %379, 1
  store i32 %inc568, i32* %insn_idx567, align 8
  br label %for.cond

for.end:                                          ; preds = %if.end513
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.else559, %if.else556, %if.then552, %if.then543, %if.then519, %if.then512, %if.then501, %if.then496, %if.then488, %if.then484, %if.then479, %if.then441, %if.then407, %if.then380, %if.then365, %if.then296, %if.then271, %if.then264, %if.then256, %if.then236, %if.then224, %if.then200, %if.then192, %if.then184, %if.then171, %if.then154, %if.then144, %if.then122, %if.then116, %if.then106, %if.then92, %if.then39, %if.then15, %if.then9, %if.then
  %380 = load i32, i32* %retval, align 4
  ret i32 %380
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @free_verifier_state(%struct.bpf_verifier_state* noundef %state, i1 noundef zeroext %free_self) #0 {
entry:
  %state.addr = alloca %struct.bpf_verifier_state*, align 8
  %free_self.addr = alloca i8, align 1
  %i = alloca i32, align 4
  store %struct.bpf_verifier_state* %state, %struct.bpf_verifier_state** %state.addr, align 8
  %frombool = zext i1 %free_self to i8
  store i8 %frombool, i8* %free_self.addr, align 1
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 0
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %5) #20
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %frame1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 0
  %7 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame1, i64 0, i64 %idxprom2
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !91

for.end:                                          ; preds = %for.cond
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  call void @clear_jmp_history(%struct.bpf_verifier_state* noundef %9) #20
  %10 = load i8, i8* %free_self.addr, align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %12 = bitcast %struct.bpf_verifier_state* %11 to i8*
  call void @kfree(i8* noundef %12) #20
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @pop_stack(%struct.bpf_verifier_env* noundef %env, i32* noundef %prev_insn_idx, i32* noundef %insn_idx, i1 noundef zeroext %pop_log) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prev_insn_idx.addr = alloca i32*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %pop_log.addr = alloca i8, align 1
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %elem = alloca %struct.bpf_verifier_stack_elem*, align 8
  %head = alloca %struct.bpf_verifier_stack_elem*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32* %prev_insn_idx, i32** %prev_insn_idx.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %frombool = zext i1 %pop_log to i8
  store i8 %frombool, i8* %pop_log.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 4
  %3 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head1, align 8
  store %struct.bpf_verifier_stack_elem* %3, %struct.bpf_verifier_stack_elem** %head, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 4
  %5 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head2, align 8
  %cmp = icmp eq %struct.bpf_verifier_stack_elem* %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -2, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %6, null
  br i1 %tobool, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %8 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %st = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %8, i32 0, i32 0
  %call = call i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %7, %struct.bpf_verifier_state* noundef %st) #20
  store i32 %call, i32* %err, align 4
  %9 = load i32, i32* %err, align 4
  %tobool4 = icmp ne i32 %9, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then3
  %10 = load i32, i32* %err, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.then3
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %if.end
  %11 = load i8, i8* %pop_log.addr, align 1
  %tobool8 = trunc i8 %11 to i1
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 26
  %13 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %log_pos = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %13, i32 0, i32 4
  %14 = load i32, i32* %log_pos, align 8
  call void @bpf_vlog_reset(%struct.bpf_verifier_log* noundef %log, i32 noundef %14) #20
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  %15 = load i32*, i32** %insn_idx.addr, align 8
  %tobool11 = icmp ne i32* %15, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %16 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %insn_idx13 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %16, i32 0, i32 1
  %17 = load i32, i32* %insn_idx13, align 8
  %18 = load i32*, i32** %insn_idx.addr, align 8
  store i32 %17, i32* %18, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  %19 = load i32*, i32** %prev_insn_idx.addr, align 8
  %tobool15 = icmp ne i32* %19, null
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end14
  %20 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %prev_insn_idx17 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %20, i32 0, i32 2
  %21 = load i32, i32* %prev_insn_idx17, align 4
  %22 = load i32*, i32** %prev_insn_idx.addr, align 8
  store i32 %21, i32* %22, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end14
  %23 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %23, i32 0, i32 3
  %24 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %next, align 8
  store %struct.bpf_verifier_stack_elem* %24, %struct.bpf_verifier_stack_elem** %elem, align 8
  %25 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %st19 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %25, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %st19, i1 noundef zeroext false) #20
  %26 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %27 = bitcast %struct.bpf_verifier_stack_elem* %26 to i8*
  call void @kfree(i8* noundef %27) #20
  %28 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head20 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 4
  store %struct.bpf_verifier_stack_elem* %28, %struct.bpf_verifier_stack_elem** %head20, align 8
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 5
  %31 = load i32, i32* %stack_size, align 8
  %dec = add i32 %31, -1
  store i32 %dec, i32* %stack_size, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then5, %if.then
  %32 = load i32, i32* %retval, align 4
  ret i32 %32
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_vlog_reset(%struct.bpf_verifier_log* noundef %log, i32 noundef %new_pos) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %new_pos.addr = alloca i32, align 4
  %zero = alloca i8, align 1
  %tmp = alloca i64, align 8
  %__ret_pu = alloca i32, align 4
  %__ptr_pu = alloca i8*, align 8
  %__val_pu = alloca i8, align 1
  %__x = alloca i8, align 1
  %__ptr = alloca i8*, align 8
  %tmp2 = alloca i64, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store i32 %new_pos, i32* %new_pos.addr, align 4
  store i8 0, i8* %zero, align 1
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %0) #20
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end5

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %new_pos.addr, align 4
  %2 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %2, i32 0, i32 3
  store i32 %1, i32* %len_used, align 8
  call void @might_fault() #20
  %3 = load i8, i8* %zero, align 1
  store i8 %3, i8* %__x, align 1
  %4 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %4, i32 0, i32 2
  %5 = load i8*, i8** %ubuf, align 8
  %6 = load i32, i32* %new_pos.addr, align 4
  %idx.ext = zext i32 %6 to i64
  %add.ptr = getelementptr i8, i8* %5, i64 %idx.ext
  store i8* %add.ptr, i8** %__ptr, align 8
  %7 = load i8*, i8** %__ptr, align 8
  store i8* %7, i8** %__ptr_pu, align 8
  %8 = load i8, i8* %__x, align 1
  store i8 %8, i8* %__val_pu, align 1
  %9 = call i64 @llvm.read_register.i64(metadata !0)
  %10 = load i8*, i8** %__ptr_pu, align 8
  %11 = load i8, i8* %__val_pu, align 1
  %12 = call { i8*, i64 } asm sideeffect "call __put_user_${4:P}", "={cx},={rsp},0,{rax},i,{rsp},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %10, i8 %11, i64 1, i64 %9) #19, !srcloc !92
  %asmresult = extractvalue { i8*, i64 } %12, 0
  %asmresult1 = extractvalue { i8*, i64 } %12, 1
  %13 = ptrtoint i8* %asmresult to i64
  %14 = trunc i64 %13 to i32
  store i32 %14, i32* %__ret_pu, align 4
  call void @llvm.write_register.i64(metadata !0, i64 %asmresult1)
  %15 = load i8*, i8** %__ptr, align 8
  call void @kmsan_copy_to_user(i8* noundef %15, i8* noundef %__x, i64 noundef 1, i64 noundef 0) #20
  %16 = load i32, i32* %__ret_pu, align 4
  %conv = sext i32 %16 to i64
  store i64 %conv, i64* %tmp2, align 8
  %17 = load i64, i64* %tmp2, align 8
  store i64 %17, i64* %tmp, align 8
  %18 = load i64, i64* %tmp, align 8
  %tobool = icmp ne i64 %18, 0
  br i1 %tobool, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %19 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf4 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %19, i32 0, i32 2
  store i8* null, i8** %ubuf4, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then, %if.then3, %if.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @free_states(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %sl = alloca %struct.bpf_verifier_state_list*, align 8
  %sln = alloca %struct.bpf_verifier_state_list*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 10
  %1 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %free_list, align 8
  store %struct.bpf_verifier_state_list* %1, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool = icmp ne %struct.bpf_verifier_state_list* %2, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %3, i32 0, i32 1
  %4 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next, align 8
  store %struct.bpf_verifier_state_list* %4, %struct.bpf_verifier_state_list** %sln, align 8
  %5 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %5, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %state, i1 noundef zeroext false) #20
  %6 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %7 = bitcast %struct.bpf_verifier_state_list* %6 to i8*
  call void @kfree(i8* noundef %7) #20
  %8 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sln, align 8
  store %struct.bpf_verifier_state_list* %8, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond, !llvm.loop !93

while.end:                                        ; preds = %while.cond
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 10
  store %struct.bpf_verifier_state_list* null, %struct.bpf_verifier_state_list** %free_list1, align 8
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 9
  %11 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states, align 8
  %tobool2 = icmp ne %struct.bpf_verifier_state_list** %11, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %while.end
  br label %for.end

if.end:                                           ; preds = %while.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @state_htab_size(%struct.bpf_verifier_env* noundef %13) #20
  %cmp = icmp ult i32 %12, %call
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 9
  %15 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states3, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %15, i64 %idxprom
  %17 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %arrayidx, align 8
  store %struct.bpf_verifier_state_list* %17, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond4

while.cond4:                                      ; preds = %while.body6, %for.body
  %18 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool5 = icmp ne %struct.bpf_verifier_state_list* %18, null
  br i1 %tobool5, label %while.body6, label %while.end9

while.body6:                                      ; preds = %while.cond4
  %19 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next7 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %19, i32 0, i32 1
  %20 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next7, align 8
  store %struct.bpf_verifier_state_list* %20, %struct.bpf_verifier_state_list** %sln, align 8
  %21 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state8 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %21, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %state8, i1 noundef zeroext false) #20
  %22 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %23 = bitcast %struct.bpf_verifier_state_list* %22 to i8*
  call void @kfree(i8* noundef %23) #20
  %24 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sln, align 8
  store %struct.bpf_verifier_state_list* %24, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond4, !llvm.loop !94

while.end9:                                       ; preds = %while.cond4
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 9
  %26 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states10, align 8
  %27 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %27 to i64
  %arrayidx12 = getelementptr %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %26, i64 %idxprom11
  store %struct.bpf_verifier_state_list* null, %struct.bpf_verifier_state_list** %arrayidx12, align 8
  br label %for.inc

for.inc:                                          ; preds = %while.end9
  %28 = load i32, i32* %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !95

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @init_reg_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %4 = load i32, i32* %i, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3, i32 noundef %4) #20
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i64 %idxprom
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 17
  store i32 0, i32* %live, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %8 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %8 to i64
  %arrayidx3 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i64 %idxprom2
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx3, i32 0, i32 14
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %parent, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %10 = load i32, i32* %i, align 4
  %idxprom4 = sext i32 %10 to i64
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i64 %idxprom4
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx5, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !96

for.end:                                          ; preds = %for.cond
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx6 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i64 10
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx6, i32 0, i32 0
  store i32 6, i32* %type, align 8
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %13, %struct.bpf_reg_state* noundef %14, i32 noundef 10) #20
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 2
  %16 = load i32, i32* %frameno, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx7 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i64 10
  %frameno8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx7, i32 0, i32 15
  store i32 %16, i32* %frameno8, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_verifier_state_scratched(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %scratched_regs = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 42
  store i32 -1, i32* %scratched_regs, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %scratched_stack_slots = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 43
  store i64 -1, i64* %scratched_stack_slots, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %0, 11
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %1, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  store i32 2305, i32* %__flags, align 4
  br label %do.body7

do.body7:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body7
  br label %do.body8

do.body8:                                         ; preds = %do.end
  %2 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1811, i32 %2, i64 12) #19, !srcloc !97
  br label %do.end9

do.end9:                                          ; preds = %do.body8
  br label %do.body10

do.body10:                                        ; preds = %do.end9
  br label %do.end11

do.end11:                                         ; preds = %do.body10
  br label %do.end12

do.end12:                                         ; preds = %do.end11
  br label %if.end

if.end:                                           ; preds = %do.end12, %entry
  %3 = load i32, i32* %__ret_warn_on, align 4
  %tobool13 = icmp ne i32 %3, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  store i64 %conv18, i64* %tmp, align 8
  %4 = load i64, i64* %tmp, align 8
  %tobool19 = icmp ne i64 %4, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = bitcast %struct.bpf_verifier_env* %5 to i8*
  %7 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %6, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.290, i64 0, i64 0), i32 noundef %7) #20
  store i32 0, i32* %regno.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then20
  %8 = load i32, i32* %regno.addr, align 4
  %cmp21 = icmp ult i32 %8, 10
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %11 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i64 %idx.ext
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %9, %struct.bpf_reg_state* noundef %add.ptr) #20
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %regno.addr, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %regno.addr, align 4
  br label %for.cond, !llvm.loop !98

for.end:                                          ; preds = %for.cond
  br label %return

if.end23:                                         ; preds = %if.end
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %15 = load i32, i32* %regno.addr, align 4
  %idx.ext24 = zext i32 %15 to i64
  %add.ptr25 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i64 %idx.ext24
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %13, %struct.bpf_reg_state* noundef %add.ptr25) #20
  br label %return

return:                                           ; preds = %if.end23, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_state_visited(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %new_sl = alloca %struct.bpf_verifier_state_list*, align 8
  %sl = alloca %struct.bpf_verifier_state_list*, align 8
  %pprev = alloca %struct.bpf_verifier_state_list**, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %new = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %err = alloca i32, align 4
  %states_cnt = alloca i32, align 4
  %add_new_state = alloca i8, align 1
  %frame = alloca %struct.bpf_func_state*, align 8
  %br = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_cond = alloca i8, align 1
  %__ret_once = alloca i8, align 1
  %tmp = alloca i64, align 8
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp129 = alloca i64, align 8
  %tmp137 = alloca i64, align 8
  %__ret_do_once185 = alloca i8, align 1
  %__ret_cond194 = alloca i8, align 1
  %__ret_once201 = alloca i8, align 1
  %tmp217 = alloca i64, align 8
  %__ret_warn_on226 = alloca i32, align 4
  %__flags240 = alloca i32, align 4
  %tmp252 = alloca i64, align 8
  %tmp260 = alloca i64, align 8
  %frame317 = alloca %struct.bpf_func_state*, align 8
  %newframe = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  store i32 0, i32* %states_cnt, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %test_state_freq = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 7
  %3 = load i8, i8* %test_state_freq, align 1
  %tobool = trunc i8 %3 to i1
  %4 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %tobool1 = icmp ne i32 %cond, 0
  %frombool = zext i1 %tobool1 to i8
  store i8 %frombool, i8* %add_new_state, align 1
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 1
  %6 = load i32, i32* %prev_insn_idx, align 4
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %last_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 8
  store i32 %6, i32* %last_insn_idx, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 24
  %9 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %10 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %9, i64 %idxprom
  %prune_point = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 8
  %11 = load i8, i8* %prune_point, align 8
  %tobool2 = trunc i8 %11 to i1
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 35
  %13 = load i32, i32* %jmps_processed, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_jmps_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 34
  %15 = load i32, i32* %prev_jmps_processed, align 8
  %sub = sub i32 %13, %15
  %cmp = icmp uge i32 %sub, 2
  br i1 %cmp, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 33
  %17 = load i32, i32* %insn_processed, align 4
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 32
  %19 = load i32, i32* %prev_insn_processed, align 8
  %sub3 = sub i32 %17, %19
  %cmp4 = icmp uge i32 %sub3, 8
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true
  store i8 1, i8* %add_new_state, align 1
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %land.lhs.true, %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = load i32, i32* %insn_idx.addr, align 4
  %call = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %20, i32 noundef %21) #20
  store %struct.bpf_verifier_state_list** %call, %struct.bpf_verifier_state_list*** %pprev, align 8
  %22 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  %23 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %22, align 8
  store %struct.bpf_verifier_state_list* %23, %struct.bpf_verifier_state_list** %sl, align 8
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load i32, i32* %insn_idx.addr, align 4
  %26 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  call void @clean_live_states(%struct.bpf_verifier_env* noundef %24, i32 noundef %25, %struct.bpf_verifier_state* noundef %26) #20
  br label %while.cond

while.cond:                                       ; preds = %next150, %if.end148, %if.end6
  %27 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool7 = icmp ne %struct.bpf_verifier_state_list* %27, null
  br i1 %tobool7, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %28 = load i32, i32* %states_cnt, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %states_cnt, align 4
  %29 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %29, i32 0, i32 0
  %insn_idx8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state, i32 0, i32 3
  %30 = load i32, i32* %insn_idx8, align 4
  %31 = load i32, i32* %insn_idx.addr, align 4
  %cmp9 = icmp ne i32 %30, %31
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  br label %next150

if.end11:                                         ; preds = %while.body
  %32 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state12 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %32, i32 0, i32 0
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state12, i32 0, i32 2
  %33 = load i32, i32* %branches, align 8
  %tobool13 = icmp ne i32 %33, 0
  br i1 %tobool13, label %if.then14, label %if.end48

if.then14:                                        ; preds = %if.end11
  %34 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state15 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %34, i32 0, i32 0
  %frame16 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state15, i32 0, i32 0
  %35 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state17 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %35, i32 0, i32 0
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state17, i32 0, i32 4
  %36 = load i32, i32* %curframe, align 8
  %idxprom18 = zext i32 %36 to i64
  %arrayidx19 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame16, i64 0, i64 %idxprom18
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx19, align 8
  store %struct.bpf_func_state* %37, %struct.bpf_func_state** %frame, align 8
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %in_async_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %38, i32 0, i32 7
  %39 = load i8, i8* %in_async_callback_fn, align 8
  %tobool20 = trunc i8 %39 to i1
  br i1 %tobool20, label %land.lhs.true21, label %if.else

land.lhs.true21:                                  ; preds = %if.then14
  %40 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %async_entry_cnt = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %40, i32 0, i32 4
  %41 = load i32, i32* %async_entry_cnt, align 4
  %42 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame22 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %42, i32 0, i32 0
  %43 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe23 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %43, i32 0, i32 4
  %44 = load i32, i32* %curframe23, align 8
  %idxprom24 = zext i32 %44 to i64
  %arrayidx25 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame22, i64 0, i64 %idxprom24
  %45 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx25, align 8
  %async_entry_cnt26 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %45, i32 0, i32 4
  %46 = load i32, i32* %async_entry_cnt26, align 4
  %cmp27 = icmp ne i32 %41, %46
  br i1 %cmp27, label %if.then28, label %if.else

if.then28:                                        ; preds = %land.lhs.true21
  br label %if.end36

if.else:                                          ; preds = %land.lhs.true21, %if.then14
  %47 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state29 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %47, i32 0, i32 0
  %48 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call30 = call zeroext i1 @states_maybe_looping(%struct.bpf_verifier_state* noundef %state29, %struct.bpf_verifier_state* noundef %48) #20
  br i1 %call30, label %land.lhs.true31, label %if.end35

land.lhs.true31:                                  ; preds = %if.else
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state32 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %50, i32 0, i32 0
  %51 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call33 = call zeroext i1 @states_equal(%struct.bpf_verifier_env* noundef %49, %struct.bpf_verifier_state* noundef %state32, %struct.bpf_verifier_state* noundef %51) #20
  br i1 %call33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %land.lhs.true31
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load i32, i32* %insn_idx.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %52, i32 noundef %53, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.155, i64 0, i64 0)) #20
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  %56 = load i32, i32* %insn_idx.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.308, i64 0, i64 0), i32 noundef %56) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end35:                                         ; preds = %land.lhs.true31, %if.else
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then28
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed37 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %57, i32 0, i32 35
  %58 = load i32, i32* %jmps_processed37, align 4
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_jmps_processed38 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %59, i32 0, i32 34
  %60 = load i32, i32* %prev_jmps_processed38, align 8
  %sub39 = sub i32 %58, %60
  %cmp40 = icmp ult i32 %sub39, 20
  br i1 %cmp40, label %land.lhs.true41, label %if.end47

land.lhs.true41:                                  ; preds = %if.end36
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed42 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %61, i32 0, i32 33
  %62 = load i32, i32* %insn_processed42, align 4
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_processed43 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %63, i32 0, i32 32
  %64 = load i32, i32* %prev_insn_processed43, align 8
  %sub44 = sub i32 %62, %64
  %cmp45 = icmp ult i32 %sub44, 100
  br i1 %cmp45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %land.lhs.true41
  store i8 0, i8* %add_new_state, align 1
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %land.lhs.true41, %if.end36
  br label %miss

if.end48:                                         ; preds = %if.end11
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %66 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state49 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %66, i32 0, i32 0
  %67 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call50 = call zeroext i1 @states_equal(%struct.bpf_verifier_env* noundef %65, %struct.bpf_verifier_state* noundef %state49, %struct.bpf_verifier_state* noundef %67) #20
  br i1 %call50, label %if.then51, label %if.end68

if.then51:                                        ; preds = %if.end48
  %68 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %hit_cnt = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %68, i32 0, i32 3
  %69 = load i32, i32* %hit_cnt, align 4
  %inc52 = add i32 %69, 1
  store i32 %inc52, i32* %hit_cnt, align 4
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state53 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %71, i32 0, i32 0
  %72 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call54 = call i32 @propagate_liveness(%struct.bpf_verifier_env* noundef %70, %struct.bpf_verifier_state* noundef %state53, %struct.bpf_verifier_state* noundef %72) #20
  store i32 %call54, i32* %err, align 4
  %73 = load i32, i32* %err, align 4
  %tobool55 = icmp ne i32 %73, 0
  br i1 %tobool55, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then51
  br label %cond.end

cond.false:                                       ; preds = %if.then51
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call56 = call i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %74, %struct.bpf_verifier_state* noundef %75) #20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond57 = phi i32 [ %73, %cond.true ], [ %call56, %cond.false ]
  store i32 %cond57, i32* %err, align 4
  %76 = load i32, i32* %err, align 4
  %tobool58 = icmp ne i32 %76, 0
  br i1 %tobool58, label %cond.true59, label %cond.false60

cond.true59:                                      ; preds = %cond.end
  br label %cond.end63

cond.false60:                                     ; preds = %cond.end
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %78 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state61 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %78, i32 0, i32 0
  %call62 = call i32 @propagate_precision(%struct.bpf_verifier_env* noundef %77, %struct.bpf_verifier_state* noundef %state61) #20
  br label %cond.end63

cond.end63:                                       ; preds = %cond.false60, %cond.true59
  %cond64 = phi i32 [ %76, %cond.true59 ], [ %call62, %cond.false60 ]
  store i32 %cond64, i32* %err, align 4
  %79 = load i32, i32* %err, align 4
  %tobool65 = icmp ne i32 %79, 0
  br i1 %tobool65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %cond.end63
  %80 = load i32, i32* %err, align 4
  store i32 %80, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %cond.end63
  store i32 1, i32* %retval, align 4
  br label %return

if.end68:                                         ; preds = %if.end48
  br label %miss

miss:                                             ; preds = %if.end68, %if.end47
  %81 = load i8, i8* %add_new_state, align 1
  %tobool69 = trunc i8 %81 to i1
  br i1 %tobool69, label %if.then70, label %if.end72

if.then70:                                        ; preds = %miss
  %82 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %miss_cnt = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %82, i32 0, i32 2
  %83 = load i32, i32* %miss_cnt, align 8
  %inc71 = add i32 %83, 1
  store i32 %inc71, i32* %miss_cnt, align 8
  br label %if.end72

if.end72:                                         ; preds = %if.then70, %miss
  %84 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %miss_cnt73 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %84, i32 0, i32 2
  %85 = load i32, i32* %miss_cnt73, align 8
  %86 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %hit_cnt74 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %86, i32 0, i32 3
  %87 = load i32, i32* %hit_cnt74, align 4
  %mul = mul i32 %87, 3
  %add = add i32 %mul, 3
  %cmp75 = icmp sgt i32 %85, %add
  br i1 %cmp75, label %if.then76, label %if.end149

if.then76:                                        ; preds = %if.end72
  %88 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %88, i32 0, i32 1
  %89 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next, align 8
  %90 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  store %struct.bpf_verifier_state_list* %89, %struct.bpf_verifier_state_list** %90, align 8
  %91 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state77 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %91, i32 0, i32 0
  %frame78 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state77, i32 0, i32 0
  %arrayidx79 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame78, i64 0, i64 0
  %92 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx79, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %92, i32 0, i32 0
  %arrayidx80 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx80, i32 0, i32 17
  %93 = load i32, i32* %live, align 8
  %and = and i32 %93, 8
  %tobool81 = icmp ne i32 %and, 0
  br i1 %tobool81, label %if.then82, label %if.else145

if.then82:                                        ; preds = %if.then76
  %94 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state83 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %94, i32 0, i32 0
  %branches84 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state83, i32 0, i32 2
  %95 = load i32, i32* %branches84, align 8
  store i32 %95, i32* %br, align 4
  %96 = load i32, i32* %br, align 4
  %tobool85 = icmp ne i32 %96, 0
  %lnot = xor i1 %tobool85, true
  %lnot86 = xor i1 %lnot, true
  %frombool87 = zext i1 %lnot86 to i8
  store i8 %frombool87, i8* %__ret_do_once, align 1
  %97 = load i8, i8* %__ret_do_once, align 1
  %tobool88 = trunc i8 %97 to i1
  %lnot89 = xor i1 %tobool88, true
  %lnot90 = xor i1 %lnot89, true
  %frombool91 = zext i1 %lnot90 to i8
  store i8 %frombool91, i8* %__ret_cond, align 1
  store i8 0, i8* %__ret_once, align 1
  %98 = load i8, i8* %__ret_cond, align 1
  %tobool92 = trunc i8 %98 to i1
  br i1 %tobool92, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then82
  %99 = load i8, i8* @is_state_visited.__already_done, align 1
  %tobool93 = trunc i8 %99 to i1
  %lnot94 = xor i1 %tobool93, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then82
  %100 = phi i1 [ false, %if.then82 ], [ %lnot94, %land.rhs ]
  %lnot95 = xor i1 %100, true
  %lnot96 = xor i1 %lnot95, true
  %lnot.ext = zext i1 %lnot96 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool97 = icmp ne i64 %conv, 0
  br i1 %tobool97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %land.end
  store i8 1, i8* @is_state_visited.__already_done, align 1
  store i8 1, i8* %__ret_once, align 1
  br label %if.end99

if.end99:                                         ; preds = %if.then98, %land.end
  %101 = load i8, i8* %__ret_once, align 1
  %tobool100 = trunc i8 %101 to i1
  %lnot101 = xor i1 %tobool100, true
  %lnot103 = xor i1 %lnot101, true
  %lnot.ext104 = zext i1 %lnot103 to i32
  %conv105 = sext i32 %lnot.ext104 to i64
  store i64 %conv105, i64* %tmp, align 8
  %102 = load i64, i64* %tmp, align 8
  %tobool106 = icmp ne i64 %102, 0
  br i1 %tobool106, label %if.then107, label %if.end136

if.then107:                                       ; preds = %if.end99
  store i32 1, i32* %__ret_warn_on, align 4
  %103 = load i32, i32* %__ret_warn_on, align 4
  %tobool108 = icmp ne i32 %103, 0
  %lnot109 = xor i1 %tobool108, true
  %lnot111 = xor i1 %lnot109, true
  %lnot.ext112 = zext i1 %lnot111 to i32
  %conv113 = sext i32 %lnot.ext112 to i64
  %tobool114 = icmp ne i64 %conv113, 0
  br i1 %tobool114, label %if.then115, label %if.end128

if.then115:                                       ; preds = %if.then107
  br label %do.body

do.body:                                          ; preds = %if.then115
  br label %do.body116

do.body116:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body116
  %104 = load i32, i32* %br, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.309, i64 0, i64 0), i32 noundef %104) #20
  br label %do.body117

do.body117:                                       ; preds = %do.end
  store i32 2313, i32* %__flags, align 4
  br label %do.body118

do.body118:                                       ; preds = %do.body117
  br label %do.end119

do.end119:                                        ; preds = %do.body118
  br label %do.body120

do.body120:                                       ; preds = %do.end119
  %105 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 13969, i32 %105, i64 12) #19, !srcloc !99
  br label %do.end121

do.end121:                                        ; preds = %do.body120
  br label %do.body122

do.body122:                                       ; preds = %do.end121
  br label %do.end123

do.end123:                                        ; preds = %do.body122
  br label %do.end124

do.end124:                                        ; preds = %do.end123
  br label %do.body125

do.body125:                                       ; preds = %do.end124
  br label %do.end126

do.end126:                                        ; preds = %do.body125
  br label %do.end127

do.end127:                                        ; preds = %do.end126
  br label %if.end128

if.end128:                                        ; preds = %do.end127, %if.then107
  %106 = load i32, i32* %__ret_warn_on, align 4
  %tobool130 = icmp ne i32 %106, 0
  %lnot131 = xor i1 %tobool130, true
  %lnot133 = xor i1 %lnot131, true
  %lnot.ext134 = zext i1 %lnot133 to i32
  %conv135 = sext i32 %lnot.ext134 to i64
  store i64 %conv135, i64* %tmp129, align 8
  %107 = load i64, i64* %tmp129, align 8
  br label %if.end136

if.end136:                                        ; preds = %if.end128, %if.end99
  %108 = load i8, i8* %__ret_do_once, align 1
  %tobool138 = trunc i8 %108 to i1
  %lnot139 = xor i1 %tobool138, true
  %lnot141 = xor i1 %lnot139, true
  %lnot.ext142 = zext i1 %lnot141 to i32
  %conv143 = sext i32 %lnot.ext142 to i64
  store i64 %conv143, i64* %tmp137, align 8
  %109 = load i64, i64* %tmp137, align 8
  %110 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state144 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %110, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %state144, i1 noundef zeroext false) #20
  %111 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %112 = bitcast %struct.bpf_verifier_state_list* %111 to i8*
  call void @kfree(i8* noundef %112) #20
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %peak_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %113, i32 0, i32 39
  %114 = load i32, i32* %peak_states, align 8
  %dec = add i32 %114, -1
  store i32 %dec, i32* %peak_states, align 8
  br label %if.end148

if.else145:                                       ; preds = %if.then76
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %115, i32 0, i32 10
  %116 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %free_list, align 8
  %117 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next146 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %117, i32 0, i32 1
  store %struct.bpf_verifier_state_list* %116, %struct.bpf_verifier_state_list** %next146, align 8
  %118 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list147 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %119, i32 0, i32 10
  store %struct.bpf_verifier_state_list* %118, %struct.bpf_verifier_state_list** %free_list147, align 8
  br label %if.end148

if.end148:                                        ; preds = %if.else145, %if.end136
  %120 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  %121 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %120, align 8
  store %struct.bpf_verifier_state_list* %121, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond, !llvm.loop !100

if.end149:                                        ; preds = %if.end72
  br label %next150

next150:                                          ; preds = %if.end149, %if.then10
  %122 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next151 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %122, i32 0, i32 1
  store %struct.bpf_verifier_state_list** %next151, %struct.bpf_verifier_state_list*** %pprev, align 8
  %123 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  %124 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %123, align 8
  store %struct.bpf_verifier_state_list* %124, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond, !llvm.loop !100

while.end:                                        ; preds = %while.cond
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %max_states_per_insn = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %125, i32 0, i32 37
  %126 = load i32, i32* %max_states_per_insn, align 8
  %127 = load i32, i32* %states_cnt, align 4
  %cmp152 = icmp ult i32 %126, %127
  br i1 %cmp152, label %if.then154, label %if.end156

if.then154:                                       ; preds = %while.end
  %128 = load i32, i32* %states_cnt, align 4
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %max_states_per_insn155 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %129, i32 0, i32 37
  store i32 %128, i32* %max_states_per_insn155, align 8
  br label %if.end156

if.end156:                                        ; preds = %if.then154, %while.end
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %130, i32 0, i32 20
  %131 = load i8, i8* %bpf_capable, align 8
  %tobool157 = trunc i8 %131 to i1
  br i1 %tobool157, label %if.end163, label %land.lhs.true158

land.lhs.true158:                                 ; preds = %if.end156
  %132 = load i32, i32* %states_cnt, align 4
  %cmp159 = icmp sgt i32 %132, 64
  br i1 %cmp159, label %if.then161, label %if.end163

if.then161:                                       ; preds = %land.lhs.true158
  %133 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %134 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call162 = call i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %133, %struct.bpf_verifier_state* noundef %134) #20
  store i32 %call162, i32* %retval, align 4
  br label %return

if.end163:                                        ; preds = %land.lhs.true158, %if.end156
  %135 = load i8, i8* %add_new_state, align 1
  %tobool164 = trunc i8 %135 to i1
  br i1 %tobool164, label %if.end167, label %if.then165

if.then165:                                       ; preds = %if.end163
  %136 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %137 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call166 = call i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %136, %struct.bpf_verifier_state* noundef %137) #20
  store i32 %call166, i32* %retval, align 4
  br label %return

if.end167:                                        ; preds = %if.end163
  %call168 = call noalias i8* @kzalloc(i64 noundef 136, i32 noundef 3264) #24
  %138 = bitcast i8* %call168 to %struct.bpf_verifier_state_list*
  store %struct.bpf_verifier_state_list* %138, %struct.bpf_verifier_state_list** %new_sl, align 8
  %139 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %tobool169 = icmp ne %struct.bpf_verifier_state_list* %139, null
  br i1 %tobool169, label %if.end171, label %if.then170

if.then170:                                       ; preds = %if.end167
  store i32 -12, i32* %retval, align 4
  br label %return

if.end171:                                        ; preds = %if.end167
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %total_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %140, i32 0, i32 38
  %141 = load i32, i32* %total_states, align 4
  %inc172 = add i32 %141, 1
  store i32 %inc172, i32* %total_states, align 4
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %peak_states173 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %142, i32 0, i32 39
  %143 = load i32, i32* %peak_states173, align 8
  %inc174 = add i32 %143, 1
  store i32 %inc174, i32* %peak_states173, align 8
  %144 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed175 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %144, i32 0, i32 35
  %145 = load i32, i32* %jmps_processed175, align 4
  %146 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_jmps_processed176 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %146, i32 0, i32 34
  store i32 %145, i32* %prev_jmps_processed176, align 8
  %147 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed177 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %147, i32 0, i32 33
  %148 = load i32, i32* %insn_processed177, align 4
  %149 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_processed178 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %149, i32 0, i32 32
  store i32 %148, i32* %prev_insn_processed178, align 8
  %150 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %state179 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %150, i32 0, i32 0
  store %struct.bpf_verifier_state* %state179, %struct.bpf_verifier_state** %new, align 8
  %151 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %152 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call180 = call i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %151, %struct.bpf_verifier_state* noundef %152) #20
  store i32 %call180, i32* %err, align 4
  %153 = load i32, i32* %err, align 4
  %tobool181 = icmp ne i32 %153, 0
  br i1 %tobool181, label %if.then182, label %if.end183

if.then182:                                       ; preds = %if.end171
  %154 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %154, i1 noundef zeroext false) #20
  %155 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %156 = bitcast %struct.bpf_verifier_state_list* %155 to i8*
  call void @kfree(i8* noundef %156) #20
  %157 = load i32, i32* %err, align 4
  store i32 %157, i32* %retval, align 4
  br label %return

if.end183:                                        ; preds = %if.end171
  %158 = load i32, i32* %insn_idx.addr, align 4
  %159 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %insn_idx184 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %159, i32 0, i32 3
  store i32 %158, i32* %insn_idx184, align 4
  %160 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %branches186 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %160, i32 0, i32 2
  %161 = load i32, i32* %branches186, align 8
  %cmp187 = icmp ne i32 %161, 1
  %lnot189 = xor i1 %cmp187, true
  %lnot191 = xor i1 %lnot189, true
  %frombool193 = zext i1 %lnot191 to i8
  store i8 %frombool193, i8* %__ret_do_once185, align 1
  %162 = load i8, i8* %__ret_do_once185, align 1
  %tobool195 = trunc i8 %162 to i1
  %lnot196 = xor i1 %tobool195, true
  %lnot198 = xor i1 %lnot196, true
  %frombool200 = zext i1 %lnot198 to i8
  store i8 %frombool200, i8* %__ret_cond194, align 1
  store i8 0, i8* %__ret_once201, align 1
  %163 = load i8, i8* %__ret_cond194, align 1
  %tobool202 = trunc i8 %163 to i1
  br i1 %tobool202, label %land.rhs204, label %land.end208

land.rhs204:                                      ; preds = %if.end183
  %164 = load i8, i8* @is_state_visited.__already_done.310, align 1
  %tobool205 = trunc i8 %164 to i1
  %lnot206 = xor i1 %tobool205, true
  br label %land.end208

land.end208:                                      ; preds = %land.rhs204, %if.end183
  %165 = phi i1 [ false, %if.end183 ], [ %lnot206, %land.rhs204 ]
  %lnot209 = xor i1 %165, true
  %lnot211 = xor i1 %lnot209, true
  %lnot.ext212 = zext i1 %lnot211 to i32
  %conv213 = sext i32 %lnot.ext212 to i64
  %tobool214 = icmp ne i64 %conv213, 0
  br i1 %tobool214, label %if.then215, label %if.end216

if.then215:                                       ; preds = %land.end208
  store i8 1, i8* @is_state_visited.__already_done.310, align 1
  store i8 1, i8* %__ret_once201, align 1
  br label %if.end216

if.end216:                                        ; preds = %if.then215, %land.end208
  %166 = load i8, i8* %__ret_once201, align 1
  %tobool218 = trunc i8 %166 to i1
  %lnot219 = xor i1 %tobool218, true
  %lnot221 = xor i1 %lnot219, true
  %lnot.ext222 = zext i1 %lnot221 to i32
  %conv223 = sext i32 %lnot.ext222 to i64
  store i64 %conv223, i64* %tmp217, align 8
  %167 = load i64, i64* %tmp217, align 8
  %tobool224 = icmp ne i64 %167, 0
  br i1 %tobool224, label %if.then225, label %if.end259

if.then225:                                       ; preds = %if.end216
  store i32 1, i32* %__ret_warn_on226, align 4
  %168 = load i32, i32* %__ret_warn_on226, align 4
  %tobool227 = icmp ne i32 %168, 0
  %lnot228 = xor i1 %tobool227, true
  %lnot230 = xor i1 %lnot228, true
  %lnot.ext231 = zext i1 %lnot230 to i32
  %conv232 = sext i32 %lnot.ext231 to i64
  %tobool233 = icmp ne i64 %conv232, 0
  br i1 %tobool233, label %if.then234, label %if.end251

if.then234:                                       ; preds = %if.then225
  br label %do.body235

do.body235:                                       ; preds = %if.then234
  br label %do.body236

do.body236:                                       ; preds = %do.body235
  br label %do.end237

do.end237:                                        ; preds = %do.body236
  %169 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %branches238 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %169, i32 0, i32 2
  %170 = load i32, i32* %branches238, align 8
  %171 = load i32, i32* %insn_idx.addr, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.311, i64 0, i64 0), i32 noundef %170, i32 noundef %171) #20
  br label %do.body239

do.body239:                                       ; preds = %do.end237
  store i32 2313, i32* %__flags240, align 4
  br label %do.body241

do.body241:                                       ; preds = %do.body239
  br label %do.end242

do.end242:                                        ; preds = %do.body241
  br label %do.body243

do.body243:                                       ; preds = %do.end242
  %172 = load i32, i32* %__flags240, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 14025, i32 %172, i64 12) #19, !srcloc !101
  br label %do.end244

do.end244:                                        ; preds = %do.body243
  br label %do.body245

do.body245:                                       ; preds = %do.end244
  br label %do.end246

do.end246:                                        ; preds = %do.body245
  br label %do.end247

do.end247:                                        ; preds = %do.end246
  br label %do.body248

do.body248:                                       ; preds = %do.end247
  br label %do.end249

do.end249:                                        ; preds = %do.body248
  br label %do.end250

do.end250:                                        ; preds = %do.end249
  br label %if.end251

if.end251:                                        ; preds = %do.end250, %if.then225
  %173 = load i32, i32* %__ret_warn_on226, align 4
  %tobool253 = icmp ne i32 %173, 0
  %lnot254 = xor i1 %tobool253, true
  %lnot256 = xor i1 %lnot254, true
  %lnot.ext257 = zext i1 %lnot256 to i32
  %conv258 = sext i32 %lnot.ext257 to i64
  store i64 %conv258, i64* %tmp252, align 8
  %174 = load i64, i64* %tmp252, align 8
  br label %if.end259

if.end259:                                        ; preds = %if.end251, %if.end216
  %175 = load i8, i8* %__ret_do_once185, align 1
  %tobool261 = trunc i8 %175 to i1
  %lnot262 = xor i1 %tobool261, true
  %lnot264 = xor i1 %lnot262, true
  %lnot.ext265 = zext i1 %lnot264 to i32
  %conv266 = sext i32 %lnot.ext265 to i64
  store i64 %conv266, i64* %tmp260, align 8
  %176 = load i64, i64* %tmp260, align 8
  %177 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %178 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %178, i32 0, i32 1
  store %struct.bpf_verifier_state* %177, %struct.bpf_verifier_state** %parent, align 8
  %179 = load i32, i32* %insn_idx.addr, align 4
  %180 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %first_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %180, i32 0, i32 7
  store i32 %179, i32* %first_insn_idx, align 4
  %181 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  call void @clear_jmp_history(%struct.bpf_verifier_state* noundef %181) #20
  %182 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %183 = load i32, i32* %insn_idx.addr, align 4
  %call267 = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %182, i32 noundef %183) #20
  %184 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %call267, align 8
  %185 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %next268 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %185, i32 0, i32 1
  store %struct.bpf_verifier_state_list* %184, %struct.bpf_verifier_state_list** %next268, align 8
  %186 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %187 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %188 = load i32, i32* %insn_idx.addr, align 4
  %call269 = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %187, i32 noundef %188) #20
  store %struct.bpf_verifier_state_list* %186, %struct.bpf_verifier_state_list** %call269, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc309, %if.end259
  %189 = load i32, i32* %j, align 4
  %190 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe270 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %190, i32 0, i32 4
  %191 = load i32, i32* %curframe270, align 8
  %cmp271 = icmp ule i32 %189, %191
  br i1 %cmp271, label %for.body, label %for.end311

for.body:                                         ; preds = %for.cond
  %192 = load i32, i32* %j, align 4
  %193 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe273 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %193, i32 0, i32 4
  %194 = load i32, i32* %curframe273, align 8
  %cmp274 = icmp ult i32 %192, %194
  %195 = zext i1 %cmp274 to i64
  %cond276 = select i1 %cmp274, i32 6, i32 0
  store i32 %cond276, i32* %i, align 4
  br label %for.cond277

for.cond277:                                      ; preds = %for.inc, %for.body
  %196 = load i32, i32* %i, align 4
  %cmp278 = icmp slt i32 %196, 10
  br i1 %cmp278, label %for.body280, label %for.end

for.body280:                                      ; preds = %for.cond277
  %197 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %frame281 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %197, i32 0, i32 0
  %198 = load i32, i32* %j, align 4
  %idxprom282 = sext i32 %198 to i64
  %arrayidx283 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame281, i64 0, i64 %idxprom282
  %199 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx283, align 8
  %regs284 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %199, i32 0, i32 0
  %200 = load i32, i32* %i, align 4
  %idxprom285 = sext i32 %200 to i64
  %arrayidx286 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs284, i64 0, i64 %idxprom285
  %201 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame287 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %201, i32 0, i32 0
  %202 = load i32, i32* %j, align 4
  %idxprom288 = sext i32 %202 to i64
  %arrayidx289 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame287, i64 0, i64 %idxprom288
  %203 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx289, align 8
  %regs290 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %203, i32 0, i32 0
  %204 = load i32, i32* %i, align 4
  %idxprom291 = sext i32 %204 to i64
  %arrayidx292 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs290, i64 0, i64 %idxprom291
  %parent293 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx292, i32 0, i32 14
  store %struct.bpf_reg_state* %arrayidx286, %struct.bpf_reg_state** %parent293, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body280
  %205 = load i32, i32* %i, align 4
  %inc294 = add i32 %205, 1
  store i32 %inc294, i32* %i, align 4
  br label %for.cond277, !llvm.loop !102

for.end:                                          ; preds = %for.cond277
  store i32 0, i32* %i, align 4
  br label %for.cond295

for.cond295:                                      ; preds = %for.inc306, %for.end
  %206 = load i32, i32* %i, align 4
  %cmp296 = icmp slt i32 %206, 10
  br i1 %cmp296, label %for.body298, label %for.end308

for.body298:                                      ; preds = %for.cond295
  %207 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame299 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %207, i32 0, i32 0
  %208 = load i32, i32* %j, align 4
  %idxprom300 = sext i32 %208 to i64
  %arrayidx301 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame299, i64 0, i64 %idxprom300
  %209 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx301, align 8
  %regs302 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %209, i32 0, i32 0
  %210 = load i32, i32* %i, align 4
  %idxprom303 = sext i32 %210 to i64
  %arrayidx304 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs302, i64 0, i64 %idxprom303
  %live305 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx304, i32 0, i32 17
  store i32 0, i32* %live305, align 8
  br label %for.inc306

for.inc306:                                       ; preds = %for.body298
  %211 = load i32, i32* %i, align 4
  %inc307 = add i32 %211, 1
  store i32 %inc307, i32* %i, align 4
  br label %for.cond295, !llvm.loop !103

for.end308:                                       ; preds = %for.cond295
  br label %for.inc309

for.inc309:                                       ; preds = %for.end308
  %212 = load i32, i32* %j, align 4
  %inc310 = add i32 %212, 1
  store i32 %inc310, i32* %j, align 4
  br label %for.cond, !llvm.loop !104

for.end311:                                       ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond312

for.cond312:                                      ; preds = %for.inc343, %for.end311
  %213 = load i32, i32* %j, align 4
  %214 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe313 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %214, i32 0, i32 4
  %215 = load i32, i32* %curframe313, align 8
  %cmp314 = icmp ule i32 %213, %215
  br i1 %cmp314, label %for.body316, label %for.end345

for.body316:                                      ; preds = %for.cond312
  %216 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame318 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %216, i32 0, i32 0
  %217 = load i32, i32* %j, align 4
  %idxprom319 = sext i32 %217 to i64
  %arrayidx320 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame318, i64 0, i64 %idxprom319
  %218 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx320, align 8
  store %struct.bpf_func_state* %218, %struct.bpf_func_state** %frame317, align 8
  %219 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %frame321 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %219, i32 0, i32 0
  %220 = load i32, i32* %j, align 4
  %idxprom322 = sext i32 %220 to i64
  %arrayidx323 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame321, i64 0, i64 %idxprom322
  %221 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx323, align 8
  store %struct.bpf_func_state* %221, %struct.bpf_func_state** %newframe, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond324

for.cond324:                                      ; preds = %for.inc340, %for.body316
  %222 = load i32, i32* %i, align 4
  %223 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame317, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %223, i32 0, i32 10
  %224 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %224, 8
  %cmp325 = icmp slt i32 %222, %div
  br i1 %cmp325, label %for.body327, label %for.end342

for.body327:                                      ; preds = %for.cond324
  %225 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame317, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %225, i32 0, i32 11
  %226 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %227 = load i32, i32* %i, align 4
  %idxprom328 = sext i32 %227 to i64
  %arrayidx329 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %226, i64 %idxprom328
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx329, i32 0, i32 0
  %live330 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 17
  store i32 0, i32* %live330, align 8
  %228 = load %struct.bpf_func_state*, %struct.bpf_func_state** %newframe, align 8
  %stack331 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %228, i32 0, i32 11
  %229 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack331, align 8
  %230 = load i32, i32* %i, align 4
  %idxprom332 = sext i32 %230 to i64
  %arrayidx333 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %229, i64 %idxprom332
  %spilled_ptr334 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx333, i32 0, i32 0
  %231 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame317, align 8
  %stack335 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %231, i32 0, i32 11
  %232 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack335, align 8
  %233 = load i32, i32* %i, align 4
  %idxprom336 = sext i32 %233 to i64
  %arrayidx337 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %232, i64 %idxprom336
  %spilled_ptr338 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx337, i32 0, i32 0
  %parent339 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr338, i32 0, i32 14
  store %struct.bpf_reg_state* %spilled_ptr334, %struct.bpf_reg_state** %parent339, align 8
  br label %for.inc340

for.inc340:                                       ; preds = %for.body327
  %234 = load i32, i32* %i, align 4
  %inc341 = add i32 %234, 1
  store i32 %inc341, i32* %i, align 4
  br label %for.cond324, !llvm.loop !105

for.end342:                                       ; preds = %for.cond324
  br label %for.inc343

for.inc343:                                       ; preds = %for.end342
  %235 = load i32, i32* %j, align 4
  %inc344 = add i32 %235, 1
  store i32 %inc344, i32* %j, align 4
  br label %for.cond312, !llvm.loop !106

for.end345:                                       ; preds = %for.cond312
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end345, %if.then182, %if.then170, %if.then165, %if.then161, %if.end67, %if.then66, %if.then34, %if.then
  %236 = load i32, i32* %retval, align 4
  ret i32 %236
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @signal_pending(%struct.task_struct* noundef %p) #0 {
entry:
  %retval = alloca i32, align 4
  %p.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %p, %struct.task_struct** %p.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %p.addr, align 8
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* noundef %0, i32 noundef 17) #20
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.task_struct*, %struct.task_struct** %p.addr, align 8
  %call3 = call i32 @task_sigpending(%struct.task_struct* noundef %1) #20
  store i32 %call3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__might_resched(i8* noundef %file, i32 noundef %line, i32 noundef %offsets) #0 {
entry:
  %file.addr = alloca i8*, align 8
  %line.addr = alloca i32, align 4
  %offsets.addr = alloca i32, align 4
  store i8* %file, i8** %file.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  store i32 %offsets, i32* %offsets.addr, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @verifier_state_scratched(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %scratched_regs = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 42
  %1 = load i32, i32* %scratched_regs, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %scratched_stack_slots = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 43
  %3 = load i64, i64* %scratched_stack_slots, align 8
  %tobool1 = icmp ne i64 %3, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %tobool1, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_insn_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_log_len = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 44
  %1 = load i32, i32* %prev_log_len, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_log_len1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 44
  %3 = load i32, i32* %prev_log_len1, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 26
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 3
  %5 = load i32, i32* %len_used, align 8
  %cmp = icmp eq i32 %3, %5
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 26
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_log_len3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 44
  %8 = load i32, i32* %prev_log_len3, align 8
  %sub = sub i32 %8, 1
  call void @bpf_vlog_reset(%struct.bpf_verifier_log* noundef %log2, i32 noundef %sub) #20
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_print_len = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 45
  %12 = load i32, i32* %prev_insn_print_len, align 4
  %call = call i32 @vlog_alignment(i32 noundef %12) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.315, i64 0, i64 0), i32 noundef %call, i32 noundef 32) #20
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 0
  %16 = load i32, i32* %insn_idx, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.316, i64 0, i64 0), i32 noundef %16) #20
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %17, %struct.bpf_func_state* noundef %18, i1 noundef zeroext false) #20
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_offload_verify_insn(%struct.bpf_verifier_env* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @sanitize_mark_insn_seen(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 6
  %3 = load i8, i8* %speculative, align 8
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %pass_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 30
  %5 = load i32, i32* %pass_cnt, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 24
  %7 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 0
  %9 = load i32, i32* %insn_idx, align 8
  %idxprom = zext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %7, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  store i32 %5, i32* %seen, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_alu_op(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %opcode = alloca i8, align 1
  %err = alloca i32, align 4
  %src_reg141 = alloca %struct.bpf_reg_state*, align 8
  %dst_reg146 = alloca %struct.bpf_reg_state*, align 8
  %size = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 0
  %2 = load i8, i8* %code, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %opcode, align 1
  %3 = load i8, i8* %opcode, align 1
  %conv2 = zext i8 %3 to i32
  %cmp = icmp eq i32 %conv2, 208
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load i8, i8* %opcode, align 1
  %conv4 = zext i8 %4 to i32
  %cmp5 = icmp eq i32 %conv4, 128
  br i1 %cmp5, label %if.then, label %if.else83

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load i8, i8* %opcode, align 1
  %conv7 = zext i8 %5 to i32
  %cmp8 = icmp eq i32 %conv7, 128
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code11 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code11, align 4
  %conv12 = zext i8 %7 to i32
  %and13 = and i32 %conv12, 8
  %cmp14 = icmp ne i32 %and13, 0
  br i1 %cmp14, label %if.then27, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %if.then10
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv17 = zext i8 %bf.lshr to i32
  %cmp18 = icmp ne i32 %conv17, 0
  br i1 %cmp18, label %if.then27, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false16
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 2
  %10 = load i16, i16* %off, align 2
  %conv21 = sext i16 %10 to i32
  %cmp22 = icmp ne i32 %conv21, 0
  br i1 %cmp22, label %if.then27, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %lor.lhs.false20
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 3
  %12 = load i32, i32* %imm, align 4
  %cmp25 = icmp ne i32 %12, 0
  br i1 %cmp25, label %if.then27, label %if.end

if.then27:                                        ; preds = %lor.lhs.false24, %lor.lhs.false20, %lor.lhs.false16, %if.then10
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.317, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false24
  br label %if.end58

if.else:                                          ; preds = %if.then
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg28 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 1
  %bf.load29 = load i8, i8* %src_reg28, align 1
  %bf.lshr30 = lshr i8 %bf.load29, 4
  %conv31 = zext i8 %bf.lshr30 to i32
  %cmp32 = icmp ne i32 %conv31, 0
  br i1 %cmp32, label %if.then56, label %lor.lhs.false34

lor.lhs.false34:                                  ; preds = %if.else
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 2
  %17 = load i16, i16* %off35, align 2
  %conv36 = sext i16 %17 to i32
  %cmp37 = icmp ne i32 %conv36, 0
  br i1 %cmp37, label %if.then56, label %lor.lhs.false39

lor.lhs.false39:                                  ; preds = %lor.lhs.false34
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm40 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 3
  %19 = load i32, i32* %imm40, align 4
  %cmp41 = icmp ne i32 %19, 16
  br i1 %cmp41, label %land.lhs.true, label %lor.lhs.false50

land.lhs.true:                                    ; preds = %lor.lhs.false39
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 3
  %21 = load i32, i32* %imm43, align 4
  %cmp44 = icmp ne i32 %21, 32
  br i1 %cmp44, label %land.lhs.true46, label %lor.lhs.false50

land.lhs.true46:                                  ; preds = %land.lhs.true
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm47 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 3
  %23 = load i32, i32* %imm47, align 4
  %cmp48 = icmp ne i32 %23, 64
  br i1 %cmp48, label %if.then56, label %lor.lhs.false50

lor.lhs.false50:                                  ; preds = %land.lhs.true46, %land.lhs.true, %lor.lhs.false39
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code51 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 0
  %25 = load i8, i8* %code51, align 4
  %conv52 = zext i8 %25 to i32
  %and53 = and i32 %conv52, 7
  %cmp54 = icmp eq i32 %and53, 7
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %lor.lhs.false50, %land.lhs.true46, %lor.lhs.false34, %if.else
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.318, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end57:                                         ; preds = %lor.lhs.false50
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.end
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load59 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load59, 15
  %conv60 = zext i8 %bf.clear to i32
  %call61 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %28, i32 noundef %conv60, i32 noundef 0) #20
  store i32 %call61, i32* %err, align 4
  %30 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %30, 0
  br i1 %tobool, label %if.then62, label %if.end63

if.then62:                                        ; preds = %if.end58
  %31 = load i32, i32* %err, align 4
  store i32 %31, i32* %retval, align 4
  br label %return

if.end63:                                         ; preds = %if.end58
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg64 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %33, i32 0, i32 1
  %bf.load65 = load i8, i8* %dst_reg64, align 1
  %bf.clear66 = and i8 %bf.load65, 15
  %conv67 = zext i8 %bf.clear66 to i32
  %call68 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %32, i32 noundef %conv67) #20
  br i1 %call68, label %if.then69, label %if.end74

if.then69:                                        ; preds = %if.end63
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg70 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %36, i32 0, i32 1
  %bf.load71 = load i8, i8* %dst_reg70, align 1
  %bf.clear72 = and i8 %bf.load71, 15
  %conv73 = zext i8 %bf.clear72 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.319, i64 0, i64 0), i32 noundef %conv73) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %if.end63
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg75 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 1
  %bf.load76 = load i8, i8* %dst_reg75, align 1
  %bf.clear77 = and i8 %bf.load76, 15
  %conv78 = zext i8 %bf.clear77 to i32
  %call79 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %37, i32 noundef %conv78, i32 noundef 1) #20
  store i32 %call79, i32* %err, align 4
  %39 = load i32, i32* %err, align 4
  %tobool80 = icmp ne i32 %39, 0
  br i1 %tobool80, label %if.then81, label %if.end82

if.then81:                                        ; preds = %if.end74
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %if.end74
  br label %if.end345

if.else83:                                        ; preds = %lor.lhs.false
  %41 = load i8, i8* %opcode, align 1
  %conv84 = zext i8 %41 to i32
  %cmp85 = icmp eq i32 %conv84, 176
  br i1 %cmp85, label %if.then87, label %if.else228

if.then87:                                        ; preds = %if.else83
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code88 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %42, i32 0, i32 0
  %43 = load i8, i8* %code88, align 4
  %conv89 = zext i8 %43 to i32
  %and90 = and i32 %conv89, 8
  %cmp91 = icmp eq i32 %and90, 8
  br i1 %cmp91, label %if.then93, label %if.else112

if.then93:                                        ; preds = %if.then87
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm94 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 3
  %45 = load i32, i32* %imm94, align 4
  %cmp95 = icmp ne i32 %45, 0
  br i1 %cmp95, label %if.then102, label %lor.lhs.false97

lor.lhs.false97:                                  ; preds = %if.then93
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off98 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 2
  %47 = load i16, i16* %off98, align 2
  %conv99 = sext i16 %47 to i32
  %cmp100 = icmp ne i32 %conv99, 0
  br i1 %cmp100, label %if.then102, label %if.end103

if.then102:                                       ; preds = %lor.lhs.false97, %if.then93
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = bitcast %struct.bpf_verifier_env* %48 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %49, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.320, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end103:                                        ; preds = %lor.lhs.false97
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg104 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %51, i32 0, i32 1
  %bf.load105 = load i8, i8* %src_reg104, align 1
  %bf.lshr106 = lshr i8 %bf.load105, 4
  %conv107 = zext i8 %bf.lshr106 to i32
  %call108 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %50, i32 noundef %conv107, i32 noundef 0) #20
  store i32 %call108, i32* %err, align 4
  %52 = load i32, i32* %err, align 4
  %tobool109 = icmp ne i32 %52, 0
  br i1 %tobool109, label %if.then110, label %if.end111

if.then110:                                       ; preds = %if.end103
  %53 = load i32, i32* %err, align 4
  store i32 %53, i32* %retval, align 4
  br label %return

if.end111:                                        ; preds = %if.end103
  br label %if.end126

if.else112:                                       ; preds = %if.then87
  %54 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %54, i32 0, i32 1
  %bf.load114 = load i8, i8* %src_reg113, align 1
  %bf.lshr115 = lshr i8 %bf.load114, 4
  %conv116 = zext i8 %bf.lshr115 to i32
  %cmp117 = icmp ne i32 %conv116, 0
  br i1 %cmp117, label %if.then124, label %lor.lhs.false119

lor.lhs.false119:                                 ; preds = %if.else112
  %55 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off120 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %55, i32 0, i32 2
  %56 = load i16, i16* %off120, align 2
  %conv121 = sext i16 %56 to i32
  %cmp122 = icmp ne i32 %conv121, 0
  br i1 %cmp122, label %if.then124, label %if.end125

if.then124:                                       ; preds = %lor.lhs.false119, %if.else112
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = bitcast %struct.bpf_verifier_env* %57 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %58, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.320, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end125:                                        ; preds = %lor.lhs.false119
  br label %if.end126

if.end126:                                        ; preds = %if.end125, %if.end111
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg127 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %60, i32 0, i32 1
  %bf.load128 = load i8, i8* %dst_reg127, align 1
  %bf.clear129 = and i8 %bf.load128, 15
  %conv130 = zext i8 %bf.clear129 to i32
  %call131 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %59, i32 noundef %conv130, i32 noundef 2) #20
  store i32 %call131, i32* %err, align 4
  %61 = load i32, i32* %err, align 4
  %tobool132 = icmp ne i32 %61, 0
  br i1 %tobool132, label %if.then133, label %if.end134

if.then133:                                       ; preds = %if.end126
  %62 = load i32, i32* %err, align 4
  store i32 %62, i32* %retval, align 4
  br label %return

if.end134:                                        ; preds = %if.end126
  %63 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code135 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %63, i32 0, i32 0
  %64 = load i8, i8* %code135, align 4
  %conv136 = zext i8 %64 to i32
  %and137 = and i32 %conv136, 8
  %cmp138 = icmp eq i32 %and137, 8
  br i1 %cmp138, label %if.then140, label %if.else194

if.then140:                                       ; preds = %if.end134
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %66 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg142 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %66, i32 0, i32 1
  %bf.load143 = load i8, i8* %src_reg142, align 1
  %bf.lshr144 = lshr i8 %bf.load143, 4
  %conv145 = zext i8 %bf.lshr144 to i32
  %idx.ext = sext i32 %conv145 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %src_reg141, align 8
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %68 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg147 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %68, i32 0, i32 1
  %bf.load148 = load i8, i8* %dst_reg147, align 1
  %bf.clear149 = and i8 %bf.load148, 15
  %conv150 = zext i8 %bf.clear149 to i32
  %idx.ext151 = sext i32 %conv150 to i64
  %add.ptr152 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i64 %idx.ext151
  store %struct.bpf_reg_state* %add.ptr152, %struct.bpf_reg_state** %dst_reg146, align 8
  %69 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code153 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %69, i32 0, i32 0
  %70 = load i8, i8* %code153, align 4
  %conv154 = zext i8 %70 to i32
  %and155 = and i32 %conv154, 7
  %cmp156 = icmp eq i32 %and155, 7
  br i1 %cmp156, label %if.then158, label %if.else166

if.then158:                                       ; preds = %if.then140
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 0
  %72 = load i32, i32* %type, align 8
  %cmp159 = icmp eq i32 %72, 1
  br i1 %cmp159, label %land.lhs.true161, label %if.end165

land.lhs.true161:                                 ; preds = %if.then158
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %73, i32 0, i32 3
  %74 = load i32, i32* %id, align 8
  %tobool162 = icmp ne i32 %74, 0
  br i1 %tobool162, label %if.end165, label %if.then163

if.then163:                                       ; preds = %land.lhs.true161
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %75, i32 0, i32 15
  %76 = load i32, i32* %id_gen, align 8
  %inc = add i32 %76, 1
  store i32 %inc, i32* %id_gen, align 8
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %id164 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 3
  store i32 %inc, i32* %id164, align 8
  br label %if.end165

if.end165:                                        ; preds = %if.then163, %land.lhs.true161, %if.then158
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %80 = bitcast %struct.bpf_reg_state* %78 to i8*
  %81 = bitcast %struct.bpf_reg_state* %79 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %80, i8* align 8 %81, i64 120, i1 false)
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 17
  %83 = load i32, i32* %live, align 8
  %or = or i32 %83, 4
  store i32 %or, i32* %live, align 8
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %84, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  br label %if.end193

if.else166:                                       ; preds = %if.then140
  %85 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %86 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg167 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %86, i32 0, i32 1
  %bf.load168 = load i8, i8* %src_reg167, align 1
  %bf.lshr169 = lshr i8 %bf.load168, 4
  %conv170 = zext i8 %bf.lshr169 to i32
  %call171 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %85, i32 noundef %conv170) #20
  br i1 %call171, label %if.then172, label %if.else177

if.then172:                                       ; preds = %if.else166
  %87 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %88 = bitcast %struct.bpf_verifier_env* %87 to i8*
  %89 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg173 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %89, i32 0, i32 1
  %bf.load174 = load i8, i8* %src_reg173, align 1
  %bf.lshr175 = lshr i8 %bf.load174, 4
  %conv176 = zext i8 %bf.lshr175 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %88, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.321, i64 0, i64 0), i32 noundef %conv176) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.else177:                                       ; preds = %if.else166
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %type178 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %90, i32 0, i32 0
  %91 = load i32, i32* %type178, align 8
  %cmp179 = icmp eq i32 %91, 1
  br i1 %cmp179, label %if.then181, label %if.else186

if.then181:                                       ; preds = %if.else177
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %94 = bitcast %struct.bpf_reg_state* %92 to i8*
  %95 = bitcast %struct.bpf_reg_state* %93 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %94, i8* align 8 %95, i64 120, i1 false)
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %id182 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %96, i32 0, i32 3
  store i32 0, i32* %id182, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %live183 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 17
  %98 = load i32, i32* %live183, align 8
  %or184 = or i32 %98, 4
  store i32 %or184, i32* %live183, align 8
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %99, i32 0, i32 0
  %100 = load i32, i32* %insn_idx, align 8
  %add = add i32 %100, 1
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %subreg_def185 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %101, i32 0, i32 16
  store i32 %add, i32* %subreg_def185, align 4
  br label %if.end191

if.else186:                                       ; preds = %if.else177
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %104 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg187 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %104, i32 0, i32 1
  %bf.load188 = load i8, i8* %dst_reg187, align 1
  %bf.clear189 = and i8 %bf.load188, 15
  %conv190 = zext i8 %bf.clear189 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %102, %struct.bpf_reg_state* noundef %103, i32 noundef %conv190) #20
  br label %if.end191

if.end191:                                        ; preds = %if.else186, %if.then181
  br label %if.end192

if.end192:                                        ; preds = %if.end191
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  call void @zext_32_to_64(%struct.bpf_reg_state* noundef %105) #20
  %106 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  call void @reg_bounds_sync(%struct.bpf_reg_state* noundef %106) #20
  br label %if.end193

if.end193:                                        ; preds = %if.end192, %if.end165
  br label %if.end227

if.else194:                                       ; preds = %if.end134
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %108 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %109 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg195 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %109, i32 0, i32 1
  %bf.load196 = load i8, i8* %dst_reg195, align 1
  %bf.clear197 = and i8 %bf.load196, 15
  %conv198 = zext i8 %bf.clear197 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %107, %struct.bpf_reg_state* noundef %108, i32 noundef %conv198) #20
  %110 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %111 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg199 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %111, i32 0, i32 1
  %bf.load200 = load i8, i8* %dst_reg199, align 1
  %bf.clear201 = and i8 %bf.load200, 15
  %idxprom = zext i8 %bf.clear201 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %110, i64 %idxprom
  %type202 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  store i32 1, i32* %type202, align 8
  %112 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code203 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %112, i32 0, i32 0
  %113 = load i8, i8* %code203, align 4
  %conv204 = zext i8 %113 to i32
  %and205 = and i32 %conv204, 7
  %cmp206 = icmp eq i32 %and205, 7
  br i1 %cmp206, label %if.then208, label %if.else217

if.then208:                                       ; preds = %if.else194
  %114 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %115 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg209 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %115, i32 0, i32 1
  %bf.load210 = load i8, i8* %dst_reg209, align 1
  %bf.clear211 = and i8 %bf.load210, 15
  %conv212 = zext i8 %bf.clear211 to i32
  %idx.ext213 = sext i32 %conv212 to i64
  %add.ptr214 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %114, i64 %idx.ext213
  %116 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm215 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %116, i32 0, i32 3
  %117 = load i32, i32* %imm215, align 4
  %conv216 = sext i32 %117 to i64
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %add.ptr214, i64 noundef %conv216) #20
  br label %if.end226

if.else217:                                       ; preds = %if.else194
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %119 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg218 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %119, i32 0, i32 1
  %bf.load219 = load i8, i8* %dst_reg218, align 1
  %bf.clear220 = and i8 %bf.load219, 15
  %conv221 = zext i8 %bf.clear220 to i32
  %idx.ext222 = sext i32 %conv221 to i64
  %add.ptr223 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i64 %idx.ext222
  %120 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm224 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %120, i32 0, i32 3
  %121 = load i32, i32* %imm224, align 4
  %conv225 = zext i32 %121 to i64
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %add.ptr223, i64 noundef %conv225) #20
  br label %if.end226

if.end226:                                        ; preds = %if.else217, %if.then208
  br label %if.end227

if.end227:                                        ; preds = %if.end226, %if.end193
  br label %if.end344

if.else228:                                       ; preds = %if.else83
  %122 = load i8, i8* %opcode, align 1
  %conv229 = zext i8 %122 to i32
  %cmp230 = icmp sgt i32 %conv229, 208
  br i1 %cmp230, label %if.then232, label %if.else234

if.then232:                                       ; preds = %if.else228
  %123 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %124 = bitcast %struct.bpf_verifier_env* %123 to i8*
  %125 = load i8, i8* %opcode, align 1
  %conv233 = zext i8 %125 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %124, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.322, i64 0, i64 0), i32 noundef %conv233) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.else234:                                       ; preds = %if.else228
  %126 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code235 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %126, i32 0, i32 0
  %127 = load i8, i8* %code235, align 4
  %conv236 = zext i8 %127 to i32
  %and237 = and i32 %conv236, 8
  %cmp238 = icmp eq i32 %and237, 8
  br i1 %cmp238, label %if.then240, label %if.else259

if.then240:                                       ; preds = %if.else234
  %128 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm241 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %128, i32 0, i32 3
  %129 = load i32, i32* %imm241, align 4
  %cmp242 = icmp ne i32 %129, 0
  br i1 %cmp242, label %if.then249, label %lor.lhs.false244

lor.lhs.false244:                                 ; preds = %if.then240
  %130 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off245 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %130, i32 0, i32 2
  %131 = load i16, i16* %off245, align 2
  %conv246 = sext i16 %131 to i32
  %cmp247 = icmp ne i32 %conv246, 0
  br i1 %cmp247, label %if.then249, label %if.end250

if.then249:                                       ; preds = %lor.lhs.false244, %if.then240
  %132 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %133 = bitcast %struct.bpf_verifier_env* %132 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %133, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.323, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end250:                                        ; preds = %lor.lhs.false244
  %134 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %135 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg251 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %135, i32 0, i32 1
  %bf.load252 = load i8, i8* %src_reg251, align 1
  %bf.lshr253 = lshr i8 %bf.load252, 4
  %conv254 = zext i8 %bf.lshr253 to i32
  %call255 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %134, i32 noundef %conv254, i32 noundef 0) #20
  store i32 %call255, i32* %err, align 4
  %136 = load i32, i32* %err, align 4
  %tobool256 = icmp ne i32 %136, 0
  br i1 %tobool256, label %if.then257, label %if.end258

if.then257:                                       ; preds = %if.end250
  %137 = load i32, i32* %err, align 4
  store i32 %137, i32* %retval, align 4
  br label %return

if.end258:                                        ; preds = %if.end250
  br label %if.end273

if.else259:                                       ; preds = %if.else234
  %138 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg260 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %138, i32 0, i32 1
  %bf.load261 = load i8, i8* %src_reg260, align 1
  %bf.lshr262 = lshr i8 %bf.load261, 4
  %conv263 = zext i8 %bf.lshr262 to i32
  %cmp264 = icmp ne i32 %conv263, 0
  br i1 %cmp264, label %if.then271, label %lor.lhs.false266

lor.lhs.false266:                                 ; preds = %if.else259
  %139 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off267 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %139, i32 0, i32 2
  %140 = load i16, i16* %off267, align 2
  %conv268 = sext i16 %140 to i32
  %cmp269 = icmp ne i32 %conv268, 0
  br i1 %cmp269, label %if.then271, label %if.end272

if.then271:                                       ; preds = %lor.lhs.false266, %if.else259
  %141 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %142 = bitcast %struct.bpf_verifier_env* %141 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %142, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.323, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end272:                                        ; preds = %lor.lhs.false266
  br label %if.end273

if.end273:                                        ; preds = %if.end272, %if.end258
  %143 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %144 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg274 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %144, i32 0, i32 1
  %bf.load275 = load i8, i8* %dst_reg274, align 1
  %bf.clear276 = and i8 %bf.load275, 15
  %conv277 = zext i8 %bf.clear276 to i32
  %call278 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %143, i32 noundef %conv277, i32 noundef 0) #20
  store i32 %call278, i32* %err, align 4
  %145 = load i32, i32* %err, align 4
  %tobool279 = icmp ne i32 %145, 0
  br i1 %tobool279, label %if.then280, label %if.end281

if.then280:                                       ; preds = %if.end273
  %146 = load i32, i32* %err, align 4
  store i32 %146, i32* %retval, align 4
  br label %return

if.end281:                                        ; preds = %if.end273
  %147 = load i8, i8* %opcode, align 1
  %conv282 = zext i8 %147 to i32
  %cmp283 = icmp eq i32 %conv282, 144
  br i1 %cmp283, label %land.lhs.true289, label %lor.lhs.false285

lor.lhs.false285:                                 ; preds = %if.end281
  %148 = load i8, i8* %opcode, align 1
  %conv286 = zext i8 %148 to i32
  %cmp287 = icmp eq i32 %conv286, 48
  br i1 %cmp287, label %land.lhs.true289, label %if.end300

land.lhs.true289:                                 ; preds = %lor.lhs.false285, %if.end281
  %149 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code290 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %149, i32 0, i32 0
  %150 = load i8, i8* %code290, align 4
  %conv291 = zext i8 %150 to i32
  %and292 = and i32 %conv291, 8
  %cmp293 = icmp eq i32 %and292, 0
  br i1 %cmp293, label %land.lhs.true295, label %if.end300

land.lhs.true295:                                 ; preds = %land.lhs.true289
  %151 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm296 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %151, i32 0, i32 3
  %152 = load i32, i32* %imm296, align 4
  %cmp297 = icmp eq i32 %152, 0
  br i1 %cmp297, label %if.then299, label %if.end300

if.then299:                                       ; preds = %land.lhs.true295
  %153 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %154 = bitcast %struct.bpf_verifier_env* %153 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %154, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.324, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end300:                                        ; preds = %land.lhs.true295, %land.lhs.true289, %lor.lhs.false285
  %155 = load i8, i8* %opcode, align 1
  %conv301 = zext i8 %155 to i32
  %cmp302 = icmp eq i32 %conv301, 96
  br i1 %cmp302, label %land.lhs.true312, label %lor.lhs.false304

lor.lhs.false304:                                 ; preds = %if.end300
  %156 = load i8, i8* %opcode, align 1
  %conv305 = zext i8 %156 to i32
  %cmp306 = icmp eq i32 %conv305, 112
  br i1 %cmp306, label %land.lhs.true312, label %lor.lhs.false308

lor.lhs.false308:                                 ; preds = %lor.lhs.false304
  %157 = load i8, i8* %opcode, align 1
  %conv309 = zext i8 %157 to i32
  %cmp310 = icmp eq i32 %conv309, 192
  br i1 %cmp310, label %land.lhs.true312, label %if.end334

land.lhs.true312:                                 ; preds = %lor.lhs.false308, %lor.lhs.false304, %if.end300
  %158 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code313 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %158, i32 0, i32 0
  %159 = load i8, i8* %code313, align 4
  %conv314 = zext i8 %159 to i32
  %and315 = and i32 %conv314, 8
  %cmp316 = icmp eq i32 %and315, 0
  br i1 %cmp316, label %if.then318, label %if.end334

if.then318:                                       ; preds = %land.lhs.true312
  %160 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code319 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %160, i32 0, i32 0
  %161 = load i8, i8* %code319, align 4
  %conv320 = zext i8 %161 to i32
  %and321 = and i32 %conv320, 7
  %cmp322 = icmp eq i32 %and321, 7
  %162 = zext i1 %cmp322 to i64
  %cond = select i1 %cmp322, i32 64, i32 32
  store i32 %cond, i32* %size, align 4
  %163 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm324 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %163, i32 0, i32 3
  %164 = load i32, i32* %imm324, align 4
  %cmp325 = icmp slt i32 %164, 0
  br i1 %cmp325, label %if.then331, label %lor.lhs.false327

lor.lhs.false327:                                 ; preds = %if.then318
  %165 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm328 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %165, i32 0, i32 3
  %166 = load i32, i32* %imm328, align 4
  %167 = load i32, i32* %size, align 4
  %cmp329 = icmp sge i32 %166, %167
  br i1 %cmp329, label %if.then331, label %if.end333

if.then331:                                       ; preds = %lor.lhs.false327, %if.then318
  %168 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %169 = bitcast %struct.bpf_verifier_env* %168 to i8*
  %170 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm332 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %170, i32 0, i32 3
  %171 = load i32, i32* %imm332, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %169, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.325, i64 0, i64 0), i32 noundef %171) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end333:                                        ; preds = %lor.lhs.false327
  br label %if.end334

if.end334:                                        ; preds = %if.end333, %land.lhs.true312, %lor.lhs.false308
  %172 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %173 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg335 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %173, i32 0, i32 1
  %bf.load336 = load i8, i8* %dst_reg335, align 1
  %bf.clear337 = and i8 %bf.load336, 15
  %conv338 = zext i8 %bf.clear337 to i32
  %call339 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %172, i32 noundef %conv338, i32 noundef 2) #20
  store i32 %call339, i32* %err, align 4
  %174 = load i32, i32* %err, align 4
  %tobool340 = icmp ne i32 %174, 0
  br i1 %tobool340, label %if.then341, label %if.end342

if.then341:                                       ; preds = %if.end334
  %175 = load i32, i32* %err, align 4
  store i32 %175, i32* %retval, align 4
  br label %return

if.end342:                                        ; preds = %if.end334
  %176 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %177 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call343 = call i32 @adjust_reg_min_max_vals(%struct.bpf_verifier_env* noundef %176, %struct.bpf_insn* noundef %177) #20
  store i32 %call343, i32* %retval, align 4
  br label %return

if.end344:                                        ; preds = %if.end227
  br label %if.end345

if.end345:                                        ; preds = %if.end344, %if.end82
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end345, %if.end342, %if.then341, %if.then331, %if.then299, %if.then280, %if.then271, %if.then257, %if.then249, %if.then232, %if.then172, %if.then133, %if.then124, %if.then110, %if.then102, %if.then81, %if.then69, %if.then62, %if.then56, %if.then27
  %178 = load i32, i32* %retval, align 4
  ret i32 %178
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %t) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %rw64 = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %8 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 12
  %9 = bitcast %union.anon.198* %8 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %9, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 0
  %11 = load i32, i32* %insn_idx, align 8
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %insn, align 8
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay2, %struct.bpf_reg_state** %regs, align 8
  %13 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %13, 11
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([16 x i8], [16 x i8]* @.str.344, i64 0, i64 0), i32 noundef %16) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %regno.addr, align 4
  call void @mark_reg_scratched(%struct.bpf_verifier_env* noundef %17, i32 noundef %18) #20
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %20 = load i32, i32* %regno.addr, align 4
  %idxprom3 = zext i32 %20 to i64
  %arrayidx4 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i64 %idxprom3
  store %struct.bpf_reg_state* %arrayidx4, %struct.bpf_reg_state** %reg, align 8
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %23 = load i32, i32* %regno.addr, align 4
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %25 = load i32, i32* %t.addr, align 4
  %call = call zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %21, %struct.bpf_insn* noundef %22, i32 noundef %23, %struct.bpf_reg_state* noundef %24, i32 noundef %25) #20
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %rw64, align 1
  %26 = load i32, i32* %t.addr, align 4
  %cmp5 = icmp eq i32 %26, 0
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 0
  %28 = load i32, i32* %type, align 8
  %cmp7 = icmp eq i32 %28, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.then6
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.345, i64 0, i64 0), i32 noundef %31) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.then6
  %32 = load i32, i32* %regno.addr, align 4
  %cmp10 = icmp eq i32 %32, 10
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  store i32 0, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end9
  %33 = load i8, i8* %rw64, align 1
  %tobool = trunc i8 %33 to i1
  br i1 %tobool, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end12
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @mark_insn_zext(%struct.bpf_verifier_env* noundef %34, %struct.bpf_reg_state* noundef %35) #20
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end12
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 14
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %40 = load i8, i8* %rw64, align 1
  %tobool15 = trunc i8 %40 to i1
  %41 = zext i1 %tobool15 to i64
  %cond = select i1 %tobool15, i32 2, i32 1
  %conv = trunc i32 %cond to i8
  %call16 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %36, %struct.bpf_reg_state* noundef %37, %struct.bpf_reg_state* noundef %39, i8 noundef zeroext %conv) #20
  store i32 %call16, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end
  %42 = load i32, i32* %regno.addr, align 4
  %cmp17 = icmp eq i32 %42, 10
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.else
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = bitcast %struct.bpf_verifier_env* %43 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %44, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.346, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.else
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 17
  %46 = load i32, i32* %live, align 8
  %or = or i32 %46, 4
  store i32 %or, i32* %live, align 8
  %47 = load i8, i8* %rw64, align 1
  %tobool21 = trunc i8 %47 to i1
  br i1 %tobool21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end20
  br label %cond.end

cond.false:                                       ; preds = %if.end20
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx23 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %48, i32 0, i32 0
  %49 = load i32, i32* %insn_idx23, align 8
  %add = add i32 %49, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond24 = phi i32 [ 0, %cond.true ], [ %add, %cond.false ]
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 16
  store i32 %cond24, i32* %subreg_def, align 4
  %51 = load i32, i32* %t.addr, align 4
  %cmp25 = icmp eq i32 %51, 1
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %cond.end
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %54 = load i32, i32* %regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %52, %struct.bpf_reg_state* noundef %53, i32 noundef %54) #20
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %cond.end
  br label %if.end29

if.end29:                                         ; preds = %if.end28
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end29, %if.then19, %if.end14, %if.then11, %if.then8, %if.then
  %55 = load i32, i32* %retval, align 4
  ret i32 %55
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_mismatch(i32 noundef %src, i32 noundef %prev) #0 {
entry:
  %src.addr = alloca i32, align 4
  %prev.addr = alloca i32, align 4
  store i32 %src, i32* %src.addr, align 4
  store i32 %prev, i32* %prev.addr, align 4
  %0 = load i32, i32* %src.addr, align 4
  %1 = load i32, i32* %prev.addr, align 4
  %cmp = icmp ne i32 %0, %1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load i32, i32* %src.addr, align 4
  %call = call zeroext i1 @reg_type_mismatch_ok(i32 noundef %2) #20
  br i1 %call, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.rhs
  %3 = load i32, i32* %prev.addr, align 4
  %call1 = call zeroext i1 @reg_type_mismatch_ok(i32 noundef %3) #20
  %lnot = xor i1 %call1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %4 = phi i1 [ true, %land.rhs ], [ %lnot, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %entry
  %5 = phi i1 [ false, %entry ], [ %4, %lor.end ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_atomic(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %load_reg = alloca i32, align 4
  %err = alloca i32, align 4
  %aux_reg = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 3
  %1 = load i32, i32* %imm, align 4
  switch i32 %1, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb
    i32 80, label %sw.bb
    i32 81, label %sw.bb
    i32 64, label %sw.bb
    i32 65, label %sw.bb
    i32 160, label %sw.bb
    i32 161, label %sw.bb
    i32 225, label %sw.bb
    i32 241, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 3
  %5 = load i32, i32* %imm1, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.347, i64 0, i64 0), i32 noundef %5) #20
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code, align 4
  %conv = zext i8 %7 to i32
  %and = and i32 %conv, 24
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %sw.epilog
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code3 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 0
  %9 = load i8, i8* %code3, align 4
  %conv4 = zext i8 %9 to i32
  %and5 = and i32 %conv4, 24
  %cmp6 = icmp ne i32 %and5, 24
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.348, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %sw.epilog
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv8 = zext i8 %bf.lshr to i32
  %call = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %12, i32 noundef %conv8, i32 noundef 0) #20
  store i32 %call, i32* %err, align 4
  %14 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %15 = load i32, i32* %err, align 4
  store i32 %15, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %17, i32 0, i32 1
  %bf.load11 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load11, 15
  %conv12 = zext i8 %bf.clear to i32
  %call13 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %16, i32 noundef %conv12, i32 noundef 0) #20
  store i32 %call13, i32* %err, align 4
  %18 = load i32, i32* %err, align 4
  %tobool14 = icmp ne i32 %18, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end10
  %19 = load i32, i32* %err, align 4
  store i32 %19, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end10
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm17 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 3
  %21 = load i32, i32* %imm17, align 4
  %cmp18 = icmp eq i32 %21, 241
  br i1 %cmp18, label %if.then20, label %if.end28

if.then20:                                        ; preds = %if.end16
  store i32 0, i32* %aux_reg, align 4
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call21 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %22, i32 noundef 0, i32 noundef 0) #20
  store i32 %call21, i32* %err, align 4
  %23 = load i32, i32* %err, align 4
  %tobool22 = icmp ne i32 %23, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.then20
  %24 = load i32, i32* %err, align 4
  store i32 %24, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.then20
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call25 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %25, i32 noundef 0) #20
  br i1 %call25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end24
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.153, i64 0, i64 0), i32 noundef 0) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.end24
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end16
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg29 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load30 = load i8, i8* %src_reg29, align 1
  %bf.lshr31 = lshr i8 %bf.load30, 4
  %conv32 = zext i8 %bf.lshr31 to i32
  %call33 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %28, i32 noundef %conv32) #20
  br i1 %call33, label %if.then34, label %if.end39

if.then34:                                        ; preds = %if.end28
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %32, i32 0, i32 1
  %bf.load36 = load i8, i8* %src_reg35, align 1
  %bf.lshr37 = lshr i8 %bf.load36, 4
  %conv38 = zext i8 %bf.lshr37 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.153, i64 0, i64 0), i32 noundef %conv38) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end39:                                         ; preds = %if.end28
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg40 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %34, i32 0, i32 1
  %bf.load41 = load i8, i8* %dst_reg40, align 1
  %bf.clear42 = and i8 %bf.load41, 15
  %conv43 = zext i8 %bf.clear42 to i32
  %call44 = call zeroext i1 @is_ctx_reg(%struct.bpf_verifier_env* noundef %33, i32 noundef %conv43) #20
  br i1 %call44, label %if.then66, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end39
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg46 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %36, i32 0, i32 1
  %bf.load47 = load i8, i8* %dst_reg46, align 1
  %bf.clear48 = and i8 %bf.load47, 15
  %conv49 = zext i8 %bf.clear48 to i32
  %call50 = call zeroext i1 @is_pkt_reg(%struct.bpf_verifier_env* noundef %35, i32 noundef %conv49) #20
  br i1 %call50, label %if.then66, label %lor.lhs.false52

lor.lhs.false52:                                  ; preds = %lor.lhs.false
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg53 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 1
  %bf.load54 = load i8, i8* %dst_reg53, align 1
  %bf.clear55 = and i8 %bf.load54, 15
  %conv56 = zext i8 %bf.clear55 to i32
  %call57 = call zeroext i1 @is_flow_key_reg(%struct.bpf_verifier_env* noundef %37, i32 noundef %conv56) #20
  br i1 %call57, label %if.then66, label %lor.lhs.false59

lor.lhs.false59:                                  ; preds = %lor.lhs.false52
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %40, i32 0, i32 1
  %bf.load61 = load i8, i8* %dst_reg60, align 1
  %bf.clear62 = and i8 %bf.load61, 15
  %conv63 = zext i8 %bf.clear62 to i32
  %call64 = call zeroext i1 @is_sk_reg(%struct.bpf_verifier_env* noundef %39, i32 noundef %conv63) #20
  br i1 %call64, label %if.then66, label %if.end77

if.then66:                                        ; preds = %lor.lhs.false59, %lor.lhs.false52, %lor.lhs.false, %if.end39
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg67 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %43, i32 0, i32 1
  %bf.load68 = load i8, i8* %dst_reg67, align 1
  %bf.clear69 = and i8 %bf.load68, 15
  %conv70 = zext i8 %bf.clear69 to i32
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg71 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 1
  %bf.load72 = load i8, i8* %dst_reg71, align 1
  %bf.clear73 = and i8 %bf.load72, 15
  %conv74 = zext i8 %bf.clear73 to i32
  %call75 = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %45, i32 noundef %conv74) #20
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %call75, i32 0, i32 0
  %47 = load i32, i32* %type, align 8
  %call76 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %44, i32 noundef %47) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.349, i64 0, i64 0), i32 noundef %conv70, i8* noundef %call76) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %lor.lhs.false59
  %48 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm78 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %48, i32 0, i32 3
  %49 = load i32, i32* %imm78, align 4
  %and79 = and i32 %49, 1
  %tobool80 = icmp ne i32 %and79, 0
  br i1 %tobool80, label %if.then81, label %if.else95

if.then81:                                        ; preds = %if.end77
  %50 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm82 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %50, i32 0, i32 3
  %51 = load i32, i32* %imm82, align 4
  %cmp83 = icmp eq i32 %51, 241
  br i1 %cmp83, label %if.then85, label %if.else

if.then85:                                        ; preds = %if.then81
  store i32 0, i32* %load_reg, align 4
  br label %if.end90

if.else:                                          ; preds = %if.then81
  %52 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg86 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %52, i32 0, i32 1
  %bf.load87 = load i8, i8* %src_reg86, align 1
  %bf.lshr88 = lshr i8 %bf.load87, 4
  %conv89 = zext i8 %bf.lshr88 to i32
  store i32 %conv89, i32* %load_reg, align 4
  br label %if.end90

if.end90:                                         ; preds = %if.else, %if.then85
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = load i32, i32* %load_reg, align 4
  %call91 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %53, i32 noundef %54, i32 noundef 1) #20
  store i32 %call91, i32* %err, align 4
  %55 = load i32, i32* %err, align 4
  %tobool92 = icmp ne i32 %55, 0
  br i1 %tobool92, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.end90
  %56 = load i32, i32* %err, align 4
  store i32 %56, i32* %retval, align 4
  br label %return

if.end94:                                         ; preds = %if.end90
  br label %if.end96

if.else95:                                        ; preds = %if.end77
  store i32 -1, i32* %load_reg, align 4
  br label %if.end96

if.end96:                                         ; preds = %if.else95, %if.end94
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = load i32, i32* %insn_idx.addr, align 4
  %59 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg97 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %59, i32 0, i32 1
  %bf.load98 = load i8, i8* %dst_reg97, align 1
  %bf.clear99 = and i8 %bf.load98, 15
  %conv100 = zext i8 %bf.clear99 to i32
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %60, i32 0, i32 2
  %61 = load i16, i16* %off, align 2
  %conv101 = sext i16 %61 to i32
  %62 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code102 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %62, i32 0, i32 0
  %63 = load i8, i8* %code102, align 4
  %conv103 = zext i8 %63 to i32
  %and104 = and i32 %conv103, 24
  %call105 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %57, i32 noundef %58, i32 noundef %conv100, i32 noundef %conv101, i32 noundef %and104, i32 noundef 1, i32 noundef -1, i1 noundef zeroext true) #20
  store i32 %call105, i32* %err, align 4
  %64 = load i32, i32* %err, align 4
  %tobool106 = icmp ne i32 %64, 0
  br i1 %tobool106, label %if.end121, label %land.lhs.true107

land.lhs.true107:                                 ; preds = %if.end96
  %65 = load i32, i32* %load_reg, align 4
  %cmp108 = icmp sge i32 %65, 0
  br i1 %cmp108, label %if.then110, label %if.end121

if.then110:                                       ; preds = %land.lhs.true107
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = load i32, i32* %insn_idx.addr, align 4
  %68 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg111 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %68, i32 0, i32 1
  %bf.load112 = load i8, i8* %dst_reg111, align 1
  %bf.clear113 = and i8 %bf.load112, 15
  %conv114 = zext i8 %bf.clear113 to i32
  %69 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off115 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %69, i32 0, i32 2
  %70 = load i16, i16* %off115, align 2
  %conv116 = sext i16 %70 to i32
  %71 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code117 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %71, i32 0, i32 0
  %72 = load i8, i8* %code117, align 4
  %conv118 = zext i8 %72 to i32
  %and119 = and i32 %conv118, 24
  %73 = load i32, i32* %load_reg, align 4
  %call120 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %66, i32 noundef %67, i32 noundef %conv114, i32 noundef %conv116, i32 noundef %and119, i32 noundef 1, i32 noundef %73, i1 noundef zeroext true) #20
  store i32 %call120, i32* %err, align 4
  br label %if.end121

if.end121:                                        ; preds = %if.then110, %land.lhs.true107, %if.end96
  %74 = load i32, i32* %err, align 4
  %tobool122 = icmp ne i32 %74, 0
  br i1 %tobool122, label %if.then123, label %if.end124

if.then123:                                       ; preds = %if.end121
  %75 = load i32, i32* %err, align 4
  store i32 %75, i32* %retval, align 4
  br label %return

if.end124:                                        ; preds = %if.end121
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %77 = load i32, i32* %insn_idx.addr, align 4
  %78 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg125 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %78, i32 0, i32 1
  %bf.load126 = load i8, i8* %dst_reg125, align 1
  %bf.clear127 = and i8 %bf.load126, 15
  %conv128 = zext i8 %bf.clear127 to i32
  %79 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off129 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %79, i32 0, i32 2
  %80 = load i16, i16* %off129, align 2
  %conv130 = sext i16 %80 to i32
  %81 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code131 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %81, i32 0, i32 0
  %82 = load i8, i8* %code131, align 4
  %conv132 = zext i8 %82 to i32
  %and133 = and i32 %conv132, 24
  %call134 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %76, i32 noundef %77, i32 noundef %conv128, i32 noundef %conv130, i32 noundef %and133, i32 noundef 2, i32 noundef -1, i1 noundef zeroext true) #20
  store i32 %call134, i32* %err, align 4
  %83 = load i32, i32* %err, align 4
  %tobool135 = icmp ne i32 %83, 0
  br i1 %tobool135, label %if.then136, label %if.end137

if.then136:                                       ; preds = %if.end124
  %84 = load i32, i32* %err, align 4
  store i32 %84, i32* %retval, align 4
  br label %return

if.end137:                                        ; preds = %if.end124
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end137, %if.then136, %if.then123, %if.then93, %if.then66, %if.then34, %if.then26, %if.then23, %if.then15, %if.then9, %if.then, %sw.default
  %85 = load i32, i32* %retval, align 4
  ret i32 %85
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_ctx_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %3, 2
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_func_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %subprog = alloca i32, align 4
  %target_insn = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load i32*, i32** %insn_idx.addr, align 8
  %1 = load i32, i32* %0, align 4
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 3
  %3 = load i32, i32* %imm, align 4
  %add = add i32 %1, %3
  %add1 = add i32 %add, 1
  store i32 %add1, i32* %target_insn, align 4
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = load i32, i32* %target_insn, align 4
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %4, i32 noundef %5) #20
  store i32 %call, i32* %subprog, align 4
  %6 = load i32, i32* %subprog, align 4
  %cmp = icmp slt i32 %6, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = bitcast %struct.bpf_verifier_env* %7 to i8*
  %9 = load i32, i32* %target_insn, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %8, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.350, i64 0, i64 0), i32 noundef %9) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %12 = load i32*, i32** %insn_idx.addr, align 8
  %13 = load i32, i32* %subprog, align 4
  %call2 = call i32 @__check_func_call(%struct.bpf_verifier_env* noundef %10, %struct.bpf_insn* noundef %11, i32* noundef %12, i32 noundef %13, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* noundef @set_callee_state) #20
  store i32 %call2, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_kfunc_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx_p) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx_p.addr = alloca i32*, align 8
  %t = alloca %struct.btf_type*, align 8
  %func = alloca %struct.btf_type*, align 8
  %func_proto = alloca %struct.btf_type*, align 8
  %ptr_type = alloca %struct.btf_type*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %meta = alloca %struct.bpf_kfunc_arg_meta, align 8
  %func_name = alloca i8*, align 8
  %ptr_type_name = alloca i8*, align 8
  %i = alloca i32, align 4
  %nargs = alloca i32, align 4
  %func_id = alloca i32, align 4
  %ptr_type_id = alloca i32, align 4
  %err = alloca i32, align 4
  %insn_idx = alloca i32, align 4
  %args = alloca %struct.btf_param*, align 8
  %desc_btf = alloca %struct.btf*, align 8
  %kfunc_flags = alloca i32*, align 8
  %acq = alloca i8, align 1
  %id93 = alloca i32, align 4
  %regno = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx_p, i32** %insn_idx_p.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = bitcast %struct.bpf_kfunc_arg_meta* %meta to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %1, i8 0, i64 24, i1 false)
  %2 = load i32*, i32** %insn_idx_p.addr, align 8
  %3 = load i32, i32* %2, align 4
  store i32 %3, i32* %insn_idx, align 4
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 3
  %5 = load i32, i32* %imm, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 2
  %8 = load i16, i16* %off, align 2
  %call1 = call %struct.btf* @find_kfunc_desc_btf(%struct.bpf_verifier_env* noundef %6, i16 noundef signext %8) #20
  store %struct.btf* %call1, %struct.btf** %desc_btf, align 8
  %9 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %10 = bitcast %struct.btf* %9 to i8*
  %call2 = call zeroext i1 @IS_ERR(i8* noundef %10) #20
  br i1 %call2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %11 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %12 = bitcast %struct.btf* %11 to i8*
  %call4 = call i64 @PTR_ERR(i8* noundef %12) #20
  %conv = trunc i64 %call4 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 3
  %14 = load i32, i32* %imm6, align 4
  store i32 %14, i32* %func_id, align 4
  %15 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %16 = load i32, i32* %func_id, align 4
  %call7 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %15, i32 noundef %16) #20
  store %struct.btf_type* %call7, %struct.btf_type** %func, align 8
  %17 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %18 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %18, i32 0, i32 0
  %19 = load i32, i32* %name_off, align 4
  %call8 = call i8* @btf_name_by_offset(%struct.btf* noundef %17, i32 noundef %19) #20
  store i8* %call8, i8** %func_name, align 8
  %20 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %21 = load %struct.btf_type*, %struct.btf_type** %func, align 8
  %22 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %21, i32 0, i32 2
  %type = bitcast %union.anon.137* %22 to i32*
  %23 = load i32, i32* %type, align 4
  %call9 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %20, i32 noundef %23) #20
  store %struct.btf_type* %call9, %struct.btf_type** %func_proto, align 8
  %24 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 2
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call10 = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %26) #20
  %27 = load i32, i32* %func_id, align 4
  %call11 = call i32* @btf_kfunc_id_set_contains(%struct.btf* noundef %24, i32 noundef %call10, i32 noundef %27) #20
  store i32* %call11, i32** %kfunc_flags, align 8
  %28 = load i32*, i32** %kfunc_flags, align 8
  %tobool12 = icmp ne i32* %28, null
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end5
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load i8*, i8** %func_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.358, i64 0, i64 0), i8* noundef %31) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end5
  %32 = load i32*, i32** %kfunc_flags, align 8
  %33 = load i32, i32* %32, align 4
  %and = and i32 %33, 64
  %tobool15 = icmp ne i32 %and, 0
  br i1 %tobool15, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %if.end14
  %call16 = call zeroext i1 @capable(i32 noundef 22) #20
  br i1 %call16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %land.lhs.true
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.359, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %land.lhs.true, %if.end14
  %36 = load i32*, i32** %kfunc_flags, align 8
  %37 = load i32, i32* %36, align 4
  %and19 = and i32 %37, 1
  %tobool20 = icmp ne i32 %and19, 0
  %frombool = zext i1 %tobool20 to i8
  store i8 %frombool, i8* %acq, align 1
  %38 = load i32*, i32** %kfunc_flags, align 8
  %39 = load i32, i32* %38, align 4
  %flags = getelementptr inbounds %struct.bpf_kfunc_arg_meta, %struct.bpf_kfunc_arg_meta* %meta, i32 0, i32 3
  store i32 %39, i32* %flags, align 8
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %42 = load i32, i32* %func_id, align 4
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %call21 = call i32 @btf_check_kfunc_arg_match(%struct.bpf_verifier_env* noundef %40, %struct.btf* noundef %41, i32 noundef %42, %struct.bpf_reg_state* noundef %43, %struct.bpf_kfunc_arg_meta* noundef %meta) #20
  store i32 %call21, i32* %err, align 4
  %44 = load i32, i32* %err, align 4
  %cmp = icmp slt i32 %44, 0
  br i1 %cmp, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end18
  %45 = load i32, i32* %err, align 4
  store i32 %45, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end18
  %46 = load i32, i32* %err, align 4
  %tobool25 = icmp ne i32 %46, 0
  br i1 %tobool25, label %if.then26, label %if.end31

if.then26:                                        ; preds = %if.end24
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %49 = load i32, i32* %err, align 4
  %idxprom = sext i32 %49 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i64 %idxprom
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 4
  %50 = load i32, i32* %ref_obj_id, align 4
  %call27 = call i32 @release_reference(%struct.bpf_verifier_env* noundef %47, i32 noundef %50) #20
  store i32 %call27, i32* %err, align 4
  %51 = load i32, i32* %err, align 4
  %tobool28 = icmp ne i32 %51, 0
  br i1 %tobool28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.then26
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  %54 = load i8*, i8** %func_name, align 8
  %55 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.360, i64 0, i64 0), i8* noundef %54, i32 noundef %55) #20
  %56 = load i32, i32* %err, align 4
  store i32 %56, i32* %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.then26
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.end24
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end31
  %57 = load i32, i32* %i, align 4
  %cmp32 = icmp ult i32 %57, 6
  br i1 %cmp32, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %60 = load i32, i32* %i, align 4
  %idxprom34 = zext i32 %60 to i64
  %arrayidx35 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom34
  %61 = load i32, i32* %arrayidx35, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %58, %struct.bpf_reg_state* noundef %59, i32 noundef %61) #20
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %62 = load i32, i32* %i, align 4
  %inc = add i32 %62, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !107

for.end:                                          ; preds = %for.cond
  %63 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %64 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %65 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %64, i32 0, i32 2
  %type36 = bitcast %union.anon.137* %65 to i32*
  %66 = load i32, i32* %type36, align 4
  %call37 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %63, i32 noundef %66, i32* noundef null) #20
  store %struct.btf_type* %call37, %struct.btf_type** %t, align 8
  %67 = load i8, i8* %acq, align 1
  %tobool38 = trunc i8 %67 to i1
  br i1 %tobool38, label %land.lhs.true40, label %if.end43

land.lhs.true40:                                  ; preds = %for.end
  %68 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %69 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call41 = call zeroext i1 @btf_type_is_struct_ptr(%struct.btf* noundef %68, %struct.btf_type* noundef %69) #20
  br i1 %call41, label %if.end43, label %if.then42

if.then42:                                        ; preds = %land.lhs.true40
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = bitcast %struct.bpf_verifier_env* %70 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %71, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.361, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %land.lhs.true40, %for.end
  %72 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call44 = call zeroext i1 @btf_type_is_scalar(%struct.btf_type* noundef %72) #20
  br i1 %call44, label %if.then45, label %if.else

if.then45:                                        ; preds = %if.end43
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %73, %struct.bpf_reg_state* noundef %74, i32 noundef 0) #20
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %77 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %76, i32 0, i32 2
  %size = bitcast %union.anon.137* %77 to i32*
  %78 = load i32, i32* %size, align 4
  %conv46 = zext i32 %78 to i64
  call void @mark_btf_func_reg_size(%struct.bpf_verifier_env* noundef %75, i32 noundef 0, i64 noundef %conv46) #20
  br label %if.end105

if.else:                                          ; preds = %if.end43
  %79 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call47 = call zeroext i1 @btf_type_is_ptr(%struct.btf_type* noundef %79) #20
  br i1 %call47, label %if.then48, label %if.end104

if.then48:                                        ; preds = %if.else
  %80 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %81 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %82 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %81, i32 0, i32 2
  %type49 = bitcast %union.anon.137* %82 to i32*
  %83 = load i32, i32* %type49, align 4
  %call50 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %80, i32 noundef %83, i32* noundef %ptr_type_id) #20
  store %struct.btf_type* %call50, %struct.btf_type** %ptr_type, align 8
  %84 = load %struct.btf_type*, %struct.btf_type** %ptr_type, align 8
  %call51 = call zeroext i1 @btf_type_is_struct(%struct.btf_type* noundef %84) #20
  br i1 %call51, label %if.else76, label %if.then52

if.then52:                                        ; preds = %if.then48
  %r0_size = getelementptr inbounds %struct.bpf_kfunc_arg_meta, %struct.bpf_kfunc_arg_meta* %meta, i32 0, i32 0
  %85 = load i64, i64* %r0_size, align 8
  %tobool53 = icmp ne i64 %85, 0
  br i1 %tobool53, label %if.end58, label %if.then54

if.then54:                                        ; preds = %if.then52
  %86 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %87 = load %struct.btf_type*, %struct.btf_type** %ptr_type, align 8
  %name_off55 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %87, i32 0, i32 0
  %88 = load i32, i32* %name_off55, align 4
  %call56 = call i8* @btf_name_by_offset(%struct.btf* noundef %86, i32 noundef %88) #20
  store i8* %call56, i8** %ptr_type_name, align 8
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %90 = bitcast %struct.bpf_verifier_env* %89 to i8*
  %91 = load i8*, i8** %func_name, align 8
  %92 = load %struct.btf_type*, %struct.btf_type** %ptr_type, align 8
  %call57 = call i8* @btf_type_str(%struct.btf_type* noundef %92) #20
  %93 = load i8*, i8** %ptr_type_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %90, i8* noundef getelementptr inbounds ([64 x i8], [64 x i8]* @.str.362, i64 0, i64 0), i8* noundef %91, i8* noundef %call57, i8* noundef %93) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end58:                                         ; preds = %if.then52
  %94 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %94, %struct.bpf_reg_state* noundef %95, i32 noundef 0) #20
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx59 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %96, i64 0
  %type60 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx59, i32 0, i32 0
  store i32 17, i32* %type60, align 8
  %r0_size61 = getelementptr inbounds %struct.bpf_kfunc_arg_meta, %struct.bpf_kfunc_arg_meta* %meta, i32 0, i32 0
  %97 = load i64, i64* %r0_size61, align 8
  %conv62 = trunc i64 %97 to i32
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx63 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %98, i64 0
  %99 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx63, i32 0, i32 2
  %mem_size = bitcast %union.anon.168* %99 to i32*
  store i32 %conv62, i32* %mem_size, align 8
  %r0_rdonly = getelementptr inbounds %struct.bpf_kfunc_arg_meta, %struct.bpf_kfunc_arg_meta* %meta, i32 0, i32 1
  %100 = load i8, i8* %r0_rdonly, align 8
  %tobool64 = trunc i8 %100 to i1
  br i1 %tobool64, label %if.then65, label %if.end68

if.then65:                                        ; preds = %if.end58
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx66 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %101, i64 0
  %type67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx66, i32 0, i32 0
  %102 = load i32, i32* %type67, align 8
  %or = or i32 %102, 512
  store i32 %or, i32* %type67, align 8
  br label %if.end68

if.end68:                                         ; preds = %if.then65, %if.end58
  %ref_obj_id69 = getelementptr inbounds %struct.bpf_kfunc_arg_meta, %struct.bpf_kfunc_arg_meta* %meta, i32 0, i32 2
  %103 = load i32, i32* %ref_obj_id69, align 4
  %tobool70 = icmp ne i32 %103, 0
  br i1 %tobool70, label %if.then71, label %if.end75

if.then71:                                        ; preds = %if.end68
  %ref_obj_id72 = getelementptr inbounds %struct.bpf_kfunc_arg_meta, %struct.bpf_kfunc_arg_meta* %meta, i32 0, i32 2
  %104 = load i32, i32* %ref_obj_id72, align 4
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx73 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %105, i64 0
  %ref_obj_id74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx73, i32 0, i32 4
  store i32 %104, i32* %ref_obj_id74, align 4
  br label %if.end75

if.end75:                                         ; preds = %if.then71, %if.end68
  br label %if.end81

if.else76:                                        ; preds = %if.then48
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %107 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %106, %struct.bpf_reg_state* noundef %107, i32 noundef 0) #20
  %108 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %109 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx77 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %109, i64 0
  %110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx77, i32 0, i32 2
  %111 = bitcast %union.anon.168* %110 to %struct.anon.170*
  %btf = getelementptr inbounds %struct.anon.170, %struct.anon.170* %111, i32 0, i32 0
  store %struct.btf* %108, %struct.btf** %btf, align 8
  %112 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx78 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %112, i64 0
  %type79 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx78, i32 0, i32 0
  store i32 16, i32* %type79, align 8
  %113 = load i32, i32* %ptr_type_id, align 4
  %114 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx80 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %114, i64 0
  %115 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx80, i32 0, i32 2
  %116 = bitcast %union.anon.168* %115 to %struct.anon.170*
  %btf_id = getelementptr inbounds %struct.anon.170, %struct.anon.170* %116, i32 0, i32 1
  store i32 %113, i32* %btf_id, align 8
  br label %if.end81

if.end81:                                         ; preds = %if.else76, %if.end75
  %117 = load i32*, i32** %kfunc_flags, align 8
  %118 = load i32, i32* %117, align 4
  %and82 = and i32 %118, 4
  %tobool83 = icmp ne i32 %and82, 0
  br i1 %tobool83, label %if.then84, label %if.end90

if.then84:                                        ; preds = %if.end81
  %119 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx85 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %119, i64 0
  %type86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx85, i32 0, i32 0
  %120 = load i32, i32* %type86, align 8
  %or87 = or i32 %120, 256
  store i32 %or87, i32* %type86, align 8
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %121, i32 0, i32 15
  %122 = load i32, i32* %id_gen, align 8
  %inc88 = add i32 %122, 1
  store i32 %inc88, i32* %id_gen, align 8
  %123 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx89 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %123, i64 0
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx89, i32 0, i32 3
  store i32 %inc88, i32* %id, align 8
  br label %if.end90

if.end90:                                         ; preds = %if.then84, %if.end81
  %124 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @mark_btf_func_reg_size(%struct.bpf_verifier_env* noundef %124, i32 noundef 0, i64 noundef 8) #20
  %125 = load i8, i8* %acq, align 1
  %tobool91 = trunc i8 %125 to i1
  br i1 %tobool91, label %if.then92, label %if.end103

if.then92:                                        ; preds = %if.end90
  %126 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %127 = load i32, i32* %insn_idx, align 4
  %call94 = call i32 @acquire_reference_state(%struct.bpf_verifier_env* noundef %126, i32 noundef %127) #20
  store i32 %call94, i32* %id93, align 4
  %128 = load i32, i32* %id93, align 4
  %cmp95 = icmp slt i32 %128, 0
  br i1 %cmp95, label %if.then97, label %if.end98

if.then97:                                        ; preds = %if.then92
  %129 = load i32, i32* %id93, align 4
  store i32 %129, i32* %retval, align 4
  br label %return

if.end98:                                         ; preds = %if.then92
  %130 = load i32, i32* %id93, align 4
  %131 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx99 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %131, i64 0
  %id100 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx99, i32 0, i32 3
  store i32 %130, i32* %id100, align 8
  %132 = load i32, i32* %id93, align 4
  %133 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx101 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %133, i64 0
  %ref_obj_id102 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx101, i32 0, i32 4
  store i32 %132, i32* %ref_obj_id102, align 4
  br label %if.end103

if.end103:                                        ; preds = %if.end98, %if.end90
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %if.else
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %if.then45
  %134 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %call106 = call zeroext i16 @btf_type_vlen(%struct.btf_type* noundef %134) #20
  %conv107 = zext i16 %call106 to i32
  store i32 %conv107, i32* %nargs, align 4
  %135 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %add.ptr = getelementptr %struct.btf_type, %struct.btf_type* %135, i64 1
  %136 = bitcast %struct.btf_type* %add.ptr to %struct.btf_param*
  store %struct.btf_param* %136, %struct.btf_param** %args, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond108

for.cond108:                                      ; preds = %for.inc122, %if.end105
  %137 = load i32, i32* %i, align 4
  %138 = load i32, i32* %nargs, align 4
  %cmp109 = icmp ult i32 %137, %138
  br i1 %cmp109, label %for.body111, label %for.end124

for.body111:                                      ; preds = %for.cond108
  %139 = load i32, i32* %i, align 4
  %add = add i32 %139, 1
  store i32 %add, i32* %regno, align 4
  %140 = load %struct.btf*, %struct.btf** %desc_btf, align 8
  %141 = load %struct.btf_param*, %struct.btf_param** %args, align 8
  %142 = load i32, i32* %i, align 4
  %idxprom112 = zext i32 %142 to i64
  %arrayidx113 = getelementptr %struct.btf_param, %struct.btf_param* %141, i64 %idxprom112
  %type114 = getelementptr inbounds %struct.btf_param, %struct.btf_param* %arrayidx113, i32 0, i32 1
  %143 = load i32, i32* %type114, align 4
  %call115 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %140, i32 noundef %143, i32* noundef null) #20
  store %struct.btf_type* %call115, %struct.btf_type** %t, align 8
  %144 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call116 = call zeroext i1 @btf_type_is_ptr(%struct.btf_type* noundef %144) #20
  br i1 %call116, label %if.then117, label %if.else118

if.then117:                                       ; preds = %for.body111
  %145 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %146 = load i32, i32* %regno, align 4
  call void @mark_btf_func_reg_size(%struct.bpf_verifier_env* noundef %145, i32 noundef %146, i64 noundef 8) #20
  br label %if.end121

if.else118:                                       ; preds = %for.body111
  %147 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %148 = load i32, i32* %regno, align 4
  %149 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %150 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %149, i32 0, i32 2
  %size119 = bitcast %union.anon.137* %150 to i32*
  %151 = load i32, i32* %size119, align 4
  %conv120 = zext i32 %151 to i64
  call void @mark_btf_func_reg_size(%struct.bpf_verifier_env* noundef %147, i32 noundef %148, i64 noundef %conv120) #20
  br label %if.end121

if.end121:                                        ; preds = %if.else118, %if.then117
  br label %for.inc122

for.inc122:                                       ; preds = %if.end121
  %152 = load i32, i32* %i, align 4
  %inc123 = add i32 %152, 1
  store i32 %inc123, i32* %i, align 4
  br label %for.cond108, !llvm.loop !108

for.end124:                                       ; preds = %for.cond108
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end124, %if.then97, %if.then54, %if.then42, %if.then29, %if.then23, %if.then17, %if.then13, %if.then3, %if.then
  %153 = load i32, i32* %retval, align 4
  ret i32 %153
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_helper_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx_p) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx_p.addr = alloca i32*, align 8
  %prog_type = alloca i32, align 4
  %fn = alloca %struct.bpf_func_proto*, align 8
  %ret_type = alloca i32, align 4
  %ret_flag = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %meta = alloca %struct.bpf_call_arg_meta, align 8
  %insn_idx = alloca i32, align 4
  %changes_data = alloca i8, align 1
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %func_id = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %t = alloca %struct.btf_type*, align 8
  %tsize = alloca i32, align 4
  %ret = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %ret_btf292 = alloca %struct.btf*, align 8
  %ret_btf_id293 = alloca i32, align 4
  %id353 = alloca i32, align 4
  %err_str = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx_p, i32** %insn_idx_p.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %1) #20
  store i32 %call, i32* %prog_type, align 4
  store %struct.bpf_func_proto* null, %struct.bpf_func_proto** %fn, align 8
  %2 = load i32*, i32** %insn_idx_p.addr, align 8
  %3 = load i32, i32* %2, align 4
  store i32 %3, i32* %insn_idx, align 4
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 3
  %5 = load i32, i32* %imm, align 4
  store i32 %5, i32* %func_id, align 4
  %6 = load i32, i32* %func_id, align 4
  %cmp = icmp slt i32 %6, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load i32, i32* %func_id, align 4
  %cmp1 = icmp sge i32 %7, 210
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  %10 = load i32, i32* %func_id, align 4
  %call2 = call i8* @func_id_name(i32 noundef %10) #20
  %11 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([20 x i8], [20 x i8]* @.str.363, i64 0, i64 0), i8* noundef %call2, i32 noundef %11) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 3
  %13 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %get_func_proto = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %13, i32 0, i32 0
  %14 = load %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, %struct.bpf_func_proto* (i32, %struct.bpf_prog*)** %get_func_proto, align 8
  %tobool = icmp ne %struct.bpf_func_proto* (i32, %struct.bpf_prog*)* %14, null
  br i1 %tobool, label %if.then3, label %if.end8

if.then3:                                         ; preds = %if.end
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 3
  %16 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops4, align 8
  %get_func_proto5 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %16, i32 0, i32 0
  %17 = load %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, %struct.bpf_func_proto* (i32, %struct.bpf_prog*)** %get_func_proto5, align 8
  %18 = load i32, i32* %func_id, align 4
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 2
  %20 = load %struct.bpf_prog*, %struct.bpf_prog** %prog6, align 8
  %call7 = call %struct.bpf_func_proto* %17(i32 noundef %18, %struct.bpf_prog* noundef %20) #20
  store %struct.bpf_func_proto* %call7, %struct.bpf_func_proto** %fn, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then3, %if.end
  %21 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %tobool9 = icmp ne %struct.bpf_func_proto* %21, null
  br i1 %tobool9, label %if.end12, label %if.then10

if.then10:                                        ; preds = %if.end8
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  %24 = load i32, i32* %func_id, align 4
  %call11 = call i8* @func_id_name(i32 noundef %24) #20
  %25 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([20 x i8], [20 x i8]* @.str.364, i64 0, i64 0), i8* noundef %call11, i32 noundef %25) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end8
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog13 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 2
  %27 = load %struct.bpf_prog*, %struct.bpf_prog** %prog13, align 8
  %gpl_compatible = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %27, i32 0, i32 1
  %bf.load = load i16, i16* %gpl_compatible, align 2
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %tobool14 = icmp ne i16 %bf.clear, 0
  br i1 %tobool14, label %if.end17, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end12
  %28 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %gpl_only = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %28, i32 0, i32 1
  %29 = load i8, i8* %gpl_only, align 8
  %tobool15 = trunc i8 %29 to i1
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.365, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %land.lhs.true, %if.end12
  %32 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %allowed = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %32, i32 0, i32 7
  %33 = load i1 (%struct.bpf_prog*)*, i1 (%struct.bpf_prog*)** %allowed, align 8
  %tobool18 = icmp ne i1 (%struct.bpf_prog*)* %33, null
  br i1 %tobool18, label %land.lhs.true19, label %if.end24

land.lhs.true19:                                  ; preds = %if.end17
  %34 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %allowed20 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %34, i32 0, i32 7
  %35 = load i1 (%struct.bpf_prog*)*, i1 (%struct.bpf_prog*)** %allowed20, align 8
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog21 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %36, i32 0, i32 2
  %37 = load %struct.bpf_prog*, %struct.bpf_prog** %prog21, align 8
  %call22 = call zeroext i1 %35(%struct.bpf_prog* noundef %37) #20
  br i1 %call22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %land.lhs.true19
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = bitcast %struct.bpf_verifier_env* %38 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %39, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.366, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %land.lhs.true19, %if.end17
  %40 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %func = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %40, i32 0, i32 0
  %41 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %func, align 8
  %42 = bitcast i64 (i64, i64, i64, i64, i64)* %41 to i8*
  %call25 = call zeroext i1 @bpf_helper_changes_pkt_data(i8* noundef %42) #20
  %frombool = zext i1 %call25 to i8
  store i8 %frombool, i8* %changes_data, align 1
  %43 = load i8, i8* %changes_data, align 1
  %tobool26 = trunc i8 %43 to i1
  br i1 %tobool26, label %land.lhs.true27, label %if.end31

land.lhs.true27:                                  ; preds = %if.end24
  %44 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %45 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %44, i32 0, i32 4
  %46 = bitcast %union.anon.203* %45 to %struct.anon.204*
  %arg1_type = getelementptr inbounds %struct.anon.204, %struct.anon.204* %46, i32 0, i32 0
  %47 = load i32, i32* %arg1_type, align 8
  %cmp28 = icmp ne i32 %47, 7
  br i1 %cmp28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %land.lhs.true27
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = bitcast %struct.bpf_verifier_env* %48 to i8*
  %50 = load i32, i32* %func_id, align 4
  %call30 = call i8* @func_id_name(i32 noundef %50) #20
  %51 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %49, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.367, i64 0, i64 0), i8* noundef %call30, i32 noundef %51) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %land.lhs.true27, %if.end24
  %52 = bitcast %struct.bpf_call_arg_meta* %meta to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %52, i8 0, i64 96, i1 false)
  %53 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %pkt_access = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %53, i32 0, i32 2
  %54 = load i8, i8* %pkt_access, align 1
  %tobool32 = trunc i8 %54 to i1
  %pkt_access33 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 2
  %frombool34 = zext i1 %tobool32 to i8
  store i8 %frombool34, i8* %pkt_access33, align 1
  %55 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %56 = load i32, i32* %func_id, align 4
  %call35 = call i32 @check_func_proto(%struct.bpf_func_proto* noundef %55, i32 noundef %56) #20
  store i32 %call35, i32* %err, align 4
  %57 = load i32, i32* %err, align 4
  %tobool36 = icmp ne i32 %57, 0
  br i1 %tobool36, label %if.then37, label %if.end39

if.then37:                                        ; preds = %if.end31
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = bitcast %struct.bpf_verifier_env* %58 to i8*
  %60 = load i32, i32* %func_id, align 4
  %call38 = call i8* @func_id_name(i32 noundef %60) #20
  %61 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %59, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.368, i64 0, i64 0), i8* noundef %call38, i32 noundef %61) #20
  %62 = load i32, i32* %err, align 4
  store i32 %62, i32* %retval, align 4
  br label %return

if.end39:                                         ; preds = %if.end31
  %63 = load i32, i32* %func_id, align 4
  %func_id40 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 10
  store i32 %63, i32* %func_id40, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end39
  %64 = load i32, i32* %i, align 4
  %cmp41 = icmp slt i32 %64, 5
  br i1 %cmp41, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %66 = load i32, i32* %i, align 4
  %67 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %call42 = call i32 @check_func_arg(%struct.bpf_verifier_env* noundef %65, i32 noundef %66, %struct.bpf_call_arg_meta* noundef %meta, %struct.bpf_func_proto* noundef %67) #20
  store i32 %call42, i32* %err, align 4
  %68 = load i32, i32* %err, align 4
  %tobool43 = icmp ne i32 %68, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %for.body
  %69 = load i32, i32* %err, align 4
  store i32 %69, i32* %retval, align 4
  br label %return

if.end45:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end45
  %70 = load i32, i32* %i, align 4
  %inc = add i32 %70, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !109

for.end:                                          ; preds = %for.cond
  %71 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %72 = load i32, i32* %func_id, align 4
  %73 = load i32, i32* %insn_idx, align 4
  %call46 = call i32 @record_func_map(%struct.bpf_verifier_env* noundef %71, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %72, i32 noundef %73) #20
  store i32 %call46, i32* %err, align 4
  %74 = load i32, i32* %err, align 4
  %tobool47 = icmp ne i32 %74, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %for.end
  %75 = load i32, i32* %err, align 4
  store i32 %75, i32* %retval, align 4
  br label %return

if.end49:                                         ; preds = %for.end
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %77 = load i32, i32* %func_id, align 4
  %78 = load i32, i32* %insn_idx, align 4
  %call50 = call i32 @record_func_key(%struct.bpf_verifier_env* noundef %76, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %77, i32 noundef %78) #20
  store i32 %call50, i32* %err, align 4
  %79 = load i32, i32* %err, align 4
  %tobool51 = icmp ne i32 %79, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end49
  %80 = load i32, i32* %err, align 4
  store i32 %80, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.end49
  store i32 0, i32* %i, align 4
  br label %for.cond54

for.cond54:                                       ; preds = %for.inc61, %if.end53
  %81 = load i32, i32* %i, align 4
  %access_size = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 5
  %82 = load i32, i32* %access_size, align 8
  %cmp55 = icmp slt i32 %81, %82
  br i1 %cmp55, label %for.body56, label %for.end63

for.body56:                                       ; preds = %for.cond54
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %84 = load i32, i32* %insn_idx, align 4
  %regno = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 4
  %85 = load i32, i32* %regno, align 4
  %86 = load i32, i32* %i, align 4
  %call57 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %83, i32 noundef %84, i32 noundef %85, i32 noundef %86, i32 noundef 16, i32 noundef 2, i32 noundef -1, i1 noundef zeroext false) #20
  store i32 %call57, i32* %err, align 4
  %87 = load i32, i32* %err, align 4
  %tobool58 = icmp ne i32 %87, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %for.body56
  %88 = load i32, i32* %err, align 4
  store i32 %88, i32* %retval, align 4
  br label %return

if.end60:                                         ; preds = %for.body56
  br label %for.inc61

for.inc61:                                        ; preds = %if.end60
  %89 = load i32, i32* %i, align 4
  %inc62 = add i32 %89, 1
  store i32 %inc62, i32* %i, align 4
  br label %for.cond54, !llvm.loop !110

for.end63:                                        ; preds = %for.cond54
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call64 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %90) #20
  store %struct.bpf_reg_state* %call64, %struct.bpf_reg_state** %regs, align 8
  %uninit_dynptr_regno = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 17
  %91 = load i8, i8* %uninit_dynptr_regno, align 8
  %tobool65 = icmp ne i8 %91, 0
  br i1 %tobool65, label %if.then66, label %if.end88

if.then66:                                        ; preds = %for.end63
  store i32 0, i32* %i, align 4
  br label %for.cond67

for.cond67:                                       ; preds = %for.inc77, %if.then66
  %92 = load i32, i32* %i, align 4
  %conv = sext i32 %92 to i64
  %cmp68 = icmp ult i64 %conv, 16
  br i1 %cmp68, label %for.body70, label %for.end78

for.body70:                                       ; preds = %for.cond67
  %93 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %94 = load i32, i32* %insn_idx, align 4
  %uninit_dynptr_regno71 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 17
  %95 = load i8, i8* %uninit_dynptr_regno71, align 8
  %conv72 = zext i8 %95 to i32
  %96 = load i32, i32* %i, align 4
  %call73 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %93, i32 noundef %94, i32 noundef %conv72, i32 noundef %96, i32 noundef 24, i32 noundef 2, i32 noundef -1, i1 noundef zeroext false) #20
  store i32 %call73, i32* %err, align 4
  %97 = load i32, i32* %err, align 4
  %tobool74 = icmp ne i32 %97, 0
  br i1 %tobool74, label %if.then75, label %if.end76

if.then75:                                        ; preds = %for.body70
  %98 = load i32, i32* %err, align 4
  store i32 %98, i32* %retval, align 4
  br label %return

if.end76:                                         ; preds = %for.body70
  br label %for.inc77

for.inc77:                                        ; preds = %if.end76
  %99 = load i32, i32* %i, align 4
  %add = add i32 %99, 8
  store i32 %add, i32* %i, align 4
  br label %for.cond67, !llvm.loop !111

for.end78:                                        ; preds = %for.cond67
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %uninit_dynptr_regno79 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 17
  %102 = load i8, i8* %uninit_dynptr_regno79, align 8
  %idxprom = zext i8 %102 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %101, i64 %idxprom
  %103 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %104 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %103, i32 0, i32 4
  %arg_type = bitcast %union.anon.203* %104 to [5 x i32]*
  %uninit_dynptr_regno80 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 17
  %105 = load i8, i8* %uninit_dynptr_regno80, align 8
  %conv81 = zext i8 %105 to i32
  %sub = sub i32 %conv81, 1
  %idxprom82 = sext i32 %sub to i64
  %arrayidx83 = getelementptr [5 x i32], [5 x i32]* %arg_type, i64 0, i64 %idxprom82
  %106 = load i32, i32* %arrayidx83, align 4
  %107 = load i32, i32* %insn_idx, align 4
  %call84 = call i32 @mark_stack_slots_dynptr(%struct.bpf_verifier_env* noundef %100, %struct.bpf_reg_state* noundef %arrayidx, i32 noundef %106, i32 noundef %107) #20
  store i32 %call84, i32* %err, align 4
  %108 = load i32, i32* %err, align 4
  %tobool85 = icmp ne i32 %108, 0
  br i1 %tobool85, label %if.then86, label %if.end87

if.then86:                                        ; preds = %for.end78
  %109 = load i32, i32* %err, align 4
  store i32 %109, i32* %retval, align 4
  br label %return

if.end87:                                         ; preds = %for.end78
  br label %if.end88

if.end88:                                         ; preds = %if.end87, %for.end63
  %release_regno = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 3
  %110 = load i8, i8* %release_regno, align 2
  %tobool89 = icmp ne i8 %110, 0
  br i1 %tobool89, label %if.then90, label %if.end120

if.then90:                                        ; preds = %if.end88
  store i32 -22, i32* %err, align 4
  %111 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %112 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %111, i32 0, i32 4
  %arg_type91 = bitcast %union.anon.203* %112 to [5 x i32]*
  %release_regno92 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 3
  %113 = load i8, i8* %release_regno92, align 2
  %conv93 = zext i8 %113 to i32
  %sub94 = sub i32 %conv93, 1
  %idxprom95 = sext i32 %sub94 to i64
  %arrayidx96 = getelementptr [5 x i32], [5 x i32]* %arg_type91, i64 0, i64 %idxprom95
  %114 = load i32, i32* %arrayidx96, align 4
  %call97 = call zeroext i1 @arg_type_is_dynptr(i32 noundef %114) #20
  br i1 %call97, label %if.then98, label %if.else

if.then98:                                        ; preds = %if.then90
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %116 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %release_regno99 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 3
  %117 = load i8, i8* %release_regno99, align 2
  %idxprom100 = zext i8 %117 to i64
  %arrayidx101 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %116, i64 %idxprom100
  %call102 = call i32 @unmark_stack_slots_dynptr(%struct.bpf_verifier_env* noundef %115, %struct.bpf_reg_state* noundef %arrayidx101) #20
  store i32 %call102, i32* %err, align 4
  br label %if.end115

if.else:                                          ; preds = %if.then90
  %ref_obj_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 8
  %118 = load i32, i32* %ref_obj_id, align 8
  %tobool103 = icmp ne i32 %118, 0
  br i1 %tobool103, label %if.then104, label %if.else107

if.then104:                                       ; preds = %if.else
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ref_obj_id105 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 8
  %120 = load i32, i32* %ref_obj_id105, align 8
  %call106 = call i32 @release_reference(%struct.bpf_verifier_env* noundef %119, i32 noundef %120) #20
  store i32 %call106, i32* %err, align 4
  br label %if.end114

if.else107:                                       ; preds = %if.else
  %121 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %release_regno108 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 3
  %122 = load i8, i8* %release_regno108, align 2
  %idxprom109 = zext i8 %122 to i64
  %arrayidx110 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %121, i64 %idxprom109
  %call111 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %arrayidx110) #20
  br i1 %call111, label %if.then112, label %if.end113

if.then112:                                       ; preds = %if.else107
  store i32 0, i32* %err, align 4
  br label %if.end113

if.end113:                                        ; preds = %if.then112, %if.else107
  br label %if.end114

if.end114:                                        ; preds = %if.end113, %if.then104
  br label %if.end115

if.end115:                                        ; preds = %if.end114, %if.then98
  %123 = load i32, i32* %err, align 4
  %tobool116 = icmp ne i32 %123, 0
  br i1 %tobool116, label %if.then117, label %if.end119

if.then117:                                       ; preds = %if.end115
  %124 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %125 = bitcast %struct.bpf_verifier_env* %124 to i8*
  %126 = load i32, i32* %func_id, align 4
  %call118 = call i8* @func_id_name(i32 noundef %126) #20
  %127 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %125, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.369, i64 0, i64 0), i8* noundef %call118, i32 noundef %127) #20
  %128 = load i32, i32* %err, align 4
  store i32 %128, i32* %retval, align 4
  br label %return

if.end119:                                        ; preds = %if.end115
  br label %if.end120

if.end120:                                        ; preds = %if.end119, %if.end88
  %129 = load i32, i32* %func_id, align 4
  switch i32 %129, label %sw.epilog [
    i32 12, label %sw.bb
    i32 81, label %sw.bb125
    i32 164, label %sw.bb130
    i32 170, label %sw.bb132
    i32 180, label %sw.bb135
    i32 165, label %sw.bb138
    i32 181, label %sw.bb140
    i32 197, label %sw.bb144
    i32 187, label %sw.bb153
    i32 203, label %sw.bb167
    i32 209, label %sw.bb200
  ]

sw.bb:                                            ; preds = %if.end120
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call121 = call i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %130) #20
  store i32 %call121, i32* %err, align 4
  %131 = load i32, i32* %err, align 4
  %tobool122 = icmp ne i32 %131, 0
  br i1 %tobool122, label %if.then123, label %if.end124

if.then123:                                       ; preds = %sw.bb
  %132 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %133 = bitcast %struct.bpf_verifier_env* %132 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %133, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.370, i64 0, i64 0)) #20
  %134 = load i32, i32* %err, align 4
  store i32 %134, i32* %retval, align 4
  br label %return

if.end124:                                        ; preds = %sw.bb
  br label %sw.epilog

sw.bb125:                                         ; preds = %if.end120
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx126 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %135, i64 2
  %call127 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %arrayidx126) #20
  br i1 %call127, label %if.end129, label %if.then128

if.then128:                                       ; preds = %sw.bb125
  %136 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %137 = bitcast %struct.bpf_verifier_env* %136 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %137, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.371, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end129:                                        ; preds = %sw.bb125
  br label %sw.epilog

sw.bb130:                                         ; preds = %if.end120
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %139 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %140 = load i32*, i32** %insn_idx_p.addr, align 8
  %subprogno = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 15
  %141 = load i32, i32* %subprogno, align 4
  %call131 = call i32 @__check_func_call(%struct.bpf_verifier_env* noundef %138, %struct.bpf_insn* noundef %139, i32* noundef %140, i32 noundef %141, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* noundef @set_map_elem_callback_state) #20
  store i32 %call131, i32* %err, align 4
  br label %sw.epilog

sw.bb132:                                         ; preds = %if.end120
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %143 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %144 = load i32*, i32** %insn_idx_p.addr, align 8
  %subprogno133 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 15
  %145 = load i32, i32* %subprogno133, align 4
  %call134 = call i32 @__check_func_call(%struct.bpf_verifier_env* noundef %142, %struct.bpf_insn* noundef %143, i32* noundef %144, i32 noundef %145, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* noundef @set_timer_callback_state) #20
  store i32 %call134, i32* %err, align 4
  br label %sw.epilog

sw.bb135:                                         ; preds = %if.end120
  %146 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %147 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %148 = load i32*, i32** %insn_idx_p.addr, align 8
  %subprogno136 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 15
  %149 = load i32, i32* %subprogno136, align 4
  %call137 = call i32 @__check_func_call(%struct.bpf_verifier_env* noundef %146, %struct.bpf_insn* noundef %147, i32* noundef %148, i32 noundef %149, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* noundef @set_find_vma_callback_state) #20
  store i32 %call137, i32* %err, align 4
  br label %sw.epilog

sw.bb138:                                         ; preds = %if.end120
  %150 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %151 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %call139 = call i32 @check_bpf_snprintf_call(%struct.bpf_verifier_env* noundef %150, %struct.bpf_reg_state* noundef %151) #20
  store i32 %call139, i32* %err, align 4
  br label %sw.epilog

sw.bb140:                                         ; preds = %if.end120
  %152 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprogno141 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 15
  %153 = load i32, i32* %subprogno141, align 4
  call void @update_loop_inline_state(%struct.bpf_verifier_env* noundef %152, i32 noundef %153) #20
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %155 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %156 = load i32*, i32** %insn_idx_p.addr, align 8
  %subprogno142 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 15
  %157 = load i32, i32* %subprogno142, align 4
  %call143 = call i32 @__check_func_call(%struct.bpf_verifier_env* noundef %154, %struct.bpf_insn* noundef %155, i32* noundef %156, i32 noundef %157, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* noundef @set_loop_callback_state) #20
  store i32 %call143, i32* %err, align 4
  br label %sw.epilog

sw.bb144:                                         ; preds = %if.end120
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx145 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %158, i64 1
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx145, i32 0, i32 0
  %159 = load i32, i32* %type, align 8
  %cmp146 = icmp ne i32 %159, 4
  br i1 %cmp146, label %if.then148, label %if.end152

if.then148:                                       ; preds = %sw.bb144
  %160 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %161 = bitcast %struct.bpf_verifier_env* %160 to i8*
  %162 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx149 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %163, i64 1
  %type150 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx149, i32 0, i32 0
  %164 = load i32, i32* %type150, align 8
  %call151 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %162, i32 noundef %164) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %161, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.372, i64 0, i64 0), i8* noundef %call151) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end152:                                        ; preds = %sw.bb144
  br label %sw.epilog

sw.bb153:                                         ; preds = %if.end120
  %165 = load i32, i32* %prog_type, align 4
  %cmp154 = icmp eq i32 %165, 29
  br i1 %cmp154, label %land.lhs.true156, label %if.end166

land.lhs.true156:                                 ; preds = %sw.bb153
  %166 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog157 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %166, i32 0, i32 2
  %167 = load %struct.bpf_prog*, %struct.bpf_prog** %prog157, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %167, i32 0, i32 3
  %168 = load i32, i32* %expected_attach_type, align 8
  %cmp158 = icmp eq i32 %168, 43
  br i1 %cmp158, label %if.then160, label %if.end166

if.then160:                                       ; preds = %land.lhs.true156
  %169 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog161 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %169, i32 0, i32 2
  %170 = load %struct.bpf_prog*, %struct.bpf_prog** %prog161, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %170, i32 0, i32 10
  %171 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %attach_func_proto = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %171, i32 0, i32 28
  %172 = load %struct.btf_type*, %struct.btf_type** %attach_func_proto, align 8
  %173 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %172, i32 0, i32 2
  %type162 = bitcast %union.anon.137* %173 to i32*
  %174 = load i32, i32* %type162, align 4
  %tobool163 = icmp ne i32 %174, 0
  br i1 %tobool163, label %if.end165, label %if.then164

if.then164:                                       ; preds = %if.then160
  %175 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %176 = bitcast %struct.bpf_verifier_env* %175 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %176, i8* noundef getelementptr inbounds ([73 x i8], [73 x i8]* @.str.373, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end165:                                        ; preds = %if.then160
  br label %if.end166

if.end166:                                        ; preds = %if.end165, %land.lhs.true156, %sw.bb153
  br label %sw.epilog

sw.bb167:                                         ; preds = %if.end120
  store i32 0, i32* %i, align 4
  br label %for.cond168

for.cond168:                                      ; preds = %for.inc193, %sw.bb167
  %177 = load i32, i32* %i, align 4
  %cmp169 = icmp slt i32 %177, 5
  br i1 %cmp169, label %for.body171, label %for.end195

for.body171:                                      ; preds = %for.cond168
  %178 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %179 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %178, i32 0, i32 4
  %arg_type172 = bitcast %union.anon.203* %179 to [5 x i32]*
  %180 = load i32, i32* %i, align 4
  %idxprom173 = sext i32 %180 to i64
  %arrayidx174 = getelementptr [5 x i32], [5 x i32]* %arg_type172, i64 0, i64 %idxprom173
  %181 = load i32, i32* %arrayidx174, align 4
  %call175 = call zeroext i1 @arg_type_is_dynptr(i32 noundef %181) #20
  br i1 %call175, label %if.then176, label %if.end192

if.then176:                                       ; preds = %for.body171
  %182 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %183 = load i32, i32* %i, align 4
  %add177 = add i32 1, %183
  %idxprom178 = sext i32 %add177 to i64
  %arrayidx179 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %182, i64 %idxprom178
  store %struct.bpf_reg_state* %arrayidx179, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id180 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 8
  %184 = load i32, i32* %ref_obj_id180, align 8
  %tobool181 = icmp ne i32 %184, 0
  br i1 %tobool181, label %if.then182, label %if.end183

if.then182:                                       ; preds = %if.then176
  %185 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %186 = bitcast %struct.bpf_verifier_env* %185 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %186, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.374, i64 0, i64 0)) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end183:                                        ; preds = %if.then176
  %187 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type184 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %187, i32 0, i32 0
  %188 = load i32, i32* %type184, align 8
  %call185 = call i32 @base_type(i32 noundef %188) #20
  %cmp186 = icmp ne i32 %call185, 20
  br i1 %cmp186, label %if.then188, label %if.end191

if.then188:                                       ; preds = %if.end183
  %189 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %190 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call189 = call i32 @stack_slot_get_id(%struct.bpf_verifier_env* noundef %189, %struct.bpf_reg_state* noundef %190) #20
  %ref_obj_id190 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 8
  store i32 %call189, i32* %ref_obj_id190, align 8
  br label %if.end191

if.end191:                                        ; preds = %if.then188, %if.end183
  br label %for.end195

if.end192:                                        ; preds = %for.body171
  br label %for.inc193

for.inc193:                                       ; preds = %if.end192
  %191 = load i32, i32* %i, align 4
  %inc194 = add i32 %191, 1
  store i32 %inc194, i32* %i, align 4
  br label %for.cond168, !llvm.loop !112

for.end195:                                       ; preds = %if.end191, %for.cond168
  %192 = load i32, i32* %i, align 4
  %cmp196 = icmp eq i32 %192, 5
  br i1 %cmp196, label %if.then198, label %if.end199

if.then198:                                       ; preds = %for.end195
  %193 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %194 = bitcast %struct.bpf_verifier_env* %193 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %194, i8* noundef getelementptr inbounds ([57 x i8], [57 x i8]* @.str.375, i64 0, i64 0)) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end199:                                        ; preds = %for.end195
  br label %sw.epilog

sw.bb200:                                         ; preds = %if.end120
  %195 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %196 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %197 = load i32*, i32** %insn_idx_p.addr, align 8
  %subprogno201 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 15
  %198 = load i32, i32* %subprogno201, align 4
  %call202 = call i32 @__check_func_call(%struct.bpf_verifier_env* noundef %195, %struct.bpf_insn* noundef %196, i32* noundef %197, i32 noundef %198, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* noundef @set_user_ringbuf_callback_state) #20
  store i32 %call202, i32* %err, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end120, %sw.bb200, %if.end199, %if.end166, %if.end152, %sw.bb140, %sw.bb138, %sw.bb135, %sw.bb132, %sw.bb130, %if.end129, %if.end124
  %199 = load i32, i32* %err, align 4
  %tobool203 = icmp ne i32 %199, 0
  br i1 %tobool203, label %if.then204, label %if.end205

if.then204:                                       ; preds = %sw.epilog
  %200 = load i32, i32* %err, align 4
  store i32 %200, i32* %retval, align 4
  br label %return

if.end205:                                        ; preds = %sw.epilog
  store i32 0, i32* %i, align 4
  br label %for.cond206

for.cond206:                                      ; preds = %for.inc215, %if.end205
  %201 = load i32, i32* %i, align 4
  %cmp207 = icmp slt i32 %201, 6
  br i1 %cmp207, label %for.body209, label %for.end217

for.body209:                                      ; preds = %for.cond206
  %202 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %203 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %204 = load i32, i32* %i, align 4
  %idxprom210 = sext i32 %204 to i64
  %arrayidx211 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom210
  %205 = load i32, i32* %arrayidx211, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %202, %struct.bpf_reg_state* noundef %203, i32 noundef %205) #20
  %206 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %207 = load i32, i32* %i, align 4
  %idxprom212 = sext i32 %207 to i64
  %arrayidx213 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom212
  %208 = load i32, i32* %arrayidx213, align 4
  %call214 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %206, i32 noundef %208, i32 noundef 2) #20
  br label %for.inc215

for.inc215:                                       ; preds = %for.body209
  %209 = load i32, i32* %i, align 4
  %inc216 = add i32 %209, 1
  store i32 %inc216, i32* %i, align 4
  br label %for.cond206, !llvm.loop !113

for.end217:                                       ; preds = %for.cond206
  %210 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx218 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %210, i64 0
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx218, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  %211 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type219 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %211, i32 0, i32 3
  %212 = load i32, i32* %ret_type219, align 4
  store i32 %212, i32* %ret_type, align 4
  %213 = load i32, i32* %ret_type, align 4
  %call220 = call i32 @type_flag(i32 noundef %213) #20
  store i32 %call220, i32* %ret_flag, align 4
  %214 = load i32, i32* %ret_type, align 4
  %call221 = call i32 @base_type(i32 noundef %214) #20
  switch i32 %call221, label %sw.default [
    i32 0, label %sw.bb222
    i32 1, label %sw.bb223
    i32 2, label %sw.bb226
    i32 3, label %sw.bb247
    i32 5, label %sw.bb251
    i32 4, label %sw.bb255
    i32 6, label %sw.bb259
    i32 7, label %sw.bb265
    i32 8, label %sw.bb291
  ]

sw.bb222:                                         ; preds = %for.end217
  %215 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %216 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %215, %struct.bpf_reg_state* noundef %216, i32 noundef 0) #20
  br label %sw.epilog325

sw.bb223:                                         ; preds = %for.end217
  %217 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx224 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %217, i64 0
  %type225 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx224, i32 0, i32 0
  store i32 0, i32* %type225, align 8
  br label %sw.epilog325

sw.bb226:                                         ; preds = %for.end217
  %218 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %219 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %218, %struct.bpf_reg_state* noundef %219, i32 noundef 0) #20
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %220 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %cmp227 = icmp eq %struct.bpf_map* %220, null
  br i1 %cmp227, label %if.then229, label %if.end230

if.then229:                                       ; preds = %sw.bb226
  %221 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %222 = bitcast %struct.bpf_verifier_env* %221 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %222, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.376, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end230:                                        ; preds = %sw.bb226
  %map_ptr231 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %223 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr231, align 8
  %224 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx232 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %224, i64 0
  %225 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx232, i32 0, i32 2
  %226 = bitcast %union.anon.168* %225 to %struct.anon.169*
  %map_ptr233 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %226, i32 0, i32 0
  store %struct.bpf_map* %223, %struct.bpf_map** %map_ptr233, align 8
  %map_uid = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 9
  %227 = load i32, i32* %map_uid, align 4
  %228 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx234 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %228, i64 0
  %229 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx234, i32 0, i32 2
  %230 = bitcast %union.anon.168* %229 to %struct.anon.169*
  %map_uid235 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %230, i32 0, i32 1
  store i32 %227, i32* %map_uid235, align 8
  %231 = load i32, i32* %ret_flag, align 4
  %or = or i32 4, %231
  %232 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx236 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %232, i64 0
  %type237 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx236, i32 0, i32 0
  store i32 %or, i32* %type237, align 8
  %233 = load i32, i32* %ret_type, align 4
  %call238 = call zeroext i1 @type_may_be_null(i32 noundef %233) #20
  br i1 %call238, label %if.end246, label %land.lhs.true239

land.lhs.true239:                                 ; preds = %if.end230
  %map_ptr240 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %234 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr240, align 8
  %call241 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %234) #20
  br i1 %call241, label %if.then243, label %if.end246

if.then243:                                       ; preds = %land.lhs.true239
  %235 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %235, i32 0, i32 15
  %236 = load i32, i32* %id_gen, align 8
  %inc244 = add i32 %236, 1
  store i32 %inc244, i32* %id_gen, align 8
  %237 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx245 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %237, i64 0
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx245, i32 0, i32 3
  store i32 %inc244, i32* %id, align 8
  br label %if.end246

if.end246:                                        ; preds = %if.then243, %land.lhs.true239, %if.end230
  br label %sw.epilog325

sw.bb247:                                         ; preds = %for.end217
  %238 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %239 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %238, %struct.bpf_reg_state* noundef %239, i32 noundef 0) #20
  %240 = load i32, i32* %ret_flag, align 4
  %or248 = or i32 11, %240
  %241 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx249 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %241, i64 0
  %type250 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx249, i32 0, i32 0
  store i32 %or248, i32* %type250, align 8
  br label %sw.epilog325

sw.bb251:                                         ; preds = %for.end217
  %242 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %243 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %242, %struct.bpf_reg_state* noundef %243, i32 noundef 0) #20
  %244 = load i32, i32* %ret_flag, align 4
  %or252 = or i32 12, %244
  %245 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx253 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %245, i64 0
  %type254 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx253, i32 0, i32 0
  store i32 %or252, i32* %type254, align 8
  br label %sw.epilog325

sw.bb255:                                         ; preds = %for.end217
  %246 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %247 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %246, %struct.bpf_reg_state* noundef %247, i32 noundef 0) #20
  %248 = load i32, i32* %ret_flag, align 4
  %or256 = or i32 13, %248
  %249 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx257 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %249, i64 0
  %type258 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx257, i32 0, i32 0
  store i32 %or256, i32* %type258, align 8
  br label %sw.epilog325

sw.bb259:                                         ; preds = %for.end217
  %250 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %251 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %250, %struct.bpf_reg_state* noundef %251, i32 noundef 0) #20
  %252 = load i32, i32* %ret_flag, align 4
  %or260 = or i32 17, %252
  %253 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx261 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %253, i64 0
  %type262 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx261, i32 0, i32 0
  store i32 %or260, i32* %type262, align 8
  %mem_size = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 6
  %254 = load i32, i32* %mem_size, align 4
  %255 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx263 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %255, i64 0
  %256 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx263, i32 0, i32 2
  %mem_size264 = bitcast %union.anon.168* %256 to i32*
  store i32 %254, i32* %mem_size264, align 8
  br label %sw.epilog325

sw.bb265:                                         ; preds = %for.end217
  %257 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %258 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %257, %struct.bpf_reg_state* noundef %258, i32 noundef 0) #20
  %ret_btf = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 13
  %259 = load %struct.btf*, %struct.btf** %ret_btf, align 8
  %ret_btf_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 14
  %260 = load i32, i32* %ret_btf_id, align 8
  %call266 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %259, i32 noundef %260, i32* noundef null) #20
  store %struct.btf_type* %call266, %struct.btf_type** %t, align 8
  %261 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call267 = call zeroext i1 @btf_type_is_struct(%struct.btf_type* noundef %261) #20
  br i1 %call267, label %if.else282, label %if.then268

if.then268:                                       ; preds = %sw.bb265
  %ret_btf269 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 13
  %262 = load %struct.btf*, %struct.btf** %ret_btf269, align 8
  %263 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call270 = call %struct.btf_type* @btf_resolve_size(%struct.btf* noundef %262, %struct.btf_type* noundef %263, i32* noundef %tsize) #20
  store %struct.btf_type* %call270, %struct.btf_type** %ret, align 8
  %264 = load %struct.btf_type*, %struct.btf_type** %ret, align 8
  %265 = bitcast %struct.btf_type* %264 to i8*
  %call271 = call zeroext i1 @IS_ERR(i8* noundef %265) #20
  br i1 %call271, label %if.then272, label %if.end276

if.then272:                                       ; preds = %if.then268
  %ret_btf273 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 13
  %266 = load %struct.btf*, %struct.btf** %ret_btf273, align 8
  %267 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %267, i32 0, i32 0
  %268 = load i32, i32* %name_off, align 4
  %call274 = call i8* @btf_name_by_offset(%struct.btf* noundef %266, i32 noundef %268) #20
  store i8* %call274, i8** %tname, align 8
  %269 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %270 = bitcast %struct.bpf_verifier_env* %269 to i8*
  %271 = load i8*, i8** %tname, align 8
  %272 = load %struct.btf_type*, %struct.btf_type** %ret, align 8
  %273 = bitcast %struct.btf_type* %272 to i8*
  %call275 = call i64 @PTR_ERR(i8* noundef %273) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %270, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.377, i64 0, i64 0), i8* noundef %271, i64 noundef %call275) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end276:                                        ; preds = %if.then268
  %274 = load i32, i32* %ret_flag, align 4
  %or277 = or i32 17, %274
  %275 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx278 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %275, i64 0
  %type279 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx278, i32 0, i32 0
  store i32 %or277, i32* %type279, align 8
  %276 = load i32, i32* %tsize, align 4
  %277 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx280 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %277, i64 0
  %278 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx280, i32 0, i32 2
  %mem_size281 = bitcast %union.anon.168* %278 to i32*
  store i32 %276, i32* %mem_size281, align 8
  br label %if.end290

if.else282:                                       ; preds = %sw.bb265
  %279 = load i32, i32* %ret_flag, align 4
  %and = and i32 %279, -513
  store i32 %and, i32* %ret_flag, align 4
  %280 = load i32, i32* %ret_flag, align 4
  %or283 = or i32 16, %280
  %281 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx284 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %281, i64 0
  %type285 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx284, i32 0, i32 0
  store i32 %or283, i32* %type285, align 8
  %ret_btf286 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 13
  %282 = load %struct.btf*, %struct.btf** %ret_btf286, align 8
  %283 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx287 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %283, i64 0
  %284 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx287, i32 0, i32 2
  %285 = bitcast %union.anon.168* %284 to %struct.anon.170*
  %btf = getelementptr inbounds %struct.anon.170, %struct.anon.170* %285, i32 0, i32 0
  store %struct.btf* %282, %struct.btf** %btf, align 8
  %ret_btf_id288 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 14
  %286 = load i32, i32* %ret_btf_id288, align 8
  %287 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx289 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %287, i64 0
  %288 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx289, i32 0, i32 2
  %289 = bitcast %union.anon.168* %288 to %struct.anon.170*
  %btf_id = getelementptr inbounds %struct.anon.170, %struct.anon.170* %289, i32 0, i32 1
  store i32 %286, i32* %btf_id, align 8
  br label %if.end290

if.end290:                                        ; preds = %if.else282, %if.end276
  br label %sw.epilog325

sw.bb291:                                         ; preds = %for.end217
  %290 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %291 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %290, %struct.bpf_reg_state* noundef %291, i32 noundef 0) #20
  %292 = load i32, i32* %ret_flag, align 4
  %or294 = or i32 16, %292
  %293 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx295 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %293, i64 0
  %type296 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx295, i32 0, i32 0
  store i32 %or294, i32* %type296, align 8
  %294 = load i32, i32* %func_id, align 4
  %cmp297 = icmp eq i32 %294, 194
  br i1 %cmp297, label %if.then299, label %if.else304

if.then299:                                       ; preds = %sw.bb291
  %kptr_off_desc = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 16
  %295 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %kptr_off_desc, align 8
  %kptr = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %295, i32 0, i32 2
  %btf300 = getelementptr inbounds %struct.anon.175, %struct.anon.175* %kptr, i32 0, i32 0
  %296 = load %struct.btf*, %struct.btf** %btf300, align 8
  store %struct.btf* %296, %struct.btf** %ret_btf292, align 8
  %kptr_off_desc301 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 16
  %297 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %kptr_off_desc301, align 8
  %kptr302 = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %297, i32 0, i32 2
  %btf_id303 = getelementptr inbounds %struct.anon.175, %struct.anon.175* %kptr302, i32 0, i32 3
  %298 = load i32, i32* %btf_id303, align 8
  store i32 %298, i32* %ret_btf_id293, align 4
  br label %if.end312

if.else304:                                       ; preds = %sw.bb291
  %299 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_btf_id305 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %299, i32 0, i32 6
  %300 = load i32*, i32** %ret_btf_id305, align 8
  %cmp306 = icmp eq i32* %300, inttoptr (i64 -2401263026318546017 to i32*)
  br i1 %cmp306, label %if.then308, label %if.end310

if.then308:                                       ; preds = %if.else304
  %301 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %302 = bitcast %struct.bpf_verifier_env* %301 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %302, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.378, i64 0, i64 0)) #20
  %303 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %304 = bitcast %struct.bpf_verifier_env* %303 to i8*
  %305 = load i32, i32* %func_id, align 4
  %call309 = call i8* @func_id_name(i32 noundef %305) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %304, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.379, i64 0, i64 0), i8* noundef %call309) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end310:                                        ; preds = %if.else304
  %306 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  store %struct.btf* %306, %struct.btf** %ret_btf292, align 8
  %307 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_btf_id311 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %307, i32 0, i32 6
  %308 = load i32*, i32** %ret_btf_id311, align 8
  %309 = load i32, i32* %308, align 4
  store i32 %309, i32* %ret_btf_id293, align 4
  br label %if.end312

if.end312:                                        ; preds = %if.end310, %if.then299
  %310 = load i32, i32* %ret_btf_id293, align 4
  %cmp313 = icmp eq i32 %310, 0
  br i1 %cmp313, label %if.then315, label %if.end318

if.then315:                                       ; preds = %if.end312
  %311 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %312 = bitcast %struct.bpf_verifier_env* %311 to i8*
  %313 = load i32, i32* %ret_type, align 4
  %call316 = call i32 @base_type(i32 noundef %313) #20
  %314 = load i32, i32* %func_id, align 4
  %call317 = call i8* @func_id_name(i32 noundef %314) #20
  %315 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %312, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.380, i64 0, i64 0), i32 noundef %call316, i8* noundef %call317, i32 noundef %315) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end318:                                        ; preds = %if.end312
  %316 = load %struct.btf*, %struct.btf** %ret_btf292, align 8
  %317 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx319 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %317, i64 0
  %318 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx319, i32 0, i32 2
  %319 = bitcast %union.anon.168* %318 to %struct.anon.170*
  %btf320 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %319, i32 0, i32 0
  store %struct.btf* %316, %struct.btf** %btf320, align 8
  %320 = load i32, i32* %ret_btf_id293, align 4
  %321 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx321 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %321, i64 0
  %322 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx321, i32 0, i32 2
  %323 = bitcast %union.anon.168* %322 to %struct.anon.170*
  %btf_id322 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %323, i32 0, i32 1
  store i32 %320, i32* %btf_id322, align 8
  br label %sw.epilog325

sw.default:                                       ; preds = %for.end217
  %324 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %325 = bitcast %struct.bpf_verifier_env* %324 to i8*
  %326 = load i32, i32* %ret_type, align 4
  %call323 = call i32 @base_type(i32 noundef %326) #20
  %327 = load i32, i32* %func_id, align 4
  %call324 = call i8* @func_id_name(i32 noundef %327) #20
  %328 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %325, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.381, i64 0, i64 0), i32 noundef %call323, i8* noundef %call324, i32 noundef %328) #20
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog325:                                     ; preds = %if.end318, %if.end290, %sw.bb259, %sw.bb255, %sw.bb251, %sw.bb247, %if.end246, %sw.bb223, %sw.bb222
  %329 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx326 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %329, i64 0
  %type327 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx326, i32 0, i32 0
  %330 = load i32, i32* %type327, align 8
  %call328 = call zeroext i1 @type_may_be_null(i32 noundef %330) #20
  br i1 %call328, label %if.then329, label %if.end334

if.then329:                                       ; preds = %sw.epilog325
  %331 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen330 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %331, i32 0, i32 15
  %332 = load i32, i32* %id_gen330, align 8
  %inc331 = add i32 %332, 1
  store i32 %inc331, i32* %id_gen330, align 8
  %333 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx332 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %333, i64 0
  %id333 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx332, i32 0, i32 3
  store i32 %inc331, i32* %id333, align 8
  br label %if.end334

if.end334:                                        ; preds = %if.then329, %sw.epilog325
  %334 = load i32, i32* %func_id, align 4
  %map_ptr335 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %335 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr335, align 8
  %call336 = call zeroext i1 @helper_multiple_ref_obj_use(i32 noundef %334, %struct.bpf_map* noundef %335) #20
  br i1 %call336, label %if.then337, label %if.end339

if.then337:                                       ; preds = %if.end334
  %336 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %337 = bitcast %struct.bpf_verifier_env* %336 to i8*
  %338 = load i32, i32* %func_id, align 4
  %call338 = call i8* @func_id_name(i32 noundef %338) #20
  %339 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %337, i8* noundef getelementptr inbounds ([68 x i8], [68 x i8]* @.str.382, i64 0, i64 0), i8* noundef %call338, i32 noundef %339) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end339:                                        ; preds = %if.end334
  %340 = load i32, i32* %func_id, align 4
  %call340 = call zeroext i1 @is_ptr_cast_function(i32 noundef %340) #20
  br i1 %call340, label %if.then345, label %lor.lhs.false342

lor.lhs.false342:                                 ; preds = %if.end339
  %341 = load i32, i32* %func_id, align 4
  %call343 = call zeroext i1 @is_dynptr_ref_function(i32 noundef %341) #20
  br i1 %call343, label %if.then345, label %if.else349

if.then345:                                       ; preds = %lor.lhs.false342, %if.end339
  %ref_obj_id346 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 8
  %342 = load i32, i32* %ref_obj_id346, align 8
  %343 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx347 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %343, i64 0
  %ref_obj_id348 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx347, i32 0, i32 4
  store i32 %342, i32* %ref_obj_id348, align 4
  br label %if.end364

if.else349:                                       ; preds = %lor.lhs.false342
  %344 = load i32, i32* %func_id, align 4
  %map_ptr350 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %345 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr350, align 8
  %call351 = call zeroext i1 @is_acquire_function(i32 noundef %344, %struct.bpf_map* noundef %345) #20
  br i1 %call351, label %if.then352, label %if.end363

if.then352:                                       ; preds = %if.else349
  %346 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %347 = load i32, i32* %insn_idx, align 4
  %call354 = call i32 @acquire_reference_state(%struct.bpf_verifier_env* noundef %346, i32 noundef %347) #20
  store i32 %call354, i32* %id353, align 4
  %348 = load i32, i32* %id353, align 4
  %cmp355 = icmp slt i32 %348, 0
  br i1 %cmp355, label %if.then357, label %if.end358

if.then357:                                       ; preds = %if.then352
  %349 = load i32, i32* %id353, align 4
  store i32 %349, i32* %retval, align 4
  br label %return

if.end358:                                        ; preds = %if.then352
  %350 = load i32, i32* %id353, align 4
  %351 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx359 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %351, i64 0
  %id360 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx359, i32 0, i32 3
  store i32 %350, i32* %id360, align 8
  %352 = load i32, i32* %id353, align 4
  %353 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx361 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %353, i64 0
  %ref_obj_id362 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx361, i32 0, i32 4
  store i32 %352, i32* %ref_obj_id362, align 4
  br label %if.end363

if.end363:                                        ; preds = %if.end358, %if.else349
  br label %if.end364

if.end364:                                        ; preds = %if.end363, %if.then345
  %354 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %355 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type365 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %355, i32 0, i32 3
  %356 = load i32, i32* %ret_type365, align 4
  %357 = load i32, i32* %func_id, align 4
  call void @do_refine_retval_range(%struct.bpf_reg_state* noundef %354, i32 noundef %356, i32 noundef %357, %struct.bpf_call_arg_meta* noundef %meta) #20
  %358 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %map_ptr366 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %359 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr366, align 8
  %360 = load i32, i32* %func_id, align 4
  %call367 = call i32 @check_map_func_compatibility(%struct.bpf_verifier_env* noundef %358, %struct.bpf_map* noundef %359, i32 noundef %360) #20
  store i32 %call367, i32* %err, align 4
  %361 = load i32, i32* %err, align 4
  %tobool368 = icmp ne i32 %361, 0
  br i1 %tobool368, label %if.then369, label %if.end370

if.then369:                                       ; preds = %if.end364
  %362 = load i32, i32* %err, align 4
  store i32 %362, i32* %retval, align 4
  br label %return

if.end370:                                        ; preds = %if.end364
  %363 = load i32, i32* %func_id, align 4
  %cmp371 = icmp eq i32 %363, 67
  br i1 %cmp371, label %land.lhs.true376, label %lor.lhs.false373

lor.lhs.false373:                                 ; preds = %if.end370
  %364 = load i32, i32* %func_id, align 4
  %cmp374 = icmp eq i32 %364, 141
  br i1 %cmp374, label %land.lhs.true376, label %if.end392

land.lhs.true376:                                 ; preds = %lor.lhs.false373, %if.end370
  %365 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog377 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %365, i32 0, i32 2
  %366 = load %struct.bpf_prog*, %struct.bpf_prog** %prog377, align 8
  %has_callchain_buf = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %366, i32 0, i32 1
  %bf.load378 = load i16, i16* %has_callchain_buf, align 2
  %bf.lshr379 = lshr i16 %bf.load378, 9
  %bf.clear380 = and i16 %bf.lshr379, 1
  %tobool381 = icmp ne i16 %bf.clear380, 0
  br i1 %tobool381, label %if.end392, label %if.then382

if.then382:                                       ; preds = %land.lhs.true376
  %367 = load i32, i32* @sysctl_perf_event_max_stack, align 4
  %call383 = call i32 @get_callchain_buffers(i32 noundef %367) #20
  store i32 %call383, i32* %err, align 4
  store i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.383, i64 0, i64 0), i8** %err_str, align 8
  %368 = load i32, i32* %err, align 4
  %tobool384 = icmp ne i32 %368, 0
  br i1 %tobool384, label %if.then385, label %if.end387

if.then385:                                       ; preds = %if.then382
  %369 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %370 = bitcast %struct.bpf_verifier_env* %369 to i8*
  %371 = load i8*, i8** %err_str, align 8
  %372 = load i32, i32* %func_id, align 4
  %call386 = call i8* @func_id_name(i32 noundef %372) #20
  %373 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %370, i8* noundef %371, i8* noundef %call386, i32 noundef %373) #20
  %374 = load i32, i32* %err, align 4
  store i32 %374, i32* %retval, align 4
  br label %return

if.end387:                                        ; preds = %if.then382
  %375 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog388 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %375, i32 0, i32 2
  %376 = load %struct.bpf_prog*, %struct.bpf_prog** %prog388, align 8
  %has_callchain_buf389 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %376, i32 0, i32 1
  %bf.load390 = load i16, i16* %has_callchain_buf389, align 2
  %bf.clear391 = and i16 %bf.load390, -513
  %bf.set = or i16 %bf.clear391, 512
  store i16 %bf.set, i16* %has_callchain_buf389, align 2
  br label %if.end392

if.end392:                                        ; preds = %if.end387, %land.lhs.true376, %lor.lhs.false373
  %377 = load i32, i32* %func_id, align 4
  %cmp393 = icmp eq i32 %377, 27
  br i1 %cmp393, label %if.then398, label %lor.lhs.false395

lor.lhs.false395:                                 ; preds = %if.end392
  %378 = load i32, i32* %func_id, align 4
  %cmp396 = icmp eq i32 %378, 67
  br i1 %cmp396, label %if.then398, label %if.end403

if.then398:                                       ; preds = %lor.lhs.false395, %if.end392
  %379 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog399 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %379, i32 0, i32 2
  %380 = load %struct.bpf_prog*, %struct.bpf_prog** %prog399, align 8
  %call_get_stack = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %380, i32 0, i32 1
  %bf.load400 = load i16, i16* %call_get_stack, align 2
  %bf.clear401 = and i16 %bf.load400, -2049
  %bf.set402 = or i16 %bf.clear401, 2048
  store i16 %bf.set402, i16* %call_get_stack, align 2
  br label %if.end403

if.end403:                                        ; preds = %if.then398, %lor.lhs.false395
  %381 = load i32, i32* %func_id, align 4
  %cmp404 = icmp eq i32 %381, 173
  br i1 %cmp404, label %if.then406, label %if.end415

if.then406:                                       ; preds = %if.end403
  %382 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call407 = call i32 @check_get_func_ip(%struct.bpf_verifier_env* noundef %382) #20
  %tobool408 = icmp ne i32 %call407, 0
  br i1 %tobool408, label %if.then409, label %if.end410

if.then409:                                       ; preds = %if.then406
  store i32 -524, i32* %retval, align 4
  br label %return

if.end410:                                        ; preds = %if.then406
  %383 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog411 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %383, i32 0, i32 2
  %384 = load %struct.bpf_prog*, %struct.bpf_prog** %prog411, align 8
  %call_get_func_ip = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %384, i32 0, i32 1
  %bf.load412 = load i16, i16* %call_get_func_ip, align 2
  %bf.clear413 = and i16 %bf.load412, -4097
  %bf.set414 = or i16 %bf.clear413, 4096
  store i16 %bf.set414, i16* %call_get_func_ip, align 2
  br label %if.end415

if.end415:                                        ; preds = %if.end410, %if.end403
  %385 = load i8, i8* %changes_data, align 1
  %tobool416 = trunc i8 %385 to i1
  br i1 %tobool416, label %if.then417, label %if.end418

if.then417:                                       ; preds = %if.end415
  %386 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %386) #20
  br label %if.end418

if.end418:                                        ; preds = %if.then417, %if.end415
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end418, %if.then409, %if.then385, %if.then369, %if.then357, %if.then337, %sw.default, %if.then315, %if.then308, %if.then272, %if.then229, %if.then204, %if.then198, %if.then182, %if.then164, %if.then148, %if.then128, %if.then123, %if.then117, %if.then86, %if.then75, %if.then59, %if.then52, %if.then48, %if.then44, %if.then37, %if.then29, %if.then23, %if.then16, %if.then10, %if.then
  %387 = load i32, i32* %retval, align 4
  ret i32 %387
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %refs_lingering = alloca i8, align 1
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  store i8 0, i8* %refs_lingering, align 1
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %frameno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 2
  %2 = load i32, i32* %frameno, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %in_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 5
  %4 = load i8, i8* %in_callback_fn, align 8
  %tobool1 = trunc i8 %4 to i1
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, i32* %i, align 4
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 8
  %7 = load i32, i32* %acquired_refs, align 4
  %cmp = icmp slt i32 %5, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %in_callback_fn2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 5
  %9 = load i8, i8* %in_callback_fn2, align 8
  %tobool3 = trunc i8 %9 to i1
  br i1 %tobool3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %for.body
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 9
  %11 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %11, i64 %idxprom
  %callback_ref = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx, i32 0, i32 2
  %13 = load i32, i32* %callback_ref, align 4
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %frameno5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 2
  %15 = load i32, i32* %frameno5, align 4
  %cmp6 = icmp ne i32 %13, %15
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true4
  br label %for.inc

if.end8:                                          ; preds = %land.lhs.true4, %for.body
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs9 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 9
  %19 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs9, align 8
  %20 = load i32, i32* %i, align 4
  %idxprom10 = sext i32 %20 to i64
  %arrayidx11 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %19, i64 %idxprom10
  %id = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx11, i32 0, i32 0
  %21 = load i32, i32* %id, align 4
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs12 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 9
  %23 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs12, align 8
  %24 = load i32, i32* %i, align 4
  %idxprom13 = sext i32 %24 to i64
  %arrayidx14 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %23, i64 %idxprom13
  %insn_idx = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx14, i32 0, i32 1
  %25 = load i32, i32* %insn_idx, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.462, i64 0, i64 0), i32 noundef %21, i32 noundef %25) #20
  store i8 1, i8* %refs_lingering, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end8, %if.then7
  %26 = load i32, i32* %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !114

for.end:                                          ; preds = %for.cond
  %27 = load i8, i8* %refs_lingering, align 1
  %tobool15 = trunc i8 %27 to i1
  %28 = zext i1 %tobool15 to i64
  %cond = select i1 %tobool15, i32 -22, i32 0
  store i32 %cond, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %29 = load i32, i32* %retval, align 4
  ret i32 %29
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @prepare_func_exit(%struct.bpf_verifier_env* noundef %env, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %state = alloca %struct.bpf_verifier_state*, align 8
  %caller = alloca %struct.bpf_func_state*, align 8
  %callee = alloca %struct.bpf_func_state*, align 8
  %r0 = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  %range = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %state, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %callee, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arrayidx1 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arrayidx1, %struct.bpf_reg_state** %r0, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 0
  %8 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %8, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.463, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 0
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 4
  %13 = load i32, i32* %curframe3, align 8
  %sub = sub i32 %13, 1
  %idxprom4 = zext i32 %sub to i64
  %arrayidx5 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame2, i64 0, i64 %idxprom4
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx5, align 8
  store %struct.bpf_func_state* %14, %struct.bpf_func_state** %caller, align 8
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %in_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 5
  %16 = load i8, i8* %in_callback_fn, align 8
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %callback_ret_range = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 6
  %18 = bitcast %struct.tnum* %range to i8*
  %19 = bitcast %struct.tnum* %callback_ret_range to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %18, i8* align 8 %19, i64 16, i1 false)
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  %type7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 0
  %21 = load i32, i32* %type7, align 8
  %cmp8 = icmp ne i32 %21, 1
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.then6
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str.464, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.then6
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %25 = bitcast %struct.tnum* %range to { i64, i64 }*
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 0
  %27 = load i64, i64* %26, align 8
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 1
  %29 = load i64, i64* %28, align 8
  %30 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call = call zeroext i1 @tnum_in(i64 %27, i64 %29, i64 %32, i64 %34) #20
  br i1 %call, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end10
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  call void @verbose_invalid_scalar(%struct.bpf_verifier_env* noundef %35, %struct.bpf_reg_state* noundef %36, %struct.tnum* noundef %range, i8* noundef getelementptr inbounds ([16 x i8], [16 x i8]* @.str.465, i64 0, i64 0), i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.466, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end10
  br label %if.end15

if.else:                                          ; preds = %if.end
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs13 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %37, i32 0, i32 0
  %arrayidx14 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs13, i64 0, i64 0
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  %39 = bitcast %struct.bpf_reg_state* %arrayidx14 to i8*
  %40 = bitcast %struct.bpf_reg_state* %38 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %39, i8* align 8 %40, i64 120, i1 false)
  br label %if.end15

if.end15:                                         ; preds = %if.else, %if.end12
  %41 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %in_callback_fn16 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %41, i32 0, i32 5
  %42 = load i8, i8* %in_callback_fn16, align 8
  %tobool17 = trunc i8 %42 to i1
  br i1 %tobool17, label %if.end23, label %if.then18

if.then18:                                        ; preds = %if.end15
  %43 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %44 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %call19 = call i32 @copy_reference_state(%struct.bpf_func_state* noundef %43, %struct.bpf_func_state* noundef %44) #20
  store i32 %call19, i32* %err, align 4
  %45 = load i32, i32* %err, align 4
  %tobool20 = icmp ne i32 %45, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.then18
  %46 = load i32, i32* %err, align 4
  store i32 %46, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.then18
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.end15
  %47 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %47, i32 0, i32 1
  %48 = load i32, i32* %callsite, align 8
  %add = add i32 %48, 1
  %49 = load i32*, i32** %insn_idx.addr, align 8
  store i32 %add, i32* %49, align 4
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %50, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %51 = load i32, i32* %level, align 8
  %and = and i32 %51, 3
  %tobool24 = icmp ne i32 %and, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end23
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.467, i64 0, i64 0)) #20
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %54, %struct.bpf_func_state* noundef %55, i1 noundef zeroext true) #20
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = bitcast %struct.bpf_verifier_env* %56 to i8*
  %58 = load i32*, i32** %insn_idx.addr, align 8
  %59 = load i32, i32* %58, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %57, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.468, i64 0, i64 0), i32 noundef %59) #20
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %60, %struct.bpf_func_state* noundef %61, i1 noundef zeroext true) #20
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %if.end23
  %62 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %62) #20
  %63 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame27 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %63, i32 0, i32 0
  %64 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe28 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %64, i32 0, i32 4
  %65 = load i32, i32* %curframe28, align 8
  %dec = add i32 %65, -1
  store i32 %dec, i32* %curframe28, align 8
  %idxprom29 = zext i32 %65 to i64
  %arrayidx30 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame27, i64 0, i64 %idxprom29
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx30, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end26, %if.then21, %if.then11, %if.then9, %if.then
  %66 = load i32, i32* %retval, align 4
  ret i32 %66
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_return_code(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %enforce_attach_type_range = alloca %struct.tnum, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %range = alloca %struct.tnum, align 8
  %prog_type = alloca i32, align 4
  %err = alloca i32, align 4
  %frame = alloca %struct.bpf_func_state*, align 8
  %is_subprog = alloca i8, align 1
  %agg.tmp = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %tmp76 = alloca %struct.tnum, align 8
  %tmp84 = alloca %struct.tnum, align 8
  %tmp86 = alloca %struct.tnum, align 8
  %tmp96 = alloca %struct.tnum, align 8
  %tmp102 = alloca %struct.tnum, align 8
  %tmp109 = alloca %struct.tnum, align 8
  %tmp123 = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = bitcast %struct.tnum* %enforce_attach_type_range to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %0, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %2, %struct.bpf_prog** %prog, align 8
  %call = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #20
  %3 = bitcast %struct.tnum* %range to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 2
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %call3 = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %9) #20
  store i32 %call3, i32* %prog_type, align 4
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 8
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %frame4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame4, i64 0, i64 0
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %12, %struct.bpf_func_state** %frame, align 8
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %subprogno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 3
  %14 = load i32, i32* %subprogno, align 8
  %tobool = icmp ne i32 %14, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* %is_subprog, align 1
  %15 = load i8, i8* %is_subprog, align 1
  %tobool5 = trunc i8 %15 to i1
  br i1 %tobool5, label %if.end11, label %if.then

if.then:                                          ; preds = %entry
  %16 = load i32, i32* %prog_type, align 4
  switch i32 %16, label %sw.default [
    i32 29, label %sw.bb
    i32 27, label %sw.bb7
  ]

sw.bb:                                            ; preds = %if.then
  %17 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %17, i32 0, i32 3
  %18 = load i32, i32* %expected_attach_type, align 8
  %cmp = icmp eq i32 %18, 43
  br i1 %cmp, label %if.then6, label %if.end

if.then6:                                         ; preds = %sw.bb
  br label %sw.epilog

if.end:                                           ; preds = %sw.bb
  br label %sw.bb7

sw.bb7:                                           ; preds = %if.then, %if.end
  %19 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %19, i32 0, i32 10
  %20 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %attach_func_proto = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %20, i32 0, i32 28
  %21 = load %struct.btf_type*, %struct.btf_type** %attach_func_proto, align 8
  %22 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %21, i32 0, i32 2
  %type = bitcast %union.anon.137* %22 to i32*
  %23 = load i32, i32* %type, align 4
  %tobool8 = icmp ne i32 %23, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %sw.bb7
  store i32 0, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %sw.bb7
  br label %sw.epilog

sw.default:                                       ; preds = %if.then
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end10, %if.then6
  br label %if.end11

if.end11:                                         ; preds = %sw.epilog, %entry
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call12 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %24, i32 noundef 0, i32 noundef 0) #20
  store i32 %call12, i32* %err, align 4
  %25 = load i32, i32* %err, align 4
  %tobool13 = icmp ne i32 %25, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end11
  %26 = load i32, i32* %err, align 4
  store i32 %26, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end11
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call16 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %27, i32 noundef 0) #20
  br i1 %call16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end15
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.473, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end15
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call19 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %30) #20
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call19, i64 0
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  %31 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %in_async_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %31, i32 0, i32 7
  %32 = load i8, i8* %in_async_callback_fn, align 8
  %tobool20 = trunc i8 %32 to i1
  br i1 %tobool20, label %if.then21, label %if.end32

if.then21:                                        ; preds = %if.end18
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 0
  %34 = load i32, i32* %type22, align 8
  %cmp23 = icmp ne i32 %34, 1
  br i1 %cmp23, label %if.then24, label %if.end27

if.then24:                                        ; preds = %if.then21
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 0
  %39 = load i32, i32* %type25, align 8
  %call26 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %37, i32 noundef %39) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([61 x i8], [61 x i8]* @.str.474, i64 0, i64 0), i8* noundef %call26) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.then21
  %call28 = call { i64, i64 } @tnum_const(i64 noundef 0) #20
  %40 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %40, i32 0, i32 0
  %42 = extractvalue { i64, i64 } %call28, 0
  store i64 %42, i64* %41, align 8
  %43 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %40, i32 0, i32 1
  %44 = extractvalue { i64, i64 } %call28, 1
  store i64 %44, i64* %43, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 5
  %46 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %47 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 0
  %48 = load i64, i64* %47, align 8
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %46, i32 0, i32 1
  %50 = load i64, i64* %49, align 8
  %51 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = load i64, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = load i64, i64* %54, align 8
  %call29 = call zeroext i1 @tnum_in(i64 %48, i64 %50, i64 %53, i64 %55) #20
  br i1 %call29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.end27
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @verbose_invalid_scalar(%struct.bpf_verifier_env* noundef %56, %struct.bpf_reg_state* noundef %57, %struct.tnum* noundef %range, i8* noundef getelementptr inbounds ([15 x i8], [15 x i8]* @.str.475, i64 0, i64 0), i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.466, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end27
  store i32 0, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.end18
  %58 = load i8, i8* %is_subprog, align 1
  %tobool33 = trunc i8 %58 to i1
  br i1 %tobool33, label %if.then34, label %if.end41

if.then34:                                        ; preds = %if.end32
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 0
  %60 = load i32, i32* %type35, align 8
  %cmp36 = icmp ne i32 %60, 1
  br i1 %cmp36, label %if.then37, label %if.end40

if.then37:                                        ; preds = %if.then34
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %62 = bitcast %struct.bpf_verifier_env* %61 to i8*
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type38 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %64, i32 0, i32 0
  %65 = load i32, i32* %type38, align 8
  %call39 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %63, i32 noundef %65) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %62, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.476, i64 0, i64 0), i8* noundef %call39) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end40:                                         ; preds = %if.then34
  store i32 0, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end32
  %66 = load i32, i32* %prog_type, align 4
  switch i32 %66, label %sw.default127 [
    i32 18, label %sw.bb42
    i32 8, label %sw.bb79
    i32 9, label %sw.bb89
    i32 13, label %sw.bb89
    i32 15, label %sw.bb89
    i32 23, label %sw.bb89
    i32 25, label %sw.bb89
    i32 17, label %sw.bb90
    i32 26, label %sw.bb98
    i32 30, label %sw.bb108
    i32 29, label %sw.bb111
    i32 28, label %sw.bb126
  ]

sw.bb42:                                          ; preds = %if.end41
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog43 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %67, i32 0, i32 2
  %68 = load %struct.bpf_prog*, %struct.bpf_prog** %prog43, align 8
  %expected_attach_type44 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %68, i32 0, i32 3
  %69 = load i32, i32* %expected_attach_type44, align 8
  %cmp45 = icmp eq i32 %69, 19
  br i1 %cmp45, label %if.then65, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb42
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog46 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %70, i32 0, i32 2
  %71 = load %struct.bpf_prog*, %struct.bpf_prog** %prog46, align 8
  %expected_attach_type47 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %71, i32 0, i32 3
  %72 = load i32, i32* %expected_attach_type47, align 8
  %cmp48 = icmp eq i32 %72, 20
  br i1 %cmp48, label %if.then65, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %lor.lhs.false
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog50 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %73, i32 0, i32 2
  %74 = load %struct.bpf_prog*, %struct.bpf_prog** %prog50, align 8
  %expected_attach_type51 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %74, i32 0, i32 3
  %75 = load i32, i32* %expected_attach_type51, align 8
  %cmp52 = icmp eq i32 %75, 29
  br i1 %cmp52, label %if.then65, label %lor.lhs.false53

lor.lhs.false53:                                  ; preds = %lor.lhs.false49
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog54 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %76, i32 0, i32 2
  %77 = load %struct.bpf_prog*, %struct.bpf_prog** %prog54, align 8
  %expected_attach_type55 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %77, i32 0, i32 3
  %78 = load i32, i32* %expected_attach_type55, align 8
  %cmp56 = icmp eq i32 %78, 30
  br i1 %cmp56, label %if.then65, label %lor.lhs.false57

lor.lhs.false57:                                  ; preds = %lor.lhs.false53
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog58 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %79, i32 0, i32 2
  %80 = load %struct.bpf_prog*, %struct.bpf_prog** %prog58, align 8
  %expected_attach_type59 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %80, i32 0, i32 3
  %81 = load i32, i32* %expected_attach_type59, align 8
  %cmp60 = icmp eq i32 %81, 31
  br i1 %cmp60, label %if.then65, label %lor.lhs.false61

lor.lhs.false61:                                  ; preds = %lor.lhs.false57
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog62 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %82, i32 0, i32 2
  %83 = load %struct.bpf_prog*, %struct.bpf_prog** %prog62, align 8
  %expected_attach_type63 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %83, i32 0, i32 3
  %84 = load i32, i32* %expected_attach_type63, align 8
  %cmp64 = icmp eq i32 %84, 32
  br i1 %cmp64, label %if.then65, label %if.end67

if.then65:                                        ; preds = %lor.lhs.false61, %lor.lhs.false57, %lor.lhs.false53, %lor.lhs.false49, %lor.lhs.false, %sw.bb42
  %call66 = call { i64, i64 } @tnum_range(i64 noundef 1, i64 noundef 1) #20
  %85 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %85, i32 0, i32 0
  %87 = extractvalue { i64, i64 } %call66, 0
  store i64 %87, i64* %86, align 8
  %88 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %85, i32 0, i32 1
  %89 = extractvalue { i64, i64 } %call66, 1
  store i64 %89, i64* %88, align 8
  %90 = bitcast %struct.tnum* %range to i8*
  %91 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %90, i8* align 8 %91, i64 16, i1 false)
  br label %if.end67

if.end67:                                         ; preds = %if.then65, %lor.lhs.false61
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog68 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %92, i32 0, i32 2
  %93 = load %struct.bpf_prog*, %struct.bpf_prog** %prog68, align 8
  %expected_attach_type69 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %93, i32 0, i32 3
  %94 = load i32, i32* %expected_attach_type69, align 8
  %cmp70 = icmp eq i32 %94, 8
  br i1 %cmp70, label %if.then75, label %lor.lhs.false71

lor.lhs.false71:                                  ; preds = %if.end67
  %95 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog72 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %95, i32 0, i32 2
  %96 = load %struct.bpf_prog*, %struct.bpf_prog** %prog72, align 8
  %expected_attach_type73 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %96, i32 0, i32 3
  %97 = load i32, i32* %expected_attach_type73, align 8
  %cmp74 = icmp eq i32 %97, 9
  br i1 %cmp74, label %if.then75, label %if.end78

if.then75:                                        ; preds = %lor.lhs.false71, %if.end67
  %call77 = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 3) #20
  %98 = bitcast %struct.tnum* %tmp76 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = extractvalue { i64, i64 } %call77, 0
  store i64 %100, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = extractvalue { i64, i64 } %call77, 1
  store i64 %102, i64* %101, align 8
  %103 = bitcast %struct.tnum* %range to i8*
  %104 = bitcast %struct.tnum* %tmp76 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %103, i8* align 8 %104, i64 16, i1 false)
  br label %if.end78

if.end78:                                         ; preds = %if.then75, %lor.lhs.false71
  br label %sw.epilog128

sw.bb79:                                          ; preds = %if.end41
  %105 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog80 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %105, i32 0, i32 2
  %106 = load %struct.bpf_prog*, %struct.bpf_prog** %prog80, align 8
  %expected_attach_type81 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %106, i32 0, i32 3
  %107 = load i32, i32* %expected_attach_type81, align 8
  %cmp82 = icmp eq i32 %107, 1
  br i1 %cmp82, label %if.then83, label %if.end88

if.then83:                                        ; preds = %sw.bb79
  %call85 = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 3) #20
  %108 = bitcast %struct.tnum* %tmp84 to { i64, i64 }*
  %109 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %108, i32 0, i32 0
  %110 = extractvalue { i64, i64 } %call85, 0
  store i64 %110, i64* %109, align 8
  %111 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %108, i32 0, i32 1
  %112 = extractvalue { i64, i64 } %call85, 1
  store i64 %112, i64* %111, align 8
  %113 = bitcast %struct.tnum* %range to i8*
  %114 = bitcast %struct.tnum* %tmp84 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %113, i8* align 8 %114, i64 16, i1 false)
  %call87 = call { i64, i64 } @tnum_range(i64 noundef 2, i64 noundef 3) #20
  %115 = bitcast %struct.tnum* %tmp86 to { i64, i64 }*
  %116 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %115, i32 0, i32 0
  %117 = extractvalue { i64, i64 } %call87, 0
  store i64 %117, i64* %116, align 8
  %118 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %115, i32 0, i32 1
  %119 = extractvalue { i64, i64 } %call87, 1
  store i64 %119, i64* %118, align 8
  %120 = bitcast %struct.tnum* %enforce_attach_type_range to i8*
  %121 = bitcast %struct.tnum* %tmp86 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %120, i8* align 8 %121, i64 16, i1 false)
  br label %if.end88

if.end88:                                         ; preds = %if.then83, %sw.bb79
  br label %sw.epilog128

sw.bb89:                                          ; preds = %if.end41, %if.end41, %if.end41, %if.end41, %if.end41
  br label %sw.epilog128

sw.bb90:                                          ; preds = %if.end41
  %122 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog91 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %122, i32 0, i32 2
  %123 = load %struct.bpf_prog*, %struct.bpf_prog** %prog91, align 8
  %aux92 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %123, i32 0, i32 10
  %124 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux92, align 8
  %attach_btf_id = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %124, i32 0, i32 10
  %125 = load i32, i32* %attach_btf_id, align 4
  %tobool93 = icmp ne i32 %125, 0
  br i1 %tobool93, label %if.end95, label %if.then94

if.then94:                                        ; preds = %sw.bb90
  store i32 0, i32* %retval, align 4
  br label %return

if.end95:                                         ; preds = %sw.bb90
  %call97 = call { i64, i64 } @tnum_const(i64 noundef 0) #20
  %126 = bitcast %struct.tnum* %tmp96 to { i64, i64 }*
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %126, i32 0, i32 0
  %128 = extractvalue { i64, i64 } %call97, 0
  store i64 %128, i64* %127, align 8
  %129 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %126, i32 0, i32 1
  %130 = extractvalue { i64, i64 } %call97, 1
  store i64 %130, i64* %129, align 8
  %131 = bitcast %struct.tnum* %range to i8*
  %132 = bitcast %struct.tnum* %tmp96 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %131, i8* align 8 %132, i64 16, i1 false)
  br label %sw.epilog128

sw.bb98:                                          ; preds = %if.end41
  %133 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog99 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %133, i32 0, i32 2
  %134 = load %struct.bpf_prog*, %struct.bpf_prog** %prog99, align 8
  %expected_attach_type100 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %134, i32 0, i32 3
  %135 = load i32, i32* %expected_attach_type100, align 8
  switch i32 %135, label %sw.default106 [
    i32 24, label %sw.bb101
    i32 25, label %sw.bb101
    i32 23, label %sw.bb104
    i32 26, label %sw.bb104
    i32 28, label %sw.bb105
  ]

sw.bb101:                                         ; preds = %sw.bb98, %sw.bb98
  %call103 = call { i64, i64 } @tnum_const(i64 noundef 0) #20
  %136 = bitcast %struct.tnum* %tmp102 to { i64, i64 }*
  %137 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %136, i32 0, i32 0
  %138 = extractvalue { i64, i64 } %call103, 0
  store i64 %138, i64* %137, align 8
  %139 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %136, i32 0, i32 1
  %140 = extractvalue { i64, i64 } %call103, 1
  store i64 %140, i64* %139, align 8
  %141 = bitcast %struct.tnum* %range to i8*
  %142 = bitcast %struct.tnum* %tmp102 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %141, i8* align 8 %142, i64 16, i1 false)
  br label %sw.epilog107

sw.bb104:                                         ; preds = %sw.bb98, %sw.bb98
  store i32 0, i32* %retval, align 4
  br label %return

sw.bb105:                                         ; preds = %sw.bb98
  br label %sw.epilog107

sw.default106:                                    ; preds = %sw.bb98
  store i32 -524, i32* %retval, align 4
  br label %return

sw.epilog107:                                     ; preds = %sw.bb105, %sw.bb101
  br label %sw.epilog128

sw.bb108:                                         ; preds = %if.end41
  %call110 = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #20
  %143 = bitcast %struct.tnum* %tmp109 to { i64, i64 }*
  %144 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %143, i32 0, i32 0
  %145 = extractvalue { i64, i64 } %call110, 0
  store i64 %145, i64* %144, align 8
  %146 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %143, i32 0, i32 1
  %147 = extractvalue { i64, i64 } %call110, 1
  store i64 %147, i64* %146, align 8
  %148 = bitcast %struct.tnum* %range to i8*
  %149 = bitcast %struct.tnum* %tmp109 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %148, i8* align 8 %149, i64 16, i1 false)
  br label %sw.epilog128

sw.bb111:                                         ; preds = %if.end41
  %150 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog112 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %150, i32 0, i32 2
  %151 = load %struct.bpf_prog*, %struct.bpf_prog** %prog112, align 8
  %expected_attach_type113 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %151, i32 0, i32 3
  %152 = load i32, i32* %expected_attach_type113, align 8
  %cmp114 = icmp ne i32 %152, 43
  br i1 %cmp114, label %if.then115, label %if.end116

if.then115:                                       ; preds = %sw.bb111
  store i32 0, i32* %retval, align 4
  br label %return

if.end116:                                        ; preds = %sw.bb111
  %153 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog117 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %153, i32 0, i32 2
  %154 = load %struct.bpf_prog*, %struct.bpf_prog** %prog117, align 8
  %aux118 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %154, i32 0, i32 10
  %155 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux118, align 8
  %attach_func_proto119 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %155, i32 0, i32 28
  %156 = load %struct.btf_type*, %struct.btf_type** %attach_func_proto119, align 8
  %157 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %156, i32 0, i32 2
  %type120 = bitcast %union.anon.137* %157 to i32*
  %158 = load i32, i32* %type120, align 4
  %tobool121 = icmp ne i32 %158, 0
  br i1 %tobool121, label %if.end125, label %if.then122

if.then122:                                       ; preds = %if.end116
  %call124 = call { i64, i64 } @tnum_range(i64 noundef 1, i64 noundef 1) #20
  %159 = bitcast %struct.tnum* %tmp123 to { i64, i64 }*
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 0
  %161 = extractvalue { i64, i64 } %call124, 0
  store i64 %161, i64* %160, align 8
  %162 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 1
  %163 = extractvalue { i64, i64 } %call124, 1
  store i64 %163, i64* %162, align 8
  %164 = bitcast %struct.tnum* %range to i8*
  %165 = bitcast %struct.tnum* %tmp123 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %164, i8* align 8 %165, i64 16, i1 false)
  br label %if.end125

if.end125:                                        ; preds = %if.then122, %if.end116
  br label %sw.epilog128

sw.bb126:                                         ; preds = %if.end41
  br label %sw.default127

sw.default127:                                    ; preds = %if.end41, %sw.bb126
  store i32 0, i32* %retval, align 4
  br label %return

sw.epilog128:                                     ; preds = %if.end125, %sw.bb108, %sw.epilog107, %if.end95, %sw.bb89, %if.end88, %if.end78
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type129 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %166, i32 0, i32 0
  %167 = load i32, i32* %type129, align 8
  %cmp130 = icmp ne i32 %167, 1
  br i1 %cmp130, label %if.then131, label %if.end134

if.then131:                                       ; preds = %sw.epilog128
  %168 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %169 = bitcast %struct.bpf_verifier_env* %168 to i8*
  %170 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %171 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %171, i32 0, i32 0
  %172 = load i32, i32* %type132, align 8
  %call133 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %170, i32 noundef %172) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %169, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.477, i64 0, i64 0), i8* noundef %call133) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end134:                                        ; preds = %sw.epilog128
  %173 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off135 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %173, i32 0, i32 5
  %174 = bitcast %struct.tnum* %range to { i64, i64 }*
  %175 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %174, i32 0, i32 0
  %176 = load i64, i64* %175, align 8
  %177 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %174, i32 0, i32 1
  %178 = load i64, i64* %177, align 8
  %179 = bitcast %struct.tnum* %var_off135 to { i64, i64 }*
  %180 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %179, i32 0, i32 0
  %181 = load i64, i64* %180, align 8
  %182 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %179, i32 0, i32 1
  %183 = load i64, i64* %182, align 8
  %call136 = call zeroext i1 @tnum_in(i64 %176, i64 %178, i64 %181, i64 %183) #20
  br i1 %call136, label %if.end148, label %if.then137

if.then137:                                       ; preds = %if.end134
  %184 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %185 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @verbose_invalid_scalar(%struct.bpf_verifier_env* noundef %184, %struct.bpf_reg_state* noundef %185, %struct.tnum* noundef %range, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.478, i64 0, i64 0), i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.466, i64 0, i64 0)) #20
  %186 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type138 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %186, i32 0, i32 3
  %187 = load i32, i32* %expected_attach_type138, align 8
  %cmp139 = icmp eq i32 %187, 43
  br i1 %cmp139, label %land.lhs.true, label %if.end147

land.lhs.true:                                    ; preds = %if.then137
  %188 = load i32, i32* %prog_type, align 4
  %cmp140 = icmp eq i32 %188, 29
  br i1 %cmp140, label %land.lhs.true141, label %if.end147

land.lhs.true141:                                 ; preds = %land.lhs.true
  %189 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux142 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %189, i32 0, i32 10
  %190 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux142, align 8
  %attach_func_proto143 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %190, i32 0, i32 28
  %191 = load %struct.btf_type*, %struct.btf_type** %attach_func_proto143, align 8
  %192 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %191, i32 0, i32 2
  %type144 = bitcast %union.anon.137* %192 to i32*
  %193 = load i32, i32* %type144, align 4
  %tobool145 = icmp ne i32 %193, 0
  br i1 %tobool145, label %if.end147, label %if.then146

if.then146:                                       ; preds = %land.lhs.true141
  %194 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %195 = bitcast %struct.bpf_verifier_env* %194 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %195, i8* noundef getelementptr inbounds ([79 x i8], [79 x i8]* @.str.479, i64 0, i64 0)) #20
  br label %if.end147

if.end147:                                        ; preds = %if.then146, %land.lhs.true141, %land.lhs.true, %if.then137
  store i32 -22, i32* %retval, align 4
  br label %return

if.end148:                                        ; preds = %if.end134
  %196 = bitcast %struct.tnum* %enforce_attach_type_range to { i64, i64 }*
  %197 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %196, i32 0, i32 0
  %198 = load i64, i64* %197, align 8
  %199 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %196, i32 0, i32 1
  %200 = load i64, i64* %199, align 8
  %call149 = call zeroext i1 @tnum_is_unknown(i64 %198, i64 %200) #20
  br i1 %call149, label %if.end155, label %land.lhs.true150

land.lhs.true150:                                 ; preds = %if.end148
  %201 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off151 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %201, i32 0, i32 5
  %202 = bitcast %struct.tnum* %enforce_attach_type_range to { i64, i64 }*
  %203 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %202, i32 0, i32 0
  %204 = load i64, i64* %203, align 8
  %205 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %202, i32 0, i32 1
  %206 = load i64, i64* %205, align 8
  %207 = bitcast %struct.tnum* %var_off151 to { i64, i64 }*
  %208 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %207, i32 0, i32 0
  %209 = load i64, i64* %208, align 8
  %210 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %207, i32 0, i32 1
  %211 = load i64, i64* %210, align 8
  %call152 = call zeroext i1 @tnum_in(i64 %204, i64 %206, i64 %209, i64 %211) #20
  br i1 %call152, label %if.then153, label %if.end155

if.then153:                                       ; preds = %land.lhs.true150
  %212 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog154 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %212, i32 0, i32 2
  %213 = load %struct.bpf_prog*, %struct.bpf_prog** %prog154, align 8
  %enforce_expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %213, i32 0, i32 1
  %bf.load = load i16, i16* %enforce_expected_attach_type, align 2
  %bf.clear = and i16 %bf.load, -1025
  %bf.set = or i16 %bf.clear, 1024
  store i16 %bf.set, i16* %enforce_expected_attach_type, align 2
  br label %if.end155

if.end155:                                        ; preds = %if.then153, %land.lhs.true150, %if.end148
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end155, %if.end147, %if.then131, %sw.default127, %if.then115, %sw.default106, %sw.bb104, %if.then94, %if.end40, %if.then37, %if.end31, %if.then30, %if.then24, %if.then17, %if.then14, %if.then9
  %214 = load i32, i32* %retval, align 4
  ret i32 %214
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @update_branch_counts(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %br = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_cond = alloca i8, align 1
  %__ret_once = alloca i8, align 1
  %tmp = alloca i64, align 8
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp41 = alloca i64, align 8
  %tmp49 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end58, %entry
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %0, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 2
  %2 = load i32, i32* %branches, align 8
  %dec = add i32 %2, -1
  store i32 %dec, i32* %branches, align 8
  store i32 %dec, i32* %br, align 4
  %3 = load i32, i32* %br, align 4
  %cmp = icmp slt i32 %3, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %frombool = zext i1 %lnot1 to i8
  store i8 %frombool, i8* %__ret_do_once, align 1
  %4 = load i8, i8* %__ret_do_once, align 1
  %tobool2 = trunc i8 %4 to i1
  %lnot3 = xor i1 %tobool2, true
  %lnot4 = xor i1 %lnot3, true
  %frombool5 = zext i1 %lnot4 to i8
  store i8 %frombool5, i8* %__ret_cond, align 1
  store i8 0, i8* %__ret_once, align 1
  %5 = load i8, i8* %__ret_cond, align 1
  %tobool6 = trunc i8 %5 to i1
  br i1 %tobool6, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.body
  %6 = load i8, i8* @update_branch_counts.__already_done, align 1
  %tobool7 = trunc i8 %6 to i1
  %lnot8 = xor i1 %tobool7, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.body
  %7 = phi i1 [ false, %while.body ], [ %lnot8, %land.rhs ]
  %lnot9 = xor i1 %7, true
  %lnot10 = xor i1 %lnot9, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool11 = icmp ne i64 %conv, 0
  br i1 %tobool11, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  store i8 1, i8* @update_branch_counts.__already_done, align 1
  store i8 1, i8* %__ret_once, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.end
  %8 = load i8, i8* %__ret_once, align 1
  %tobool12 = trunc i8 %8 to i1
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  store i64 %conv17, i64* %tmp, align 8
  %9 = load i64, i64* %tmp, align 8
  %tobool18 = icmp ne i64 %9, 0
  br i1 %tobool18, label %if.then19, label %if.end48

if.then19:                                        ; preds = %if.end
  store i32 1, i32* %__ret_warn_on, align 4
  %10 = load i32, i32* %__ret_warn_on, align 4
  %tobool20 = icmp ne i32 %10, 0
  %lnot21 = xor i1 %tobool20, true
  %lnot23 = xor i1 %lnot21, true
  %lnot.ext24 = zext i1 %lnot23 to i32
  %conv25 = sext i32 %lnot.ext24 to i64
  %tobool26 = icmp ne i64 %conv25, 0
  br i1 %tobool26, label %if.then27, label %if.end40

if.then27:                                        ; preds = %if.then19
  br label %do.body

do.body:                                          ; preds = %if.then27
  br label %do.body28

do.body28:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body28
  %11 = load i32, i32* %br, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.480, i64 0, i64 0), i32 noundef %11) #20
  br label %do.body29

do.body29:                                        ; preds = %do.end
  store i32 2313, i32* %__flags, align 4
  br label %do.body30

do.body30:                                        ; preds = %do.body29
  br label %do.end31

do.end31:                                         ; preds = %do.body30
  br label %do.body32

do.body32:                                        ; preds = %do.end31
  %12 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1324, i32 %12, i64 12) #19, !srcloc !115
  br label %do.end33

do.end33:                                         ; preds = %do.body32
  br label %do.body34

do.body34:                                        ; preds = %do.end33
  br label %do.end35

do.end35:                                         ; preds = %do.body34
  br label %do.end36

do.end36:                                         ; preds = %do.end35
  br label %do.body37

do.body37:                                        ; preds = %do.end36
  br label %do.end38

do.end38:                                         ; preds = %do.body37
  br label %do.end39

do.end39:                                         ; preds = %do.end38
  br label %if.end40

if.end40:                                         ; preds = %do.end39, %if.then19
  %13 = load i32, i32* %__ret_warn_on, align 4
  %tobool42 = icmp ne i32 %13, 0
  %lnot43 = xor i1 %tobool42, true
  %lnot45 = xor i1 %lnot43, true
  %lnot.ext46 = zext i1 %lnot45 to i32
  %conv47 = sext i32 %lnot.ext46 to i64
  store i64 %conv47, i64* %tmp41, align 8
  %14 = load i64, i64* %tmp41, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.end40, %if.end
  %15 = load i8, i8* %__ret_do_once, align 1
  %tobool50 = trunc i8 %15 to i1
  %lnot51 = xor i1 %tobool50, true
  %lnot53 = xor i1 %lnot51, true
  %lnot.ext54 = zext i1 %lnot53 to i32
  %conv55 = sext i32 %lnot.ext54 to i64
  store i64 %conv55, i64* %tmp49, align 8
  %16 = load i64, i64* %tmp49, align 8
  %17 = load i32, i32* %br, align 4
  %tobool56 = icmp ne i32 %17, 0
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.end48
  br label %while.end

if.end58:                                         ; preds = %if.end48
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 1
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  store %struct.bpf_verifier_state* %19, %struct.bpf_verifier_state** %st.addr, align 8
  br label %while.cond, !llvm.loop !116

while.end:                                        ; preds = %if.then57, %while.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_cond_jmp_op(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %this_branch = alloca %struct.bpf_verifier_state*, align 8
  %other_branch = alloca %struct.bpf_verifier_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %other_branch_regs = alloca %struct.bpf_reg_state*, align 8
  %src_reg = alloca %struct.bpf_reg_state*, align 8
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %err = alloca i32, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %src_reg197 = alloca %struct.bpf_reg_state*, align 8
  %agg.tmp218 = alloca %struct.tnum, align 8
  %coerce233 = alloca %struct.tnum, align 8
  %agg.tmp245 = alloca %struct.tnum, align 8
  %coerce260 = alloca %struct.tnum, align 8
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_warn_on353 = alloca i32, align 4
  %__flags376 = alloca i32, align 4
  %tmp385 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %this_branch, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %src_reg, align 8
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code, align 4
  %conv = zext i8 %7 to i32
  %and = and i32 %conv, 240
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %opcode, align 1
  store i32 -1, i32* %pred, align 4
  %8 = load i8, i8* %opcode, align 1
  %conv3 = zext i8 %8 to i32
  %cmp = icmp eq i32 %conv3, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %9 = load i8, i8* %opcode, align 1
  %conv5 = zext i8 %9 to i32
  %cmp6 = icmp sgt i32 %conv5, 208
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load i8, i8* %opcode, align 1
  %conv8 = zext i8 %12 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.481, i64 0, i64 0), i32 noundef %conv8) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 0
  %14 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %14 to i32
  %and11 = and i32 %conv10, 8
  %cmp12 = icmp eq i32 %and11, 8
  br i1 %cmp12, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 3
  %16 = load i32, i32* %imm, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then14
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.482, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.then14
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg19 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg19, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv20 = zext i8 %bf.lshr to i32
  %call = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %19, i32 noundef %conv20, i32 noundef 0) #20
  store i32 %call, i32* %err, align 4
  %21 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %21, 0
  br i1 %tobool, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  %22 = load i32, i32* %err, align 4
  store i32 %22, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end18
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 1
  %bf.load24 = load i8, i8* %src_reg23, align 1
  %bf.lshr25 = lshr i8 %bf.load24, 4
  %conv26 = zext i8 %bf.lshr25 to i32
  %call27 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %23, i32 noundef %conv26) #20
  br i1 %call27, label %if.then28, label %if.end33

if.then28:                                        ; preds = %if.end22
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg29 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %27, i32 0, i32 1
  %bf.load30 = load i8, i8* %src_reg29, align 1
  %bf.lshr31 = lshr i8 %bf.load30, 4
  %conv32 = zext i8 %bf.lshr31 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.483, i64 0, i64 0), i32 noundef %conv32) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end22
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load35 = load i8, i8* %src_reg34, align 1
  %bf.lshr36 = lshr i8 %bf.load35, 4
  %idxprom37 = zext i8 %bf.lshr36 to i64
  %arrayidx38 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i64 %idxprom37
  store %struct.bpf_reg_state* %arrayidx38, %struct.bpf_reg_state** %src_reg, align 8
  br label %if.end47

if.else:                                          ; preds = %if.end
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %30, i32 0, i32 1
  %bf.load40 = load i8, i8* %src_reg39, align 1
  %bf.lshr41 = lshr i8 %bf.load40, 4
  %conv42 = zext i8 %bf.lshr41 to i32
  %cmp43 = icmp ne i32 %conv42, 0
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.else
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = bitcast %struct.bpf_verifier_env* %31 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %32, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.482, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end46:                                         ; preds = %if.else
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.end33
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg48 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %34, i32 0, i32 1
  %bf.load49 = load i8, i8* %dst_reg48, align 1
  %bf.clear = and i8 %bf.load49, 15
  %conv50 = zext i8 %bf.clear to i32
  %call51 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %33, i32 noundef %conv50, i32 noundef 0) #20
  store i32 %call51, i32* %err, align 4
  %35 = load i32, i32* %err, align 4
  %tobool52 = icmp ne i32 %35, 0
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end47
  %36 = load i32, i32* %err, align 4
  store i32 %36, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.end47
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg55 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 1
  %bf.load56 = load i8, i8* %dst_reg55, align 1
  %bf.clear57 = and i8 %bf.load56, 15
  %idxprom58 = zext i8 %bf.clear57 to i64
  %arrayidx59 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i64 %idxprom58
  store %struct.bpf_reg_state* %arrayidx59, %struct.bpf_reg_state** %dst_reg, align 8
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %39, i32 0, i32 0
  %40 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %40 to i32
  %and62 = and i32 %conv61, 7
  %cmp63 = icmp eq i32 %and62, 6
  %frombool = zext i1 %cmp63 to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code65 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %41, i32 0, i32 0
  %42 = load i8, i8* %code65, align 4
  %conv66 = zext i8 %42 to i32
  %and67 = and i32 %conv66, 8
  %cmp68 = icmp eq i32 %and67, 0
  br i1 %cmp68, label %if.then70, label %if.else75

if.then70:                                        ; preds = %if.end54
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm71 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 3
  %45 = load i32, i32* %imm71, align 4
  %conv72 = sext i32 %45 to i64
  %46 = load i8, i8* %opcode, align 1
  %47 = load i8, i8* %is_jmp32, align 1
  %tobool73 = trunc i8 %47 to i1
  %call74 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %43, i64 noundef %conv72, i8 noundef zeroext %46, i1 noundef zeroext %tobool73) #20
  store i32 %call74, i32* %pred, align 4
  br label %if.end117

if.else75:                                        ; preds = %if.end54
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 0
  %49 = load i32, i32* %type, align 8
  %cmp76 = icmp eq i32 %49, 1
  br i1 %cmp76, label %land.lhs.true, label %if.else89

land.lhs.true:                                    ; preds = %if.else75
  %50 = load i8, i8* %is_jmp32, align 1
  %tobool78 = trunc i8 %50 to i1
  br i1 %tobool78, label %land.lhs.true80, label %if.else89

land.lhs.true80:                                  ; preds = %land.lhs.true
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %51, i32 0, i32 5
  %52 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 0
  %54 = load i64, i64* %53, align 8
  %55 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 1
  %56 = load i64, i64* %55, align 8
  %call81 = call { i64, i64 } @tnum_subreg(i64 %54, i64 %56) #20
  %57 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 0
  %59 = extractvalue { i64, i64 } %call81, 0
  store i64 %59, i64* %58, align 8
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 1
  %61 = extractvalue { i64, i64 } %call81, 1
  store i64 %61, i64* %60, align 8
  %62 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 0
  %64 = load i64, i64* %63, align 8
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 1
  %66 = load i64, i64* %65, align 8
  %call82 = call zeroext i1 @tnum_is_const(i64 %64, i64 %66) #20
  br i1 %call82, label %if.then84, label %if.else89

if.then84:                                        ; preds = %land.lhs.true80
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 5
  %69 = bitcast %struct.tnum* %var_off85 to { i64, i64 }*
  %70 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %69, i32 0, i32 0
  %71 = load i64, i64* %70, align 8
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %69, i32 0, i32 1
  %73 = load i64, i64* %72, align 8
  %call86 = call { i64, i64 } @tnum_subreg(i64 %71, i64 %73) #20
  %74 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %75 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %74, i32 0, i32 0
  %76 = extractvalue { i64, i64 } %call86, 0
  store i64 %76, i64* %75, align 8
  %77 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %74, i32 0, i32 1
  %78 = extractvalue { i64, i64 } %call86, 1
  store i64 %78, i64* %77, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %79 = load i64, i64* %value, align 8
  %80 = load i8, i8* %opcode, align 1
  %81 = load i8, i8* %is_jmp32, align 1
  %tobool87 = trunc i8 %81 to i1
  %call88 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %67, i64 noundef %79, i8 noundef zeroext %80, i1 noundef zeroext %tobool87) #20
  store i32 %call88, i32* %pred, align 4
  br label %if.end116

if.else89:                                        ; preds = %land.lhs.true80, %land.lhs.true, %if.else75
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %type90 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 0
  %83 = load i32, i32* %type90, align 8
  %cmp91 = icmp eq i32 %83, 1
  br i1 %cmp91, label %land.lhs.true93, label %if.else104

land.lhs.true93:                                  ; preds = %if.else89
  %84 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %84 to i1
  br i1 %tobool94, label %if.else104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %land.lhs.true93
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off96 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %85, i32 0, i32 5
  %86 = bitcast %struct.tnum* %var_off96 to { i64, i64 }*
  %87 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %86, i32 0, i32 0
  %88 = load i64, i64* %87, align 8
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %86, i32 0, i32 1
  %90 = load i64, i64* %89, align 8
  %call97 = call zeroext i1 @tnum_is_const(i64 %88, i64 %90) #20
  br i1 %call97, label %if.then99, label %if.else104

if.then99:                                        ; preds = %land.lhs.true95
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off100 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 5
  %value101 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off100, i32 0, i32 0
  %93 = load i64, i64* %value101, align 8
  %94 = load i8, i8* %opcode, align 1
  %95 = load i8, i8* %is_jmp32, align 1
  %tobool102 = trunc i8 %95 to i1
  %call103 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %91, i64 noundef %93, i8 noundef zeroext %94, i1 noundef zeroext %tobool102) #20
  store i32 %call103, i32* %pred, align 4
  br label %if.end115

if.else104:                                       ; preds = %land.lhs.true95, %land.lhs.true93, %if.else89
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call105 = call zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %96) #20
  br i1 %call105, label %land.lhs.true107, label %if.end114

land.lhs.true107:                                 ; preds = %if.else104
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call108 = call zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %97) #20
  br i1 %call108, label %land.lhs.true110, label %if.end114

land.lhs.true110:                                 ; preds = %land.lhs.true107
  %98 = load i8, i8* %is_jmp32, align 1
  %tobool111 = trunc i8 %98 to i1
  br i1 %tobool111, label %if.end114, label %if.then112

if.then112:                                       ; preds = %land.lhs.true110
  %99 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %100 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %101 = load i8, i8* %opcode, align 1
  %call113 = call i32 @is_pkt_ptr_branch_taken(%struct.bpf_reg_state* noundef %99, %struct.bpf_reg_state* noundef %100, i8 noundef zeroext %101) #20
  store i32 %call113, i32* %pred, align 4
  br label %if.end114

if.end114:                                        ; preds = %if.then112, %land.lhs.true110, %land.lhs.true107, %if.else104
  br label %if.end115

if.end115:                                        ; preds = %if.end114, %if.then99
  br label %if.end116

if.end116:                                        ; preds = %if.end115, %if.then84
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.then70
  %102 = load i32, i32* %pred, align 4
  %cmp118 = icmp sge i32 %102, 0
  br i1 %cmp118, label %if.then120, label %if.end148

if.then120:                                       ; preds = %if.end117
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call121 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %103) #20
  br i1 %call121, label %if.end128, label %if.then122

if.then122:                                       ; preds = %if.then120
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %105 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg123 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %105, i32 0, i32 1
  %bf.load124 = load i8, i8* %dst_reg123, align 1
  %bf.clear125 = and i8 %bf.load124, 15
  %conv126 = zext i8 %bf.clear125 to i32
  %call127 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %104, i32 noundef %conv126) #20
  store i32 %call127, i32* %err, align 4
  br label %if.end128

if.end128:                                        ; preds = %if.then122, %if.then120
  %106 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code129 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %106, i32 0, i32 0
  %107 = load i8, i8* %code129, align 4
  %conv130 = zext i8 %107 to i32
  %and131 = and i32 %conv130, 8
  %cmp132 = icmp eq i32 %and131, 8
  br i1 %cmp132, label %land.lhs.true134, label %if.end144

land.lhs.true134:                                 ; preds = %if.end128
  %108 = load i32, i32* %err, align 4
  %tobool135 = icmp ne i32 %108, 0
  br i1 %tobool135, label %if.end144, label %land.lhs.true136

land.lhs.true136:                                 ; preds = %land.lhs.true134
  %109 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call137 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %109) #20
  br i1 %call137, label %if.end144, label %if.then138

if.then138:                                       ; preds = %land.lhs.true136
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %111 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg139 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %111, i32 0, i32 1
  %bf.load140 = load i8, i8* %src_reg139, align 1
  %bf.lshr141 = lshr i8 %bf.load140, 4
  %conv142 = zext i8 %bf.lshr141 to i32
  %call143 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %110, i32 noundef %conv142) #20
  store i32 %call143, i32* %err, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.then138, %land.lhs.true136, %land.lhs.true134, %if.end128
  %112 = load i32, i32* %err, align 4
  %tobool145 = icmp ne i32 %112, 0
  br i1 %tobool145, label %if.then146, label %if.end147

if.then146:                                       ; preds = %if.end144
  %113 = load i32, i32* %err, align 4
  store i32 %113, i32* %retval, align 4
  br label %return

if.end147:                                        ; preds = %if.end144
  br label %if.end148

if.end148:                                        ; preds = %if.end147, %if.end117
  %114 = load i32, i32* %pred, align 4
  %cmp149 = icmp eq i32 %114, 1
  br i1 %cmp149, label %if.then151, label %if.else160

if.then151:                                       ; preds = %if.end148
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %115, i32 0, i32 21
  %116 = load i8, i8* %bypass_spec_v1, align 1
  %tobool152 = trunc i8 %116 to i1
  br i1 %tobool152, label %if.end157, label %land.lhs.true153

land.lhs.true153:                                 ; preds = %if.then151
  %117 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %118 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %119 = load i32*, i32** %insn_idx.addr, align 8
  %120 = load i32, i32* %119, align 4
  %add = add i32 %120, 1
  %121 = load i32*, i32** %insn_idx.addr, align 8
  %122 = load i32, i32* %121, align 4
  %call154 = call %struct.bpf_verifier_state* @sanitize_speculative_path(%struct.bpf_verifier_env* noundef %117, %struct.bpf_insn* noundef %118, i32 noundef %add, i32 noundef %122) #20
  %tobool155 = icmp ne %struct.bpf_verifier_state* %call154, null
  br i1 %tobool155, label %if.end157, label %if.then156

if.then156:                                       ; preds = %land.lhs.true153
  store i32 -14, i32* %retval, align 4
  br label %return

if.end157:                                        ; preds = %land.lhs.true153, %if.then151
  %123 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %123, i32 0, i32 2
  %124 = load i16, i16* %off, align 2
  %conv158 = sext i16 %124 to i32
  %125 = load i32*, i32** %insn_idx.addr, align 8
  %126 = load i32, i32* %125, align 4
  %add159 = add i32 %126, %conv158
  store i32 %add159, i32* %125, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.else160:                                       ; preds = %if.end148
  %127 = load i32, i32* %pred, align 4
  %cmp161 = icmp eq i32 %127, 0
  br i1 %cmp161, label %if.then163, label %if.end175

if.then163:                                       ; preds = %if.else160
  %128 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1164 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %128, i32 0, i32 21
  %129 = load i8, i8* %bypass_spec_v1164, align 1
  %tobool165 = trunc i8 %129 to i1
  br i1 %tobool165, label %if.end174, label %land.lhs.true166

land.lhs.true166:                                 ; preds = %if.then163
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %131 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %132 = load i32*, i32** %insn_idx.addr, align 8
  %133 = load i32, i32* %132, align 4
  %134 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off167 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %134, i32 0, i32 2
  %135 = load i16, i16* %off167, align 2
  %conv168 = sext i16 %135 to i32
  %add169 = add i32 %133, %conv168
  %add170 = add i32 %add169, 1
  %136 = load i32*, i32** %insn_idx.addr, align 8
  %137 = load i32, i32* %136, align 4
  %call171 = call %struct.bpf_verifier_state* @sanitize_speculative_path(%struct.bpf_verifier_env* noundef %130, %struct.bpf_insn* noundef %131, i32 noundef %add170, i32 noundef %137) #20
  %tobool172 = icmp ne %struct.bpf_verifier_state* %call171, null
  br i1 %tobool172, label %if.end174, label %if.then173

if.then173:                                       ; preds = %land.lhs.true166
  store i32 -14, i32* %retval, align 4
  br label %return

if.end174:                                        ; preds = %land.lhs.true166, %if.then163
  store i32 0, i32* %retval, align 4
  br label %return

if.end175:                                        ; preds = %if.else160
  br label %if.end176

if.end176:                                        ; preds = %if.end175
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %139 = load i32*, i32** %insn_idx.addr, align 8
  %140 = load i32, i32* %139, align 4
  %141 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off177 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %141, i32 0, i32 2
  %142 = load i16, i16* %off177, align 2
  %conv178 = sext i16 %142 to i32
  %add179 = add i32 %140, %conv178
  %add180 = add i32 %add179, 1
  %143 = load i32*, i32** %insn_idx.addr, align 8
  %144 = load i32, i32* %143, align 4
  %call181 = call %struct.bpf_verifier_state* @push_stack(%struct.bpf_verifier_env* noundef %138, i32 noundef %add180, i32 noundef %144, i1 noundef zeroext false) #20
  store %struct.bpf_verifier_state* %call181, %struct.bpf_verifier_state** %other_branch, align 8
  %145 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %tobool182 = icmp ne %struct.bpf_verifier_state* %145, null
  br i1 %tobool182, label %if.end184, label %if.then183

if.then183:                                       ; preds = %if.end176
  store i32 -14, i32* %retval, align 4
  br label %return

if.end184:                                        ; preds = %if.end176
  %146 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %frame185 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %146, i32 0, i32 0
  %147 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %curframe186 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %147, i32 0, i32 4
  %148 = load i32, i32* %curframe186, align 8
  %idxprom187 = zext i32 %148 to i64
  %arrayidx188 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame185, i64 0, i64 %idxprom187
  %149 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx188, align 8
  %regs189 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %149, i32 0, i32 0
  %arraydecay190 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs189, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay190, %struct.bpf_reg_state** %other_branch_regs, align 8
  %150 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code191 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %150, i32 0, i32 0
  %151 = load i8, i8* %code191, align 4
  %conv192 = zext i8 %151 to i32
  %and193 = and i32 %conv192, 8
  %cmp194 = icmp eq i32 %and193, 8
  br i1 %cmp194, label %if.then196, label %if.else330

if.then196:                                       ; preds = %if.end184
  %152 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %153 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg198 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %153, i32 0, i32 1
  %bf.load199 = load i8, i8* %src_reg198, align 1
  %bf.lshr200 = lshr i8 %bf.load199, 4
  %idxprom201 = zext i8 %bf.lshr200 to i64
  %arrayidx202 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %152, i64 %idxprom201
  store %struct.bpf_reg_state* %arrayidx202, %struct.bpf_reg_state** %src_reg197, align 8
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type203 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %154, i32 0, i32 0
  %155 = load i32, i32* %type203, align 8
  %cmp204 = icmp eq i32 %155, 1
  br i1 %cmp204, label %land.lhs.true206, label %if.end329

land.lhs.true206:                                 ; preds = %if.then196
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %type207 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i32 0, i32 0
  %157 = load i32, i32* %type207, align 8
  %cmp208 = icmp eq i32 %157, 1
  br i1 %cmp208, label %if.then210, label %if.end329

if.then210:                                       ; preds = %land.lhs.true206
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %var_off211 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %158, i32 0, i32 5
  %159 = bitcast %struct.tnum* %var_off211 to { i64, i64 }*
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 0
  %161 = load i64, i64* %160, align 8
  %162 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %159, i32 0, i32 1
  %163 = load i64, i64* %162, align 8
  %call212 = call zeroext i1 @tnum_is_const(i64 %161, i64 %163) #20
  br i1 %call212, label %if.then223, label %lor.lhs.false214

lor.lhs.false214:                                 ; preds = %if.then210
  %164 = load i8, i8* %is_jmp32, align 1
  %tobool215 = trunc i8 %164 to i1
  br i1 %tobool215, label %land.lhs.true217, label %if.else237

land.lhs.true217:                                 ; preds = %lor.lhs.false214
  %165 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %var_off219 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %165, i32 0, i32 5
  %166 = bitcast %struct.tnum* %var_off219 to { i64, i64 }*
  %167 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %166, i32 0, i32 0
  %168 = load i64, i64* %167, align 8
  %169 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %166, i32 0, i32 1
  %170 = load i64, i64* %169, align 8
  %call220 = call { i64, i64 } @tnum_subreg(i64 %168, i64 %170) #20
  %171 = bitcast %struct.tnum* %agg.tmp218 to { i64, i64 }*
  %172 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %171, i32 0, i32 0
  %173 = extractvalue { i64, i64 } %call220, 0
  store i64 %173, i64* %172, align 8
  %174 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %171, i32 0, i32 1
  %175 = extractvalue { i64, i64 } %call220, 1
  store i64 %175, i64* %174, align 8
  %176 = bitcast %struct.tnum* %agg.tmp218 to { i64, i64 }*
  %177 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %176, i32 0, i32 0
  %178 = load i64, i64* %177, align 8
  %179 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %176, i32 0, i32 1
  %180 = load i64, i64* %179, align 8
  %call221 = call zeroext i1 @tnum_is_const(i64 %178, i64 %180) #20
  br i1 %call221, label %if.then223, label %if.else237

if.then223:                                       ; preds = %land.lhs.true217, %if.then210
  %181 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %182 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg224 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %182, i32 0, i32 1
  %bf.load225 = load i8, i8* %dst_reg224, align 1
  %bf.clear226 = and i8 %bf.load225, 15
  %idxprom227 = zext i8 %bf.clear226 to i64
  %arrayidx228 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %181, i64 %idxprom227
  %183 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %184 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %var_off229 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %184, i32 0, i32 5
  %value230 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off229, i32 0, i32 0
  %185 = load i64, i64* %value230, align 8
  %186 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %var_off231 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %186, i32 0, i32 5
  %187 = bitcast %struct.tnum* %var_off231 to { i64, i64 }*
  %188 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %187, i32 0, i32 0
  %189 = load i64, i64* %188, align 8
  %190 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %187, i32 0, i32 1
  %191 = load i64, i64* %190, align 8
  %call232 = call { i64, i64 } @tnum_subreg(i64 %189, i64 %191) #20
  %192 = bitcast %struct.tnum* %coerce233 to { i64, i64 }*
  %193 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %192, i32 0, i32 0
  %194 = extractvalue { i64, i64 } %call232, 0
  store i64 %194, i64* %193, align 8
  %195 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %192, i32 0, i32 1
  %196 = extractvalue { i64, i64 } %call232, 1
  store i64 %196, i64* %195, align 8
  %value234 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce233, i32 0, i32 0
  %197 = load i64, i64* %value234, align 8
  %conv235 = trunc i64 %197 to i32
  %198 = load i8, i8* %opcode, align 1
  %199 = load i8, i8* %is_jmp32, align 1
  %tobool236 = trunc i8 %199 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %arrayidx228, %struct.bpf_reg_state* noundef %183, i64 noundef %185, i32 noundef %conv235, i8 noundef zeroext %198, i1 noundef zeroext %tobool236) #20
  br label %if.end287

if.else237:                                       ; preds = %land.lhs.true217, %lor.lhs.false214
  %200 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off238 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %200, i32 0, i32 5
  %201 = bitcast %struct.tnum* %var_off238 to { i64, i64 }*
  %202 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %201, i32 0, i32 0
  %203 = load i64, i64* %202, align 8
  %204 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %201, i32 0, i32 1
  %205 = load i64, i64* %204, align 8
  %call239 = call zeroext i1 @tnum_is_const(i64 %203, i64 %205) #20
  br i1 %call239, label %if.then250, label %lor.lhs.false241

lor.lhs.false241:                                 ; preds = %if.else237
  %206 = load i8, i8* %is_jmp32, align 1
  %tobool242 = trunc i8 %206 to i1
  br i1 %tobool242, label %land.lhs.true244, label %if.else264

land.lhs.true244:                                 ; preds = %lor.lhs.false241
  %207 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off246 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %207, i32 0, i32 5
  %208 = bitcast %struct.tnum* %var_off246 to { i64, i64 }*
  %209 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %208, i32 0, i32 0
  %210 = load i64, i64* %209, align 8
  %211 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %208, i32 0, i32 1
  %212 = load i64, i64* %211, align 8
  %call247 = call { i64, i64 } @tnum_subreg(i64 %210, i64 %212) #20
  %213 = bitcast %struct.tnum* %agg.tmp245 to { i64, i64 }*
  %214 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %213, i32 0, i32 0
  %215 = extractvalue { i64, i64 } %call247, 0
  store i64 %215, i64* %214, align 8
  %216 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %213, i32 0, i32 1
  %217 = extractvalue { i64, i64 } %call247, 1
  store i64 %217, i64* %216, align 8
  %218 = bitcast %struct.tnum* %agg.tmp245 to { i64, i64 }*
  %219 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %218, i32 0, i32 0
  %220 = load i64, i64* %219, align 8
  %221 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %218, i32 0, i32 1
  %222 = load i64, i64* %221, align 8
  %call248 = call zeroext i1 @tnum_is_const(i64 %220, i64 %222) #20
  br i1 %call248, label %if.then250, label %if.else264

if.then250:                                       ; preds = %land.lhs.true244, %if.else237
  %223 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %224 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg251 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %224, i32 0, i32 1
  %bf.load252 = load i8, i8* %src_reg251, align 1
  %bf.lshr253 = lshr i8 %bf.load252, 4
  %idxprom254 = zext i8 %bf.lshr253 to i64
  %arrayidx255 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %223, i64 %idxprom254
  %225 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %226 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off256 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %226, i32 0, i32 5
  %value257 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off256, i32 0, i32 0
  %227 = load i64, i64* %value257, align 8
  %228 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off258 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %228, i32 0, i32 5
  %229 = bitcast %struct.tnum* %var_off258 to { i64, i64 }*
  %230 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %229, i32 0, i32 0
  %231 = load i64, i64* %230, align 8
  %232 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %229, i32 0, i32 1
  %233 = load i64, i64* %232, align 8
  %call259 = call { i64, i64 } @tnum_subreg(i64 %231, i64 %233) #20
  %234 = bitcast %struct.tnum* %coerce260 to { i64, i64 }*
  %235 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %234, i32 0, i32 0
  %236 = extractvalue { i64, i64 } %call259, 0
  store i64 %236, i64* %235, align 8
  %237 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %234, i32 0, i32 1
  %238 = extractvalue { i64, i64 } %call259, 1
  store i64 %238, i64* %237, align 8
  %value261 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce260, i32 0, i32 0
  %239 = load i64, i64* %value261, align 8
  %conv262 = trunc i64 %239 to i32
  %240 = load i8, i8* %opcode, align 1
  %241 = load i8, i8* %is_jmp32, align 1
  %tobool263 = trunc i8 %241 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %arrayidx255, %struct.bpf_reg_state* noundef %225, i64 noundef %227, i32 noundef %conv262, i8 noundef zeroext %240, i1 noundef zeroext %tobool263) #20
  br label %if.end286

if.else264:                                       ; preds = %land.lhs.true244, %lor.lhs.false241
  %242 = load i8, i8* %is_jmp32, align 1
  %tobool265 = trunc i8 %242 to i1
  br i1 %tobool265, label %if.end285, label %land.lhs.true266

land.lhs.true266:                                 ; preds = %if.else264
  %243 = load i8, i8* %opcode, align 1
  %conv267 = zext i8 %243 to i32
  %cmp268 = icmp eq i32 %conv267, 16
  br i1 %cmp268, label %if.then274, label %lor.lhs.false270

lor.lhs.false270:                                 ; preds = %land.lhs.true266
  %244 = load i8, i8* %opcode, align 1
  %conv271 = zext i8 %244 to i32
  %cmp272 = icmp eq i32 %conv271, 80
  br i1 %cmp272, label %if.then274, label %if.end285

if.then274:                                       ; preds = %lor.lhs.false270, %land.lhs.true266
  %245 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %246 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg275 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %246, i32 0, i32 1
  %bf.load276 = load i8, i8* %src_reg275, align 1
  %bf.lshr277 = lshr i8 %bf.load276, 4
  %idxprom278 = zext i8 %bf.lshr277 to i64
  %arrayidx279 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %245, i64 %idxprom278
  %247 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %248 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg280 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %248, i32 0, i32 1
  %bf.load281 = load i8, i8* %dst_reg280, align 1
  %bf.clear282 = and i8 %bf.load281, 15
  %idxprom283 = zext i8 %bf.clear282 to i64
  %arrayidx284 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %247, i64 %idxprom283
  %249 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %250 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %251 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %arrayidx279, %struct.bpf_reg_state* noundef %arrayidx284, %struct.bpf_reg_state* noundef %249, %struct.bpf_reg_state* noundef %250, i8 noundef zeroext %251) #20
  br label %if.end285

if.end285:                                        ; preds = %if.then274, %lor.lhs.false270, %if.else264
  br label %if.end286

if.end286:                                        ; preds = %if.end285, %if.then250
  br label %if.end287

if.end287:                                        ; preds = %if.end286, %if.then223
  %252 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %252, i32 0, i32 3
  %253 = load i32, i32* %id, align 8
  %tobool288 = icmp ne i32 %253, 0
  br i1 %tobool288, label %land.lhs.true289, label %if.end328

land.lhs.true289:                                 ; preds = %if.end287
  %254 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  %id290 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %254, i32 0, i32 3
  %255 = load i32, i32* %id290, align 8
  %256 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %257 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg291 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %257, i32 0, i32 1
  %bf.load292 = load i8, i8* %src_reg291, align 1
  %bf.lshr293 = lshr i8 %bf.load292, 4
  %idxprom294 = zext i8 %bf.lshr293 to i64
  %arrayidx295 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %256, i64 %idxprom294
  %id296 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx295, i32 0, i32 3
  %258 = load i32, i32* %id296, align 8
  %cmp297 = icmp ne i32 %255, %258
  %lnot = xor i1 %cmp297, true
  %lnot299 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot299 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %259 = load i32, i32* %__ret_warn_on, align 4
  %tobool300 = icmp ne i32 %259, 0
  %lnot301 = xor i1 %tobool300, true
  %lnot303 = xor i1 %lnot301, true
  %lnot.ext304 = zext i1 %lnot303 to i32
  %conv305 = sext i32 %lnot.ext304 to i64
  %tobool306 = icmp ne i64 %conv305, 0
  br i1 %tobool306, label %if.then307, label %if.end314

if.then307:                                       ; preds = %land.lhs.true289
  br label %do.body

do.body:                                          ; preds = %if.then307
  store i32 2307, i32* %__flags, align 4
  br label %do.body308

do.body308:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body308
  br label %do.body309

do.body309:                                       ; preds = %do.end
  %260 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 10585, i32 %260, i64 12) #19, !srcloc !117
  br label %do.end310

do.end310:                                        ; preds = %do.body309
  br label %do.body311

do.body311:                                       ; preds = %do.end310
  br label %do.end312

do.end312:                                        ; preds = %do.body311
  br label %do.end313

do.end313:                                        ; preds = %do.end312
  br label %if.end314

if.end314:                                        ; preds = %do.end313, %land.lhs.true289
  %261 = load i32, i32* %__ret_warn_on, align 4
  %tobool315 = icmp ne i32 %261, 0
  %lnot316 = xor i1 %tobool315, true
  %lnot318 = xor i1 %lnot316, true
  %lnot.ext319 = zext i1 %lnot318 to i32
  %conv320 = sext i32 %lnot.ext319 to i64
  store i64 %conv320, i64* %tmp, align 8
  %262 = load i64, i64* %tmp, align 8
  %tobool321 = icmp ne i64 %262, 0
  br i1 %tobool321, label %if.end328, label %if.then322

if.then322:                                       ; preds = %if.end314
  %263 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %264 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg197, align 8
  call void @find_equal_scalars(%struct.bpf_verifier_state* noundef %263, %struct.bpf_reg_state* noundef %264) #20
  %265 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %266 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %267 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg323 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %267, i32 0, i32 1
  %bf.load324 = load i8, i8* %src_reg323, align 1
  %bf.lshr325 = lshr i8 %bf.load324, 4
  %idxprom326 = zext i8 %bf.lshr325 to i64
  %arrayidx327 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %266, i64 %idxprom326
  call void @find_equal_scalars(%struct.bpf_verifier_state* noundef %265, %struct.bpf_reg_state* noundef %arrayidx327) #20
  br label %if.end328

if.end328:                                        ; preds = %if.then322, %if.end314, %if.end287
  br label %if.end329

if.end329:                                        ; preds = %if.end328, %land.lhs.true206, %if.then196
  br label %if.end345

if.else330:                                       ; preds = %if.end184
  %268 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type331 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %268, i32 0, i32 0
  %269 = load i32, i32* %type331, align 8
  %cmp332 = icmp eq i32 %269, 1
  br i1 %cmp332, label %if.then334, label %if.end344

if.then334:                                       ; preds = %if.else330
  %270 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %271 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg335 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %271, i32 0, i32 1
  %bf.load336 = load i8, i8* %dst_reg335, align 1
  %bf.clear337 = and i8 %bf.load336, 15
  %idxprom338 = zext i8 %bf.clear337 to i64
  %arrayidx339 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %270, i64 %idxprom338
  %272 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %273 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm340 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %273, i32 0, i32 3
  %274 = load i32, i32* %imm340, align 4
  %conv341 = sext i32 %274 to i64
  %275 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm342 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %275, i32 0, i32 3
  %276 = load i32, i32* %imm342, align 4
  %277 = load i8, i8* %opcode, align 1
  %278 = load i8, i8* %is_jmp32, align 1
  %tobool343 = trunc i8 %278 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %arrayidx339, %struct.bpf_reg_state* noundef %272, i64 noundef %conv341, i32 noundef %276, i8 noundef zeroext %277, i1 noundef zeroext %tobool343) #20
  br label %if.end344

if.end344:                                        ; preds = %if.then334, %if.else330
  br label %if.end345

if.end345:                                        ; preds = %if.end344, %if.end329
  %279 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type346 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %279, i32 0, i32 0
  %280 = load i32, i32* %type346, align 8
  %cmp347 = icmp eq i32 %280, 1
  br i1 %cmp347, label %land.lhs.true349, label %if.end399

land.lhs.true349:                                 ; preds = %if.end345
  %281 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id350 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %281, i32 0, i32 3
  %282 = load i32, i32* %id350, align 8
  %tobool351 = icmp ne i32 %282, 0
  br i1 %tobool351, label %land.lhs.true352, label %if.end399

land.lhs.true352:                                 ; preds = %land.lhs.true349
  %283 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id354 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %283, i32 0, i32 3
  %284 = load i32, i32* %id354, align 8
  %285 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %286 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg355 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %286, i32 0, i32 1
  %bf.load356 = load i8, i8* %dst_reg355, align 1
  %bf.clear357 = and i8 %bf.load356, 15
  %idxprom358 = zext i8 %bf.clear357 to i64
  %arrayidx359 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %285, i64 %idxprom358
  %id360 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx359, i32 0, i32 3
  %287 = load i32, i32* %id360, align 8
  %cmp361 = icmp ne i32 %284, %287
  %lnot363 = xor i1 %cmp361, true
  %lnot365 = xor i1 %lnot363, true
  %lnot.ext366 = zext i1 %lnot365 to i32
  store i32 %lnot.ext366, i32* %__ret_warn_on353, align 4
  %288 = load i32, i32* %__ret_warn_on353, align 4
  %tobool367 = icmp ne i32 %288, 0
  %lnot368 = xor i1 %tobool367, true
  %lnot370 = xor i1 %lnot368, true
  %lnot.ext371 = zext i1 %lnot370 to i32
  %conv372 = sext i32 %lnot.ext371 to i64
  %tobool373 = icmp ne i64 %conv372, 0
  br i1 %tobool373, label %if.then374, label %if.end384

if.then374:                                       ; preds = %land.lhs.true352
  br label %do.body375

do.body375:                                       ; preds = %if.then374
  store i32 2307, i32* %__flags376, align 4
  br label %do.body377

do.body377:                                       ; preds = %do.body375
  br label %do.end378

do.end378:                                        ; preds = %do.body377
  br label %do.body379

do.body379:                                       ; preds = %do.end378
  %289 = load i32, i32* %__flags376, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 10598, i32 %289, i64 12) #19, !srcloc !118
  br label %do.end380

do.end380:                                        ; preds = %do.body379
  br label %do.body381

do.body381:                                       ; preds = %do.end380
  br label %do.end382

do.end382:                                        ; preds = %do.body381
  br label %do.end383

do.end383:                                        ; preds = %do.end382
  br label %if.end384

if.end384:                                        ; preds = %do.end383, %land.lhs.true352
  %290 = load i32, i32* %__ret_warn_on353, align 4
  %tobool386 = icmp ne i32 %290, 0
  %lnot387 = xor i1 %tobool386, true
  %lnot389 = xor i1 %lnot387, true
  %lnot.ext390 = zext i1 %lnot389 to i32
  %conv391 = sext i32 %lnot.ext390 to i64
  store i64 %conv391, i64* %tmp385, align 8
  %291 = load i64, i64* %tmp385, align 8
  %tobool392 = icmp ne i64 %291, 0
  br i1 %tobool392, label %if.end399, label %if.then393

if.then393:                                       ; preds = %if.end384
  %292 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %293 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @find_equal_scalars(%struct.bpf_verifier_state* noundef %292, %struct.bpf_reg_state* noundef %293) #20
  %294 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %295 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %296 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg394 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %296, i32 0, i32 1
  %bf.load395 = load i8, i8* %dst_reg394, align 1
  %bf.clear396 = and i8 %bf.load395, 15
  %idxprom397 = zext i8 %bf.clear396 to i64
  %arrayidx398 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %295, i64 %idxprom397
  call void @find_equal_scalars(%struct.bpf_verifier_state* noundef %294, %struct.bpf_reg_state* noundef %arrayidx398) #20
  br label %if.end399

if.end399:                                        ; preds = %if.then393, %if.end384, %land.lhs.true349, %if.end345
  %297 = load i8, i8* %is_jmp32, align 1
  %tobool400 = trunc i8 %297 to i1
  br i1 %tobool400, label %if.else438, label %land.lhs.true401

land.lhs.true401:                                 ; preds = %if.end399
  %298 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code402 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %298, i32 0, i32 0
  %299 = load i8, i8* %code402, align 4
  %conv403 = zext i8 %299 to i32
  %and404 = and i32 %conv403, 8
  %cmp405 = icmp eq i32 %and404, 0
  br i1 %cmp405, label %land.lhs.true407, label %if.else438

land.lhs.true407:                                 ; preds = %land.lhs.true401
  %300 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm408 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %300, i32 0, i32 3
  %301 = load i32, i32* %imm408, align 4
  %cmp409 = icmp eq i32 %301, 0
  br i1 %cmp409, label %land.lhs.true411, label %if.else438

land.lhs.true411:                                 ; preds = %land.lhs.true407
  %302 = load i8, i8* %opcode, align 1
  %conv412 = zext i8 %302 to i32
  %cmp413 = icmp eq i32 %conv412, 16
  br i1 %cmp413, label %land.lhs.true419, label %lor.lhs.false415

lor.lhs.false415:                                 ; preds = %land.lhs.true411
  %303 = load i8, i8* %opcode, align 1
  %conv416 = zext i8 %303 to i32
  %cmp417 = icmp eq i32 %conv416, 80
  br i1 %cmp417, label %land.lhs.true419, label %if.else438

land.lhs.true419:                                 ; preds = %lor.lhs.false415, %land.lhs.true411
  %304 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type420 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %304, i32 0, i32 0
  %305 = load i32, i32* %type420, align 8
  %call421 = call zeroext i1 @type_may_be_null(i32 noundef %305) #20
  br i1 %call421, label %if.then423, label %if.else438

if.then423:                                       ; preds = %land.lhs.true419
  %306 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %307 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg424 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %307, i32 0, i32 1
  %bf.load425 = load i8, i8* %dst_reg424, align 1
  %bf.clear426 = and i8 %bf.load425, 15
  %conv427 = zext i8 %bf.clear426 to i32
  %308 = load i8, i8* %opcode, align 1
  %conv428 = zext i8 %308 to i32
  %cmp429 = icmp eq i32 %conv428, 80
  call void @mark_ptr_or_null_regs(%struct.bpf_verifier_state* noundef %306, i32 noundef %conv427, i1 noundef zeroext %cmp429) #20
  %309 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %310 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg431 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %310, i32 0, i32 1
  %bf.load432 = load i8, i8* %dst_reg431, align 1
  %bf.clear433 = and i8 %bf.load432, 15
  %conv434 = zext i8 %bf.clear433 to i32
  %311 = load i8, i8* %opcode, align 1
  %conv435 = zext i8 %311 to i32
  %cmp436 = icmp eq i32 %conv435, 16
  call void @mark_ptr_or_null_regs(%struct.bpf_verifier_state* noundef %309, i32 noundef %conv434, i1 noundef zeroext %cmp436) #20
  br label %if.end458

if.else438:                                       ; preds = %land.lhs.true419, %lor.lhs.false415, %land.lhs.true407, %land.lhs.true401, %if.end399
  %312 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %313 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %314 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %315 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg439 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %315, i32 0, i32 1
  %bf.load440 = load i8, i8* %src_reg439, align 1
  %bf.lshr441 = lshr i8 %bf.load440, 4
  %idxprom442 = zext i8 %bf.lshr441 to i64
  %arrayidx443 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %314, i64 %idxprom442
  %316 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %317 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %call444 = call zeroext i1 @try_match_pkt_pointers(%struct.bpf_insn* noundef %312, %struct.bpf_reg_state* noundef %313, %struct.bpf_reg_state* noundef %arrayidx443, %struct.bpf_verifier_state* noundef %316, %struct.bpf_verifier_state* noundef %317) #20
  br i1 %call444, label %if.end457, label %land.lhs.true445

land.lhs.true445:                                 ; preds = %if.else438
  %318 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %319 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg446 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %319, i32 0, i32 1
  %bf.load447 = load i8, i8* %dst_reg446, align 1
  %bf.clear448 = and i8 %bf.load447, 15
  %conv449 = zext i8 %bf.clear448 to i32
  %call450 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %318, i32 noundef %conv449) #20
  br i1 %call450, label %if.then452, label %if.end457

if.then452:                                       ; preds = %land.lhs.true445
  %320 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %321 = bitcast %struct.bpf_verifier_env* %320 to i8*
  %322 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg453 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %322, i32 0, i32 1
  %bf.load454 = load i8, i8* %dst_reg453, align 1
  %bf.clear455 = and i8 %bf.load454, 15
  %conv456 = zext i8 %bf.clear455 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %321, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.483, i64 0, i64 0), i32 noundef %conv456) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end457:                                        ; preds = %land.lhs.true445, %if.else438
  br label %if.end458

if.end458:                                        ; preds = %if.end457, %if.then423
  %323 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %323, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %324 = load i32, i32* %level, align 8
  %and459 = and i32 %324, 3
  %tobool460 = icmp ne i32 %and459, 0
  br i1 %tobool460, label %if.then461, label %if.end466

if.then461:                                       ; preds = %if.end458
  %325 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %326 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %frame462 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %326, i32 0, i32 0
  %327 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %curframe463 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %327, i32 0, i32 4
  %328 = load i32, i32* %curframe463, align 8
  %idxprom464 = zext i32 %328 to i64
  %arrayidx465 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame462, i64 0, i64 %idxprom464
  %329 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx465, align 8
  call void @print_insn_state(%struct.bpf_verifier_env* noundef %325, %struct.bpf_func_state* noundef %329) #20
  br label %if.end466

if.end466:                                        ; preds = %if.then461, %if.end458
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end466, %if.then452, %if.then183, %if.end174, %if.then173, %if.end157, %if.then156, %if.then146, %if.then53, %if.then45, %if.then28, %if.then21, %if.then17, %if.then
  %330 = load i32, i32* %retval, align 4
  ret i32 %330
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ld_abs(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %mode = alloca i8, align 1
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 0
  %2 = load i8, i8* %code, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 224
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %mode, align 1
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call2 = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %4) #20
  %call3 = call zeroext i1 @may_access_skb(i32 noundef %call2) #20
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = bitcast %struct.bpf_verifier_env* %5 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %6, i8* noundef getelementptr inbounds ([65 x i8], [65 x i8]* @.str.484, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 3
  %8 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_ld_abs = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %8, i32 0, i32 3
  %9 = load i32 (%struct.bpf_insn*, %struct.bpf_insn*)*, i32 (%struct.bpf_insn*, %struct.bpf_insn*)** %gen_ld_abs, align 8
  %tobool = icmp ne i32 (%struct.bpf_insn*, %struct.bpf_insn*)* %9, null
  br i1 %tobool, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.485, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %12, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv6 = zext i8 %bf.clear to i32
  %cmp = icmp ne i32 %conv6, 0
  br i1 %cmp, label %if.then25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 2
  %14 = load i16, i16* %off, align 2
  %conv8 = sext i16 %14 to i32
  %cmp9 = icmp ne i32 %conv8, 0
  br i1 %cmp9, label %if.then25, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code12 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 0
  %16 = load i8, i8* %code12, align 4
  %conv13 = zext i8 %16 to i32
  %and14 = and i32 %conv13, 24
  %cmp15 = icmp eq i32 %and14, 24
  br i1 %cmp15, label %if.then25, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %lor.lhs.false11
  %17 = load i8, i8* %mode, align 1
  %conv18 = zext i8 %17 to i32
  %cmp19 = icmp eq i32 %conv18, 32
  br i1 %cmp19, label %land.lhs.true, label %if.end26

land.lhs.true:                                    ; preds = %lor.lhs.false17
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 1
  %bf.load21 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load21, 4
  %conv22 = zext i8 %bf.lshr to i32
  %cmp23 = icmp ne i32 %conv22, 0
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %land.lhs.true, %lor.lhs.false11, %lor.lhs.false, %if.end5
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.486, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %land.lhs.true, %lor.lhs.false17
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call27 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %21, i32 noundef 6, i32 noundef 0) #20
  store i32 %call27, i32* %err, align 4
  %22 = load i32, i32* %err, align 4
  %tobool28 = icmp ne i32 %22, 0
  br i1 %tobool28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.end26
  %23 = load i32, i32* %err, align 4
  store i32 %23, i32* %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.end26
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call31 = call i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %24) #20
  store i32 %call31, i32* %err, align 4
  %25 = load i32, i32* %err, align 4
  %tobool32 = icmp ne i32 %25, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end30
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([57 x i8], [57 x i8]* @.str.487, i64 0, i64 0)) #20
  %28 = load i32, i32* %err, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

if.end34:                                         ; preds = %if.end30
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 8
  %30 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %30, i32 0, i32 5
  %31 = load i32, i32* %active_spin_lock, align 4
  %tobool35 = icmp ne i32 %31, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end34
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = bitcast %struct.bpf_verifier_env* %32 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %33, i8* noundef getelementptr inbounds ([64 x i8], [64 x i8]* @.str.488, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end34
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i64 6
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  %35 = load i32, i32* %type, align 8
  %cmp38 = icmp ne i32 %35, 2
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end37
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.489, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end37
  %38 = load i8, i8* %mode, align 1
  %conv42 = zext i8 %38 to i32
  %cmp43 = icmp eq i32 %conv42, 64
  br i1 %cmp43, label %if.then45, label %if.end54

if.then45:                                        ; preds = %if.end41
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg46 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %40, i32 0, i32 1
  %bf.load47 = load i8, i8* %src_reg46, align 1
  %bf.lshr48 = lshr i8 %bf.load47, 4
  %conv49 = zext i8 %bf.lshr48 to i32
  %call50 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %39, i32 noundef %conv49, i32 noundef 0) #20
  store i32 %call50, i32* %err, align 4
  %41 = load i32, i32* %err, align 4
  %tobool51 = icmp ne i32 %41, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.then45
  %42 = load i32, i32* %err, align 4
  store i32 %42, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.then45
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.end41
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx55 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i64 6
  %call56 = call i32 @check_ptr_off_reg(%struct.bpf_verifier_env* noundef %43, %struct.bpf_reg_state* noundef %arrayidx55, i32 noundef 6) #20
  store i32 %call56, i32* %err, align 4
  %45 = load i32, i32* %err, align 4
  %cmp57 = icmp slt i32 %45, 0
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end54
  %46 = load i32, i32* %err, align 4
  store i32 %46, i32* %retval, align 4
  br label %return

if.end60:                                         ; preds = %if.end54
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end60
  %47 = load i32, i32* %i, align 4
  %cmp61 = icmp slt i32 %47, 6
  br i1 %cmp61, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %50 = load i32, i32* %i, align 4
  %idxprom = sext i32 %50 to i64
  %arrayidx63 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom
  %51 = load i32, i32* %arrayidx63, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %48, %struct.bpf_reg_state* noundef %49, i32 noundef %51) #20
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load i32, i32* %i, align 4
  %idxprom64 = sext i32 %53 to i64
  %arrayidx65 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom64
  %54 = load i32, i32* %arrayidx65, align 4
  %call66 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %52, i32 noundef %54, i32 noundef 2) #20
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %55 = load i32, i32* %i, align 4
  %inc = add i32 %55, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !119

for.end:                                          ; preds = %for.cond
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %56, %struct.bpf_reg_state* noundef %57, i32 noundef 0) #20
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %58, i32 0, i32 0
  %59 = load i32, i32* %insn_idx, align 8
  %add = add i32 %59, 1
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx67 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i64 0
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx67, i32 0, i32 16
  store i32 %add, i32* %subreg_def, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then59, %if.then52, %if.then40, %if.then36, %if.then33, %if.then29, %if.then25, %if.then4, %if.then
  %61 = load i32, i32* %retval, align 4
  ret i32 %61
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ld_imm(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %err = alloca i32, align 4
  %imm = alloca i64, align 8
  %aux60 = alloca %struct.bpf_prog_aux*, align 8
  %subprogno = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_insn_aux_data* %call, %struct.bpf_insn_aux_data** %aux, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call1 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %1) #20
  store %struct.bpf_reg_state* %call1, %struct.bpf_reg_state** %regs, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code, align 4
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 24
  %cmp = icmp ne i32 %and, 24
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.490, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 2
  %7 = load i16, i16* %off, align 2
  %conv3 = sext i16 %7 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.491, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg8 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg8, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv9 = zext i8 %bf.clear to i32
  %call10 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %10, i32 noundef %conv9, i32 noundef 1) #20
  store i32 %call10, i32* %err, align 4
  %12 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end7
  %13 = load i32, i32* %err, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end7
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 1
  %bf.load14 = load i8, i8* %dst_reg13, align 1
  %bf.clear15 = and i8 %bf.load14, 15
  %idxprom = zext i8 %bf.clear15 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %dst_reg, align 8
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 1
  %bf.load16 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load16, 4
  %conv17 = zext i8 %bf.lshr to i32
  %cmp18 = icmp eq i32 %conv17, 0
  br i1 %cmp18, label %if.then20, label %if.end30

if.then20:                                        ; preds = %if.end12
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %17, i64 1
  %imm21 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %add.ptr, i32 0, i32 3
  %18 = load i32, i32* %imm21, align 4
  %conv22 = sext i32 %18 to i64
  %shl = shl i64 %conv22, 32
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %19, i32 0, i32 3
  %20 = load i32, i32* %imm23, align 4
  %conv24 = zext i32 %20 to i64
  %or = or i64 %shl, %conv24
  store i64 %or, i64* %imm, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg25 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %23, i32 0, i32 1
  %bf.load26 = load i8, i8* %dst_reg25, align 1
  %bf.clear27 = and i8 %bf.load26, 15
  %idxprom28 = zext i8 %bf.clear27 to i64
  %arrayidx29 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i64 %idxprom28
  %24 = load i64, i64* %imm, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %arrayidx29, i64 noundef %24) #20
  store i32 0, i32* %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.end12
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg31 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %27, i32 0, i32 1
  %bf.load32 = load i8, i8* %dst_reg31, align 1
  %bf.clear33 = and i8 %bf.load32, 15
  %conv34 = zext i8 %bf.clear33 to i32
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %25, %struct.bpf_reg_state* noundef %26, i32 noundef %conv34) #20
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %28, i32 0, i32 1
  %bf.load36 = load i8, i8* %src_reg35, align 1
  %bf.lshr37 = lshr i8 %bf.load36, 4
  %conv38 = zext i8 %bf.lshr37 to i32
  %cmp39 = icmp eq i32 %conv38, 3
  br i1 %cmp39, label %if.then41, label %if.end52

if.then41:                                        ; preds = %if.end30
  %29 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %30 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %29, i32 0, i32 0
  %btf_var = bitcast %union.anon.210* %30 to %struct.anon.212*
  %reg_type = getelementptr inbounds %struct.anon.212, %struct.anon.212* %btf_var, i32 0, i32 0
  %31 = load i32, i32* %reg_type, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 0
  store i32 %31, i32* %type42, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 0
  %34 = load i32, i32* %type43, align 8
  %call44 = call i32 @base_type(i32 noundef %34) #20
  switch i32 %call44, label %sw.default [
    i32 17, label %sw.bb
    i32 16, label %sw.bb47
  ]

sw.bb:                                            ; preds = %if.then41
  %35 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %36 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %35, i32 0, i32 0
  %btf_var45 = bitcast %union.anon.210* %36 to %struct.anon.212*
  %37 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %btf_var45, i32 0, i32 1
  %mem_size = bitcast %union.anon.213* %37 to i32*
  %38 = load i32, i32* %mem_size, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %40 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 2
  %mem_size46 = bitcast %union.anon.168* %40 to i32*
  store i32 %38, i32* %mem_size46, align 8
  br label %sw.epilog

sw.bb47:                                          ; preds = %if.then41
  %41 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %42 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %41, i32 0, i32 0
  %btf_var48 = bitcast %union.anon.210* %42 to %struct.anon.212*
  %43 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %btf_var48, i32 0, i32 1
  %44 = bitcast %union.anon.213* %43 to %struct.anon.214*
  %btf = getelementptr inbounds %struct.anon.214, %struct.anon.214* %44, i32 0, i32 0
  %45 = load %struct.btf*, %struct.btf** %btf, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %47 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 2
  %48 = bitcast %union.anon.168* %47 to %struct.anon.170*
  %btf49 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %48, i32 0, i32 0
  store %struct.btf* %45, %struct.btf** %btf49, align 8
  %49 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %50 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %49, i32 0, i32 0
  %btf_var50 = bitcast %union.anon.210* %50 to %struct.anon.212*
  %51 = getelementptr inbounds %struct.anon.212, %struct.anon.212* %btf_var50, i32 0, i32 1
  %52 = bitcast %union.anon.213* %51 to %struct.anon.214*
  %btf_id = getelementptr inbounds %struct.anon.214, %struct.anon.214* %52, i32 0, i32 1
  %53 = load i32, i32* %btf_id, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %55 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 2
  %56 = bitcast %union.anon.168* %55 to %struct.anon.170*
  %btf_id51 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %56, i32 0, i32 1
  store i32 %53, i32* %btf_id51, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.then41
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = bitcast %struct.bpf_verifier_env* %57 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %58, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.485, i64 0, i64 0)) #20
  store i32 -14, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb47, %sw.bb
  store i32 0, i32* %retval, align 4
  br label %return

if.end52:                                         ; preds = %if.end30
  %59 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg53 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %59, i32 0, i32 1
  %bf.load54 = load i8, i8* %src_reg53, align 1
  %bf.lshr55 = lshr i8 %bf.load54, 4
  %conv56 = zext i8 %bf.lshr55 to i32
  %cmp57 = icmp eq i32 %conv56, 4
  br i1 %cmp57, label %if.then59, label %if.end77

if.then59:                                        ; preds = %if.end52
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %60, i32 0, i32 2
  %61 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux61 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %61, i32 0, i32 10
  %62 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux61, align 8
  store %struct.bpf_prog_aux* %62, %struct.bpf_prog_aux** %aux60, align 8
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %64, i32 0, i32 0
  %65 = load i32, i32* %insn_idx, align 8
  %66 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm62 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %66, i32 0, i32 3
  %67 = load i32, i32* %imm62, align 4
  %add = add i32 %65, %67
  %add63 = add i32 %add, 1
  %call64 = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %63, i32 noundef %add63) #20
  store i32 %call64, i32* %subprogno, align 4
  %68 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux60, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %68, i32 0, i32 51
  %69 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info, align 8
  %tobool65 = icmp ne %struct.bpf_func_info* %69, null
  br i1 %tobool65, label %if.end67, label %if.then66

if.then66:                                        ; preds = %if.then59
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = bitcast %struct.bpf_verifier_env* %70 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %71, i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str.492, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.then59
  %72 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux60, align 8
  %func_info_aux = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %72, i32 0, i32 52
  %73 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %74 = load i32, i32* %subprogno, align 4
  %idxprom68 = zext i32 %74 to i64
  %arrayidx69 = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %73, i64 %idxprom68
  %linkage = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx69, i32 0, i32 0
  %75 = load i16, i16* %linkage, align 2
  %conv70 = zext i16 %75 to i32
  %cmp71 = icmp ne i32 %conv70, 0
  br i1 %cmp71, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.end67
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %77 = bitcast %struct.bpf_verifier_env* %76 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %77, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.493, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %if.end67
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %78, i32 0, i32 0
  store i32 19, i32* %type75, align 8
  %79 = load i32, i32* %subprogno, align 4
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 2
  %subprogno76 = bitcast %union.anon.168* %81 to i32*
  store i32 %79, i32* %subprogno76, align 8
  store i32 0, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %if.end52
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %82, i32 0, i32 11
  %83 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %84 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %83, i32 0, i32 0
  %85 = bitcast %union.anon.210* %84 to %struct.anon.211*
  %map_index = getelementptr inbounds %struct.anon.211, %struct.anon.211* %85, i32 0, i32 0
  %86 = load i32, i32* %map_index, align 8
  %idxprom78 = zext i32 %86 to i64
  %arrayidx79 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps, i64 0, i64 %idxprom78
  %87 = load %struct.bpf_map*, %struct.bpf_map** %arrayidx79, align 8
  store %struct.bpf_map* %87, %struct.bpf_map** %map, align 8
  %88 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %89 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %90 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %89, i32 0, i32 2
  %91 = bitcast %union.anon.168* %90 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %91, i32 0, i32 0
  store %struct.bpf_map* %88, %struct.bpf_map** %map_ptr, align 8
  %92 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg80 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %92, i32 0, i32 1
  %bf.load81 = load i8, i8* %src_reg80, align 1
  %bf.lshr82 = lshr i8 %bf.load81, 4
  %conv83 = zext i8 %bf.lshr82 to i32
  %cmp84 = icmp eq i32 %conv83, 2
  br i1 %cmp84, label %if.then92, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end77
  %93 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg86 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %93, i32 0, i32 1
  %bf.load87 = load i8, i8* %src_reg86, align 1
  %bf.lshr88 = lshr i8 %bf.load87, 4
  %conv89 = zext i8 %bf.lshr88 to i32
  %cmp90 = icmp eq i32 %conv89, 6
  br i1 %cmp90, label %if.then92, label %if.else

if.then92:                                        ; preds = %lor.lhs.false, %if.end77
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type93 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %94, i32 0, i32 0
  store i32 4, i32* %type93, align 8
  %95 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %96 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %95, i32 0, i32 0
  %97 = bitcast %union.anon.210* %96 to %struct.anon.211*
  %map_off = getelementptr inbounds %struct.anon.211, %struct.anon.211* %97, i32 0, i32 1
  %98 = load i32, i32* %map_off, align 4
  %99 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off94 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %99, i32 0, i32 1
  store i32 %98, i32* %off94, align 4
  %100 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call95 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %100) #20
  br i1 %call95, label %if.then96, label %if.end97

if.then96:                                        ; preds = %if.then92
  %101 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %101, i32 0, i32 15
  %102 = load i32, i32* %id_gen, align 8
  %inc = add i32 %102, 1
  store i32 %inc, i32* %id_gen, align 8
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %103, i32 0, i32 3
  store i32 %inc, i32* %id, align 8
  br label %if.end97

if.end97:                                         ; preds = %if.then96, %if.then92
  br label %if.end115

if.else:                                          ; preds = %lor.lhs.false
  %104 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg98 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %104, i32 0, i32 1
  %bf.load99 = load i8, i8* %src_reg98, align 1
  %bf.lshr100 = lshr i8 %bf.load99, 4
  %conv101 = zext i8 %bf.lshr100 to i32
  %cmp102 = icmp eq i32 %conv101, 1
  br i1 %cmp102, label %if.then111, label %lor.lhs.false104

lor.lhs.false104:                                 ; preds = %if.else
  %105 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg105 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %105, i32 0, i32 1
  %bf.load106 = load i8, i8* %src_reg105, align 1
  %bf.lshr107 = lshr i8 %bf.load106, 4
  %conv108 = zext i8 %bf.lshr107 to i32
  %cmp109 = icmp eq i32 %conv108, 5
  br i1 %cmp109, label %if.then111, label %if.else113

if.then111:                                       ; preds = %lor.lhs.false104, %if.else
  %106 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type112 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %106, i32 0, i32 0
  store i32 3, i32* %type112, align 8
  br label %if.end114

if.else113:                                       ; preds = %lor.lhs.false104
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %108 = bitcast %struct.bpf_verifier_env* %107 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %108, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.485, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end114:                                        ; preds = %if.then111
  br label %if.end115

if.end115:                                        ; preds = %if.end114, %if.end97
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end115, %if.else113, %if.end74, %if.then73, %if.then66, %sw.epilog, %sw.default, %if.then20, %if.then11, %if.then6, %if.then
  %109 = load i32, i32* %retval, align 4
  ret i32 %109
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %idx.addr = alloca i32, align 4
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 9
  %7 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states, align 8
  %8 = load i32, i32* %idx.addr, align 4
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 1
  %10 = load i32, i32* %callsite, align 8
  %xor = xor i32 %8, %10
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @state_htab_size(%struct.bpf_verifier_env* noundef %11) #20
  %rem = urem i32 %xor, %call
  %idxprom1 = zext i32 %rem to i64
  %arrayidx2 = getelementptr %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %7, i64 %idxprom1
  ret %struct.bpf_verifier_state_list** %arrayidx2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clean_live_states(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca i32, align 4
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %sl = alloca %struct.bpf_verifier_state_list*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn, i32* %insn.addr, align 4
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %insn.addr, align 4
  %call = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #20
  %2 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %call, align 8
  store %struct.bpf_verifier_state_list* %2, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.cond:                                       ; preds = %next, %entry
  %3 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool = icmp ne %struct.bpf_verifier_state_list* %3, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %4, i32 0, i32 0
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state, i32 0, i32 2
  %5 = load i32, i32* %branches, align 8
  %tobool1 = icmp ne i32 %5, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %next

if.end:                                           ; preds = %while.body
  %6 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state2 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %6, i32 0, i32 0
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state2, i32 0, i32 3
  %7 = load i32, i32* %insn_idx, align 4
  %8 = load i32, i32* %insn.addr, align 4
  %cmp = icmp ne i32 %7, %8
  br i1 %cmp, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %9 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state3 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %9, i32 0, i32 0
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state3, i32 0, i32 4
  %10 = load i32, i32* %curframe, align 8
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 4
  %12 = load i32, i32* %curframe4, align 8
  %cmp5 = icmp ne i32 %10, %12
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %lor.lhs.false, %if.end
  br label %next

if.end7:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %13 = load i32, i32* %i, align 4
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 4
  %15 = load i32, i32* %curframe8, align 8
  %cmp9 = icmp ule i32 %13, %15
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state10 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %16, i32 0, i32 0
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state10, i32 0, i32 0
  %17 = load i32, i32* %i, align 4
  %idxprom = sext i32 %17 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 1
  %19 = load i32, i32* %callsite, align 8
  %20 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame11 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %20, i32 0, i32 0
  %21 = load i32, i32* %i, align 4
  %idxprom12 = sext i32 %21 to i64
  %arrayidx13 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame11, i64 0, i64 %idxprom12
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx13, align 8
  %callsite14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 1
  %23 = load i32, i32* %callsite14, align 8
  %cmp15 = icmp ne i32 %19, %23
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %for.body
  br label %next

if.end17:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %24 = load i32, i32* %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !120

for.end:                                          ; preds = %for.cond
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state18 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %26, i32 0, i32 0
  call void @clean_verifier_state(%struct.bpf_verifier_env* noundef %25, %struct.bpf_verifier_state* noundef %state18) #20
  br label %next

next:                                             ; preds = %for.end, %if.then16, %if.then6, %if.then
  %27 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next19 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %27, i32 0, i32 1
  %28 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next19, align 8
  store %struct.bpf_verifier_state_list* %28, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond, !llvm.loop !121

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @states_maybe_looping(%struct.bpf_verifier_state* noundef %old, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %old.addr = alloca %struct.bpf_verifier_state*, align 8
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %fold = alloca %struct.bpf_func_state*, align 8
  %fcur = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %fr = alloca i32, align 4
  store %struct.bpf_verifier_state* %old, %struct.bpf_verifier_state** %old.addr, align 8
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 4
  %1 = load i32, i32* %curframe, align 8
  store i32 %1, i32* %fr, align 4
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe1, align 8
  %4 = load i32, i32* %fr, align 4
  %cmp = icmp ne i32 %3, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %5, i32 0, i32 0
  %6 = load i32, i32* %fr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %7, %struct.bpf_func_state** %fold, align 8
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 0
  %9 = load i32, i32* %fr, align 4
  %idxprom3 = sext i32 %9 to i64
  %arrayidx4 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame2, i64 0, i64 %idxprom3
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx4, align 8
  store %struct.bpf_func_state* %10, %struct.bpf_func_state** %fcur, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %11 = load i32, i32* %i, align 4
  %cmp5 = icmp slt i32 %11, 11
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %fold, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 0
  %13 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom6
  %14 = bitcast %struct.bpf_reg_state* %arrayidx7 to i8*
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %fcur, align 8
  %regs8 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 0
  %16 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %16 to i64
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs8, i64 0, i64 %idxprom9
  %17 = bitcast %struct.bpf_reg_state* %arrayidx10 to i8*
  %call = call i32 @memcmp(i8* noundef %14, i8* noundef %17, i64 noundef 96) #20
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body
  store i1 false, i1* %retval, align 1
  br label %return

if.end12:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !122

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then11, %if.then
  %19 = load i1, i1* %retval, align 1
  ret i1 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @states_equal(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %old, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %old.addr = alloca %struct.bpf_verifier_state*, align 8
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %old, %struct.bpf_verifier_state** %old.addr, align 8
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 4
  %1 = load i32, i32* %curframe, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe1, align 8
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 6
  %5 = load i8, i8* %speculative, align 8
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %speculative2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 6
  %7 = load i8, i8* %speculative2, align 8
  %tobool3 = trunc i8 %7 to i1
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  store i1 false, i1* %retval, align 1
  br label %return

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 5
  %9 = load i32, i32* %active_spin_lock, align 4
  %10 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %active_spin_lock6 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %10, i32 0, i32 5
  %11 = load i32, i32* %active_spin_lock6, align 4
  %cmp7 = icmp ne i32 %9, %11
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  store i1 false, i1* %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.end5
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 4
  %14 = load i32, i32* %curframe10, align 8
  %cmp11 = icmp ule i32 %12, %14
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %15, i32 0, i32 0
  %16 = load i32, i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 1
  %18 = load i32, i32* %callsite, align 8
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame12 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 0
  %20 = load i32, i32* %i, align 4
  %idxprom13 = sext i32 %20 to i64
  %arrayidx14 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame12, i64 0, i64 %idxprom13
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx14, align 8
  %callsite15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 1
  %22 = load i32, i32* %callsite15, align 8
  %cmp16 = icmp ne i32 %18, %22
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.body
  store i1 false, i1* %retval, align 1
  br label %return

if.end18:                                         ; preds = %for.body
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame19 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %24, i32 0, i32 0
  %25 = load i32, i32* %i, align 4
  %idxprom20 = sext i32 %25 to i64
  %arrayidx21 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame19, i64 0, i64 %idxprom20
  %26 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx21, align 8
  %27 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame22 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %27, i32 0, i32 0
  %28 = load i32, i32* %i, align 4
  %idxprom23 = sext i32 %28 to i64
  %arrayidx24 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame22, i64 0, i64 %idxprom23
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx24, align 8
  %call = call zeroext i1 @func_states_equal(%struct.bpf_verifier_env* noundef %23, %struct.bpf_func_state* noundef %26, %struct.bpf_func_state* noundef %29) #20
  br i1 %call, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end18
  store i1 false, i1* %retval, align 1
  br label %return

if.end26:                                         ; preds = %if.end18
  br label %for.inc

for.inc:                                          ; preds = %if.end26
  %30 = load i32, i32* %i, align 4
  %inc = add i32 %30, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !123

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then25, %if.then17, %if.then8, %if.then4, %if.then
  %31 = load i1, i1* %retval, align 1
  ret i1 %31
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @propagate_liveness(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %vstate, %struct.bpf_verifier_state* noundef %vparent) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %vparent.addr = alloca %struct.bpf_verifier_state*, align 8
  %state_reg = alloca %struct.bpf_reg_state*, align 8
  %parent_reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %parent = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %frame = alloca i32, align 4
  %err = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_verifier_state* %vparent, %struct.bpf_verifier_state** %vparent.addr, align 8
  store i32 0, i32* %err, align 4
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vparent.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 4
  %1 = load i32, i32* %curframe, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe1, align 8
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end25

if.then:                                          ; preds = %entry
  store i32 1, i32* %__ret_warn_on, align 4
  %4 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %4, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool3 = icmp ne i64 %conv, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  br label %do.body5

do.body5:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body5
  %5 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vparent.addr, align 8
  %curframe6 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %5, i32 0, i32 4
  %6 = load i32, i32* %curframe6, align 8
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe7 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 4
  %8 = load i32, i32* %curframe7, align 8
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.312, i64 0, i64 0), i32 noundef %6, i32 noundef %8) #20
  br label %do.body8

do.body8:                                         ; preds = %do.end
  store i32 2313, i32* %__flags, align 4
  br label %do.body9

do.body9:                                         ; preds = %do.body8
  br label %do.end10

do.end10:                                         ; preds = %do.body9
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %9 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 13751, i32 %9, i64 12) #19, !srcloc !124
  br label %do.end12

do.end12:                                         ; preds = %do.body11
  br label %do.body13

do.body13:                                        ; preds = %do.end12
  br label %do.end14

do.end14:                                         ; preds = %do.body13
  br label %do.end15

do.end15:                                         ; preds = %do.end14
  br label %do.body16

do.body16:                                        ; preds = %do.end15
  br label %do.end17

do.end17:                                         ; preds = %do.body16
  br label %do.end18

do.end18:                                         ; preds = %do.end17
  br label %if.end

if.end:                                           ; preds = %do.end18, %if.then
  %10 = load i32, i32* %__ret_warn_on, align 4
  %tobool19 = icmp ne i32 %10, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  store i64 %conv24, i64* %tmp, align 8
  %11 = load i64, i64* %tmp, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end25:                                         ; preds = %entry
  br label %do.body26

do.body26:                                        ; preds = %if.end25
  br label %do.end27

do.end27:                                         ; preds = %do.body26
  store i32 0, i32* %frame, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc80, %do.end27
  %12 = load i32, i32* %frame, align 4
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe28 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 4
  %14 = load i32, i32* %curframe28, align 8
  %cmp29 = icmp ule i32 %12, %14
  br i1 %cmp29, label %for.body, label %for.end82

for.body:                                         ; preds = %for.cond
  %15 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vparent.addr, align 8
  %frame31 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %15, i32 0, i32 0
  %16 = load i32, i32* %frame, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame31, i64 0, i64 %idxprom
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %17, %struct.bpf_func_state** %parent, align 8
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame32 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 0
  %19 = load i32, i32* %frame, align 4
  %idxprom33 = sext i32 %19 to i64
  %arrayidx34 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame32, i64 0, i64 %idxprom33
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx34, align 8
  store %struct.bpf_func_state* %20, %struct.bpf_func_state** %state, align 8
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %parent, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %parent_reg, align 8
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs35 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 0
  %arraydecay36 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs35, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay36, %struct.bpf_reg_state** %state_reg, align 8
  %23 = load i32, i32* %frame, align 4
  %24 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe37 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %24, i32 0, i32 4
  %25 = load i32, i32* %curframe37, align 8
  %cmp38 = icmp ult i32 %23, %25
  %26 = zext i1 %cmp38 to i64
  %cond = select i1 %cmp38, i32 6, i32 0
  store i32 %cond, i32* %i, align 4
  br label %for.cond40

for.cond40:                                       ; preds = %for.inc, %for.body
  %27 = load i32, i32* %i, align 4
  %cmp41 = icmp slt i32 %27, 10
  br i1 %cmp41, label %for.body43, label %for.end

for.body43:                                       ; preds = %for.cond40
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %30 = load i32, i32* %i, align 4
  %idxprom44 = sext i32 %30 to i64
  %arrayidx45 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i64 %idxprom44
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg, align 8
  %32 = load i32, i32* %i, align 4
  %idxprom46 = sext i32 %32 to i64
  %arrayidx47 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i64 %idxprom46
  %call = call i32 @propagate_liveness_reg(%struct.bpf_verifier_env* noundef %28, %struct.bpf_reg_state* noundef %arrayidx45, %struct.bpf_reg_state* noundef %arrayidx47) #20
  store i32 %call, i32* %err, align 4
  %33 = load i32, i32* %err, align 4
  %cmp48 = icmp slt i32 %33, 0
  br i1 %cmp48, label %if.then50, label %if.end51

if.then50:                                        ; preds = %for.body43
  %34 = load i32, i32* %err, align 4
  store i32 %34, i32* %retval, align 4
  br label %return

if.end51:                                         ; preds = %for.body43
  %35 = load i32, i32* %err, align 4
  %cmp52 = icmp eq i32 %35, 2
  br i1 %cmp52, label %if.then54, label %if.end57

if.then54:                                        ; preds = %if.end51
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg, align 8
  %38 = load i32, i32* %i, align 4
  %idxprom55 = sext i32 %38 to i64
  %arrayidx56 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i64 %idxprom55
  call void @mark_insn_zext(%struct.bpf_verifier_env* noundef %36, %struct.bpf_reg_state* noundef %arrayidx56) #20
  br label %if.end57

if.end57:                                         ; preds = %if.then54, %if.end51
  br label %for.inc

for.inc:                                          ; preds = %if.end57
  %39 = load i32, i32* %i, align 4
  %inc = add i32 %39, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond40, !llvm.loop !125

for.end:                                          ; preds = %for.cond40
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc77, %for.end
  %40 = load i32, i32* %i, align 4
  %41 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %41, i32 0, i32 10
  %42 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %42, 8
  %cmp59 = icmp slt i32 %40, %div
  br i1 %cmp59, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond58
  %43 = load i32, i32* %i, align 4
  %44 = load %struct.bpf_func_state*, %struct.bpf_func_state** %parent, align 8
  %allocated_stack61 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %44, i32 0, i32 10
  %45 = load i32, i32* %allocated_stack61, align 8
  %div62 = sdiv i32 %45, 8
  %cmp63 = icmp slt i32 %43, %div62
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond58
  %46 = phi i1 [ false, %for.cond58 ], [ %cmp63, %land.rhs ]
  br i1 %46, label %for.body65, label %for.end79

for.body65:                                       ; preds = %land.end
  %47 = load %struct.bpf_func_state*, %struct.bpf_func_state** %parent, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %47, i32 0, i32 11
  %48 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %49 = load i32, i32* %i, align 4
  %idxprom66 = sext i32 %49 to i64
  %arrayidx67 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %48, i64 %idxprom66
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx67, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %parent_reg, align 8
  %50 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack68 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %50, i32 0, i32 11
  %51 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack68, align 8
  %52 = load i32, i32* %i, align 4
  %idxprom69 = sext i32 %52 to i64
  %arrayidx70 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %51, i64 %idxprom69
  %spilled_ptr71 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx70, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr71, %struct.bpf_reg_state** %state_reg, align 8
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg, align 8
  %call72 = call i32 @propagate_liveness_reg(%struct.bpf_verifier_env* noundef %53, %struct.bpf_reg_state* noundef %54, %struct.bpf_reg_state* noundef %55) #20
  store i32 %call72, i32* %err, align 4
  %56 = load i32, i32* %err, align 4
  %cmp73 = icmp slt i32 %56, 0
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %for.body65
  %57 = load i32, i32* %err, align 4
  store i32 %57, i32* %retval, align 4
  br label %return

if.end76:                                         ; preds = %for.body65
  br label %for.inc77

for.inc77:                                        ; preds = %if.end76
  %58 = load i32, i32* %i, align 4
  %inc78 = add i32 %58, 1
  store i32 %inc78, i32* %i, align 4
  br label %for.cond58, !llvm.loop !126

for.end79:                                        ; preds = %land.end
  br label %for.inc80

for.inc80:                                        ; preds = %for.end79
  %59 = load i32, i32* %frame, align 4
  %inc81 = add i32 %59, 1
  store i32 %inc81, i32* %frame, align 4
  br label %for.cond, !llvm.loop !127

for.end82:                                        ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end82, %if.then75, %if.then50, %if.end
  %60 = load i32, i32* %retval, align 4
  ret i32 %60
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %cnt = alloca i32, align 4
  %p = alloca %struct.bpf_idx_pair*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 10
  %1 = load i32, i32* %jmp_history_cnt, align 8
  store i32 %1, i32* %cnt, align 4
  %2 = load i32, i32* %cnt, align 4
  %inc = add i32 %2, 1
  store i32 %inc, i32* %cnt, align 4
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  %4 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history, align 8
  %5 = bitcast %struct.bpf_idx_pair* %4 to i8*
  %6 = load i32, i32* %cnt, align 4
  %conv = zext i32 %6 to i64
  %mul = mul i64 %conv, 8
  %call = call i8* @krealloc(i8* noundef %5, i64 noundef %mul, i32 noundef 1051840) #29
  %7 = bitcast i8* %call to %struct.bpf_idx_pair*
  store %struct.bpf_idx_pair* %7, %struct.bpf_idx_pair** %p, align 8
  %8 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %p, align 8
  %tobool = icmp ne %struct.bpf_idx_pair* %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 0
  %10 = load i32, i32* %insn_idx, align 8
  %11 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %p, align 8
  %12 = load i32, i32* %cnt, align 4
  %sub = sub i32 %12, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr %struct.bpf_idx_pair, %struct.bpf_idx_pair* %11, i64 %idxprom
  %idx = getelementptr inbounds %struct.bpf_idx_pair, %struct.bpf_idx_pair* %arrayidx, i32 0, i32 1
  store i32 %10, i32* %idx, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 1
  %14 = load i32, i32* %prev_insn_idx, align 4
  %15 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %p, align 8
  %16 = load i32, i32* %cnt, align 4
  %sub1 = sub i32 %16, 1
  %idxprom2 = zext i32 %sub1 to i64
  %arrayidx3 = getelementptr %struct.bpf_idx_pair, %struct.bpf_idx_pair* %15, i64 %idxprom2
  %prev_idx = getelementptr inbounds %struct.bpf_idx_pair, %struct.bpf_idx_pair* %arrayidx3, i32 0, i32 0
  store i32 %14, i32* %prev_idx, align 4
  %17 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %p, align 8
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 9
  store %struct.bpf_idx_pair* %17, %struct.bpf_idx_pair** %jmp_history4, align 8
  %19 = load i32, i32* %cnt, align 4
  %20 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history_cnt5 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %20, i32 0, i32 10
  store i32 %19, i32* %jmp_history_cnt5, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %21 = load i32, i32* %retval, align 4
  ret i32 %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @propagate_precision(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %old) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %old.addr = alloca %struct.bpf_verifier_state*, align 8
  %state_reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %old, %struct.bpf_verifier_state** %old.addr, align 8
  store i32 0, i32* %err, align 4
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %3, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %state_reg, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %5, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp1 = icmp ne i32 %7, 1
  br i1 %cmp1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 18
  %9 = load i8, i8* %precise, align 4
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end:                                           ; preds = %lor.lhs.false
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %11 = load i32, i32* %level, align 8
  %and = and i32 %11, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.313, i64 0, i64 0), i32 noundef %14) #20
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = load i32, i32* %i, align 4
  %call = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %15, i32 noundef %16) #20
  store i32 %call, i32* %err, align 4
  %17 = load i32, i32* %err, align 4
  %cmp5 = icmp slt i32 %17, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %18 = load i32, i32* %err, align 4
  store i32 %18, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end4
  br label %for.inc

for.inc:                                          ; preds = %if.end7, %if.then
  %19 = load i32, i32* %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %i, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %incdec.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 1
  store %struct.bpf_reg_state* %incdec.ptr, %struct.bpf_reg_state** %state_reg, align 8
  br label %for.cond, !llvm.loop !128

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc37, %for.end
  %21 = load i32, i32* %i, align 4
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 10
  %23 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %23, 8
  %cmp9 = icmp slt i32 %21, %div
  br i1 %cmp9, label %for.body10, label %for.end39

for.body10:                                       ; preds = %for.cond8
  %24 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %24, i32 0, i32 11
  %25 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %26 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %26 to i64
  %arrayidx12 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %25, i64 %idxprom11
  %call13 = call zeroext i1 @is_spilled_reg(%struct.bpf_stack_state* noundef %arrayidx12) #20
  br i1 %call13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %for.body10
  br label %for.inc37

if.end15:                                         ; preds = %for.body10
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack16 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 11
  %28 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack16, align 8
  %29 = load i32, i32* %i, align 4
  %idxprom17 = sext i32 %29 to i64
  %arrayidx18 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %28, i64 %idxprom17
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx18, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %state_reg, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %type19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 0
  %31 = load i32, i32* %type19, align 8
  %cmp20 = icmp ne i32 %31, 1
  br i1 %cmp20, label %if.then24, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %if.end15
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %precise22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 18
  %33 = load i8, i8* %precise22, align 4
  %tobool23 = trunc i8 %33 to i1
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %lor.lhs.false21, %if.end15
  br label %for.inc37

if.end25:                                         ; preds = %lor.lhs.false21
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log26 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %34, i32 0, i32 26
  %level27 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log26, i32 0, i32 0
  %35 = load i32, i32* %level27, align 8
  %and28 = and i32 %35, 2
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end25
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  %38 = load i32, i32* %i, align 4
  %sub = sub i32 0, %38
  %sub31 = sub i32 %sub, 1
  %mul = mul i32 %sub31, 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.314, i64 0, i64 0), i32 noundef %mul) #20
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %if.end25
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load i32, i32* %i, align 4
  %call33 = call i32 @mark_chain_precision_stack(%struct.bpf_verifier_env* noundef %39, i32 noundef %40) #20
  store i32 %call33, i32* %err, align 4
  %41 = load i32, i32* %err, align 4
  %cmp34 = icmp slt i32 %41, 0
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end32
  %42 = load i32, i32* %err, align 4
  store i32 %42, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.end32
  br label %for.inc37

for.inc37:                                        ; preds = %if.end36, %if.then24, %if.then14
  %43 = load i32, i32* %i, align 4
  %inc38 = add i32 %43, 1
  store i32 %inc38, i32* %i, align 4
  br label %for.cond8, !llvm.loop !129

for.end39:                                        ; preds = %for.cond8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end39, %if.then35, %if.then6
  %44 = load i32, i32* %retval, align 4
  ret i32 %44
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %dst_state, %struct.bpf_verifier_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst_state.addr = alloca %struct.bpf_verifier_state*, align 8
  %src.addr = alloca %struct.bpf_verifier_state*, align 8
  %dst = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_state* %dst_state, %struct.bpf_verifier_state** %dst_state.addr, align 8
  store %struct.bpf_verifier_state* %src, %struct.bpf_verifier_state** %src.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 9
  %1 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history, align 8
  %2 = bitcast %struct.bpf_idx_pair* %1 to i8*
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  %4 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history1, align 8
  %5 = bitcast %struct.bpf_idx_pair* %4 to i8*
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 10
  %7 = load i32, i32* %jmp_history_cnt, align 8
  %conv = zext i32 %7 to i64
  %call = call i8* @copy_array(i8* noundef %2, i8* noundef %5, i64 noundef %conv, i64 noundef 8, i32 noundef 1051840) #20
  %8 = bitcast i8* %call to %struct.bpf_idx_pair*
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %9, i32 0, i32 9
  store %struct.bpf_idx_pair* %8, %struct.bpf_idx_pair** %jmp_history2, align 8
  %10 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %10, i32 0, i32 9
  %11 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history3, align 8
  %tobool = icmp ne %struct.bpf_idx_pair* %11, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history_cnt4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 10
  %13 = load i32, i32* %jmp_history_cnt4, align 8
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history_cnt5 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 10
  store i32 %13, i32* %jmp_history_cnt5, align 8
  %15 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %15, i32 0, i32 4
  %16 = load i32, i32* %curframe, align 8
  %add = add i32 %16, 1
  store i32 %add, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %17 = load i32, i32* %i, align 4
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %curframe6 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 4
  %19 = load i32, i32* %curframe6, align 8
  %cmp = icmp ule i32 %17, %19
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %20, i32 0, i32 0
  %21 = load i32, i32* %i, align 4
  %idxprom = sext i32 %21 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %22) #20
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 0
  %24 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %24 to i64
  %arrayidx10 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame8, i64 0, i64 %idxprom9
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx10, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %25 = load i32, i32* %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !130

for.end:                                          ; preds = %for.cond
  %26 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %26, i32 0, i32 6
  %27 = load i8, i8* %speculative, align 8
  %tobool11 = trunc i8 %27 to i1
  %28 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %speculative12 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %28, i32 0, i32 6
  %frombool = zext i1 %tobool11 to i8
  store i8 %frombool, i8* %speculative12, align 8
  %29 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %curframe13 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %29, i32 0, i32 4
  %30 = load i32, i32* %curframe13, align 8
  %31 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %curframe14 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %31, i32 0, i32 4
  store i32 %30, i32* %curframe14, align 8
  %32 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %32, i32 0, i32 5
  %33 = load i32, i32* %active_spin_lock, align 4
  %34 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %active_spin_lock15 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %34, i32 0, i32 5
  store i32 %33, i32* %active_spin_lock15, align 4
  %35 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %35, i32 0, i32 2
  %36 = load i32, i32* %branches, align 8
  %37 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %branches16 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %37, i32 0, i32 2
  store i32 %36, i32* %branches16, align 8
  %38 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %38, i32 0, i32 1
  %39 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  %40 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %parent17 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %40, i32 0, i32 1
  store %struct.bpf_verifier_state* %39, %struct.bpf_verifier_state** %parent17, align 8
  %41 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %first_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %41, i32 0, i32 7
  %42 = load i32, i32* %first_insn_idx, align 4
  %43 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %first_insn_idx18 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %43, i32 0, i32 7
  store i32 %42, i32* %first_insn_idx18, align 4
  %44 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %last_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %44, i32 0, i32 8
  %45 = load i32, i32* %last_insn_idx, align 8
  %46 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %last_insn_idx19 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %46, i32 0, i32 8
  store i32 %45, i32* %last_insn_idx19, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc45, %for.end
  %47 = load i32, i32* %i, align 4
  %48 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %curframe21 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %48, i32 0, i32 4
  %49 = load i32, i32* %curframe21, align 8
  %cmp22 = icmp ule i32 %47, %49
  br i1 %cmp22, label %for.body24, label %for.end47

for.body24:                                       ; preds = %for.cond20
  %50 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame25 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %50, i32 0, i32 0
  %51 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %51 to i64
  %arrayidx27 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame25, i64 0, i64 %idxprom26
  %52 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx27, align 8
  store %struct.bpf_func_state* %52, %struct.bpf_func_state** %dst, align 8
  %53 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %tobool28 = icmp ne %struct.bpf_func_state* %53, null
  br i1 %tobool28, label %if.end37, label %if.then29

if.then29:                                        ; preds = %for.body24
  %call30 = call noalias i8* @kzalloc(i64 noundef 1392, i32 noundef 3264) #24
  %54 = bitcast i8* %call30 to %struct.bpf_func_state*
  store %struct.bpf_func_state* %54, %struct.bpf_func_state** %dst, align 8
  %55 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %tobool31 = icmp ne %struct.bpf_func_state* %55, null
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %if.then29
  store i32 -12, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.then29
  %56 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %57 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame34 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %57, i32 0, i32 0
  %58 = load i32, i32* %i, align 4
  %idxprom35 = sext i32 %58 to i64
  %arrayidx36 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame34, i64 0, i64 %idxprom35
  store %struct.bpf_func_state* %56, %struct.bpf_func_state** %arrayidx36, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.end33, %for.body24
  %59 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %60 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %frame38 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %60, i32 0, i32 0
  %61 = load i32, i32* %i, align 4
  %idxprom39 = sext i32 %61 to i64
  %arrayidx40 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame38, i64 0, i64 %idxprom39
  %62 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx40, align 8
  %call41 = call i32 @copy_func_state(%struct.bpf_func_state* noundef %59, %struct.bpf_func_state* noundef %62) #20
  store i32 %call41, i32* %err, align 4
  %63 = load i32, i32* %err, align 4
  %tobool42 = icmp ne i32 %63, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end37
  %64 = load i32, i32* %err, align 4
  store i32 %64, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %if.end37
  br label %for.inc45

for.inc45:                                        ; preds = %if.end44
  %65 = load i32, i32* %i, align 4
  %inc46 = add i32 %65, 1
  store i32 %inc46, i32* %i, align 4
  br label %for.cond20, !llvm.loop !131

for.end47:                                        ; preds = %for.cond20
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end47, %if.then43, %if.then32, %if.then
  %66 = load i32, i32* %retval, align 4
  ret i32 %66
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clear_jmp_history(%struct.bpf_verifier_state* noundef %state) #0 {
entry:
  %state.addr = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_state* %state, %struct.bpf_verifier_state** %state.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 9
  %1 = load %struct.bpf_idx_pair*, %struct.bpf_idx_pair** %jmp_history, align 8
  %2 = bitcast %struct.bpf_idx_pair* %1 to i8*
  call void @kfree(i8* noundef %2) #20
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %jmp_history1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  store %struct.bpf_idx_pair* null, %struct.bpf_idx_pair** %jmp_history1, align 8
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 10
  store i32 0, i32* %jmp_history_cnt, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clean_verifier_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 0
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %arrayidx1 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx1, i32 0, i32 17
  %2 = load i32, i32* %live, align 8
  %and = and i32 %2, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %i, align 4
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 4
  %5 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %3, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %frame2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 0
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx3 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame2, i64 0, i64 %idxprom
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx3, align 8
  call void @clean_func_state(%struct.bpf_verifier_env* noundef %6, %struct.bpf_func_state* noundef %9) #20
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !132

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clean_func_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_func_state*, align 8
  %live = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %st, %struct.bpf_func_state** %st.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %2 = load i32, i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %live1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 17
  %3 = load i32, i32* %live1, align 8
  store i32 %3, i32* %live, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %regs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %5 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %5 to i64
  %arrayidx4 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs2, i64 0, i64 %idxprom3
  %live5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx4, i32 0, i32 17
  %6 = load i32, i32* %live5, align 8
  %or = or i32 %6, 8
  store i32 %or, i32* %live5, align 8
  %7 = load i32, i32* %live, align 4
  %and = and i32 %7, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %regs6 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 0
  %10 = load i32, i32* %i, align 4
  %idxprom7 = sext i32 %10 to i64
  %arrayidx8 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs6, i64 0, i64 %idxprom7
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %arrayidx8) #20
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %11 = load i32, i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !133

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc40, %for.end
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 10
  %14 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %14, 8
  %cmp10 = icmp slt i32 %12, %div
  br i1 %cmp10, label %for.body11, label %for.end42

for.body11:                                       ; preds = %for.cond9
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 11
  %16 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %17 = load i32, i32* %i, align 4
  %idxprom12 = sext i32 %17 to i64
  %arrayidx13 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %16, i64 %idxprom12
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx13, i32 0, i32 0
  %live14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 17
  %18 = load i32, i32* %live14, align 8
  store i32 %18, i32* %live, align 4
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 11
  %20 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack15, align 8
  %21 = load i32, i32* %i, align 4
  %idxprom16 = sext i32 %21 to i64
  %arrayidx17 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %20, i64 %idxprom16
  %spilled_ptr18 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx17, i32 0, i32 0
  %live19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr18, i32 0, i32 17
  %22 = load i32, i32* %live19, align 8
  %or20 = or i32 %22, 8
  store i32 %or20, i32* %live19, align 8
  %23 = load i32, i32* %live, align 4
  %and21 = and i32 %23, 3
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.end39, label %if.then23

if.then23:                                        ; preds = %for.body11
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack24 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 11
  %26 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack24, align 8
  %27 = load i32, i32* %i, align 4
  %idxprom25 = sext i32 %27 to i64
  %arrayidx26 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %26, i64 %idxprom25
  %spilled_ptr27 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx26, i32 0, i32 0
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %24, %struct.bpf_reg_state* noundef %spilled_ptr27) #20
  store i32 0, i32* %j, align 4
  br label %for.cond28

for.cond28:                                       ; preds = %for.inc36, %if.then23
  %28 = load i32, i32* %j, align 4
  %cmp29 = icmp slt i32 %28, 8
  br i1 %cmp29, label %for.body30, label %for.end38

for.body30:                                       ; preds = %for.cond28
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack31 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 11
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack31, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom32 = sext i32 %31 to i64
  %arrayidx33 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom32
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx33, i32 0, i32 1
  %32 = load i32, i32* %j, align 4
  %idxprom34 = sext i32 %32 to i64
  %arrayidx35 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom34
  store i8 0, i8* %arrayidx35, align 1
  br label %for.inc36

for.inc36:                                        ; preds = %for.body30
  %33 = load i32, i32* %j, align 4
  %inc37 = add i32 %33, 1
  store i32 %inc37, i32* %j, align 4
  br label %for.cond28, !llvm.loop !134

for.end38:                                        ; preds = %for.cond28
  br label %if.end39

if.end39:                                         ; preds = %for.end38, %for.body11
  br label %for.inc40

for.inc40:                                        ; preds = %if.end39
  %34 = load i32, i32* %i, align 4
  %inc41 = add i32 %34, 1
  store i32 %inc41, i32* %i, align 4
  br label %for.cond9, !llvm.loop !135

for.end42:                                        ; preds = %for.cond9
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @memcmp(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @func_states_equal(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %old, %struct.bpf_func_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %old.addr = alloca %struct.bpf_func_state*, align 8
  %cur.addr = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %old, %struct.bpf_func_state** %old.addr, align 8
  store %struct.bpf_func_state* %cur, %struct.bpf_func_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %idmap_scratch = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 28
  %arraydecay = getelementptr inbounds [75 x %struct.bpf_id_pair], [75 x %struct.bpf_id_pair]* %idmap_scratch, i64 0, i64 0
  %1 = bitcast %struct.bpf_id_pair* %arraydecay to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %1, i8 0, i64 600, i1 false)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %2, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %5 = load i32, i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %7 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 %idxprom2
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %idmap_scratch4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 28
  %arraydecay5 = getelementptr inbounds [75 x %struct.bpf_id_pair], [75 x %struct.bpf_id_pair]* %idmap_scratch4, i64 0, i64 0
  %call = call zeroext i1 @regsafe(%struct.bpf_verifier_env* noundef %3, %struct.bpf_reg_state* noundef %arrayidx, %struct.bpf_reg_state* noundef %arrayidx3, %struct.bpf_id_pair* noundef %arraydecay5) #20
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !136

for.end:                                          ; preds = %for.cond
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %idmap_scratch6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 28
  %arraydecay7 = getelementptr inbounds [75 x %struct.bpf_id_pair], [75 x %struct.bpf_id_pair]* %idmap_scratch6, i64 0, i64 0
  %call8 = call zeroext i1 @stacksafe(%struct.bpf_verifier_env* noundef %10, %struct.bpf_func_state* noundef %11, %struct.bpf_func_state* noundef %12, %struct.bpf_id_pair* noundef %arraydecay7) #20
  br i1 %call8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %for.end
  store i1 false, i1* %retval, align 1
  br label %return

if.end10:                                         ; preds = %for.end
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %call11 = call zeroext i1 @refsafe(%struct.bpf_func_state* noundef %14, %struct.bpf_func_state* noundef %15) #20
  br i1 %call11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end10
  store i1 false, i1* %retval, align 1
  br label %return

if.end13:                                         ; preds = %if.end10
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end13, %if.then12, %if.then9, %if.then
  %16 = load i1, i1* %retval, align 1
  ret i1 %16
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @regsafe(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %rold, %struct.bpf_reg_state* noundef %rcur, %struct.bpf_id_pair* noundef %idmap) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %rold.addr = alloca %struct.bpf_reg_state*, align 8
  %rcur.addr = alloca %struct.bpf_reg_state*, align 8
  %idmap.addr = alloca %struct.bpf_id_pair*, align 8
  %equal = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %rold, %struct.bpf_reg_state** %rold.addr, align 8
  store %struct.bpf_reg_state* %rcur, %struct.bpf_reg_state** %rcur.addr, align 8
  store %struct.bpf_id_pair* %idmap, %struct.bpf_id_pair** %idmap.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 17
  %1 = load i32, i32* %live, align 8
  %and = and i32 %1, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %3 = bitcast %struct.bpf_reg_state* %2 to i8*
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %5 = bitcast %struct.bpf_reg_state* %4 to i8*
  %call = call i32 @memcmp(i8* noundef %3, i8* noundef %5, i64 noundef 96) #20
  %cmp = icmp eq i32 %call, 0
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %equal, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp1 = icmp eq i32 %7, 6
  br i1 %cmp1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %8 = load i8, i8* %equal, align 1
  %tobool3 = trunc i8 %8 to i1
  br i1 %tobool3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then2
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 15
  %10 = load i32, i32* %frameno, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %frameno4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 15
  %12 = load i32, i32* %frameno4, align 8
  %cmp5 = icmp eq i32 %10, %12
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then2
  %13 = phi i1 [ false, %if.then2 ], [ %cmp5, %land.rhs ]
  store i1 %13, i1* %retval, align 1
  br label %return

if.end6:                                          ; preds = %if.end
  %14 = load i8, i8* %equal, align 1
  %tobool7 = trunc i8 %14 to i1
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  store i1 true, i1* %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.end6
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type10, align 8
  %cmp11 = icmp eq i32 %16, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  store i1 true, i1* %retval, align 1
  br label %return

if.end13:                                         ; preds = %if.end9
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 0
  %18 = load i32, i32* %type14, align 8
  %cmp15 = icmp eq i32 %18, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  store i1 false, i1* %retval, align 1
  br label %return

if.end17:                                         ; preds = %if.end13
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type18, align 8
  %call19 = call i32 @base_type(i32 noundef %20) #20
  switch i32 %call19, label %sw.default [
    i32 1, label %sw.bb
    i32 5, label %sw.bb36
    i32 4, label %sw.bb36
    i32 7, label %sw.bb60
    i32 8, label %sw.bb60
    i32 2, label %sw.bb88
    i32 3, label %sw.bb88
    i32 9, label %sw.bb88
    i32 10, label %sw.bb88
    i32 11, label %sw.bb88
    i32 12, label %sw.bb88
    i32 13, label %sw.bb88
    i32 15, label %sw.bb88
  ]

sw.bb:                                            ; preds = %if.end17
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explore_alu_limits = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %21, i32 0, i32 16
  %22 = load i8, i8* %explore_alu_limits, align 4
  %tobool20 = trunc i8 %22 to i1
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %sw.bb
  store i1 false, i1* %retval, align 1
  br label %return

if.end22:                                         ; preds = %sw.bb
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 0
  %24 = load i32, i32* %type23, align 8
  %cmp24 = icmp eq i32 %24, 1
  br i1 %cmp24, label %if.then25, label %if.else

if.then25:                                        ; preds = %if.end22
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 18
  %26 = load i8, i8* %precise, align 4
  %tobool26 = trunc i8 %26 to i1
  br i1 %tobool26, label %if.end30, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then25
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %precise27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 18
  %28 = load i8, i8* %precise27, align 4
  %tobool28 = trunc i8 %28 to i1
  br i1 %tobool28, label %if.end30, label %if.then29

if.then29:                                        ; preds = %land.lhs.true
  store i1 true, i1* %retval, align 1
  br label %return

if.end30:                                         ; preds = %land.lhs.true, %if.then25
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %call31 = call zeroext i1 @range_within(%struct.bpf_reg_state* noundef %29, %struct.bpf_reg_state* noundef %30) #20
  br i1 %call31, label %land.rhs32, label %land.end35

land.rhs32:                                       ; preds = %if.end30
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 5
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %var_off33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 5
  %33 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %33, i32 0, i32 0
  %35 = load i64, i64* %34, align 8
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %33, i32 0, i32 1
  %37 = load i64, i64* %36, align 8
  %38 = bitcast %struct.tnum* %var_off33 to { i64, i64 }*
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 0
  %40 = load i64, i64* %39, align 8
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %38, i32 0, i32 1
  %42 = load i64, i64* %41, align 8
  %call34 = call zeroext i1 @tnum_in(i64 %35, i64 %37, i64 %40, i64 %42) #20
  br label %land.end35

land.end35:                                       ; preds = %land.rhs32, %if.end30
  %43 = phi i1 [ false, %if.end30 ], [ %call34, %land.rhs32 ]
  store i1 %43, i1* %retval, align 1
  br label %return

if.else:                                          ; preds = %if.end22
  store i1 false, i1* %retval, align 1
  br label %return

sw.bb36:                                          ; preds = %if.end17, %if.end17
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type37 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 0
  %45 = load i32, i32* %type37, align 8
  %call38 = call zeroext i1 @type_may_be_null(i32 noundef %45) #20
  br i1 %call38, label %if.then39, label %if.end50

if.then39:                                        ; preds = %sw.bb36
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type40 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 0
  %47 = load i32, i32* %type40, align 8
  %call41 = call zeroext i1 @type_may_be_null(i32 noundef %47) #20
  br i1 %call41, label %if.end43, label %if.then42

if.then42:                                        ; preds = %if.then39
  store i1 false, i1* %retval, align 1
  br label %return

if.end43:                                         ; preds = %if.then39
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %49 = bitcast %struct.bpf_reg_state* %48 to i8*
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %51 = bitcast %struct.bpf_reg_state* %50 to i8*
  %call44 = call i32 @memcmp(i8* noundef %49, i8* noundef %51, i64 noundef 24) #20
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.end43
  store i1 false, i1* %retval, align 1
  br label %return

if.end47:                                         ; preds = %if.end43
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 3
  %53 = load i32, i32* %id, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %id48 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 3
  %55 = load i32, i32* %id48, align 8
  %56 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %call49 = call zeroext i1 @check_ids(i32 noundef %53, i32 noundef %55, %struct.bpf_id_pair* noundef %56) #20
  store i1 %call49, i1* %retval, align 1
  br label %return

if.end50:                                         ; preds = %sw.bb36
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %58 = bitcast %struct.bpf_reg_state* %57 to i8*
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %60 = bitcast %struct.bpf_reg_state* %59 to i8*
  %call51 = call i32 @memcmp(i8* noundef %58, i8* noundef %60, i64 noundef 24) #20
  %cmp52 = icmp eq i32 %call51, 0
  br i1 %cmp52, label %land.lhs.true53, label %land.end59

land.lhs.true53:                                  ; preds = %if.end50
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %call54 = call zeroext i1 @range_within(%struct.bpf_reg_state* noundef %61, %struct.bpf_reg_state* noundef %62) #20
  br i1 %call54, label %land.rhs55, label %land.end59

land.rhs55:                                       ; preds = %land.lhs.true53
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %var_off56 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %63, i32 0, i32 5
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %var_off57 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %64, i32 0, i32 5
  %65 = bitcast %struct.tnum* %var_off56 to { i64, i64 }*
  %66 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %65, i32 0, i32 0
  %67 = load i64, i64* %66, align 8
  %68 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %65, i32 0, i32 1
  %69 = load i64, i64* %68, align 8
  %70 = bitcast %struct.tnum* %var_off57 to { i64, i64 }*
  %71 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %70, i32 0, i32 0
  %72 = load i64, i64* %71, align 8
  %73 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %70, i32 0, i32 1
  %74 = load i64, i64* %73, align 8
  %call58 = call zeroext i1 @tnum_in(i64 %67, i64 %69, i64 %72, i64 %74) #20
  br label %land.end59

land.end59:                                       ; preds = %land.rhs55, %land.lhs.true53, %if.end50
  %75 = phi i1 [ false, %land.lhs.true53 ], [ false, %if.end50 ], [ %call58, %land.rhs55 ]
  store i1 %75, i1* %retval, align 1
  br label %return

sw.bb60:                                          ; preds = %if.end17, %if.end17
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type61 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %76, i32 0, i32 0
  %77 = load i32, i32* %type61, align 8
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type62 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %78, i32 0, i32 0
  %79 = load i32, i32* %type62, align 8
  %cmp63 = icmp ne i32 %77, %79
  br i1 %cmp63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %sw.bb60
  store i1 false, i1* %retval, align 1
  br label %return

if.end65:                                         ; preds = %sw.bb60
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 2
  %range = bitcast %union.anon.168* %81 to i32*
  %82 = load i32, i32* %range, align 8
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %84 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 2
  %range66 = bitcast %union.anon.168* %84 to i32*
  %85 = load i32, i32* %range66, align 8
  %cmp67 = icmp sgt i32 %82, %85
  br i1 %cmp67, label %if.then68, label %if.end69

if.then68:                                        ; preds = %if.end65
  store i1 false, i1* %retval, align 1
  br label %return

if.end69:                                         ; preds = %if.end65
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 1
  %87 = load i32, i32* %off, align 4
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %off70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 1
  %89 = load i32, i32* %off70, align 4
  %cmp71 = icmp ne i32 %87, %89
  br i1 %cmp71, label %if.then72, label %if.end73

if.then72:                                        ; preds = %if.end69
  store i1 false, i1* %retval, align 1
  br label %return

if.end73:                                         ; preds = %if.end69
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %id74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %90, i32 0, i32 3
  %91 = load i32, i32* %id74, align 8
  %tobool75 = icmp ne i32 %91, 0
  br i1 %tobool75, label %land.lhs.true76, label %if.end81

land.lhs.true76:                                  ; preds = %if.end73
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %id77 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 3
  %93 = load i32, i32* %id77, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %id78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %94, i32 0, i32 3
  %95 = load i32, i32* %id78, align 8
  %96 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %call79 = call zeroext i1 @check_ids(i32 noundef %93, i32 noundef %95, %struct.bpf_id_pair* noundef %96) #20
  br i1 %call79, label %if.end81, label %if.then80

if.then80:                                        ; preds = %land.lhs.true76
  store i1 false, i1* %retval, align 1
  br label %return

if.end81:                                         ; preds = %land.lhs.true76, %if.end73
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %call82 = call zeroext i1 @range_within(%struct.bpf_reg_state* noundef %97, %struct.bpf_reg_state* noundef %98) #20
  br i1 %call82, label %land.rhs83, label %land.end87

land.rhs83:                                       ; preds = %if.end81
  %99 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %var_off84 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %99, i32 0, i32 5
  %100 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %100, i32 0, i32 5
  %101 = bitcast %struct.tnum* %var_off84 to { i64, i64 }*
  %102 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %101, i32 0, i32 0
  %103 = load i64, i64* %102, align 8
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %101, i32 0, i32 1
  %105 = load i64, i64* %104, align 8
  %106 = bitcast %struct.tnum* %var_off85 to { i64, i64 }*
  %107 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %106, i32 0, i32 0
  %108 = load i64, i64* %107, align 8
  %109 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %106, i32 0, i32 1
  %110 = load i64, i64* %109, align 8
  %call86 = call zeroext i1 @tnum_in(i64 %103, i64 %105, i64 %108, i64 %110) #20
  br label %land.end87

land.end87:                                       ; preds = %land.rhs83, %if.end81
  %111 = phi i1 [ false, %if.end81 ], [ %call86, %land.rhs83 ]
  store i1 %111, i1* %retval, align 1
  br label %return

sw.bb88:                                          ; preds = %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17
  br label %sw.default

sw.default:                                       ; preds = %if.end17, %sw.bb88
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %land.end87, %if.then80, %if.then72, %if.then68, %if.then64, %land.end59, %if.end47, %if.then46, %if.then42, %if.else, %land.end35, %if.then29, %if.then21, %if.then16, %if.then12, %if.then8, %land.end, %if.then
  %112 = load i1, i1* %retval, align 1
  ret i1 %112
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @stacksafe(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %old, %struct.bpf_func_state* noundef %cur, %struct.bpf_id_pair* noundef %idmap) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %old.addr = alloca %struct.bpf_func_state*, align 8
  %cur.addr = alloca %struct.bpf_func_state*, align 8
  %idmap.addr = alloca %struct.bpf_id_pair*, align 8
  %i = alloca i32, align 4
  %spi = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %old, %struct.bpf_func_state** %old.addr, align 8
  store %struct.bpf_func_state* %cur, %struct.bpf_func_state** %cur.addr, align 8
  store %struct.bpf_id_pair* %idmap, %struct.bpf_id_pair** %idmap.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 10
  %2 = load i32, i32* %allocated_stack, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, i32* %i, align 4
  %div = sdiv i32 %3, 8
  store i32 %div, i32* %spi, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 11
  %5 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %6 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %5, i64 %idxprom
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 17
  %7 = load i32, i32* %live, align 8
  %and = and i32 %7, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add = add i32 %8, 7
  store i32 %add, i32* %i, align 4
  br label %for.inc

if.end:                                           ; preds = %for.body
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 11
  %10 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack1, align 8
  %11 = load i32, i32* %spi, align 4
  %idxprom2 = sext i32 %11 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %10, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %12 = load i32, i32* %i, align 4
  %rem = srem i32 %12, 8
  %idxprom4 = sext i32 %rem to i64
  %arrayidx5 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom4
  %13 = load i8, i8* %arrayidx5, align 1
  %conv = zext i8 %13 to i32
  %cmp6 = icmp eq i32 %conv, 0
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  br label %for.inc

if.end9:                                          ; preds = %if.end
  %14 = load i32, i32* %i, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %allocated_stack10 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 10
  %16 = load i32, i32* %allocated_stack10, align 8
  %cmp11 = icmp sge i32 %14, %16
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  store i1 false, i1* %retval, align 1
  br label %return

if.end14:                                         ; preds = %if.end9
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 11
  %18 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack15, align 8
  %19 = load i32, i32* %spi, align 4
  %idxprom16 = sext i32 %19 to i64
  %arrayidx17 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %18, i64 %idxprom16
  %slot_type18 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx17, i32 0, i32 1
  %20 = load i32, i32* %i, align 4
  %rem19 = srem i32 %20, 8
  %idxprom20 = sext i32 %rem19 to i64
  %arrayidx21 = getelementptr [8 x i8], [8 x i8]* %slot_type18, i64 0, i64 %idxprom20
  %21 = load i8, i8* %arrayidx21, align 1
  %conv22 = zext i8 %21 to i32
  %cmp23 = icmp eq i32 %conv22, 2
  br i1 %cmp23, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %if.end14
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %stack25 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 11
  %23 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack25, align 8
  %24 = load i32, i32* %spi, align 4
  %idxprom26 = sext i32 %24 to i64
  %arrayidx27 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %23, i64 %idxprom26
  %slot_type28 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx27, i32 0, i32 1
  %25 = load i32, i32* %i, align 4
  %rem29 = srem i32 %25, 8
  %idxprom30 = sext i32 %rem29 to i64
  %arrayidx31 = getelementptr [8 x i8], [8 x i8]* %slot_type28, i64 0, i64 %idxprom30
  %26 = load i8, i8* %arrayidx31, align 1
  %conv32 = zext i8 %26 to i32
  %cmp33 = icmp eq i32 %conv32, 3
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %land.lhs.true
  br label %for.inc

if.end36:                                         ; preds = %land.lhs.true, %if.end14
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack37 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 11
  %28 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack37, align 8
  %29 = load i32, i32* %spi, align 4
  %idxprom38 = sext i32 %29 to i64
  %arrayidx39 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %28, i64 %idxprom38
  %slot_type40 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx39, i32 0, i32 1
  %30 = load i32, i32* %i, align 4
  %rem41 = srem i32 %30, 8
  %idxprom42 = sext i32 %rem41 to i64
  %arrayidx43 = getelementptr [8 x i8], [8 x i8]* %slot_type40, i64 0, i64 %idxprom42
  %31 = load i8, i8* %arrayidx43, align 1
  %conv44 = zext i8 %31 to i32
  %32 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %stack45 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %32, i32 0, i32 11
  %33 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack45, align 8
  %34 = load i32, i32* %spi, align 4
  %idxprom46 = sext i32 %34 to i64
  %arrayidx47 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %33, i64 %idxprom46
  %slot_type48 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx47, i32 0, i32 1
  %35 = load i32, i32* %i, align 4
  %rem49 = srem i32 %35, 8
  %idxprom50 = sext i32 %rem49 to i64
  %arrayidx51 = getelementptr [8 x i8], [8 x i8]* %slot_type48, i64 0, i64 %idxprom50
  %36 = load i8, i8* %arrayidx51, align 1
  %conv52 = zext i8 %36 to i32
  %cmp53 = icmp ne i32 %conv44, %conv52
  br i1 %cmp53, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end36
  store i1 false, i1* %retval, align 1
  br label %return

if.end56:                                         ; preds = %if.end36
  %37 = load i32, i32* %i, align 4
  %rem57 = srem i32 %37, 8
  %cmp58 = icmp ne i32 %rem57, 7
  br i1 %cmp58, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.end56
  br label %for.inc

if.end61:                                         ; preds = %if.end56
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack62 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %38, i32 0, i32 11
  %39 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack62, align 8
  %40 = load i32, i32* %spi, align 4
  %idxprom63 = sext i32 %40 to i64
  %arrayidx64 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %39, i64 %idxprom63
  %call = call zeroext i1 @is_spilled_reg(%struct.bpf_stack_state* noundef %arrayidx64) #20
  br i1 %call, label %if.end66, label %if.then65

if.then65:                                        ; preds = %if.end61
  br label %for.inc

if.end66:                                         ; preds = %if.end61
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack67 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %42, i32 0, i32 11
  %43 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack67, align 8
  %44 = load i32, i32* %spi, align 4
  %idxprom68 = sext i32 %44 to i64
  %arrayidx69 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %43, i64 %idxprom68
  %spilled_ptr70 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx69, i32 0, i32 0
  %45 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %stack71 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %45, i32 0, i32 11
  %46 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack71, align 8
  %47 = load i32, i32* %spi, align 4
  %idxprom72 = sext i32 %47 to i64
  %arrayidx73 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %46, i64 %idxprom72
  %spilled_ptr74 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx73, i32 0, i32 0
  %48 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %call75 = call zeroext i1 @regsafe(%struct.bpf_verifier_env* noundef %41, %struct.bpf_reg_state* noundef %spilled_ptr70, %struct.bpf_reg_state* noundef %spilled_ptr74, %struct.bpf_id_pair* noundef %48) #20
  br i1 %call75, label %if.end77, label %if.then76

if.then76:                                        ; preds = %if.end66
  store i1 false, i1* %retval, align 1
  br label %return

if.end77:                                         ; preds = %if.end66
  br label %for.inc

for.inc:                                          ; preds = %if.end77, %if.then65, %if.then60, %if.then35, %if.then8, %if.then
  %49 = load i32, i32* %i, align 4
  %inc = add i32 %49, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !137

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then76, %if.then55, %if.then13
  %50 = load i1, i1* %retval, align 1
  ret i1 %50
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @refsafe(%struct.bpf_func_state* noundef %old, %struct.bpf_func_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %old.addr = alloca %struct.bpf_func_state*, align 8
  %cur.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_func_state* %old, %struct.bpf_func_state** %old.addr, align 8
  store %struct.bpf_func_state* %cur, %struct.bpf_func_state** %cur.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 8
  %1 = load i32, i32* %acquired_refs, align 4
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 8
  %3 = load i32, i32* %acquired_refs1, align 4
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 9
  %5 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %6 = bitcast %struct.bpf_reference_state* %5 to i8*
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %refs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 9
  %8 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs2, align 8
  %9 = bitcast %struct.bpf_reference_state* %8 to i8*
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %acquired_refs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 8
  %11 = load i32, i32* %acquired_refs3, align 4
  %conv = sext i32 %11 to i64
  %mul = mul i64 12, %conv
  %call = call i32 @memcmp(i8* noundef %6, i8* noundef %9, i64 noundef %mul) #20
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i1, i1* %retval, align 1
  ret i1 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @range_within(%struct.bpf_reg_state* noundef %old, %struct.bpf_reg_state* noundef %cur) #0 {
entry:
  %old.addr = alloca %struct.bpf_reg_state*, align 8
  %cur.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %old, %struct.bpf_reg_state** %old.addr, align 8
  store %struct.bpf_reg_state* %cur, %struct.bpf_reg_state** %cur.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 8
  %1 = load i64, i64* %umin_value, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %umin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value1, align 8
  %cmp = icmp ule i64 %1, %3
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 9
  %5 = load i64, i64* %umax_value, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %umax_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 9
  %7 = load i64, i64* %umax_value2, align 8
  %cmp3 = icmp uge i64 %5, %7
  br i1 %cmp3, label %land.lhs.true4, label %land.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  %11 = load i64, i64* %smin_value5, align 8
  %cmp6 = icmp sle i64 %9, %11
  br i1 %cmp6, label %land.lhs.true7, label %land.end

land.lhs.true7:                                   ; preds = %land.lhs.true4
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %smax_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 7
  %15 = load i64, i64* %smax_value8, align 8
  %cmp9 = icmp sge i64 %13, %15
  br i1 %cmp9, label %land.lhs.true10, label %land.end

land.lhs.true10:                                  ; preds = %land.lhs.true7
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 12
  %17 = load i32, i32* %u32_min_value, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %u32_min_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 12
  %19 = load i32, i32* %u32_min_value11, align 8
  %cmp12 = icmp ule i32 %17, %19
  br i1 %cmp12, label %land.lhs.true13, label %land.end

land.lhs.true13:                                  ; preds = %land.lhs.true10
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 13
  %21 = load i32, i32* %u32_max_value, align 4
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %u32_max_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 13
  %23 = load i32, i32* %u32_max_value14, align 4
  %cmp15 = icmp uge i32 %21, %23
  br i1 %cmp15, label %land.lhs.true16, label %land.end

land.lhs.true16:                                  ; preds = %land.lhs.true13
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 10
  %25 = load i32, i32* %s32_min_value, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %s32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 10
  %27 = load i32, i32* %s32_min_value17, align 8
  %cmp18 = icmp sle i32 %25, %27
  br i1 %cmp18, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true16
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 11
  %29 = load i32, i32* %s32_max_value, align 4
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %s32_max_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 11
  %31 = load i32, i32* %s32_max_value19, align 4
  %cmp20 = icmp sge i32 %29, %31
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true16, %land.lhs.true13, %land.lhs.true10, %land.lhs.true7, %land.lhs.true4, %land.lhs.true, %entry
  %32 = phi i1 [ false, %land.lhs.true16 ], [ false, %land.lhs.true13 ], [ false, %land.lhs.true10 ], [ false, %land.lhs.true7 ], [ false, %land.lhs.true4 ], [ false, %land.lhs.true ], [ false, %entry ], [ %cmp20, %land.rhs ]
  ret i1 %32
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @tnum_in(i64, i64, i64, i64) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_ids(i32 noundef %old_id, i32 noundef %cur_id, %struct.bpf_id_pair* noundef %idmap) #0 {
entry:
  %retval = alloca i1, align 1
  %old_id.addr = alloca i32, align 4
  %cur_id.addr = alloca i32, align 4
  %idmap.addr = alloca %struct.bpf_id_pair*, align 8
  %i = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp = alloca i64, align 8
  store i32 %old_id, i32* %old_id.addr, align 4
  store i32 %cur_id, i32* %cur_id.addr, align 4
  store %struct.bpf_id_pair* %idmap, %struct.bpf_id_pair** %idmap.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp ult i32 %0, 75
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %2 = load i32, i32* %i, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_id_pair, %struct.bpf_id_pair* %1, i64 %idxprom
  %old = getelementptr inbounds %struct.bpf_id_pair, %struct.bpf_id_pair* %arrayidx, i32 0, i32 0
  %3 = load i32, i32* %old, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %4 = load i32, i32* %old_id.addr, align 4
  %5 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom1 = zext i32 %6 to i64
  %arrayidx2 = getelementptr %struct.bpf_id_pair, %struct.bpf_id_pair* %5, i64 %idxprom1
  %old3 = getelementptr inbounds %struct.bpf_id_pair, %struct.bpf_id_pair* %arrayidx2, i32 0, i32 0
  store i32 %4, i32* %old3, align 4
  %7 = load i32, i32* %cur_id.addr, align 4
  %8 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %9 = load i32, i32* %i, align 4
  %idxprom4 = zext i32 %9 to i64
  %arrayidx5 = getelementptr %struct.bpf_id_pair, %struct.bpf_id_pair* %8, i64 %idxprom4
  %cur = getelementptr inbounds %struct.bpf_id_pair, %struct.bpf_id_pair* %arrayidx5, i32 0, i32 1
  store i32 %7, i32* %cur, align 4
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  %10 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %11 = load i32, i32* %i, align 4
  %idxprom6 = zext i32 %11 to i64
  %arrayidx7 = getelementptr %struct.bpf_id_pair, %struct.bpf_id_pair* %10, i64 %idxprom6
  %old8 = getelementptr inbounds %struct.bpf_id_pair, %struct.bpf_id_pair* %arrayidx7, i32 0, i32 0
  %12 = load i32, i32* %old8, align 4
  %13 = load i32, i32* %old_id.addr, align 4
  %cmp9 = icmp eq i32 %12, %13
  br i1 %cmp9, label %if.then10, label %if.end15

if.then10:                                        ; preds = %if.end
  %14 = load %struct.bpf_id_pair*, %struct.bpf_id_pair** %idmap.addr, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom11 = zext i32 %15 to i64
  %arrayidx12 = getelementptr %struct.bpf_id_pair, %struct.bpf_id_pair* %14, i64 %idxprom11
  %cur13 = getelementptr inbounds %struct.bpf_id_pair, %struct.bpf_id_pair* %arrayidx12, i32 0, i32 1
  %16 = load i32, i32* %cur13, align 4
  %17 = load i32, i32* %cur_id.addr, align 4
  %cmp14 = icmp eq i32 %16, %17
  store i1 %cmp14, i1* %retval, align 1
  br label %return

if.end15:                                         ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end15
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !138

for.end:                                          ; preds = %for.cond
  store i32 1, i32* %__ret_warn_on, align 4
  %19 = load i32, i32* %__ret_warn_on, align 4
  %tobool16 = icmp ne i32 %19, 0
  %lnot = xor i1 %tobool16, true
  %lnot17 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot17 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool18 = icmp ne i64 %conv, 0
  br i1 %tobool18, label %if.then19, label %if.end26

if.then19:                                        ; preds = %for.end
  br label %do.body

do.body:                                          ; preds = %if.then19
  store i32 2307, i32* %__flags, align 4
  br label %do.body20

do.body20:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body20
  br label %do.body21

do.body21:                                        ; preds = %do.end
  %20 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 13339, i32 %20, i64 12) #19, !srcloc !139
  br label %do.end22

do.end22:                                         ; preds = %do.body21
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  br label %do.end24

do.end24:                                         ; preds = %do.body23
  br label %do.end25

do.end25:                                         ; preds = %do.end24
  br label %if.end26

if.end26:                                         ; preds = %do.end25, %for.end
  %21 = load i32, i32* %__ret_warn_on, align 4
  %tobool27 = icmp ne i32 %21, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  store i64 %conv32, i64* %tmp, align 8
  %22 = load i64, i64* %tmp, align 8
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end26, %if.then10, %if.then
  %23 = load i1, i1* %retval, align 1
  ret i1 %23
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @propagate_liveness_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, %struct.bpf_reg_state* noundef %parent_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %parent_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %parent_flag = alloca i8, align 1
  %flag = alloca i8, align 1
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store %struct.bpf_reg_state* %parent_reg, %struct.bpf_reg_state** %parent_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg.addr, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 17
  %1 = load i32, i32* %live, align 8
  %and = and i32 %1, 3
  %conv = trunc i32 %and to i8
  store i8 %conv, i8* %parent_flag, align 1
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %live1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 17
  %3 = load i32, i32* %live1, align 8
  %and2 = and i32 %3, 3
  %conv3 = trunc i32 %and2 to i8
  store i8 %conv3, i8* %flag, align 1
  %4 = load i8, i8* %parent_flag, align 1
  %conv4 = zext i8 %4 to i32
  %cmp = icmp eq i32 %conv4, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i8, i8* %flag, align 1
  %tobool = icmp ne i8 %5, 0
  br i1 %tobool, label %lor.lhs.false6, label %if.then

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %6 = load i8, i8* %parent_flag, align 1
  %conv7 = zext i8 %6 to i32
  %7 = load i8, i8* %flag, align 1
  %conv8 = zext i8 %7 to i32
  %cmp9 = icmp eq i32 %conv7, %conv8
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false6, %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false6
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg.addr, align 8
  %11 = load i8, i8* %flag, align 1
  %call = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %9, %struct.bpf_reg_state* noundef %10, i8 noundef zeroext %11) #20
  store i32 %call, i32* %err, align 4
  %12 = load i32, i32* %err, align 4
  %tobool11 = icmp ne i32 %12, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  %13 = load i32, i32* %err, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end
  %14 = load i8, i8* %flag, align 1
  %conv14 = zext i8 %14 to i32
  store i32 %conv14, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then12, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_insn_zext(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %def_idx = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 16
  %1 = load i32, i32* %subreg_def, align 4
  store i32 %1, i32* %def_idx, align 4
  %2 = load i32, i32* %def_idx, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 24
  %4 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %5 = load i32, i32* %def_idx, align 4
  %sub = sub i32 %5, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %4, i64 %idxprom
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 5
  store i8 1, i8* %zext_dst, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %subreg_def1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 16
  store i32 0, i32* %subreg_def1, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @mark_chain_precision_stack(%struct.bpf_verifier_env* noundef %env, i32 noundef %spi) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %spi.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %spi, i32* %spi.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %spi.addr, align 4
  %call = call i32 @__mark_chain_precision(%struct.bpf_verifier_env* noundef %0, i32 noundef -1, i32 noundef %1) #20
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @copy_array(i8* noundef %dst, i8* noundef %src, i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %retval = alloca i8*, align 8
  %dst.addr = alloca i8*, align 8
  %src.addr = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca i64, align 8
  store i8* %dst, i8** %dst.addr, align 8
  store i8* %src, i8** %src.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i8*, i8** %src.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  %cmp = icmp ule i64 %1, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %out

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %n.addr, align 8
  %3 = load i64, i64* %size.addr, align 8
  %4 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %2, i64 %3)
  %5 = extractvalue { i64, i1 } %4, 1
  %6 = extractvalue { i64, i1 } %4, 0
  store i64 %6, i64* %bytes, align 8
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %5) #20
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i8* null, i8** %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %7 = load i8*, i8** %dst.addr, align 8
  %call4 = call i64 @ksize(i8* noundef %7) #20
  %8 = load i64, i64* %bytes, align 8
  %cmp5 = icmp ult i64 %call4, %8
  br i1 %cmp5, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end3
  %9 = load i8*, i8** %dst.addr, align 8
  call void @kfree(i8* noundef %9) #20
  %10 = load i64, i64* %bytes, align 8
  %11 = load i32, i32* %flags.addr, align 4
  %12 = call i8* @llvm.returnaddress(i32 0)
  %13 = ptrtoint i8* %12 to i64
  %call8 = call noalias i8* @__kmalloc_node_track_caller(i64 noundef %10, i32 noundef %11, i32 noundef -1, i64 noundef %13) #24
  store i8* %call8, i8** %dst.addr, align 8
  %14 = load i8*, i8** %dst.addr, align 8
  %tobool9 = icmp ne i8* %14, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.then7
  store i8* null, i8** %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.then7
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end3
  %15 = load i8*, i8** %dst.addr, align 8
  %16 = load i8*, i8** %src.addr, align 8
  %17 = load i64, i64* %bytes, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %15, i8* align 1 %16, i64 %17, i1 false)
  br label %out

out:                                              ; preds = %if.end12, %if.then
  %18 = load i8*, i8** %dst.addr, align 8
  %tobool13 = icmp ne i8* %18, null
  br i1 %tobool13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %out
  %19 = load i8*, i8** %dst.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %out
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %19, %cond.true ], [ inttoptr (i64 16 to i8*), %cond.false ]
  store i8* %cond, i8** %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.then10, %if.then2
  %20 = load i8*, i8** %retval, align 8
  ret i8* %20
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @free_func_state(%struct.bpf_func_state* noundef %state) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %tobool = icmp ne %struct.bpf_func_state* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 9
  %2 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %3 = bitcast %struct.bpf_reference_state* %2 to i8*
  call void @kfree(i8* noundef %3) #20
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 11
  %5 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %6 = bitcast %struct.bpf_stack_state* %5 to i8*
  call void @kfree(i8* noundef %6) #20
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %8 = bitcast %struct.bpf_func_state* %7 to i8*
  call void @kfree(i8* noundef %8) #20
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_func_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %1 = bitcast %struct.bpf_func_state* %0 to i8*
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %3 = bitcast %struct.bpf_func_state* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %1, i8* align 8 %3, i64 1364, i1 false)
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %call = call i32 @copy_reference_state(%struct.bpf_func_state* noundef %4, %struct.bpf_func_state* noundef %5) #20
  store i32 %call, i32* %err, align 4
  %6 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load i32, i32* %err, align 4
  store i32 %7, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %call1 = call i32 @copy_stack_state(%struct.bpf_func_state* noundef %8, %struct.bpf_func_state* noundef %9) #20
  store i32 %call1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @ksize(i8* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid allocsize(0)
declare dso_local noalias i8* @__kmalloc_node_track_caller(i64 noundef, i32 noundef, i32 noundef, i64 noundef) #7

; Function Attrs: nofree nosync nounwind readnone willreturn
declare i8* @llvm.returnaddress(i32 immarg) #17

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_reference_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 9
  %1 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %2 = bitcast %struct.bpf_reference_state* %1 to i8*
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 9
  %4 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs1, align 8
  %5 = bitcast %struct.bpf_reference_state* %4 to i8*
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 8
  %7 = load i32, i32* %acquired_refs, align 4
  %conv = sext i32 %7 to i64
  %call = call i8* @copy_array(i8* noundef %2, i8* noundef %5, i64 noundef %conv, i64 noundef 12, i32 noundef 3264) #20
  %8 = bitcast i8* %call to %struct.bpf_reference_state*
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %refs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 9
  store %struct.bpf_reference_state* %8, %struct.bpf_reference_state** %refs2, align 8
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %refs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 9
  %11 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs3, align 8
  %tobool = icmp ne %struct.bpf_reference_state* %11, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %acquired_refs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 8
  %13 = load i32, i32* %acquired_refs4, align 4
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %acquired_refs5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 8
  store i32 %13, i32* %acquired_refs5, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_stack_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  %n = alloca i64, align 8
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 10
  %1 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %1, 8
  %conv = sext i32 %div to i64
  store i64 %conv, i64* %n, align 8
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 11
  %3 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %4 = bitcast %struct.bpf_stack_state* %3 to i8*
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %stack1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 11
  %6 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack1, align 8
  %7 = bitcast %struct.bpf_stack_state* %6 to i8*
  %8 = load i64, i64* %n, align 8
  %call = call i8* @copy_array(i8* noundef %4, i8* noundef %7, i64 noundef %8, i64 noundef 128, i32 noundef 3264) #20
  %9 = bitcast i8* %call to %struct.bpf_stack_state*
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %stack2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 11
  store %struct.bpf_stack_state* %9, %struct.bpf_stack_state** %stack2, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %stack3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 11
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack3, align 8
  %tobool = icmp ne %struct.bpf_stack_state* %12, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %allocated_stack4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 10
  %14 = load i32, i32* %allocated_stack4, align 8
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %allocated_stack5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 10
  store i32 %14, i32* %allocated_stack5, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %16 = load i32, i32* %retval, align 4
  ret i32 %16
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @test_tsk_thread_flag(%struct.task_struct* noundef %tsk, i32 noundef %flag) #0 {
entry:
  %tsk.addr = alloca %struct.task_struct*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.task_struct* %tsk, %struct.task_struct** %tsk.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load %struct.task_struct*, %struct.task_struct** %tsk.addr, align 8
  %thread_info = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 0
  %1 = load i32, i32* %flag.addr, align 4
  %call = call i32 @test_ti_thread_flag(%struct.thread_info* noundef %thread_info, i32 noundef %1) #20
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @task_sigpending(%struct.task_struct* noundef %p) #0 {
entry:
  %p.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %p, %struct.task_struct** %p.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %p.addr, align 8
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* noundef %0, i32 noundef 2) #20
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %conv2 = trunc i64 %conv to i32
  ret i32 %conv2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @test_ti_thread_flag(%struct.thread_info* noundef %ti, i32 noundef %flag) #0 {
entry:
  %nr.addr.i28 = alloca i64, align 8
  %addr.addr.i29 = alloca i64*, align 8
  %oldbit.i = alloca i8, align 1
  %nr.addr.i24 = alloca i64, align 8
  %addr.addr.i25 = alloca i64*, align 8
  %nr.addr.i19 = alloca i64, align 8
  %addr.addr.i20 = alloca i64*, align 8
  %v.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %nr.addr.i14 = alloca i64, align 8
  %addr.addr.i15 = alloca i64*, align 8
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %p.i = alloca i64*, align 8
  %mask.i = alloca i64, align 8
  %val.i = alloca i64, align 8
  %ti.addr = alloca %struct.thread_info*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.thread_info* %ti, %struct.thread_info** %ti.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load i32, i32* %flag.addr, align 4
  %1 = call i1 @llvm.is.constant.i32(i32 %0)
  br i1 %1, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.thread_info*, %struct.thread_info** %ti.addr, align 8
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %2, i32 0, i32 0
  %3 = ptrtoint i64* %flags to i64
  %cmp = icmp ne i64 %3, 0
  %conv = zext i1 %cmp to i32
  %4 = call i1 @llvm.is.constant.i32(i32 %conv)
  br i1 %4, label %land.lhs.true1, label %cond.false

land.lhs.true1:                                   ; preds = %land.lhs.true
  %5 = load %struct.thread_info*, %struct.thread_info** %ti.addr, align 8
  %flags2 = getelementptr inbounds %struct.thread_info, %struct.thread_info* %5, i32 0, i32 0
  %6 = ptrtoint i64* %flags2 to i64
  %cmp3 = icmp ne i64 %6, 0
  br i1 %cmp3, label %land.lhs.true5, label %cond.false

land.lhs.true5:                                   ; preds = %land.lhs.true1
  %7 = load %struct.thread_info*, %struct.thread_info** %ti.addr, align 8
  %flags6 = getelementptr inbounds %struct.thread_info, %struct.thread_info* %7, i32 0, i32 0
  %8 = load i64, i64* %flags6, align 8
  %9 = call i1 @llvm.is.constant.i64(i64 %8)
  br i1 %9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true5
  %10 = load i32, i32* %flag.addr, align 4
  %conv7 = sext i32 %10 to i64
  %11 = load %struct.thread_info*, %struct.thread_info** %ti.addr, align 8
  %flags8 = getelementptr inbounds %struct.thread_info, %struct.thread_info* %11, i32 0, i32 0
  store i64 %conv7, i64* %nr.addr.i, align 8
  store i64* %flags8, i64** %addr.addr.i, align 8
  %12 = load i64*, i64** %addr.addr.i, align 8
  %13 = load i64, i64* %nr.addr.i, align 8
  %div.i = udiv i64 %13, 64
  %add.ptr.i = getelementptr i64, i64* %12, i64 %div.i
  store i64* %add.ptr.i, i64** %p.i, align 8
  %14 = load i64, i64* %nr.addr.i, align 8
  %rem.i = urem i64 %14, 64
  %shl.i = shl i64 1, %rem.i
  store i64 %shl.i, i64* %mask.i, align 8
  %15 = load i64*, i64** %p.i, align 8
  %16 = load i64, i64* %15, align 8
  store i64 %16, i64* %val.i, align 8
  %17 = load i64, i64* %val.i, align 8
  %18 = load i64, i64* %mask.i, align 8
  %and.i = and i64 %17, %18
  %tobool.i = icmp ne i64 %and.i, 0
  %lnot.i = xor i1 %tobool.i, true
  %conv9 = zext i1 %tobool.i to i32
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true5, %land.lhs.true1, %land.lhs.true, %entry
  %19 = load i32, i32* %flag.addr, align 4
  %conv10 = sext i32 %19 to i64
  %20 = load %struct.thread_info*, %struct.thread_info** %ti.addr, align 8
  %flags11 = getelementptr inbounds %struct.thread_info, %struct.thread_info* %20, i32 0, i32 0
  store i64 %conv10, i64* %nr.addr.i14, align 8
  store i64* %flags11, i64** %addr.addr.i15, align 8
  %21 = load i64*, i64** %addr.addr.i15, align 8
  %22 = load i64, i64* %nr.addr.i14, align 8
  %div.i16 = udiv i64 %22, 64
  %add.ptr.i17 = getelementptr i64, i64* %21, i64 %div.i16
  %23 = bitcast i64* %add.ptr.i17 to i8*
  store i8* %23, i8** %v.addr.i, align 8
  store i64 8, i64* %size.addr.i, align 8
  %24 = load i8*, i8** %v.addr.i, align 8
  %25 = load i64, i64* %size.addr.i, align 8
  %conv.i = trunc i64 %25 to i32
  %call.i18 = call zeroext i1 @kasan_check_read(i8* noundef %24, i32 noundef %conv.i) #22
  %26 = load i8*, i8** %v.addr.i, align 8
  %27 = load i64, i64* %size.addr.i, align 8
  call void @kcsan_check_access(i8* noundef %26, i64 noundef %27, i32 noundef 4) #22
  %28 = load i64, i64* %nr.addr.i14, align 8
  %29 = load i64*, i64** %addr.addr.i15, align 8
  store i64 %28, i64* %nr.addr.i19, align 8
  store i64* %29, i64** %addr.addr.i20, align 8
  %30 = load i64, i64* %nr.addr.i19, align 8
  %31 = call i1 @llvm.is.constant.i64(i64 %30) #19
  br i1 %31, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %cond.false
  %32 = load i64, i64* %nr.addr.i19, align 8
  %33 = load i64*, i64** %addr.addr.i20, align 8
  store i64 %32, i64* %nr.addr.i24, align 8
  store i64* %33, i64** %addr.addr.i25, align 8
  %34 = load i64, i64* %nr.addr.i24, align 8
  %and.i26 = and i64 %34, 63
  %shl.i27 = shl i64 1, %and.i26
  %35 = load i64*, i64** %addr.addr.i25, align 8
  %36 = load i64, i64* %nr.addr.i24, align 8
  %shr.i = ashr i64 %36, 6
  %arrayidx.i = getelementptr i64, i64* %35, i64 %shr.i
  %37 = load volatile i64, i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i27, %37
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i22 = zext i1 %cmp.i to i32
  br label %arch_test_bit.exit

cond.false.i:                                     ; preds = %cond.false
  %38 = load i64, i64* %nr.addr.i19, align 8
  %39 = load i64*, i64** %addr.addr.i20, align 8
  store i64 %38, i64* %nr.addr.i28, align 8
  store i64* %39, i64** %addr.addr.i29, align 8
  %40 = load i64*, i64** %addr.addr.i29, align 8
  %41 = load i64, i64* %nr.addr.i28, align 8
  %42 = call i8 asm sideeffect " btq  $2,$1\0A\09/* output condition code c*/\0A", "={@ccc},*m,Ir,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* elementtype(i64) %40, i64 %41) #19, !srcloc !140
  store i8 %42, i8* %oldbit.i, align 1
  %43 = load i8, i8* %oldbit.i, align 1
  %tobool.i30 = trunc i8 %43 to i1
  %conv2.i = zext i1 %tobool.i30 to i32
  br label %arch_test_bit.exit

arch_test_bit.exit:                               ; preds = %cond.true.i, %cond.false.i
  %cond.i = phi i32 [ %conv.i22, %cond.true.i ], [ %conv2.i, %cond.false.i ]
  %tobool.i23 = icmp ne i32 %cond.i, 0
  %conv13 = zext i1 %tobool.i23 to i32
  br label %cond.end

cond.end:                                         ; preds = %arch_test_bit.exit, %cond.true
  %cond = phi i32 [ %conv9, %cond.true ], [ %conv13, %arch_test_bit.exit ]
  ret i32 %cond
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @kasan_check_read(i8* noundef %p, i32 noundef %size) #0 {
entry:
  %p.addr = alloca i8*, align 8
  %size.addr = alloca i32, align 4
  store i8* %p, i8** %p.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  ret i1 true
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @kcsan_check_access(i8* noundef %ptr, i64 noundef %size, i32 noundef %type) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %type.addr = alloca i32, align 4
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @__SCT__cond_resched() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @vlog_alignment(i32 noundef %pos) #0 {
entry:
  %pos.addr = alloca i32, align 4
  %__UNIQUE_ID___x525 = alloca i32, align 4
  %__UNIQUE_ID___y526 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store i32 %pos, i32* %pos.addr, align 4
  %0 = load i32, i32* %pos.addr, align 4
  %add = add i32 %0, 4
  store i32 %add, i32* %__UNIQUE_ID___x525, align 4
  store i32 40, i32* %__UNIQUE_ID___y526, align 4
  %1 = load i32, i32* %__UNIQUE_ID___x525, align 4
  %2 = load i32, i32* %__UNIQUE_ID___y526, align 4
  %cmp = icmp ugt i32 %1, %2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, i32* %__UNIQUE_ID___x525, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, i32* %__UNIQUE_ID___y526, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ %4, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %5 = load i32, i32* %tmp, align 4
  %sub = sub i32 %5, 1
  %or = or i32 %sub, 7
  %add1 = add i32 %or, 1
  %6 = load i32, i32* %pos.addr, align 4
  %sub2 = sub i32 %add1, %6
  %sub3 = sub i32 %sub2, 1
  ret i32 %sub3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_reg_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %src_reg = alloca %struct.bpf_reg_state*, align 8
  %ptr_reg = alloca %struct.bpf_reg_state*, align 8
  %off_reg = alloca %struct.bpf_reg_state, align 8
  %opcode = alloca i8, align 1
  %err = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_warn_on99 = alloca i32, align 4
  %__flags116 = alloca i32, align 4
  %tmp125 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %ptr_reg, align 8
  %7 = bitcast %struct.bpf_reg_state* %off_reg to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %7, i8 0, i64 120, i1 false)
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 0
  %9 = load i8, i8* %code, align 4
  %conv = zext i8 %9 to i32
  %and = and i32 %conv, 240
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %opcode, align 1
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg3 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg3, align 1
  %bf.clear = and i8 %bf.load, 15
  %idxprom4 = zext i8 %bf.clear to i64
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i64 %idxprom4
  store %struct.bpf_reg_state* %arrayidx5, %struct.bpf_reg_state** %dst_reg, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %src_reg, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 0
  %13 = load i32, i32* %type, align 8
  %cmp = icmp ne i32 %13, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  store %struct.bpf_reg_state* %14, %struct.bpf_reg_state** %ptr_reg, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 3
  store i32 0, i32* %id, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 0
  %17 = load i8, i8* %code7, align 4
  %conv8 = zext i8 %17 to i32
  %and9 = and i32 %conv8, 8
  %cmp10 = icmp eq i32 %and9, 8
  br i1 %cmp10, label %if.then12, label %if.else65

if.then12:                                        ; preds = %if.end
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %19, i32 0, i32 1
  %bf.load14 = load i8, i8* %src_reg13, align 1
  %bf.lshr = lshr i8 %bf.load14, 4
  %idxprom15 = zext i8 %bf.lshr to i64
  %arrayidx16 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i64 %idxprom15
  store %struct.bpf_reg_state* %arrayidx16, %struct.bpf_reg_state** %src_reg, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %type17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 0
  %21 = load i32, i32* %type17, align 8
  %cmp18 = icmp ne i32 %21, 1
  br i1 %cmp18, label %if.then20, label %if.else51

if.then20:                                        ; preds = %if.then12
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 0
  %23 = load i32, i32* %type21, align 8
  %cmp22 = icmp ne i32 %23, 1
  br i1 %cmp22, label %if.then24, label %if.else42

if.then24:                                        ; preds = %if.then20
  %24 = load i8, i8* %opcode, align 1
  %conv25 = zext i8 %24 to i32
  %cmp26 = icmp eq i32 %conv25, 16
  br i1 %cmp26, label %land.lhs.true, label %if.end34

land.lhs.true:                                    ; preds = %if.then24
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 17
  %26 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool = trunc i8 %26 to i1
  br i1 %tobool, label %if.then29, label %if.end34

if.then29:                                        ; preds = %land.lhs.true
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg30 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load31 = load i8, i8* %dst_reg30, align 1
  %bf.clear32 = and i8 %bf.load31, 15
  %conv33 = zext i8 %bf.clear32 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %27, %struct.bpf_reg_state* noundef %28, i32 noundef %conv33) #20
  store i32 0, i32* %retval, align 4
  br label %return

if.end34:                                         ; preds = %land.lhs.true, %if.then24
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %32, i32 0, i32 1
  %bf.load36 = load i8, i8* %dst_reg35, align 1
  %bf.clear37 = and i8 %bf.load36, 15
  %conv38 = zext i8 %bf.clear37 to i32
  %33 = load i8, i8* %opcode, align 1
  %conv39 = zext i8 %33 to i32
  %shr = ashr i32 %conv39, 4
  %idxprom40 = sext i32 %shr to i64
  %arrayidx41 = getelementptr [16 x i8*], [16 x i8*]* @bpf_alu_string, i64 0, i64 %idxprom40
  %34 = load i8*, i8** %arrayidx41, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.326, i64 0, i64 0), i32 noundef %conv38, i8* noundef %34) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.else42:                                        ; preds = %if.then20
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %36, i32 0, i32 1
  %bf.load44 = load i8, i8* %dst_reg43, align 1
  %bf.clear45 = and i8 %bf.load44, 15
  %conv46 = zext i8 %bf.clear45 to i32
  %call = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %35, i32 noundef %conv46) #20
  store i32 %call, i32* %err, align 4
  %37 = load i32, i32* %err, align 4
  %tobool47 = icmp ne i32 %37, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.else42
  %38 = load i32, i32* %err, align 4
  store i32 %38, i32* %retval, align 4
  br label %return

if.end49:                                         ; preds = %if.else42
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call50 = call i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %39, %struct.bpf_insn* noundef %40, %struct.bpf_reg_state* noundef %41, %struct.bpf_reg_state* noundef %42) #20
  store i32 %call50, i32* %retval, align 4
  br label %return

if.else51:                                        ; preds = %if.then12
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %tobool52 = icmp ne %struct.bpf_reg_state* %43, null
  br i1 %tobool52, label %if.then53, label %if.end63

if.then53:                                        ; preds = %if.else51
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg54 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %45, i32 0, i32 1
  %bf.load55 = load i8, i8* %src_reg54, align 1
  %bf.lshr56 = lshr i8 %bf.load55, 4
  %conv57 = zext i8 %bf.lshr56 to i32
  %call58 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %44, i32 noundef %conv57) #20
  store i32 %call58, i32* %err, align 4
  %46 = load i32, i32* %err, align 4
  %tobool59 = icmp ne i32 %46, 0
  br i1 %tobool59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.then53
  %47 = load i32, i32* %err, align 4
  store i32 %47, i32* %retval, align 4
  br label %return

if.end61:                                         ; preds = %if.then53
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call62 = call i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %48, %struct.bpf_insn* noundef %49, %struct.bpf_reg_state* noundef %50, %struct.bpf_reg_state* noundef %51) #20
  store i32 %call62, i32* %retval, align 4
  br label %return

if.end63:                                         ; preds = %if.else51
  br label %if.end64

if.end64:                                         ; preds = %if.end63
  br label %if.end72

if.else65:                                        ; preds = %if.end
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %off_reg, i32 0, i32 0
  store i32 1, i32* %type66, align 8
  %52 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %52, i32 0, i32 3
  %53 = load i32, i32* %imm, align 4
  %conv67 = sext i32 %53 to i64
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %off_reg, i64 noundef %conv67) #20
  store %struct.bpf_reg_state* %off_reg, %struct.bpf_reg_state** %src_reg, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %tobool68 = icmp ne %struct.bpf_reg_state* %54, null
  br i1 %tobool68, label %if.then69, label %if.end71

if.then69:                                        ; preds = %if.else65
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call70 = call i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %55, %struct.bpf_insn* noundef %56, %struct.bpf_reg_state* noundef %57, %struct.bpf_reg_state* noundef %58) #20
  store i32 %call70, i32* %retval, align 4
  br label %return

if.end71:                                         ; preds = %if.else65
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %if.end64
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %tobool73 = icmp ne %struct.bpf_reg_state* %59, null
  %lnot = xor i1 %tobool73, true
  %lnot74 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot74 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %60 = load i32, i32* %__ret_warn_on, align 4
  %tobool75 = icmp ne i32 %60, 0
  %lnot76 = xor i1 %tobool75, true
  %lnot78 = xor i1 %lnot76, true
  %lnot.ext79 = zext i1 %lnot78 to i32
  %conv80 = sext i32 %lnot.ext79 to i64
  %tobool81 = icmp ne i64 %conv80, 0
  br i1 %tobool81, label %if.then82, label %if.end89

if.then82:                                        ; preds = %if.end72
  br label %do.body

do.body:                                          ; preds = %if.then82
  store i32 2307, i32* %__flags, align 4
  br label %do.body83

do.body83:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body83
  br label %do.body84

do.body84:                                        ; preds = %do.end
  %61 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 9535, i32 %61, i64 12) #19, !srcloc !141
  br label %do.end85

do.end85:                                         ; preds = %do.body84
  br label %do.body86

do.body86:                                        ; preds = %do.end85
  br label %do.end87

do.end87:                                         ; preds = %do.body86
  br label %do.end88

do.end88:                                         ; preds = %do.end87
  br label %if.end89

if.end89:                                         ; preds = %do.end88, %if.end72
  %62 = load i32, i32* %__ret_warn_on, align 4
  %tobool90 = icmp ne i32 %62, 0
  %lnot91 = xor i1 %tobool90, true
  %lnot93 = xor i1 %lnot91, true
  %lnot.ext94 = zext i1 %lnot93 to i32
  %conv95 = sext i32 %lnot.ext94 to i64
  store i64 %conv95, i64* %tmp, align 8
  %63 = load i64, i64* %tmp, align 8
  %tobool96 = icmp ne i64 %63, 0
  br i1 %tobool96, label %if.then97, label %if.end98

if.then97:                                        ; preds = %if.end89
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %64, %struct.bpf_func_state* noundef %65, i1 noundef zeroext true) #20
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = bitcast %struct.bpf_verifier_env* %66 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %67, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.327, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end98:                                         ; preds = %if.end89
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %tobool100 = icmp ne %struct.bpf_reg_state* %68, null
  %lnot101 = xor i1 %tobool100, true
  %lnot103 = xor i1 %lnot101, true
  %lnot105 = xor i1 %lnot103, true
  %lnot.ext106 = zext i1 %lnot105 to i32
  store i32 %lnot.ext106, i32* %__ret_warn_on99, align 4
  %69 = load i32, i32* %__ret_warn_on99, align 4
  %tobool107 = icmp ne i32 %69, 0
  %lnot108 = xor i1 %tobool107, true
  %lnot110 = xor i1 %lnot108, true
  %lnot.ext111 = zext i1 %lnot110 to i32
  %conv112 = sext i32 %lnot.ext111 to i64
  %tobool113 = icmp ne i64 %conv112, 0
  br i1 %tobool113, label %if.then114, label %if.end124

if.then114:                                       ; preds = %if.end98
  br label %do.body115

do.body115:                                       ; preds = %if.then114
  store i32 2305, i32* %__flags116, align 4
  br label %do.body117

do.body117:                                       ; preds = %do.body115
  br label %do.end118

do.end118:                                        ; preds = %do.body117
  br label %do.body119

do.body119:                                       ; preds = %do.end118
  %70 = load i32, i32* %__flags116, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 9540, i32 %70, i64 12) #19, !srcloc !142
  br label %do.end120

do.end120:                                        ; preds = %do.body119
  br label %do.body121

do.body121:                                       ; preds = %do.end120
  br label %do.end122

do.end122:                                        ; preds = %do.body121
  br label %do.end123

do.end123:                                        ; preds = %do.end122
  br label %if.end124

if.end124:                                        ; preds = %do.end123, %if.end98
  %71 = load i32, i32* %__ret_warn_on99, align 4
  %tobool126 = icmp ne i32 %71, 0
  %lnot127 = xor i1 %tobool126, true
  %lnot129 = xor i1 %lnot127, true
  %lnot.ext130 = zext i1 %lnot129 to i32
  %conv131 = sext i32 %lnot.ext130 to i64
  store i64 %conv131, i64* %tmp125, align 8
  %72 = load i64, i64* %tmp125, align 8
  %tobool132 = icmp ne i64 %72, 0
  br i1 %tobool132, label %if.then133, label %if.end134

if.then133:                                       ; preds = %if.end124
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %74 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %73, %struct.bpf_func_state* noundef %74, i1 noundef zeroext true) #20
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = bitcast %struct.bpf_verifier_env* %75 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %76, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.328, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end134:                                        ; preds = %if.end124
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %78 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call135 = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %77, %struct.bpf_insn* noundef %78, %struct.bpf_reg_state* noundef %79, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %80) #20
  store i32 %call135, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end134, %if.then133, %if.then97, %if.then69, %if.end61, %if.then60, %if.end49, %if.then48, %if.end34, %if.then29
  %81 = load i32, i32* %retval, align 4
  ret i32 %81
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %ptr_reg, %struct.bpf_reg_state* noundef %off_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %ptr_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %smin_ptr = alloca i64, align 8
  %smax_ptr = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  %umin_ptr = alloca i64, align 8
  %umax_ptr = alloca i64, align 8
  %info = alloca %struct.bpf_sanitize_info, align 8
  %opcode = alloca i8, align 1
  %dst = alloca i32, align 4
  %ret = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  %tmp211 = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %ptr_reg, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  store %struct.bpf_reg_state* %off_reg, %struct.bpf_reg_state** %off_reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #20
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %known, align 1
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 6
  %14 = load i64, i64* %smin_value, align 8
  store i64 %14, i64* %smin_val, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  %16 = load i64, i64* %smax_value, align 8
  store i64 %16, i64* %smax_val, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value2, align 8
  store i64 %18, i64* %smin_ptr, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %smax_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 7
  %20 = load i64, i64* %smax_value3, align 8
  store i64 %20, i64* %smax_ptr, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 8
  %22 = load i64, i64* %umin_value, align 8
  store i64 %22, i64* %umin_val, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 9
  %24 = load i64, i64* %umax_value, align 8
  store i64 %24, i64* %umax_val, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %umin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 8
  %26 = load i64, i64* %umin_value4, align 8
  store i64 %26, i64* %umin_ptr, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %umax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 9
  %28 = load i64, i64* %umax_value5, align 8
  store i64 %28, i64* %umax_ptr, align 8
  %29 = bitcast %struct.bpf_sanitize_info* %info to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %29, i8 0, i64 64, i1 false)
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %30, i32 0, i32 0
  %31 = load i8, i8* %code, align 4
  %conv = zext i8 %31 to i32
  %and = and i32 %conv, 240
  %conv6 = trunc i32 %and to i8
  store i8 %conv6, i8* %opcode, align 1
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %32, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg7, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv8 = zext i8 %bf.clear to i32
  store i32 %conv8, i32* %dst, align 4
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %34 = load i32, i32* %dst, align 4
  %idxprom9 = zext i32 %34 to i64
  %arrayidx10 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i64 %idxprom9
  store %struct.bpf_reg_state* %arrayidx10, %struct.bpf_reg_state** %dst_reg, align 8
  %35 = load i8, i8* %known, align 1
  %tobool = trunc i8 %35 to i1
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false15

land.lhs.true:                                    ; preds = %entry
  %36 = load i64, i64* %smin_val, align 8
  %37 = load i64, i64* %smax_val, align 8
  %cmp = icmp ne i64 %36, %37
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %38 = load i64, i64* %umin_val, align 8
  %39 = load i64, i64* %umax_val, align 8
  %cmp13 = icmp ne i64 %38, %39
  br i1 %cmp13, label %if.then, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %lor.lhs.false, %entry
  %40 = load i64, i64* %smin_val, align 8
  %41 = load i64, i64* %smax_val, align 8
  %cmp16 = icmp sgt i64 %40, %41
  br i1 %cmp16, label %if.then, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %lor.lhs.false15
  %42 = load i64, i64* %umin_val, align 8
  %43 = load i64, i64* %umax_val, align 8
  %cmp19 = icmp ugt i64 %42, %43
  br i1 %cmp19, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false18, %lor.lhs.false15, %lor.lhs.false, %land.lhs.true
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %44, %struct.bpf_reg_state* noundef %45) #20
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false18
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code21 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 0
  %47 = load i8, i8* %code21, align 4
  %conv22 = zext i8 %47 to i32
  %and23 = and i32 %conv22, 7
  %cmp24 = icmp ne i32 %and23, 7
  br i1 %cmp24, label %if.then26, label %if.end35

if.then26:                                        ; preds = %if.end
  %48 = load i8, i8* %opcode, align 1
  %conv27 = zext i8 %48 to i32
  %cmp28 = icmp eq i32 %conv27, 16
  br i1 %cmp28, label %land.lhs.true30, label %if.end34

land.lhs.true30:                                  ; preds = %if.then26
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %49, i32 0, i32 17
  %50 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool31 = trunc i8 %50 to i1
  br i1 %tobool31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %land.lhs.true30
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %51, %struct.bpf_reg_state* noundef %52) #20
  store i32 0, i32* %retval, align 4
  br label %return

if.end34:                                         ; preds = %land.lhs.true30, %if.then26
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = bitcast %struct.bpf_verifier_env* %53 to i8*
  %55 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %54, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.329, i64 0, i64 0), i32 noundef %55) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end35:                                         ; preds = %if.end
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 0
  %57 = load i32, i32* %type, align 8
  %and36 = and i32 %57, 256
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.then38, label %if.end41

if.then38:                                        ; preds = %if.end35
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = bitcast %struct.bpf_verifier_env* %58 to i8*
  %60 = load i32, i32* %dst, align 4
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type39 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 0
  %63 = load i32, i32* %type39, align 8
  %call40 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %61, i32 noundef %63) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %59, i8* noundef getelementptr inbounds ([62 x i8], [62 x i8]* @.str.330, i64 0, i64 0), i32 noundef %60, i8* noundef %call40) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end35
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %64, i32 0, i32 0
  %65 = load i32, i32* %type42, align 8
  %call43 = call i32 @base_type(i32 noundef %65) #20
  switch i32 %call43, label %sw.default [
    i32 3, label %sw.bb
    i32 9, label %sw.bb55
    i32 11, label %sw.bb55
    i32 12, label %sw.bb55
    i32 13, label %sw.bb55
    i32 15, label %sw.bb55
  ]

sw.bb:                                            ; preds = %if.end41
  %66 = load i8, i8* %known, align 1
  %tobool44 = trunc i8 %66 to i1
  br i1 %tobool44, label %land.lhs.true46, label %if.end54

land.lhs.true46:                                  ; preds = %sw.bb
  %67 = load i64, i64* %smin_val, align 8
  %cmp47 = icmp eq i64 %67, 0
  br i1 %cmp47, label %land.lhs.true49, label %if.end54

land.lhs.true49:                                  ; preds = %land.lhs.true46
  %68 = load i8, i8* %opcode, align 1
  %conv50 = zext i8 %68 to i32
  %cmp51 = icmp eq i32 %conv50, 0
  br i1 %cmp51, label %if.then53, label %if.end54

if.then53:                                        ; preds = %land.lhs.true49
  br label %sw.epilog

if.end54:                                         ; preds = %land.lhs.true49, %land.lhs.true46, %sw.bb
  br label %sw.bb55

sw.bb55:                                          ; preds = %if.end41, %if.end41, %if.end41, %if.end41, %if.end41, %if.end54
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = bitcast %struct.bpf_verifier_env* %69 to i8*
  %71 = load i32, i32* %dst, align 4
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type56 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %73, i32 0, i32 0
  %74 = load i32, i32* %type56, align 8
  %call57 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %72, i32 noundef %74) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %70, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.331, i64 0, i64 0), i32 noundef %71, i8* noundef %call57) #20
  store i32 -13, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end41
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.then53
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %75, i32 0, i32 0
  %76 = load i32, i32* %type58, align 8
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 0
  store i32 %76, i32* %type59, align 8
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %78, i32 0, i32 3
  %79 = load i32, i32* %id, align 8
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id60 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 3
  store i32 %79, i32* %id60, align 8
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type61 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 0
  %84 = load i32, i32* %type61, align 8
  %call62 = call zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %81, %struct.bpf_reg_state* noundef %82, i32 noundef %84) #20
  br i1 %call62, label %lor.lhs.false63, label %if.then66

lor.lhs.false63:                                  ; preds = %sw.epilog
  %85 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type64 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %87, i32 0, i32 0
  %88 = load i32, i32* %type64, align 8
  %call65 = call zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %85, %struct.bpf_reg_state* noundef %86, i32 noundef %88) #20
  br i1 %call65, label %if.end67, label %if.then66

if.then66:                                        ; preds = %lor.lhs.false63, %sw.epilog
  store i32 -22, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %lor.lhs.false63
  %89 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %89) #20
  %90 = load i8, i8* %opcode, align 1
  %call68 = call zeroext i1 @sanitize_needed(i8 noundef zeroext %90) #20
  br i1 %call68, label %if.then69, label %if.end76

if.then69:                                        ; preds = %if.end67
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %92 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call70 = call i32 @sanitize_ptr_alu(%struct.bpf_verifier_env* noundef %91, %struct.bpf_insn* noundef %92, %struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, %struct.bpf_reg_state* noundef %95, %struct.bpf_sanitize_info* noundef %info, i1 noundef zeroext false) #20
  store i32 %call70, i32* %ret, align 4
  %96 = load i32, i32* %ret, align 4
  %cmp71 = icmp slt i32 %96, 0
  br i1 %cmp71, label %if.then73, label %if.end75

if.then73:                                        ; preds = %if.then69
  %97 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %98 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %99 = load i32, i32* %ret, align 4
  %100 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call74 = call i32 @sanitize_err(%struct.bpf_verifier_env* noundef %97, %struct.bpf_insn* noundef %98, i32 noundef %99, %struct.bpf_reg_state* noundef %100, %struct.bpf_reg_state* noundef %101) #20
  store i32 %call74, i32* %retval, align 4
  br label %return

if.end75:                                         ; preds = %if.then69
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end67
  %102 = load i8, i8* %opcode, align 1
  %conv77 = zext i8 %102 to i32
  switch i32 %conv77, label %sw.default234 [
    i32 0, label %sw.bb78
    i32 16, label %sw.bb146
    i32 80, label %sw.bb230
    i32 64, label %sw.bb230
    i32 160, label %sw.bb230
  ]

sw.bb78:                                          ; preds = %if.end76
  %103 = load i8, i8* %known, align 1
  %tobool79 = trunc i8 %103 to i1
  br i1 %tobool79, label %land.lhs.true81, label %if.end103

land.lhs.true81:                                  ; preds = %sw.bb78
  %104 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %104, i32 0, i32 1
  %105 = load i32, i32* %off, align 4
  %conv82 = sext i32 %105 to i64
  %106 = load i64, i64* %smin_val, align 8
  %add = add i64 %conv82, %106
  %107 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off83 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %107, i32 0, i32 1
  %108 = load i32, i32* %off83, align 4
  %conv84 = sext i32 %108 to i64
  %109 = load i64, i64* %smin_val, align 8
  %add85 = add i64 %conv84, %109
  %conv86 = trunc i64 %add85 to i32
  %conv87 = sext i32 %conv86 to i64
  %cmp88 = icmp eq i64 %add, %conv87
  br i1 %cmp88, label %if.then90, label %if.end103

if.then90:                                        ; preds = %land.lhs.true81
  %110 = load i64, i64* %smin_ptr, align 8
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value91 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 6
  store i64 %110, i64* %smin_value91, align 8
  %112 = load i64, i64* %smax_ptr, align 8
  %113 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %113, i32 0, i32 7
  store i64 %112, i64* %smax_value92, align 8
  %114 = load i64, i64* %umin_ptr, align 8
  %115 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value93 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %115, i32 0, i32 8
  store i64 %114, i64* %umin_value93, align 8
  %116 = load i64, i64* %umax_ptr, align 8
  %117 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value94 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %117, i32 0, i32 9
  store i64 %116, i64* %umax_value94, align 8
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off96 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %119, i32 0, i32 5
  %120 = bitcast %struct.tnum* %var_off95 to i8*
  %121 = bitcast %struct.tnum* %var_off96 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %120, i8* align 8 %121, i64 16, i1 false)
  %122 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off97 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %122, i32 0, i32 1
  %123 = load i32, i32* %off97, align 4
  %conv98 = sext i32 %123 to i64
  %124 = load i64, i64* %smin_val, align 8
  %add99 = add i64 %conv98, %124
  %conv100 = trunc i64 %add99 to i32
  %125 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off101 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %125, i32 0, i32 1
  store i32 %conv100, i32* %off101, align 4
  %126 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %127 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %126, i32 0, i32 2
  %raw = bitcast %union.anon.168* %127 to %struct.anon.172*
  %128 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %129 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %128, i32 0, i32 2
  %raw102 = bitcast %union.anon.168* %129 to %struct.anon.172*
  %130 = bitcast %struct.anon.172* %raw to i8*
  %131 = bitcast %struct.anon.172* %raw102 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %130, i8* align 8 %131, i64 16, i1 false)
  br label %sw.epilog239

if.end103:                                        ; preds = %land.lhs.true81, %sw.bb78
  %132 = load i64, i64* %smin_ptr, align 8
  %133 = load i64, i64* %smin_val, align 8
  %call104 = call zeroext i1 @signed_add_overflows(i64 noundef %132, i64 noundef %133) #20
  br i1 %call104, label %if.then109, label %lor.lhs.false106

lor.lhs.false106:                                 ; preds = %if.end103
  %134 = load i64, i64* %smax_ptr, align 8
  %135 = load i64, i64* %smax_val, align 8
  %call107 = call zeroext i1 @signed_add_overflows(i64 noundef %134, i64 noundef %135) #20
  br i1 %call107, label %if.then109, label %if.else

if.then109:                                       ; preds = %lor.lhs.false106, %if.end103
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value110, align 8
  %137 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value111 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %137, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value111, align 8
  br label %if.end116

if.else:                                          ; preds = %lor.lhs.false106
  %138 = load i64, i64* %smin_ptr, align 8
  %139 = load i64, i64* %smin_val, align 8
  %add112 = add i64 %138, %139
  %140 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value113 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %140, i32 0, i32 6
  store i64 %add112, i64* %smin_value113, align 8
  %141 = load i64, i64* %smax_ptr, align 8
  %142 = load i64, i64* %smax_val, align 8
  %add114 = add i64 %141, %142
  %143 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value115 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %143, i32 0, i32 7
  store i64 %add114, i64* %smax_value115, align 8
  br label %if.end116

if.end116:                                        ; preds = %if.else, %if.then109
  %144 = load i64, i64* %umin_ptr, align 8
  %145 = load i64, i64* %umin_val, align 8
  %add117 = add i64 %144, %145
  %146 = load i64, i64* %umin_ptr, align 8
  %cmp118 = icmp ult i64 %add117, %146
  br i1 %cmp118, label %if.then124, label %lor.lhs.false120

lor.lhs.false120:                                 ; preds = %if.end116
  %147 = load i64, i64* %umax_ptr, align 8
  %148 = load i64, i64* %umax_val, align 8
  %add121 = add i64 %147, %148
  %149 = load i64, i64* %umax_ptr, align 8
  %cmp122 = icmp ult i64 %add121, %149
  br i1 %cmp122, label %if.then124, label %if.else127

if.then124:                                       ; preds = %lor.lhs.false120, %if.end116
  %150 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value125 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %150, i32 0, i32 8
  store i64 0, i64* %umin_value125, align 8
  %151 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value126 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %151, i32 0, i32 9
  store i64 -1, i64* %umax_value126, align 8
  br label %if.end132

if.else127:                                       ; preds = %lor.lhs.false120
  %152 = load i64, i64* %umin_ptr, align 8
  %153 = load i64, i64* %umin_val, align 8
  %add128 = add i64 %152, %153
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value129 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %154, i32 0, i32 8
  store i64 %add128, i64* %umin_value129, align 8
  %155 = load i64, i64* %umax_ptr, align 8
  %156 = load i64, i64* %umax_val, align 8
  %add130 = add i64 %155, %156
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value131 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %157, i32 0, i32 9
  store i64 %add130, i64* %umax_value131, align 8
  br label %if.end132

if.end132:                                        ; preds = %if.else127, %if.then124
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off133 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %158, i32 0, i32 5
  %159 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off134 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %159, i32 0, i32 5
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off135 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 5
  %161 = bitcast %struct.tnum* %var_off134 to { i64, i64 }*
  %162 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %161, i32 0, i32 0
  %163 = load i64, i64* %162, align 8
  %164 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %161, i32 0, i32 1
  %165 = load i64, i64* %164, align 8
  %166 = bitcast %struct.tnum* %var_off135 to { i64, i64 }*
  %167 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %166, i32 0, i32 0
  %168 = load i64, i64* %167, align 8
  %169 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %166, i32 0, i32 1
  %170 = load i64, i64* %169, align 8
  %call136 = call { i64, i64 } @tnum_add(i64 %163, i64 %165, i64 %168, i64 %170) #20
  %171 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %172 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %171, i32 0, i32 0
  %173 = extractvalue { i64, i64 } %call136, 0
  store i64 %173, i64* %172, align 8
  %174 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %171, i32 0, i32 1
  %175 = extractvalue { i64, i64 } %call136, 1
  store i64 %175, i64* %174, align 8
  %176 = bitcast %struct.tnum* %var_off133 to i8*
  %177 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %176, i8* align 8 %177, i64 16, i1 false)
  %178 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off137 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %178, i32 0, i32 1
  %179 = load i32, i32* %off137, align 4
  %180 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off138 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %180, i32 0, i32 1
  store i32 %179, i32* %off138, align 4
  %181 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %182 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %181, i32 0, i32 2
  %raw139 = bitcast %union.anon.168* %182 to %struct.anon.172*
  %183 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %184 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %183, i32 0, i32 2
  %raw140 = bitcast %union.anon.168* %184 to %struct.anon.172*
  %185 = bitcast %struct.anon.172* %raw139 to i8*
  %186 = bitcast %struct.anon.172* %raw140 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %185, i8* align 8 %186, i64 16, i1 false)
  %187 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %call141 = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %187) #20
  br i1 %call141, label %if.then142, label %if.end145

if.then142:                                       ; preds = %if.end132
  %188 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %188, i32 0, i32 15
  %189 = load i32, i32* %id_gen, align 8
  %inc = add i32 %189, 1
  store i32 %inc, i32* %id_gen, align 8
  %190 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id143 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %190, i32 0, i32 3
  store i32 %inc, i32* %id143, align 8
  %191 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %192 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %191, i32 0, i32 2
  %raw144 = bitcast %union.anon.168* %192 to %struct.anon.172*
  %193 = bitcast %struct.anon.172* %raw144 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %193, i8 0, i64 16, i1 false)
  br label %if.end145

if.end145:                                        ; preds = %if.then142, %if.end132
  br label %sw.epilog239

sw.bb146:                                         ; preds = %if.end76
  %194 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %195 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %cmp147 = icmp eq %struct.bpf_reg_state* %194, %195
  br i1 %cmp147, label %if.then149, label %if.end150

if.then149:                                       ; preds = %sw.bb146
  %196 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %197 = bitcast %struct.bpf_verifier_env* %196 to i8*
  %198 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %197, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.332, i64 0, i64 0), i32 noundef %198) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end150:                                        ; preds = %sw.bb146
  %199 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type151 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %199, i32 0, i32 0
  %200 = load i32, i32* %type151, align 8
  %cmp152 = icmp eq i32 %200, 6
  br i1 %cmp152, label %if.then154, label %if.end155

if.then154:                                       ; preds = %if.end150
  %201 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %202 = bitcast %struct.bpf_verifier_env* %201 to i8*
  %203 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %202, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.333, i64 0, i64 0), i32 noundef %203) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end155:                                        ; preds = %if.end150
  %204 = load i8, i8* %known, align 1
  %tobool156 = trunc i8 %204 to i1
  br i1 %tobool156, label %land.lhs.true158, label %if.end184

land.lhs.true158:                                 ; preds = %if.end155
  %205 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off159 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %205, i32 0, i32 1
  %206 = load i32, i32* %off159, align 4
  %conv160 = sext i32 %206 to i64
  %207 = load i64, i64* %smin_val, align 8
  %sub = sub i64 %conv160, %207
  %208 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off161 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %208, i32 0, i32 1
  %209 = load i32, i32* %off161, align 4
  %conv162 = sext i32 %209 to i64
  %210 = load i64, i64* %smin_val, align 8
  %sub163 = sub i64 %conv162, %210
  %conv164 = trunc i64 %sub163 to i32
  %conv165 = sext i32 %conv164 to i64
  %cmp166 = icmp eq i64 %sub, %conv165
  br i1 %cmp166, label %if.then168, label %if.end184

if.then168:                                       ; preds = %land.lhs.true158
  %211 = load i64, i64* %smin_ptr, align 8
  %212 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value169 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %212, i32 0, i32 6
  store i64 %211, i64* %smin_value169, align 8
  %213 = load i64, i64* %smax_ptr, align 8
  %214 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value170 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %214, i32 0, i32 7
  store i64 %213, i64* %smax_value170, align 8
  %215 = load i64, i64* %umin_ptr, align 8
  %216 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value171 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %216, i32 0, i32 8
  store i64 %215, i64* %umin_value171, align 8
  %217 = load i64, i64* %umax_ptr, align 8
  %218 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value172 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %218, i32 0, i32 9
  store i64 %217, i64* %umax_value172, align 8
  %219 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off173 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %219, i32 0, i32 5
  %220 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off174 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %220, i32 0, i32 5
  %221 = bitcast %struct.tnum* %var_off173 to i8*
  %222 = bitcast %struct.tnum* %var_off174 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %221, i8* align 8 %222, i64 16, i1 false)
  %223 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %id175 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %223, i32 0, i32 3
  %224 = load i32, i32* %id175, align 8
  %225 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id176 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %225, i32 0, i32 3
  store i32 %224, i32* %id176, align 8
  %226 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off177 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %226, i32 0, i32 1
  %227 = load i32, i32* %off177, align 4
  %conv178 = sext i32 %227 to i64
  %228 = load i64, i64* %smin_val, align 8
  %sub179 = sub i64 %conv178, %228
  %conv180 = trunc i64 %sub179 to i32
  %229 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off181 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %229, i32 0, i32 1
  store i32 %conv180, i32* %off181, align 4
  %230 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %231 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %230, i32 0, i32 2
  %raw182 = bitcast %union.anon.168* %231 to %struct.anon.172*
  %232 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %233 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %232, i32 0, i32 2
  %raw183 = bitcast %union.anon.168* %233 to %struct.anon.172*
  %234 = bitcast %struct.anon.172* %raw182 to i8*
  %235 = bitcast %struct.anon.172* %raw183 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %234, i8* align 8 %235, i64 16, i1 false)
  br label %sw.epilog239

if.end184:                                        ; preds = %land.lhs.true158, %if.end155
  %236 = load i64, i64* %smin_ptr, align 8
  %237 = load i64, i64* %smax_val, align 8
  %call185 = call zeroext i1 @signed_sub_overflows(i64 noundef %236, i64 noundef %237) #20
  br i1 %call185, label %if.then190, label %lor.lhs.false187

lor.lhs.false187:                                 ; preds = %if.end184
  %238 = load i64, i64* %smax_ptr, align 8
  %239 = load i64, i64* %smin_val, align 8
  %call188 = call zeroext i1 @signed_sub_overflows(i64 noundef %238, i64 noundef %239) #20
  br i1 %call188, label %if.then190, label %if.else193

if.then190:                                       ; preds = %lor.lhs.false187, %if.end184
  %240 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value191 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %240, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value191, align 8
  %241 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value192 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %241, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value192, align 8
  br label %if.end198

if.else193:                                       ; preds = %lor.lhs.false187
  %242 = load i64, i64* %smin_ptr, align 8
  %243 = load i64, i64* %smax_val, align 8
  %sub194 = sub i64 %242, %243
  %244 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value195 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %244, i32 0, i32 6
  store i64 %sub194, i64* %smin_value195, align 8
  %245 = load i64, i64* %smax_ptr, align 8
  %246 = load i64, i64* %smin_val, align 8
  %sub196 = sub i64 %245, %246
  %247 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value197 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %247, i32 0, i32 7
  store i64 %sub196, i64* %smax_value197, align 8
  br label %if.end198

if.end198:                                        ; preds = %if.else193, %if.then190
  %248 = load i64, i64* %umin_ptr, align 8
  %249 = load i64, i64* %umax_val, align 8
  %cmp199 = icmp ult i64 %248, %249
  br i1 %cmp199, label %if.then201, label %if.else204

if.then201:                                       ; preds = %if.end198
  %250 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value202 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %250, i32 0, i32 8
  store i64 0, i64* %umin_value202, align 8
  %251 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value203 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %251, i32 0, i32 9
  store i64 -1, i64* %umax_value203, align 8
  br label %if.end209

if.else204:                                       ; preds = %if.end198
  %252 = load i64, i64* %umin_ptr, align 8
  %253 = load i64, i64* %umax_val, align 8
  %sub205 = sub i64 %252, %253
  %254 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value206 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %254, i32 0, i32 8
  store i64 %sub205, i64* %umin_value206, align 8
  %255 = load i64, i64* %umax_ptr, align 8
  %256 = load i64, i64* %umin_val, align 8
  %sub207 = sub i64 %255, %256
  %257 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value208 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %257, i32 0, i32 9
  store i64 %sub207, i64* %umax_value208, align 8
  br label %if.end209

if.end209:                                        ; preds = %if.else204, %if.then201
  %258 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off210 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %258, i32 0, i32 5
  %259 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off212 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %259, i32 0, i32 5
  %260 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off213 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %260, i32 0, i32 5
  %261 = bitcast %struct.tnum* %var_off212 to { i64, i64 }*
  %262 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %261, i32 0, i32 0
  %263 = load i64, i64* %262, align 8
  %264 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %261, i32 0, i32 1
  %265 = load i64, i64* %264, align 8
  %266 = bitcast %struct.tnum* %var_off213 to { i64, i64 }*
  %267 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %266, i32 0, i32 0
  %268 = load i64, i64* %267, align 8
  %269 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %266, i32 0, i32 1
  %270 = load i64, i64* %269, align 8
  %call214 = call { i64, i64 } @tnum_sub(i64 %263, i64 %265, i64 %268, i64 %270) #20
  %271 = bitcast %struct.tnum* %tmp211 to { i64, i64 }*
  %272 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %271, i32 0, i32 0
  %273 = extractvalue { i64, i64 } %call214, 0
  store i64 %273, i64* %272, align 8
  %274 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %271, i32 0, i32 1
  %275 = extractvalue { i64, i64 } %call214, 1
  store i64 %275, i64* %274, align 8
  %276 = bitcast %struct.tnum* %var_off210 to i8*
  %277 = bitcast %struct.tnum* %tmp211 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %276, i8* align 8 %277, i64 16, i1 false)
  %278 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off215 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %278, i32 0, i32 1
  %279 = load i32, i32* %off215, align 4
  %280 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off216 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %280, i32 0, i32 1
  store i32 %279, i32* %off216, align 4
  %281 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %282 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %281, i32 0, i32 2
  %raw217 = bitcast %union.anon.168* %282 to %struct.anon.172*
  %283 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %284 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %283, i32 0, i32 2
  %raw218 = bitcast %union.anon.168* %284 to %struct.anon.172*
  %285 = bitcast %struct.anon.172* %raw217 to i8*
  %286 = bitcast %struct.anon.172* %raw218 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %285, i8* align 8 %286, i64 16, i1 false)
  %287 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %call219 = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %287) #20
  br i1 %call219, label %if.then220, label %if.end229

if.then220:                                       ; preds = %if.end209
  %288 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen221 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %288, i32 0, i32 15
  %289 = load i32, i32* %id_gen221, align 8
  %inc222 = add i32 %289, 1
  store i32 %inc222, i32* %id_gen221, align 8
  %290 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id223 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %290, i32 0, i32 3
  store i32 %inc222, i32* %id223, align 8
  %291 = load i64, i64* %smin_val, align 8
  %cmp224 = icmp slt i64 %291, 0
  br i1 %cmp224, label %if.then226, label %if.end228

if.then226:                                       ; preds = %if.then220
  %292 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %293 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %292, i32 0, i32 2
  %raw227 = bitcast %union.anon.168* %293 to %struct.anon.172*
  %294 = bitcast %struct.anon.172* %raw227 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %294, i8 0, i64 16, i1 false)
  br label %if.end228

if.end228:                                        ; preds = %if.then226, %if.then220
  br label %if.end229

if.end229:                                        ; preds = %if.end228, %if.end209
  br label %sw.epilog239

sw.bb230:                                         ; preds = %if.end76, %if.end76, %if.end76
  %295 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %296 = bitcast %struct.bpf_verifier_env* %295 to i8*
  %297 = load i32, i32* %dst, align 4
  %298 = load i8, i8* %opcode, align 1
  %conv231 = zext i8 %298 to i32
  %shr = ashr i32 %conv231, 4
  %idxprom232 = sext i32 %shr to i64
  %arrayidx233 = getelementptr [16 x i8*], [16 x i8*]* @bpf_alu_string, i64 0, i64 %idxprom232
  %299 = load i8*, i8** %arrayidx233, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %296, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.334, i64 0, i64 0), i32 noundef %297, i8* noundef %299) #20
  store i32 -13, i32* %retval, align 4
  br label %return

sw.default234:                                    ; preds = %if.end76
  %300 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %301 = bitcast %struct.bpf_verifier_env* %300 to i8*
  %302 = load i32, i32* %dst, align 4
  %303 = load i8, i8* %opcode, align 1
  %conv235 = zext i8 %303 to i32
  %shr236 = ashr i32 %conv235, 4
  %idxprom237 = sext i32 %shr236 to i64
  %arrayidx238 = getelementptr [16 x i8*], [16 x i8*]* @bpf_alu_string, i64 0, i64 %idxprom237
  %304 = load i8*, i8** %arrayidx238, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %301, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.335, i64 0, i64 0), i32 noundef %302, i8* noundef %304) #20
  store i32 -13, i32* %retval, align 4
  br label %return

sw.epilog239:                                     ; preds = %if.end229, %if.then168, %if.end145, %if.then90
  %305 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %306 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %307 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type240 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %307, i32 0, i32 0
  %308 = load i32, i32* %type240, align 8
  %call241 = call zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %305, %struct.bpf_reg_state* noundef %306, i32 noundef %308) #20
  br i1 %call241, label %if.end243, label %if.then242

if.then242:                                       ; preds = %sw.epilog239
  store i32 -22, i32* %retval, align 4
  br label %return

if.end243:                                        ; preds = %sw.epilog239
  %309 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @reg_bounds_sync(%struct.bpf_reg_state* noundef %309) #20
  %310 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %311 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %312 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call244 = call i32 @sanitize_check_bounds(%struct.bpf_verifier_env* noundef %310, %struct.bpf_insn* noundef %311, %struct.bpf_reg_state* noundef %312) #20
  %cmp245 = icmp slt i32 %call244, 0
  br i1 %cmp245, label %if.then247, label %if.end248

if.then247:                                       ; preds = %if.end243
  store i32 -13, i32* %retval, align 4
  br label %return

if.end248:                                        ; preds = %if.end243
  %313 = load i8, i8* %opcode, align 1
  %call249 = call zeroext i1 @sanitize_needed(i8 noundef zeroext %313) #20
  br i1 %call249, label %if.then250, label %if.end257

if.then250:                                       ; preds = %if.end248
  %314 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %315 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %316 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %317 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %318 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call251 = call i32 @sanitize_ptr_alu(%struct.bpf_verifier_env* noundef %314, %struct.bpf_insn* noundef %315, %struct.bpf_reg_state* noundef %316, %struct.bpf_reg_state* noundef %317, %struct.bpf_reg_state* noundef %318, %struct.bpf_sanitize_info* noundef %info, i1 noundef zeroext true) #20
  store i32 %call251, i32* %ret, align 4
  %319 = load i32, i32* %ret, align 4
  %cmp252 = icmp slt i32 %319, 0
  br i1 %cmp252, label %if.then254, label %if.end256

if.then254:                                       ; preds = %if.then250
  %320 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %321 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %322 = load i32, i32* %ret, align 4
  %323 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %324 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call255 = call i32 @sanitize_err(%struct.bpf_verifier_env* noundef %320, %struct.bpf_insn* noundef %321, i32 noundef %322, %struct.bpf_reg_state* noundef %323, %struct.bpf_reg_state* noundef %324) #20
  store i32 %call255, i32* %retval, align 4
  br label %return

if.end256:                                        ; preds = %if.then250
  br label %if.end257

if.end257:                                        ; preds = %if.end256, %if.end248
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end257, %if.then254, %if.then247, %if.then242, %sw.default234, %sw.bb230, %if.then154, %if.then149, %if.then73, %if.then66, %sw.bb55, %if.then38, %if.end34, %if.then33, %if.then
  %325 = load i32, i32* %retval, align 4
  ret i32 %325
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %type.addr = alloca i32, align 4
  %known = alloca i8, align 1
  %val = alloca i64, align 8
  %smin = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #20
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off1, i32 0, i32 0
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %val, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  store i64 %9, i64* %smin, align 8
  %10 = load i8, i8* %known, align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %11 = load i64, i64* %val, align 8
  %cmp = icmp sge i64 %11, 536870912
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %12 = load i64, i64* %val, align 8
  %cmp2 = icmp sle i64 %12, -536870912
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = load i32, i32* %type.addr, align 4
  %call3 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %15, i32 noundef %16) #20
  %17 = load i64, i64* %val, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.336, i64 0, i64 0), i8* noundef %call3, i64 noundef %17) #20
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 1
  %19 = load i32, i32* %off, align 4
  %cmp4 = icmp sge i32 %19, 536870912
  br i1 %cmp4, label %if.then8, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %if.end
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 1
  %21 = load i32, i32* %off6, align 4
  %cmp7 = icmp sle i32 %21, -536870912
  br i1 %cmp7, label %if.then8, label %if.end11

if.then8:                                         ; preds = %lor.lhs.false5, %if.end
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load i32, i32* %type.addr, align 4
  %call9 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %24, i32 noundef %25) #20
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 1
  %27 = load i32, i32* %off10, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.337, i64 0, i64 0), i8* noundef %call9, i32 noundef %27) #20
  store i1 false, i1* %retval, align 1
  br label %return

if.end11:                                         ; preds = %lor.lhs.false5
  %28 = load i64, i64* %smin, align 8
  %cmp12 = icmp eq i64 %28, -9223372036854775808
  br i1 %cmp12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = load i32, i32* %type.addr, align 4
  %call14 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %31, i32 noundef %32) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([78 x i8], [78 x i8]* @.str.338, i64 0, i64 0), i8* noundef %call14) #20
  store i1 false, i1* %retval, align 1
  br label %return

if.end15:                                         ; preds = %if.end11
  %33 = load i64, i64* %smin, align 8
  %cmp16 = icmp sge i64 %33, 536870912
  br i1 %cmp16, label %if.then19, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %if.end15
  %34 = load i64, i64* %smin, align 8
  %cmp18 = icmp sle i64 %34, -536870912
  br i1 %cmp18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %lor.lhs.false17, %if.end15
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load i64, i64* %smin, align 8
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load i32, i32* %type.addr, align 4
  %call20 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %38, i32 noundef %39) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.339, i64 0, i64 0), i64 noundef %37, i8* noundef %call20) #20
  store i1 false, i1* %retval, align 1
  br label %return

if.end21:                                         ; preds = %lor.lhs.false17
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end21, %if.then19, %if.then13, %if.then8, %if.then
  %40 = load i1, i1* %retval, align 1
  ret i1 %40
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @sanitize_ptr_alu(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %ptr_reg, %struct.bpf_reg_state* noundef %off_reg, %struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_sanitize_info* noundef %info, i1 noundef zeroext %commit_window) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %ptr_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %info.addr = alloca %struct.bpf_sanitize_info*, align 8
  %commit_window.addr = alloca i8, align 1
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %off_is_imm = alloca i8, align 1
  %off_is_neg = alloca i8, align 1
  %ptr_is_dst_reg = alloca i8, align 1
  %opcode = alloca i8, align 1
  %alu_state = alloca i32, align 4
  %alu_limit = alloca i32, align 4
  %tmp = alloca %struct.bpf_reg_state, align 8
  %ret = alloca i8, align 1
  %err = alloca i32, align 4
  %__x = alloca i32, align 4
  %tmp51 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %ptr_reg, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  store %struct.bpf_reg_state* %off_reg, %struct.bpf_reg_state** %off_reg.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_sanitize_info* %info, %struct.bpf_sanitize_info** %info.addr, align 8
  %frombool = zext i1 %commit_window to i8
  store i8 %frombool, i8* %commit_window.addr, align 1
  %0 = load i8, i8* %commit_window.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %1) #20
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load %struct.bpf_sanitize_info*, %struct.bpf_sanitize_info** %info.addr, align 8
  %aux1 = getelementptr inbounds %struct.bpf_sanitize_info, %struct.bpf_sanitize_info* %2, i32 0, i32 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_insn_aux_data* [ %call, %cond.true ], [ %aux1, %cond.false ]
  store %struct.bpf_insn_aux_data* %cond, %struct.bpf_insn_aux_data** %aux, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 8
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %4, %struct.bpf_verifier_state** %vstate, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 5
  %6 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %8, i64 %10) #20
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %off_is_imm, align 1
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 6
  %12 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %12, 0
  %frombool4 = zext i1 %cmp to i8
  store i8 %frombool4, i8* %off_is_neg, align 1
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %cmp5 = icmp eq %struct.bpf_reg_state* %13, %14
  %frombool6 = zext i1 %cmp5 to i8
  store i8 %frombool6, i8* %ptr_is_dst_reg, align 1
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 0
  %16 = load i8, i8* %code, align 4
  %conv = zext i8 %16 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call8 = call zeroext i1 @can_skip_alu_sanitation(%struct.bpf_verifier_env* noundef %17, %struct.bpf_insn* noundef %18) #20
  br i1 %call8, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 6
  %20 = load i8, i8* %speculative, align 8
  %tobool9 = trunc i8 %20 to i1
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  br label %do_sim

if.end11:                                         ; preds = %if.end
  %21 = load i8, i8* %commit_window.addr, align 1
  %tobool12 = trunc i8 %21 to i1
  br i1 %tobool12, label %if.end36, label %if.then13

if.then13:                                        ; preds = %if.end11
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 5
  %23 = bitcast %struct.tnum* %var_off14 to { i64, i64 }*
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  %call15 = call zeroext i1 @tnum_is_const(i64 %25, i64 %27) #20
  br i1 %call15, label %if.end24, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then13
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 6
  %29 = load i64, i64* %smin_value16, align 8
  %cmp17 = icmp slt i64 %29, 0
  %conv18 = zext i1 %cmp17 to i32
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 7
  %31 = load i64, i64* %smax_value, align 8
  %cmp19 = icmp slt i64 %31, 0
  %conv20 = zext i1 %cmp19 to i32
  %cmp21 = icmp ne i32 %conv18, %conv20
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %land.lhs.true
  store i32 -1, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %land.lhs.true, %if.then13
  %32 = load i8, i8* %opcode, align 1
  %conv25 = zext i8 %32 to i32
  %cmp26 = icmp eq i32 %conv25, 0
  br i1 %cmp26, label %land.lhs.true28, label %lor.rhs

land.lhs.true28:                                  ; preds = %if.end24
  %33 = load i8, i8* %off_is_neg, align 1
  %tobool29 = trunc i8 %33 to i1
  br i1 %tobool29, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true28, %if.end24
  %34 = load i8, i8* %opcode, align 1
  %conv31 = zext i8 %34 to i32
  %cmp32 = icmp eq i32 %conv31, 16
  br i1 %cmp32, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %35 = load i8, i8* %off_is_neg, align 1
  %tobool34 = trunc i8 %35 to i1
  %lnot = xor i1 %tobool34, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %36 = phi i1 [ false, %lor.rhs ], [ %lnot, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.lhs.true28
  %37 = phi i1 [ true, %land.lhs.true28 ], [ %36, %land.end ]
  %38 = load %struct.bpf_sanitize_info*, %struct.bpf_sanitize_info** %info.addr, align 8
  %mask_to_left = getelementptr inbounds %struct.bpf_sanitize_info, %struct.bpf_sanitize_info* %38, i32 0, i32 1
  %frombool35 = zext i1 %37 to i8
  store i8 %frombool35, i8* %mask_to_left, align 8
  br label %if.end36

if.end36:                                         ; preds = %lor.end, %if.end11
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %40 = load %struct.bpf_sanitize_info*, %struct.bpf_sanitize_info** %info.addr, align 8
  %mask_to_left37 = getelementptr inbounds %struct.bpf_sanitize_info, %struct.bpf_sanitize_info* %40, i32 0, i32 1
  %41 = load i8, i8* %mask_to_left37, align 8
  %tobool38 = trunc i8 %41 to i1
  %call39 = call i32 @retrieve_ptr_limit(%struct.bpf_reg_state* noundef %39, i32* noundef %alu_limit, i1 noundef zeroext %tobool38) #20
  store i32 %call39, i32* %err, align 4
  %42 = load i32, i32* %err, align 4
  %cmp40 = icmp slt i32 %42, 0
  br i1 %cmp40, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end36
  %43 = load i32, i32* %err, align 4
  store i32 %43, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.end36
  %44 = load i8, i8* %commit_window.addr, align 1
  %tobool44 = trunc i8 %44 to i1
  br i1 %tobool44, label %if.then45, label %if.else

if.then45:                                        ; preds = %if.end43
  %45 = load %struct.bpf_sanitize_info*, %struct.bpf_sanitize_info** %info.addr, align 8
  %aux46 = getelementptr inbounds %struct.bpf_sanitize_info, %struct.bpf_sanitize_info* %45, i32 0, i32 0
  %alu_state47 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %aux46, i32 0, i32 6
  %46 = load i8, i8* %alu_state47, align 2
  %conv48 = zext i8 %46 to i32
  store i32 %conv48, i32* %alu_state, align 4
  %47 = load %struct.bpf_sanitize_info*, %struct.bpf_sanitize_info** %info.addr, align 8
  %aux49 = getelementptr inbounds %struct.bpf_sanitize_info, %struct.bpf_sanitize_info* %47, i32 0, i32 0
  %48 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %aux49, i32 0, i32 0
  %alu_limit50 = bitcast %union.anon.210* %48 to i32*
  %49 = load i32, i32* %alu_limit50, align 8
  %50 = load i32, i32* %alu_limit, align 4
  %sub = sub i32 %49, %50
  store i32 %sub, i32* %__x, align 4
  %51 = load i32, i32* %__x, align 4
  %cmp52 = icmp slt i32 %51, 0
  br i1 %cmp52, label %cond.true54, label %cond.false56

cond.true54:                                      ; preds = %if.then45
  %52 = load i32, i32* %__x, align 4
  %sub55 = sub i32 0, %52
  br label %cond.end57

cond.false56:                                     ; preds = %if.then45
  %53 = load i32, i32* %__x, align 4
  br label %cond.end57

cond.end57:                                       ; preds = %cond.false56, %cond.true54
  %cond58 = phi i32 [ %sub55, %cond.true54 ], [ %53, %cond.false56 ]
  store i32 %cond58, i32* %tmp51, align 4
  %54 = load i32, i32* %tmp51, align 4
  store i32 %54, i32* %alu_limit, align 4
  br label %if.end72

if.else:                                          ; preds = %if.end43
  %55 = load i8, i8* %off_is_neg, align 1
  %tobool59 = trunc i8 %55 to i1
  %56 = zext i1 %tobool59 to i64
  %cond61 = select i1 %tobool59, i32 4, i32 0
  store i32 %cond61, i32* %alu_state, align 4
  %57 = load i8, i8* %off_is_imm, align 1
  %tobool62 = trunc i8 %57 to i1
  %58 = zext i1 %tobool62 to i64
  %cond64 = select i1 %tobool62, i32 16, i32 0
  %59 = load i32, i32* %alu_state, align 4
  %or = or i32 %59, %cond64
  store i32 %or, i32* %alu_state, align 4
  %60 = load i8, i8* %ptr_is_dst_reg, align 1
  %tobool65 = trunc i8 %60 to i1
  %61 = zext i1 %tobool65 to i64
  %cond67 = select i1 %tobool65, i32 1, i32 2
  %62 = load i32, i32* %alu_state, align 4
  %or68 = or i32 %62, %cond67
  store i32 %or68, i32* %alu_state, align 4
  %63 = load i8, i8* %off_is_imm, align 1
  %tobool69 = trunc i8 %63 to i1
  br i1 %tobool69, label %if.end71, label %if.then70

if.then70:                                        ; preds = %if.else
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explore_alu_limits = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %64, i32 0, i32 16
  store i8 1, i8* %explore_alu_limits, align 4
  br label %if.end71

if.end71:                                         ; preds = %if.then70, %if.else
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %cond.end57
  %65 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %66 = load i32, i32* %alu_state, align 4
  %67 = load i32, i32* %alu_limit, align 4
  %call73 = call i32 @update_alu_sanitation_state(%struct.bpf_insn_aux_data* noundef %65, i32 noundef %66, i32 noundef %67) #20
  store i32 %call73, i32* %err, align 4
  %68 = load i32, i32* %err, align 4
  %cmp74 = icmp slt i32 %68, 0
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.end72
  %69 = load i32, i32* %err, align 4
  store i32 %69, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %if.end72
  br label %do_sim

do_sim:                                           ; preds = %if.end77, %if.then10
  %70 = load i8, i8* %commit_window.addr, align 1
  %tobool78 = trunc i8 %70 to i1
  br i1 %tobool78, label %if.then82, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do_sim
  %71 = load i8, i8* %off_is_imm, align 1
  %tobool80 = trunc i8 %71 to i1
  br i1 %tobool80, label %if.then82, label %if.end83

if.then82:                                        ; preds = %lor.lhs.false, %do_sim
  store i32 0, i32* %retval, align 4
  br label %return

if.end83:                                         ; preds = %lor.lhs.false
  %72 = load i8, i8* %ptr_is_dst_reg, align 1
  %tobool84 = trunc i8 %72 to i1
  br i1 %tobool84, label %if.end86, label %if.then85

if.then85:                                        ; preds = %if.end83
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %74 = bitcast %struct.bpf_reg_state* %tmp to i8*
  %75 = bitcast %struct.bpf_reg_state* %73 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %74, i8* align 8 %75, i64 120, i1 false)
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %78 = bitcast %struct.bpf_reg_state* %76 to i8*
  %79 = bitcast %struct.bpf_reg_state* %77 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %78, i8* align 8 %79, i64 120, i1 false)
  br label %if.end86

if.end86:                                         ; preds = %if.then85, %if.end83
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %81, i32 0, i32 0
  %82 = load i32, i32* %insn_idx, align 8
  %add = add i32 %82, 1
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx87 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %83, i32 0, i32 0
  %84 = load i32, i32* %insn_idx87, align 8
  %call88 = call %struct.bpf_verifier_state* @sanitize_speculative_path(%struct.bpf_verifier_env* noundef %80, %struct.bpf_insn* noundef null, i32 noundef %add, i32 noundef %84) #20
  %tobool89 = icmp ne %struct.bpf_verifier_state* %call88, null
  %frombool90 = zext i1 %tobool89 to i8
  store i8 %frombool90, i8* %ret, align 1
  %85 = load i8, i8* %ptr_is_dst_reg, align 1
  %tobool91 = trunc i8 %85 to i1
  br i1 %tobool91, label %if.end96, label %land.lhs.true92

land.lhs.true92:                                  ; preds = %if.end86
  %86 = load i8, i8* %ret, align 1
  %tobool93 = trunc i8 %86 to i1
  br i1 %tobool93, label %if.then95, label %if.end96

if.then95:                                        ; preds = %land.lhs.true92
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %88 = bitcast %struct.bpf_reg_state* %87 to i8*
  %89 = bitcast %struct.bpf_reg_state* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %88, i8* align 8 %89, i64 120, i1 false)
  br label %if.end96

if.end96:                                         ; preds = %if.then95, %land.lhs.true92, %if.end86
  %90 = load i8, i8* %ret, align 1
  %tobool97 = trunc i8 %90 to i1
  %lnot98 = xor i1 %tobool97, true
  %91 = zext i1 %lnot98 to i64
  %cond99 = select i1 %lnot98, i32 -5, i32 0
  store i32 %cond99, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end96, %if.then82, %if.then76, %if.then42, %if.then23, %if.then
  %92 = load i32, i32* %retval, align 4
  ret i32 %92
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @sanitize_check_bounds(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %dst_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %dst = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv = zext i8 %bf.clear to i32
  store i32 %conv, i32* %dst, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 21
  %2 = load i8, i8* %bypass_spec_v1, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type, align 8
  switch i32 %4, label %sw.default [
    i32 6, label %sw.bb
    i32 4, label %sw.bb7
  ]

sw.bb:                                            ; preds = %if.end
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load i32, i32* %dst, align 4
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 1
  %9 = load i32, i32* %off, align 4
  %conv2 = sext i32 %9 to i64
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %11 = load i64, i64* %value, align 8
  %add = add i64 %conv2, %11
  %conv3 = trunc i64 %add to i32
  %call = call i32 @check_stack_access_for_ptr_arithmetic(%struct.bpf_verifier_env* noundef %5, i32 noundef %6, %struct.bpf_reg_state* noundef %7, i32 noundef %conv3) #20
  %tobool4 = icmp ne i32 %call, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %sw.bb
  store i32 -13, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %sw.bb
  br label %sw.epilog

sw.bb7:                                           ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load i32, i32* %dst, align 4
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 1
  %15 = load i32, i32* %off8, align 4
  %call9 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %12, i32 noundef %13, i32 noundef %15, i32 noundef 1, i1 noundef zeroext false, i32 noundef 2) #20
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %sw.bb7
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([77 x i8], [77 x i8]* @.str.341, i64 0, i64 0), i32 noundef %18) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %sw.bb7
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end12, %if.end6
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then11, %if.then5, %if.then
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @retrieve_ptr_limit(%struct.bpf_reg_state* noundef %ptr_reg, i32* noundef %alu_limit, i1 noundef zeroext %mask_to_left) #0 {
entry:
  %retval = alloca i32, align 4
  %ptr_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %alu_limit.addr = alloca i32*, align 8
  %mask_to_left.addr = alloca i8, align 1
  %max = alloca i32, align 4
  %ptr_limit = alloca i32, align 4
  store %struct.bpf_reg_state* %ptr_reg, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  store i32* %alu_limit, i32** %alu_limit.addr, align 8
  %frombool = zext i1 %mask_to_left to i8
  store i8 %frombool, i8* %mask_to_left.addr, align 1
  store i32 0, i32* %max, align 4
  store i32 0, i32* %ptr_limit, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  switch i32 %1, label %sw.default [
    i32 6, label %sw.bb
    i32 4, label %sw.bb4
  ]

sw.bb:                                            ; preds = %entry
  %2 = load i8, i8* %mask_to_left.addr, align 1
  %tobool = trunc i8 %2 to i1
  %conv = zext i1 %tobool to i32
  %add = add i32 512, %conv
  store i32 %add, i32* %max, align 4
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %4 = load i64, i64* %value, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 1
  %6 = load i32, i32* %off, align 4
  %conv1 = sext i32 %6 to i64
  %add2 = add i64 %4, %conv1
  %sub = sub i64 0, %add2
  %conv3 = trunc i64 %sub to i32
  store i32 %conv3, i32* %ptr_limit, align 4
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 2
  %9 = bitcast %union.anon.168* %8 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %9, i32 0, i32 0
  %10 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %10, i32 0, i32 5
  %11 = load i32, i32* %value_size, align 32
  store i32 %11, i32* %max, align 4
  %12 = load i8, i8* %mask_to_left.addr, align 1
  %tobool5 = trunc i8 %12 to i1
  br i1 %tobool5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 6
  %14 = load i64, i64* %smin_value, align 8
  br label %cond.end

cond.false:                                       ; preds = %sw.bb4
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 9
  %16 = load i64, i64* %umax_value, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %14, %cond.true ], [ %16, %cond.false ]
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 1
  %18 = load i32, i32* %off7, align 4
  %conv8 = sext i32 %18 to i64
  %add9 = add i64 %cond, %conv8
  %conv10 = trunc i64 %add9 to i32
  store i32 %conv10, i32* %ptr_limit, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store i32 -2, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %cond.end, %sw.bb
  %19 = load i32, i32* %ptr_limit, align 4
  %20 = load i32, i32* %max, align 4
  %cmp = icmp uge i32 %19, %20
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.epilog
  store i32 -4, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %sw.epilog
  %21 = load i32, i32* %ptr_limit, align 4
  %22 = load i32*, i32** %alu_limit.addr, align 8
  store i32 %21, i32* %22, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then, %sw.default
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_verifier_state* @sanitize_speculative_path(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32 noundef %next_idx, i32 noundef %curr_idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %next_idx.addr = alloca i32, align 4
  %curr_idx.addr = alloca i32, align 4
  %branch = alloca %struct.bpf_verifier_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32 %next_idx, i32* %next_idx.addr, align 4
  store i32 %curr_idx, i32* %curr_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %next_idx.addr, align 4
  %2 = load i32, i32* %curr_idx.addr, align 4
  %call = call %struct.bpf_verifier_state* @push_stack(%struct.bpf_verifier_env* noundef %0, i32 noundef %1, i32 noundef %2, i1 noundef zeroext true) #20
  store %struct.bpf_verifier_state* %call, %struct.bpf_verifier_state** %branch, align 8
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %branch, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %3, null
  br i1 %tobool, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %entry
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %tobool1 = icmp ne %struct.bpf_insn* %4, null
  br i1 %tobool1, label %if.then, label %if.end19

if.then:                                          ; preds = %land.lhs.true
  %5 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %branch, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %5, i32 0, i32 0
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %branch, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 4
  %7 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %7 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %regs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs2, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 0
  %10 = load i8, i8* %code, align 4
  %conv = zext i8 %10 to i32
  %and = and i32 %conv, 8
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv5 = zext i8 %bf.clear to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %11, %struct.bpf_reg_state* noundef %12, i32 noundef %conv5) #20
  br label %if.end18

if.else:                                          ; preds = %if.then
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %14, i32 0, i32 0
  %15 = load i8, i8* %code6, align 4
  %conv7 = zext i8 %15 to i32
  %and8 = and i32 %conv7, 8
  %cmp9 = icmp eq i32 %and8, 8
  br i1 %cmp9, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.else
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg12 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 1
  %bf.load13 = load i8, i8* %dst_reg12, align 1
  %bf.clear14 = and i8 %bf.load13, 15
  %conv15 = zext i8 %bf.clear14 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %16, %struct.bpf_reg_state* noundef %17, i32 noundef %conv15) #20
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %21 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %21, i32 0, i32 1
  %bf.load16 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load16, 4
  %conv17 = zext i8 %bf.lshr to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %19, %struct.bpf_reg_state* noundef %20, i32 noundef %conv17) #20
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.else
  br label %if.end18

if.end18:                                         ; preds = %if.end, %if.then4
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %land.lhs.true, %entry
  %22 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %branch, align 8
  ret %struct.bpf_verifier_state* %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_verifier_state* @push_stack(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %prev_insn_idx, i1 noundef zeroext %speculative) #0 {
entry:
  %retval = alloca %struct.bpf_verifier_state*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %prev_insn_idx.addr = alloca i32, align 4
  %speculative.addr = alloca i8, align 1
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %elem = alloca %struct.bpf_verifier_stack_elem*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %prev_insn_idx, i32* %prev_insn_idx.addr, align 4
  %frombool = zext i1 %speculative to i8
  store i8 %frombool, i8* %speculative.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %call = call noalias i8* @kzalloc(i64 noundef 144, i32 noundef 3264) #24
  %2 = bitcast i8* %call to %struct.bpf_verifier_stack_elem*
  store %struct.bpf_verifier_stack_elem* %2, %struct.bpf_verifier_stack_elem** %elem, align 8
  %3 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %tobool = icmp ne %struct.bpf_verifier_stack_elem* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %err28

if.end:                                           ; preds = %entry
  %4 = load i32, i32* %insn_idx.addr, align 4
  %5 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %insn_idx1 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %5, i32 0, i32 1
  store i32 %4, i32* %insn_idx1, align 8
  %6 = load i32, i32* %prev_insn_idx.addr, align 4
  %7 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %prev_insn_idx2 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %7, i32 0, i32 2
  store i32 %6, i32* %prev_insn_idx2, align 4
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 4
  %9 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %10 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %10, i32 0, i32 3
  store %struct.bpf_verifier_stack_elem* %9, %struct.bpf_verifier_stack_elem** %next, align 8
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 26
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 3
  %12 = load i32, i32* %len_used, align 8
  %13 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %log_pos = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %13, i32 0, i32 4
  store i32 %12, i32* %log_pos, align 8
  %14 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 4
  store %struct.bpf_verifier_stack_elem* %14, %struct.bpf_verifier_stack_elem** %head3, align 8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 5
  %17 = load i32, i32* %stack_size, align 8
  %inc = add i32 %17, 1
  store i32 %inc, i32* %stack_size, align 8
  %18 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %18, i32 0, i32 0
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call4 = call i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %st, %struct.bpf_verifier_state* noundef %19) #20
  store i32 %call4, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool5 = icmp ne i32 %20, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  br label %err28

if.end7:                                          ; preds = %if.end
  %21 = load i8, i8* %speculative.addr, align 1
  %tobool8 = trunc i8 %21 to i1
  %conv = zext i1 %tobool8 to i32
  %22 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st9 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %22, i32 0, i32 0
  %speculative10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st9, i32 0, i32 6
  %23 = load i8, i8* %speculative10, align 8
  %tobool11 = trunc i8 %23 to i1
  %conv12 = zext i1 %tobool11 to i32
  %or = or i32 %conv12, %conv
  %tobool13 = icmp ne i32 %or, 0
  %frombool14 = zext i1 %tobool13 to i8
  store i8 %frombool14, i8* %speculative10, align 8
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size15 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 5
  %25 = load i32, i32* %stack_size15, align 8
  %cmp = icmp sgt i32 %25, 8192
  br i1 %cmp, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end7
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size18 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 5
  %29 = load i32, i32* %stack_size18, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.340, i64 0, i64 0), i32 noundef %29) #20
  br label %err28

if.end19:                                         ; preds = %if.end7
  %30 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st20 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %30, i32 0, i32 0
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st20, i32 0, i32 1
  %31 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  %tobool21 = icmp ne %struct.bpf_verifier_state* %31, null
  br i1 %tobool21, label %if.then22, label %if.end26

if.then22:                                        ; preds = %if.end19
  %32 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st23 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %32, i32 0, i32 0
  %parent24 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st23, i32 0, i32 1
  %33 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent24, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %33, i32 0, i32 2
  %34 = load i32, i32* %branches, align 8
  %inc25 = add i32 %34, 1
  store i32 %inc25, i32* %branches, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then22, %if.end19
  %35 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st27 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %35, i32 0, i32 0
  store %struct.bpf_verifier_state* %st27, %struct.bpf_verifier_state** %retval, align 8
  br label %return

err28:                                            ; preds = %if.then17, %if.then6, %if.then
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %36, i32 0, i32 8
  %37 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state29, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %37, i1 noundef zeroext true) #20
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %38, i32 0, i32 8
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %cur_state30, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %err28
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call31 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %39, i32* noundef null, i32* noundef null, i1 noundef zeroext false) #20
  %tobool32 = icmp ne i32 %call31, 0
  %lnot = xor i1 %tobool32, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond, !llvm.loop !143

while.end:                                        ; preds = %while.cond
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.end26
  %40 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %retval, align 8
  ret %struct.bpf_verifier_state* %40
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_access_for_ptr_arithmetic(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, %struct.bpf_reg_state* noundef %reg, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off.addr = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #20
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %9, i64 %11) #20
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %regno.addr, align 4
  %arraydecay3 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %15 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([67 x i8], [67 x i8]* @.str.342, i64 0, i64 0), i32 noundef %14, i8* noundef %arraydecay3, i32 noundef %15) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %16 = load i32, i32* %off.addr, align 4
  %cmp = icmp sge i32 %16, 0
  br i1 %cmp, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %17 = load i32, i32* %off.addr, align 4
  %cmp4 = icmp slt i32 %17, -512
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %regno.addr, align 4
  %21 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([78 x i8], [78 x i8]* @.str.343, i64 0, i64 0), i32 noundef %20, i32 noundef %21) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_scratched(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %shl = shl i32 1, %0
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %scratched_regs = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 42
  %2 = load i32, i32* %scratched_regs, align 8
  %or = or i32 %2, %shl
  store i32 %or, i32* %scratched_regs, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32 noundef %regno, %struct.bpf_reg_state* noundef %reg, i32 noundef %t) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %regno.addr = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %t.addr = alloca i32, align 4
  %code = alloca i8, align 1
  %class = alloca i8, align 1
  %op = alloca i8, align 1
  %mode = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code1, align 4
  store i8 %1, i8* %code, align 1
  %2 = load i8, i8* %code, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 7
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %class, align 1
  %3 = load i8, i8* %code, align 1
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 240
  %conv5 = trunc i32 %and4 to i8
  store i8 %conv5, i8* %op, align 1
  %4 = load i8, i8* %class, align 1
  %conv6 = zext i8 %4 to i32
  %cmp = icmp eq i32 %conv6, 5
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  %5 = load i8, i8* %op, align 1
  %conv8 = zext i8 %5 to i32
  %cmp9 = icmp eq i32 %conv8, 144
  br i1 %cmp9, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %if.then
  %6 = load i8, i8* %op, align 1
  %conv12 = zext i8 %6 to i32
  %cmp13 = icmp eq i32 %conv12, 128
  br i1 %cmp13, label %if.then15, label %if.end25

if.then15:                                        ; preds = %if.end
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv16 = zext i8 %bf.lshr to i32
  %cmp17 = icmp eq i32 %conv16, 1
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.then15
  store i1 false, i1* %retval, align 1
  br label %return

if.end20:                                         ; preds = %if.then15
  %8 = load i32, i32* %t.addr, align 4
  %cmp21 = icmp eq i32 %8, 0
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  store i1 true, i1* %retval, align 1
  br label %return

if.end24:                                         ; preds = %if.end20
  store i1 false, i1* %retval, align 1
  br label %return

if.end25:                                         ; preds = %if.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %9 = load i8, i8* %class, align 1
  %conv27 = zext i8 %9 to i32
  %cmp28 = icmp eq i32 %conv27, 7
  br i1 %cmp28, label %if.then43, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end26
  %10 = load i8, i8* %class, align 1
  %conv30 = zext i8 %10 to i32
  %cmp31 = icmp eq i32 %conv30, 5
  br i1 %cmp31, label %if.then43, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %lor.lhs.false
  %11 = load i8, i8* %class, align 1
  %conv34 = zext i8 %11 to i32
  %cmp35 = icmp eq i32 %conv34, 4
  br i1 %cmp35, label %land.lhs.true, label %if.end44

land.lhs.true:                                    ; preds = %lor.lhs.false33
  %12 = load i8, i8* %op, align 1
  %conv37 = zext i8 %12 to i32
  %cmp38 = icmp eq i32 %conv37, 208
  br i1 %cmp38, label %land.lhs.true40, label %if.end44

land.lhs.true40:                                  ; preds = %land.lhs.true
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 3
  %14 = load i32, i32* %imm, align 4
  %cmp41 = icmp eq i32 %14, 64
  br i1 %cmp41, label %if.then43, label %if.end44

if.then43:                                        ; preds = %land.lhs.true40, %lor.lhs.false, %if.end26
  store i1 true, i1* %retval, align 1
  br label %return

if.end44:                                         ; preds = %land.lhs.true40, %land.lhs.true, %lor.lhs.false33
  %15 = load i8, i8* %class, align 1
  %conv45 = zext i8 %15 to i32
  %cmp46 = icmp eq i32 %conv45, 4
  br i1 %cmp46, label %if.then52, label %lor.lhs.false48

lor.lhs.false48:                                  ; preds = %if.end44
  %16 = load i8, i8* %class, align 1
  %conv49 = zext i8 %16 to i32
  %cmp50 = icmp eq i32 %conv49, 6
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %lor.lhs.false48, %if.end44
  store i1 false, i1* %retval, align 1
  br label %return

if.end53:                                         ; preds = %lor.lhs.false48
  %17 = load i8, i8* %class, align 1
  %conv54 = zext i8 %17 to i32
  %cmp55 = icmp eq i32 %conv54, 1
  br i1 %cmp55, label %if.then57, label %if.end66

if.then57:                                        ; preds = %if.end53
  %18 = load i32, i32* %t.addr, align 4
  %cmp58 = icmp ne i32 %18, 0
  br i1 %cmp58, label %if.then60, label %if.end65

if.then60:                                        ; preds = %if.then57
  %19 = load i8, i8* %code, align 1
  %conv61 = zext i8 %19 to i32
  %and62 = and i32 %conv61, 24
  %cmp63 = icmp eq i32 %and62, 24
  store i1 %cmp63, i1* %retval, align 1
  br label %return

if.end65:                                         ; preds = %if.then57
  store i1 true, i1* %retval, align 1
  br label %return

if.end66:                                         ; preds = %if.end53
  %20 = load i8, i8* %class, align 1
  %conv67 = zext i8 %20 to i32
  %cmp68 = icmp eq i32 %conv67, 3
  br i1 %cmp68, label %if.then70, label %if.end82

if.then70:                                        ; preds = %if.end66
  %21 = load i32, i32* %t.addr, align 4
  %cmp71 = icmp eq i32 %21, 0
  br i1 %cmp71, label %land.lhs.true73, label %if.end77

land.lhs.true73:                                  ; preds = %if.then70
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 0
  %23 = load i32, i32* %type, align 8
  %cmp74 = icmp ne i32 %23, 1
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %land.lhs.true73
  store i1 true, i1* %retval, align 1
  br label %return

if.end77:                                         ; preds = %land.lhs.true73, %if.then70
  %24 = load i8, i8* %code, align 1
  %conv78 = zext i8 %24 to i32
  %and79 = and i32 %conv78, 24
  %cmp80 = icmp eq i32 %and79, 24
  store i1 %cmp80, i1* %retval, align 1
  br label %return

if.end82:                                         ; preds = %if.end66
  %25 = load i8, i8* %class, align 1
  %conv83 = zext i8 %25 to i32
  %cmp84 = icmp eq i32 %conv83, 0
  br i1 %cmp84, label %if.then86, label %if.end103

if.then86:                                        ; preds = %if.end82
  %26 = load i8, i8* %code, align 1
  %conv87 = zext i8 %26 to i32
  %and88 = and i32 %conv87, 224
  %conv89 = trunc i32 %and88 to i8
  store i8 %conv89, i8* %mode, align 1
  %27 = load i8, i8* %mode, align 1
  %conv90 = zext i8 %27 to i32
  %cmp91 = icmp eq i32 %conv90, 0
  br i1 %cmp91, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.then86
  store i1 true, i1* %retval, align 1
  br label %return

if.end94:                                         ; preds = %if.then86
  %28 = load i32, i32* %t.addr, align 4
  %cmp95 = icmp ne i32 %28, 0
  br i1 %cmp95, label %if.then97, label %if.end98

if.then97:                                        ; preds = %if.end94
  store i1 false, i1* %retval, align 1
  br label %return

if.end98:                                         ; preds = %if.end94
  %29 = load i32, i32* %regno.addr, align 4
  %cmp99 = icmp eq i32 %29, 6
  br i1 %cmp99, label %if.then101, label %if.end102

if.then101:                                       ; preds = %if.end98
  store i1 true, i1* %retval, align 1
  br label %return

if.end102:                                        ; preds = %if.end98
  store i1 true, i1* %retval, align 1
  br label %return

if.end103:                                        ; preds = %if.end82
  %30 = load i8, i8* %class, align 1
  %conv104 = zext i8 %30 to i32
  %cmp105 = icmp eq i32 %conv104, 2
  br i1 %cmp105, label %if.then107, label %if.end108

if.then107:                                       ; preds = %if.end103
  store i1 true, i1* %retval, align 1
  br label %return

if.end108:                                        ; preds = %if.end103
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end108, %if.then107, %if.end102, %if.then101, %if.then97, %if.then93, %if.end77, %if.then76, %if.end65, %if.then60, %if.then52, %if.then43, %if.end24, %if.then23, %if.then19, %if.then11
  %31 = load i1, i1* %retval, align 1
  ret i1 %31
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_mismatch_ok(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %call = call i32 @base_type(i32 noundef %0) #20
  switch i32 %call, label %sw.default [
    i32 2, label %sw.bb
    i32 11, label %sw.bb
    i32 12, label %sw.bb
    i32 13, label %sw.bb
    i32 15, label %sw.bb
    i32 16, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry
  store i1 false, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_pkt_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %3) #20
  ret i1 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_flow_key_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %3, 10
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_sk_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @type_is_sk_pointer(i32 noundef %3) #20
  ret i1 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_func_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx, i32 noundef %subprog, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* noundef %set_callee_state_cb) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %subprog.addr = alloca i32, align 4
  %set_callee_state_cb.addr = alloca i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)*, align 8
  %state = alloca %struct.bpf_verifier_state*, align 8
  %func_info_aux = alloca %struct.bpf_func_info_aux*, align 8
  %caller = alloca %struct.bpf_func_state*, align 8
  %callee = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  %is_global = alloca i8, align 1
  %async_cb = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  store i32 %subprog, i32* %subprog.addr, align 4
  store i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)* %set_callee_state_cb, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)** %set_callee_state_cb.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %state, align 8
  store i8 0, i8* %is_global, align 1
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe, align 8
  %add = add i32 %3, 1
  %cmp = icmp uge i32 %add, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 4
  %7 = load i32, i32* %curframe1, align 8
  %add2 = add i32 %7, 2
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.351, i64 0, i64 0), i32 noundef %add2) #20
  store i32 -7, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 0
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %9, i32 0, i32 4
  %10 = load i32, i32* %curframe3, align 8
  %idxprom = zext i32 %10 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %11, %struct.bpf_func_state** %caller, align 8
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 0
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe5 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 4
  %14 = load i32, i32* %curframe5, align 8
  %add6 = add i32 %14, 1
  %idxprom7 = zext i32 %add6 to i64
  %arrayidx8 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame4, i64 0, i64 %idxprom7
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx8, align 8
  %tobool = icmp ne %struct.bpf_func_state* %15, null
  br i1 %tobool, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 4
  %19 = load i32, i32* %curframe10, align 8
  %add11 = add i32 %19, 1
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.352, i64 0, i64 0), i32 noundef %add11) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 2
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 10
  %22 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_aux13 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %22, i32 0, i32 52
  %23 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux13, align 8
  store %struct.bpf_func_info_aux* %23, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %24 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %tobool14 = icmp ne %struct.bpf_func_info_aux* %24, null
  br i1 %tobool14, label %if.then15, label %if.end20

if.then15:                                        ; preds = %if.end12
  %25 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %26 = load i32, i32* %subprog.addr, align 4
  %idxprom16 = sext i32 %26 to i64
  %arrayidx17 = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %25, i64 %idxprom16
  %linkage = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx17, i32 0, i32 0
  %27 = load i16, i16* %linkage, align 2
  %conv = zext i16 %27 to i32
  %cmp18 = icmp eq i32 %conv, 1
  %frombool = zext i1 %cmp18 to i8
  store i8 %frombool, i8* %is_global, align 1
  br label %if.end20

if.end20:                                         ; preds = %if.then15, %if.end12
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load i32, i32* %subprog.addr, align 4
  %30 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %30, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %call = call i32 @btf_check_subprog_call(%struct.bpf_verifier_env* noundef %28, i32 noundef %29, %struct.bpf_reg_state* noundef %arraydecay) #20
  store i32 %call, i32* %err, align 4
  %31 = load i32, i32* %err, align 4
  %cmp21 = icmp eq i32 %31, -14
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  %32 = load i32, i32* %err, align 4
  store i32 %32, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end20
  %33 = load i8, i8* %is_global, align 1
  %tobool25 = trunc i8 %33 to i1
  br i1 %tobool25, label %if.then26, label %if.end38

if.then26:                                        ; preds = %if.end24
  %34 = load i32, i32* %err, align 4
  %tobool27 = icmp ne i32 %34, 0
  br i1 %tobool27, label %if.then28, label %if.else

if.then28:                                        ; preds = %if.then26
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load i32, i32* %subprog.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.353, i64 0, i64 0), i32 noundef %37) #20
  %38 = load i32, i32* %err, align 4
  store i32 %38, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.then26
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %39, i32 0, i32 26
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %40 = load i32, i32* %level, align 8
  %and = and i32 %40, 3
  %tobool29 = icmp ne i32 %and, 0
  br i1 %tobool29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.else
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load i32, i32* %subprog.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.354, i64 0, i64 0), i32 noundef %43) #20
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %if.else
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs32 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %45, i32 0, i32 0
  %arraydecay33 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs32, i64 0, i64 0
  call void @clear_caller_saved_regs(%struct.bpf_verifier_env* noundef %44, %struct.bpf_reg_state* noundef %arraydecay33) #20
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs34 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %47, i32 0, i32 0
  %arraydecay35 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs34, i64 0, i64 0
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %46, %struct.bpf_reg_state* noundef %arraydecay35, i32 noundef 0) #20
  %48 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs36 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %48, i32 0, i32 0
  %arrayidx37 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs36, i64 0, i64 0
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx37, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.end24
  %49 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %49, i32 0, i32 0
  %50 = load i8, i8* %code, align 4
  %conv39 = zext i8 %50 to i32
  %cmp40 = icmp eq i32 %conv39, 133
  br i1 %cmp40, label %land.lhs.true, label %if.end73

land.lhs.true:                                    ; preds = %if.end38
  %51 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %51, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv42 = zext i8 %bf.lshr to i32
  %cmp43 = icmp eq i32 %conv42, 0
  br i1 %cmp43, label %land.lhs.true45, label %if.end73

land.lhs.true45:                                  ; preds = %land.lhs.true
  %52 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %52, i32 0, i32 3
  %53 = load i32, i32* %imm, align 4
  %cmp46 = icmp eq i32 %53, 170
  br i1 %cmp46, label %if.then48, label %if.end73

if.then48:                                        ; preds = %land.lhs.true45
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %54, i32 0, i32 27
  %55 = load i32, i32* %subprog.addr, align 4
  %idxprom49 = sext i32 %55 to i64
  %arrayidx50 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom49
  %is_async_cb = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx50, i32 0, i32 6
  store i8 1, i8* %is_async_cb, align 1
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info51 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %57, i32 0, i32 27
  %58 = load i32, i32* %subprog.addr, align 4
  %idxprom52 = sext i32 %58 to i64
  %arrayidx53 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info51, i64 0, i64 %idxprom52
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx53, i32 0, i32 0
  %59 = load i32, i32* %start, align 8
  %60 = load i32*, i32** %insn_idx.addr, align 8
  %61 = load i32, i32* %60, align 4
  %62 = load i32, i32* %subprog.addr, align 4
  %call54 = call %struct.bpf_verifier_state* @push_async_cb(%struct.bpf_verifier_env* noundef %56, i32 noundef %59, i32 noundef %61, i32 noundef %62) #20
  store %struct.bpf_verifier_state* %call54, %struct.bpf_verifier_state** %async_cb, align 8
  %63 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %async_cb, align 8
  %tobool55 = icmp ne %struct.bpf_verifier_state* %63, null
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %if.then48
  store i32 -14, i32* %retval, align 4
  br label %return

if.end57:                                         ; preds = %if.then48
  %64 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %async_cb, align 8
  %frame58 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %64, i32 0, i32 0
  %arrayidx59 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame58, i64 0, i64 0
  %65 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx59, align 8
  store %struct.bpf_func_state* %65, %struct.bpf_func_state** %callee, align 8
  %66 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %async_entry_cnt = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %66, i32 0, i32 4
  %67 = load i32, i32* %async_entry_cnt, align 4
  %add60 = add i32 %67, 1
  %68 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %async_entry_cnt61 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %68, i32 0, i32 4
  store i32 %add60, i32* %async_entry_cnt61, align 4
  %69 = load i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)*, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)** %set_callee_state_cb.addr, align 8
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %72 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %73 = load i32*, i32** %insn_idx.addr, align 8
  %74 = load i32, i32* %73, align 4
  %call62 = call i32 %69(%struct.bpf_verifier_env* noundef %70, %struct.bpf_func_state* noundef %71, %struct.bpf_func_state* noundef %72, i32 noundef %74) #20
  store i32 %call62, i32* %err, align 4
  %75 = load i32, i32* %err, align 4
  %tobool63 = icmp ne i32 %75, 0
  br i1 %tobool63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.end57
  %76 = load i32, i32* %err, align 4
  store i32 %76, i32* %retval, align 4
  br label %return

if.end65:                                         ; preds = %if.end57
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %78 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs66 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %78, i32 0, i32 0
  %arraydecay67 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs66, i64 0, i64 0
  call void @clear_caller_saved_regs(%struct.bpf_verifier_env* noundef %77, %struct.bpf_reg_state* noundef %arraydecay67) #20
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %80 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs68 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %80, i32 0, i32 0
  %arraydecay69 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs68, i64 0, i64 0
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %79, %struct.bpf_reg_state* noundef %arraydecay69, i32 noundef 0) #20
  %81 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs70 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %81, i32 0, i32 0
  %arrayidx71 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs70, i64 0, i64 0
  %subreg_def72 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx71, i32 0, i32 16
  store i32 0, i32* %subreg_def72, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end73:                                         ; preds = %land.lhs.true45, %land.lhs.true, %if.end38
  %call74 = call noalias i8* @kzalloc(i64 noundef 1392, i32 noundef 3264) #24
  %82 = bitcast i8* %call74 to %struct.bpf_func_state*
  store %struct.bpf_func_state* %82, %struct.bpf_func_state** %callee, align 8
  %83 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %tobool75 = icmp ne %struct.bpf_func_state* %83, null
  br i1 %tobool75, label %if.end77, label %if.then76

if.then76:                                        ; preds = %if.end73
  store i32 -12, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %if.end73
  %84 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %85 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame78 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %85, i32 0, i32 0
  %86 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe79 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %86, i32 0, i32 4
  %87 = load i32, i32* %curframe79, align 8
  %add80 = add i32 %87, 1
  %idxprom81 = zext i32 %add80 to i64
  %arrayidx82 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame78, i64 0, i64 %idxprom81
  store %struct.bpf_func_state* %84, %struct.bpf_func_state** %arrayidx82, align 8
  %88 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %89 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %90 = load i32*, i32** %insn_idx.addr, align 8
  %91 = load i32, i32* %90, align 4
  %92 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe83 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %92, i32 0, i32 4
  %93 = load i32, i32* %curframe83, align 8
  %add84 = add i32 %93, 1
  %94 = load i32, i32* %subprog.addr, align 4
  call void @init_func_state(%struct.bpf_verifier_env* noundef %88, %struct.bpf_func_state* noundef %89, i32 noundef %91, i32 noundef %add84, i32 noundef %94) #20
  %95 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %96 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %call85 = call i32 @copy_reference_state(%struct.bpf_func_state* noundef %95, %struct.bpf_func_state* noundef %96) #20
  store i32 %call85, i32* %err, align 4
  %97 = load i32, i32* %err, align 4
  %tobool86 = icmp ne i32 %97, 0
  br i1 %tobool86, label %if.then87, label %if.end88

if.then87:                                        ; preds = %if.end77
  br label %err_out

if.end88:                                         ; preds = %if.end77
  %98 = load i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)*, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*, i32)** %set_callee_state_cb.addr, align 8
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %100 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %101 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %102 = load i32*, i32** %insn_idx.addr, align 8
  %103 = load i32, i32* %102, align 4
  %call89 = call i32 %98(%struct.bpf_verifier_env* noundef %99, %struct.bpf_func_state* noundef %100, %struct.bpf_func_state* noundef %101, i32 noundef %103) #20
  store i32 %call89, i32* %err, align 4
  %104 = load i32, i32* %err, align 4
  %tobool90 = icmp ne i32 %104, 0
  br i1 %tobool90, label %if.then91, label %if.end92

if.then91:                                        ; preds = %if.end88
  br label %err_out

if.end92:                                         ; preds = %if.end88
  %105 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %106 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs93 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %106, i32 0, i32 0
  %arraydecay94 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs93, i64 0, i64 0
  call void @clear_caller_saved_regs(%struct.bpf_verifier_env* noundef %105, %struct.bpf_reg_state* noundef %arraydecay94) #20
  %107 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe95 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %107, i32 0, i32 4
  %108 = load i32, i32* %curframe95, align 8
  %inc = add i32 %108, 1
  store i32 %inc, i32* %curframe95, align 8
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info96 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %109, i32 0, i32 27
  %110 = load i32, i32* %subprog.addr, align 4
  %idxprom97 = sext i32 %110 to i64
  %arrayidx98 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info96, i64 0, i64 %idxprom97
  %start99 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx98, i32 0, i32 0
  %111 = load i32, i32* %start99, align 8
  %sub = sub i32 %111, 1
  %112 = load i32*, i32** %insn_idx.addr, align 8
  store i32 %sub, i32* %112, align 4
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log100 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %113, i32 0, i32 26
  %level101 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log100, i32 0, i32 0
  %114 = load i32, i32* %level101, align 8
  %and102 = and i32 %114, 3
  %tobool103 = icmp ne i32 %and102, 0
  br i1 %tobool103, label %if.then104, label %if.end105

if.then104:                                       ; preds = %if.end92
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %116 = bitcast %struct.bpf_verifier_env* %115 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %116, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.355, i64 0, i64 0)) #20
  %117 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %118 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %117, %struct.bpf_func_state* noundef %118, i1 noundef zeroext true) #20
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %120 = bitcast %struct.bpf_verifier_env* %119 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %120, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.356, i64 0, i64 0)) #20
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %122 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %121, %struct.bpf_func_state* noundef %122, i1 noundef zeroext true) #20
  br label %if.end105

if.end105:                                        ; preds = %if.then104, %if.end92
  store i32 0, i32* %retval, align 4
  br label %return

err_out:                                          ; preds = %if.then91, %if.then87
  %123 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %123) #20
  %124 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame106 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %124, i32 0, i32 0
  %125 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe107 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %125, i32 0, i32 4
  %126 = load i32, i32* %curframe107, align 8
  %add108 = add i32 %126, 1
  %idxprom109 = zext i32 %add108 to i64
  %arrayidx110 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame106, i64 0, i64 %idxprom109
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx110, align 8
  %127 = load i32, i32* %err, align 4
  store i32 %127, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_out, %if.end105, %if.then76, %if.end65, %if.then64, %if.then56, %if.end31, %if.then28, %if.then23, %if.then9, %if.then
  %128 = load i32, i32* %retval, align 4
  ret i32 %128
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @set_callee_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %caller, %struct.bpf_func_state* noundef %callee, i32 noundef %insn_idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %caller.addr = alloca %struct.bpf_func_state*, align 8
  %callee.addr = alloca %struct.bpf_func_state*, align 8
  %insn_idx.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %caller, %struct.bpf_func_state** %caller.addr, align 8
  store %struct.bpf_func_state* %callee, %struct.bpf_func_state** %callee.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %2 = load i32, i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 0
  %4 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %4 to i64
  %arrayidx3 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 %idxprom2
  %5 = bitcast %struct.bpf_reg_state* %arrayidx to i8*
  %6 = bitcast %struct.bpf_reg_state* %arrayidx3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* align 8 %6, i64 120, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !144

for.end:                                          ; preds = %for.cond
  ret i32 0
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_check_subprog_call(%struct.bpf_verifier_env* noundef, i32 noundef, %struct.bpf_reg_state* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clear_caller_saved_regs(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %1, %struct.bpf_reg_state* noundef %2, i32 noundef %4) #20
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom1 = sext i32 %6 to i64
  %arrayidx2 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom1
  %7 = load i32, i32* %arrayidx2, align 4
  %call = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %5, i32 noundef %7, i32 noundef 2) #20
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !145

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_verifier_state* @push_async_cb(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %prev_insn_idx, i32 noundef %subprog) #0 {
entry:
  %retval = alloca %struct.bpf_verifier_state*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %prev_insn_idx.addr = alloca i32, align 4
  %subprog.addr = alloca i32, align 4
  %elem = alloca %struct.bpf_verifier_stack_elem*, align 8
  %frame = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %prev_insn_idx, i32* %prev_insn_idx.addr, align 4
  store i32 %subprog, i32* %subprog.addr, align 4
  %call = call noalias i8* @kzalloc(i64 noundef 144, i32 noundef 3264) #24
  %0 = bitcast i8* %call to %struct.bpf_verifier_stack_elem*
  store %struct.bpf_verifier_stack_elem* %0, %struct.bpf_verifier_stack_elem** %elem, align 8
  %1 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %tobool = icmp ne %struct.bpf_verifier_stack_elem* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %err

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %insn_idx.addr, align 4
  %3 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %insn_idx1 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %3, i32 0, i32 1
  store i32 %2, i32* %insn_idx1, align 8
  %4 = load i32, i32* %prev_insn_idx.addr, align 4
  %5 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %prev_insn_idx2 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %5, i32 0, i32 2
  store i32 %4, i32* %prev_insn_idx2, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 4
  %7 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %8 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %8, i32 0, i32 3
  store %struct.bpf_verifier_stack_elem* %7, %struct.bpf_verifier_stack_elem** %next, align 8
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 26
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 3
  %10 = load i32, i32* %len_used, align 8
  %11 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %log_pos = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %11, i32 0, i32 4
  store i32 %10, i32* %log_pos, align 8
  %12 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 4
  store %struct.bpf_verifier_stack_elem* %12, %struct.bpf_verifier_stack_elem** %head3, align 8
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 5
  %15 = load i32, i32* %stack_size, align 8
  %inc = add i32 %15, 1
  store i32 %inc, i32* %stack_size, align 8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 5
  %17 = load i32, i32* %stack_size4, align 8
  %cmp = icmp sgt i32 %17, 8192
  br i1 %cmp, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 5
  %21 = load i32, i32* %stack_size6, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.357, i64 0, i64 0), i32 noundef %21) #20
  br label %err

if.end7:                                          ; preds = %if.end
  %22 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %22, i32 0, i32 0
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st, i32 0, i32 2
  store i32 1, i32* %branches, align 8
  %call8 = call noalias i8* @kzalloc(i64 noundef 1392, i32 noundef 3264) #24
  %23 = bitcast i8* %call8 to %struct.bpf_func_state*
  store %struct.bpf_func_state* %23, %struct.bpf_func_state** %frame, align 8
  %24 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %tobool9 = icmp ne %struct.bpf_func_state* %24, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end7
  br label %err

if.end11:                                         ; preds = %if.end7
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %27 = load i32, i32* %subprog.addr, align 4
  call void @init_func_state(%struct.bpf_verifier_env* noundef %25, %struct.bpf_func_state* noundef %26, i32 noundef -1, i32 noundef 0, i32 noundef %27) #20
  %28 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame, align 8
  %29 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st12 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %29, i32 0, i32 0
  %frame13 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st12, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame13, i64 0, i64 0
  store %struct.bpf_func_state* %28, %struct.bpf_func_state** %arrayidx, align 8
  %30 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st14 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %30, i32 0, i32 0
  store %struct.bpf_verifier_state* %st14, %struct.bpf_verifier_state** %retval, align 8
  br label %return

err:                                              ; preds = %if.then10, %if.then5, %if.then
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 8
  %32 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %32, i1 noundef zeroext true) #20
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state15 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 8
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %cur_state15, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %err
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call16 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %34, i32* noundef null, i32* noundef null, i1 noundef zeroext false) #20
  %tobool17 = icmp ne i32 %call16, 0
  %lnot = xor i1 %tobool17, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond, !llvm.loop !146

while.end:                                        ; preds = %while.cond
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.end11
  %35 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %retval, align 8
  ret %struct.bpf_verifier_state* %35
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32* @btf_kfunc_id_set_contains(%struct.btf* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_check_kfunc_arg_match(%struct.bpf_verifier_env* noundef, %struct.btf* noundef, i32 noundef, %struct.bpf_reg_state* noundef, %struct.bpf_kfunc_arg_meta* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @release_reference(%struct.bpf_verifier_env* noundef %env, i32 noundef %ref_obj_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ref_obj_id.addr = alloca i32, align 4
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  %___vstate = alloca %struct.bpf_verifier_state*, align 8
  %___i = alloca i32, align 4
  %___j = alloca i32, align 4
  %___regs = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %ref_obj_id, i32* %ref_obj_id.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #20
  %1 = load i32, i32* %ref_obj_id.addr, align 4
  %call1 = call i32 @release_reference_state(%struct.bpf_func_state* noundef %call, i32 noundef %1) #20
  store i32 %call1, i32* %err, align 4
  %2 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %err, align 4
  store i32 %3, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 8
  %5 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %5, %struct.bpf_verifier_state** %___vstate, align 8
  store i32 0, i32* %___i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc66, %if.end
  %6 = load i32, i32* %___i, align 4
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %___vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 4
  %8 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %6, %8
  br i1 %cmp, label %for.body, label %for.end68

for.body:                                         ; preds = %for.cond
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %___vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %9, i32 0, i32 0
  %10 = load i32, i32* %___i, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %11, %struct.bpf_func_state** %state, align 8
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %___regs, align 8
  store i32 0, i32* %___j, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %13 = load i32, i32* %___j, align 4
  %cmp3 = icmp slt i32 %13, 11
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond2
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %___regs, align 8
  %15 = load i32, i32* %___j, align 4
  %idxprom5 = sext i32 %15 to i64
  %arrayidx6 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i64 %idxprom5
  store %struct.bpf_reg_state* %arrayidx6, %struct.bpf_reg_state** %reg, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 4
  %17 = load i32, i32* %ref_obj_id7, align 4
  %18 = load i32, i32* %ref_obj_id.addr, align 4
  %cmp8 = icmp eq i32 %17, %18
  br i1 %cmp8, label %if.then9, label %if.end13

if.then9:                                         ; preds = %for.body4
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 17
  %20 = load i8, i8* %allow_ptr_leaks, align 1
  %tobool10 = trunc i8 %20 to i1
  br i1 %tobool10, label %if.else, label %if.then11

if.then11:                                        ; preds = %if.then9
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %21, %struct.bpf_reg_state* noundef %22) #20
  br label %if.end12

if.else:                                          ; preds = %if.then9
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %23, %struct.bpf_reg_state* noundef %24) #20
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then11
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %for.body4
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %25 = load i32, i32* %___j, align 4
  %inc = add i32 %25, 1
  store i32 %inc, i32* %___j, align 4
  br label %for.cond2, !llvm.loop !147

for.end:                                          ; preds = %for.cond2
  store i32 0, i32* %___j, align 4
  %26 = load i32, i32* %___j, align 4
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 10
  %28 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %28, 8
  %cmp14 = icmp slt i32 %26, %div
  br i1 %cmp14, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.end
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 11
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %31 = load i32, i32* %___j, align 4
  %idxprom15 = sext i32 %31 to i64
  %arrayidx16 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom15
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx16, i32 0, i32 1
  %arrayidx17 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %32 = load i8, i8* %arrayidx17, align 8
  %conv = zext i8 %32 to i32
  %cmp18 = icmp eq i32 %conv, 1
  br i1 %cmp18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack20 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 11
  %34 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack20, align 8
  %35 = load i32, i32* %___j, align 4
  %idxprom21 = sext i32 %35 to i64
  %arrayidx22 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %34, i64 %idxprom21
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx22, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond23

for.cond23:                                       ; preds = %cond.end63, %cond.end
  %36 = load i32, i32* %___j, align 4
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack24 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %37, i32 0, i32 10
  %38 = load i32, i32* %allocated_stack24, align 8
  %div25 = sdiv i32 %38, 8
  %cmp26 = icmp slt i32 %36, %div25
  br i1 %cmp26, label %for.body28, label %for.end65

for.body28:                                       ; preds = %for.cond23
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool29 = icmp ne %struct.bpf_reg_state* %39, null
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %for.body28
  br label %for.inc42

if.end31:                                         ; preds = %for.body28
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id32 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 4
  %41 = load i32, i32* %ref_obj_id32, align 4
  %42 = load i32, i32* %ref_obj_id.addr, align 4
  %cmp33 = icmp eq i32 %41, %42
  br i1 %cmp33, label %if.then35, label %if.end41

if.then35:                                        ; preds = %if.end31
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks36 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %43, i32 0, i32 17
  %44 = load i8, i8* %allow_ptr_leaks36, align 1
  %tobool37 = trunc i8 %44 to i1
  br i1 %tobool37, label %if.else39, label %if.then38

if.then38:                                        ; preds = %if.then35
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %45, %struct.bpf_reg_state* noundef %46) #20
  br label %if.end40

if.else39:                                        ; preds = %if.then35
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %47, %struct.bpf_reg_state* noundef %48) #20
  br label %if.end40

if.end40:                                         ; preds = %if.else39, %if.then38
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.end31
  br label %for.inc42

for.inc42:                                        ; preds = %if.end41, %if.then30
  %49 = load i32, i32* %___j, align 4
  %inc43 = add i32 %49, 1
  store i32 %inc43, i32* %___j, align 4
  %50 = load i32, i32* %___j, align 4
  %51 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack44 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %51, i32 0, i32 10
  %52 = load i32, i32* %allocated_stack44, align 8
  %div45 = sdiv i32 %52, 8
  %cmp46 = icmp slt i32 %50, %div45
  br i1 %cmp46, label %land.lhs.true48, label %cond.false62

land.lhs.true48:                                  ; preds = %for.inc42
  %53 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack49 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %53, i32 0, i32 11
  %54 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack49, align 8
  %55 = load i32, i32* %___j, align 4
  %idxprom50 = sext i32 %55 to i64
  %arrayidx51 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %54, i64 %idxprom50
  %slot_type52 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx51, i32 0, i32 1
  %arrayidx53 = getelementptr [8 x i8], [8 x i8]* %slot_type52, i64 0, i64 0
  %56 = load i8, i8* %arrayidx53, align 8
  %conv54 = zext i8 %56 to i32
  %cmp55 = icmp eq i32 %conv54, 1
  br i1 %cmp55, label %cond.true57, label %cond.false62

cond.true57:                                      ; preds = %land.lhs.true48
  %57 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack58 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %57, i32 0, i32 11
  %58 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack58, align 8
  %59 = load i32, i32* %___j, align 4
  %idxprom59 = sext i32 %59 to i64
  %arrayidx60 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %58, i64 %idxprom59
  %spilled_ptr61 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx60, i32 0, i32 0
  br label %cond.end63

cond.false62:                                     ; preds = %land.lhs.true48, %for.inc42
  br label %cond.end63

cond.end63:                                       ; preds = %cond.false62, %cond.true57
  %cond64 = phi %struct.bpf_reg_state* [ %spilled_ptr61, %cond.true57 ], [ null, %cond.false62 ]
  store %struct.bpf_reg_state* %cond64, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond23, !llvm.loop !148

for.end65:                                        ; preds = %for.cond23
  br label %for.inc66

for.inc66:                                        ; preds = %for.end65
  %60 = load i32, i32* %___i, align 4
  %inc67 = add i32 %60, 1
  store i32 %inc67, i32* %___i, align 4
  br label %for.cond, !llvm.loop !149

for.end68:                                        ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end68, %if.then
  %61 = load i32, i32* %retval, align 4
  ret i32 %61
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_struct_ptr(%struct.btf* noundef %btf, %struct.btf_type* noundef %t) #0 {
entry:
  %retval = alloca i1, align 1
  %btf.addr = alloca %struct.btf*, align 8
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf* %btf, %struct.btf** %btf.addr, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %call = call zeroext i1 @btf_type_is_ptr(%struct.btf_type* noundef %0) #20
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.btf*, %struct.btf** %btf.addr, align 8
  %2 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %3 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %2, i32 0, i32 2
  %type = bitcast %union.anon.137* %3 to i32*
  %4 = load i32, i32* %type, align 4
  %call1 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %1, i32 noundef %4, i32* noundef null) #20
  store %struct.btf_type* %call1, %struct.btf_type** %t.addr, align 8
  %5 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %call2 = call zeroext i1 @btf_type_is_struct(%struct.btf_type* noundef %5) #20
  store i1 %call2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i1, i1* %retval, align 1
  ret i1 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_scalar(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %call = call zeroext i1 @btf_type_is_int(%struct.btf_type* noundef %0) #20
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %call1 = call zeroext i1 @btf_type_is_enum(%struct.btf_type* noundef %1) #20
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %call1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_btf_func_reg_size(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i64 noundef %reg_size) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg_size.addr = alloca i64, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i64 %reg_size, i64* %reg_size.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  %1 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 17
  %4 = load i32, i32* %live, align 8
  %or = or i32 %4, 4
  store i32 %or, i32* %live, align 8
  %5 = load i64, i64* %reg_size.addr, align 8
  %cmp1 = icmp eq i64 %5, 8
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 0
  %7 = load i32, i32* %insn_idx, align 8
  %add = add i32 %7, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %add, %cond.false ]
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 16
  store i32 %cond, i32* %subreg_def, align 4
  br label %if.end8

if.else:                                          ; preds = %entry
  %9 = load i64, i64* %reg_size.addr, align 8
  %cmp2 = icmp eq i64 %9, 8
  br i1 %cmp2, label %if.then3, label %if.else5

if.then3:                                         ; preds = %if.else
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @mark_insn_zext(%struct.bpf_verifier_env* noundef %10, %struct.bpf_reg_state* noundef %11) #20
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 14
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %call4 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %12, %struct.bpf_reg_state* noundef %13, %struct.bpf_reg_state* noundef %15, i8 noundef zeroext 2) #20
  br label %if.end

if.else5:                                         ; preds = %if.else
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 14
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent6, align 8
  %call7 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %16, %struct.bpf_reg_state* noundef %17, %struct.bpf_reg_state* noundef %19, i8 noundef zeroext 1) #20
  br label %if.end

if.end:                                           ; preds = %if.else5, %if.then3
  br label %if.end8

if.end8:                                          ; preds = %if.end, %cond.end
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @btf_type_str(%struct.btf_type* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @acquire_reference_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %state = alloca %struct.bpf_func_state*, align 8
  %new_ofs = alloca i32, align 4
  %id = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 8
  %2 = load i32, i32* %acquired_refs, align 4
  store i32 %2, i32* %new_ofs, align 4
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 8
  %5 = load i32, i32* %acquired_refs1, align 4
  %add = add i32 %5, 1
  %conv = sext i32 %add to i64
  %call2 = call i32 @resize_reference_state(%struct.bpf_func_state* noundef %3, i64 noundef %conv) #20
  store i32 %call2, i32* %err, align 4
  %6 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load i32, i32* %err, align 4
  store i32 %7, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 15
  %9 = load i32, i32* %id_gen, align 8
  %inc = add i32 %9, 1
  store i32 %inc, i32* %id_gen, align 8
  store i32 %inc, i32* %id, align 4
  %10 = load i32, i32* %id, align 4
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 9
  %12 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %13 = load i32, i32* %new_ofs, align 4
  %idxprom = sext i32 %13 to i64
  %arrayidx = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %12, i64 %idxprom
  %id3 = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx, i32 0, i32 0
  store i32 %10, i32* %id3, align 4
  %14 = load i32, i32* %insn_idx.addr, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 9
  %16 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs4, align 8
  %17 = load i32, i32* %new_ofs, align 4
  %idxprom5 = sext i32 %17 to i64
  %arrayidx6 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %16, i64 %idxprom5
  %insn_idx7 = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx6, i32 0, i32 1
  store i32 %14, i32* %insn_idx7, align 4
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %in_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 5
  %19 = load i8, i8* %in_callback_fn, align 8
  %tobool8 = trunc i8 %19 to i1
  br i1 %tobool8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %frameno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %20, i32 0, i32 2
  %21 = load i32, i32* %frameno, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %21, %cond.true ], [ 0, %cond.false ]
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs10 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 9
  %23 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs10, align 8
  %24 = load i32, i32* %new_ofs, align 4
  %idxprom11 = sext i32 %24 to i64
  %arrayidx12 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %23, i64 %idxprom11
  %callback_ref = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx12, i32 0, i32 2
  store i32 %cond, i32* %callback_ref, align 4
  %25 = load i32, i32* %id, align 4
  store i32 %25, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @release_reference_state(%struct.bpf_func_state* noundef %state, i32 noundef %ptr_id) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %ptr_id.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %last_idx = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %ptr_id, i32* %ptr_id.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 8
  %1 = load i32, i32* %acquired_refs, align 4
  %sub = sub i32 %1, 1
  store i32 %sub, i32* %last_idx, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 8
  %4 = load i32, i32* %acquired_refs1, align 4
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 9
  %6 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %7 = load i32, i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %6, i64 %idxprom
  %id = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx, i32 0, i32 0
  %8 = load i32, i32* %id, align 4
  %9 = load i32, i32* %ptr_id.addr, align 4
  %cmp2 = icmp eq i32 %8, %9
  br i1 %cmp2, label %if.then, label %if.end23

if.then:                                          ; preds = %for.body
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %in_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 5
  %11 = load i8, i8* %in_callback_fn, align 8
  %tobool = trunc i8 %11 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 9
  %13 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs3, align 8
  %14 = load i32, i32* %i, align 4
  %idxprom4 = sext i32 %14 to i64
  %arrayidx5 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %13, i64 %idxprom4
  %callback_ref = getelementptr inbounds %struct.bpf_reference_state, %struct.bpf_reference_state* %arrayidx5, i32 0, i32 2
  %15 = load i32, i32* %callback_ref, align 4
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %16, i32 0, i32 2
  %17 = load i32, i32* %frameno, align 4
  %cmp6 = icmp ne i32 %15, %17
  br i1 %cmp6, label %if.then7, label %if.end

if.then7:                                         ; preds = %land.lhs.true
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.then
  %18 = load i32, i32* %last_idx, align 4
  %tobool8 = icmp ne i32 %18, 0
  br i1 %tobool8, label %land.lhs.true9, label %if.end18

land.lhs.true9:                                   ; preds = %if.end
  %19 = load i32, i32* %i, align 4
  %20 = load i32, i32* %last_idx, align 4
  %cmp10 = icmp ne i32 %19, %20
  br i1 %cmp10, label %if.then11, label %if.end18

if.then11:                                        ; preds = %land.lhs.true9
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs12 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 9
  %22 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs12, align 8
  %23 = load i32, i32* %i, align 4
  %idxprom13 = sext i32 %23 to i64
  %arrayidx14 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %22, i64 %idxprom13
  %24 = bitcast %struct.bpf_reference_state* %arrayidx14 to i8*
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 9
  %26 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs15, align 8
  %27 = load i32, i32* %last_idx, align 4
  %idxprom16 = sext i32 %27 to i64
  %arrayidx17 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %26, i64 %idxprom16
  %28 = bitcast %struct.bpf_reference_state* %arrayidx17 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %24, i8* align 4 %28, i64 12, i1 false)
  br label %if.end18

if.end18:                                         ; preds = %if.then11, %land.lhs.true9, %if.end
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs19 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 9
  %30 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs19, align 8
  %31 = load i32, i32* %last_idx, align 4
  %idxprom20 = sext i32 %31 to i64
  %arrayidx21 = getelementptr %struct.bpf_reference_state, %struct.bpf_reference_state* %30, i64 %idxprom20
  %32 = bitcast %struct.bpf_reference_state* %arrayidx21 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %32, i8 0, i64 12, i1 false)
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs22 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 8
  %34 = load i32, i32* %acquired_refs22, align 4
  %dec = add i32 %34, -1
  store i32 %dec, i32* %acquired_refs22, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end23
  %35 = load i32, i32* %i, align 4
  %inc = add i32 %35, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !150

for.end:                                          ; preds = %for.cond
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end18, %if.then7
  %36 = load i32, i32* %retval, align 4
  ret i32 %36
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_enum(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 31
  %cmp = icmp eq i32 %and, 6
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @resize_reference_state(%struct.bpf_func_state* noundef %state, i64 noundef %n) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %n.addr = alloca i64, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 9
  %1 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs, align 8
  %2 = bitcast %struct.bpf_reference_state* %1 to i8*
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 8
  %4 = load i32, i32* %acquired_refs, align 4
  %conv = sext i32 %4 to i64
  %5 = load i64, i64* %n.addr, align 8
  %call = call i8* @realloc_array(i8* noundef %2, i64 noundef %conv, i64 noundef %5, i64 noundef 12) #20
  %6 = bitcast i8* %call to %struct.bpf_reference_state*
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 9
  store %struct.bpf_reference_state* %6, %struct.bpf_reference_state** %refs1, align 8
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 9
  %9 = load %struct.bpf_reference_state*, %struct.bpf_reference_state** %refs2, align 8
  %tobool = icmp ne %struct.bpf_reference_state* %9, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %n.addr, align 8
  %conv3 = trunc i64 %10 to i32
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 8
  store i32 %conv3, i32* %acquired_refs4, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, i32* %retval, align 4
  ret i32 %12
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @func_id_name(i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_helper_changes_pkt_data(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_func_proto(%struct.bpf_func_proto* noundef %fn, i32 noundef %func_id) #0 {
entry:
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %func_id.addr = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call = call zeroext i1 @check_raw_mode_ok(%struct.bpf_func_proto* noundef %0) #20
  br i1 %call, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call1 = call zeroext i1 @check_arg_pair_ok(%struct.bpf_func_proto* noundef %1) #20
  br i1 %call1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %2 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call2 = call zeroext i1 @check_btf_id_ok(%struct.bpf_func_proto* noundef %2) #20
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %3 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %call2, %land.rhs ]
  %4 = zext i1 %3 to i64
  %cond = select i1 %3, i32 0, i32 -22
  ret i32 %cond
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_func_arg(%struct.bpf_verifier_env* noundef %env, i32 noundef %arg, %struct.bpf_call_arg_meta* noundef %meta, %struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %arg.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %regno = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %arg_type = alloca i32, align 4
  %type = alloca i32, align 4
  %arg_btf_id = alloca i32*, align 8
  %err = alloca i32, align 4
  %state = alloca %struct.bpf_func_state*, align 8
  %spi = alloca i32, align 4
  %err_extra = alloca i8*, align 8
  %size = alloca i32, align 4
  %map = alloca %struct.bpf_map*, align 8
  %map_off = alloca i32, align 4
  %map_addr = alloca i64, align 8
  %str_ptr = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %arg, i32* %arg.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  %0 = load i32, i32* %arg.addr, align 4
  %add = add i32 1, %0
  store i32 %add, i32* %regno, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %1) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %3 = load i32, i32* %regno, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %4 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %5 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %4, i32 0, i32 4
  %arg_type1 = bitcast %union.anon.203* %5 to [5 x i32]*
  %6 = load i32, i32* %arg.addr, align 4
  %idxprom2 = zext i32 %6 to i64
  %arrayidx3 = getelementptr [5 x i32], [5 x i32]* %arg_type1, i64 0, i64 %idxprom2
  %7 = load i32, i32* %arrayidx3, align 4
  store i32 %7, i32* %arg_type, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 0
  %9 = load i32, i32* %type4, align 8
  store i32 %9, i32* %type, align 4
  store i32* null, i32** %arg_btf_id, align 8
  store i32 0, i32* %err, align 4
  %10 = load i32, i32* %arg_type, align 4
  %cmp = icmp eq i32 %10, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %regno, align 4
  %call5 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %11, i32 noundef %12, i32 noundef 0) #20
  store i32 %call5, i32* %err, align 4
  %13 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %14 = load i32, i32* %err, align 4
  store i32 %14, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %15 = load i32, i32* %arg_type, align 4
  %cmp8 = icmp eq i32 %15, 8
  br i1 %cmp8, label %if.then9, label %if.end13

if.then9:                                         ; preds = %if.end7
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load i32, i32* %regno, align 4
  %call10 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %16, i32 noundef %17) #20
  br i1 %call10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.then9
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.384, i64 0, i64 0), i32 noundef %20) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.then9
  store i32 0, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end7
  %21 = load i32, i32* %type, align 4
  %call14 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %21) #20
  br i1 %call14, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.end13
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call15 = call zeroext i1 @may_access_direct_pkt_data(%struct.bpf_verifier_env* noundef %22, %struct.bpf_call_arg_meta* noundef %23, i32 noundef 1) #20
  br i1 %call15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %land.lhs.true
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.385, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %land.lhs.true, %if.end13
  %26 = load i32, i32* %arg_type, align 4
  %call18 = call i32 @base_type(i32 noundef %26) #20
  %cmp19 = icmp eq i32 %call18, 3
  br i1 %cmp19, label %if.then20, label %if.end25

if.then20:                                        ; preds = %if.end17
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call21 = call i32 @resolve_map_arg_type(%struct.bpf_verifier_env* noundef %27, %struct.bpf_call_arg_meta* noundef %28, i32* noundef %arg_type) #20
  store i32 %call21, i32* %err, align 4
  %29 = load i32, i32* %err, align 4
  %tobool22 = icmp ne i32 %29, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.then20
  %30 = load i32, i32* %err, align 4
  store i32 %30, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.then20
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end17
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call26 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %31) #20
  br i1 %call26, label %land.lhs.true27, label %if.end30

land.lhs.true27:                                  ; preds = %if.end25
  %32 = load i32, i32* %arg_type, align 4
  %call28 = call zeroext i1 @type_may_be_null(i32 noundef %32) #20
  br i1 %call28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %land.lhs.true27
  br label %skip_type_check

if.end30:                                         ; preds = %land.lhs.true27, %if.end25
  %33 = load i32, i32* %arg_type, align 4
  %call31 = call i32 @base_type(i32 noundef %33) #20
  %cmp32 = icmp eq i32 %call31, 14
  br i1 %cmp32, label %if.then33, label %if.end37

if.then33:                                        ; preds = %if.end30
  %34 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %35 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %34, i32 0, i32 5
  %arg_btf_id34 = bitcast %union.anon.205* %35 to [5 x i32*]*
  %36 = load i32, i32* %arg.addr, align 4
  %idxprom35 = zext i32 %36 to i64
  %arrayidx36 = getelementptr [5 x i32*], [5 x i32*]* %arg_btf_id34, i64 0, i64 %idxprom35
  %37 = load i32*, i32** %arrayidx36, align 8
  store i32* %37, i32** %arg_btf_id, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.then33, %if.end30
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load i32, i32* %regno, align 4
  %40 = load i32, i32* %arg_type, align 4
  %41 = load i32*, i32** %arg_btf_id, align 8
  %42 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call38 = call i32 @check_reg_type(%struct.bpf_verifier_env* noundef %38, i32 noundef %39, i32 noundef %40, i32* noundef %41, %struct.bpf_call_arg_meta* noundef %42) #20
  store i32 %call38, i32* %err, align 4
  %43 = load i32, i32* %err, align 4
  %tobool39 = icmp ne i32 %43, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end37
  %44 = load i32, i32* %err, align 4
  store i32 %44, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end37
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %47 = load i32, i32* %regno, align 4
  %48 = load i32, i32* %arg_type, align 4
  %call42 = call i32 @check_func_arg_reg_off(%struct.bpf_verifier_env* noundef %45, %struct.bpf_reg_state* noundef %46, i32 noundef %47, i32 noundef %48) #20
  store i32 %call42, i32* %err, align 4
  %49 = load i32, i32* %err, align 4
  %tobool43 = icmp ne i32 %49, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end41
  %50 = load i32, i32* %err, align 4
  store i32 %50, i32* %retval, align 4
  br label %return

if.end45:                                         ; preds = %if.end41
  br label %skip_type_check

skip_type_check:                                  ; preds = %if.end45, %if.then29
  %51 = load i32, i32* %arg_type, align 4
  %call46 = call zeroext i1 @arg_type_is_release(i32 noundef %51) #20
  br i1 %call46, label %if.then47, label %if.end68

if.then47:                                        ; preds = %skip_type_check
  %52 = load i32, i32* %arg_type, align 4
  %call48 = call zeroext i1 @arg_type_is_dynptr(i32 noundef %52) #20
  br i1 %call48, label %if.then49, label %if.else

if.then49:                                        ; preds = %if.then47
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call50 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %53, %struct.bpf_reg_state* noundef %54) #20
  store %struct.bpf_func_state* %call50, %struct.bpf_func_state** %state, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 1
  %56 = load i32, i32* %off, align 4
  %call51 = call i32 @get_spi(i32 noundef %56) #20
  store i32 %call51, i32* %spi, align 4
  %57 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %58 = load i32, i32* %spi, align 4
  %call52 = call zeroext i1 @is_spi_bounds_valid(%struct.bpf_func_state* noundef %57, i32 noundef %58, i32 noundef 2) #20
  br i1 %call52, label %lor.lhs.false, label %if.then56

lor.lhs.false:                                    ; preds = %if.then49
  %59 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %59, i32 0, i32 11
  %60 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %61 = load i32, i32* %spi, align 4
  %idxprom53 = sext i32 %61 to i64
  %arrayidx54 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %60, i64 %idxprom53
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx54, i32 0, i32 0
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 3
  %62 = load i32, i32* %id, align 8
  %tobool55 = icmp ne i32 %62, 0
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %lor.lhs.false, %if.then49
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = bitcast %struct.bpf_verifier_env* %63 to i8*
  %65 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %64, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.386, i64 0, i64 0), i32 noundef %65) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end57:                                         ; preds = %lor.lhs.false
  br label %if.end63

if.else:                                          ; preds = %if.then47
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 4
  %67 = load i32, i32* %ref_obj_id, align 4
  %tobool58 = icmp ne i32 %67, 0
  br i1 %tobool58, label %if.end62, label %land.lhs.true59

land.lhs.true59:                                  ; preds = %if.else
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call60 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %68) #20
  br i1 %call60, label %if.end62, label %if.then61

if.then61:                                        ; preds = %land.lhs.true59
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = bitcast %struct.bpf_verifier_env* %69 to i8*
  %71 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %70, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.387, i64 0, i64 0), i32 noundef %71) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end62:                                         ; preds = %land.lhs.true59, %if.else
  br label %if.end63

if.end63:                                         ; preds = %if.end62, %if.end57
  %72 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %release_regno = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %72, i32 0, i32 3
  %73 = load i8, i8* %release_regno, align 2
  %tobool64 = icmp ne i8 %73, 0
  br i1 %tobool64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %if.end63
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = bitcast %struct.bpf_verifier_env* %74 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %75, i8* noundef getelementptr inbounds ([57 x i8], [57 x i8]* @.str.388, i64 0, i64 0)) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end66:                                         ; preds = %if.end63
  %76 = load i32, i32* %regno, align 4
  %conv = trunc i32 %76 to i8
  %77 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %release_regno67 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %77, i32 0, i32 3
  store i8 %conv, i8* %release_regno67, align 2
  br label %if.end68

if.end68:                                         ; preds = %if.end66, %skip_type_check
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id69 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %78, i32 0, i32 4
  %79 = load i32, i32* %ref_obj_id69, align 4
  %tobool70 = icmp ne i32 %79, 0
  br i1 %tobool70, label %if.then71, label %if.end80

if.then71:                                        ; preds = %if.end68
  %80 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ref_obj_id72 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %80, i32 0, i32 8
  %81 = load i32, i32* %ref_obj_id72, align 8
  %tobool73 = icmp ne i32 %81, 0
  br i1 %tobool73, label %if.then74, label %if.end77

if.then74:                                        ; preds = %if.then71
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %83 = bitcast %struct.bpf_verifier_env* %82 to i8*
  %84 = load i32, i32* %regno, align 4
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %85, i32 0, i32 4
  %86 = load i32, i32* %ref_obj_id75, align 4
  %87 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ref_obj_id76 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %87, i32 0, i32 8
  %88 = load i32, i32* %ref_obj_id76, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %83, i8* noundef getelementptr inbounds ([70 x i8], [70 x i8]* @.str.389, i64 0, i64 0), i32 noundef %84, i32 noundef %86, i32 noundef %88) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %if.then71
  %89 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %89, i32 0, i32 4
  %90 = load i32, i32* %ref_obj_id78, align 4
  %91 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ref_obj_id79 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %91, i32 0, i32 8
  store i32 %90, i32* %ref_obj_id79, align 8
  br label %if.end80

if.end80:                                         ; preds = %if.end77, %if.end68
  %92 = load i32, i32* %arg_type, align 4
  %call81 = call i32 @base_type(i32 noundef %92) #20
  switch i32 %call81, label %sw.epilog264 [
    i32 1, label %sw.bb
    i32 2, label %sw.bb101
    i32 3, label %sw.bb108
    i32 18, label %sw.bb123
    i32 9, label %sw.bb128
    i32 22, label %sw.bb148
    i32 19, label %sw.bb153
    i32 4, label %sw.bb155
    i32 5, label %sw.bb168
    i32 6, label %sw.bb170
    i32 24, label %sw.bb172
    i32 16, label %sw.bb204
    i32 11, label %sw.bb214
    i32 12, label %sw.bb214
    i32 21, label %sw.bb221
    i32 23, label %sw.bb259
  ]

sw.bb:                                            ; preds = %if.end80
  %93 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %93, i32 0, i32 0
  %94 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %tobool82 = icmp ne %struct.bpf_map* %94, null
  br i1 %tobool82, label %if.then83, label %if.end96

if.then83:                                        ; preds = %sw.bb
  %95 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr84 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %95, i32 0, i32 0
  %96 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr84, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %98 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 2
  %99 = bitcast %union.anon.168* %98 to %struct.anon.169*
  %map_ptr85 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %99, i32 0, i32 0
  %100 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr85, align 8
  %cmp86 = icmp ne %struct.bpf_map* %96, %100
  br i1 %cmp86, label %if.then92, label %lor.lhs.false88

lor.lhs.false88:                                  ; preds = %if.then83
  %101 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_uid = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %101, i32 0, i32 9
  %102 = load i32, i32* %map_uid, align 4
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %104 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %103, i32 0, i32 2
  %105 = bitcast %union.anon.168* %104 to %struct.anon.169*
  %map_uid89 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %105, i32 0, i32 1
  %106 = load i32, i32* %map_uid89, align 8
  %cmp90 = icmp ne i32 %102, %106
  br i1 %cmp90, label %if.then92, label %if.end95

if.then92:                                        ; preds = %lor.lhs.false88, %if.then83
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %108 = bitcast %struct.bpf_verifier_env* %107 to i8*
  %109 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_uid93 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %109, i32 0, i32 9
  %110 = load i32, i32* %map_uid93, align 4
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %112 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 2
  %113 = bitcast %union.anon.168* %112 to %struct.anon.169*
  %map_uid94 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %113, i32 0, i32 1
  %114 = load i32, i32* %map_uid94, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %108, i8* noundef getelementptr inbounds ([75 x i8], [75 x i8]* @.str.390, i64 0, i64 0), i32 noundef %110, i32 noundef %114) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end95:                                         ; preds = %lor.lhs.false88
  br label %if.end96

if.end96:                                         ; preds = %if.end95, %sw.bb
  %115 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %116 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %115, i32 0, i32 2
  %117 = bitcast %union.anon.168* %116 to %struct.anon.169*
  %map_ptr97 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %117, i32 0, i32 0
  %118 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr97, align 8
  %119 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr98 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %119, i32 0, i32 0
  store %struct.bpf_map* %118, %struct.bpf_map** %map_ptr98, align 8
  %120 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %121 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %120, i32 0, i32 2
  %122 = bitcast %union.anon.168* %121 to %struct.anon.169*
  %map_uid99 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %122, i32 0, i32 1
  %123 = load i32, i32* %map_uid99, align 8
  %124 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_uid100 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %124, i32 0, i32 9
  store i32 %123, i32* %map_uid100, align 4
  br label %sw.epilog264

sw.bb101:                                         ; preds = %if.end80
  %125 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr102 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %125, i32 0, i32 0
  %126 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr102, align 8
  %tobool103 = icmp ne %struct.bpf_map* %126, null
  br i1 %tobool103, label %if.end105, label %if.then104

if.then104:                                       ; preds = %sw.bb101
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %128 = bitcast %struct.bpf_verifier_env* %127 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %128, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.391, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end105:                                        ; preds = %sw.bb101
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %130 = load i32, i32* %regno, align 4
  %131 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr106 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %131, i32 0, i32 0
  %132 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr106, align 8
  %key_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %132, i32 0, i32 4
  %133 = load i32, i32* %key_size, align 4
  %call107 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %129, i32 noundef %130, i32 noundef %133, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef null) #20
  store i32 %call107, i32* %err, align 4
  br label %sw.epilog264

sw.bb108:                                         ; preds = %if.end80
  %134 = load i32, i32* %arg_type, align 4
  %call109 = call zeroext i1 @type_may_be_null(i32 noundef %134) #20
  br i1 %call109, label %land.lhs.true111, label %if.end115

land.lhs.true111:                                 ; preds = %sw.bb108
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call112 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %135) #20
  br i1 %call112, label %if.then114, label %if.end115

if.then114:                                       ; preds = %land.lhs.true111
  store i32 0, i32* %retval, align 4
  br label %return

if.end115:                                        ; preds = %land.lhs.true111, %sw.bb108
  %136 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr116 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %136, i32 0, i32 0
  %137 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr116, align 8
  %tobool117 = icmp ne %struct.bpf_map* %137, null
  br i1 %tobool117, label %if.end119, label %if.then118

if.then118:                                       ; preds = %if.end115
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %139 = bitcast %struct.bpf_verifier_env* %138 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %139, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.392, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end119:                                        ; preds = %if.end115
  %140 = load i32, i32* %arg_type, align 4
  %and = and i32 %140, 32768
  %tobool120 = icmp ne i32 %and, 0
  %141 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %141, i32 0, i32 1
  %frombool = zext i1 %tobool120 to i8
  store i8 %frombool, i8* %raw_mode, align 8
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %143 = load i32, i32* %regno, align 4
  %144 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr121 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %144, i32 0, i32 0
  %145 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr121, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %145, i32 0, i32 5
  %146 = load i32, i32* %value_size, align 32
  %147 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call122 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %142, i32 noundef %143, i32 noundef %146, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef %147) #20
  store i32 %call122, i32* %err, align 4
  br label %sw.epilog264

sw.bb123:                                         ; preds = %if.end80
  %148 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %149 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %148, i32 0, i32 2
  %150 = bitcast %union.anon.168* %149 to %struct.anon.170*
  %btf_id = getelementptr inbounds %struct.anon.170, %struct.anon.170* %150, i32 0, i32 1
  %151 = load i32, i32* %btf_id, align 8
  %tobool124 = icmp ne i32 %151, 0
  br i1 %tobool124, label %if.end126, label %if.then125

if.then125:                                       ; preds = %sw.bb123
  %152 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %153 = bitcast %struct.bpf_verifier_env* %152 to i8*
  %154 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %153, i8* noundef getelementptr inbounds ([34 x i8], [34 x i8]* @.str.393, i64 0, i64 0), i32 noundef %154) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end126:                                        ; preds = %sw.bb123
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %156 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %155, i32 0, i32 2
  %157 = bitcast %union.anon.168* %156 to %struct.anon.170*
  %btf = getelementptr inbounds %struct.anon.170, %struct.anon.170* %157, i32 0, i32 0
  %158 = load %struct.btf*, %struct.btf** %btf, align 8
  %159 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ret_btf = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %159, i32 0, i32 13
  store %struct.btf* %158, %struct.btf** %ret_btf, align 8
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %161 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 2
  %162 = bitcast %union.anon.168* %161 to %struct.anon.170*
  %btf_id127 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %162, i32 0, i32 1
  %163 = load i32, i32* %btf_id127, align 8
  %164 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ret_btf_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %164, i32 0, i32 14
  store i32 %163, i32* %ret_btf_id, align 8
  br label %sw.epilog264

sw.bb128:                                         ; preds = %if.end80
  %165 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %func_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %165, i32 0, i32 10
  %166 = load i32, i32* %func_id, align 8
  %cmp129 = icmp eq i32 %166, 93
  br i1 %cmp129, label %if.then131, label %if.else136

if.then131:                                       ; preds = %sw.bb128
  %167 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %168 = load i32, i32* %regno, align 4
  %call132 = call i32 @process_spin_lock(%struct.bpf_verifier_env* noundef %167, i32 noundef %168, i1 noundef zeroext true) #20
  %tobool133 = icmp ne i32 %call132, 0
  br i1 %tobool133, label %if.then134, label %if.end135

if.then134:                                       ; preds = %if.then131
  store i32 -13, i32* %retval, align 4
  br label %return

if.end135:                                        ; preds = %if.then131
  br label %if.end147

if.else136:                                       ; preds = %sw.bb128
  %169 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %func_id137 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %169, i32 0, i32 10
  %170 = load i32, i32* %func_id137, align 8
  %cmp138 = icmp eq i32 %170, 94
  br i1 %cmp138, label %if.then140, label %if.else145

if.then140:                                       ; preds = %if.else136
  %171 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %172 = load i32, i32* %regno, align 4
  %call141 = call i32 @process_spin_lock(%struct.bpf_verifier_env* noundef %171, i32 noundef %172, i1 noundef zeroext false) #20
  %tobool142 = icmp ne i32 %call141, 0
  br i1 %tobool142, label %if.then143, label %if.end144

if.then143:                                       ; preds = %if.then140
  store i32 -13, i32* %retval, align 4
  br label %return

if.end144:                                        ; preds = %if.then140
  br label %if.end146

if.else145:                                       ; preds = %if.else136
  %173 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %174 = bitcast %struct.bpf_verifier_env* %173 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %174, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.394, i64 0, i64 0)) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end146:                                        ; preds = %if.end144
  br label %if.end147

if.end147:                                        ; preds = %if.end146, %if.end135
  br label %sw.epilog264

sw.bb148:                                         ; preds = %if.end80
  %175 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %176 = load i32, i32* %regno, align 4
  %177 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call149 = call i32 @process_timer_func(%struct.bpf_verifier_env* noundef %175, i32 noundef %176, %struct.bpf_call_arg_meta* noundef %177) #20
  %tobool150 = icmp ne i32 %call149, 0
  br i1 %tobool150, label %if.then151, label %if.end152

if.then151:                                       ; preds = %sw.bb148
  store i32 -13, i32* %retval, align 4
  br label %return

if.end152:                                        ; preds = %sw.bb148
  br label %sw.epilog264

sw.bb153:                                         ; preds = %if.end80
  %178 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %179 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %178, i32 0, i32 2
  %subprogno = bitcast %union.anon.168* %179 to i32*
  %180 = load i32, i32* %subprogno, align 8
  %181 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %subprogno154 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %181, i32 0, i32 15
  store i32 %180, i32* %subprogno154, align 4
  br label %sw.epilog264

sw.bb155:                                         ; preds = %if.end80
  %182 = load i32, i32* %arg_type, align 4
  %and156 = and i32 %182, 32768
  %tobool157 = icmp ne i32 %and156, 0
  %183 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode158 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %183, i32 0, i32 1
  %frombool159 = zext i1 %tobool157 to i8
  store i8 %frombool159, i8* %raw_mode158, align 8
  %184 = load i32, i32* %arg_type, align 4
  %and160 = and i32 %184, 262144
  %tobool161 = icmp ne i32 %and160, 0
  br i1 %tobool161, label %if.then162, label %if.end167

if.then162:                                       ; preds = %sw.bb155
  %185 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %186 = load i32, i32* %regno, align 4
  %187 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %188 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %187, i32 0, i32 5
  %arg_size = bitcast %union.anon.205* %188 to [5 x i64]*
  %189 = load i32, i32* %arg.addr, align 4
  %idxprom163 = zext i32 %189 to i64
  %arrayidx164 = getelementptr [5 x i64], [5 x i64]* %arg_size, i64 0, i64 %idxprom163
  %190 = load i64, i64* %arrayidx164, align 8
  %conv165 = trunc i64 %190 to i32
  %191 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call166 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %185, i32 noundef %186, i32 noundef %conv165, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef %191) #20
  store i32 %call166, i32* %err, align 4
  br label %if.end167

if.end167:                                        ; preds = %if.then162, %sw.bb155
  br label %sw.epilog264

sw.bb168:                                         ; preds = %if.end80
  %192 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %193 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %194 = load i32, i32* %regno, align 4
  %195 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call169 = call i32 @check_mem_size_reg(%struct.bpf_verifier_env* noundef %192, %struct.bpf_reg_state* noundef %193, i32 noundef %194, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef %195) #20
  store i32 %call169, i32* %err, align 4
  br label %sw.epilog264

sw.bb170:                                         ; preds = %if.end80
  %196 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %197 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %198 = load i32, i32* %regno, align 4
  %199 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call171 = call i32 @check_mem_size_reg(%struct.bpf_verifier_env* noundef %196, %struct.bpf_reg_state* noundef %197, i32 noundef %198, i1 noundef zeroext true, %struct.bpf_call_arg_meta* noundef %199) #20
  store i32 %call171, i32* %err, align 4
  br label %sw.epilog264

sw.bb172:                                         ; preds = %if.end80
  %200 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type173 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %200, i32 0, i32 0
  %201 = load i32, i32* %type173, align 8
  %call174 = call i32 @base_type(i32 noundef %201) #20
  %cmp175 = icmp eq i32 %call174, 20
  br i1 %cmp175, label %if.then177, label %if.end178

if.then177:                                       ; preds = %sw.bb172
  br label %sw.epilog264

if.end178:                                        ; preds = %sw.bb172
  %202 = load i32, i32* %arg_type, align 4
  %and179 = and i32 %202, 32768
  %tobool180 = icmp ne i32 %and179, 0
  br i1 %tobool180, label %if.then181, label %if.else190

if.then181:                                       ; preds = %if.end178
  %203 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %204 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call182 = call zeroext i1 @is_dynptr_reg_valid_uninit(%struct.bpf_verifier_env* noundef %203, %struct.bpf_reg_state* noundef %204) #20
  br i1 %call182, label %if.end184, label %if.then183

if.then183:                                       ; preds = %if.then181
  %205 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %206 = bitcast %struct.bpf_verifier_env* %205 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %206, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.395, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end184:                                        ; preds = %if.then181
  %207 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %uninit_dynptr_regno = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %207, i32 0, i32 17
  %208 = load i8, i8* %uninit_dynptr_regno, align 8
  %tobool185 = icmp ne i8 %208, 0
  br i1 %tobool185, label %if.then186, label %if.end187

if.then186:                                       ; preds = %if.end184
  %209 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %210 = bitcast %struct.bpf_verifier_env* %209 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %210, i8* noundef getelementptr inbounds ([61 x i8], [61 x i8]* @.str.396, i64 0, i64 0)) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end187:                                        ; preds = %if.end184
  %211 = load i32, i32* %regno, align 4
  %conv188 = trunc i32 %211 to i8
  %212 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %uninit_dynptr_regno189 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %212, i32 0, i32 17
  store i8 %conv188, i8* %uninit_dynptr_regno189, align 8
  br label %if.end203

if.else190:                                       ; preds = %if.end178
  %213 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %214 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call191 = call zeroext i1 @is_dynptr_reg_valid_init(%struct.bpf_verifier_env* noundef %213, %struct.bpf_reg_state* noundef %214) #20
  br i1 %call191, label %if.else194, label %if.then192

if.then192:                                       ; preds = %if.else190
  %215 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %216 = bitcast %struct.bpf_verifier_env* %215 to i8*
  %217 = load i32, i32* %arg.addr, align 4
  %add193 = add i32 %217, 1
  call void (i8*, i8*, ...) @verbose(i8* noundef %216, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.397, i64 0, i64 0), i32 noundef %add193) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.else194:                                       ; preds = %if.else190
  %218 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %219 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %220 = load i32, i32* %arg_type, align 4
  %call195 = call zeroext i1 @is_dynptr_type_expected(%struct.bpf_verifier_env* noundef %218, %struct.bpf_reg_state* noundef %219, i32 noundef %220) #20
  br i1 %call195, label %if.end201, label %if.then196

if.then196:                                       ; preds = %if.else194
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.3, i64 0, i64 0), i8** %err_extra, align 8
  %221 = load i32, i32* %arg_type, align 4
  %and197 = and i32 %221, 196608
  switch i32 %and197, label %sw.default [
    i32 65536, label %sw.bb198
    i32 131072, label %sw.bb199
  ]

sw.bb198:                                         ; preds = %if.then196
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.398, i64 0, i64 0), i8** %err_extra, align 8
  br label %sw.epilog

sw.bb199:                                         ; preds = %if.then196
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.399, i64 0, i64 0), i8** %err_extra, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.then196
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.400, i64 0, i64 0), i8** %err_extra, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb199, %sw.bb198
  %222 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %223 = bitcast %struct.bpf_verifier_env* %222 to i8*
  %224 = load i8*, i8** %err_extra, align 8
  %225 = load i32, i32* %arg.addr, align 4
  %add200 = add i32 %225, 1
  call void (i8*, i8*, ...) @verbose(i8* noundef %223, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.401, i64 0, i64 0), i8* noundef %224, i32 noundef %add200) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end201:                                        ; preds = %if.else194
  br label %if.end202

if.end202:                                        ; preds = %if.end201
  br label %if.end203

if.end203:                                        ; preds = %if.end202, %if.end187
  br label %sw.epilog264

sw.bb204:                                         ; preds = %if.end80
  %226 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %226, i32 0, i32 5
  %227 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %228 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %227, i32 0, i32 0
  %229 = load i64, i64* %228, align 8
  %230 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %227, i32 0, i32 1
  %231 = load i64, i64* %230, align 8
  %call205 = call zeroext i1 @tnum_is_const(i64 %229, i64 %231) #20
  br i1 %call205, label %if.end207, label %if.then206

if.then206:                                       ; preds = %sw.bb204
  %232 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %233 = bitcast %struct.bpf_verifier_env* %232 to i8*
  %234 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %233, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.402, i64 0, i64 0), i32 noundef %234) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end207:                                        ; preds = %sw.bb204
  %235 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off208 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %235, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off208, i32 0, i32 0
  %236 = load i64, i64* %value, align 8
  %conv209 = trunc i64 %236 to i32
  %237 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %mem_size = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %237, i32 0, i32 6
  store i32 %conv209, i32* %mem_size, align 4
  %238 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %239 = load i32, i32* %regno, align 4
  %call210 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %238, i32 noundef %239) #20
  store i32 %call210, i32* %err, align 4
  %240 = load i32, i32* %err, align 4
  %tobool211 = icmp ne i32 %240, 0
  br i1 %tobool211, label %if.then212, label %if.end213

if.then212:                                       ; preds = %if.end207
  %241 = load i32, i32* %err, align 4
  store i32 %241, i32* %retval, align 4
  br label %return

if.end213:                                        ; preds = %if.end207
  br label %sw.epilog264

sw.bb214:                                         ; preds = %if.end80, %if.end80
  %242 = load i32, i32* %arg_type, align 4
  %call215 = call i32 @int_ptr_type_to_size(i32 noundef %242) #20
  store i32 %call215, i32* %size, align 4
  %243 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %244 = load i32, i32* %regno, align 4
  %245 = load i32, i32* %size, align 4
  %246 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call216 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %243, i32 noundef %244, i32 noundef %245, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef %246) #20
  store i32 %call216, i32* %err, align 4
  %247 = load i32, i32* %err, align 4
  %tobool217 = icmp ne i32 %247, 0
  br i1 %tobool217, label %if.then218, label %if.end219

if.then218:                                       ; preds = %sw.bb214
  %248 = load i32, i32* %err, align 4
  store i32 %248, i32* %retval, align 4
  br label %return

if.end219:                                        ; preds = %sw.bb214
  %249 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %250 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %251 = load i32, i32* %size, align 4
  %call220 = call i32 @check_ptr_alignment(%struct.bpf_verifier_env* noundef %249, %struct.bpf_reg_state* noundef %250, i32 noundef 0, i32 noundef %251, i1 noundef zeroext true) #20
  store i32 %call220, i32* %err, align 4
  br label %sw.epilog264

sw.bb221:                                         ; preds = %if.end80
  %252 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %253 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %252, i32 0, i32 2
  %254 = bitcast %union.anon.168* %253 to %struct.anon.169*
  %map_ptr222 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %254, i32 0, i32 0
  %255 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr222, align 8
  store %struct.bpf_map* %255, %struct.bpf_map** %map, align 8
  %256 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call223 = call zeroext i1 @bpf_map_is_rdonly(%struct.bpf_map* noundef %256) #20
  br i1 %call223, label %if.end225, label %if.then224

if.then224:                                       ; preds = %sw.bb221
  %257 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %258 = bitcast %struct.bpf_verifier_env* %257 to i8*
  %259 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %258, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.403, i64 0, i64 0), i32 noundef %259) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end225:                                        ; preds = %sw.bb221
  %260 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off226 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %260, i32 0, i32 5
  %261 = bitcast %struct.tnum* %var_off226 to { i64, i64 }*
  %262 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %261, i32 0, i32 0
  %263 = load i64, i64* %262, align 8
  %264 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %261, i32 0, i32 1
  %265 = load i64, i64* %264, align 8
  %call227 = call zeroext i1 @tnum_is_const(i64 %263, i64 %265) #20
  br i1 %call227, label %if.end229, label %if.then228

if.then228:                                       ; preds = %if.end225
  %266 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %267 = bitcast %struct.bpf_verifier_env* %266 to i8*
  %268 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %267, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.404, i64 0, i64 0), i32 noundef %268) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end229:                                        ; preds = %if.end225
  %269 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %269, i32 0, i32 0
  %270 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %270, i32 0, i32 28
  %271 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %tobool230 = icmp ne i32 (%struct.bpf_map*, i64*, i32)* %271, null
  br i1 %tobool230, label %if.end232, label %if.then231

if.then231:                                       ; preds = %if.end229
  %272 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %273 = bitcast %struct.bpf_verifier_env* %272 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %273, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.266, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end232:                                        ; preds = %if.end229
  %274 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %275 = load i32, i32* %regno, align 4
  %276 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off233 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %276, i32 0, i32 1
  %277 = load i32, i32* %off233, align 4
  %278 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size234 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %278, i32 0, i32 5
  %279 = load i32, i32* %value_size234, align 32
  %280 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off235 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %280, i32 0, i32 1
  %281 = load i32, i32* %off235, align 4
  %sub = sub i32 %279, %281
  %call236 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %274, i32 noundef %275, i32 noundef %277, i32 noundef %sub, i1 noundef zeroext false, i32 noundef 2) #20
  store i32 %call236, i32* %err, align 4
  %282 = load i32, i32* %err, align 4
  %tobool237 = icmp ne i32 %282, 0
  br i1 %tobool237, label %if.then238, label %if.end239

if.then238:                                       ; preds = %if.end232
  %283 = load i32, i32* %err, align 4
  store i32 %283, i32* %retval, align 4
  br label %return

if.end239:                                        ; preds = %if.end232
  %284 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off240 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %284, i32 0, i32 1
  %285 = load i32, i32* %off240, align 4
  %conv241 = sext i32 %285 to i64
  %286 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off242 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %286, i32 0, i32 5
  %value243 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off242, i32 0, i32 0
  %287 = load i64, i64* %value243, align 8
  %add244 = add i64 %conv241, %287
  %conv245 = trunc i64 %add244 to i32
  store i32 %conv245, i32* %map_off, align 4
  %288 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops246 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %288, i32 0, i32 0
  %289 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops246, align 64
  %map_direct_value_addr247 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %289, i32 0, i32 28
  %290 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr247, align 8
  %291 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %292 = load i32, i32* %map_off, align 4
  %call248 = call i32 %290(%struct.bpf_map* noundef %291, i64* noundef %map_addr, i32 noundef %292) #20
  store i32 %call248, i32* %err, align 4
  %293 = load i32, i32* %err, align 4
  %tobool249 = icmp ne i32 %293, 0
  br i1 %tobool249, label %if.then250, label %if.end251

if.then250:                                       ; preds = %if.end239
  %294 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %295 = bitcast %struct.bpf_verifier_env* %294 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %295, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.405, i64 0, i64 0)) #20
  %296 = load i32, i32* %err, align 4
  store i32 %296, i32* %retval, align 4
  br label %return

if.end251:                                        ; preds = %if.end239
  %297 = load i64, i64* %map_addr, align 8
  %298 = inttoptr i64 %297 to i8*
  store i8* %298, i8** %str_ptr, align 8
  %299 = load i8*, i8** %str_ptr, align 8
  %300 = load i32, i32* %map_off, align 4
  %idx.ext = sext i32 %300 to i64
  %add.ptr = getelementptr i8, i8* %299, i64 %idx.ext
  %301 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size252 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %301, i32 0, i32 5
  %302 = load i32, i32* %value_size252, align 32
  %303 = load i32, i32* %map_off, align 4
  %sub253 = sub i32 %302, %303
  %conv254 = zext i32 %sub253 to i64
  %call255 = call i8* @strnchr(i8* noundef %add.ptr, i64 noundef %conv254, i32 noundef 0) #20
  %tobool256 = icmp ne i8* %call255, null
  br i1 %tobool256, label %if.end258, label %if.then257

if.then257:                                       ; preds = %if.end251
  %304 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %305 = bitcast %struct.bpf_verifier_env* %304 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %305, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.406, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end258:                                        ; preds = %if.end251
  br label %sw.epilog264

sw.bb259:                                         ; preds = %if.end80
  %306 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %307 = load i32, i32* %regno, align 4
  %308 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call260 = call i32 @process_kptr_func(%struct.bpf_verifier_env* noundef %306, i32 noundef %307, %struct.bpf_call_arg_meta* noundef %308) #20
  %tobool261 = icmp ne i32 %call260, 0
  br i1 %tobool261, label %if.then262, label %if.end263

if.then262:                                       ; preds = %sw.bb259
  store i32 -13, i32* %retval, align 4
  br label %return

if.end263:                                        ; preds = %sw.bb259
  br label %sw.epilog264

sw.epilog264:                                     ; preds = %if.end80, %if.end263, %if.end258, %if.end219, %if.end213, %if.end203, %if.then177, %sw.bb170, %sw.bb168, %if.end167, %sw.bb153, %if.end152, %if.end147, %if.end126, %if.end119, %if.end105, %if.end96
  %309 = load i32, i32* %err, align 4
  store i32 %309, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog264, %if.then262, %if.then257, %if.then250, %if.then238, %if.then231, %if.then228, %if.then224, %if.then218, %if.then212, %if.then206, %sw.epilog, %if.then192, %if.then186, %if.then183, %if.then151, %if.else145, %if.then143, %if.then134, %if.then125, %if.then118, %if.then114, %if.then104, %if.then92, %if.then74, %if.then65, %if.then61, %if.then56, %if.then44, %if.then40, %if.then23, %if.then16, %if.end12, %if.then11, %if.then6, %if.then
  %310 = load i32, i32* %retval, align 4
  ret i32 %310
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @record_func_map(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %func_id, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %func_id.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %map = alloca %struct.bpf_map*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx, %struct.bpf_insn_aux_data** %aux, align 8
  %3 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %3, i32 0, i32 0
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %4, %struct.bpf_map** %map, align 8
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %5, 12
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp ne i32 %6, 1
  br i1 %cmp1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %7 = load i32, i32* %func_id.addr, align 4
  %cmp3 = icmp ne i32 %7, 2
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %8 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp ne i32 %8, 3
  br i1 %cmp5, label %land.lhs.true6, label %if.end

land.lhs.true6:                                   ; preds = %land.lhs.true4
  %9 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp ne i32 %9, 87
  br i1 %cmp7, label %land.lhs.true8, label %if.end

land.lhs.true8:                                   ; preds = %land.lhs.true6
  %10 = load i32, i32* %func_id.addr, align 4
  %cmp9 = icmp ne i32 %10, 88
  br i1 %cmp9, label %land.lhs.true10, label %if.end

land.lhs.true10:                                  ; preds = %land.lhs.true8
  %11 = load i32, i32* %func_id.addr, align 4
  %cmp11 = icmp ne i32 %11, 89
  br i1 %cmp11, label %land.lhs.true12, label %if.end

land.lhs.true12:                                  ; preds = %land.lhs.true10
  %12 = load i32, i32* %func_id.addr, align 4
  %cmp13 = icmp ne i32 %12, 164
  br i1 %cmp13, label %land.lhs.true14, label %if.end

land.lhs.true14:                                  ; preds = %land.lhs.true12
  %13 = load i32, i32* %func_id.addr, align 4
  %cmp15 = icmp ne i32 %13, 51
  br i1 %cmp15, label %land.lhs.true16, label %if.end

land.lhs.true16:                                  ; preds = %land.lhs.true14
  %14 = load i32, i32* %func_id.addr, align 4
  %cmp17 = icmp ne i32 %14, 195
  br i1 %cmp17, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true16
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true16, %land.lhs.true14, %land.lhs.true12, %land.lhs.true10, %land.lhs.true8, %land.lhs.true6, %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %15 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %cmp18 = icmp eq %struct.bpf_map* %15, null
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.376, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.end
  %18 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %18, i32 0, i32 8
  %19 = load i32, i32* %map_flags, align 16
  %and = and i32 %19, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true21, label %if.end29

land.lhs.true21:                                  ; preds = %if.end20
  %20 = load i32, i32* %func_id.addr, align 4
  %cmp22 = icmp eq i32 %20, 3
  br i1 %cmp22, label %if.then28, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true21
  %21 = load i32, i32* %func_id.addr, align 4
  %cmp23 = icmp eq i32 %21, 2
  br i1 %cmp23, label %if.then28, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %lor.lhs.false
  %22 = load i32, i32* %func_id.addr, align 4
  %cmp25 = icmp eq i32 %22, 87
  br i1 %cmp25, label %if.then28, label %lor.lhs.false26

lor.lhs.false26:                                  ; preds = %lor.lhs.false24
  %23 = load i32, i32* %func_id.addr, align 4
  %cmp27 = icmp eq i32 %23, 88
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %lor.lhs.false26, %lor.lhs.false24, %lor.lhs.false, %land.lhs.true21
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.452, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %lor.lhs.false26, %if.end20
  %26 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %27 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %26, i32 0, i32 0
  %map_ptr_state = bitcast %union.anon.210* %27 to i64*
  %28 = load i64, i64* %map_ptr_state, align 8
  %and30 = and i64 %28, -2
  %29 = inttoptr i64 %and30 to %struct.bpf_map*
  %tobool31 = icmp ne %struct.bpf_map* %29, null
  br i1 %tobool31, label %if.else, label %if.then32

if.then32:                                        ; preds = %if.end29
  %30 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %31 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr33 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %31, i32 0, i32 0
  %32 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr33, align 8
  %33 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr34 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %33, i32 0, i32 0
  %34 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr34, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %34, i32 0, i32 27
  %35 = load i8, i8* %bypass_spec_v1, align 4
  %tobool35 = trunc i8 %35 to i1
  %lnot = xor i1 %tobool35, true
  call void @bpf_map_ptr_store(%struct.bpf_insn_aux_data* noundef %30, %struct.bpf_map* noundef %32, i1 noundef zeroext %lnot) #20
  br label %if.end46

if.else:                                          ; preds = %if.end29
  %36 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %37 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %36, i32 0, i32 0
  %map_ptr_state36 = bitcast %union.anon.210* %37 to i64*
  %38 = load i64, i64* %map_ptr_state36, align 8
  %and37 = and i64 %38, -2
  %39 = inttoptr i64 %and37 to %struct.bpf_map*
  %40 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr38 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %40, i32 0, i32 0
  %41 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr38, align 8
  %cmp39 = icmp ne %struct.bpf_map* %39, %41
  br i1 %cmp39, label %if.then40, label %if.end45

if.then40:                                        ; preds = %if.else
  %42 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %43 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr41 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %43, i32 0, i32 0
  %44 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr41, align 8
  %bypass_spec_v142 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %44, i32 0, i32 27
  %45 = load i8, i8* %bypass_spec_v142, align 4
  %tobool43 = trunc i8 %45 to i1
  %lnot44 = xor i1 %tobool43, true
  call void @bpf_map_ptr_store(%struct.bpf_insn_aux_data* noundef %42, %struct.bpf_map* noundef inttoptr (i64 -2401263026318485698 to %struct.bpf_map*), i1 noundef zeroext %lnot44) #20
  br label %if.end45

if.end45:                                         ; preds = %if.then40, %if.else
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %if.then32
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end46, %if.then28, %if.then19, %if.then
  %46 = load i32, i32* %retval, align 4
  ret i32 %46
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @record_func_key(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %func_id, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %func_id.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %val = alloca i64, align 8
  %max = alloca i64, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx, %struct.bpf_insn_aux_data** %aux, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %3) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %4 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %5, %struct.bpf_map** %map, align 8
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %6, 12
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %tobool = icmp ne %struct.bpf_map* %7, null
  br i1 %tobool, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %8 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %8, i32 0, i32 3
  %9 = load i32, i32* %map_type, align 8
  %cmp1 = icmp ne i32 %9, 3
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.376, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx4 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i64 3
  store %struct.bpf_reg_state* %arrayidx4, %struct.bpf_reg_state** %reg, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %14 = load i64, i64* %value, align 8
  store i64 %14, i64* %val, align 8
  %15 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %max_entries = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %15, i32 0, i32 6
  %16 = load i32, i32* %max_entries, align 4
  %conv = zext i32 %16 to i64
  store i64 %conv, i64* %max, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call5 = call zeroext i1 @register_is_const(%struct.bpf_reg_state* noundef %17) #20
  br i1 %call5, label %land.lhs.true, label %if.then9

land.lhs.true:                                    ; preds = %if.end3
  %18 = load i64, i64* %val, align 8
  %19 = load i64, i64* %max, align 8
  %cmp7 = icmp ult i64 %18, %19
  br i1 %cmp7, label %if.end10, label %if.then9

if.then9:                                         ; preds = %land.lhs.true, %if.end3
  %20 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  call void @bpf_map_key_store(%struct.bpf_insn_aux_data* noundef %20, i64 noundef -9223372036854775808) #20
  store i32 0, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %land.lhs.true
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call11 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %21, i32 noundef 3) #20
  store i32 %call11, i32* %err, align 4
  %22 = load i32, i32* %err, align 4
  %tobool12 = icmp ne i32 %22, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %23 = load i32, i32* %err, align 4
  store i32 %23, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end10
  %24 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call15 = call zeroext i1 @bpf_map_key_unseen(%struct.bpf_insn_aux_data* noundef %24) #20
  br i1 %call15, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end14
  %25 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %26 = load i64, i64* %val, align 8
  call void @bpf_map_key_store(%struct.bpf_insn_aux_data* noundef %25, i64 noundef %26) #20
  br label %if.end24

if.else:                                          ; preds = %if.end14
  %27 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call17 = call zeroext i1 @bpf_map_key_poisoned(%struct.bpf_insn_aux_data* noundef %27) #20
  br i1 %call17, label %if.end23, label %land.lhs.true18

land.lhs.true18:                                  ; preds = %if.else
  %28 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call19 = call i64 @bpf_map_key_immediate(%struct.bpf_insn_aux_data* noundef %28) #20
  %29 = load i64, i64* %val, align 8
  %cmp20 = icmp ne i64 %call19, %29
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true18
  %30 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  call void @bpf_map_key_store(%struct.bpf_insn_aux_data* noundef %30, i64 noundef -9223372036854775808) #20
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %land.lhs.true18, %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then16
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end24, %if.then13, %if.then9, %if.then2, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @mark_stack_slots_dynptr(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %arg_type, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %arg_type.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %state = alloca %struct.bpf_func_state*, align 8
  %type = alloca i32, align 4
  %spi = alloca i32, align 4
  %i = alloca i32, align 4
  %id = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %arg_type, i32* %arg_type.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %0, %struct.bpf_reg_state* noundef %1) #20
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 1
  %3 = load i32, i32* %off, align 4
  %call1 = call i32 @get_spi(i32 noundef %3) #20
  store i32 %call1, i32* %spi, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %5 = load i32, i32* %spi, align 4
  %call2 = call zeroext i1 @is_spi_bounds_valid(%struct.bpf_func_state* noundef %4, i32 noundef %5, i32 noundef 2) #20
  br i1 %call2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %6, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 11
  %8 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %9 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %8, i64 %idxprom
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %10 to i64
  %arrayidx4 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom3
  store i8 4, i8* %arrayidx4, align 1
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 11
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack5, align 8
  %13 = load i32, i32* %spi, align 4
  %sub = sub i32 %13, 1
  %idxprom6 = sext i32 %sub to i64
  %arrayidx7 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom6
  %slot_type8 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx7, i32 0, i32 1
  %14 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %14 to i64
  %arrayidx10 = getelementptr [8 x i8], [8 x i8]* %slot_type8, i64 0, i64 %idxprom9
  store i8 4, i8* %arrayidx10, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i32, i32* %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !151

for.end:                                          ; preds = %for.cond
  %16 = load i32, i32* %arg_type.addr, align 4
  %call11 = call i32 @arg_to_dynptr_type(i32 noundef %16) #20
  store i32 %call11, i32* %type, align 4
  %17 = load i32, i32* %type, align 4
  %cmp12 = icmp eq i32 %17, 0
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %for.end
  store i32 -22, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %for.end
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 11
  %19 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack15, align 8
  %20 = load i32, i32* %spi, align 4
  %idxprom16 = sext i32 %20 to i64
  %arrayidx17 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %19, i64 %idxprom16
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx17, i32 0, i32 0
  %21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 2
  %dynptr = bitcast %union.anon.168* %21 to %struct.anon.171*
  %first_slot = getelementptr inbounds %struct.anon.171, %struct.anon.171* %dynptr, i32 0, i32 1
  store i8 1, i8* %first_slot, align 4
  %22 = load i32, i32* %type, align 4
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack18 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 11
  %24 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack18, align 8
  %25 = load i32, i32* %spi, align 4
  %idxprom19 = sext i32 %25 to i64
  %arrayidx20 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %24, i64 %idxprom19
  %spilled_ptr21 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx20, i32 0, i32 0
  %26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr21, i32 0, i32 2
  %dynptr22 = bitcast %union.anon.168* %26 to %struct.anon.171*
  %type23 = getelementptr inbounds %struct.anon.171, %struct.anon.171* %dynptr22, i32 0, i32 0
  store i32 %22, i32* %type23, align 8
  %27 = load i32, i32* %type, align 4
  %28 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack24 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %28, i32 0, i32 11
  %29 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack24, align 8
  %30 = load i32, i32* %spi, align 4
  %sub25 = sub i32 %30, 1
  %idxprom26 = sext i32 %sub25 to i64
  %arrayidx27 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %29, i64 %idxprom26
  %spilled_ptr28 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx27, i32 0, i32 0
  %31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr28, i32 0, i32 2
  %dynptr29 = bitcast %union.anon.168* %31 to %struct.anon.171*
  %type30 = getelementptr inbounds %struct.anon.171, %struct.anon.171* %dynptr29, i32 0, i32 0
  store i32 %27, i32* %type30, align 8
  %32 = load i32, i32* %type, align 4
  %call31 = call zeroext i1 @dynptr_type_refcounted(i32 noundef %32) #20
  br i1 %call31, label %if.then32, label %if.end48

if.then32:                                        ; preds = %if.end14
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load i32, i32* %insn_idx.addr, align 4
  %call33 = call i32 @acquire_reference_state(%struct.bpf_verifier_env* noundef %33, i32 noundef %34) #20
  store i32 %call33, i32* %id, align 4
  %35 = load i32, i32* %id, align 4
  %cmp34 = icmp slt i32 %35, 0
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then32
  %36 = load i32, i32* %id, align 4
  store i32 %36, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.then32
  %37 = load i32, i32* %id, align 4
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack37 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %38, i32 0, i32 11
  %39 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack37, align 8
  %40 = load i32, i32* %spi, align 4
  %idxprom38 = sext i32 %40 to i64
  %arrayidx39 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %39, i64 %idxprom38
  %spilled_ptr40 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx39, i32 0, i32 0
  %id41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr40, i32 0, i32 3
  store i32 %37, i32* %id41, align 8
  %41 = load i32, i32* %id, align 4
  %42 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack42 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %42, i32 0, i32 11
  %43 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack42, align 8
  %44 = load i32, i32* %spi, align 4
  %sub43 = sub i32 %44, 1
  %idxprom44 = sext i32 %sub43 to i64
  %arrayidx45 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %43, i64 %idxprom44
  %spilled_ptr46 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx45, i32 0, i32 0
  %id47 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr46, i32 0, i32 3
  store i32 %41, i32* %id47, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.end36, %if.end14
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end48, %if.then35, %if.then13, %if.then
  %45 = load i32, i32* %retval, align 4
  ret i32 %45
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @unmark_stack_slots_dynptr(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %spi = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %0, %struct.bpf_reg_state* noundef %1) #20
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 1
  %3 = load i32, i32* %off, align 4
  %call1 = call i32 @get_spi(i32 noundef %3) #20
  store i32 %call1, i32* %spi, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %5 = load i32, i32* %spi, align 4
  %call2 = call zeroext i1 @is_spi_bounds_valid(%struct.bpf_func_state* noundef %4, i32 noundef %5, i32 noundef 2) #20
  br i1 %call2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %6, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 11
  %8 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %9 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %8, i64 %idxprom
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %10 to i64
  %arrayidx4 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom3
  store i8 0, i8* %arrayidx4, align 1
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 11
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack5, align 8
  %13 = load i32, i32* %spi, align 4
  %sub = sub i32 %13, 1
  %idxprom6 = sext i32 %sub to i64
  %arrayidx7 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom6
  %slot_type8 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx7, i32 0, i32 1
  %14 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %14 to i64
  %arrayidx10 = getelementptr [8 x i8], [8 x i8]* %slot_type8, i64 0, i64 %idxprom9
  store i8 0, i8* %arrayidx10, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i32, i32* %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !152

for.end:                                          ; preds = %for.cond
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack11 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %16, i32 0, i32 11
  %17 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack11, align 8
  %18 = load i32, i32* %spi, align 4
  %idxprom12 = sext i32 %18 to i64
  %arrayidx13 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %17, i64 %idxprom12
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx13, i32 0, i32 0
  %19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 2
  %dynptr = bitcast %union.anon.168* %19 to %struct.anon.171*
  %type = getelementptr inbounds %struct.anon.171, %struct.anon.171* %dynptr, i32 0, i32 0
  %20 = load i32, i32* %type, align 8
  %call14 = call zeroext i1 @dynptr_type_refcounted(i32 noundef %20) #20
  br i1 %call14, label %if.then15, label %if.end32

if.then15:                                        ; preds = %for.end
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack16 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 11
  %23 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack16, align 8
  %24 = load i32, i32* %spi, align 4
  %idxprom17 = sext i32 %24 to i64
  %arrayidx18 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %23, i64 %idxprom17
  %spilled_ptr19 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx18, i32 0, i32 0
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr19, i32 0, i32 3
  %25 = load i32, i32* %id, align 8
  %call20 = call i32 @release_reference(%struct.bpf_verifier_env* noundef %21, i32 noundef %25) #20
  %26 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack21 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %26, i32 0, i32 11
  %27 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack21, align 8
  %28 = load i32, i32* %spi, align 4
  %idxprom22 = sext i32 %28 to i64
  %arrayidx23 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %27, i64 %idxprom22
  %spilled_ptr24 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx23, i32 0, i32 0
  %id25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr24, i32 0, i32 3
  store i32 0, i32* %id25, align 8
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack26 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 11
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack26, align 8
  %31 = load i32, i32* %spi, align 4
  %sub27 = sub i32 %31, 1
  %idxprom28 = sext i32 %sub27 to i64
  %arrayidx29 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom28
  %spilled_ptr30 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx29, i32 0, i32 0
  %id31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr30, i32 0, i32 3
  store i32 0, i32* %id31, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then15, %for.end
  %32 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack33 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %32, i32 0, i32 11
  %33 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack33, align 8
  %34 = load i32, i32* %spi, align 4
  %idxprom34 = sext i32 %34 to i64
  %arrayidx35 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %33, i64 %idxprom34
  %spilled_ptr36 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx35, i32 0, i32 0
  %35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr36, i32 0, i32 2
  %dynptr37 = bitcast %union.anon.168* %35 to %struct.anon.171*
  %first_slot = getelementptr inbounds %struct.anon.171, %struct.anon.171* %dynptr37, i32 0, i32 1
  store i8 0, i8* %first_slot, align 4
  %36 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack38 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %36, i32 0, i32 11
  %37 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack38, align 8
  %38 = load i32, i32* %spi, align 4
  %idxprom39 = sext i32 %38 to i64
  %arrayidx40 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %37, i64 %idxprom39
  %spilled_ptr41 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx40, i32 0, i32 0
  %39 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr41, i32 0, i32 2
  %dynptr42 = bitcast %union.anon.168* %39 to %struct.anon.171*
  %type43 = getelementptr inbounds %struct.anon.171, %struct.anon.171* %dynptr42, i32 0, i32 0
  store i32 0, i32* %type43, align 8
  %40 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack44 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %40, i32 0, i32 11
  %41 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack44, align 8
  %42 = load i32, i32* %spi, align 4
  %sub45 = sub i32 %42, 1
  %idxprom46 = sext i32 %sub45 to i64
  %arrayidx47 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %41, i64 %idxprom46
  %spilled_ptr48 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx47, i32 0, i32 0
  %43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr48, i32 0, i32 2
  %dynptr49 = bitcast %union.anon.168* %43 to %struct.anon.171*
  %type50 = getelementptr inbounds %struct.anon.171, %struct.anon.171* %dynptr49, i32 0, i32 0
  store i32 0, i32* %type50, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end32, %if.then
  %44 = load i32, i32* %retval, align 4
  ret i32 %44
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @set_map_elem_callback_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %caller, %struct.bpf_func_state* noundef %callee, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %caller.addr = alloca %struct.bpf_func_state*, align 8
  %callee.addr = alloca %struct.bpf_func_state*, align 8
  %insn_idx.addr = alloca i32, align 4
  %insn_aux = alloca %struct.bpf_insn_aux_data*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %err = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %caller, %struct.bpf_func_state** %caller.addr, align 8
  store %struct.bpf_func_state* %callee, %struct.bpf_func_state** %callee.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx, %struct.bpf_insn_aux_data** %insn_aux, align 8
  %3 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux, align 8
  %call = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %3) #20
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.453, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux, align 8
  %7 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %6, i32 0, i32 0
  %map_ptr_state = bitcast %union.anon.210* %7 to i64*
  %8 = load i64, i64* %map_ptr_state, align 8
  %and = and i64 %8, -2
  %9 = inttoptr i64 %and to %struct.bpf_map*
  store %struct.bpf_map* %9, %struct.bpf_map** %map, align 8
  %10 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %10, i32 0, i32 0
  %11 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_set_for_each_callback_args = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %11, i32 0, i32 37
  %12 = load i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)*, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)** %map_set_for_each_callback_args, align 8
  %tobool = icmp ne i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)* %12, null
  br i1 %tobool, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %if.end
  %13 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %13, i32 0, i32 0
  %14 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops1, align 64
  %map_for_each_callback = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %14, i32 0, i32 38
  %15 = load i32 (%struct.bpf_map*, i64 (i64, i64, i64, i64, i64)*, i8*, i64)*, i32 (%struct.bpf_map*, i64 (i64, i64, i64, i64, i64)*, i8*, i64)** %map_for_each_callback, align 8
  %tobool2 = icmp ne i32 (%struct.bpf_map*, i64 (i64, i64, i64, i64, i64)*, i8*, i64)* %15, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.454, i64 0, i64 0)) #20
  store i32 -524, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %lor.lhs.false
  %18 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops5 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %18, i32 0, i32 0
  %19 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops5, align 64
  %map_set_for_each_callback_args6 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %19, i32 0, i32 37
  %20 = load i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)*, i32 (%struct.bpf_verifier_env*, %struct.bpf_func_state*, %struct.bpf_func_state*)** %map_set_for_each_callback_args6, align 8
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %call7 = call i32 %20(%struct.bpf_verifier_env* noundef %21, %struct.bpf_func_state* noundef %22, %struct.bpf_func_state* noundef %23) #20
  store i32 %call7, i32* %err, align 4
  %24 = load i32, i32* %err, align 4
  %tobool8 = icmp ne i32 %24, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end4
  %25 = load i32, i32* %err, align 4
  store i32 %25, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end4
  %26 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %in_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %26, i32 0, i32 5
  store i8 1, i8* %in_callback_fn, align 8
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %callback_ret_range = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 6
  %call11 = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #20
  %28 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %28, i32 0, i32 0
  %30 = extractvalue { i64, i64 } %call11, 0
  store i64 %30, i64* %29, align 8
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %28, i32 0, i32 1
  %32 = extractvalue { i64, i64 } %call11, 1
  store i64 %32, i64* %31, align 8
  %33 = bitcast %struct.tnum* %callback_ret_range to i8*
  %34 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %33, i8* align 8 %34, i64 16, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then9, %if.then3, %if.then
  %35 = load i32, i32* %retval, align 4
  ret i32 %35
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @set_timer_callback_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %caller, %struct.bpf_func_state* noundef %callee, i32 noundef %insn_idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %caller.addr = alloca %struct.bpf_func_state*, align 8
  %callee.addr = alloca %struct.bpf_func_state*, align 8
  %insn_idx.addr = alloca i32, align 4
  %map_ptr = alloca %struct.bpf_map*, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %caller, %struct.bpf_func_state** %caller.addr, align 8
  store %struct.bpf_func_state* %callee, %struct.bpf_func_state** %callee.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 1
  %1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 2
  %2 = bitcast %union.anon.168* %1 to %struct.anon.169*
  %map_ptr1 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %2, i32 0, i32 0
  %3 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr1, align 8
  store %struct.bpf_map* %3, %struct.bpf_map** %map_ptr, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arrayidx3 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs2, i64 0, i64 1
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx3, i32 0, i32 0
  store i32 3, i32* %type, align 8
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 0
  %arrayidx5 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs4, i64 0, i64 1
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %arrayidx5) #20
  %6 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs6 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 0
  %arrayidx7 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs6, i64 0, i64 1
  %8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx7, i32 0, i32 2
  %9 = bitcast %union.anon.168* %8 to %struct.anon.169*
  %map_ptr8 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %9, i32 0, i32 0
  store %struct.bpf_map* %6, %struct.bpf_map** %map_ptr8, align 8
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs9 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 0
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs9, i64 0, i64 2
  %type11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx10, i32 0, i32 0
  store i32 5, i32* %type11, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs12 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 0
  %arrayidx13 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs12, i64 0, i64 2
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %arrayidx13) #20
  %12 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 0
  %arrayidx15 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs14, i64 0, i64 2
  %14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx15, i32 0, i32 2
  %15 = bitcast %union.anon.168* %14 to %struct.anon.169*
  %map_ptr16 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %15, i32 0, i32 0
  store %struct.bpf_map* %12, %struct.bpf_map** %map_ptr16, align 8
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs17 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %16, i32 0, i32 0
  %arrayidx18 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs17, i64 0, i64 3
  %type19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx18, i32 0, i32 0
  store i32 4, i32* %type19, align 8
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs20 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 0
  %arrayidx21 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs20, i64 0, i64 3
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %arrayidx21) #20
  %18 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs22 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 0
  %arrayidx23 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs22, i64 0, i64 3
  %20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx23, i32 0, i32 2
  %21 = bitcast %union.anon.168* %20 to %struct.anon.169*
  %map_ptr24 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %21, i32 0, i32 0
  store %struct.bpf_map* %18, %struct.bpf_map** %map_ptr24, align 8
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs25 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 0
  %arrayidx26 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs25, i64 0, i64 4
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %22, %struct.bpf_reg_state* noundef %arrayidx26) #20
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs27 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 0
  %arrayidx28 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs27, i64 0, i64 5
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %24, %struct.bpf_reg_state* noundef %arrayidx28) #20
  %26 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %in_async_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %26, i32 0, i32 7
  store i8 1, i8* %in_async_callback_fn, align 8
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %callback_ret_range = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 6
  %call = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #20
  %28 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %28, i32 0, i32 0
  %30 = extractvalue { i64, i64 } %call, 0
  store i64 %30, i64* %29, align 8
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %28, i32 0, i32 1
  %32 = extractvalue { i64, i64 } %call, 1
  store i64 %32, i64* %31, align 8
  %33 = bitcast %struct.tnum* %callback_ret_range to i8*
  %34 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %33, i8* align 8 %34, i64 16, i1 false)
  ret i32 0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @set_find_vma_callback_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %caller, %struct.bpf_func_state* noundef %callee, i32 noundef %insn_idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %caller.addr = alloca %struct.bpf_func_state*, align 8
  %callee.addr = alloca %struct.bpf_func_state*, align 8
  %insn_idx.addr = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %caller, %struct.bpf_func_state** %caller.addr, align 8
  store %struct.bpf_func_state* %callee, %struct.bpf_func_state** %callee.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 1
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 1
  %2 = bitcast %struct.bpf_reg_state* %arrayidx to i8*
  %3 = bitcast %struct.bpf_reg_state* %arrayidx2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 %3, i64 120, i1 false)
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arrayidx4 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs3, i64 0, i64 2
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx4, i32 0, i32 0
  store i32 16, i32* %type, align 8
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 0
  %arrayidx6 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs5, i64 0, i64 2
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %arrayidx6) #20
  %6 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 0
  %arrayidx8 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs7, i64 0, i64 2
  %8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx8, i32 0, i32 2
  %9 = bitcast %union.anon.168* %8 to %struct.anon.170*
  %btf = getelementptr inbounds %struct.anon.170, %struct.anon.170* %9, i32 0, i32 0
  store %struct.btf* %6, %struct.btf** %btf, align 8
  %10 = load i32, i32* getelementptr inbounds ([0 x i32], [0 x i32]* @btf_tracing_ids, i64 0, i64 2), align 4
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs9 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 0
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs9, i64 0, i64 2
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx10, i32 0, i32 2
  %13 = bitcast %union.anon.168* %12 to %struct.anon.170*
  %btf_id = getelementptr inbounds %struct.anon.170, %struct.anon.170* %13, i32 0, i32 1
  store i32 %10, i32* %btf_id, align 8
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs11 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 0
  %arrayidx12 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs11, i64 0, i64 3
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs13 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 0
  %arrayidx14 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs13, i64 0, i64 4
  %16 = bitcast %struct.bpf_reg_state* %arrayidx12 to i8*
  %17 = bitcast %struct.bpf_reg_state* %arrayidx14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 8 %17, i64 120, i1 false)
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 0
  %arrayidx16 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs15, i64 0, i64 4
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %18, %struct.bpf_reg_state* noundef %arrayidx16) #20
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs17 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 0
  %arrayidx18 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs17, i64 0, i64 5
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %20, %struct.bpf_reg_state* noundef %arrayidx18) #20
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %in_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 5
  store i8 1, i8* %in_callback_fn, align 8
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %callback_ret_range = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 6
  %call = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #20
  %24 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %callback_ret_range to i8*
  %30 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %29, i8* align 8 %30, i64 16, i1 false)
  ret i32 0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_bpf_snprintf_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %fmt_reg = alloca %struct.bpf_reg_state*, align 8
  %data_len_reg = alloca %struct.bpf_reg_state*, align 8
  %fmt_map = alloca %struct.bpf_map*, align 8
  %err = alloca i32, align 4
  %fmt_map_off = alloca i32, align 4
  %num_args = alloca i32, align 4
  %fmt_addr = alloca i64, align 8
  %fmt = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i64 3
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %fmt_reg, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %arrayidx1 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 5
  store %struct.bpf_reg_state* %arrayidx1, %struct.bpf_reg_state** %data_len_reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %fmt_reg, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 2
  %4 = bitcast %union.anon.168* %3 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %5, %struct.bpf_map** %fmt_map, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %data_len_reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %7 = load i64, i64* %value, align 8
  %rem = urem i64 %7, 8
  %tobool = icmp ne i64 %rem, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %data_len_reg, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 5
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off2, i32 0, i32 0
  %9 = load i64, i64* %value3, align 8
  %div = udiv i64 %9, 8
  %conv = trunc i64 %div to i32
  store i32 %conv, i32* %num_args, align 4
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %fmt_reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 1
  %11 = load i32, i32* %off, align 4
  %conv4 = sext i32 %11 to i64
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %fmt_reg, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %value6 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %13 = load i64, i64* %value6, align 8
  %add = add i64 %conv4, %13
  %conv7 = trunc i64 %add to i32
  store i32 %conv7, i32* %fmt_map_off, align 4
  %14 = load %struct.bpf_map*, %struct.bpf_map** %fmt_map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %14, i32 0, i32 0
  %15 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %15, i32 0, i32 28
  %16 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %17 = load %struct.bpf_map*, %struct.bpf_map** %fmt_map, align 8
  %18 = load i32, i32* %fmt_map_off, align 4
  %call = call i32 %16(%struct.bpf_map* noundef %17, i64* noundef %fmt_addr, i32 noundef %18) #20
  store i32 %call, i32* %err, align 4
  %19 = load i32, i32* %err, align 4
  %tobool8 = icmp ne i32 %19, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.455, i64 0, i64 0)) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  %22 = load i64, i64* %fmt_addr, align 8
  %23 = inttoptr i64 %22 to i8*
  %24 = load i32, i32* %fmt_map_off, align 4
  %idx.ext = sext i32 %24 to i64
  %add.ptr = getelementptr i8, i8* %23, i64 %idx.ext
  store i8* %add.ptr, i8** %fmt, align 8
  %25 = load i8*, i8** %fmt, align 8
  %26 = load i32, i32* %num_args, align 4
  %call11 = call i32 @bpf_bprintf_prepare(i8* noundef %25, i32 noundef -1, i64* noundef null, i32** noundef null, i32 noundef %26) #20
  store i32 %call11, i32* %err, align 4
  %27 = load i32, i32* %err, align 4
  %cmp = icmp slt i32 %27, 0
  br i1 %cmp, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str.456, i64 0, i64 0)) #20
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end10
  %30 = load i32, i32* %err, align 4
  store i32 %30, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %if.then9, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @update_loop_inline_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %subprogno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %subprogno.addr = alloca i32, align 4
  %state = alloca %struct.bpf_loop_inline_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %subprogno, i32* %subprogno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %0) #20
  %1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %call, i32 0, i32 0
  %loop_inline_state = bitcast %union.anon.210* %1 to %struct.bpf_loop_inline_state*
  store %struct.bpf_loop_inline_state* %loop_inline_state, %struct.bpf_loop_inline_state** %state, align 8
  %2 = load %struct.bpf_loop_inline_state*, %struct.bpf_loop_inline_state** %state, align 8
  %3 = bitcast %struct.bpf_loop_inline_state* %2 to i8*
  %bf.load = load i8, i8* %3, align 4
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_loop_inline_state*, %struct.bpf_loop_inline_state** %state, align 8
  %5 = bitcast %struct.bpf_loop_inline_state* %4 to i8*
  %bf.load1 = load i8, i8* %5, align 4
  %bf.clear2 = and i8 %bf.load1, -2
  %bf.set = or i8 %bf.clear2, 1
  store i8 %bf.set, i8* %5, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call3 = call zeroext i1 @loop_flag_is_zero(%struct.bpf_verifier_env* noundef %6) #20
  %conv = zext i1 %call3 to i32
  %7 = load %struct.bpf_loop_inline_state*, %struct.bpf_loop_inline_state** %state, align 8
  %8 = bitcast %struct.bpf_loop_inline_state* %7 to i8*
  %9 = trunc i32 %conv to i8
  %bf.load4 = load i8, i8* %8, align 4
  %bf.value = and i8 %9, 1
  %bf.shl = shl i8 %bf.value, 1
  %bf.clear5 = and i8 %bf.load4, -3
  %bf.set6 = or i8 %bf.clear5, %bf.shl
  store i8 %bf.set6, i8* %8, align 4
  %bf.result.cast = zext i8 %bf.value to i32
  %10 = load i32, i32* %subprogno.addr, align 4
  %11 = load %struct.bpf_loop_inline_state*, %struct.bpf_loop_inline_state** %state, align 8
  %callback_subprogno = getelementptr inbounds %struct.bpf_loop_inline_state, %struct.bpf_loop_inline_state* %11, i32 0, i32 1
  store i32 %10, i32* %callback_subprogno, align 4
  br label %return

if.end:                                           ; preds = %entry
  %12 = load %struct.bpf_loop_inline_state*, %struct.bpf_loop_inline_state** %state, align 8
  %13 = bitcast %struct.bpf_loop_inline_state* %12 to i8*
  %bf.load7 = load i8, i8* %13, align 4
  %bf.lshr = lshr i8 %bf.load7, 1
  %bf.clear8 = and i8 %bf.lshr, 1
  %bf.cast9 = zext i8 %bf.clear8 to i32
  %tobool10 = icmp ne i32 %bf.cast9, 0
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end
  br label %return

if.end12:                                         ; preds = %if.end
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call13 = call zeroext i1 @loop_flag_is_zero(%struct.bpf_verifier_env* noundef %14) #20
  br i1 %call13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end12
  %15 = load %struct.bpf_loop_inline_state*, %struct.bpf_loop_inline_state** %state, align 8
  %callback_subprogno15 = getelementptr inbounds %struct.bpf_loop_inline_state, %struct.bpf_loop_inline_state* %15, i32 0, i32 1
  %16 = load i32, i32* %callback_subprogno15, align 4
  %17 = load i32, i32* %subprogno.addr, align 4
  %cmp = icmp eq i32 %16, %17
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end12
  %18 = phi i1 [ false, %if.end12 ], [ %cmp, %land.rhs ]
  %land.ext = zext i1 %18 to i32
  %19 = load %struct.bpf_loop_inline_state*, %struct.bpf_loop_inline_state** %state, align 8
  %20 = bitcast %struct.bpf_loop_inline_state* %19 to i8*
  %21 = trunc i32 %land.ext to i8
  %bf.load17 = load i8, i8* %20, align 4
  %bf.value18 = and i8 %21, 1
  %bf.shl19 = shl i8 %bf.value18, 1
  %bf.clear20 = and i8 %bf.load17, -3
  %bf.set21 = or i8 %bf.clear20, %bf.shl19
  store i8 %bf.set21, i8* %20, align 4
  %bf.result.cast22 = zext i8 %bf.value18 to i32
  br label %return

return:                                           ; preds = %land.end, %if.then11, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @set_loop_callback_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %caller, %struct.bpf_func_state* noundef %callee, i32 noundef %insn_idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %caller.addr = alloca %struct.bpf_func_state*, align 8
  %callee.addr = alloca %struct.bpf_func_state*, align 8
  %insn_idx.addr = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %caller, %struct.bpf_func_state** %caller.addr, align 8
  store %struct.bpf_func_state* %callee, %struct.bpf_func_state** %callee.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 1
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 2
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 0
  %arrayidx4 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs3, i64 0, i64 3
  %3 = bitcast %struct.bpf_reg_state* %arrayidx2 to i8*
  %4 = bitcast %struct.bpf_reg_state* %arrayidx4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %3, i8* align 8 %4, i64 120, i1 false)
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arrayidx6 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs5, i64 0, i64 3
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %5, %struct.bpf_reg_state* noundef %arrayidx6) #20
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 0
  %arrayidx8 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs7, i64 0, i64 4
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %7, %struct.bpf_reg_state* noundef %arrayidx8) #20
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs9 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 0
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs9, i64 0, i64 5
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %9, %struct.bpf_reg_state* noundef %arrayidx10) #20
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %in_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 5
  store i8 1, i8* %in_callback_fn, align 8
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %callback_ret_range = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 6
  %call = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #20
  %13 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = extractvalue { i64, i64 } %call, 0
  store i64 %15, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = extractvalue { i64, i64 } %call, 1
  store i64 %17, i64* %16, align 8
  %18 = bitcast %struct.tnum* %callback_ret_range to i8*
  %19 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %18, i8* align 8 %19, i64 16, i1 false)
  ret i32 0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @stack_slot_get_id(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %spi = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %0, %struct.bpf_reg_state* noundef %1) #20
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 1
  %3 = load i32, i32* %off, align 4
  %call1 = call i32 @get_spi(i32 noundef %3) #20
  store i32 %call1, i32* %spi, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 11
  %5 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %6 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %5, i64 %idxprom
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 0
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 3
  %7 = load i32, i32* %id, align 8
  ret i32 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @set_user_ringbuf_callback_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %caller, %struct.bpf_func_state* noundef %callee, i32 noundef %insn_idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %caller.addr = alloca %struct.bpf_func_state*, align 8
  %callee.addr = alloca %struct.bpf_func_state*, align 8
  %insn_idx.addr = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %caller, %struct.bpf_func_state** %caller.addr, align 8
  store %struct.bpf_func_state* %callee, %struct.bpf_func_state** %callee.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %0, %struct.bpf_reg_state* noundef %arrayidx) #20
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 0
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 1
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx2, i32 0, i32 0
  store i32 65556, i32* %type, align 8
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 0
  %arrayidx4 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs3, i64 0, i64 1
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %arrayidx4) #20
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arrayidx6 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs5, i64 0, i64 2
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller.addr, align 8
  %regs7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 0
  %arrayidx8 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs7, i64 0, i64 3
  %6 = bitcast %struct.bpf_reg_state* %arrayidx6 to i8*
  %7 = bitcast %struct.bpf_reg_state* %arrayidx8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %6, i8* align 8 %7, i64 120, i1 false)
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs9 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 0
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs9, i64 0, i64 3
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %arrayidx10) #20
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs11 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 0
  %arrayidx12 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs11, i64 0, i64 4
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %10, %struct.bpf_reg_state* noundef %arrayidx12) #20
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %regs13 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 0
  %arrayidx14 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs13, i64 0, i64 5
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %12, %struct.bpf_reg_state* noundef %arrayidx14) #20
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %in_callback_fn = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 5
  store i8 1, i8* %in_callback_fn, align 8
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee.addr, align 8
  %callback_ret_range = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 6
  %call = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #20
  %16 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call, 1
  store i64 %20, i64* %19, align 8
  %21 = bitcast %struct.tnum* %callback_ret_range to i8*
  %22 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %22, i64 16, i1 false)
  ret i32 0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @helper_multiple_ref_obj_use(i32 noundef %func_id, %struct.bpf_map* noundef %map) #0 {
entry:
  %func_id.addr = alloca i32, align 4
  %map.addr = alloca %struct.bpf_map*, align 8
  %ref_obj_uses = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  store i32 0, i32* %ref_obj_uses, align 4
  %0 = load i32, i32* %func_id.addr, align 4
  %call = call zeroext i1 @is_ptr_cast_function(i32 noundef %0) #20
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %ref_obj_uses, align 4
  %inc = add i32 %1, 1
  store i32 %inc, i32* %ref_obj_uses, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, i32* %func_id.addr, align 4
  %3 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call1 = call zeroext i1 @is_acquire_function(i32 noundef %2, %struct.bpf_map* noundef %3) #20
  br i1 %call1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %4 = load i32, i32* %ref_obj_uses, align 4
  %inc3 = add i32 %4, 1
  store i32 %inc3, i32* %ref_obj_uses, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %5 = load i32, i32* %func_id.addr, align 4
  %call5 = call zeroext i1 @is_dynptr_ref_function(i32 noundef %5) #20
  br i1 %call5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %6 = load i32, i32* %ref_obj_uses, align 4
  %inc7 = add i32 %6, 1
  store i32 %inc7, i32* %ref_obj_uses, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %7 = load i32, i32* %ref_obj_uses, align 4
  %cmp = icmp sgt i32 %7, 1
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_ptr_cast_function(i32 noundef %func_id) #0 {
entry:
  %func_id.addr = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %0, 96
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp eq i32 %1, 95
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %func_id.addr, align 4
  %cmp3 = icmp eq i32 %2, 137
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp eq i32 %3, 136
  br i1 %cmp5, label %lor.end, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp eq i32 %4, 140
  br i1 %cmp7, label %lor.end, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp9 = icmp eq i32 %5, 196
  br i1 %cmp9, label %lor.end, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %lor.lhs.false8
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp11 = icmp eq i32 %6, 138
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false10
  %7 = load i32, i32* %func_id.addr, align 4
  %cmp12 = icmp eq i32 %7, 139
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false10, %lor.lhs.false8, %lor.lhs.false6, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %8 = phi i1 [ true, %lor.lhs.false10 ], [ true, %lor.lhs.false8 ], [ true, %lor.lhs.false6 ], [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp12, %lor.rhs ]
  ret i1 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_dynptr_ref_function(i32 noundef %func_id) #0 {
entry:
  %func_id.addr = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %0, 203
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_acquire_function(i32 noundef %func_id, %struct.bpf_map* noundef %map) #0 {
entry:
  %retval = alloca i1, align 1
  %func_id.addr = alloca i32, align 4
  %map.addr = alloca %struct.bpf_map*, align 8
  %map_type = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %tobool = icmp ne %struct.bpf_map* %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %1, i32 0, i32 3
  %2 = load i32, i32* %map_type1, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %map_type, align 4
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %3, 84
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp2 = icmp eq i32 %4, 85
  br i1 %cmp2, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp4 = icmp eq i32 %5, 99
  br i1 %cmp4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false3
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp6 = icmp eq i32 %6, 131
  br i1 %cmp6, label %if.then, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %lor.lhs.false5
  %7 = load i32, i32* %func_id.addr, align 4
  %cmp8 = icmp eq i32 %7, 194
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false7, %lor.lhs.false5, %lor.lhs.false3, %lor.lhs.false, %cond.end
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false7
  %8 = load i32, i32* %func_id.addr, align 4
  %cmp9 = icmp eq i32 %8, 1
  br i1 %cmp9, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %if.end
  %9 = load i32, i32* %map_type, align 4
  %cmp10 = icmp eq i32 %9, 15
  br i1 %cmp10, label %if.then13, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %land.lhs.true
  %10 = load i32, i32* %map_type, align 4
  %cmp12 = icmp eq i32 %10, 18
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %lor.lhs.false11, %land.lhs.true
  store i1 true, i1* %retval, align 1
  br label %return

if.end14:                                         ; preds = %lor.lhs.false11, %if.end
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end14, %if.then13, %if.then
  %11 = load i1, i1* %retval, align 1
  ret i1 %11
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @do_refine_retval_range(%struct.bpf_reg_state* noundef %regs, i32 noundef %ret_type, i32 noundef %func_id, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %ret_type.addr = alloca i32, align 4
  %func_id.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %ret_reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %ret_type, i32* %ret_type.addr, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i64 0
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %ret_reg, align 8
  %1 = load i32, i32* %ret_type.addr, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp ne i32 %2, 67
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp2 = icmp ne i32 %3, 141
  br i1 %cmp2, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp4 = icmp ne i32 %4, 45
  br i1 %cmp4, label %land.lhs.true5, label %if.end

land.lhs.true5:                                   ; preds = %land.lhs.true3
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp6 = icmp ne i32 %5, 115
  br i1 %cmp6, label %land.lhs.true7, label %if.end

land.lhs.true7:                                   ; preds = %land.lhs.true5
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp8 = icmp ne i32 %6, 114
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true7, %entry
  br label %return

if.end:                                           ; preds = %land.lhs.true7, %land.lhs.true5, %land.lhs.true3, %land.lhs.true, %lor.lhs.false
  %7 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_max_value = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %7, i32 0, i32 7
  %8 = load i64, i64* %msize_max_value, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 7
  store i64 %8, i64* %smax_value, align 8
  %10 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_max_value9 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %10, i32 0, i32 7
  %11 = load i64, i64* %msize_max_value9, align 8
  %conv = trunc i64 %11 to i32
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 11
  store i32 %conv, i32* %s32_max_value, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 6
  store i64 -4095, i64* %smin_value, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  store i32 -4095, i32* %s32_min_value, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  call void @reg_bounds_sync(%struct.bpf_reg_state* noundef %15) #20
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_func_compatibility(%struct.bpf_verifier_env* noundef %env, %struct.bpf_map* noundef %map, i32 noundef %func_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  %func_id.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %tobool = icmp ne %struct.bpf_map* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %1, i32 0, i32 3
  %2 = load i32, i32* %map_type, align 8
  switch i32 %2, label %sw.default [
    i32 3, label %sw.bb
    i32 4, label %sw.bb3
    i32 27, label %sw.bb14
    i32 31, label %sw.bb28
    i32 7, label %sw.bb32
    i32 8, label %sw.bb36
    i32 19, label %sw.bb42
    i32 21, label %sw.bb42
    i32 14, label %sw.bb46
    i32 25, label %sw.bb46
    i32 16, label %sw.bb52
    i32 17, label %sw.bb56
    i32 12, label %sw.bb62
    i32 13, label %sw.bb62
    i32 15, label %sw.bb66
    i32 18, label %sw.bb81
    i32 20, label %sw.bb97
    i32 22, label %sw.bb101
    i32 23, label %sw.bb101
    i32 24, label %sw.bb109
    i32 28, label %sw.bb115
    i32 29, label %sw.bb121
    i32 30, label %sw.bb127
  ]

sw.bb:                                            ; preds = %if.end
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %3, 12
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %sw.bb
  br label %error

if.end2:                                          ; preds = %sw.bb
  br label %sw.epilog

sw.bb3:                                           ; preds = %if.end
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp4 = icmp ne i32 %4, 22
  br i1 %cmp4, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %sw.bb3
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp ne i32 %5, 25
  br i1 %cmp5, label %land.lhs.true6, label %if.end13

land.lhs.true6:                                   ; preds = %land.lhs.true
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp ne i32 %6, 111
  br i1 %cmp7, label %land.lhs.true8, label %if.end13

land.lhs.true8:                                   ; preds = %land.lhs.true6
  %7 = load i32, i32* %func_id.addr, align 4
  %cmp9 = icmp ne i32 %7, 55
  br i1 %cmp9, label %land.lhs.true10, label %if.end13

land.lhs.true10:                                  ; preds = %land.lhs.true8
  %8 = load i32, i32* %func_id.addr, align 4
  %cmp11 = icmp ne i32 %8, 121
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %land.lhs.true10
  br label %error

if.end13:                                         ; preds = %land.lhs.true10, %land.lhs.true8, %land.lhs.true6, %land.lhs.true, %sw.bb3
  br label %sw.epilog

sw.bb14:                                          ; preds = %if.end
  %9 = load i32, i32* %func_id.addr, align 4
  %cmp15 = icmp ne i32 %9, 130
  br i1 %cmp15, label %land.lhs.true16, label %if.end27

land.lhs.true16:                                  ; preds = %sw.bb14
  %10 = load i32, i32* %func_id.addr, align 4
  %cmp17 = icmp ne i32 %10, 131
  br i1 %cmp17, label %land.lhs.true18, label %if.end27

land.lhs.true18:                                  ; preds = %land.lhs.true16
  %11 = load i32, i32* %func_id.addr, align 4
  %cmp19 = icmp ne i32 %11, 134
  br i1 %cmp19, label %land.lhs.true20, label %if.end27

land.lhs.true20:                                  ; preds = %land.lhs.true18
  %12 = load i32, i32* %func_id.addr, align 4
  %cmp21 = icmp ne i32 %12, 198
  br i1 %cmp21, label %land.lhs.true22, label %if.end27

land.lhs.true22:                                  ; preds = %land.lhs.true20
  %13 = load i32, i32* %func_id.addr, align 4
  %cmp23 = icmp ne i32 %13, 199
  br i1 %cmp23, label %land.lhs.true24, label %if.end27

land.lhs.true24:                                  ; preds = %land.lhs.true22
  %14 = load i32, i32* %func_id.addr, align 4
  %cmp25 = icmp ne i32 %14, 200
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %land.lhs.true24
  br label %error

if.end27:                                         ; preds = %land.lhs.true24, %land.lhs.true22, %land.lhs.true20, %land.lhs.true18, %land.lhs.true16, %sw.bb14
  br label %sw.epilog

sw.bb28:                                          ; preds = %if.end
  %15 = load i32, i32* %func_id.addr, align 4
  %cmp29 = icmp ne i32 %15, 209
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %sw.bb28
  br label %error

if.end31:                                         ; preds = %sw.bb28
  br label %sw.epilog

sw.bb32:                                          ; preds = %if.end
  %16 = load i32, i32* %func_id.addr, align 4
  %cmp33 = icmp ne i32 %16, 27
  br i1 %cmp33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %sw.bb32
  br label %error

if.end35:                                         ; preds = %sw.bb32
  br label %sw.epilog

sw.bb36:                                          ; preds = %if.end
  %17 = load i32, i32* %func_id.addr, align 4
  %cmp37 = icmp ne i32 %17, 33
  br i1 %cmp37, label %land.lhs.true38, label %if.end41

land.lhs.true38:                                  ; preds = %sw.bb36
  %18 = load i32, i32* %func_id.addr, align 4
  %cmp39 = icmp ne i32 %18, 37
  br i1 %cmp39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %land.lhs.true38
  br label %error

if.end41:                                         ; preds = %land.lhs.true38, %sw.bb36
  br label %sw.epilog

sw.bb42:                                          ; preds = %if.end, %if.end
  %19 = load i32, i32* %func_id.addr, align 4
  %cmp43 = icmp ne i32 %19, 81
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %sw.bb42
  br label %error

if.end45:                                         ; preds = %sw.bb42
  br label %sw.epilog

sw.bb46:                                          ; preds = %if.end, %if.end
  %20 = load i32, i32* %func_id.addr, align 4
  %cmp47 = icmp ne i32 %20, 51
  br i1 %cmp47, label %land.lhs.true48, label %if.end51

land.lhs.true48:                                  ; preds = %sw.bb46
  %21 = load i32, i32* %func_id.addr, align 4
  %cmp49 = icmp ne i32 %21, 1
  br i1 %cmp49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %land.lhs.true48
  br label %error

if.end51:                                         ; preds = %land.lhs.true48, %sw.bb46
  br label %sw.epilog

sw.bb52:                                          ; preds = %if.end
  %22 = load i32, i32* %func_id.addr, align 4
  %cmp53 = icmp ne i32 %22, 51
  br i1 %cmp53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %sw.bb52
  br label %error

if.end55:                                         ; preds = %sw.bb52
  br label %sw.epilog

sw.bb56:                                          ; preds = %if.end
  %23 = load i32, i32* %func_id.addr, align 4
  %cmp57 = icmp ne i32 %23, 51
  br i1 %cmp57, label %land.lhs.true58, label %if.end61

land.lhs.true58:                                  ; preds = %sw.bb56
  %24 = load i32, i32* %func_id.addr, align 4
  %cmp59 = icmp ne i32 %24, 1
  br i1 %cmp59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %land.lhs.true58
  br label %error

if.end61:                                         ; preds = %land.lhs.true58, %sw.bb56
  br label %sw.epilog

sw.bb62:                                          ; preds = %if.end, %if.end
  %25 = load i32, i32* %func_id.addr, align 4
  %cmp63 = icmp ne i32 %25, 1
  br i1 %cmp63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %sw.bb62
  br label %error

if.end65:                                         ; preds = %sw.bb62
  br label %sw.epilog

sw.bb66:                                          ; preds = %if.end
  %26 = load i32, i32* %func_id.addr, align 4
  %cmp67 = icmp ne i32 %26, 52
  br i1 %cmp67, label %land.lhs.true68, label %if.end80

land.lhs.true68:                                  ; preds = %sw.bb66
  %27 = load i32, i32* %func_id.addr, align 4
  %cmp69 = icmp ne i32 %27, 53
  br i1 %cmp69, label %land.lhs.true70, label %if.end80

land.lhs.true70:                                  ; preds = %land.lhs.true68
  %28 = load i32, i32* %func_id.addr, align 4
  %cmp71 = icmp ne i32 %28, 3
  br i1 %cmp71, label %land.lhs.true72, label %if.end80

land.lhs.true72:                                  ; preds = %land.lhs.true70
  %29 = load i32, i32* %func_id.addr, align 4
  %cmp73 = icmp ne i32 %29, 60
  br i1 %cmp73, label %land.lhs.true74, label %if.end80

land.lhs.true74:                                  ; preds = %land.lhs.true72
  %30 = load i32, i32* %func_id.addr, align 4
  %cmp75 = icmp ne i32 %30, 82
  br i1 %cmp75, label %land.lhs.true76, label %if.end80

land.lhs.true76:                                  ; preds = %land.lhs.true74
  %31 = load i32, i32* %func_id.addr, align 4
  %cmp77 = icmp ne i32 %31, 1
  br i1 %cmp77, label %land.lhs.true78, label %if.end80

land.lhs.true78:                                  ; preds = %land.lhs.true76
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load i32, i32* %func_id.addr, align 4
  %call = call zeroext i1 @may_update_sockmap(%struct.bpf_verifier_env* noundef %32, i32 noundef %33) #20
  br i1 %call, label %if.end80, label %if.then79

if.then79:                                        ; preds = %land.lhs.true78
  br label %error

if.end80:                                         ; preds = %land.lhs.true78, %land.lhs.true76, %land.lhs.true74, %land.lhs.true72, %land.lhs.true70, %land.lhs.true68, %sw.bb66
  br label %sw.epilog

sw.bb81:                                          ; preds = %if.end
  %34 = load i32, i32* %func_id.addr, align 4
  %cmp82 = icmp ne i32 %34, 72
  br i1 %cmp82, label %land.lhs.true83, label %if.end96

land.lhs.true83:                                  ; preds = %sw.bb81
  %35 = load i32, i32* %func_id.addr, align 4
  %cmp84 = icmp ne i32 %35, 70
  br i1 %cmp84, label %land.lhs.true85, label %if.end96

land.lhs.true85:                                  ; preds = %land.lhs.true83
  %36 = load i32, i32* %func_id.addr, align 4
  %cmp86 = icmp ne i32 %36, 3
  br i1 %cmp86, label %land.lhs.true87, label %if.end96

land.lhs.true87:                                  ; preds = %land.lhs.true85
  %37 = load i32, i32* %func_id.addr, align 4
  %cmp88 = icmp ne i32 %37, 71
  br i1 %cmp88, label %land.lhs.true89, label %if.end96

land.lhs.true89:                                  ; preds = %land.lhs.true87
  %38 = load i32, i32* %func_id.addr, align 4
  %cmp90 = icmp ne i32 %38, 82
  br i1 %cmp90, label %land.lhs.true91, label %if.end96

land.lhs.true91:                                  ; preds = %land.lhs.true89
  %39 = load i32, i32* %func_id.addr, align 4
  %cmp92 = icmp ne i32 %39, 1
  br i1 %cmp92, label %land.lhs.true93, label %if.end96

land.lhs.true93:                                  ; preds = %land.lhs.true91
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = load i32, i32* %func_id.addr, align 4
  %call94 = call zeroext i1 @may_update_sockmap(%struct.bpf_verifier_env* noundef %40, i32 noundef %41) #20
  br i1 %call94, label %if.end96, label %if.then95

if.then95:                                        ; preds = %land.lhs.true93
  br label %error

if.end96:                                         ; preds = %land.lhs.true93, %land.lhs.true91, %land.lhs.true89, %land.lhs.true87, %land.lhs.true85, %land.lhs.true83, %sw.bb81
  br label %sw.epilog

sw.bb97:                                          ; preds = %if.end
  %42 = load i32, i32* %func_id.addr, align 4
  %cmp98 = icmp ne i32 %42, 82
  br i1 %cmp98, label %if.then99, label %if.end100

if.then99:                                        ; preds = %sw.bb97
  br label %error

if.end100:                                        ; preds = %sw.bb97
  br label %sw.epilog

sw.bb101:                                         ; preds = %if.end, %if.end
  %43 = load i32, i32* %func_id.addr, align 4
  %cmp102 = icmp ne i32 %43, 89
  br i1 %cmp102, label %land.lhs.true103, label %if.end108

land.lhs.true103:                                 ; preds = %sw.bb101
  %44 = load i32, i32* %func_id.addr, align 4
  %cmp104 = icmp ne i32 %44, 88
  br i1 %cmp104, label %land.lhs.true105, label %if.end108

land.lhs.true105:                                 ; preds = %land.lhs.true103
  %45 = load i32, i32* %func_id.addr, align 4
  %cmp106 = icmp ne i32 %45, 87
  br i1 %cmp106, label %if.then107, label %if.end108

if.then107:                                       ; preds = %land.lhs.true105
  br label %error

if.end108:                                        ; preds = %land.lhs.true105, %land.lhs.true103, %sw.bb101
  br label %sw.epilog

sw.bb109:                                         ; preds = %if.end
  %46 = load i32, i32* %func_id.addr, align 4
  %cmp110 = icmp ne i32 %46, 107
  br i1 %cmp110, label %land.lhs.true111, label %if.end114

land.lhs.true111:                                 ; preds = %sw.bb109
  %47 = load i32, i32* %func_id.addr, align 4
  %cmp112 = icmp ne i32 %47, 108
  br i1 %cmp112, label %if.then113, label %if.end114

if.then113:                                       ; preds = %land.lhs.true111
  br label %error

if.end114:                                        ; preds = %land.lhs.true111, %sw.bb109
  br label %sw.epilog

sw.bb115:                                         ; preds = %if.end
  %48 = load i32, i32* %func_id.addr, align 4
  %cmp116 = icmp ne i32 %48, 145
  br i1 %cmp116, label %land.lhs.true117, label %if.end120

land.lhs.true117:                                 ; preds = %sw.bb115
  %49 = load i32, i32* %func_id.addr, align 4
  %cmp118 = icmp ne i32 %49, 146
  br i1 %cmp118, label %if.then119, label %if.end120

if.then119:                                       ; preds = %land.lhs.true117
  br label %error

if.end120:                                        ; preds = %land.lhs.true117, %sw.bb115
  br label %sw.epilog

sw.bb121:                                         ; preds = %if.end
  %50 = load i32, i32* %func_id.addr, align 4
  %cmp122 = icmp ne i32 %50, 156
  br i1 %cmp122, label %land.lhs.true123, label %if.end126

land.lhs.true123:                                 ; preds = %sw.bb121
  %51 = load i32, i32* %func_id.addr, align 4
  %cmp124 = icmp ne i32 %51, 157
  br i1 %cmp124, label %if.then125, label %if.end126

if.then125:                                       ; preds = %land.lhs.true123
  br label %error

if.end126:                                        ; preds = %land.lhs.true123, %sw.bb121
  br label %sw.epilog

sw.bb127:                                         ; preds = %if.end
  %52 = load i32, i32* %func_id.addr, align 4
  %cmp128 = icmp ne i32 %52, 89
  br i1 %cmp128, label %land.lhs.true129, label %if.end132

land.lhs.true129:                                 ; preds = %sw.bb127
  %53 = load i32, i32* %func_id.addr, align 4
  %cmp130 = icmp ne i32 %53, 87
  br i1 %cmp130, label %if.then131, label %if.end132

if.then131:                                       ; preds = %land.lhs.true129
  br label %error

if.end132:                                        ; preds = %land.lhs.true129, %sw.bb127
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end132, %if.end126, %if.end120, %if.end114, %if.end108, %if.end100, %if.end96, %if.end80, %if.end65, %if.end61, %if.end55, %if.end51, %if.end45, %if.end41, %if.end35, %if.end31, %if.end27, %if.end13, %if.end2
  %54 = load i32, i32* %func_id.addr, align 4
  switch i32 %54, label %sw.default256 [
    i32 12, label %sw.bb133
    i32 22, label %sw.bb143
    i32 25, label %sw.bb143
    i32 55, label %sw.bb143
    i32 111, label %sw.bb143
    i32 121, label %sw.bb143
    i32 130, label %sw.bb148
    i32 131, label %sw.bb148
    i32 134, label %sw.bb148
    i32 198, label %sw.bb148
    i32 199, label %sw.bb148
    i32 200, label %sw.bb148
    i32 209, label %sw.bb153
    i32 27, label %sw.bb158
    i32 37, label %sw.bb163
    i32 33, label %sw.bb163
    i32 51, label %sw.bb168
    i32 52, label %sw.bb182
    i32 60, label %sw.bb182
    i32 53, label %sw.bb182
    i32 72, label %sw.bb187
    i32 71, label %sw.bb187
    i32 70, label %sw.bb187
    i32 81, label %sw.bb192
    i32 82, label %sw.bb200
    i32 88, label %sw.bb211
    i32 89, label %sw.bb219
    i32 87, label %sw.bb219
    i32 195, label %sw.bb230
    i32 107, label %sw.bb241
    i32 108, label %sw.bb241
    i32 145, label %sw.bb246
    i32 146, label %sw.bb246
    i32 156, label %sw.bb251
    i32 157, label %sw.bb251
  ]

sw.bb133:                                         ; preds = %sw.epilog
  %55 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type134 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %55, i32 0, i32 3
  %56 = load i32, i32* %map_type134, align 8
  %cmp135 = icmp ne i32 %56, 3
  br i1 %cmp135, label %if.then136, label %if.end137

if.then136:                                       ; preds = %sw.bb133
  br label %error

if.end137:                                        ; preds = %sw.bb133
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %57, i32 0, i32 31
  %58 = load i32, i32* %subprog_cnt, align 4
  %cmp138 = icmp ugt i32 %58, 1
  br i1 %cmp138, label %land.lhs.true139, label %if.end142

land.lhs.true139:                                 ; preds = %if.end137
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call140 = call zeroext i1 @allow_tail_call_in_subprogs(%struct.bpf_verifier_env* noundef %59) #20
  br i1 %call140, label %if.end142, label %if.then141

if.then141:                                       ; preds = %land.lhs.true139
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = bitcast %struct.bpf_verifier_env* %60 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %61, i8* noundef getelementptr inbounds ([72 x i8], [72 x i8]* @.str.457, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end142:                                        ; preds = %land.lhs.true139, %if.end137
  br label %sw.epilog257

sw.bb143:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog, %sw.epilog, %sw.epilog
  %62 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type144 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %62, i32 0, i32 3
  %63 = load i32, i32* %map_type144, align 8
  %cmp145 = icmp ne i32 %63, 4
  br i1 %cmp145, label %if.then146, label %if.end147

if.then146:                                       ; preds = %sw.bb143
  br label %error

if.end147:                                        ; preds = %sw.bb143
  br label %sw.epilog257

sw.bb148:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog, %sw.epilog, %sw.epilog, %sw.epilog
  %64 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type149 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %64, i32 0, i32 3
  %65 = load i32, i32* %map_type149, align 8
  %cmp150 = icmp ne i32 %65, 27
  br i1 %cmp150, label %if.then151, label %if.end152

if.then151:                                       ; preds = %sw.bb148
  br label %error

if.end152:                                        ; preds = %sw.bb148
  br label %sw.epilog257

sw.bb153:                                         ; preds = %sw.epilog
  %66 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type154 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %66, i32 0, i32 3
  %67 = load i32, i32* %map_type154, align 8
  %cmp155 = icmp ne i32 %67, 31
  br i1 %cmp155, label %if.then156, label %if.end157

if.then156:                                       ; preds = %sw.bb153
  br label %error

if.end157:                                        ; preds = %sw.bb153
  br label %sw.epilog257

sw.bb158:                                         ; preds = %sw.epilog
  %68 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type159 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %68, i32 0, i32 3
  %69 = load i32, i32* %map_type159, align 8
  %cmp160 = icmp ne i32 %69, 7
  br i1 %cmp160, label %if.then161, label %if.end162

if.then161:                                       ; preds = %sw.bb158
  br label %error

if.end162:                                        ; preds = %sw.bb158
  br label %sw.epilog257

sw.bb163:                                         ; preds = %sw.epilog, %sw.epilog
  %70 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type164 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %70, i32 0, i32 3
  %71 = load i32, i32* %map_type164, align 8
  %cmp165 = icmp ne i32 %71, 8
  br i1 %cmp165, label %if.then166, label %if.end167

if.then166:                                       ; preds = %sw.bb163
  br label %error

if.end167:                                        ; preds = %sw.bb163
  br label %sw.epilog257

sw.bb168:                                         ; preds = %sw.epilog
  %72 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type169 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %72, i32 0, i32 3
  %73 = load i32, i32* %map_type169, align 8
  %cmp170 = icmp ne i32 %73, 14
  br i1 %cmp170, label %land.lhs.true171, label %if.end181

land.lhs.true171:                                 ; preds = %sw.bb168
  %74 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type172 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %74, i32 0, i32 3
  %75 = load i32, i32* %map_type172, align 8
  %cmp173 = icmp ne i32 %75, 25
  br i1 %cmp173, label %land.lhs.true174, label %if.end181

land.lhs.true174:                                 ; preds = %land.lhs.true171
  %76 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type175 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %76, i32 0, i32 3
  %77 = load i32, i32* %map_type175, align 8
  %cmp176 = icmp ne i32 %77, 16
  br i1 %cmp176, label %land.lhs.true177, label %if.end181

land.lhs.true177:                                 ; preds = %land.lhs.true174
  %78 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type178 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %78, i32 0, i32 3
  %79 = load i32, i32* %map_type178, align 8
  %cmp179 = icmp ne i32 %79, 17
  br i1 %cmp179, label %if.then180, label %if.end181

if.then180:                                       ; preds = %land.lhs.true177
  br label %error

if.end181:                                        ; preds = %land.lhs.true177, %land.lhs.true174, %land.lhs.true171, %sw.bb168
  br label %sw.epilog257

sw.bb182:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %80 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type183 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %80, i32 0, i32 3
  %81 = load i32, i32* %map_type183, align 8
  %cmp184 = icmp ne i32 %81, 15
  br i1 %cmp184, label %if.then185, label %if.end186

if.then185:                                       ; preds = %sw.bb182
  br label %error

if.end186:                                        ; preds = %sw.bb182
  br label %sw.epilog257

sw.bb187:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %82 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type188 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %82, i32 0, i32 3
  %83 = load i32, i32* %map_type188, align 8
  %cmp189 = icmp ne i32 %83, 18
  br i1 %cmp189, label %if.then190, label %if.end191

if.then190:                                       ; preds = %sw.bb187
  br label %error

if.end191:                                        ; preds = %sw.bb187
  br label %sw.epilog257

sw.bb192:                                         ; preds = %sw.epilog
  %84 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type193 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %84, i32 0, i32 3
  %85 = load i32, i32* %map_type193, align 8
  %cmp194 = icmp ne i32 %85, 19
  br i1 %cmp194, label %land.lhs.true195, label %if.end199

land.lhs.true195:                                 ; preds = %sw.bb192
  %86 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type196 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %86, i32 0, i32 3
  %87 = load i32, i32* %map_type196, align 8
  %cmp197 = icmp ne i32 %87, 21
  br i1 %cmp197, label %if.then198, label %if.end199

if.then198:                                       ; preds = %land.lhs.true195
  br label %error

if.end199:                                        ; preds = %land.lhs.true195, %sw.bb192
  br label %sw.epilog257

sw.bb200:                                         ; preds = %sw.epilog
  %88 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type201 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %88, i32 0, i32 3
  %89 = load i32, i32* %map_type201, align 8
  %cmp202 = icmp ne i32 %89, 20
  br i1 %cmp202, label %land.lhs.true203, label %if.end210

land.lhs.true203:                                 ; preds = %sw.bb200
  %90 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type204 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %90, i32 0, i32 3
  %91 = load i32, i32* %map_type204, align 8
  %cmp205 = icmp ne i32 %91, 15
  br i1 %cmp205, label %land.lhs.true206, label %if.end210

land.lhs.true206:                                 ; preds = %land.lhs.true203
  %92 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type207 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %92, i32 0, i32 3
  %93 = load i32, i32* %map_type207, align 8
  %cmp208 = icmp ne i32 %93, 18
  br i1 %cmp208, label %if.then209, label %if.end210

if.then209:                                       ; preds = %land.lhs.true206
  br label %error

if.end210:                                        ; preds = %land.lhs.true206, %land.lhs.true203, %sw.bb200
  br label %sw.epilog257

sw.bb211:                                         ; preds = %sw.epilog
  %94 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type212 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %94, i32 0, i32 3
  %95 = load i32, i32* %map_type212, align 8
  %cmp213 = icmp ne i32 %95, 22
  br i1 %cmp213, label %land.lhs.true214, label %if.end218

land.lhs.true214:                                 ; preds = %sw.bb211
  %96 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type215 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %96, i32 0, i32 3
  %97 = load i32, i32* %map_type215, align 8
  %cmp216 = icmp ne i32 %97, 23
  br i1 %cmp216, label %if.then217, label %if.end218

if.then217:                                       ; preds = %land.lhs.true214
  br label %error

if.end218:                                        ; preds = %land.lhs.true214, %sw.bb211
  br label %sw.epilog257

sw.bb219:                                         ; preds = %sw.epilog, %sw.epilog
  %98 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type220 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %98, i32 0, i32 3
  %99 = load i32, i32* %map_type220, align 8
  %cmp221 = icmp ne i32 %99, 22
  br i1 %cmp221, label %land.lhs.true222, label %if.end229

land.lhs.true222:                                 ; preds = %sw.bb219
  %100 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type223 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %100, i32 0, i32 3
  %101 = load i32, i32* %map_type223, align 8
  %cmp224 = icmp ne i32 %101, 23
  br i1 %cmp224, label %land.lhs.true225, label %if.end229

land.lhs.true225:                                 ; preds = %land.lhs.true222
  %102 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type226 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %102, i32 0, i32 3
  %103 = load i32, i32* %map_type226, align 8
  %cmp227 = icmp ne i32 %103, 30
  br i1 %cmp227, label %if.then228, label %if.end229

if.then228:                                       ; preds = %land.lhs.true225
  br label %error

if.end229:                                        ; preds = %land.lhs.true225, %land.lhs.true222, %sw.bb219
  br label %sw.epilog257

sw.bb230:                                         ; preds = %sw.epilog
  %104 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type231 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %104, i32 0, i32 3
  %105 = load i32, i32* %map_type231, align 8
  %cmp232 = icmp ne i32 %105, 6
  br i1 %cmp232, label %land.lhs.true233, label %if.end240

land.lhs.true233:                                 ; preds = %sw.bb230
  %106 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type234 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %106, i32 0, i32 3
  %107 = load i32, i32* %map_type234, align 8
  %cmp235 = icmp ne i32 %107, 5
  br i1 %cmp235, label %land.lhs.true236, label %if.end240

land.lhs.true236:                                 ; preds = %land.lhs.true233
  %108 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type237 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %108, i32 0, i32 3
  %109 = load i32, i32* %map_type237, align 8
  %cmp238 = icmp ne i32 %109, 10
  br i1 %cmp238, label %if.then239, label %if.end240

if.then239:                                       ; preds = %land.lhs.true236
  br label %error

if.end240:                                        ; preds = %land.lhs.true236, %land.lhs.true233, %sw.bb230
  br label %sw.epilog257

sw.bb241:                                         ; preds = %sw.epilog, %sw.epilog
  %110 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type242 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %110, i32 0, i32 3
  %111 = load i32, i32* %map_type242, align 8
  %cmp243 = icmp ne i32 %111, 24
  br i1 %cmp243, label %if.then244, label %if.end245

if.then244:                                       ; preds = %sw.bb241
  br label %error

if.end245:                                        ; preds = %sw.bb241
  br label %sw.epilog257

sw.bb246:                                         ; preds = %sw.epilog, %sw.epilog
  %112 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type247 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %112, i32 0, i32 3
  %113 = load i32, i32* %map_type247, align 8
  %cmp248 = icmp ne i32 %113, 28
  br i1 %cmp248, label %if.then249, label %if.end250

if.then249:                                       ; preds = %sw.bb246
  br label %error

if.end250:                                        ; preds = %sw.bb246
  br label %sw.epilog257

sw.bb251:                                         ; preds = %sw.epilog, %sw.epilog
  %114 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type252 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %114, i32 0, i32 3
  %115 = load i32, i32* %map_type252, align 8
  %cmp253 = icmp ne i32 %115, 29
  br i1 %cmp253, label %if.then254, label %if.end255

if.then254:                                       ; preds = %sw.bb251
  br label %error

if.end255:                                        ; preds = %sw.bb251
  br label %sw.epilog257

sw.default256:                                    ; preds = %sw.epilog
  br label %sw.epilog257

sw.epilog257:                                     ; preds = %sw.default256, %if.end255, %if.end250, %if.end245, %if.end240, %if.end229, %if.end218, %if.end210, %if.end199, %if.end191, %if.end186, %if.end181, %if.end167, %if.end162, %if.end157, %if.end152, %if.end147, %if.end142
  store i32 0, i32* %retval, align 4
  br label %return

error:                                            ; preds = %if.then254, %if.then249, %if.then244, %if.then239, %if.then228, %if.then217, %if.then209, %if.then198, %if.then190, %if.then185, %if.then180, %if.then166, %if.then161, %if.then156, %if.then151, %if.then146, %if.then136, %if.then131, %if.then125, %if.then119, %if.then113, %if.then107, %if.then99, %if.then95, %if.then79, %if.then64, %if.then60, %if.then54, %if.then50, %if.then44, %if.then40, %if.then34, %if.then30, %if.then26, %if.then12, %if.then1
  %116 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %117 = bitcast %struct.bpf_verifier_env* %116 to i8*
  %118 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type258 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %118, i32 0, i32 3
  %119 = load i32, i32* %map_type258, align 8
  %120 = load i32, i32* %func_id.addr, align 4
  %call259 = call i8* @func_id_name(i32 noundef %120) #20
  %121 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %117, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.458, i64 0, i64 0), i32 noundef %119, i8* noundef %call259, i32 noundef %121) #20
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %error, %sw.epilog257, %if.then141, %if.then
  %122 = load i32, i32* %retval, align 4
  ret i32 %122
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @get_callchain_buffers(i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_get_func_ip(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %type = alloca i32, align 4
  %func_id = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %1) #20
  store i32 %call, i32* %type, align 4
  store i32 173, i32* %func_id, align 4
  %2 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %2, 26
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %call2 = call zeroext i1 @bpf_prog_has_trampoline(%struct.bpf_prog* noundef %4) #20
  br i1 %call2, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = bitcast %struct.bpf_verifier_env* %5 to i8*
  %7 = load i32, i32* %func_id, align 4
  %call4 = call i8* @func_id_name(i32 noundef %7) #20
  %8 = load i32, i32* %func_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %6, i8* noundef getelementptr inbounds ([62 x i8], [62 x i8]* @.str.460, i64 0, i64 0), i8* noundef %call4, i32 noundef %8) #20
  store i32 -524, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %9 = load i32, i32* %type, align 4
  %cmp5 = icmp eq i32 %9, 2
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.else
  br label %if.end8

if.end8:                                          ; preds = %if.end7
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load i32, i32* %func_id, align 4
  %call9 = call i8* @func_id_name(i32 noundef %12) #20
  %13 = load i32, i32* %func_id, align 4
  %14 = load i32, i32* %type, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.461, i64 0, i64 0), i8* noundef %call9, i32 noundef %13, i32 noundef %14) #20
  store i32 -524, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then6, %if.end, %if.then3
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %___vstate = alloca %struct.bpf_verifier_state*, align 8
  %___i = alloca i32, align 4
  %___j = alloca i32, align 4
  %___regs = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %___vstate, align 8
  store i32 0, i32* %___i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc50, %entry
  %2 = load i32, i32* %___i, align 4
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %___vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end52

for.body:                                         ; preds = %for.cond
  %5 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %___vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %5, i32 0, i32 0
  %6 = load i32, i32* %___i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %7, %struct.bpf_func_state** %state, align 8
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %___regs, align 8
  store i32 0, i32* %___j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %9 = load i32, i32* %___j, align 4
  %cmp2 = icmp slt i32 %9, 11
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %___regs, align 8
  %11 = load i32, i32* %___j, align 4
  %idxprom4 = sext i32 %11 to i64
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i64 %idxprom4
  store %struct.bpf_reg_state* %arrayidx5, %struct.bpf_reg_state** %reg, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call = call zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %12) #20
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %for.body3
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %13, %struct.bpf_reg_state* noundef %14) #20
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body3
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %15 = load i32, i32* %___j, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %___j, align 4
  br label %for.cond1, !llvm.loop !153

for.end:                                          ; preds = %for.cond1
  store i32 0, i32* %___j, align 4
  %16 = load i32, i32* %___j, align 4
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 10
  %18 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %18, 8
  %cmp6 = icmp slt i32 %16, %div
  br i1 %cmp6, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.end
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 11
  %20 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %21 = load i32, i32* %___j, align 4
  %idxprom7 = sext i32 %21 to i64
  %arrayidx8 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %20, i64 %idxprom7
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx8, i32 0, i32 1
  %arrayidx9 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %22 = load i8, i8* %arrayidx9, align 8
  %conv = zext i8 %22 to i32
  %cmp10 = icmp eq i32 %conv, 1
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack12 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 11
  %24 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack12, align 8
  %25 = load i32, i32* %___j, align 4
  %idxprom13 = sext i32 %25 to i64
  %arrayidx14 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %24, i64 %idxprom13
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx14, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond15

for.cond15:                                       ; preds = %cond.end47, %cond.end
  %26 = load i32, i32* %___j, align 4
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack16 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 10
  %28 = load i32, i32* %allocated_stack16, align 8
  %div17 = sdiv i32 %28, 8
  %cmp18 = icmp slt i32 %26, %div17
  br i1 %cmp18, label %for.body20, label %for.end49

for.body20:                                       ; preds = %for.cond15
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %29, null
  br i1 %tobool, label %if.end22, label %if.then21

if.then21:                                        ; preds = %for.body20
  br label %for.inc26

if.end22:                                         ; preds = %for.body20
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call23 = call zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %30) #20
  br i1 %call23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end22
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %31, %struct.bpf_reg_state* noundef %32) #20
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.end22
  br label %for.inc26

for.inc26:                                        ; preds = %if.end25, %if.then21
  %33 = load i32, i32* %___j, align 4
  %inc27 = add i32 %33, 1
  store i32 %inc27, i32* %___j, align 4
  %34 = load i32, i32* %___j, align 4
  %35 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack28 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %35, i32 0, i32 10
  %36 = load i32, i32* %allocated_stack28, align 8
  %div29 = sdiv i32 %36, 8
  %cmp30 = icmp slt i32 %34, %div29
  br i1 %cmp30, label %land.lhs.true32, label %cond.false46

land.lhs.true32:                                  ; preds = %for.inc26
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack33 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %37, i32 0, i32 11
  %38 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack33, align 8
  %39 = load i32, i32* %___j, align 4
  %idxprom34 = sext i32 %39 to i64
  %arrayidx35 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %38, i64 %idxprom34
  %slot_type36 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx35, i32 0, i32 1
  %arrayidx37 = getelementptr [8 x i8], [8 x i8]* %slot_type36, i64 0, i64 0
  %40 = load i8, i8* %arrayidx37, align 8
  %conv38 = zext i8 %40 to i32
  %cmp39 = icmp eq i32 %conv38, 1
  br i1 %cmp39, label %cond.true41, label %cond.false46

cond.true41:                                      ; preds = %land.lhs.true32
  %41 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack42 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %41, i32 0, i32 11
  %42 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack42, align 8
  %43 = load i32, i32* %___j, align 4
  %idxprom43 = sext i32 %43 to i64
  %arrayidx44 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %42, i64 %idxprom43
  %spilled_ptr45 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx44, i32 0, i32 0
  br label %cond.end47

cond.false46:                                     ; preds = %land.lhs.true32, %for.inc26
  br label %cond.end47

cond.end47:                                       ; preds = %cond.false46, %cond.true41
  %cond48 = phi %struct.bpf_reg_state* [ %spilled_ptr45, %cond.true41 ], [ null, %cond.false46 ]
  store %struct.bpf_reg_state* %cond48, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond15, !llvm.loop !154

for.end49:                                        ; preds = %for.cond15
  br label %for.inc50

for.inc50:                                        ; preds = %for.end49
  %44 = load i32, i32* %___i, align 4
  %inc51 = add i32 %44, 1
  store i32 %inc51, i32* %___i, align 4
  br label %for.cond, !llvm.loop !155

for.end52:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_raw_mode_ok(%struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %count = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 0, i32* %count, align 4
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %0, i32 0, i32 4
  %2 = bitcast %union.anon.203* %1 to %struct.anon.204*
  %arg1_type = getelementptr inbounds %struct.anon.204, %struct.anon.204* %2, i32 0, i32 0
  %3 = load i32, i32* %arg1_type, align 8
  %cmp = icmp eq i32 %3, 32772
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %count, align 4
  %inc = add i32 %4, 1
  store i32 %inc, i32* %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %6 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %5, i32 0, i32 4
  %7 = bitcast %union.anon.203* %6 to %struct.anon.204*
  %arg2_type = getelementptr inbounds %struct.anon.204, %struct.anon.204* %7, i32 0, i32 1
  %8 = load i32, i32* %arg2_type, align 4
  %cmp1 = icmp eq i32 %8, 32772
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %9 = load i32, i32* %count, align 4
  %inc3 = add i32 %9, 1
  store i32 %inc3, i32* %count, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %10 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %11 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %10, i32 0, i32 4
  %12 = bitcast %union.anon.203* %11 to %struct.anon.204*
  %arg3_type = getelementptr inbounds %struct.anon.204, %struct.anon.204* %12, i32 0, i32 2
  %13 = load i32, i32* %arg3_type, align 8
  %cmp5 = icmp eq i32 %13, 32772
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %14 = load i32, i32* %count, align 4
  %inc7 = add i32 %14, 1
  store i32 %inc7, i32* %count, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %15 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %16 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %15, i32 0, i32 4
  %17 = bitcast %union.anon.203* %16 to %struct.anon.204*
  %arg4_type = getelementptr inbounds %struct.anon.204, %struct.anon.204* %17, i32 0, i32 3
  %18 = load i32, i32* %arg4_type, align 4
  %cmp9 = icmp eq i32 %18, 32772
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %19 = load i32, i32* %count, align 4
  %inc11 = add i32 %19, 1
  store i32 %inc11, i32* %count, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %20 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %21 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %20, i32 0, i32 4
  %22 = bitcast %union.anon.203* %21 to %struct.anon.204*
  %arg5_type = getelementptr inbounds %struct.anon.204, %struct.anon.204* %22, i32 0, i32 4
  %23 = load i32, i32* %arg5_type, align 8
  %cmp13 = icmp eq i32 %23, 32772
  br i1 %cmp13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %24 = load i32, i32* %count, align 4
  %inc15 = add i32 %24, 1
  store i32 %inc15, i32* %count, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %25 = load i32, i32* %count, align 4
  %cmp17 = icmp sle i32 %25, 1
  ret i1 %cmp17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_arg_pair_ok(%struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %retval = alloca i1, align 1
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %0, i32 0, i32 4
  %2 = bitcast %union.anon.203* %1 to %struct.anon.204*
  %arg1_type = getelementptr inbounds %struct.anon.204, %struct.anon.204* %2, i32 0, i32 0
  %3 = load i32, i32* %arg1_type, align 8
  %call = call zeroext i1 @arg_type_is_mem_size(i32 noundef %3) #20
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call1 = call zeroext i1 @check_args_pair_invalid(%struct.bpf_func_proto* noundef %4, i32 noundef 0) #20
  br i1 %call1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %5 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call3 = call zeroext i1 @check_args_pair_invalid(%struct.bpf_func_proto* noundef %5, i32 noundef 1) #20
  br i1 %call3, label %if.then, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %6 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call5 = call zeroext i1 @check_args_pair_invalid(%struct.bpf_func_proto* noundef %6, i32 noundef 2) #20
  br i1 %call5, label %if.then, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %7 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call7 = call zeroext i1 @check_args_pair_invalid(%struct.bpf_func_proto* noundef %7, i32 noundef 3) #20
  br i1 %call7, label %if.then, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %8 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call9 = call zeroext i1 @check_args_pair_invalid(%struct.bpf_func_proto* noundef %8, i32 noundef 4) #20
  br i1 %call9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false8, %lor.lhs.false6, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false8
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i1, i1* %retval, align 1
  ret i1 %9
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_btf_id_ok(%struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %retval = alloca i1, align 1
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %conv = sext i32 %0 to i64
  %cmp = icmp ult i64 %conv, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %2 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %1, i32 0, i32 4
  %arg_type = bitcast %union.anon.203* %2 to [5 x i32]*
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [5 x i32], [5 x i32]* %arg_type, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4
  %call = call i32 @base_type(i32 noundef %4) #20
  %cmp2 = icmp eq i32 %call, 14
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %5 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %6 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %5, i32 0, i32 5
  %arg_btf_id = bitcast %union.anon.205* %6 to [5 x i32*]*
  %7 = load i32, i32* %i, align 4
  %idxprom4 = sext i32 %7 to i64
  %arrayidx5 = getelementptr [5 x i32*], [5 x i32*]* %arg_btf_id, i64 0, i64 %idxprom4
  %8 = load i32*, i32** %arrayidx5, align 8
  %tobool = icmp ne i32* %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %land.lhs.true, %for.body
  %9 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %10 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %9, i32 0, i32 4
  %arg_type6 = bitcast %union.anon.203* %10 to [5 x i32]*
  %11 = load i32, i32* %i, align 4
  %idxprom7 = sext i32 %11 to i64
  %arrayidx8 = getelementptr [5 x i32], [5 x i32]* %arg_type6, i64 0, i64 %idxprom7
  %12 = load i32, i32* %arrayidx8, align 4
  %call9 = call i32 @base_type(i32 noundef %12) #20
  %cmp10 = icmp ne i32 %call9, 14
  br i1 %cmp10, label %land.lhs.true12, label %if.end29

land.lhs.true12:                                  ; preds = %if.end
  %13 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %14 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %13, i32 0, i32 5
  %arg_btf_id13 = bitcast %union.anon.205* %14 to [5 x i32*]*
  %15 = load i32, i32* %i, align 4
  %idxprom14 = sext i32 %15 to i64
  %arrayidx15 = getelementptr [5 x i32*], [5 x i32*]* %arg_btf_id13, i64 0, i64 %idxprom14
  %16 = load i32*, i32** %arrayidx15, align 8
  %tobool16 = icmp ne i32* %16, null
  br i1 %tobool16, label %land.lhs.true17, label %if.end29

land.lhs.true17:                                  ; preds = %land.lhs.true12
  %17 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %18 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %17, i32 0, i32 4
  %arg_type18 = bitcast %union.anon.203* %18 to [5 x i32]*
  %19 = load i32, i32* %i, align 4
  %idxprom19 = sext i32 %19 to i64
  %arrayidx20 = getelementptr [5 x i32], [5 x i32]* %arg_type18, i64 0, i64 %idxprom19
  %20 = load i32, i32* %arrayidx20, align 4
  %call21 = call i32 @base_type(i32 noundef %20) #20
  %cmp22 = icmp ne i32 %call21, 4
  br i1 %cmp22, label %if.then28, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true17
  %21 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %22 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %21, i32 0, i32 4
  %arg_type24 = bitcast %union.anon.203* %22 to [5 x i32]*
  %23 = load i32, i32* %i, align 4
  %idxprom25 = sext i32 %23 to i64
  %arrayidx26 = getelementptr [5 x i32], [5 x i32]* %arg_type24, i64 0, i64 %idxprom25
  %24 = load i32, i32* %arrayidx26, align 4
  %and = and i32 %24, 262144
  %tobool27 = icmp ne i32 %and, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %lor.lhs.false, %land.lhs.true17
  store i1 false, i1* %retval, align 1
  br label %return

if.end29:                                         ; preds = %lor.lhs.false, %land.lhs.true12, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end29
  %25 = load i32, i32* %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !156

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then28, %if.then
  %26 = load i1, i1* %retval, align 1
  ret i1 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_mem_size(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 5
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 6
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_args_pair_invalid(%struct.bpf_func_proto* noundef %fn, i32 noundef %arg) #0 {
entry:
  %retval = alloca i1, align 1
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %arg.addr = alloca i32, align 4
  %is_fixed = alloca i8, align 1
  %has_size = alloca i8, align 1
  %is_next_size = alloca i8, align 1
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 %arg, i32* %arg.addr, align 4
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %0, i32 0, i32 4
  %arg_type = bitcast %union.anon.203* %1 to [5 x i32]*
  %2 = load i32, i32* %arg.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [5 x i32], [5 x i32]* %arg_type, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4
  %and = and i32 %3, 262144
  %tobool = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* %is_fixed, align 1
  %4 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %5 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %4, i32 0, i32 5
  %arg_size = bitcast %union.anon.205* %5 to [5 x i64]*
  %6 = load i32, i32* %arg.addr, align 4
  %idxprom1 = sext i32 %6 to i64
  %arrayidx2 = getelementptr [5 x i64], [5 x i64]* %arg_size, i64 0, i64 %idxprom1
  %7 = load i64, i64* %arrayidx2, align 8
  %cmp = icmp ne i64 %7, 0
  %frombool3 = zext i1 %cmp to i8
  store i8 %frombool3, i8* %has_size, align 1
  store i8 0, i8* %is_next_size, align 1
  %8 = load i32, i32* %arg.addr, align 4
  %add = add i32 %8, 1
  %conv = sext i32 %add to i64
  %cmp4 = icmp ult i64 %conv, 5
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %10 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %9, i32 0, i32 4
  %arg_type6 = bitcast %union.anon.203* %10 to [5 x i32]*
  %11 = load i32, i32* %arg.addr, align 4
  %add7 = add i32 %11, 1
  %idxprom8 = sext i32 %add7 to i64
  %arrayidx9 = getelementptr [5 x i32], [5 x i32]* %arg_type6, i64 0, i64 %idxprom8
  %12 = load i32, i32* %arrayidx9, align 4
  %call = call zeroext i1 @arg_type_is_mem_size(i32 noundef %12) #20
  %frombool10 = zext i1 %call to i8
  store i8 %frombool10, i8* %is_next_size, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %13 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %14 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %13, i32 0, i32 4
  %arg_type11 = bitcast %union.anon.203* %14 to [5 x i32]*
  %15 = load i32, i32* %arg.addr, align 4
  %idxprom12 = sext i32 %15 to i64
  %arrayidx13 = getelementptr [5 x i32], [5 x i32]* %arg_type11, i64 0, i64 %idxprom12
  %16 = load i32, i32* %arrayidx13, align 4
  %call14 = call i32 @base_type(i32 noundef %16) #20
  %cmp15 = icmp ne i32 %call14, 4
  br i1 %cmp15, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end
  %17 = load i8, i8* %is_next_size, align 1
  %tobool18 = trunc i8 %17 to i1
  store i1 %tobool18, i1* %retval, align 1
  br label %return

if.end19:                                         ; preds = %if.end
  %18 = load i8, i8* %has_size, align 1
  %tobool20 = trunc i8 %18 to i1
  %conv21 = zext i1 %tobool20 to i32
  %19 = load i8, i8* %is_next_size, align 1
  %tobool22 = trunc i8 %19 to i1
  %conv23 = zext i1 %tobool22 to i32
  %cmp24 = icmp eq i32 %conv21, %conv23
  br i1 %cmp24, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end19
  %20 = load i8, i8* %is_next_size, align 1
  %tobool26 = trunc i8 %20 to i1
  %conv27 = zext i1 %tobool26 to i32
  %21 = load i8, i8* %is_fixed, align 1
  %tobool28 = trunc i8 %21 to i1
  %conv29 = zext i1 %tobool28 to i32
  %cmp30 = icmp eq i32 %conv27, %conv29
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end19
  %22 = phi i1 [ true, %if.end19 ], [ %cmp30, %lor.rhs ]
  store i1 %22, i1* %retval, align 1
  br label %return

return:                                           ; preds = %lor.end, %if.then17
  %23 = load i1, i1* %retval, align 1
  ret i1 %23
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @resolve_map_arg_type(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32* noundef %arg_type) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %arg_type.addr = alloca i32*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32* %arg_type, i32** %arg_type.addr, align 8
  %0 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %0, i32 0, i32 0
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %tobool = icmp ne %struct.bpf_map* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.407, i64 0, i64 0)) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr1 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr1, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %5, i32 0, i32 3
  %6 = load i32, i32* %map_type, align 8
  switch i32 %6, label %sw.default [
    i32 15, label %sw.bb
    i32 18, label %sw.bb
    i32 30, label %sw.bb4
  ]

sw.bb:                                            ; preds = %if.end, %if.end
  %7 = load i32*, i32** %arg_type.addr, align 8
  %8 = load i32, i32* %7, align 4
  %cmp = icmp eq i32 %8, 3
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %sw.bb
  %9 = load i32*, i32** %arg_type.addr, align 8
  store i32 17, i32* %9, align 4
  br label %if.end3

if.else:                                          ; preds = %sw.bb
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.408, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.then2
  br label %sw.epilog

sw.bb4:                                           ; preds = %if.end
  %12 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %func_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %12, i32 0, i32 10
  %13 = load i32, i32* %func_id, align 8
  %cmp5 = icmp eq i32 %13, 89
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %sw.bb4
  %14 = load i32*, i32** %arg_type.addr, align 8
  store i32 3, i32* %14, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %sw.bb4
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end7, %if.end3
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.else, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_reg_type(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %arg_type, i32* noundef %arg_btf_id, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %arg_type.addr = alloca i32, align 4
  %arg_btf_id.addr = alloca i32*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %expected = alloca i32, align 4
  %type = alloca i32, align 4
  %compatible = alloca %struct.bpf_reg_types*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %strict_type_match = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %arg_type, i32* %arg_type.addr, align 4
  store i32* %arg_btf_id, i32** %arg_btf_id.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type1, align 8
  store i32 %4, i32* %type, align 4
  %5 = load i32, i32* %arg_type.addr, align 4
  %call2 = call i32 @base_type(i32 noundef %5) #20
  %idxprom3 = zext i32 %call2 to i64
  %arrayidx4 = getelementptr [25 x %struct.bpf_reg_types*], [25 x %struct.bpf_reg_types*]* @compatible_reg_types, i64 0, i64 %idxprom3
  %6 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %arrayidx4, align 8
  store %struct.bpf_reg_types* %6, %struct.bpf_reg_types** %compatible, align 8
  %7 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %tobool = icmp ne %struct.bpf_reg_types* %7, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  %10 = load i32, i32* %arg_type.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.409, i64 0, i64 0), i32 noundef %10) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load i32, i32* %arg_type.addr, align 4
  %and = and i32 %11, 512
  %tobool5 = icmp ne i32 %and, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %12 = load i32, i32* %type, align 4
  %and7 = and i32 %12, -513
  store i32 %and7, i32* %type, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %13 = load i32, i32* %arg_type.addr, align 4
  %and9 = and i32 %13, 256
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  %14 = load i32, i32* %type, align 4
  %and12 = and i32 %14, -257
  store i32 %and12, i32* %type, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end13
  %15 = load i32, i32* %i, align 4
  %conv = sext i32 %15 to i64
  %cmp = icmp ult i64 %conv, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %types = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %16, i32 0, i32 0
  %17 = load i32, i32* %i, align 4
  %idxprom15 = sext i32 %17 to i64
  %arrayidx16 = getelementptr [10 x i32], [10 x i32]* %types, i64 0, i64 %idxprom15
  %18 = load i32, i32* %arrayidx16, align 4
  store i32 %18, i32* %expected, align 4
  %19 = load i32, i32* %expected, align 4
  %cmp17 = icmp eq i32 %19, 0
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %for.body
  br label %for.end

if.end20:                                         ; preds = %for.body
  %20 = load i32, i32* %type, align 4
  %21 = load i32, i32* %expected, align 4
  %cmp21 = icmp eq i32 %20, %21
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  br label %found

if.end24:                                         ; preds = %if.end20
  br label %for.inc

for.inc:                                          ; preds = %if.end24
  %22 = load i32, i32* %i, align 4
  %inc = add i32 %22, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !157

for.end:                                          ; preds = %if.then19, %for.cond
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  %25 = load i32, i32* %regno.addr, align 4
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 0
  %28 = load i32, i32* %type25, align 8
  %call26 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %26, i32 noundef %28) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.410, i64 0, i64 0), i32 noundef %25, i8* noundef %call26) #20
  store i32 0, i32* %j, align 4
  br label %for.cond27

for.cond27:                                       ; preds = %for.inc35, %for.end
  %29 = load i32, i32* %j, align 4
  %add = add i32 %29, 1
  %30 = load i32, i32* %i, align 4
  %cmp28 = icmp slt i32 %add, %30
  br i1 %cmp28, label %for.body30, label %for.end37

for.body30:                                       ; preds = %for.cond27
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = bitcast %struct.bpf_verifier_env* %31 to i8*
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %types31 = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %34, i32 0, i32 0
  %35 = load i32, i32* %j, align 4
  %idxprom32 = sext i32 %35 to i64
  %arrayidx33 = getelementptr [10 x i32], [10 x i32]* %types31, i64 0, i64 %idxprom32
  %36 = load i32, i32* %arrayidx33, align 4
  %call34 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %33, i32 noundef %36) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %32, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.411, i64 0, i64 0), i8* noundef %call34) #20
  br label %for.inc35

for.inc35:                                        ; preds = %for.body30
  %37 = load i32, i32* %j, align 4
  %inc36 = add i32 %37, 1
  store i32 %inc36, i32* %j, align 4
  br label %for.cond27, !llvm.loop !158

for.end37:                                        ; preds = %for.cond27
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = bitcast %struct.bpf_verifier_env* %38 to i8*
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %types38 = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %41, i32 0, i32 0
  %42 = load i32, i32* %j, align 4
  %idxprom39 = sext i32 %42 to i64
  %arrayidx40 = getelementptr [10 x i32], [10 x i32]* %types38, i64 0, i64 %idxprom39
  %43 = load i32, i32* %arrayidx40, align 4
  %call41 = call i8* @reg_type_str(%struct.bpf_verifier_env* noundef %40, i32 noundef %43) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %39, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.180, i64 0, i64 0), i8* noundef %call41) #20
  store i32 -13, i32* %retval, align 4
  br label %return

found:                                            ; preds = %if.then23
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 0
  %45 = load i32, i32* %type42, align 8
  %cmp43 = icmp eq i32 %45, 16
  br i1 %cmp43, label %if.then45, label %if.end79

if.then45:                                        ; preds = %found
  %46 = load i32, i32* %arg_type.addr, align 4
  %call46 = call zeroext i1 @arg_type_is_release(i32 noundef %46) #20
  br i1 %call46, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then45
  %47 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %func_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %47, i32 0, i32 10
  %48 = load i32, i32* %func_id, align 8
  %cmp48 = icmp ne i32 %48, 86
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then45
  %49 = phi i1 [ false, %if.then45 ], [ %cmp48, %land.rhs ]
  %frombool = zext i1 %49 to i8
  store i8 %frombool, i8* %strict_type_match, align 1
  %50 = load i32*, i32** %arg_btf_id.addr, align 8
  %tobool50 = icmp ne i32* %50, null
  br i1 %tobool50, label %if.end56, label %if.then51

if.then51:                                        ; preds = %land.end
  %51 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %btf_id = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %51, i32 0, i32 1
  %52 = load i32*, i32** %btf_id, align 8
  %tobool52 = icmp ne i32* %52, null
  br i1 %tobool52, label %if.end54, label %if.then53

if.then53:                                        ; preds = %if.then51
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = bitcast %struct.bpf_verifier_env* %53 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %54, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.412, i64 0, i64 0)) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.then51
  %55 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %btf_id55 = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %55, i32 0, i32 1
  %56 = load i32*, i32** %btf_id55, align 8
  store i32* %56, i32** %arg_btf_id.addr, align 8
  br label %if.end56

if.end56:                                         ; preds = %if.end54, %land.end
  %57 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %func_id57 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %57, i32 0, i32 10
  %58 = load i32, i32* %func_id57, align 8
  %cmp58 = icmp eq i32 %58, 194
  br i1 %cmp58, label %if.then60, label %if.else

if.then60:                                        ; preds = %if.end56
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %kptr_off_desc = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %60, i32 0, i32 16
  %61 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %kptr_off_desc, align 8
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %63 = load i32, i32* %regno.addr, align 4
  %call61 = call i32 @map_kptr_match_type(%struct.bpf_verifier_env* noundef %59, %struct.bpf_map_value_off_desc* noundef %61, %struct.bpf_reg_state* noundef %62, i32 noundef %63) #20
  %tobool62 = icmp ne i32 %call61, 0
  br i1 %tobool62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.then60
  store i32 -13, i32* %retval, align 4
  br label %return

if.end64:                                         ; preds = %if.then60
  br label %if.end78

if.else:                                          ; preds = %if.end56
  %64 = load i32*, i32** %arg_btf_id.addr, align 8
  %cmp65 = icmp eq i32* %64, inttoptr (i64 -2401263026318546017 to i32*)
  br i1 %cmp65, label %if.then67, label %if.end68

if.then67:                                        ; preds = %if.else
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %66 = bitcast %struct.bpf_verifier_env* %65 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %66, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.378, i64 0, i64 0)) #20
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %68 = bitcast %struct.bpf_verifier_env* %67 to i8*
  %69 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %68, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.413, i64 0, i64 0), i32 noundef %69) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end68:                                         ; preds = %if.else
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %70, i32 0, i32 26
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %72 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 2
  %73 = bitcast %union.anon.168* %72 to %struct.anon.170*
  %btf = getelementptr inbounds %struct.anon.170, %struct.anon.170* %73, i32 0, i32 0
  %74 = load %struct.btf*, %struct.btf** %btf, align 8
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %76 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %75, i32 0, i32 2
  %77 = bitcast %union.anon.168* %76 to %struct.anon.170*
  %btf_id69 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %77, i32 0, i32 1
  %78 = load i32, i32* %btf_id69, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %79, i32 0, i32 1
  %80 = load i32, i32* %off, align 4
  %81 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %82 = load i32*, i32** %arg_btf_id.addr, align 8
  %83 = load i32, i32* %82, align 4
  %84 = load i8, i8* %strict_type_match, align 1
  %tobool70 = trunc i8 %84 to i1
  %call71 = call zeroext i1 @btf_struct_ids_match(%struct.bpf_verifier_log* noundef %log, %struct.btf* noundef %74, i32 noundef %78, i32 noundef %80, %struct.btf* noundef %81, i32 noundef %83, i1 noundef zeroext %tobool70) #20
  br i1 %call71, label %if.end77, label %if.then72

if.then72:                                        ; preds = %if.end68
  %85 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %86 = bitcast %struct.bpf_verifier_env* %85 to i8*
  %87 = load i32, i32* %regno.addr, align 4
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %89 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 2
  %90 = bitcast %union.anon.168* %89 to %struct.anon.170*
  %btf73 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %90, i32 0, i32 0
  %91 = load %struct.btf*, %struct.btf** %btf73, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %93 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 2
  %94 = bitcast %union.anon.168* %93 to %struct.anon.170*
  %btf_id74 = getelementptr inbounds %struct.anon.170, %struct.anon.170* %94, i32 0, i32 1
  %95 = load i32, i32* %btf_id74, align 8
  %call75 = call i8* @kernel_type_name(%struct.btf* noundef %91, i32 noundef %95) #20
  %96 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %97 = load i32*, i32** %arg_btf_id.addr, align 8
  %98 = load i32, i32* %97, align 4
  %call76 = call i8* @kernel_type_name(%struct.btf* noundef %96, i32 noundef %98) #20
  call void (i8*, i8*, ...) @verbose(i8* noundef %86, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.414, i64 0, i64 0), i32 noundef %87, i8* noundef %call75, i8* noundef %call76) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %if.end68
  br label %if.end78

if.end78:                                         ; preds = %if.end77, %if.end64
  br label %if.end79

if.end79:                                         ; preds = %if.end78, %found
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end79, %if.then72, %if.then67, %if.then63, %if.then53, %for.end37, %if.then
  %99 = load i32, i32* %retval, align 4
  ret i32 %99
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @process_spin_lock(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i1 noundef zeroext %is_lock) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %is_lock.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %is_const = alloca i8, align 1
  %map = alloca %struct.bpf_map*, align 8
  %val = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %frombool = zext i1 %is_lock to i8
  store i8 %frombool, i8* %is_lock.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 8
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %4, %struct.bpf_verifier_state** %cur, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 5
  %6 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %call1 = call zeroext i1 @tnum_is_const(i64 %8, i64 %10) #20
  %frombool2 = zext i1 %call1 to i8
  store i8 %frombool2, i8* %is_const, align 1
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 2
  %13 = bitcast %union.anon.168* %12 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %13, i32 0, i32 0
  %14 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %14, %struct.bpf_map** %map, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off3, i32 0, i32 0
  %16 = load i64, i64* %value, align 8
  store i64 %16, i64* %val, align 8
  %17 = load i8, i8* %is_const, align 1
  %tobool = trunc i8 %17 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([82 x i8], [82 x i8]* @.str.429, i64 0, i64 0), i32 noundef %20) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %21 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %btf = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %21, i32 0, i32 17
  %22 = load %struct.btf*, %struct.btf** %btf, align 8
  %tobool4 = icmp ne %struct.btf* %22, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  %25 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %25, i32 0, i32 18
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %name, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.430, i64 0, i64 0), i8* noundef %arraydecay) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %26 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call7 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %26) #20
  br i1 %call7, label %if.end22, label %if.then8

if.then8:                                         ; preds = %if.end6
  %27 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %27, i32 0, i32 9
  %28 = load i32, i32* %spin_lock_off, align 4
  %cmp = icmp eq i32 %28, -7
  br i1 %cmp, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name10 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %31, i32 0, i32 18
  %arraydecay11 = getelementptr inbounds [16 x i8], [16 x i8]* %name10, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.431, i64 0, i64 0), i8* noundef %arraydecay11) #20
  br label %if.end21

if.else:                                          ; preds = %if.then8
  %32 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off12 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %32, i32 0, i32 9
  %33 = load i32, i32* %spin_lock_off12, align 4
  %cmp13 = icmp eq i32 %33, -2
  br i1 %cmp13, label %if.then14, label %if.else17

if.then14:                                        ; preds = %if.else
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name15 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %36, i32 0, i32 18
  %arraydecay16 = getelementptr inbounds [16 x i8], [16 x i8]* %name15, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.432, i64 0, i64 0), i8* noundef %arraydecay16) #20
  br label %if.end20

if.else17:                                        ; preds = %if.else
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = bitcast %struct.bpf_verifier_env* %37 to i8*
  %39 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name18 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %39, i32 0, i32 18
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %name18, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %38, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.433, i64 0, i64 0), i8* noundef %arraydecay19) #20
  br label %if.end20

if.end20:                                         ; preds = %if.else17, %if.then14
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then9
  store i32 -22, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end6
  %40 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off23 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %40, i32 0, i32 9
  %41 = load i32, i32* %spin_lock_off23, align 4
  %conv = sext i32 %41 to i64
  %42 = load i64, i64* %val, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 1
  %44 = load i32, i32* %off, align 4
  %conv24 = sext i32 %44 to i64
  %add = add i64 %42, %conv24
  %cmp25 = icmp ne i64 %conv, %add
  br i1 %cmp25, label %if.then27, label %if.end31

if.then27:                                        ; preds = %if.end22
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = bitcast %struct.bpf_verifier_env* %45 to i8*
  %47 = load i64, i64* %val, align 8
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 1
  %49 = load i32, i32* %off28, align 4
  %conv29 = sext i32 %49 to i64
  %add30 = add i64 %47, %conv29
  call void (i8*, i8*, ...) @verbose(i8* noundef %46, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.434, i64 0, i64 0), i64 noundef %add30) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end22
  %50 = load i8, i8* %is_lock.addr, align 1
  %tobool32 = trunc i8 %50 to i1
  br i1 %tobool32, label %if.then33, label %if.else38

if.then33:                                        ; preds = %if.end31
  %51 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %51, i32 0, i32 5
  %52 = load i32, i32* %active_spin_lock, align 4
  %tobool34 = icmp ne i32 %52, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then33
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = bitcast %struct.bpf_verifier_env* %53 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %54, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.435, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.then33
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 3
  %56 = load i32, i32* %id, align 8
  %57 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock37 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %57, i32 0, i32 5
  store i32 %56, i32* %active_spin_lock37, align 4
  br label %if.end50

if.else38:                                        ; preds = %if.end31
  %58 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock39 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %58, i32 0, i32 5
  %59 = load i32, i32* %active_spin_lock39, align 4
  %tobool40 = icmp ne i32 %59, 0
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.else38
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = bitcast %struct.bpf_verifier_env* %60 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %61, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.436, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end42:                                         ; preds = %if.else38
  %62 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock43 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %62, i32 0, i32 5
  %63 = load i32, i32* %active_spin_lock43, align 4
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %64, i32 0, i32 3
  %65 = load i32, i32* %id44, align 8
  %cmp45 = icmp ne i32 %63, %65
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end42
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = bitcast %struct.bpf_verifier_env* %66 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %67, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.437, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.end42
  %68 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock49 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %68, i32 0, i32 5
  store i32 0, i32* %active_spin_lock49, align 4
  br label %if.end50

if.end50:                                         ; preds = %if.end48, %if.end36
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end50, %if.then47, %if.then41, %if.then35, %if.then27, %if.end21, %if.then5, %if.then
  %69 = load i32, i32* %retval, align 4
  ret i32 %69
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @process_timer_func(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %is_const = alloca i8, align 1
  %map = alloca %struct.bpf_map*, align 8
  %val = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 5
  %4 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 0
  %6 = load i64, i64* %5, align 8
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %4, i32 0, i32 1
  %8 = load i64, i64* %7, align 8
  %call1 = call zeroext i1 @tnum_is_const(i64 %6, i64 %8) #20
  %frombool = zext i1 %call1 to i8
  store i8 %frombool, i8* %is_const, align 1
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 2
  %11 = bitcast %union.anon.168* %10 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %11, i32 0, i32 0
  %12 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %12, %struct.bpf_map** %map, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off2, i32 0, i32 0
  %14 = load i64, i64* %value, align 8
  store i64 %14, i64* %val, align 8
  %15 = load i8, i8* %is_const, align 1
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([78 x i8], [78 x i8]* @.str.438, i64 0, i64 0), i32 noundef %18) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %19 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %btf = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %19, i32 0, i32 17
  %20 = load %struct.btf*, %struct.btf** %btf, align 8
  %tobool3 = icmp ne %struct.btf* %20, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  %23 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %23, i32 0, i32 18
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %name, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.439, i64 0, i64 0), i8* noundef %arraydecay) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %24 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call6 = call zeroext i1 @map_value_has_timer(%struct.bpf_map* noundef %24) #20
  br i1 %call6, label %if.end21, label %if.then7

if.then7:                                         ; preds = %if.end5
  %25 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %timer_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %25, i32 0, i32 11
  %26 = load i32, i32* %timer_off, align 64
  %cmp = icmp eq i32 %26, -7
  br i1 %cmp, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then7
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = bitcast %struct.bpf_verifier_env* %27 to i8*
  %29 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name9 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %29, i32 0, i32 18
  %arraydecay10 = getelementptr inbounds [16 x i8], [16 x i8]* %name9, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %28, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.440, i64 0, i64 0), i8* noundef %arraydecay10) #20
  br label %if.end20

if.else:                                          ; preds = %if.then7
  %30 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %timer_off11 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %30, i32 0, i32 11
  %31 = load i32, i32* %timer_off11, align 64
  %cmp12 = icmp eq i32 %31, -2
  br i1 %cmp12, label %if.then13, label %if.else16

if.then13:                                        ; preds = %if.else
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = bitcast %struct.bpf_verifier_env* %32 to i8*
  %34 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name14 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %34, i32 0, i32 18
  %arraydecay15 = getelementptr inbounds [16 x i8], [16 x i8]* %name14, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %33, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.441, i64 0, i64 0), i8* noundef %arraydecay15) #20
  br label %if.end19

if.else16:                                        ; preds = %if.else
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name17 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %37, i32 0, i32 18
  %arraydecay18 = getelementptr inbounds [16 x i8], [16 x i8]* %name17, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.442, i64 0, i64 0), i8* noundef %arraydecay18) #20
  br label %if.end19

if.end19:                                         ; preds = %if.else16, %if.then13
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end5
  %38 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %timer_off22 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %38, i32 0, i32 11
  %39 = load i32, i32* %timer_off22, align 64
  %conv = sext i32 %39 to i64
  %40 = load i64, i64* %val, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 1
  %42 = load i32, i32* %off, align 4
  %conv23 = sext i32 %42 to i64
  %add = add i64 %40, %conv23
  %cmp24 = icmp ne i64 %conv, %add
  br i1 %cmp24, label %if.then26, label %if.end31

if.then26:                                        ; preds = %if.end21
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = bitcast %struct.bpf_verifier_env* %43 to i8*
  %45 = load i64, i64* %val, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 1
  %47 = load i32, i32* %off27, align 4
  %conv28 = sext i32 %47 to i64
  %add29 = add i64 %45, %conv28
  %48 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %timer_off30 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %48, i32 0, i32 11
  %49 = load i32, i32* %timer_off30, align 64
  call void (i8*, i8*, ...) @verbose(i8* noundef %44, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.443, i64 0, i64 0), i64 noundef %add29, i32 noundef %49) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end21
  %50 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr32 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %50, i32 0, i32 0
  %51 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr32, align 8
  %tobool33 = icmp ne %struct.bpf_map* %51, null
  br i1 %tobool33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end31
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.444, i64 0, i64 0)) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end35:                                         ; preds = %if.end31
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %55 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 2
  %56 = bitcast %union.anon.168* %55 to %struct.anon.169*
  %map_uid = getelementptr inbounds %struct.anon.169, %struct.anon.169* %56, i32 0, i32 1
  %57 = load i32, i32* %map_uid, align 8
  %58 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_uid36 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %58, i32 0, i32 9
  store i32 %57, i32* %map_uid36, align 4
  %59 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %60 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr37 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %60, i32 0, i32 0
  store %struct.bpf_map* %59, %struct.bpf_map** %map_ptr37, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end35, %if.then34, %if.then26, %if.end20, %if.then4, %if.then
  %61 = load i32, i32* %retval, align 4
  ret i32 %61
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_dynptr_reg_valid_uninit(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %spi = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %0, %struct.bpf_reg_state* noundef %1) #20
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 1
  %3 = load i32, i32* %off, align 4
  %call1 = call i32 @get_spi(i32 noundef %3) #20
  store i32 %call1, i32* %spi, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %5 = load i32, i32* %spi, align 4
  %call2 = call zeroext i1 @is_spi_bounds_valid(%struct.bpf_func_state* noundef %4, i32 noundef %5, i32 noundef 2) #20
  br i1 %call2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %6, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 11
  %8 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %9 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %8, i64 %idxprom
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 1
  %10 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %10 to i64
  %arrayidx4 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom3
  %11 = load i8, i8* %arrayidx4, align 1
  %conv = zext i8 %11 to i32
  %cmp5 = icmp eq i32 %conv, 4
  br i1 %cmp5, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 11
  %13 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack7, align 8
  %14 = load i32, i32* %spi, align 4
  %sub = sub i32 %14, 1
  %idxprom8 = sext i32 %sub to i64
  %arrayidx9 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %13, i64 %idxprom8
  %slot_type10 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx9, i32 0, i32 1
  %15 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %15 to i64
  %arrayidx12 = getelementptr [8 x i8], [8 x i8]* %slot_type10, i64 0, i64 %idxprom11
  %16 = load i8, i8* %arrayidx12, align 1
  %conv13 = zext i8 %16 to i32
  %cmp14 = icmp eq i32 %conv13, 4
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %for.body
  store i1 false, i1* %retval, align 1
  br label %return

if.end17:                                         ; preds = %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %17 = load i32, i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !159

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then16, %if.then
  %18 = load i1, i1* %retval, align 1
  ret i1 %18
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @int_ptr_type_to_size(i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 11
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 4, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 12
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store i32 8, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @strnchr(i8* noundef, i64 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @process_kptr_func(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %off_desc = alloca %struct.bpf_map_value_off_desc*, align 8
  %map_ptr = alloca %struct.bpf_map*, align 8
  %kptr_off = alloca i32, align 4
  %ret = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 2
  %5 = bitcast %union.anon.168* %4 to %struct.anon.169*
  %map_ptr1 = getelementptr inbounds %struct.anon.169, %struct.anon.169* %5, i32 0, i32 0
  %6 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr1, align 8
  store %struct.bpf_map* %6, %struct.bpf_map** %map_ptr, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #20
  br i1 %call2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  %15 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([73 x i8], [73 x i8]* @.str.445, i64 0, i64 0), i32 noundef %15) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %16 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %btf = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %16, i32 0, i32 17
  %17 = load %struct.btf*, %struct.btf** %btf, align 8
  %tobool = icmp ne %struct.btf* %17, null
  br i1 %tobool, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %name = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %20, i32 0, i32 18
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %name, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.446, i64 0, i64 0), i8* noundef %arraydecay) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %21 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %call5 = call zeroext i1 @map_value_has_kptrs(%struct.bpf_map* noundef %21) #20
  br i1 %call5, label %if.end20, label %if.then6

if.then6:                                         ; preds = %if.end4
  %22 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %kptr_off_tab = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %22, i32 0, i32 10
  %23 = load %struct.bpf_map_value_off*, %struct.bpf_map_value_off** %kptr_off_tab, align 8
  %24 = bitcast %struct.bpf_map_value_off* %23 to i8*
  %call7 = call i32 @PTR_ERR_OR_ZERO(i8* noundef %24) #20
  store i32 %call7, i32* %ret, align 4
  %25 = load i32, i32* %ret, align 4
  %cmp = icmp eq i32 %25, -7
  br i1 %cmp, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then6
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %name9 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %28, i32 0, i32 18
  %arraydecay10 = getelementptr inbounds [16 x i8], [16 x i8]* %name9, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.447, i64 0, i64 0), i8* noundef %arraydecay10, i32 noundef 8) #20
  br label %if.end19

if.else:                                          ; preds = %if.then6
  %29 = load i32, i32* %ret, align 4
  %cmp11 = icmp eq i32 %29, -17
  br i1 %cmp11, label %if.then12, label %if.else15

if.then12:                                        ; preds = %if.else
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %name13 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %32, i32 0, i32 18
  %arraydecay14 = getelementptr inbounds [16 x i8], [16 x i8]* %name13, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.448, i64 0, i64 0), i8* noundef %arraydecay14) #20
  br label %if.end18

if.else15:                                        ; preds = %if.else
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  %35 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %name16 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %35, i32 0, i32 18
  %arraydecay17 = getelementptr inbounds [16 x i8], [16 x i8]* %name16, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.449, i64 0, i64 0), i8* noundef %arraydecay17) #20
  br label %if.end18

if.end18:                                         ; preds = %if.else15, %if.then12
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.then8
  store i32 -22, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.end4
  %36 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %37 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr21 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %37, i32 0, i32 0
  store %struct.bpf_map* %36, %struct.bpf_map** %map_ptr21, align 8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 1
  %39 = load i32, i32* %off, align 4
  %conv = sext i32 %39 to i64
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off22, i32 0, i32 0
  %41 = load i64, i64* %value, align 8
  %add = add i64 %conv, %41
  %conv23 = trunc i64 %add to i32
  store i32 %conv23, i32* %kptr_off, align 4
  %42 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %43 = load i32, i32* %kptr_off, align 4
  %call24 = call %struct.bpf_map_value_off_desc* @bpf_map_kptr_off_contains(%struct.bpf_map* noundef %42, i32 noundef %43) #20
  store %struct.bpf_map_value_off_desc* %call24, %struct.bpf_map_value_off_desc** %off_desc, align 8
  %44 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc, align 8
  %tobool25 = icmp ne %struct.bpf_map_value_off_desc* %44, null
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %if.end20
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = bitcast %struct.bpf_verifier_env* %45 to i8*
  %47 = load i32, i32* %kptr_off, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %46, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.450, i64 0, i64 0), i32 noundef %47) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.end20
  %48 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc, align 8
  %type = getelementptr inbounds %struct.bpf_map_value_off_desc, %struct.bpf_map_value_off_desc* %48, i32 0, i32 1
  %49 = load i32, i32* %type, align 4
  %cmp28 = icmp ne i32 %49, 1
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end27
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = bitcast %struct.bpf_verifier_env* %50 to i8*
  %52 = load i32, i32* %kptr_off, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %51, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.451, i64 0, i64 0), i32 noundef %52) #20
  store i32 -13, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end27
  %53 = load %struct.bpf_map_value_off_desc*, %struct.bpf_map_value_off_desc** %off_desc, align 8
  %54 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %kptr_off_desc = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %54, i32 0, i32 16
  store %struct.bpf_map_value_off_desc* %53, %struct.bpf_map_value_off_desc** %kptr_off_desc, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end31, %if.then30, %if.then26, %if.end19, %if.then3, %if.then
  %55 = load i32, i32* %retval, align 4
  ret i32 %55
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @PTR_ERR_OR_ZERO(i8* noundef %ptr) #0 {
entry:
  %retval = alloca i32, align 4
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %call = call zeroext i1 @IS_ERR(i8* noundef %0) #20
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %ptr.addr, align 8
  %call1 = call i64 @PTR_ERR(i8* noundef %1) #20
  %conv = trunc i64 %call1 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_map_ptr_store(%struct.bpf_insn_aux_data* noundef %aux, %struct.bpf_map* noundef %map, i1 noundef zeroext %unpriv) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  %unpriv.addr = alloca i8, align 1
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %frombool = zext i1 %unpriv to i8
  store i8 %frombool, i8* %unpriv.addr, align 1
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %call = call zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %0) #20
  %conv = zext i1 %call to i32
  %1 = load i8, i8* %unpriv.addr, align 1
  %tobool = trunc i8 %1 to i1
  %conv1 = zext i1 %tobool to i32
  %or = or i32 %conv1, %conv
  %tobool2 = icmp ne i32 %or, 0
  %frombool3 = zext i1 %tobool2 to i8
  store i8 %frombool3, i8* %unpriv.addr, align 1
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %3 = ptrtoint %struct.bpf_map* %2 to i64
  %4 = load i8, i8* %unpriv.addr, align 1
  %tobool4 = trunc i8 %4 to i1
  %5 = zext i1 %tobool4 to i64
  %cond = select i1 %tobool4, i64 1, i64 0
  %or6 = or i64 %3, %cond
  %6 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %7 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %6, i32 0, i32 0
  %map_ptr_state = bitcast %union.anon.210* %7 to i64*
  store i64 %or6, i64* %map_ptr_state, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 0
  %map_ptr_state = bitcast %union.anon.210* %1 to i64*
  %2 = load i64, i64* %map_ptr_state, align 8
  %and = and i64 %2, 1
  %tobool = icmp ne i64 %and, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @register_is_const(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %5, i64 %7) #20
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_map_key_store(%struct.bpf_insn_aux_data* noundef %aux, i64 noundef %state) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %state.addr = alloca i64, align 8
  %poisoned = alloca i8, align 1
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store i64 %state, i64* %state.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %call = call zeroext i1 @bpf_map_key_poisoned(%struct.bpf_insn_aux_data* noundef %0) #20
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %poisoned, align 1
  %1 = load i64, i64* %state.addr, align 8
  %or = or i64 %1, 4611686018427387904
  %2 = load i8, i8* %poisoned, align 1
  %tobool = trunc i8 %2 to i1
  %3 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i64 -9223372036854775808, i64 0
  %or1 = or i64 %or, %cond
  %4 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %map_key_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %4, i32 0, i32 1
  store i64 %or1, i64* %map_key_state, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_key_unseen(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %map_key_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 1
  %1 = load i64, i64* %map_key_state, align 8
  %and = and i64 %1, 4611686018427387904
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_key_poisoned(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %map_key_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 1
  %1 = load i64, i64* %map_key_state, align 8
  %and = and i64 %1, -9223372036854775808
  %tobool = icmp ne i64 %and, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @bpf_map_key_immediate(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %map_key_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 1
  %1 = load i64, i64* %map_key_state, align 8
  %and = and i64 %1, 4611686018427387903
  ret i64 %and
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @dynptr_type_refcounted(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 2
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 0
  %map_ptr_state = bitcast %union.anon.210* %1 to i64*
  %2 = load i64, i64* %map_ptr_state, align 8
  %and = and i64 %2, -2
  %3 = inttoptr i64 %and to %struct.bpf_map*
  %cmp = icmp eq %struct.bpf_map* %3, inttoptr (i64 -2401263026318485698 to %struct.bpf_map*)
  ret i1 %cmp
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_bprintf_prepare(i8* noundef, i32 noundef, i64* noundef, i32** noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @loop_flag_is_zero(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %reg_is_null = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #20
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 4
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %2) #20
  %frombool = zext i1 %call1 to i8
  store i8 %frombool, i8* %reg_is_null, align 1
  %3 = load i8, i8* %reg_is_null, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call2 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %4, i32 noundef 4) #20
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i8, i8* %reg_is_null, align 1
  %tobool3 = trunc i8 %5 to i1
  ret i1 %tobool3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_update_sockmap(%struct.bpf_verifier_env* noundef %env, i32 noundef %func_id) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %func_id.addr = alloca i32, align 4
  %eatype = alloca i32, align 4
  %type = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 3
  %2 = load i32, i32* %expected_attach_type, align 8
  store i32 %2, i32* %eatype, align 4
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %4) #20
  store i32 %call, i32* %type, align 4
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %5, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, i32* %type, align 4
  switch i32 %6, label %sw.default [
    i32 26, label %sw.bb
    i32 1, label %sw.bb5
    i32 3, label %sw.bb5
    i32 4, label %sw.bb5
    i32 6, label %sw.bb5
    i32 21, label %sw.bb5
    i32 22, label %sw.bb5
    i32 30, label %sw.bb5
  ]

sw.bb:                                            ; preds = %if.end
  %7 = load i32, i32* %eatype, align 4
  %cmp2 = icmp eq i32 %7, 28
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %sw.bb
  store i1 true, i1* %retval, align 1
  br label %return

if.end4:                                          ; preds = %sw.bb
  br label %sw.epilog

sw.bb5:                                           ; preds = %if.end, %if.end, %if.end, %if.end, %if.end, %if.end, %if.end
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end4
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.459, i64 0, i64 0)) #20
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb5, %if.then3, %if.then
  %10 = load i1, i1* %retval, align 1
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @allow_tail_call_in_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 1
  %bf.load = load i16, i16* %jit_requested, align 2
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %conv = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %call = call zeroext i1 @bpf_jit_supports_subprog_tailcalls() #20
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_jit_supports_subprog_tailcalls() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_prog_has_trampoline(%struct.bpf_prog* noundef %prog) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  ret i1 false
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %0) #20
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  %2 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %2, 9
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %cmp, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @verbose_invalid_scalar(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, %struct.tnum* noundef %range, i8* noundef %ctx, i8* noundef %reg_name) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %range.addr = alloca %struct.tnum*, align 8
  %ctx.addr = alloca i8*, align 8
  %reg_name.addr = alloca i8*, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store %struct.tnum* %range, %struct.tnum** %range.addr, align 8
  store i8* %ctx, i8** %ctx.addr, align 8
  store i8* %reg_name, i8** %reg_name.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = bitcast %struct.bpf_verifier_env* %0 to i8*
  %2 = load i8*, i8** %ctx.addr, align 8
  %3 = load i8*, i8** %reg_name.addr, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %1, i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str.469, i64 0, i64 0), i8* noundef %2, i8* noundef %3) #20
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %5 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = load i64, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %call = call zeroext i1 @tnum_is_unknown(i64 %7, i64 %9) #20
  br i1 %call, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %11 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call2 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %13, i64 %15) #20
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %arraydecay3 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.470, i64 0, i64 0), i8* noundef %arraydecay3) #20
  br label %if.end

if.else:                                          ; preds = %entry
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.471, i64 0, i64 0)) #20
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %arraydecay4 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %20 = load %struct.tnum*, %struct.tnum** %range.addr, align 8
  %21 = bitcast %struct.tnum* %20 to { i64, i64 }*
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 1
  %25 = load i64, i64* %24, align 8
  %call5 = call i32 @tnum_strn(i8* noundef %arraydecay4, i64 noundef 48, i64 %23, i64 %25) #20
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %arraydecay6 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.472, i64 0, i64 0), i8* noundef %arraydecay6) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_pkt_ptr_branch_taken(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, i8 noundef zeroext %opcode) #0 {
entry:
  %retval = alloca i32, align 4
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %opcode.addr = alloca i8, align 1
  %pkt = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 9
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %2, %struct.bpf_reg_state** %pkt, align 8
  br label %if.end6

if.else:                                          ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type1, align 8
  %cmp2 = icmp eq i32 %4, 9
  br i1 %cmp2, label %if.then3, label %if.else5

if.then3:                                         ; preds = %if.else
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %5, %struct.bpf_reg_state** %pkt, align 8
  %6 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %6 to i32
  %call = call i32 @flip_opcode(i32 noundef %conv) #20
  %conv4 = trunc i32 %call to i8
  store i8 %conv4, i8* %opcode.addr, align 1
  br label %if.end

if.else5:                                         ; preds = %if.else
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then3
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %pkt, align 8
  %8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 2
  %range = bitcast %union.anon.168* %8 to i32*
  %9 = load i32, i32* %range, align 8
  %cmp7 = icmp sge i32 %9, 0
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  store i32 -1, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %10 = load i8, i8* %opcode.addr, align 1
  %conv11 = zext i8 %10 to i32
  switch i32 %conv11, label %sw.epilog [
    i32 176, label %sw.bb
    i32 32, label %sw.bb12
    i32 160, label %sw.bb21
    i32 48, label %sw.bb22
  ]

sw.bb:                                            ; preds = %if.end10
  br label %sw.bb12

sw.bb12:                                          ; preds = %if.end10, %sw.bb
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %pkt, align 8
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 2
  %range13 = bitcast %union.anon.168* %12 to i32*
  %13 = load i32, i32* %range13, align 8
  %cmp14 = icmp eq i32 %13, -2
  br i1 %cmp14, label %if.then16, label %if.end20

if.then16:                                        ; preds = %sw.bb12
  %14 = load i8, i8* %opcode.addr, align 1
  %conv17 = zext i8 %14 to i32
  %cmp18 = icmp eq i32 %conv17, 32
  %conv19 = zext i1 %cmp18 to i32
  store i32 %conv19, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %sw.bb12
  br label %sw.epilog

sw.bb21:                                          ; preds = %if.end10
  br label %sw.bb22

sw.bb22:                                          ; preds = %if.end10, %sw.bb21
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %pkt, align 8
  %16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 2
  %range23 = bitcast %union.anon.168* %16 to i32*
  %17 = load i32, i32* %range23, align 8
  %cmp24 = icmp eq i32 %17, -2
  br i1 %cmp24, label %if.then29, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb22
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %pkt, align 8
  %19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 2
  %range26 = bitcast %union.anon.168* %19 to i32*
  %20 = load i32, i32* %range26, align 8
  %cmp27 = icmp eq i32 %20, -1
  br i1 %cmp27, label %if.then29, label %if.end33

if.then29:                                        ; preds = %lor.lhs.false, %sw.bb22
  %21 = load i8, i8* %opcode.addr, align 1
  %conv30 = zext i8 %21 to i32
  %cmp31 = icmp eq i32 %conv30, 48
  %conv32 = zext i1 %cmp31 to i32
  store i32 %conv32, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %lor.lhs.false
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end10, %if.end33, %if.end20
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then29, %if.then16, %if.then9, %if.else5
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @find_equal_scalars(%struct.bpf_verifier_state* noundef %vstate, %struct.bpf_reg_state* noundef %known_reg) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %known_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %___vstate = alloca %struct.bpf_verifier_state*, align 8
  %___i = alloca i32, align 4
  %___j = alloca i32, align 4
  %___regs = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_reg_state* %known_reg, %struct.bpf_reg_state** %known_reg.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_verifier_state* %0, %struct.bpf_verifier_state** %___vstate, align 8
  store i32 0, i32* %___i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc61, %entry
  %1 = load i32, i32* %___i, align 4
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %___vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %1, %3
  br i1 %cmp, label %for.body, label %for.end63

for.body:                                         ; preds = %for.cond
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %___vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 0
  %5 = load i32, i32* %___i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %6, %struct.bpf_func_state** %state, align 8
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %___regs, align 8
  store i32 0, i32* %___j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %8 = load i32, i32* %___j, align 4
  %cmp2 = icmp slt i32 %8, 11
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %___regs, align 8
  %10 = load i32, i32* %___j, align 4
  %idxprom4 = sext i32 %10 to i64
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i64 %idxprom4
  store %struct.bpf_reg_state* %arrayidx5, %struct.bpf_reg_state** %reg, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 0
  %12 = load i32, i32* %type, align 8
  %cmp6 = icmp eq i32 %12, 1
  br i1 %cmp6, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body3
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 3
  %14 = load i32, i32* %id, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %known_reg.addr, align 8
  %id7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 3
  %16 = load i32, i32* %id7, align 8
  %cmp8 = icmp eq i32 %14, %16
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %known_reg.addr, align 8
  %19 = bitcast %struct.bpf_reg_state* %17 to i8*
  %20 = bitcast %struct.bpf_reg_state* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 %20, i64 120, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body3
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %21 = load i32, i32* %___j, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %___j, align 4
  br label %for.cond1, !llvm.loop !160

for.end:                                          ; preds = %for.cond1
  store i32 0, i32* %___j, align 4
  %22 = load i32, i32* %___j, align 4
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 10
  %24 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %24, 8
  %cmp9 = icmp slt i32 %22, %div
  br i1 %cmp9, label %land.lhs.true10, label %cond.false

land.lhs.true10:                                  ; preds = %for.end
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 11
  %26 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %27 = load i32, i32* %___j, align 4
  %idxprom11 = sext i32 %27 to i64
  %arrayidx12 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %26, i64 %idxprom11
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx12, i32 0, i32 1
  %arrayidx13 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %28 = load i8, i8* %arrayidx13, align 8
  %conv = zext i8 %28 to i32
  %cmp14 = icmp eq i32 %conv, 1
  br i1 %cmp14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true10
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack16 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 11
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack16, align 8
  %31 = load i32, i32* %___j, align 4
  %idxprom17 = sext i32 %31 to i64
  %arrayidx18 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom17
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx18, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true10, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond19

for.cond19:                                       ; preds = %cond.end58, %cond.end
  %32 = load i32, i32* %___j, align 4
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack20 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 10
  %34 = load i32, i32* %allocated_stack20, align 8
  %div21 = sdiv i32 %34, 8
  %cmp22 = icmp slt i32 %32, %div21
  br i1 %cmp22, label %for.body24, label %for.end60

for.body24:                                       ; preds = %for.cond19
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %35, null
  br i1 %tobool, label %if.end26, label %if.then25

if.then25:                                        ; preds = %for.body24
  br label %for.inc37

if.end26:                                         ; preds = %for.body24
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 0
  %37 = load i32, i32* %type27, align 8
  %cmp28 = icmp eq i32 %37, 1
  br i1 %cmp28, label %land.lhs.true30, label %if.end36

land.lhs.true30:                                  ; preds = %if.end26
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 3
  %39 = load i32, i32* %id31, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %known_reg.addr, align 8
  %id32 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 3
  %41 = load i32, i32* %id32, align 8
  %cmp33 = icmp eq i32 %39, %41
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %land.lhs.true30
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %known_reg.addr, align 8
  %44 = bitcast %struct.bpf_reg_state* %42 to i8*
  %45 = bitcast %struct.bpf_reg_state* %43 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %44, i8* align 8 %45, i64 120, i1 false)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %land.lhs.true30, %if.end26
  br label %for.inc37

for.inc37:                                        ; preds = %if.end36, %if.then25
  %46 = load i32, i32* %___j, align 4
  %inc38 = add i32 %46, 1
  store i32 %inc38, i32* %___j, align 4
  %47 = load i32, i32* %___j, align 4
  %48 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack39 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %48, i32 0, i32 10
  %49 = load i32, i32* %allocated_stack39, align 8
  %div40 = sdiv i32 %49, 8
  %cmp41 = icmp slt i32 %47, %div40
  br i1 %cmp41, label %land.lhs.true43, label %cond.false57

land.lhs.true43:                                  ; preds = %for.inc37
  %50 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack44 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %50, i32 0, i32 11
  %51 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack44, align 8
  %52 = load i32, i32* %___j, align 4
  %idxprom45 = sext i32 %52 to i64
  %arrayidx46 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %51, i64 %idxprom45
  %slot_type47 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx46, i32 0, i32 1
  %arrayidx48 = getelementptr [8 x i8], [8 x i8]* %slot_type47, i64 0, i64 0
  %53 = load i8, i8* %arrayidx48, align 8
  %conv49 = zext i8 %53 to i32
  %cmp50 = icmp eq i32 %conv49, 1
  br i1 %cmp50, label %cond.true52, label %cond.false57

cond.true52:                                      ; preds = %land.lhs.true43
  %54 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack53 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %54, i32 0, i32 11
  %55 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack53, align 8
  %56 = load i32, i32* %___j, align 4
  %idxprom54 = sext i32 %56 to i64
  %arrayidx55 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %55, i64 %idxprom54
  %spilled_ptr56 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx55, i32 0, i32 0
  br label %cond.end58

cond.false57:                                     ; preds = %land.lhs.true43, %for.inc37
  br label %cond.end58

cond.end58:                                       ; preds = %cond.false57, %cond.true52
  %cond59 = phi %struct.bpf_reg_state* [ %spilled_ptr56, %cond.true52 ], [ null, %cond.false57 ]
  store %struct.bpf_reg_state* %cond59, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond19, !llvm.loop !161

for.end60:                                        ; preds = %for.cond19
  br label %for.inc61

for.inc61:                                        ; preds = %for.end60
  %57 = load i32, i32* %___i, align 4
  %inc62 = add i32 %57, 1
  store i32 %inc62, i32* %___i, align 4
  br label %for.cond, !llvm.loop !162

for.end63:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_ptr_or_null_regs(%struct.bpf_verifier_state* noundef %vstate, i32 noundef %regno, i1 noundef zeroext %is_null) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %regno.addr = alloca i32, align 4
  %is_null.addr = alloca i8, align 1
  %state = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %ref_obj_id = alloca i32, align 4
  %id = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp = alloca i64, align 8
  %___vstate = alloca %struct.bpf_verifier_state*, align 8
  %___i = alloca i32, align 4
  %___j = alloca i32, align 4
  %___regs = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %frombool = zext i1 %is_null to i8
  store i8 %frombool, i8* %is_null.addr, align 1
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %3, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %6 = load i32, i32* %regno.addr, align 4
  %idxprom2 = zext i32 %6 to i64
  %arrayidx3 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i64 %idxprom2
  %ref_obj_id4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx3, i32 0, i32 4
  %7 = load i32, i32* %ref_obj_id4, align 4
  store i32 %7, i32* %ref_obj_id, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %9 = load i32, i32* %regno.addr, align 4
  %idxprom5 = zext i32 %9 to i64
  %arrayidx6 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i64 %idxprom5
  %id7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx6, i32 0, i32 3
  %10 = load i32, i32* %id7, align 8
  store i32 %10, i32* %id, align 4
  %11 = load i32, i32* %ref_obj_id, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %entry
  %12 = load i32, i32* %ref_obj_id, align 4
  %13 = load i32, i32* %id, align 4
  %cmp = icmp eq i32 %12, %13
  br i1 %cmp, label %land.lhs.true8, label %if.end31

land.lhs.true8:                                   ; preds = %land.lhs.true
  %14 = load i8, i8* %is_null.addr, align 1
  %tobool9 = trunc i8 %14 to i1
  br i1 %tobool9, label %if.then, label %if.end31

if.then:                                          ; preds = %land.lhs.true8
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %16 = load i32, i32* %id, align 4
  %call = call i32 @release_reference_state(%struct.bpf_func_state* noundef %15, i32 noundef %16) #20
  %tobool10 = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %17 = load i32, i32* %__ret_warn_on, align 4
  %tobool12 = icmp ne i32 %17, 0
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv = sext i32 %lnot.ext16 to i64
  %tobool17 = icmp ne i64 %conv, 0
  br i1 %tobool17, label %if.then18, label %if.end

if.then18:                                        ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then18
  store i32 2307, i32* %__flags, align 4
  br label %do.body19

do.body19:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body19
  br label %do.body20

do.body20:                                        ; preds = %do.end
  %18 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 10313, i32 %18, i64 12) #19, !srcloc !163
  br label %do.end21

do.end21:                                         ; preds = %do.body20
  br label %do.body22

do.body22:                                        ; preds = %do.end21
  br label %do.end23

do.end23:                                         ; preds = %do.body22
  br label %do.end24

do.end24:                                         ; preds = %do.end23
  br label %if.end

if.end:                                           ; preds = %do.end24, %if.then
  %19 = load i32, i32* %__ret_warn_on, align 4
  %tobool25 = icmp ne i32 %19, 0
  %lnot26 = xor i1 %tobool25, true
  %lnot28 = xor i1 %lnot26, true
  %lnot.ext29 = zext i1 %lnot28 to i32
  %conv30 = sext i32 %lnot.ext29 to i64
  store i64 %conv30, i64* %tmp, align 8
  %20 = load i64, i64* %tmp, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.end, %land.lhs.true8, %land.lhs.true, %entry
  %21 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_verifier_state* %21, %struct.bpf_verifier_state** %___vstate, align 8
  store i32 0, i32* %___i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc93, %if.end31
  %22 = load i32, i32* %___i, align 4
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %___vstate, align 8
  %curframe32 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 4
  %24 = load i32, i32* %curframe32, align 8
  %cmp33 = icmp ule i32 %22, %24
  br i1 %cmp33, label %for.body, label %for.end95

for.body:                                         ; preds = %for.cond
  %25 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %___vstate, align 8
  %frame35 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %25, i32 0, i32 0
  %26 = load i32, i32* %___i, align 4
  %idxprom36 = sext i32 %26 to i64
  %arrayidx37 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame35, i64 0, i64 %idxprom36
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx37, align 8
  store %struct.bpf_func_state* %27, %struct.bpf_func_state** %state, align 8
  %28 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs38 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %28, i32 0, i32 0
  %arraydecay39 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs38, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay39, %struct.bpf_reg_state** %___regs, align 8
  store i32 0, i32* %___j, align 4
  br label %for.cond40

for.cond40:                                       ; preds = %for.inc, %for.body
  %29 = load i32, i32* %___j, align 4
  %cmp41 = icmp slt i32 %29, 11
  br i1 %cmp41, label %for.body43, label %for.end

for.body43:                                       ; preds = %for.cond40
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %___regs, align 8
  %31 = load i32, i32* %___j, align 4
  %idxprom44 = sext i32 %31 to i64
  %arrayidx45 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i64 %idxprom44
  store %struct.bpf_reg_state* %arrayidx45, %struct.bpf_reg_state** %reg, align 8
  %32 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %34 = load i32, i32* %id, align 4
  %35 = load i8, i8* %is_null.addr, align 1
  %tobool46 = trunc i8 %35 to i1
  call void @mark_ptr_or_null_reg(%struct.bpf_func_state* noundef %32, %struct.bpf_reg_state* noundef %33, i32 noundef %34, i1 noundef zeroext %tobool46) #20
  br label %for.inc

for.inc:                                          ; preds = %for.body43
  %36 = load i32, i32* %___j, align 4
  %inc = add i32 %36, 1
  store i32 %inc, i32* %___j, align 4
  br label %for.cond40, !llvm.loop !164

for.end:                                          ; preds = %for.cond40
  store i32 0, i32* %___j, align 4
  %37 = load i32, i32* %___j, align 4
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %38, i32 0, i32 10
  %39 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %39, 8
  %cmp47 = icmp slt i32 %37, %div
  br i1 %cmp47, label %land.lhs.true49, label %cond.false

land.lhs.true49:                                  ; preds = %for.end
  %40 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %40, i32 0, i32 11
  %41 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %42 = load i32, i32* %___j, align 4
  %idxprom50 = sext i32 %42 to i64
  %arrayidx51 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %41, i64 %idxprom50
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx51, i32 0, i32 1
  %arrayidx52 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %43 = load i8, i8* %arrayidx52, align 8
  %conv53 = zext i8 %43 to i32
  %cmp54 = icmp eq i32 %conv53, 1
  br i1 %cmp54, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true49
  %44 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack56 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %44, i32 0, i32 11
  %45 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack56, align 8
  %46 = load i32, i32* %___j, align 4
  %idxprom57 = sext i32 %46 to i64
  %arrayidx58 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %45, i64 %idxprom57
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx58, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true49, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond59

for.cond59:                                       ; preds = %cond.end90, %cond.end
  %47 = load i32, i32* %___j, align 4
  %48 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack60 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %48, i32 0, i32 10
  %49 = load i32, i32* %allocated_stack60, align 8
  %div61 = sdiv i32 %49, 8
  %cmp62 = icmp slt i32 %47, %div61
  br i1 %cmp62, label %for.body64, label %for.end92

for.body64:                                       ; preds = %for.cond59
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool65 = icmp ne %struct.bpf_reg_state* %50, null
  br i1 %tobool65, label %if.end67, label %if.then66

if.then66:                                        ; preds = %for.body64
  br label %for.inc69

if.end67:                                         ; preds = %for.body64
  %51 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %53 = load i32, i32* %id, align 4
  %54 = load i8, i8* %is_null.addr, align 1
  %tobool68 = trunc i8 %54 to i1
  call void @mark_ptr_or_null_reg(%struct.bpf_func_state* noundef %51, %struct.bpf_reg_state* noundef %52, i32 noundef %53, i1 noundef zeroext %tobool68) #20
  br label %for.inc69

for.inc69:                                        ; preds = %if.end67, %if.then66
  %55 = load i32, i32* %___j, align 4
  %inc70 = add i32 %55, 1
  store i32 %inc70, i32* %___j, align 4
  %56 = load i32, i32* %___j, align 4
  %57 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack71 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %57, i32 0, i32 10
  %58 = load i32, i32* %allocated_stack71, align 8
  %div72 = sdiv i32 %58, 8
  %cmp73 = icmp slt i32 %56, %div72
  br i1 %cmp73, label %land.lhs.true75, label %cond.false89

land.lhs.true75:                                  ; preds = %for.inc69
  %59 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack76 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %59, i32 0, i32 11
  %60 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack76, align 8
  %61 = load i32, i32* %___j, align 4
  %idxprom77 = sext i32 %61 to i64
  %arrayidx78 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %60, i64 %idxprom77
  %slot_type79 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx78, i32 0, i32 1
  %arrayidx80 = getelementptr [8 x i8], [8 x i8]* %slot_type79, i64 0, i64 0
  %62 = load i8, i8* %arrayidx80, align 8
  %conv81 = zext i8 %62 to i32
  %cmp82 = icmp eq i32 %conv81, 1
  br i1 %cmp82, label %cond.true84, label %cond.false89

cond.true84:                                      ; preds = %land.lhs.true75
  %63 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack85 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %63, i32 0, i32 11
  %64 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack85, align 8
  %65 = load i32, i32* %___j, align 4
  %idxprom86 = sext i32 %65 to i64
  %arrayidx87 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %64, i64 %idxprom86
  %spilled_ptr88 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx87, i32 0, i32 0
  br label %cond.end90

cond.false89:                                     ; preds = %land.lhs.true75, %for.inc69
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false89, %cond.true84
  %cond91 = phi %struct.bpf_reg_state* [ %spilled_ptr88, %cond.true84 ], [ null, %cond.false89 ]
  store %struct.bpf_reg_state* %cond91, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond59, !llvm.loop !165

for.end92:                                        ; preds = %for.cond59
  br label %for.inc93

for.inc93:                                        ; preds = %for.end92
  %66 = load i32, i32* %___i, align 4
  %inc94 = add i32 %66, 1
  store i32 %inc94, i32* %___i, align 4
  br label %for.cond, !llvm.loop !166

for.end95:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @try_match_pkt_pointers(%struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_verifier_state* noundef %this_branch, %struct.bpf_verifier_state* noundef %other_branch) #0 {
entry:
  %retval = alloca i1, align 1
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %this_branch.addr = alloca %struct.bpf_verifier_state*, align 8
  %other_branch.addr = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_verifier_state* %this_branch, %struct.bpf_verifier_state** %this_branch.addr, align 8
  store %struct.bpf_verifier_state* %other_branch, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 8
  %cmp = icmp ne i32 %and, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 7
  %cmp5 = icmp eq i32 %and4, 6
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  store i1 false, i1* %retval, align 1
  br label %return

if.end8:                                          ; preds = %if.end
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 0
  %5 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %5 to i32
  %and11 = and i32 %conv10, 240
  switch i32 %and11, label %sw.default [
    i32 32, label %sw.bb
    i32 160, label %sw.bb48
    i32 48, label %sw.bb93
    i32 176, label %sw.bb138
  ]

sw.bb:                                            ; preds = %if.end8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp12 = icmp eq i32 %7, 8
  br i1 %cmp12, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %sw.bb
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 0
  %9 = load i32, i32* %type14, align 8
  %cmp15 = icmp eq i32 %9, 9
  br i1 %cmp15, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %sw.bb
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 0
  %11 = load i32, i32* %type17, align 8
  %cmp18 = icmp eq i32 %11, 7
  br i1 %cmp18, label %land.lhs.true20, label %if.else

land.lhs.true20:                                  ; preds = %lor.lhs.false
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %12, i32 noundef 8) #20
  br i1 %call, label %if.then22, label %if.else

if.then22:                                        ; preds = %land.lhs.true20, %land.lhs.true
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type23, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %13, %struct.bpf_reg_state* noundef %14, i32 noundef %16, i1 noundef zeroext false) #20
  %17 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg24 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg24, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv25 = zext i8 %bf.clear to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %17, i32 noundef %conv25, i1 noundef zeroext true) #20
  br label %if.end47

if.else:                                          ; preds = %land.lhs.true20, %lor.lhs.false
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type26, align 8
  %cmp27 = icmp eq i32 %20, 9
  br i1 %cmp27, label %land.lhs.true29, label %lor.lhs.false33

land.lhs.true29:                                  ; preds = %if.else
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  %22 = load i32, i32* %type30, align 8
  %cmp31 = icmp eq i32 %22, 8
  br i1 %cmp31, label %if.then40, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %land.lhs.true29, %if.else
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call34 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %23, i32 noundef 8) #20
  br i1 %call34, label %land.lhs.true36, label %if.else45

land.lhs.true36:                                  ; preds = %lor.lhs.false33
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type37 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 0
  %25 = load i32, i32* %type37, align 8
  %cmp38 = icmp eq i32 %25, 7
  br i1 %cmp38, label %if.then40, label %if.else45

if.then40:                                        ; preds = %land.lhs.true36, %land.lhs.true29
  %26 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 0
  %29 = load i32, i32* %type41, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %26, %struct.bpf_reg_state* noundef %27, i32 noundef %29, i1 noundef zeroext true) #20
  %30 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg42 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %31, i32 0, i32 1
  %bf.load43 = load i8, i8* %src_reg42, align 1
  %bf.lshr = lshr i8 %bf.load43, 4
  %conv44 = zext i8 %bf.lshr to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %30, i32 noundef %conv44, i1 noundef zeroext false) #20
  br label %if.end46

if.else45:                                        ; preds = %land.lhs.true36, %lor.lhs.false33
  store i1 false, i1* %retval, align 1
  br label %return

if.end46:                                         ; preds = %if.then40
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.then22
  br label %sw.epilog

sw.bb48:                                          ; preds = %if.end8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 0
  %33 = load i32, i32* %type49, align 8
  %cmp50 = icmp eq i32 %33, 8
  br i1 %cmp50, label %land.lhs.true52, label %lor.lhs.false56

land.lhs.true52:                                  ; preds = %sw.bb48
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 0
  %35 = load i32, i32* %type53, align 8
  %cmp54 = icmp eq i32 %35, 9
  br i1 %cmp54, label %if.then63, label %lor.lhs.false56

lor.lhs.false56:                                  ; preds = %land.lhs.true52, %sw.bb48
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type57 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 0
  %37 = load i32, i32* %type57, align 8
  %cmp58 = icmp eq i32 %37, 7
  br i1 %cmp58, label %land.lhs.true60, label %if.else69

land.lhs.true60:                                  ; preds = %lor.lhs.false56
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call61 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %38, i32 noundef 8) #20
  br i1 %call61, label %if.then63, label %if.else69

if.then63:                                        ; preds = %land.lhs.true60, %land.lhs.true52
  %39 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type64 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type64, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %39, %struct.bpf_reg_state* noundef %40, i32 noundef %42, i1 noundef zeroext true) #20
  %43 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg65 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 1
  %bf.load66 = load i8, i8* %dst_reg65, align 1
  %bf.clear67 = and i8 %bf.load66, 15
  %conv68 = zext i8 %bf.clear67 to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %43, i32 noundef %conv68, i1 noundef zeroext false) #20
  br label %if.end92

if.else69:                                        ; preds = %land.lhs.true60, %lor.lhs.false56
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 0
  %46 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %46, 9
  br i1 %cmp71, label %land.lhs.true73, label %lor.lhs.false77

land.lhs.true73:                                  ; preds = %if.else69
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 0
  %48 = load i32, i32* %type74, align 8
  %cmp75 = icmp eq i32 %48, 8
  br i1 %cmp75, label %if.then84, label %lor.lhs.false77

lor.lhs.false77:                                  ; preds = %land.lhs.true73, %if.else69
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call78 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %49, i32 noundef 8) #20
  br i1 %call78, label %land.lhs.true80, label %if.else90

land.lhs.true80:                                  ; preds = %lor.lhs.false77
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 0
  %51 = load i32, i32* %type81, align 8
  %cmp82 = icmp eq i32 %51, 7
  br i1 %cmp82, label %if.then84, label %if.else90

if.then84:                                        ; preds = %land.lhs.true80, %land.lhs.true73
  %52 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 0
  %55 = load i32, i32* %type85, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %52, %struct.bpf_reg_state* noundef %53, i32 noundef %55, i1 noundef zeroext false) #20
  %56 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %57 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg86 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %57, i32 0, i32 1
  %bf.load87 = load i8, i8* %src_reg86, align 1
  %bf.lshr88 = lshr i8 %bf.load87, 4
  %conv89 = zext i8 %bf.lshr88 to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %56, i32 noundef %conv89, i1 noundef zeroext true) #20
  br label %if.end91

if.else90:                                        ; preds = %land.lhs.true80, %lor.lhs.false77
  store i1 false, i1* %retval, align 1
  br label %return

if.end91:                                         ; preds = %if.then84
  br label %if.end92

if.end92:                                         ; preds = %if.end91, %if.then63
  br label %sw.epilog

sw.bb93:                                          ; preds = %if.end8
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type94 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %58, i32 0, i32 0
  %59 = load i32, i32* %type94, align 8
  %cmp95 = icmp eq i32 %59, 8
  br i1 %cmp95, label %land.lhs.true97, label %lor.lhs.false101

land.lhs.true97:                                  ; preds = %sw.bb93
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type98 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i32 0, i32 0
  %61 = load i32, i32* %type98, align 8
  %cmp99 = icmp eq i32 %61, 9
  br i1 %cmp99, label %if.then108, label %lor.lhs.false101

lor.lhs.false101:                                 ; preds = %land.lhs.true97, %sw.bb93
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type102 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 0
  %63 = load i32, i32* %type102, align 8
  %cmp103 = icmp eq i32 %63, 7
  br i1 %cmp103, label %land.lhs.true105, label %if.else114

land.lhs.true105:                                 ; preds = %lor.lhs.false101
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call106 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %64, i32 noundef 8) #20
  br i1 %call106, label %if.then108, label %if.else114

if.then108:                                       ; preds = %land.lhs.true105, %land.lhs.true97
  %65 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i32 0, i32 0
  %68 = load i32, i32* %type109, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %65, %struct.bpf_reg_state* noundef %66, i32 noundef %68, i1 noundef zeroext true) #20
  %69 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %70 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg110 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %70, i32 0, i32 1
  %bf.load111 = load i8, i8* %dst_reg110, align 1
  %bf.clear112 = and i8 %bf.load111, 15
  %conv113 = zext i8 %bf.clear112 to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %69, i32 noundef %conv113, i1 noundef zeroext false) #20
  br label %if.end137

if.else114:                                       ; preds = %land.lhs.true105, %lor.lhs.false101
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type115 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 0
  %72 = load i32, i32* %type115, align 8
  %cmp116 = icmp eq i32 %72, 9
  br i1 %cmp116, label %land.lhs.true118, label %lor.lhs.false122

land.lhs.true118:                                 ; preds = %if.else114
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type119 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %73, i32 0, i32 0
  %74 = load i32, i32* %type119, align 8
  %cmp120 = icmp eq i32 %74, 8
  br i1 %cmp120, label %if.then129, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118, %if.else114
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call123 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %75, i32 noundef 8) #20
  br i1 %call123, label %land.lhs.true125, label %if.else135

land.lhs.true125:                                 ; preds = %lor.lhs.false122
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type126 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %76, i32 0, i32 0
  %77 = load i32, i32* %type126, align 8
  %cmp127 = icmp eq i32 %77, 7
  br i1 %cmp127, label %if.then129, label %if.else135

if.then129:                                       ; preds = %land.lhs.true125, %land.lhs.true118
  %78 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type130 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 0
  %81 = load i32, i32* %type130, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %78, %struct.bpf_reg_state* noundef %79, i32 noundef %81, i1 noundef zeroext false) #20
  %82 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %83 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg131 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %83, i32 0, i32 1
  %bf.load132 = load i8, i8* %src_reg131, align 1
  %bf.lshr133 = lshr i8 %bf.load132, 4
  %conv134 = zext i8 %bf.lshr133 to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %82, i32 noundef %conv134, i1 noundef zeroext true) #20
  br label %if.end136

if.else135:                                       ; preds = %land.lhs.true125, %lor.lhs.false122
  store i1 false, i1* %retval, align 1
  br label %return

if.end136:                                        ; preds = %if.then129
  br label %if.end137

if.end137:                                        ; preds = %if.end136, %if.then108
  br label %sw.epilog

sw.bb138:                                         ; preds = %if.end8
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type139 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %84, i32 0, i32 0
  %85 = load i32, i32* %type139, align 8
  %cmp140 = icmp eq i32 %85, 8
  br i1 %cmp140, label %land.lhs.true142, label %lor.lhs.false146

land.lhs.true142:                                 ; preds = %sw.bb138
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type143 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 0
  %87 = load i32, i32* %type143, align 8
  %cmp144 = icmp eq i32 %87, 9
  br i1 %cmp144, label %if.then153, label %lor.lhs.false146

lor.lhs.false146:                                 ; preds = %land.lhs.true142, %sw.bb138
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type147 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 0
  %89 = load i32, i32* %type147, align 8
  %cmp148 = icmp eq i32 %89, 7
  br i1 %cmp148, label %land.lhs.true150, label %if.else159

land.lhs.true150:                                 ; preds = %lor.lhs.false146
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call151 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %90, i32 noundef 8) #20
  br i1 %call151, label %if.then153, label %if.else159

if.then153:                                       ; preds = %land.lhs.true150, %land.lhs.true142
  %91 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type154 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %93, i32 0, i32 0
  %94 = load i32, i32* %type154, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %91, %struct.bpf_reg_state* noundef %92, i32 noundef %94, i1 noundef zeroext false) #20
  %95 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %96 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg155 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %96, i32 0, i32 1
  %bf.load156 = load i8, i8* %dst_reg155, align 1
  %bf.clear157 = and i8 %bf.load156, 15
  %conv158 = zext i8 %bf.clear157 to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %95, i32 noundef %conv158, i1 noundef zeroext true) #20
  br label %if.end182

if.else159:                                       ; preds = %land.lhs.true150, %lor.lhs.false146
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type160 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 0
  %98 = load i32, i32* %type160, align 8
  %cmp161 = icmp eq i32 %98, 9
  br i1 %cmp161, label %land.lhs.true163, label %lor.lhs.false167

land.lhs.true163:                                 ; preds = %if.else159
  %99 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type164 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %99, i32 0, i32 0
  %100 = load i32, i32* %type164, align 8
  %cmp165 = icmp eq i32 %100, 8
  br i1 %cmp165, label %if.then174, label %lor.lhs.false167

lor.lhs.false167:                                 ; preds = %land.lhs.true163, %if.else159
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call168 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %101, i32 noundef 8) #20
  br i1 %call168, label %land.lhs.true170, label %if.else180

land.lhs.true170:                                 ; preds = %lor.lhs.false167
  %102 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type171 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %102, i32 0, i32 0
  %103 = load i32, i32* %type171, align 8
  %cmp172 = icmp eq i32 %103, 7
  br i1 %cmp172, label %if.then174, label %if.else180

if.then174:                                       ; preds = %land.lhs.true170, %land.lhs.true163
  %104 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %106 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type175 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %106, i32 0, i32 0
  %107 = load i32, i32* %type175, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %104, %struct.bpf_reg_state* noundef %105, i32 noundef %107, i1 noundef zeroext true) #20
  %108 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %109 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg176 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %109, i32 0, i32 1
  %bf.load177 = load i8, i8* %src_reg176, align 1
  %bf.lshr178 = lshr i8 %bf.load177, 4
  %conv179 = zext i8 %bf.lshr178 to i32
  call void @mark_pkt_end(%struct.bpf_verifier_state* noundef %108, i32 noundef %conv179, i1 noundef zeroext false) #20
  br label %if.end181

if.else180:                                       ; preds = %land.lhs.true170, %lor.lhs.false167
  store i1 false, i1* %retval, align 1
  br label %return

if.end181:                                        ; preds = %if.then174
  br label %if.end182

if.end182:                                        ; preds = %if.end181, %if.then153
  br label %sw.epilog

sw.default:                                       ; preds = %if.end8
  store i1 false, i1* %retval, align 1
  br label %return

sw.epilog:                                        ; preds = %if.end182, %if.end137, %if.end92, %if.end47
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %if.else180, %if.else135, %if.else90, %if.else45, %if.then7, %if.then
  %110 = load i1, i1* %retval, align 1
  ret i1 %110
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_ptr_or_null_reg(%struct.bpf_func_state* noundef %state, %struct.bpf_reg_state* noundef %reg, i32 noundef %id, i1 noundef zeroext %is_null) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %id.addr = alloca i32, align 4
  %is_null.addr = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_warn_on26 = alloca i32, align 4
  %__flags45 = alloca i32, align 4
  %tmp54 = alloca i64, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %id, i32* %id.addr, align 4
  %frombool = zext i1 %is_null to i8
  store i8 %frombool, i8* %is_null.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %call = call zeroext i1 @type_may_be_null(i32 noundef %1) #20
  br i1 %call, label %land.lhs.true, label %if.end73

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 3
  %3 = load i32, i32* %id1, align 8
  %4 = load i32, i32* %id.addr, align 4
  %cmp = icmp eq i32 %3, %4
  br i1 %cmp, label %land.lhs.true2, label %if.end73

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 3
  %6 = load i32, i32* %id3, align 8
  %tobool = icmp ne i32 %6, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool6 = icmp ne i32 %7, 0
  %lnot7 = xor i1 %tobool6, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext10 to i64
  %tobool11 = icmp ne i64 %conv, 0
  br i1 %tobool11, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true2
  br label %do.body

do.body:                                          ; preds = %if.then
  store i32 2307, i32* %__flags, align 4
  br label %do.body12

do.body12:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body12
  br label %do.body13

do.body13:                                        ; preds = %do.end
  %8 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 10260, i32 %8, i64 12) #19, !srcloc !167
  br label %do.end14

do.end14:                                         ; preds = %do.body13
  br label %do.body15

do.body15:                                        ; preds = %do.end14
  br label %do.end16

do.end16:                                         ; preds = %do.body15
  br label %do.end17

do.end17:                                         ; preds = %do.end16
  br label %if.end

if.end:                                           ; preds = %do.end17, %land.lhs.true2
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool18 = icmp ne i32 %9, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  store i64 %conv23, i64* %tmp, align 8
  %10 = load i64, i64* %tmp, align 8
  %tobool24 = icmp ne i64 %10, 0
  br i1 %tobool24, label %if.end73, label %if.then25

if.then25:                                        ; preds = %if.end
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 6
  %12 = load i64, i64* %smin_value, align 8
  %tobool27 = icmp ne i64 %12, 0
  br i1 %tobool27, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then25
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 7
  %14 = load i64, i64* %smax_value, align 8
  %tobool28 = icmp ne i64 %14, 0
  br i1 %tobool28, label %lor.end, label %lor.lhs.false29

lor.lhs.false29:                                  ; preds = %lor.lhs.false
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %16 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call30 = call zeroext i1 @tnum_equals_const(i64 %18, i64 %20, i64 noundef 0) #20
  br i1 %call30, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %lor.lhs.false29
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 1
  %22 = load i32, i32* %off, align 4
  %tobool31 = icmp ne i32 %22, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false29, %lor.lhs.false, %if.then25
  %23 = phi i1 [ true, %lor.lhs.false29 ], [ true, %lor.lhs.false ], [ true, %if.then25 ], [ %tobool31, %lor.rhs ]
  %lnot32 = xor i1 %23, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  store i32 %lnot.ext35, i32* %__ret_warn_on26, align 4
  %24 = load i32, i32* %__ret_warn_on26, align 4
  %tobool36 = icmp ne i32 %24, 0
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  %tobool42 = icmp ne i64 %conv41, 0
  br i1 %tobool42, label %if.then43, label %if.end53

if.then43:                                        ; preds = %lor.end
  br label %do.body44

do.body44:                                        ; preds = %if.then43
  store i32 2307, i32* %__flags45, align 4
  br label %do.body46

do.body46:                                        ; preds = %do.body44
  br label %do.end47

do.end47:                                         ; preds = %do.body46
  br label %do.body48

do.body48:                                        ; preds = %do.end47
  %25 = load i32, i32* %__flags45, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 10263, i32 %25, i64 12) #19, !srcloc !168
  br label %do.end49

do.end49:                                         ; preds = %do.body48
  br label %do.body50

do.body50:                                        ; preds = %do.end49
  br label %do.end51

do.end51:                                         ; preds = %do.body50
  br label %do.end52

do.end52:                                         ; preds = %do.end51
  br label %if.end53

if.end53:                                         ; preds = %do.end52, %lor.end
  %26 = load i32, i32* %__ret_warn_on26, align 4
  %tobool55 = icmp ne i32 %26, 0
  %lnot56 = xor i1 %tobool55, true
  %lnot58 = xor i1 %lnot56, true
  %lnot.ext59 = zext i1 %lnot58 to i32
  %conv60 = sext i32 %lnot.ext59 to i64
  store i64 %conv60, i64* %tmp54, align 8
  %27 = load i64, i64* %tmp54, align 8
  %tobool61 = icmp ne i64 %27, 0
  br i1 %tobool61, label %if.then62, label %if.end63

if.then62:                                        ; preds = %if.end53
  br label %if.end73

if.end63:                                         ; preds = %if.end53
  %28 = load i8, i8* %is_null.addr, align 1
  %tobool64 = trunc i8 %28 to i1
  br i1 %tobool64, label %if.then65, label %if.end68

if.then65:                                        ; preds = %if.end63
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 0
  store i32 1, i32* %type66, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 3
  store i32 0, i32* %id67, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 4
  store i32 0, i32* %ref_obj_id, align 4
  br label %if.end73

if.end68:                                         ; preds = %if.end63
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @mark_ptr_not_null_reg(%struct.bpf_reg_state* noundef %32) #20
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call69 = call zeroext i1 @reg_may_point_to_spin_lock(%struct.bpf_reg_state* noundef %33) #20
  br i1 %call69, label %if.end72, label %if.then70

if.then70:                                        ; preds = %if.end68
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 3
  store i32 0, i32* %id71, align 8
  br label %if.end72

if.end72:                                         ; preds = %if.then70, %if.end68
  br label %if.end73

if.end73:                                         ; preds = %if.then62, %if.then65, %if.end72, %if.end, %land.lhs.true, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_may_point_to_spin_lock(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 4
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 2
  %4 = bitcast %union.anon.168* %3 to %struct.anon.169*
  %map_ptr = getelementptr inbounds %struct.anon.169, %struct.anon.169* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %call = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %5) #20
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %reg, i32 noundef %which) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %which.addr = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %which, i32* %which.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %2 = load i32, i32* %which.addr, align 4
  %cmp = icmp eq i32 %1, %2
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 3
  %4 = load i32, i32* %id, align 8
  %cmp1 = icmp eq i32 %4, 0
  br i1 %cmp1, label %land.lhs.true2, label %land.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 1
  %6 = load i32, i32* %off, align 4
  %cmp3 = icmp eq i32 %6, 0
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true2
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_equals_const(i64 %10, i64 %12, i64 noundef 0) #20
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true2, %land.lhs.true, %entry
  %13 = phi i1 [ false, %land.lhs.true2 ], [ false, %land.lhs.true ], [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %13
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %vstate, %struct.bpf_reg_state* noundef %dst_reg, i32 noundef %type, i1 noundef zeroext %range_right_open) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %type.addr = alloca i32, align 4
  %range_right_open.addr = alloca i8, align 1
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %new_range = alloca i32, align 4
  %___vstate = alloca %struct.bpf_verifier_state*, align 8
  %___i = alloca i32, align 4
  %___j = alloca i32, align 4
  %___regs = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x574 = alloca i32, align 4
  %__UNIQUE_ID___y575 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__UNIQUE_ID___x57470 = alloca i32, align 4
  %__UNIQUE_ID___y57572 = alloca i32, align 4
  %tmp73 = alloca i32, align 4
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %frombool = zext i1 %range_right_open to i8
  store i8 %frombool, i8* %range_right_open.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 1
  %1 = load i32, i32* %off, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 1
  %3 = load i32, i32* %off1, align 4
  %cmp2 = icmp eq i32 %3, 0
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %4 = load i8, i8* %range_right_open.addr, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %entry
  br label %for.end108

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 9
  %6 = load i64, i64* %umax_value, align 8
  %cmp3 = icmp ugt i64 %6, 65535
  br i1 %cmp3, label %if.then9, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 9
  %8 = load i64, i64* %umax_value5, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 1
  %10 = load i32, i32* %off6, align 4
  %conv = sext i32 %10 to i64
  %add = add i64 %8, %conv
  %cmp7 = icmp ugt i64 %add, 65535
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %lor.lhs.false4, %if.end
  br label %for.end108

if.end10:                                         ; preds = %lor.lhs.false4
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 1
  %12 = load i32, i32* %off11, align 4
  store i32 %12, i32* %new_range, align 4
  %13 = load i8, i8* %range_right_open.addr, align 1
  %tobool12 = trunc i8 %13 to i1
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %14 = load i32, i32* %new_range, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %new_range, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end10
  %15 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_verifier_state* %15, %struct.bpf_verifier_state** %___vstate, align 8
  store i32 0, i32* %___i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc106, %if.end14
  %16 = load i32, i32* %___i, align 4
  %17 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %___vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %17, i32 0, i32 4
  %18 = load i32, i32* %curframe, align 8
  %cmp15 = icmp ule i32 %16, %18
  br i1 %cmp15, label %for.body, label %for.end108

for.body:                                         ; preds = %for.cond
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %___vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 0
  %20 = load i32, i32* %___i, align 4
  %idxprom = sext i32 %20 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %21, %struct.bpf_func_state** %state, align 8
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %___regs, align 8
  store i32 0, i32* %___j, align 4
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc, %for.body
  %23 = load i32, i32* %___j, align 4
  %cmp18 = icmp slt i32 %23, 11
  br i1 %cmp18, label %for.body20, label %for.end

for.body20:                                       ; preds = %for.cond17
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %___regs, align 8
  %25 = load i32, i32* %___j, align 4
  %idxprom21 = sext i32 %25 to i64
  %arrayidx22 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i64 %idxprom21
  store %struct.bpf_reg_state* %arrayidx22, %struct.bpf_reg_state** %reg, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 0
  %27 = load i32, i32* %type23, align 8
  %28 = load i32, i32* %type.addr, align 4
  %cmp24 = icmp eq i32 %27, %28
  br i1 %cmp24, label %land.lhs.true26, label %if.end34

land.lhs.true26:                                  ; preds = %for.body20
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 3
  %30 = load i32, i32* %id, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %id27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 3
  %32 = load i32, i32* %id27, align 8
  %cmp28 = icmp eq i32 %30, %32
  br i1 %cmp28, label %if.then30, label %if.end34

if.then30:                                        ; preds = %land.lhs.true26
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 2
  %range = bitcast %union.anon.168* %34 to i32*
  %35 = load i32, i32* %range, align 8
  store i32 %35, i32* %__UNIQUE_ID___x574, align 4
  %36 = load i32, i32* %new_range, align 4
  store i32 %36, i32* %__UNIQUE_ID___y575, align 4
  %37 = load i32, i32* %__UNIQUE_ID___x574, align 4
  %38 = load i32, i32* %__UNIQUE_ID___y575, align 4
  %cmp31 = icmp sgt i32 %37, %38
  br i1 %cmp31, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then30
  %39 = load i32, i32* %__UNIQUE_ID___x574, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then30
  %40 = load i32, i32* %__UNIQUE_ID___y575, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %39, %cond.true ], [ %40, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %41 = load i32, i32* %tmp, align 4
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 2
  %range33 = bitcast %union.anon.168* %43 to i32*
  store i32 %41, i32* %range33, align 8
  br label %if.end34

if.end34:                                         ; preds = %cond.end, %land.lhs.true26, %for.body20
  br label %for.inc

for.inc:                                          ; preds = %if.end34
  %44 = load i32, i32* %___j, align 4
  %inc35 = add i32 %44, 1
  store i32 %inc35, i32* %___j, align 4
  br label %for.cond17, !llvm.loop !169

for.end:                                          ; preds = %for.cond17
  store i32 0, i32* %___j, align 4
  %45 = load i32, i32* %___j, align 4
  %46 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %46, i32 0, i32 10
  %47 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %47, 8
  %cmp36 = icmp slt i32 %45, %div
  br i1 %cmp36, label %land.lhs.true38, label %cond.false49

land.lhs.true38:                                  ; preds = %for.end
  %48 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %48, i32 0, i32 11
  %49 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %50 = load i32, i32* %___j, align 4
  %idxprom39 = sext i32 %50 to i64
  %arrayidx40 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %49, i64 %idxprom39
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx40, i32 0, i32 1
  %arrayidx41 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %51 = load i8, i8* %arrayidx41, align 8
  %conv42 = zext i8 %51 to i32
  %cmp43 = icmp eq i32 %conv42, 1
  br i1 %cmp43, label %cond.true45, label %cond.false49

cond.true45:                                      ; preds = %land.lhs.true38
  %52 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack46 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %52, i32 0, i32 11
  %53 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack46, align 8
  %54 = load i32, i32* %___j, align 4
  %idxprom47 = sext i32 %54 to i64
  %arrayidx48 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %53, i64 %idxprom47
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx48, i32 0, i32 0
  br label %cond.end50

cond.false49:                                     ; preds = %land.lhs.true38, %for.end
  br label %cond.end50

cond.end50:                                       ; preds = %cond.false49, %cond.true45
  %cond51 = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true45 ], [ null, %cond.false49 ]
  store %struct.bpf_reg_state* %cond51, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond52

for.cond52:                                       ; preds = %cond.end103, %cond.end50
  %55 = load i32, i32* %___j, align 4
  %56 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack53 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %56, i32 0, i32 10
  %57 = load i32, i32* %allocated_stack53, align 8
  %div54 = sdiv i32 %57, 8
  %cmp55 = icmp slt i32 %55, %div54
  br i1 %cmp55, label %for.body57, label %for.end105

for.body57:                                       ; preds = %for.cond52
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool58 = icmp ne %struct.bpf_reg_state* %58, null
  br i1 %tobool58, label %if.end60, label %if.then59

if.then59:                                        ; preds = %for.body57
  br label %for.inc82

if.end60:                                         ; preds = %for.body57
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type61 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 0
  %60 = load i32, i32* %type61, align 8
  %61 = load i32, i32* %type.addr, align 4
  %cmp62 = icmp eq i32 %60, %61
  br i1 %cmp62, label %land.lhs.true64, label %if.end81

land.lhs.true64:                                  ; preds = %if.end60
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 3
  %63 = load i32, i32* %id65, align 8
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %id66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %64, i32 0, i32 3
  %65 = load i32, i32* %id66, align 8
  %cmp67 = icmp eq i32 %63, %65
  br i1 %cmp67, label %if.then69, label %if.end81

if.then69:                                        ; preds = %land.lhs.true64
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 2
  %range71 = bitcast %union.anon.168* %67 to i32*
  %68 = load i32, i32* %range71, align 8
  store i32 %68, i32* %__UNIQUE_ID___x57470, align 4
  %69 = load i32, i32* %new_range, align 4
  store i32 %69, i32* %__UNIQUE_ID___y57572, align 4
  %70 = load i32, i32* %__UNIQUE_ID___x57470, align 4
  %71 = load i32, i32* %__UNIQUE_ID___y57572, align 4
  %cmp74 = icmp sgt i32 %70, %71
  br i1 %cmp74, label %cond.true76, label %cond.false77

cond.true76:                                      ; preds = %if.then69
  %72 = load i32, i32* %__UNIQUE_ID___x57470, align 4
  br label %cond.end78

cond.false77:                                     ; preds = %if.then69
  %73 = load i32, i32* %__UNIQUE_ID___y57572, align 4
  br label %cond.end78

cond.end78:                                       ; preds = %cond.false77, %cond.true76
  %cond79 = phi i32 [ %72, %cond.true76 ], [ %73, %cond.false77 ]
  store i32 %cond79, i32* %tmp73, align 4
  %74 = load i32, i32* %tmp73, align 4
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %76 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %75, i32 0, i32 2
  %range80 = bitcast %union.anon.168* %76 to i32*
  store i32 %74, i32* %range80, align 8
  br label %if.end81

if.end81:                                         ; preds = %cond.end78, %land.lhs.true64, %if.end60
  br label %for.inc82

for.inc82:                                        ; preds = %if.end81, %if.then59
  %77 = load i32, i32* %___j, align 4
  %inc83 = add i32 %77, 1
  store i32 %inc83, i32* %___j, align 4
  %78 = load i32, i32* %___j, align 4
  %79 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack84 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %79, i32 0, i32 10
  %80 = load i32, i32* %allocated_stack84, align 8
  %div85 = sdiv i32 %80, 8
  %cmp86 = icmp slt i32 %78, %div85
  br i1 %cmp86, label %land.lhs.true88, label %cond.false102

land.lhs.true88:                                  ; preds = %for.inc82
  %81 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack89 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %81, i32 0, i32 11
  %82 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack89, align 8
  %83 = load i32, i32* %___j, align 4
  %idxprom90 = sext i32 %83 to i64
  %arrayidx91 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %82, i64 %idxprom90
  %slot_type92 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx91, i32 0, i32 1
  %arrayidx93 = getelementptr [8 x i8], [8 x i8]* %slot_type92, i64 0, i64 0
  %84 = load i8, i8* %arrayidx93, align 8
  %conv94 = zext i8 %84 to i32
  %cmp95 = icmp eq i32 %conv94, 1
  br i1 %cmp95, label %cond.true97, label %cond.false102

cond.true97:                                      ; preds = %land.lhs.true88
  %85 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack98 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %85, i32 0, i32 11
  %86 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack98, align 8
  %87 = load i32, i32* %___j, align 4
  %idxprom99 = sext i32 %87 to i64
  %arrayidx100 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %86, i64 %idxprom99
  %spilled_ptr101 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx100, i32 0, i32 0
  br label %cond.end103

cond.false102:                                    ; preds = %land.lhs.true88, %for.inc82
  br label %cond.end103

cond.end103:                                      ; preds = %cond.false102, %cond.true97
  %cond104 = phi %struct.bpf_reg_state* [ %spilled_ptr101, %cond.true97 ], [ null, %cond.false102 ]
  store %struct.bpf_reg_state* %cond104, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond52, !llvm.loop !170

for.end105:                                       ; preds = %for.cond52
  br label %for.inc106

for.inc106:                                       ; preds = %for.end105
  %88 = load i32, i32* %___i, align 4
  %inc107 = add i32 %88, 1
  store i32 %inc107, i32* %___i, align 4
  br label %for.cond, !llvm.loop !171

for.end108:                                       ; preds = %if.then, %if.then9, %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_pkt_end(%struct.bpf_verifier_state* noundef %vstate, i32 noundef %regn, i1 noundef zeroext %range_open) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %regn.addr = alloca i32, align 4
  %range_open.addr = alloca i8, align 1
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store i32 %regn, i32* %regn.addr, align 4
  %frombool = zext i1 %range_open to i8
  store i8 %frombool, i8* %range_open.addr, align 1
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %3, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %5 = load i32, i32* %regn.addr, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom1
  store %struct.bpf_reg_state* %arrayidx2, %struct.bpf_reg_state** %reg, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp = icmp ne i32 %7, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end5

if.end:                                           ; preds = %entry
  %8 = load i8, i8* %range_open.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 2
  %range = bitcast %union.anon.168* %10 to i32*
  store i32 -2, i32* %range, align 8
  br label %if.end5

if.else:                                          ; preds = %if.end
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 2
  %range4 = bitcast %union.anon.168* %12 to i32*
  store i32 -1, i32* %range4, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then, %if.else, %if.then3
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_access_skb(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 1, label %sw.bb
    i32 3, label %sw.bb
    i32 4, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @might_fault() #0 {
entry:
  ret void
}

; Function Attrs: nounwind readonly
declare i64 @llvm.read_register.i64(metadata) #18

; Function Attrs: nounwind
declare void @llvm.write_register.i64(metadata, i64) #19

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @kmsan_copy_to_user(i8* noundef %to, i8* noundef %from, i64 noundef %to_copy, i64 noundef %left) #0 {
entry:
  %to.addr = alloca i8*, align 8
  %from.addr = alloca i8*, align 8
  %to_copy.addr = alloca i64, align 8
  %left.addr = alloca i64, align 8
  store i8* %to, i8** %to.addr, align 8
  store i8* %from, i8** %from.addr, align 8
  store i64 %to_copy, i64* %to_copy.addr, align 8
  store i64 %left, i64* %left.addr, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_bpf_loop_call(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 133
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv2 = zext i8 %bf.lshr to i32
  %cmp3 = icmp eq i32 %conv2, 0
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %3, i32 0, i32 3
  %4 = load i32, i32* %imm, align 4
  %cmp5 = icmp eq i32 %4, 181
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %5 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp5, %land.rhs ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_prog* @inline_bpf_loop(%struct.bpf_verifier_env* noundef %env, i32 noundef %position, i32 noundef %stack_base, i32 noundef %callback_subprogno, i32* noundef %cnt) #0 {
entry:
  %retval = alloca %struct.bpf_prog*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %position.addr = alloca i32, align 4
  %stack_base.addr = alloca i32, align 4
  %callback_subprogno.addr = alloca i32, align 4
  %cnt.addr = alloca i32*, align 8
  %r6_offset = alloca i32, align 4
  %r7_offset = alloca i32, align 4
  %r8_offset = alloca i32, align 4
  %reg_loop_max = alloca i32, align 4
  %reg_loop_cnt = alloca i32, align 4
  %reg_loop_ctx = alloca i32, align 4
  %new_prog = alloca %struct.bpf_prog*, align 8
  %callback_start = alloca i32, align 4
  %call_insn_offset = alloca i32, align 4
  %callback_offset = alloca i32, align 4
  %insn_buf = alloca [19 x %struct.bpf_insn], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %position, i32* %position.addr, align 4
  store i32 %stack_base, i32* %stack_base.addr, align 4
  store i32 %callback_subprogno, i32* %callback_subprogno.addr, align 4
  store i32* %cnt, i32** %cnt.addr, align 8
  %0 = load i32, i32* %stack_base.addr, align 4
  %add = add i32 %0, 0
  store i32 %add, i32* %r6_offset, align 4
  %1 = load i32, i32* %stack_base.addr, align 4
  %add1 = add i32 %1, 8
  store i32 %add1, i32* %r7_offset, align 4
  %2 = load i32, i32* %stack_base.addr, align 4
  %add2 = add i32 %2, 16
  store i32 %add2, i32* %r8_offset, align 4
  store i32 6, i32* %reg_loop_max, align 4
  store i32 7, i32* %reg_loop_cnt, align 4
  store i32 8, i32* %reg_loop_ctx, align 4
  %arrayinit.begin = getelementptr inbounds [19 x %struct.bpf_insn], [19 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 0
  store i8 -75, i8* %code, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 0
  store i8 %bf.set5, i8* %src_reg, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 2
  store i16 2, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 3
  store i32 8388608, i32* %imm, align 4
  %arrayinit.element = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i64 1
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 0
  store i8 -76, i8* %code6, align 8
  %dst_reg7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %bf.load8 = load i8, i8* %dst_reg7, align 1
  %bf.clear9 = and i8 %bf.load8, -16
  %bf.set10 = or i8 %bf.clear9, 0
  store i8 %bf.set10, i8* %dst_reg7, align 1
  %src_reg11 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %bf.load12 = load i8, i8* %src_reg11, align 1
  %bf.clear13 = and i8 %bf.load12, 15
  %bf.set14 = or i8 %bf.clear13, 0
  store i8 %bf.set14, i8* %src_reg11, align 1
  %off15 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 2
  store i16 0, i16* %off15, align 2
  %imm16 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 3
  store i32 -7, i32* %imm16, align 4
  %arrayinit.element17 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i64 1
  %code18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element17, i32 0, i32 0
  store i8 5, i8* %code18, align 8
  %dst_reg19 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element17, i32 0, i32 1
  %bf.load20 = load i8, i8* %dst_reg19, align 1
  %bf.clear21 = and i8 %bf.load20, -16
  %bf.set22 = or i8 %bf.clear21, 0
  store i8 %bf.set22, i8* %dst_reg19, align 1
  %src_reg23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element17, i32 0, i32 1
  %bf.load24 = load i8, i8* %src_reg23, align 1
  %bf.clear25 = and i8 %bf.load24, 15
  %bf.set26 = or i8 %bf.clear25, 0
  store i8 %bf.set26, i8* %src_reg23, align 1
  %off27 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element17, i32 0, i32 2
  store i16 16, i16* %off27, align 2
  %imm28 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element17, i32 0, i32 3
  store i32 0, i32* %imm28, align 4
  %arrayinit.element29 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element17, i64 1
  %code30 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element29, i32 0, i32 0
  store i8 123, i8* %code30, align 8
  %dst_reg31 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element29, i32 0, i32 1
  %bf.load32 = load i8, i8* %dst_reg31, align 1
  %bf.clear33 = and i8 %bf.load32, -16
  %bf.set34 = or i8 %bf.clear33, 10
  store i8 %bf.set34, i8* %dst_reg31, align 1
  %src_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element29, i32 0, i32 1
  %bf.load36 = load i8, i8* %src_reg35, align 1
  %bf.clear37 = and i8 %bf.load36, 15
  %bf.set38 = or i8 %bf.clear37, 96
  store i8 %bf.set38, i8* %src_reg35, align 1
  %off39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element29, i32 0, i32 2
  %3 = load i32, i32* %r6_offset, align 4
  %conv = trunc i32 %3 to i16
  store i16 %conv, i16* %off39, align 2
  %imm40 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element29, i32 0, i32 3
  store i32 0, i32* %imm40, align 4
  %arrayinit.element41 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element29, i64 1
  %code42 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element41, i32 0, i32 0
  store i8 123, i8* %code42, align 8
  %dst_reg43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element41, i32 0, i32 1
  %bf.load44 = load i8, i8* %dst_reg43, align 1
  %bf.clear45 = and i8 %bf.load44, -16
  %bf.set46 = or i8 %bf.clear45, 10
  store i8 %bf.set46, i8* %dst_reg43, align 1
  %src_reg47 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element41, i32 0, i32 1
  %bf.load48 = load i8, i8* %src_reg47, align 1
  %bf.clear49 = and i8 %bf.load48, 15
  %bf.set50 = or i8 %bf.clear49, 112
  store i8 %bf.set50, i8* %src_reg47, align 1
  %off51 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element41, i32 0, i32 2
  %4 = load i32, i32* %r7_offset, align 4
  %conv52 = trunc i32 %4 to i16
  store i16 %conv52, i16* %off51, align 2
  %imm53 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element41, i32 0, i32 3
  store i32 0, i32* %imm53, align 4
  %arrayinit.element54 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element41, i64 1
  %code55 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element54, i32 0, i32 0
  store i8 123, i8* %code55, align 8
  %dst_reg56 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element54, i32 0, i32 1
  %bf.load57 = load i8, i8* %dst_reg56, align 1
  %bf.clear58 = and i8 %bf.load57, -16
  %bf.set59 = or i8 %bf.clear58, 10
  store i8 %bf.set59, i8* %dst_reg56, align 1
  %src_reg60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element54, i32 0, i32 1
  %bf.load61 = load i8, i8* %src_reg60, align 1
  %bf.clear62 = and i8 %bf.load61, 15
  %bf.set63 = or i8 %bf.clear62, -128
  store i8 %bf.set63, i8* %src_reg60, align 1
  %off64 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element54, i32 0, i32 2
  %5 = load i32, i32* %r8_offset, align 4
  %conv65 = trunc i32 %5 to i16
  store i16 %conv65, i16* %off64, align 2
  %imm66 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element54, i32 0, i32 3
  store i32 0, i32* %imm66, align 4
  %arrayinit.element67 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element54, i64 1
  %code68 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element67, i32 0, i32 0
  store i8 -65, i8* %code68, align 8
  %dst_reg69 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element67, i32 0, i32 1
  %6 = load i32, i32* %reg_loop_max, align 4
  %conv70 = trunc i32 %6 to i8
  %bf.load71 = load i8, i8* %dst_reg69, align 1
  %bf.value = and i8 %conv70, 15
  %bf.clear72 = and i8 %bf.load71, -16
  %bf.set73 = or i8 %bf.clear72, %bf.value
  store i8 %bf.set73, i8* %dst_reg69, align 1
  %src_reg74 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element67, i32 0, i32 1
  %bf.load75 = load i8, i8* %src_reg74, align 1
  %bf.clear76 = and i8 %bf.load75, 15
  %bf.set77 = or i8 %bf.clear76, 16
  store i8 %bf.set77, i8* %src_reg74, align 1
  %off78 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element67, i32 0, i32 2
  store i16 0, i16* %off78, align 2
  %imm79 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element67, i32 0, i32 3
  store i32 0, i32* %imm79, align 4
  %arrayinit.element80 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element67, i64 1
  %code81 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element80, i32 0, i32 0
  store i8 -76, i8* %code81, align 8
  %dst_reg82 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element80, i32 0, i32 1
  %7 = load i32, i32* %reg_loop_cnt, align 4
  %conv83 = trunc i32 %7 to i8
  %bf.load84 = load i8, i8* %dst_reg82, align 1
  %bf.value85 = and i8 %conv83, 15
  %bf.clear86 = and i8 %bf.load84, -16
  %bf.set87 = or i8 %bf.clear86, %bf.value85
  store i8 %bf.set87, i8* %dst_reg82, align 1
  %src_reg88 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element80, i32 0, i32 1
  %bf.load89 = load i8, i8* %src_reg88, align 1
  %bf.clear90 = and i8 %bf.load89, 15
  %bf.set91 = or i8 %bf.clear90, 0
  store i8 %bf.set91, i8* %src_reg88, align 1
  %off92 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element80, i32 0, i32 2
  store i16 0, i16* %off92, align 2
  %imm93 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element80, i32 0, i32 3
  store i32 0, i32* %imm93, align 4
  %arrayinit.element94 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element80, i64 1
  %code95 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element94, i32 0, i32 0
  store i8 -65, i8* %code95, align 8
  %dst_reg96 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element94, i32 0, i32 1
  %8 = load i32, i32* %reg_loop_ctx, align 4
  %conv97 = trunc i32 %8 to i8
  %bf.load98 = load i8, i8* %dst_reg96, align 1
  %bf.value99 = and i8 %conv97, 15
  %bf.clear100 = and i8 %bf.load98, -16
  %bf.set101 = or i8 %bf.clear100, %bf.value99
  store i8 %bf.set101, i8* %dst_reg96, align 1
  %src_reg102 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element94, i32 0, i32 1
  %bf.load103 = load i8, i8* %src_reg102, align 1
  %bf.clear104 = and i8 %bf.load103, 15
  %bf.set105 = or i8 %bf.clear104, 48
  store i8 %bf.set105, i8* %src_reg102, align 1
  %off106 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element94, i32 0, i32 2
  store i16 0, i16* %off106, align 2
  %imm107 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element94, i32 0, i32 3
  store i32 0, i32* %imm107, align 4
  %arrayinit.element108 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element94, i64 1
  %code109 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element108, i32 0, i32 0
  store i8 61, i8* %code109, align 8
  %dst_reg110 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element108, i32 0, i32 1
  %9 = load i32, i32* %reg_loop_cnt, align 4
  %conv111 = trunc i32 %9 to i8
  %bf.load112 = load i8, i8* %dst_reg110, align 1
  %bf.value113 = and i8 %conv111, 15
  %bf.clear114 = and i8 %bf.load112, -16
  %bf.set115 = or i8 %bf.clear114, %bf.value113
  store i8 %bf.set115, i8* %dst_reg110, align 1
  %src_reg116 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element108, i32 0, i32 1
  %10 = load i32, i32* %reg_loop_max, align 4
  %conv117 = trunc i32 %10 to i8
  %bf.load118 = load i8, i8* %src_reg116, align 1
  %bf.value119 = and i8 %conv117, 15
  %bf.shl = shl i8 %bf.value119, 4
  %bf.clear120 = and i8 %bf.load118, 15
  %bf.set121 = or i8 %bf.clear120, %bf.shl
  store i8 %bf.set121, i8* %src_reg116, align 1
  %off122 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element108, i32 0, i32 2
  store i16 5, i16* %off122, align 2
  %imm123 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element108, i32 0, i32 3
  store i32 0, i32* %imm123, align 4
  %arrayinit.element124 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element108, i64 1
  %code125 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element124, i32 0, i32 0
  store i8 -65, i8* %code125, align 8
  %dst_reg126 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element124, i32 0, i32 1
  %bf.load127 = load i8, i8* %dst_reg126, align 1
  %bf.clear128 = and i8 %bf.load127, -16
  %bf.set129 = or i8 %bf.clear128, 1
  store i8 %bf.set129, i8* %dst_reg126, align 1
  %src_reg130 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element124, i32 0, i32 1
  %11 = load i32, i32* %reg_loop_cnt, align 4
  %conv131 = trunc i32 %11 to i8
  %bf.load132 = load i8, i8* %src_reg130, align 1
  %bf.value133 = and i8 %conv131, 15
  %bf.shl134 = shl i8 %bf.value133, 4
  %bf.clear135 = and i8 %bf.load132, 15
  %bf.set136 = or i8 %bf.clear135, %bf.shl134
  store i8 %bf.set136, i8* %src_reg130, align 1
  %off137 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element124, i32 0, i32 2
  store i16 0, i16* %off137, align 2
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element124, i32 0, i32 3
  store i32 0, i32* %imm138, align 4
  %arrayinit.element139 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element124, i64 1
  %code140 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element139, i32 0, i32 0
  store i8 -65, i8* %code140, align 8
  %dst_reg141 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element139, i32 0, i32 1
  %bf.load142 = load i8, i8* %dst_reg141, align 1
  %bf.clear143 = and i8 %bf.load142, -16
  %bf.set144 = or i8 %bf.clear143, 2
  store i8 %bf.set144, i8* %dst_reg141, align 1
  %src_reg145 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element139, i32 0, i32 1
  %12 = load i32, i32* %reg_loop_ctx, align 4
  %conv146 = trunc i32 %12 to i8
  %bf.load147 = load i8, i8* %src_reg145, align 1
  %bf.value148 = and i8 %conv146, 15
  %bf.shl149 = shl i8 %bf.value148, 4
  %bf.clear150 = and i8 %bf.load147, 15
  %bf.set151 = or i8 %bf.clear150, %bf.shl149
  store i8 %bf.set151, i8* %src_reg145, align 1
  %off152 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element139, i32 0, i32 2
  store i16 0, i16* %off152, align 2
  %imm153 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element139, i32 0, i32 3
  store i32 0, i32* %imm153, align 4
  %arrayinit.element154 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element139, i64 1
  %code155 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element154, i32 0, i32 0
  store i8 -123, i8* %code155, align 8
  %dst_reg156 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element154, i32 0, i32 1
  %bf.load157 = load i8, i8* %dst_reg156, align 1
  %bf.clear158 = and i8 %bf.load157, -16
  %bf.set159 = or i8 %bf.clear158, 0
  store i8 %bf.set159, i8* %dst_reg156, align 1
  %src_reg160 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element154, i32 0, i32 1
  %bf.load161 = load i8, i8* %src_reg160, align 1
  %bf.clear162 = and i8 %bf.load161, 15
  %bf.set163 = or i8 %bf.clear162, 16
  store i8 %bf.set163, i8* %src_reg160, align 1
  %off164 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element154, i32 0, i32 2
  store i16 0, i16* %off164, align 2
  %imm165 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element154, i32 0, i32 3
  store i32 0, i32* %imm165, align 4
  %arrayinit.element166 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element154, i64 1
  %code167 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element166, i32 0, i32 0
  store i8 7, i8* %code167, align 8
  %dst_reg168 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element166, i32 0, i32 1
  %13 = load i32, i32* %reg_loop_cnt, align 4
  %conv169 = trunc i32 %13 to i8
  %bf.load170 = load i8, i8* %dst_reg168, align 1
  %bf.value171 = and i8 %conv169, 15
  %bf.clear172 = and i8 %bf.load170, -16
  %bf.set173 = or i8 %bf.clear172, %bf.value171
  store i8 %bf.set173, i8* %dst_reg168, align 1
  %src_reg174 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element166, i32 0, i32 1
  %bf.load175 = load i8, i8* %src_reg174, align 1
  %bf.clear176 = and i8 %bf.load175, 15
  %bf.set177 = or i8 %bf.clear176, 0
  store i8 %bf.set177, i8* %src_reg174, align 1
  %off178 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element166, i32 0, i32 2
  store i16 0, i16* %off178, align 2
  %imm179 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element166, i32 0, i32 3
  store i32 1, i32* %imm179, align 4
  %arrayinit.element180 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element166, i64 1
  %code181 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element180, i32 0, i32 0
  store i8 21, i8* %code181, align 8
  %dst_reg182 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element180, i32 0, i32 1
  %bf.load183 = load i8, i8* %dst_reg182, align 1
  %bf.clear184 = and i8 %bf.load183, -16
  %bf.set185 = or i8 %bf.clear184, 0
  store i8 %bf.set185, i8* %dst_reg182, align 1
  %src_reg186 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element180, i32 0, i32 1
  %bf.load187 = load i8, i8* %src_reg186, align 1
  %bf.clear188 = and i8 %bf.load187, 15
  %bf.set189 = or i8 %bf.clear188, 0
  store i8 %bf.set189, i8* %src_reg186, align 1
  %off190 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element180, i32 0, i32 2
  store i16 -6, i16* %off190, align 2
  %imm191 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element180, i32 0, i32 3
  store i32 0, i32* %imm191, align 4
  %arrayinit.element192 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element180, i64 1
  %code193 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element192, i32 0, i32 0
  store i8 -65, i8* %code193, align 8
  %dst_reg194 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element192, i32 0, i32 1
  %bf.load195 = load i8, i8* %dst_reg194, align 1
  %bf.clear196 = and i8 %bf.load195, -16
  %bf.set197 = or i8 %bf.clear196, 0
  store i8 %bf.set197, i8* %dst_reg194, align 1
  %src_reg198 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element192, i32 0, i32 1
  %14 = load i32, i32* %reg_loop_cnt, align 4
  %conv199 = trunc i32 %14 to i8
  %bf.load200 = load i8, i8* %src_reg198, align 1
  %bf.value201 = and i8 %conv199, 15
  %bf.shl202 = shl i8 %bf.value201, 4
  %bf.clear203 = and i8 %bf.load200, 15
  %bf.set204 = or i8 %bf.clear203, %bf.shl202
  store i8 %bf.set204, i8* %src_reg198, align 1
  %off205 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element192, i32 0, i32 2
  store i16 0, i16* %off205, align 2
  %imm206 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element192, i32 0, i32 3
  store i32 0, i32* %imm206, align 4
  %arrayinit.element207 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element192, i64 1
  %code208 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element207, i32 0, i32 0
  store i8 121, i8* %code208, align 8
  %dst_reg209 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element207, i32 0, i32 1
  %bf.load210 = load i8, i8* %dst_reg209, align 1
  %bf.clear211 = and i8 %bf.load210, -16
  %bf.set212 = or i8 %bf.clear211, 6
  store i8 %bf.set212, i8* %dst_reg209, align 1
  %src_reg213 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element207, i32 0, i32 1
  %bf.load214 = load i8, i8* %src_reg213, align 1
  %bf.clear215 = and i8 %bf.load214, 15
  %bf.set216 = or i8 %bf.clear215, -96
  store i8 %bf.set216, i8* %src_reg213, align 1
  %off217 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element207, i32 0, i32 2
  %15 = load i32, i32* %r6_offset, align 4
  %conv218 = trunc i32 %15 to i16
  store i16 %conv218, i16* %off217, align 2
  %imm219 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element207, i32 0, i32 3
  store i32 0, i32* %imm219, align 4
  %arrayinit.element220 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element207, i64 1
  %code221 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element220, i32 0, i32 0
  store i8 121, i8* %code221, align 8
  %dst_reg222 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element220, i32 0, i32 1
  %bf.load223 = load i8, i8* %dst_reg222, align 1
  %bf.clear224 = and i8 %bf.load223, -16
  %bf.set225 = or i8 %bf.clear224, 7
  store i8 %bf.set225, i8* %dst_reg222, align 1
  %src_reg226 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element220, i32 0, i32 1
  %bf.load227 = load i8, i8* %src_reg226, align 1
  %bf.clear228 = and i8 %bf.load227, 15
  %bf.set229 = or i8 %bf.clear228, -96
  store i8 %bf.set229, i8* %src_reg226, align 1
  %off230 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element220, i32 0, i32 2
  %16 = load i32, i32* %r7_offset, align 4
  %conv231 = trunc i32 %16 to i16
  store i16 %conv231, i16* %off230, align 2
  %imm232 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element220, i32 0, i32 3
  store i32 0, i32* %imm232, align 4
  %arrayinit.element233 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element220, i64 1
  %code234 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element233, i32 0, i32 0
  store i8 121, i8* %code234, align 8
  %dst_reg235 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element233, i32 0, i32 1
  %bf.load236 = load i8, i8* %dst_reg235, align 1
  %bf.clear237 = and i8 %bf.load236, -16
  %bf.set238 = or i8 %bf.clear237, 8
  store i8 %bf.set238, i8* %dst_reg235, align 1
  %src_reg239 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element233, i32 0, i32 1
  %bf.load240 = load i8, i8* %src_reg239, align 1
  %bf.clear241 = and i8 %bf.load240, 15
  %bf.set242 = or i8 %bf.clear241, -96
  store i8 %bf.set242, i8* %src_reg239, align 1
  %off243 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element233, i32 0, i32 2
  %17 = load i32, i32* %r8_offset, align 4
  %conv244 = trunc i32 %17 to i16
  store i16 %conv244, i16* %off243, align 2
  %imm245 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element233, i32 0, i32 3
  store i32 0, i32* %imm245, align 4
  %18 = load i32*, i32** %cnt.addr, align 8
  store i32 19, i32* %18, align 4
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load i32, i32* %position.addr, align 4
  %arraydecay = getelementptr inbounds [19 x %struct.bpf_insn], [19 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %21 = load i32*, i32** %cnt.addr, align 8
  %22 = load i32, i32* %21, align 4
  %call = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %19, i32 noundef %20, %struct.bpf_insn* noundef %arraydecay, i32 noundef %22) #20
  store %struct.bpf_prog* %call, %struct.bpf_prog** %new_prog, align 8
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool = icmp ne %struct.bpf_prog* %23, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %24 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %24, %struct.bpf_prog** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 27
  %26 = load i32, i32* %callback_subprogno.addr, align 4
  %idxprom = zext i32 %26 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %27 = load i32, i32* %start, align 8
  store i32 %27, i32* %callback_start, align 4
  %28 = load i32, i32* %position.addr, align 4
  %add246 = add i32 %28, 12
  store i32 %add246, i32* %call_insn_offset, align 4
  %29 = load i32, i32* %callback_start, align 4
  %30 = load i32, i32* %call_insn_offset, align 4
  %sub = sub i32 %29, %30
  %sub247 = sub i32 %sub, 1
  store i32 %sub247, i32* %callback_offset, align 4
  %31 = load i32, i32* %callback_offset, align 4
  %32 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %33 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %32, i32 0, i32 12
  %34 = bitcast %union.anon.198* %33 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %34, i32 0, i32 1
  %35 = load i32, i32* %call_insn_offset, align 4
  %idxprom248 = zext i32 %35 to i64
  %arrayidx249 = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 %idxprom248
  %imm250 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx249, i32 0, i32 3
  store i32 %31, i32* %imm250, align 4
  %36 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %36, %struct.bpf_prog** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %37 = load %struct.bpf_prog*, %struct.bpf_prog** %retval, align 8
  ret %struct.bpf_prog* %37
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, %struct.bpf_insn* noundef %patch, i32 noundef %len) #0 {
entry:
  %retval = alloca %struct.bpf_prog*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %patch.addr = alloca %struct.bpf_insn*, align 8
  %len.addr = alloca i32, align 4
  %new_prog = alloca %struct.bpf_prog*, align 8
  %new_data = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store %struct.bpf_insn* %patch, %struct.bpf_insn** %patch.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  store %struct.bpf_insn_aux_data* null, %struct.bpf_insn_aux_data** %new_data, align 8
  %0 = load i32, i32* %len.addr, align 4
  %cmp = icmp ugt i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 4
  %3 = load i32, i32* %len1, align 4
  %4 = load i32, i32* %len.addr, align 4
  %add = add i32 %3, %4
  %sub = sub i32 %add, 1
  %conv = zext i32 %sub to i64
  %call = call i64 @size_mul(i64 noundef %conv, i64 noundef 56) #20
  %call2 = call noalias i8* @vzalloc(i64 noundef %call) #24
  %5 = bitcast i8* %call2 to %struct.bpf_insn_aux_data*
  store %struct.bpf_insn_aux_data* %5, %struct.bpf_insn_aux_data** %new_data, align 8
  %6 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %tobool = icmp ne %struct.bpf_insn_aux_data* %6, null
  br i1 %tobool, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then
  store %struct.bpf_prog* null, %struct.bpf_prog** %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog5 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 2
  %8 = load %struct.bpf_prog*, %struct.bpf_prog** %prog5, align 8
  %9 = load i32, i32* %off.addr, align 4
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %patch.addr, align 8
  %11 = load i32, i32* %len.addr, align 4
  %call6 = call %struct.bpf_prog* @bpf_patch_insn_single(%struct.bpf_prog* noundef %8, i32 noundef %9, %struct.bpf_insn* noundef %10, i32 noundef %11) #20
  store %struct.bpf_prog* %call6, %struct.bpf_prog** %new_prog, align 8
  %12 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %13 = bitcast %struct.bpf_prog* %12 to i8*
  %call7 = call zeroext i1 @IS_ERR(i8* noundef %13) #20
  br i1 %call7, label %if.then8, label %if.end14

if.then8:                                         ; preds = %if.end4
  %14 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %15 = bitcast %struct.bpf_prog* %14 to i8*
  %call9 = call i64 @PTR_ERR(i8* noundef %15) #20
  %cmp10 = icmp eq i64 %call9, -34
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.then8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 24
  %19 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %20 = load i32, i32* %off.addr, align 4
  %idxprom = zext i32 %20 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %19, i64 %idxprom
  %orig_idx = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 7
  %21 = load i32, i32* %orig_idx, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.498, i64 0, i64 0), i32 noundef %21) #20
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.then8
  %22 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %23 = bitcast %struct.bpf_insn_aux_data* %22 to i8*
  call void @vfree(i8* noundef %23) #20
  store %struct.bpf_prog* null, %struct.bpf_prog** %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end4
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %27 = load i32, i32* %off.addr, align 4
  %28 = load i32, i32* %len.addr, align 4
  call void @adjust_insn_aux_data(%struct.bpf_verifier_env* noundef %24, %struct.bpf_insn_aux_data* noundef %25, %struct.bpf_prog* noundef %26, i32 noundef %27, i32 noundef %28) #20
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = load i32, i32* %off.addr, align 4
  %31 = load i32, i32* %len.addr, align 4
  call void @adjust_subprog_starts(%struct.bpf_verifier_env* noundef %29, i32 noundef %30, i32 noundef %31) #20
  %32 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %33 = load i32, i32* %off.addr, align 4
  %34 = load i32, i32* %len.addr, align 4
  call void @adjust_poke_descs(%struct.bpf_prog* noundef %32, i32 noundef %33, i32 noundef %34) #20
  %35 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %35, %struct.bpf_prog** %retval, align 8
  br label %return

return:                                           ; preds = %if.end14, %if.end13, %if.then3
  %36 = load %struct.bpf_prog*, %struct.bpf_prog** %retval, align 8
  ret %struct.bpf_prog* %36
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_prog* @bpf_patch_insn_single(%struct.bpf_prog* noundef, i32 noundef, %struct.bpf_insn* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_insn_aux_data(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn_aux_data* noundef %new_data, %struct.bpf_prog* noundef %new_prog, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %new_data.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %new_prog.addr = alloca %struct.bpf_prog*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %old_data = alloca %struct.bpf_insn_aux_data*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %old_seen = alloca i32, align 4
  %prog_len = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn_aux_data* %new_data, %struct.bpf_insn_aux_data** %new_data.addr, align 8
  store %struct.bpf_prog* %new_prog, %struct.bpf_prog** %new_prog.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %old_data, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog.addr, align 8
  %3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 12
  %4 = bitcast %union.anon.198* %3 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %4, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %6 = load i32, i32* %off.addr, align 4
  %idxprom = zext i32 %6 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %5, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  %7 = load i32, i32* %seen, align 4
  store i32 %7, i32* %old_seen, align 4
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %10 = load i32, i32* %off.addr, align 4
  %idx.ext = zext i32 %10 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %9, i64 %idx.ext
  %11 = load i32, i32* %cnt.addr, align 4
  %idx.ext1 = zext i32 %11 to i64
  %add.ptr2 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr, i64 %idx.ext1
  %add.ptr3 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr2, i64 -1
  %call = call zeroext i1 @insn_has_def32(%struct.bpf_verifier_env* noundef %8, %struct.bpf_insn* noundef %add.ptr3) #20
  %12 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %13 = load i32, i32* %off.addr, align 4
  %idxprom4 = zext i32 %13 to i64
  %arrayidx5 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %12, i64 %idxprom4
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx5, i32 0, i32 5
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %zext_dst, align 1
  %14 = load i32, i32* %cnt.addr, align 4
  %cmp = icmp eq i32 %14, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog.addr, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %15, i32 0, i32 4
  %16 = load i32, i32* %len, align 4
  store i32 %16, i32* %prog_len, align 4
  %17 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data.addr, align 8
  %18 = bitcast %struct.bpf_insn_aux_data* %17 to i8*
  %19 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %20 = bitcast %struct.bpf_insn_aux_data* %19 to i8*
  %21 = load i32, i32* %off.addr, align 4
  %conv = zext i32 %21 to i64
  %mul = mul i64 56, %conv
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %18, i8* align 8 %20, i64 %mul, i1 false)
  %22 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data.addr, align 8
  %23 = load i32, i32* %off.addr, align 4
  %idx.ext6 = zext i32 %23 to i64
  %add.ptr7 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %22, i64 %idx.ext6
  %24 = load i32, i32* %cnt.addr, align 4
  %idx.ext8 = zext i32 %24 to i64
  %add.ptr9 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %add.ptr7, i64 %idx.ext8
  %add.ptr10 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %add.ptr9, i64 -1
  %25 = bitcast %struct.bpf_insn_aux_data* %add.ptr10 to i8*
  %26 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %27 = load i32, i32* %off.addr, align 4
  %idx.ext11 = zext i32 %27 to i64
  %add.ptr12 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %26, i64 %idx.ext11
  %28 = bitcast %struct.bpf_insn_aux_data* %add.ptr12 to i8*
  %29 = load i32, i32* %prog_len, align 4
  %30 = load i32, i32* %off.addr, align 4
  %sub = sub i32 %29, %30
  %31 = load i32, i32* %cnt.addr, align 4
  %sub13 = sub i32 %sub, %31
  %add = add i32 %sub13, 1
  %conv14 = zext i32 %add to i64
  %mul15 = mul i64 56, %conv14
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %28, i64 %mul15, i1 false)
  %32 = load i32, i32* %off.addr, align 4
  store i32 %32, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %33 = load i32, i32* %i, align 4
  %34 = load i32, i32* %off.addr, align 4
  %35 = load i32, i32* %cnt.addr, align 4
  %add16 = add i32 %34, %35
  %sub17 = sub i32 %add16, 1
  %cmp18 = icmp ult i32 %33, %sub17
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load i32, i32* %old_seen, align 4
  %37 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data.addr, align 8
  %38 = load i32, i32* %i, align 4
  %idxprom20 = sext i32 %38 to i64
  %arrayidx21 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %37, i64 %idxprom20
  %seen22 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx21, i32 0, i32 3
  store i32 %36, i32* %seen22, align 4
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %41 = load i32, i32* %i, align 4
  %idx.ext23 = sext i32 %41 to i64
  %add.ptr24 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %40, i64 %idx.ext23
  %call25 = call zeroext i1 @insn_has_def32(%struct.bpf_verifier_env* noundef %39, %struct.bpf_insn* noundef %add.ptr24) #20
  %42 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data.addr, align 8
  %43 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %43 to i64
  %arrayidx27 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %42, i64 %idxprom26
  %zext_dst28 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx27, i32 0, i32 5
  %frombool29 = zext i1 %call25 to i8
  store i8 %frombool29, i8* %zext_dst28, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %44 = load i32, i32* %i, align 4
  %inc = add i32 %44, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !172

for.end:                                          ; preds = %for.cond
  %45 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data.addr, align 8
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %46, i32 0, i32 24
  store %struct.bpf_insn_aux_data* %45, %struct.bpf_insn_aux_data** %insn_aux_data30, align 8
  %47 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %48 = bitcast %struct.bpf_insn_aux_data* %47 to i8*
  call void @vfree(i8* noundef %48) #20
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_subprog_starts(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %len) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  %0 = load i32, i32* %len.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 31
  %3 = load i32, i32* %subprog_cnt, align 4
  %cmp1 = icmp ule i32 %1, %3
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 27
  %5 = load i32, i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %6 = load i32, i32* %start, align 8
  %7 = load i32, i32* %off.addr, align 4
  %cmp2 = icmp ule i32 %6, %7
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %for.body
  br label %for.inc

if.end4:                                          ; preds = %for.body
  %8 = load i32, i32* %len.addr, align 4
  %sub = sub i32 %8, 1
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info5 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 27
  %10 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %10 to i64
  %arrayidx7 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info5, i64 0, i64 %idxprom6
  %start8 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx7, i32 0, i32 0
  %11 = load i32, i32* %start8, align 8
  %add = add i32 %11, %sub
  store i32 %add, i32* %start8, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end4, %if.then3
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !173

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_poke_descs(%struct.bpf_prog* noundef %prog, i32 noundef %off, i32 noundef %len) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %off.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  %tab = alloca %struct.bpf_jit_poke_descriptor*, align 8
  %i = alloca i32, align 4
  %sz = alloca i32, align 4
  %desc = alloca %struct.bpf_jit_poke_descriptor*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 10
  %1 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %1, i32 0, i32 32
  %2 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab, align 8
  store %struct.bpf_jit_poke_descriptor* %2, %struct.bpf_jit_poke_descriptor** %tab, align 8
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 10
  %4 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1, align 8
  %size_poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %4, i32 0, i32 35
  %5 = load i32, i32* %size_poke_tab, align 8
  store i32 %5, i32* %sz, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %sz, align 4
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %tab, align 8
  %9 = load i32, i32* %i, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %8, i64 %idxprom
  store %struct.bpf_jit_poke_descriptor* %arrayidx, %struct.bpf_jit_poke_descriptor** %desc, align 8
  %10 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %desc, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %10, i32 0, i32 8
  %11 = load i32, i32* %insn_idx, align 4
  %12 = load i32, i32* %off.addr, align 4
  %cmp2 = icmp ule i32 %11, %12
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %13 = load i32, i32* %len.addr, align 4
  %sub = sub i32 %13, 1
  %14 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %desc, align 8
  %insn_idx3 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %14, i32 0, i32 8
  %15 = load i32, i32* %insn_idx3, align 4
  %add = add i32 %15, %sub
  store i32 %add, i32* %insn_idx3, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %16 = load i32, i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !174

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @insn_has_def32(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %dst_reg = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call = call i32 @insn_def_regno(%struct.bpf_insn* noundef %0) #20
  store i32 %call, i32* %dst_reg, align 4
  %1 = load i32, i32* %dst_reg, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %4 = load i32, i32* %dst_reg, align 4
  %call1 = call zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %2, %struct.bpf_insn* noundef %3, i32 noundef %4, %struct.bpf_reg_state* noundef null, i32 noundef 1) #20
  %lnot = xor i1 %call1, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i1, i1* %retval, align 1
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @insn_def_regno(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %sw.default [
    i32 5, label %sw.bb
    i32 6, label %sw.bb
    i32 2, label %sw.bb
    i32 3, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  store i32 -1, i32* %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 224
  %cmp = icmp eq i32 %and4, 192
  br i1 %cmp, label %land.lhs.true, label %if.else12

land.lhs.true:                                    ; preds = %sw.bb1
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 3
  %5 = load i32, i32* %imm, align 4
  %and6 = and i32 %5, 1
  %tobool = icmp ne i32 %and6, 0
  br i1 %tobool, label %if.then, label %if.else12

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 3
  %7 = load i32, i32* %imm7, align 4
  %cmp8 = icmp eq i32 %7, 241
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.then
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv11 = zext i8 %bf.lshr to i32
  store i32 %conv11, i32* %retval, align 4
  br label %return

if.else12:                                        ; preds = %land.lhs.true, %sw.bb1
  store i32 -1, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 1
  %bf.load13 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load13, 15
  %conv14 = zext i8 %bf.clear to i32
  store i32 %conv14, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %if.else12, %if.else, %if.then10, %sw.bb
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @insn_is_cond_jump(i8 noundef zeroext %code) #0 {
entry:
  %retval = alloca i1, align 1
  %code.addr = alloca i8, align 1
  %op = alloca i8, align 1
  store i8 %code, i8* %code.addr, align 1
  %0 = load i8, i8* %code.addr, align 1
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 7
  %cmp = icmp eq i32 %and, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8, i8* %code.addr, align 1
  %conv2 = zext i8 %1 to i32
  %and3 = and i32 %conv2, 7
  %cmp4 = icmp ne i32 %and3, 5
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i1 false, i1* %retval, align 1
  br label %return

if.end7:                                          ; preds = %if.end
  %2 = load i8, i8* %code.addr, align 1
  %conv8 = zext i8 %2 to i32
  %and9 = and i32 %conv8, 240
  %conv10 = trunc i32 %and9 to i8
  store i8 %conv10, i8* %op, align 1
  %3 = load i8, i8* %op, align 1
  %conv11 = zext i8 %3 to i32
  %cmp12 = icmp ne i32 %conv11, 0
  br i1 %cmp12, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.end7
  %4 = load i8, i8* %op, align 1
  %conv14 = zext i8 %4 to i32
  %cmp15 = icmp ne i32 %conv14, 144
  br i1 %cmp15, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %5 = load i8, i8* %op, align 1
  %conv17 = zext i8 %5 to i32
  %cmp18 = icmp ne i32 %conv17, 128
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %if.end7
  %6 = phi i1 [ false, %land.lhs.true ], [ false, %if.end7 ], [ %cmp18, %land.rhs ]
  store i1 %6, i1* %retval, align 1
  br label %return

return:                                           ; preds = %land.end, %if.then6, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_offload_replace_insn(%struct.bpf_verifier_env* noundef, i32 noundef, %struct.bpf_insn* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @verifier_remove_insns(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %orig_prog_len = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %orig_prog_len, align 4
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 10
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %7) #20
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load i32, i32* %off.addr, align 4
  %10 = load i32, i32* %cnt.addr, align 4
  call void @bpf_prog_offload_remove_insns(%struct.bpf_verifier_env* noundef %8, i32 noundef %9, i32 noundef %10) #20
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 2
  %12 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %cnt.addr, align 4
  %call3 = call i32 @bpf_remove_insns(%struct.bpf_prog* noundef %12, i32 noundef %13, i32 noundef %14) #20
  store i32 %call3, i32* %err, align 4
  %15 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %15, 0
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %16 = load i32, i32* %err, align 4
  store i32 %16, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %off.addr, align 4
  %19 = load i32, i32* %cnt.addr, align 4
  %call6 = call i32 @adjust_subprog_starts_after_remove(%struct.bpf_verifier_env* noundef %17, i32 noundef %18, i32 noundef %19) #20
  store i32 %call6, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool7 = icmp ne i32 %20, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %21 = load i32, i32* %err, align 4
  store i32 %21, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end5
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load i32, i32* %off.addr, align 4
  %24 = load i32, i32* %cnt.addr, align 4
  %call10 = call i32 @bpf_adj_linfo_after_remove(%struct.bpf_verifier_env* noundef %22, i32 noundef %23, i32 noundef %24) #20
  store i32 %call10, i32* %err, align 4
  %25 = load i32, i32* %err, align 4
  %tobool11 = icmp ne i32 %25, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  %26 = load i32, i32* %err, align 4
  store i32 %26, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end9
  %27 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %28 = load i32, i32* %off.addr, align 4
  %idx.ext = zext i32 %28 to i64
  %add.ptr = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %27, i64 %idx.ext
  %29 = bitcast %struct.bpf_insn_aux_data* %add.ptr to i8*
  %30 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %31 = load i32, i32* %off.addr, align 4
  %idx.ext14 = zext i32 %31 to i64
  %add.ptr15 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %30, i64 %idx.ext14
  %32 = load i32, i32* %cnt.addr, align 4
  %idx.ext16 = zext i32 %32 to i64
  %add.ptr17 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %add.ptr15, i64 %idx.ext16
  %33 = bitcast %struct.bpf_insn_aux_data* %add.ptr17 to i8*
  %34 = load i32, i32* %orig_prog_len, align 4
  %35 = load i32, i32* %off.addr, align 4
  %sub = sub i32 %34, %35
  %36 = load i32, i32* %cnt.addr, align 4
  %sub18 = sub i32 %sub, %36
  %conv = zext i32 %sub18 to i64
  %mul = mul i64 56, %conv
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 8 %29, i8* align 8 %33, i64 %mul, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then12, %if.then8, %if.then4
  %37 = load i32, i32* %retval, align 4
  ret i32 %37
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_offload_remove_insns(%struct.bpf_verifier_env* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_remove_insns(%struct.bpf_prog* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_subprog_starts_after_remove(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %aux = alloca %struct.bpf_prog_aux*, align 8
  %move = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 31
  %2 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 27
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %5 = load i32, i32* %start, align 8
  %6 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp uge i32 %5, %6
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !175

for.end:                                          ; preds = %if.then, %for.cond
  %8 = load i32, i32* %i, align 4
  store i32 %8, i32* %j, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc13, %for.end
  %9 = load i32, i32* %j, align 4
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 31
  %11 = load i32, i32* %subprog_cnt3, align 4
  %cmp4 = icmp ult i32 %9, %11
  br i1 %cmp4, label %for.body5, label %for.end15

for.body5:                                        ; preds = %for.cond2
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 27
  %13 = load i32, i32* %j, align 4
  %idxprom7 = sext i32 %13 to i64
  %arrayidx8 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info6, i64 0, i64 %idxprom7
  %start9 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx8, i32 0, i32 0
  %14 = load i32, i32* %start9, align 8
  %15 = load i32, i32* %off.addr, align 4
  %16 = load i32, i32* %cnt.addr, align 4
  %add = add i32 %15, %16
  %cmp10 = icmp uge i32 %14, %add
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body5
  br label %for.end15

if.end12:                                         ; preds = %for.body5
  br label %for.inc13

for.inc13:                                        ; preds = %if.end12
  %17 = load i32, i32* %j, align 4
  %inc14 = add i32 %17, 1
  store i32 %inc14, i32* %j, align 4
  br label %for.cond2, !llvm.loop !176

for.end15:                                        ; preds = %if.then11, %for.cond2
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 27
  %19 = load i32, i32* %j, align 4
  %idxprom17 = sext i32 %19 to i64
  %arrayidx18 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info16, i64 0, i64 %idxprom17
  %start19 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx18, i32 0, i32 0
  %20 = load i32, i32* %start19, align 8
  %21 = load i32, i32* %off.addr, align 4
  %22 = load i32, i32* %cnt.addr, align 4
  %add20 = add i32 %21, %22
  %cmp21 = icmp ne i32 %20, %add20
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %for.end15
  %23 = load i32, i32* %j, align 4
  %dec = add i32 %23, -1
  store i32 %dec, i32* %j, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %for.end15
  %24 = load i32, i32* %j, align 4
  %25 = load i32, i32* %i, align 4
  %cmp24 = icmp sgt i32 %24, %25
  br i1 %cmp24, label %if.then25, label %if.else

if.then25:                                        ; preds = %if.end23
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 2
  %27 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux26 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %27, i32 0, i32 10
  %28 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux26, align 8
  store %struct.bpf_prog_aux* %28, %struct.bpf_prog_aux** %aux, align 8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 31
  %30 = load i32, i32* %subprog_cnt27, align 4
  %add28 = add i32 %30, 1
  %31 = load i32, i32* %j, align 4
  %sub = sub i32 %add28, %31
  store i32 %sub, i32* %move, align 4
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %32, i32 0, i32 27
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info29, i64 0, i64 0
  %33 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %33 to i64
  %add.ptr = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arraydecay, i64 %idx.ext
  %34 = bitcast %struct.bpf_subprog_info* %add.ptr to i8*
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 27
  %arraydecay31 = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info30, i64 0, i64 0
  %36 = load i32, i32* %j, align 4
  %idx.ext32 = sext i32 %36 to i64
  %add.ptr33 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arraydecay31, i64 %idx.ext32
  %37 = bitcast %struct.bpf_subprog_info* %add.ptr33 to i8*
  %38 = load i32, i32* %move, align 4
  %conv = sext i32 %38 to i64
  %mul = mul i64 16, %conv
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %34, i8* align 4 %37, i64 %mul, i1 false)
  %39 = load i32, i32* %j, align 4
  %40 = load i32, i32* %i, align 4
  %sub34 = sub i32 %39, %40
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt35 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %41, i32 0, i32 31
  %42 = load i32, i32* %subprog_cnt35, align 4
  %sub36 = sub i32 %42, %sub34
  store i32 %sub36, i32* %subprog_cnt35, align 4
  %43 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %43, i32 0, i32 51
  %44 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info, align 8
  %tobool = icmp ne %struct.bpf_func_info* %44, null
  br i1 %tobool, label %if.then37, label %if.end50

if.then37:                                        ; preds = %if.then25
  %45 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_cnt = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %45, i32 0, i32 55
  %46 = load i32, i32* %func_info_cnt, align 8
  %47 = load i32, i32* %j, align 4
  %sub38 = sub i32 %46, %47
  store i32 %sub38, i32* %move, align 4
  %48 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info39 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %48, i32 0, i32 51
  %49 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info39, align 8
  %50 = load i32, i32* %i, align 4
  %idx.ext40 = sext i32 %50 to i64
  %add.ptr41 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %49, i64 %idx.ext40
  %51 = bitcast %struct.bpf_func_info* %add.ptr41 to i8*
  %52 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info42 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %52, i32 0, i32 51
  %53 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info42, align 8
  %54 = load i32, i32* %j, align 4
  %idx.ext43 = sext i32 %54 to i64
  %add.ptr44 = getelementptr %struct.bpf_func_info, %struct.bpf_func_info* %53, i64 %idx.ext43
  %55 = bitcast %struct.bpf_func_info* %add.ptr44 to i8*
  %56 = load i32, i32* %move, align 4
  %conv45 = sext i32 %56 to i64
  %mul46 = mul i64 8, %conv45
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %51, i8* align 4 %55, i64 %mul46, i1 false)
  %57 = load i32, i32* %j, align 4
  %58 = load i32, i32* %i, align 4
  %sub47 = sub i32 %57, %58
  %59 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_cnt48 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %59, i32 0, i32 55
  %60 = load i32, i32* %func_info_cnt48, align 8
  %sub49 = sub i32 %60, %sub47
  store i32 %sub49, i32* %func_info_cnt48, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then37, %if.then25
  br label %if.end60

if.else:                                          ; preds = %if.end23
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info51 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %61, i32 0, i32 27
  %62 = load i32, i32* %i, align 4
  %idxprom52 = sext i32 %62 to i64
  %arrayidx53 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info51, i64 0, i64 %idxprom52
  %start54 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx53, i32 0, i32 0
  %63 = load i32, i32* %start54, align 8
  %64 = load i32, i32* %off.addr, align 4
  %cmp55 = icmp eq i32 %63, %64
  br i1 %cmp55, label %if.then57, label %if.end59

if.then57:                                        ; preds = %if.else
  %65 = load i32, i32* %i, align 4
  %inc58 = add i32 %65, 1
  store i32 %inc58, i32* %i, align 4
  br label %if.end59

if.end59:                                         ; preds = %if.then57, %if.else
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.end50
  br label %for.cond61

for.cond61:                                       ; preds = %for.inc71, %if.end60
  %66 = load i32, i32* %i, align 4
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt62 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %67, i32 0, i32 31
  %68 = load i32, i32* %subprog_cnt62, align 4
  %cmp63 = icmp ule i32 %66, %68
  br i1 %cmp63, label %for.body65, label %for.end73

for.body65:                                       ; preds = %for.cond61
  %69 = load i32, i32* %cnt.addr, align 4
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info66 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %70, i32 0, i32 27
  %71 = load i32, i32* %i, align 4
  %idxprom67 = sext i32 %71 to i64
  %arrayidx68 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info66, i64 0, i64 %idxprom67
  %start69 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx68, i32 0, i32 0
  %72 = load i32, i32* %start69, align 8
  %sub70 = sub i32 %72, %69
  store i32 %sub70, i32* %start69, align 8
  br label %for.inc71

for.inc71:                                        ; preds = %for.body65
  %73 = load i32, i32* %i, align 4
  %inc72 = add i32 %73, 1
  store i32 %inc72, i32* %i, align 4
  br label %for.cond61, !llvm.loop !177

for.end73:                                        ; preds = %for.cond61
  ret i32 0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_adj_linfo_after_remove(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %prog = alloca %struct.bpf_prog*, align 8
  %i = alloca i32, align 4
  %l_off = alloca i32, align 4
  %l_cnt = alloca i32, align 4
  %nr_linfo = alloca i32, align 4
  %linfo = alloca %struct.bpf_line_info*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 10
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %nr_linfo2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 56
  %4 = load i32, i32* %nr_linfo2, align 4
  store i32 %4, i32* %nr_linfo, align 4
  %5 = load i32, i32* %nr_linfo, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 10
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %linfo4 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 53
  %8 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo4, align 8
  store %struct.bpf_line_info* %8, %struct.bpf_line_info** %linfo, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %nr_linfo, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom = zext i32 %12 to i64
  %arrayidx = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %11, i64 %idxprom
  %insn_off = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx, i32 0, i32 0
  %13 = load i32, i32* %insn_off, align 4
  %14 = load i32, i32* %off.addr, align 4
  %cmp5 = icmp uge i32 %13, %14
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  br label %for.end

if.end7:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %15 = load i32, i32* %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond, !llvm.loop !178

for.end:                                          ; preds = %if.then6, %for.cond
  %16 = load i32, i32* %i, align 4
  store i32 %16, i32* %l_off, align 4
  store i32 0, i32* %l_cnt, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc18, %for.end
  %17 = load i32, i32* %i, align 4
  %18 = load i32, i32* %nr_linfo, align 4
  %cmp9 = icmp ult i32 %17, %18
  br i1 %cmp9, label %for.body10, label %for.end20

for.body10:                                       ; preds = %for.cond8
  %19 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %20 = load i32, i32* %i, align 4
  %idxprom11 = zext i32 %20 to i64
  %arrayidx12 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %19, i64 %idxprom11
  %insn_off13 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx12, i32 0, i32 0
  %21 = load i32, i32* %insn_off13, align 4
  %22 = load i32, i32* %off.addr, align 4
  %23 = load i32, i32* %cnt.addr, align 4
  %add = add i32 %22, %23
  %cmp14 = icmp ult i32 %21, %add
  br i1 %cmp14, label %if.then15, label %if.else

if.then15:                                        ; preds = %for.body10
  %24 = load i32, i32* %l_cnt, align 4
  %inc16 = add i32 %24, 1
  store i32 %inc16, i32* %l_cnt, align 4
  br label %if.end17

if.else:                                          ; preds = %for.body10
  br label %for.end20

if.end17:                                         ; preds = %if.then15
  br label %for.inc18

for.inc18:                                        ; preds = %if.end17
  %25 = load i32, i32* %i, align 4
  %inc19 = add i32 %25, 1
  store i32 %inc19, i32* %i, align 4
  br label %for.cond8, !llvm.loop !179

for.end20:                                        ; preds = %if.else, %for.cond8
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %26, i32 0, i32 4
  %27 = load i32, i32* %len, align 4
  %28 = load i32, i32* %off.addr, align 4
  %cmp21 = icmp ne i32 %27, %28
  br i1 %cmp21, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %for.end20
  %29 = load i32, i32* %l_cnt, align 4
  %tobool22 = icmp ne i32 %29, 0
  br i1 %tobool22, label %land.lhs.true23, label %if.end36

land.lhs.true23:                                  ; preds = %land.lhs.true
  %30 = load i32, i32* %i, align 4
  %31 = load i32, i32* %nr_linfo, align 4
  %cmp24 = icmp eq i32 %30, %31
  br i1 %cmp24, label %if.then30, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true23
  %32 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %33 = load i32, i32* %i, align 4
  %idxprom25 = zext i32 %33 to i64
  %arrayidx26 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %32, i64 %idxprom25
  %insn_off27 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx26, i32 0, i32 0
  %34 = load i32, i32* %insn_off27, align 4
  %35 = load i32, i32* %off.addr, align 4
  %36 = load i32, i32* %cnt.addr, align 4
  %add28 = add i32 %35, %36
  %cmp29 = icmp ne i32 %34, %add28
  br i1 %cmp29, label %if.then30, label %if.end36

if.then30:                                        ; preds = %lor.lhs.false, %land.lhs.true23
  %37 = load i32, i32* %l_cnt, align 4
  %dec = add i32 %37, -1
  store i32 %dec, i32* %l_cnt, align 4
  %38 = load i32, i32* %off.addr, align 4
  %39 = load i32, i32* %cnt.addr, align 4
  %add31 = add i32 %38, %39
  %40 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %41 = load i32, i32* %i, align 4
  %dec32 = add i32 %41, -1
  store i32 %dec32, i32* %i, align 4
  %idxprom33 = zext i32 %dec32 to i64
  %arrayidx34 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %40, i64 %idxprom33
  %insn_off35 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx34, i32 0, i32 0
  store i32 %add31, i32* %insn_off35, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then30, %lor.lhs.false, %land.lhs.true, %for.end20
  %42 = load i32, i32* %l_cnt, align 4
  %tobool37 = icmp ne i32 %42, 0
  br i1 %tobool37, label %if.then38, label %if.end46

if.then38:                                        ; preds = %if.end36
  %43 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %44 = load i32, i32* %l_off, align 4
  %idx.ext = zext i32 %44 to i64
  %add.ptr = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %43, i64 %idx.ext
  %45 = bitcast %struct.bpf_line_info* %add.ptr to i8*
  %46 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %47 = load i32, i32* %i, align 4
  %idx.ext39 = zext i32 %47 to i64
  %add.ptr40 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %46, i64 %idx.ext39
  %48 = bitcast %struct.bpf_line_info* %add.ptr40 to i8*
  %49 = load i32, i32* %nr_linfo, align 4
  %50 = load i32, i32* %i, align 4
  %sub = sub i32 %49, %50
  %conv = zext i32 %sub to i64
  %mul = mul i64 16, %conv
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %45, i8* align 4 %48, i64 %mul, i1 false)
  %51 = load i32, i32* %l_cnt, align 4
  %52 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux41 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %52, i32 0, i32 10
  %53 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux41, align 8
  %nr_linfo42 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %53, i32 0, i32 56
  %54 = load i32, i32* %nr_linfo42, align 4
  %sub43 = sub i32 %54, %51
  store i32 %sub43, i32* %nr_linfo42, align 4
  %55 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux44 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %55, i32 0, i32 10
  %56 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux44, align 8
  %nr_linfo45 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %56, i32 0, i32 56
  %57 = load i32, i32* %nr_linfo45, align 4
  store i32 %57, i32* %nr_linfo, align 4
  br label %if.end46

if.end46:                                         ; preds = %if.then38, %if.end36
  %58 = load i32, i32* %l_off, align 4
  store i32 %58, i32* %i, align 4
  br label %for.cond47

for.cond47:                                       ; preds = %for.inc55, %if.end46
  %59 = load i32, i32* %i, align 4
  %60 = load i32, i32* %nr_linfo, align 4
  %cmp48 = icmp ult i32 %59, %60
  br i1 %cmp48, label %for.body50, label %for.end57

for.body50:                                       ; preds = %for.cond47
  %61 = load i32, i32* %cnt.addr, align 4
  %62 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %63 = load i32, i32* %i, align 4
  %idxprom51 = zext i32 %63 to i64
  %arrayidx52 = getelementptr %struct.bpf_line_info, %struct.bpf_line_info* %62, i64 %idxprom51
  %insn_off53 = getelementptr inbounds %struct.bpf_line_info, %struct.bpf_line_info* %arrayidx52, i32 0, i32 0
  %64 = load i32, i32* %insn_off53, align 4
  %sub54 = sub i32 %64, %61
  store i32 %sub54, i32* %insn_off53, align 4
  br label %for.inc55

for.inc55:                                        ; preds = %for.body50
  %65 = load i32, i32* %i, align 4
  %inc56 = add i32 %65, 1
  store i32 %inc56, i32* %i, align 4
  br label %for.cond47, !llvm.loop !180

for.end57:                                        ; preds = %for.cond47
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc87, %for.end57
  %66 = load i32, i32* %i, align 4
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %67, i32 0, i32 31
  %68 = load i32, i32* %subprog_cnt, align 4
  %cmp59 = icmp ule i32 %66, %68
  br i1 %cmp59, label %for.body61, label %for.end89

for.body61:                                       ; preds = %for.cond58
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %69, i32 0, i32 27
  %70 = load i32, i32* %i, align 4
  %idxprom62 = zext i32 %70 to i64
  %arrayidx63 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom62
  %linfo_idx = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx63, i32 0, i32 1
  %71 = load i32, i32* %linfo_idx, align 4
  %72 = load i32, i32* %l_off, align 4
  %cmp64 = icmp ugt i32 %71, %72
  br i1 %cmp64, label %if.then66, label %if.end86

if.then66:                                        ; preds = %for.body61
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info67 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %73, i32 0, i32 27
  %74 = load i32, i32* %i, align 4
  %idxprom68 = zext i32 %74 to i64
  %arrayidx69 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info67, i64 0, i64 %idxprom68
  %linfo_idx70 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx69, i32 0, i32 1
  %75 = load i32, i32* %linfo_idx70, align 4
  %76 = load i32, i32* %l_off, align 4
  %77 = load i32, i32* %l_cnt, align 4
  %add71 = add i32 %76, %77
  %cmp72 = icmp uge i32 %75, %add71
  br i1 %cmp72, label %if.then74, label %if.else80

if.then74:                                        ; preds = %if.then66
  %78 = load i32, i32* %l_cnt, align 4
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info75 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %79, i32 0, i32 27
  %80 = load i32, i32* %i, align 4
  %idxprom76 = zext i32 %80 to i64
  %arrayidx77 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info75, i64 0, i64 %idxprom76
  %linfo_idx78 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx77, i32 0, i32 1
  %81 = load i32, i32* %linfo_idx78, align 4
  %sub79 = sub i32 %81, %78
  store i32 %sub79, i32* %linfo_idx78, align 4
  br label %if.end85

if.else80:                                        ; preds = %if.then66
  %82 = load i32, i32* %l_off, align 4
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info81 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %83, i32 0, i32 27
  %84 = load i32, i32* %i, align 4
  %idxprom82 = zext i32 %84 to i64
  %arrayidx83 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info81, i64 0, i64 %idxprom82
  %linfo_idx84 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx83, i32 0, i32 1
  store i32 %82, i32* %linfo_idx84, align 4
  br label %if.end85

if.end85:                                         ; preds = %if.else80, %if.then74
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %for.body61
  br label %for.inc87

for.inc87:                                        ; preds = %if.end86
  %85 = load i32, i32* %i, align 4
  %inc88 = add i32 %85, 1
  store i32 %inc88, i32* %i, align 4
  br label %for.cond58, !llvm.loop !181

for.end89:                                        ; preds = %for.cond58
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end89, %if.then
  %86 = load i32, i32* %retval, align 4
  ret i32 %86
}

; Function Attrs: argmemonly nofree nounwind willreturn
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1 immarg) #5

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_sock_convert_ctx_access(i32 noundef, %struct.bpf_insn* noundef, %struct.bpf_insn* noundef, %struct.bpf_prog* noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_tcp_sock_convert_ctx_access(i32 noundef, %struct.bpf_insn* noundef, %struct.bpf_insn* noundef, %struct.bpf_prog* noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_xdp_sock_convert_ctx_access(i32 noundef, %struct.bpf_insn* noundef, %struct.bpf_insn* noundef, %struct.bpf_prog* noundef, i32* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_ctx_off_adjust_machine(i32 noundef %size) #0 {
entry:
  %size.addr = alloca i32, align 4
  %size_machine = alloca i32, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 8, i32* %size_machine, align 4
  %0 = load i32, i32* %size.addr, align 4
  %cmp = icmp ugt i32 %0, 8
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %rem = urem i32 %1, 8
  %cmp1 = icmp eq i32 %rem, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 8, i32* %size.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %2 = load i32, i32* %size.addr, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i8 @bpf_ctx_narrow_access_offset(i32 noundef %off, i32 noundef %size, i32 noundef %size_default) #0 {
entry:
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %size_default.addr = alloca i32, align 4
  %access_off = alloca i8, align 1
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %size_default, i32* %size_default.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %1 = load i32, i32* %size_default.addr, align 4
  %sub = sub i32 %1, 1
  %and = and i32 %0, %sub
  %conv = trunc i32 %and to i8
  store i8 %conv, i8* %access_off, align 1
  %2 = load i8, i8* %access_off, align 1
  ret i8 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @fixup_kfunc_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %desc = alloca %struct.bpf_kfunc_desc*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 3
  %1 = load i32, i32* %imm, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([62 x i8], [62 x i8]* @.str.503, i64 0, i64 0)) #20
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 2
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 3
  %7 = load i32, i32* %imm1, align 4
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 2
  %9 = load i16, i16* %off, align 2
  %call = call %struct.bpf_kfunc_desc* @find_kfunc_desc(%struct.bpf_prog* noundef %5, i32 noundef %7, i16 noundef zeroext %9) #20
  store %struct.bpf_kfunc_desc* %call, %struct.bpf_kfunc_desc** %desc, align 8
  %10 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %desc, align 8
  %tobool2 = icmp ne %struct.bpf_kfunc_desc* %10, null
  br i1 %tobool2, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm4 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 3
  %14 = load i32, i32* %imm4, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([78 x i8], [78 x i8]* @.str.504, i64 0, i64 0), i32 noundef %14) #20
  store i32 -14, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %15 = load %struct.bpf_kfunc_desc*, %struct.bpf_kfunc_desc** %desc, align 8
  %imm6 = getelementptr inbounds %struct.bpf_kfunc_desc, %struct.bpf_kfunc_desc* %15, i32 0, i32 2
  %16 = load i32, i32* %imm6, align 4
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %17, i32 0, i32 3
  store i32 %16, i32* %imm7, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end5, %if.then3, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_user_rnd_init_once() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_jit_add_poke_descriptor(%struct.bpf_prog* noundef %prog, %struct.bpf_jit_poke_descriptor* noundef %poke) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %poke.addr = alloca %struct.bpf_jit_poke_descriptor*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store %struct.bpf_jit_poke_descriptor* %poke, %struct.bpf_jit_poke_descriptor** %poke.addr, align 8
  ret i32 -524
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @sort_kfunc_descs_by_imm(%struct.bpf_prog* noundef %prog) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %tab = alloca %struct.bpf_kfunc_desc_tab*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 10
  %1 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %kfunc_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %1, i32 0, i32 33
  %2 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %kfunc_tab, align 8
  store %struct.bpf_kfunc_desc_tab* %2, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %3 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %tobool = icmp ne %struct.bpf_kfunc_desc_tab* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x %struct.bpf_kfunc_desc], [256 x %struct.bpf_kfunc_desc]* %descs, i64 0, i64 0
  %5 = bitcast %struct.bpf_kfunc_desc* %arraydecay to i8*
  %6 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %tab, align 8
  %nr_descs = getelementptr inbounds %struct.bpf_kfunc_desc_tab, %struct.bpf_kfunc_desc_tab* %6, i32 0, i32 1
  %7 = load i32, i32* %nr_descs, align 4
  %conv = zext i32 %7 to i64
  call void @sort(i8* noundef %5, i64 noundef %conv, i64 noundef 40, i32 (i8*, i8*)* noundef @kfunc_desc_cmp_by_imm, void (i8*, i8*, i32)* noundef null) #20
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @get_random_u32() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_cmpxchg_insn(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 7
  %cmp = icmp eq i32 %and, 3
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 224
  %cmp5 = icmp eq i32 %and4, 192
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 3
  %5 = load i32, i32* %imm, align 4
  %cmp7 = icmp eq i32 %5, 241
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %6 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp7, %land.rhs ]
  ret i1 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @jit_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %tmp.i503 = alloca i32 ()*, align 8
  %tmp.i = alloca i32 ()*, align 8
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %func = alloca %struct.bpf_prog**, align 8
  %tmp = alloca %struct.bpf_prog*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %subprog_start = alloca i32, align 4
  %subprog_end = alloca i32, align 4
  %len = alloca i32, align 4
  %subprog = alloca i32, align 4
  %map_ptr = alloca %struct.bpf_map*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %old_bpf_func = alloca i8*, align 8
  %err = alloca i32, align 4
  %num_exentries = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_cond = alloca i8, align 1
  %__ret_once = alloca i8, align 1
  %tmp20 = alloca i64, align 8
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp53 = alloca i64, align 8
  %tmp61 = alloca i64, align 8
  %poke = alloca %struct.bpf_jit_poke_descriptor*, align 8
  %tmp287 = alloca i32, align 4
  %tmp371 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  store i32 0, i32* %subprog_end, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 31
  %3 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ule i32 %3, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %5 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 12
  %6 = bitcast %union.anon.198* %5 to %struct.anon.201*
  %insnsi = getelementptr inbounds %struct.anon.201, %struct.anon.201* %6, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, i32* %i, align 4
  %8 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %8, i32 0, i32 4
  %9 = load i32, i32* %len2, align 4
  %cmp3 = icmp ult i32 %7, %9
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %10) #20
  br i1 %call, label %if.end6, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call4 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %11) #20
  br i1 %call4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %land.lhs.true
  br label %for.inc

if.end6:                                          ; preds = %land.lhs.true, %for.body
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load i32, i32* %i, align 4
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %14, i32 0, i32 3
  %15 = load i32, i32* %imm, align 4
  %add = add i32 %13, %15
  %add7 = add i32 %add, 1
  %call8 = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %12, i32 noundef %add7) #20
  store i32 %call8, i32* %subprog, align 4
  %16 = load i32, i32* %subprog, align 4
  %cmp9 = icmp slt i32 %16, 0
  br i1 %cmp9, label %if.then10, label %if.end68

if.then10:                                        ; preds = %if.end6
  store i8 1, i8* %__ret_do_once, align 1
  %17 = load i8, i8* %__ret_do_once, align 1
  %tobool = trunc i8 %17 to i1
  %lnot = xor i1 %tobool, true
  %lnot11 = xor i1 %lnot, true
  %frombool = zext i1 %lnot11 to i8
  store i8 %frombool, i8* %__ret_cond, align 1
  store i8 0, i8* %__ret_once, align 1
  %18 = load i8, i8* %__ret_cond, align 1
  %tobool12 = trunc i8 %18 to i1
  br i1 %tobool12, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then10
  %19 = load i8, i8* @jit_subprogs.__already_done, align 1
  %tobool13 = trunc i8 %19 to i1
  %lnot14 = xor i1 %tobool13, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then10
  %20 = phi i1 [ false, %if.then10 ], [ %lnot14, %land.rhs ]
  %lnot15 = xor i1 %20, true
  %lnot16 = xor i1 %lnot15, true
  %lnot.ext = zext i1 %lnot16 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool17 = icmp ne i64 %conv, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.end
  store i8 1, i8* @jit_subprogs.__already_done, align 1
  store i8 1, i8* %__ret_once, align 1
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %land.end
  %21 = load i8, i8* %__ret_once, align 1
  %tobool21 = trunc i8 %21 to i1
  %lnot22 = xor i1 %tobool21, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  %conv26 = sext i32 %lnot.ext25 to i64
  store i64 %conv26, i64* %tmp20, align 8
  %22 = load i64, i64* %tmp20, align 8
  %tobool27 = icmp ne i64 %22, 0
  br i1 %tobool27, label %if.then28, label %if.end60

if.then28:                                        ; preds = %if.end19
  store i32 1, i32* %__ret_warn_on, align 4
  %23 = load i32, i32* %__ret_warn_on, align 4
  %tobool29 = icmp ne i32 %23, 0
  %lnot30 = xor i1 %tobool29, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %tobool35 = icmp ne i64 %conv34, 0
  br i1 %tobool35, label %if.then36, label %if.end52

if.then36:                                        ; preds = %if.then28
  br label %do.body

do.body:                                          ; preds = %if.then36
  br label %do.body37

do.body37:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body37
  %24 = load i32, i32* %i, align 4
  %25 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm38 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %25, i32 0, i32 3
  %26 = load i32, i32* %imm38, align 4
  %add39 = add i32 %24, %26
  %add40 = add i32 %add39, 1
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.350, i64 0, i64 0), i32 noundef %add40) #20
  br label %do.body41

do.body41:                                        ; preds = %do.end
  store i32 2313, i32* %__flags, align 4
  br label %do.body42

do.body42:                                        ; preds = %do.body41
  br label %do.end43

do.end43:                                         ; preds = %do.body42
  br label %do.body44

do.body44:                                        ; preds = %do.end43
  %27 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 15568, i32 %27, i64 12) #19, !srcloc !182
  br label %do.end45

do.end45:                                         ; preds = %do.body44
  br label %do.body46

do.body46:                                        ; preds = %do.end45
  br label %do.end47

do.end47:                                         ; preds = %do.body46
  br label %do.end48

do.end48:                                         ; preds = %do.end47
  br label %do.body49

do.body49:                                        ; preds = %do.end48
  br label %do.end50

do.end50:                                         ; preds = %do.body49
  br label %do.end51

do.end51:                                         ; preds = %do.end50
  br label %if.end52

if.end52:                                         ; preds = %do.end51, %if.then28
  %28 = load i32, i32* %__ret_warn_on, align 4
  %tobool54 = icmp ne i32 %28, 0
  %lnot55 = xor i1 %tobool54, true
  %lnot57 = xor i1 %lnot55, true
  %lnot.ext58 = zext i1 %lnot57 to i32
  %conv59 = sext i32 %lnot.ext58 to i64
  store i64 %conv59, i64* %tmp53, align 8
  %29 = load i64, i64* %tmp53, align 8
  br label %if.end60

if.end60:                                         ; preds = %if.end52, %if.end19
  %30 = load i8, i8* %__ret_do_once, align 1
  %tobool62 = trunc i8 %30 to i1
  %lnot63 = xor i1 %tobool62, true
  %lnot65 = xor i1 %lnot63, true
  %lnot.ext66 = zext i1 %lnot65 to i32
  %conv67 = sext i32 %lnot.ext66 to i64
  store i64 %conv67, i64* %tmp61, align 8
  %31 = load i64, i64* %tmp61, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end68:                                         ; preds = %if.end6
  %32 = load i32, i32* %subprog, align 4
  %conv69 = trunc i32 %32 to i16
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %33, i32 0, i32 2
  store i16 %conv69, i16* %off, align 2
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm70 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %34, i32 0, i32 3
  %35 = load i32, i32* %imm70, align 4
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %36, i32 0, i32 24
  %37 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %38 = load i32, i32* %i, align 4
  %idxprom = sext i32 %38 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %37, i64 %idxprom
  %39 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 0
  %call_imm = bitcast %union.anon.210* %39 to i32*
  store i32 %35, i32* %call_imm, align 8
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm71 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %40, i32 0, i32 3
  store i32 1, i32* %imm71, align 4
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call72 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %41) #20
  br i1 %call72, label %if.then73, label %if.end76

if.then73:                                        ; preds = %if.end68
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx74 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %42, i64 1
  %imm75 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx74, i32 0, i32 3
  store i32 1, i32* %imm75, align 4
  br label %if.end76

if.end76:                                         ; preds = %if.then73, %if.end68
  br label %for.inc

for.inc:                                          ; preds = %if.end76, %if.then5
  %43 = load i32, i32* %i, align 4
  %inc = add i32 %43, 1
  store i32 %inc, i32* %i, align 4
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %44, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond, !llvm.loop !183

for.end:                                          ; preds = %for.cond
  %45 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call77 = call i32 @bpf_prog_alloc_jited_linfo(%struct.bpf_prog* noundef %45) #20
  store i32 %call77, i32* %err, align 4
  %46 = load i32, i32* %err, align 4
  %tobool78 = icmp ne i32 %46, 0
  br i1 %tobool78, label %if.then79, label %if.end80

if.then79:                                        ; preds = %for.end
  br label %out_undo_insn

if.end80:                                         ; preds = %for.end
  store i32 -12, i32* %err, align 4
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt81 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %47, i32 0, i32 31
  %48 = load i32, i32* %subprog_cnt81, align 4
  %conv82 = zext i32 %48 to i64
  %call83 = call noalias i8* @kcalloc(i64 noundef %conv82, i64 noundef 8, i32 noundef 3264) #25
  %49 = bitcast i8* %call83 to %struct.bpf_prog**
  store %struct.bpf_prog** %49, %struct.bpf_prog*** %func, align 8
  %50 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %tobool84 = icmp ne %struct.bpf_prog** %50, null
  br i1 %tobool84, label %if.end86, label %if.then85

if.then85:                                        ; preds = %if.end80
  br label %out_undo_insn

if.end86:                                         ; preds = %if.end80
  store i32 0, i32* %i, align 4
  br label %for.cond87

for.cond87:                                       ; preds = %for.inc289, %if.end86
  %51 = load i32, i32* %i, align 4
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt88 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %52, i32 0, i32 31
  %53 = load i32, i32* %subprog_cnt88, align 4
  %cmp89 = icmp ult i32 %51, %53
  br i1 %cmp89, label %for.body91, label %for.end291

for.body91:                                       ; preds = %for.cond87
  %54 = load i32, i32* %subprog_end, align 4
  store i32 %54, i32* %subprog_start, align 4
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %55, i32 0, i32 27
  %56 = load i32, i32* %i, align 4
  %add92 = add i32 %56, 1
  %idxprom93 = sext i32 %add92 to i64
  %arrayidx94 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom93
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx94, i32 0, i32 0
  %57 = load i32, i32* %start, align 8
  store i32 %57, i32* %subprog_end, align 4
  %58 = load i32, i32* %subprog_end, align 4
  %59 = load i32, i32* %subprog_start, align 4
  %sub = sub i32 %58, %59
  store i32 %sub, i32* %len, align 4
  %60 = load i32, i32* %len, align 4
  %call95 = call i32 @bpf_prog_size(i32 noundef %60) #20
  %call96 = call %struct.bpf_prog* @bpf_prog_alloc_no_stats(i32 noundef %call95, i32 noundef 1051840) #20
  %61 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %62 = load i32, i32* %i, align 4
  %idxprom97 = sext i32 %62 to i64
  %arrayidx98 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %61, i64 %idxprom97
  store %struct.bpf_prog* %call96, %struct.bpf_prog** %arrayidx98, align 8
  %63 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %64 = load i32, i32* %i, align 4
  %idxprom99 = sext i32 %64 to i64
  %arrayidx100 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %63, i64 %idxprom99
  %65 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx100, align 8
  %tobool101 = icmp ne %struct.bpf_prog* %65, null
  br i1 %tobool101, label %if.end103, label %if.then102

if.then102:                                       ; preds = %for.body91
  br label %out_free

if.end103:                                        ; preds = %for.body91
  %66 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %67 = load i32, i32* %i, align 4
  %idxprom104 = sext i32 %67 to i64
  %arrayidx105 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %66, i64 %idxprom104
  %68 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx105, align 8
  %69 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %68, i32 0, i32 12
  %70 = bitcast %union.anon.198* %69 to %struct.anon.201*
  %insnsi106 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %70, i32 0, i32 1
  %arraydecay107 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi106, i64 0, i64 0
  %71 = bitcast %struct.bpf_insn* %arraydecay107 to i8*
  %72 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %73 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %72, i32 0, i32 12
  %74 = bitcast %union.anon.198* %73 to %struct.anon.201*
  %insnsi108 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %74, i32 0, i32 1
  %75 = load i32, i32* %subprog_start, align 4
  %idxprom109 = sext i32 %75 to i64
  %arrayidx110 = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi108, i64 0, i64 %idxprom109
  %76 = bitcast %struct.bpf_insn* %arrayidx110 to i8*
  %77 = load i32, i32* %len, align 4
  %conv111 = sext i32 %77 to i64
  %mul = mul i64 %conv111, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %71, i8* align 8 %76, i64 %mul, i1 false)
  %78 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %78, i32 0, i32 2
  %79 = load i32, i32* %type, align 4
  %80 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %81 = load i32, i32* %i, align 4
  %idxprom112 = sext i32 %81 to i64
  %arrayidx113 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %80, i64 %idxprom112
  %82 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx113, align 8
  %type114 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %82, i32 0, i32 2
  store i32 %79, i32* %type114, align 4
  %83 = load i32, i32* %len, align 4
  %84 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %85 = load i32, i32* %i, align 4
  %idxprom115 = sext i32 %85 to i64
  %arrayidx116 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %84, i64 %idxprom115
  %86 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx116, align 8
  %len117 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %86, i32 0, i32 4
  store i32 %83, i32* %len117, align 4
  %87 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %88 = load i32, i32* %i, align 4
  %idxprom118 = sext i32 %88 to i64
  %arrayidx119 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %87, i64 %idxprom118
  %89 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx119, align 8
  %call120 = call i32 @bpf_prog_calc_tag(%struct.bpf_prog* noundef %89) #20
  %tobool121 = icmp ne i32 %call120, 0
  br i1 %tobool121, label %if.then122, label %if.end123

if.then122:                                       ; preds = %if.end103
  br label %out_free

if.end123:                                        ; preds = %if.end103
  %90 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %91 = load i32, i32* %i, align 4
  %idxprom124 = sext i32 %91 to i64
  %arrayidx125 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %90, i64 %idxprom124
  %92 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx125, align 8
  %is_func = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %92, i32 0, i32 1
  %bf.load = load i16, i16* %is_func, align 2
  %bf.clear = and i16 %bf.load, -129
  %bf.set = or i16 %bf.clear, 128
  store i16 %bf.set, i16* %is_func, align 2
  %93 = load i32, i32* %i, align 4
  %94 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %95 = load i32, i32* %i, align 4
  %idxprom126 = sext i32 %95 to i64
  %arrayidx127 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %94, i64 %idxprom126
  %96 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx127, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %96, i32 0, i32 10
  %97 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_idx = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %97, i32 0, i32 9
  store i32 %93, i32* %func_idx, align 8
  %98 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux128 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %98, i32 0, i32 10
  %99 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux128, align 8
  %btf = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %99, i32 0, i32 50
  %100 = load %struct.btf*, %struct.btf** %btf, align 8
  %101 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %102 = load i32, i32* %i, align 4
  %idxprom129 = sext i32 %102 to i64
  %arrayidx130 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %101, i64 %idxprom129
  %103 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx130, align 8
  %aux131 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %103, i32 0, i32 10
  %104 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux131, align 8
  %btf132 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %104, i32 0, i32 50
  store %struct.btf* %100, %struct.btf** %btf132, align 8
  %105 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux133 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %105, i32 0, i32 10
  %106 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux133, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %106, i32 0, i32 51
  %107 = load %struct.bpf_func_info*, %struct.bpf_func_info** %func_info, align 8
  %108 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %109 = load i32, i32* %i, align 4
  %idxprom134 = sext i32 %109 to i64
  %arrayidx135 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %108, i64 %idxprom134
  %110 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx135, align 8
  %aux136 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %110, i32 0, i32 10
  %111 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux136, align 8
  %func_info137 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %111, i32 0, i32 51
  store %struct.bpf_func_info* %107, %struct.bpf_func_info** %func_info137, align 8
  %112 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux138 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %112, i32 0, i32 10
  %113 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux138, align 8
  %func_info_cnt = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %113, i32 0, i32 55
  %114 = load i32, i32* %func_info_cnt, align 8
  %115 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %116 = load i32, i32* %i, align 4
  %idxprom139 = sext i32 %116 to i64
  %arrayidx140 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %115, i64 %idxprom139
  %117 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx140, align 8
  %aux141 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %117, i32 0, i32 10
  %118 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux141, align 8
  %func_info_cnt142 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %118, i32 0, i32 55
  store i32 %114, i32* %func_info_cnt142, align 8
  %119 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux143 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %119, i32 0, i32 10
  %120 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux143, align 8
  %poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %120, i32 0, i32 32
  %121 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab, align 8
  %122 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %123 = load i32, i32* %i, align 4
  %idxprom144 = sext i32 %123 to i64
  %arrayidx145 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %122, i64 %idxprom144
  %124 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx145, align 8
  %aux146 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %124, i32 0, i32 10
  %125 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux146, align 8
  %poke_tab147 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %125, i32 0, i32 32
  store %struct.bpf_jit_poke_descriptor* %121, %struct.bpf_jit_poke_descriptor** %poke_tab147, align 8
  %126 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux148 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %126, i32 0, i32 10
  %127 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux148, align 8
  %size_poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %127, i32 0, i32 35
  %128 = load i32, i32* %size_poke_tab, align 8
  %129 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %130 = load i32, i32* %i, align 4
  %idxprom149 = sext i32 %130 to i64
  %arrayidx150 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %129, i64 %idxprom149
  %131 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx150, align 8
  %aux151 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %131, i32 0, i32 10
  %132 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux151, align 8
  %size_poke_tab152 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %132, i32 0, i32 35
  store i32 %128, i32* %size_poke_tab152, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond153

for.cond153:                                      ; preds = %for.inc175, %if.end123
  %133 = load i32, i32* %j, align 4
  %134 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux154 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %134, i32 0, i32 10
  %135 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux154, align 8
  %size_poke_tab155 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %135, i32 0, i32 35
  %136 = load i32, i32* %size_poke_tab155, align 8
  %cmp156 = icmp ult i32 %133, %136
  br i1 %cmp156, label %for.body158, label %for.end177

for.body158:                                      ; preds = %for.cond153
  %137 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux159 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %137, i32 0, i32 10
  %138 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux159, align 8
  %poke_tab160 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %138, i32 0, i32 32
  %139 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab160, align 8
  %140 = load i32, i32* %j, align 4
  %idxprom161 = sext i32 %140 to i64
  %arrayidx162 = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %139, i64 %idxprom161
  store %struct.bpf_jit_poke_descriptor* %arrayidx162, %struct.bpf_jit_poke_descriptor** %poke, align 8
  %141 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %141, i32 0, i32 8
  %142 = load i32, i32* %insn_idx, align 4
  %143 = load i32, i32* %subprog_end, align 4
  %cmp163 = icmp ult i32 %142, %143
  br i1 %cmp163, label %land.lhs.true165, label %if.end174

land.lhs.true165:                                 ; preds = %for.body158
  %144 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke, align 8
  %insn_idx166 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %144, i32 0, i32 8
  %145 = load i32, i32* %insn_idx166, align 4
  %146 = load i32, i32* %subprog_start, align 4
  %cmp167 = icmp uge i32 %145, %146
  br i1 %cmp167, label %if.then169, label %if.end174

if.then169:                                       ; preds = %land.lhs.true165
  %147 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %148 = load i32, i32* %i, align 4
  %idxprom170 = sext i32 %148 to i64
  %arrayidx171 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %147, i64 %idxprom170
  %149 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx171, align 8
  %aux172 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %149, i32 0, i32 10
  %150 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux172, align 8
  %151 = bitcast %struct.bpf_prog_aux* %150 to i8*
  %152 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke, align 8
  %aux173 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %152, i32 0, i32 3
  store i8* %151, i8** %aux173, align 8
  br label %if.end174

if.end174:                                        ; preds = %if.then169, %land.lhs.true165, %for.body158
  br label %for.inc175

for.inc175:                                       ; preds = %if.end174
  %153 = load i32, i32* %j, align 4
  %inc176 = add i32 %153, 1
  store i32 %inc176, i32* %j, align 4
  br label %for.cond153, !llvm.loop !184

for.end177:                                       ; preds = %for.cond153
  %154 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %155 = load i32, i32* %i, align 4
  %idxprom178 = sext i32 %155 to i64
  %arrayidx179 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %154, i64 %idxprom178
  %156 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx179, align 8
  %aux180 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %156, i32 0, i32 10
  %157 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux180, align 8
  %name = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %157, i32 0, i32 47
  %arrayidx181 = getelementptr [16 x i8], [16 x i8]* %name, i64 0, i64 0
  store i8 70, i8* %arrayidx181, align 8
  %158 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info182 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %158, i32 0, i32 27
  %159 = load i32, i32* %i, align 4
  %idxprom183 = sext i32 %159 to i64
  %arrayidx184 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info182, i64 0, i64 %idxprom183
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx184, i32 0, i32 2
  %160 = load i16, i16* %stack_depth, align 8
  %conv185 = zext i16 %160 to i32
  %161 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %162 = load i32, i32* %i, align 4
  %idxprom186 = sext i32 %162 to i64
  %arrayidx187 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %161, i64 %idxprom186
  %163 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx187, align 8
  %aux188 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %163, i32 0, i32 10
  %164 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux188, align 8
  %stack_depth189 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %164, i32 0, i32 6
  store i32 %conv185, i32* %stack_depth189, align 4
  %165 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %166 = load i32, i32* %i, align 4
  %idxprom190 = sext i32 %166 to i64
  %arrayidx191 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %165, i64 %idxprom190
  %167 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx191, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %167, i32 0, i32 1
  %bf.load192 = load i16, i16* %jit_requested, align 2
  %bf.clear193 = and i16 %bf.load192, -3
  %bf.set194 = or i16 %bf.clear193, 2
  store i16 %bf.set194, i16* %jit_requested, align 2
  %168 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %blinding_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %168, i32 0, i32 1
  %bf.load195 = load i16, i16* %blinding_requested, align 2
  %bf.lshr = lshr i16 %bf.load195, 5
  %bf.clear196 = and i16 %bf.lshr, 1
  %169 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %170 = load i32, i32* %i, align 4
  %idxprom197 = sext i32 %170 to i64
  %arrayidx198 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %169, i64 %idxprom197
  %171 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx198, align 8
  %blinding_requested199 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %171, i32 0, i32 1
  %bf.load200 = load i16, i16* %blinding_requested199, align 2
  %bf.value = and i16 %bf.clear196, 1
  %bf.shl = shl i16 %bf.value, 5
  %bf.clear201 = and i16 %bf.load200, -33
  %bf.set202 = or i16 %bf.clear201, %bf.shl
  store i16 %bf.set202, i16* %blinding_requested199, align 2
  %172 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux203 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %172, i32 0, i32 10
  %173 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux203, align 8
  %kfunc_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %173, i32 0, i32 33
  %174 = load %struct.bpf_kfunc_desc_tab*, %struct.bpf_kfunc_desc_tab** %kfunc_tab, align 8
  %175 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %176 = load i32, i32* %i, align 4
  %idxprom204 = sext i32 %176 to i64
  %arrayidx205 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %175, i64 %idxprom204
  %177 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx205, align 8
  %aux206 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %177, i32 0, i32 10
  %178 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux206, align 8
  %kfunc_tab207 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %178, i32 0, i32 33
  store %struct.bpf_kfunc_desc_tab* %174, %struct.bpf_kfunc_desc_tab** %kfunc_tab207, align 8
  %179 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux208 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %179, i32 0, i32 10
  %180 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux208, align 8
  %kfunc_btf_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %180, i32 0, i32 34
  %181 = load %struct.bpf_kfunc_btf_tab*, %struct.bpf_kfunc_btf_tab** %kfunc_btf_tab, align 8
  %182 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %183 = load i32, i32* %i, align 4
  %idxprom209 = sext i32 %183 to i64
  %arrayidx210 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %182, i64 %idxprom209
  %184 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx210, align 8
  %aux211 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %184, i32 0, i32 10
  %185 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux211, align 8
  %kfunc_btf_tab212 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %185, i32 0, i32 34
  store %struct.bpf_kfunc_btf_tab* %181, %struct.bpf_kfunc_btf_tab** %kfunc_btf_tab212, align 8
  %186 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux213 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %186, i32 0, i32 10
  %187 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux213, align 8
  %linfo = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %187, i32 0, i32 53
  %188 = load %struct.bpf_line_info*, %struct.bpf_line_info** %linfo, align 8
  %189 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %190 = load i32, i32* %i, align 4
  %idxprom214 = sext i32 %190 to i64
  %arrayidx215 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %189, i64 %idxprom214
  %191 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx215, align 8
  %aux216 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %191, i32 0, i32 10
  %192 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux216, align 8
  %linfo217 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %192, i32 0, i32 53
  store %struct.bpf_line_info* %188, %struct.bpf_line_info** %linfo217, align 8
  %193 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux218 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %193, i32 0, i32 10
  %194 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux218, align 8
  %nr_linfo = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %194, i32 0, i32 56
  %195 = load i32, i32* %nr_linfo, align 4
  %196 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %197 = load i32, i32* %i, align 4
  %idxprom219 = sext i32 %197 to i64
  %arrayidx220 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %196, i64 %idxprom219
  %198 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx220, align 8
  %aux221 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %198, i32 0, i32 10
  %199 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux221, align 8
  %nr_linfo222 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %199, i32 0, i32 56
  store i32 %195, i32* %nr_linfo222, align 4
  %200 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux223 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %200, i32 0, i32 10
  %201 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux223, align 8
  %jited_linfo = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %201, i32 0, i32 54
  %202 = load i8**, i8*** %jited_linfo, align 8
  %203 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %204 = load i32, i32* %i, align 4
  %idxprom224 = sext i32 %204 to i64
  %arrayidx225 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %203, i64 %idxprom224
  %205 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx225, align 8
  %aux226 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %205, i32 0, i32 10
  %206 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux226, align 8
  %jited_linfo227 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %206, i32 0, i32 54
  store i8** %202, i8*** %jited_linfo227, align 8
  %207 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info228 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %207, i32 0, i32 27
  %208 = load i32, i32* %i, align 4
  %idxprom229 = sext i32 %208 to i64
  %arrayidx230 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info228, i64 0, i64 %idxprom229
  %linfo_idx = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx230, i32 0, i32 1
  %209 = load i32, i32* %linfo_idx, align 4
  %210 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %211 = load i32, i32* %i, align 4
  %idxprom231 = sext i32 %211 to i64
  %arrayidx232 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %210, i64 %idxprom231
  %212 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx232, align 8
  %aux233 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %212, i32 0, i32 10
  %213 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux233, align 8
  %linfo_idx234 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %213, i32 0, i32 57
  store i32 %209, i32* %linfo_idx234, align 8
  store i32 0, i32* %num_exentries, align 4
  %214 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %215 = load i32, i32* %i, align 4
  %idxprom235 = sext i32 %215 to i64
  %arrayidx236 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %214, i64 %idxprom235
  %216 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx236, align 8
  %217 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %216, i32 0, i32 12
  %218 = bitcast %union.anon.198* %217 to %struct.anon.201*
  %insnsi237 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %218, i32 0, i32 1
  %arraydecay238 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi237, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay238, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond239

for.cond239:                                      ; preds = %for.inc258, %for.end177
  %219 = load i32, i32* %j, align 4
  %220 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %221 = load i32, i32* %i, align 4
  %idxprom240 = sext i32 %221 to i64
  %arrayidx241 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %220, i64 %idxprom240
  %222 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx241, align 8
  %len242 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %222, i32 0, i32 4
  %223 = load i32, i32* %len242, align 4
  %cmp243 = icmp ult i32 %219, %223
  br i1 %cmp243, label %for.body245, label %for.end261

for.body245:                                      ; preds = %for.cond239
  %224 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %224, i32 0, i32 0
  %225 = load i8, i8* %code, align 4
  %conv246 = zext i8 %225 to i32
  %and = and i32 %conv246, 7
  %cmp247 = icmp eq i32 %and, 1
  br i1 %cmp247, label %land.lhs.true249, label %if.end257

land.lhs.true249:                                 ; preds = %for.body245
  %226 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code250 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %226, i32 0, i32 0
  %227 = load i8, i8* %code250, align 4
  %conv251 = zext i8 %227 to i32
  %and252 = and i32 %conv251, 224
  %cmp253 = icmp eq i32 %and252, 32
  br i1 %cmp253, label %if.then255, label %if.end257

if.then255:                                       ; preds = %land.lhs.true249
  %228 = load i32, i32* %num_exentries, align 4
  %inc256 = add i32 %228, 1
  store i32 %inc256, i32* %num_exentries, align 4
  br label %if.end257

if.end257:                                        ; preds = %if.then255, %land.lhs.true249, %for.body245
  br label %for.inc258

for.inc258:                                       ; preds = %if.end257
  %229 = load i32, i32* %j, align 4
  %inc259 = add i32 %229, 1
  store i32 %inc259, i32* %j, align 4
  %230 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr260 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %230, i32 1
  store %struct.bpf_insn* %incdec.ptr260, %struct.bpf_insn** %insn, align 8
  br label %for.cond239, !llvm.loop !185

for.end261:                                       ; preds = %for.cond239
  %231 = load i32, i32* %num_exentries, align 4
  %232 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %233 = load i32, i32* %i, align 4
  %idxprom262 = sext i32 %233 to i64
  %arrayidx263 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %232, i64 %idxprom262
  %234 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx263, align 8
  %aux264 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %234, i32 0, i32 10
  %235 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux264, align 8
  %num_exentries265 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %235, i32 0, i32 58
  store i32 %231, i32* %num_exentries265, align 4
  %236 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info266 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %236, i32 0, i32 27
  %237 = load i32, i32* %i, align 4
  %idxprom267 = sext i32 %237 to i64
  %arrayidx268 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info266, i64 0, i64 %idxprom267
  %tail_call_reachable = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx268, i32 0, i32 4
  %238 = load i8, i8* %tail_call_reachable, align 1
  %tobool269 = trunc i8 %238 to i1
  %239 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %240 = load i32, i32* %i, align 4
  %idxprom270 = sext i32 %240 to i64
  %arrayidx271 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %239, i64 %idxprom270
  %241 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx271, align 8
  %aux272 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %241, i32 0, i32 10
  %242 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux272, align 8
  %tail_call_reachable273 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %242, i32 0, i32 26
  %frombool274 = zext i1 %tobool269 to i8
  store i8 %frombool274, i8* %tail_call_reachable273, align 1
  %243 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %244 = load i32, i32* %i, align 4
  %idxprom275 = sext i32 %244 to i64
  %arrayidx276 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %243, i64 %idxprom275
  %245 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx276, align 8
  %call277 = call %struct.bpf_prog* @bpf_int_jit_compile(%struct.bpf_prog* noundef %245) #20
  %246 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %247 = load i32, i32* %i, align 4
  %idxprom278 = sext i32 %247 to i64
  %arrayidx279 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %246, i64 %idxprom278
  store %struct.bpf_prog* %call277, %struct.bpf_prog** %arrayidx279, align 8
  %248 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %249 = load i32, i32* %i, align 4
  %idxprom280 = sext i32 %249 to i64
  %arrayidx281 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %248, i64 %idxprom280
  %250 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx281, align 8
  %jited = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %250, i32 0, i32 1
  %bf.load282 = load i16, i16* %jited, align 2
  %bf.clear283 = and i16 %bf.load282, 1
  %tobool284 = icmp ne i16 %bf.clear283, 0
  br i1 %tobool284, label %if.end286, label %if.then285

if.then285:                                       ; preds = %for.end261
  store i32 -524, i32* %err, align 4
  br label %out_free

if.end286:                                        ; preds = %for.end261
  call void @__might_resched(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 noundef 15659, i32 noundef 0) #20
  store i32 ()* @__SCT__cond_resched, i32 ()** %tmp.i503, align 8
  %251 = load i32 ()*, i32 ()** %tmp.i503, align 8
  %call.i504 = call i32 %251() #22
  store i32 %call.i504, i32* %tmp287, align 4
  %252 = load i32, i32* %tmp287, align 4
  br label %for.inc289

for.inc289:                                       ; preds = %if.end286
  %253 = load i32, i32* %i, align 4
  %inc290 = add i32 %253, 1
  store i32 %inc290, i32* %i, align 4
  br label %for.cond87, !llvm.loop !186

for.end291:                                       ; preds = %for.cond87
  store i32 0, i32* %i, align 4
  br label %for.cond292

for.cond292:                                      ; preds = %for.inc346, %for.end291
  %254 = load i32, i32* %i, align 4
  %255 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt293 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %255, i32 0, i32 31
  %256 = load i32, i32* %subprog_cnt293, align 4
  %cmp294 = icmp ult i32 %254, %256
  br i1 %cmp294, label %for.body296, label %for.end348

for.body296:                                      ; preds = %for.cond292
  %257 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %258 = load i32, i32* %i, align 4
  %idxprom297 = sext i32 %258 to i64
  %arrayidx298 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %257, i64 %idxprom297
  %259 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx298, align 8
  %260 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %259, i32 0, i32 12
  %261 = bitcast %union.anon.198* %260 to %struct.anon.201*
  %insnsi299 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %261, i32 0, i32 1
  %arraydecay300 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi299, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay300, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond301

for.cond301:                                      ; preds = %for.inc334, %for.body296
  %262 = load i32, i32* %j, align 4
  %263 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %264 = load i32, i32* %i, align 4
  %idxprom302 = sext i32 %264 to i64
  %arrayidx303 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %263, i64 %idxprom302
  %265 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx303, align 8
  %len304 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %265, i32 0, i32 4
  %266 = load i32, i32* %len304, align 4
  %cmp305 = icmp ult i32 %262, %266
  br i1 %cmp305, label %for.body307, label %for.end337

for.body307:                                      ; preds = %for.cond301
  %267 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call308 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %267) #20
  br i1 %call308, label %if.then309, label %if.end323

if.then309:                                       ; preds = %for.body307
  %268 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off310 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %268, i32 0, i32 2
  %269 = load i16, i16* %off310, align 2
  %conv311 = sext i16 %269 to i32
  store i32 %conv311, i32* %subprog, align 4
  %270 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %271 = load i32, i32* %subprog, align 4
  %idxprom312 = sext i32 %271 to i64
  %arrayidx313 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %270, i64 %idxprom312
  %272 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx313, align 8
  %bpf_func = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %272, i32 0, i32 9
  %273 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func, align 8
  %274 = ptrtoint i32 (i8*, %struct.bpf_insn*)* %273 to i64
  %conv314 = trunc i64 %274 to i32
  %275 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx315 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %275, i64 0
  %imm316 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx315, i32 0, i32 3
  store i32 %conv314, i32* %imm316, align 4
  %276 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %277 = load i32, i32* %subprog, align 4
  %idxprom317 = sext i32 %277 to i64
  %arrayidx318 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %276, i64 %idxprom317
  %278 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx318, align 8
  %bpf_func319 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %278, i32 0, i32 9
  %279 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func319, align 8
  %280 = ptrtoint i32 (i8*, %struct.bpf_insn*)* %279 to i64
  %shr = lshr i64 %280, 32
  %conv320 = trunc i64 %shr to i32
  %281 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx321 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %281, i64 1
  %imm322 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx321, i32 0, i32 3
  store i32 %conv320, i32* %imm322, align 4
  br label %for.inc334

if.end323:                                        ; preds = %for.body307
  %282 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call324 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %282) #20
  br i1 %call324, label %if.end326, label %if.then325

if.then325:                                       ; preds = %if.end323
  br label %for.inc334

if.end326:                                        ; preds = %if.end323
  %283 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off327 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %283, i32 0, i32 2
  %284 = load i16, i16* %off327, align 2
  %conv328 = sext i16 %284 to i32
  store i32 %conv328, i32* %subprog, align 4
  %285 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %286 = load i32, i32* %subprog, align 4
  %idxprom329 = sext i32 %286 to i64
  %arrayidx330 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %285, i64 %idxprom329
  %287 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx330, align 8
  %bpf_func331 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %287, i32 0, i32 9
  %288 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func331, align 8
  %289 = bitcast i32 (i8*, %struct.bpf_insn*)* %288 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %289 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv332 = trunc i64 %sub.ptr.sub to i32
  %290 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm333 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %290, i32 0, i32 3
  store i32 %conv332, i32* %imm333, align 4
  br label %for.inc334

for.inc334:                                       ; preds = %if.end326, %if.then325, %if.then309
  %291 = load i32, i32* %j, align 4
  %inc335 = add i32 %291, 1
  store i32 %inc335, i32* %j, align 4
  %292 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr336 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %292, i32 1
  store %struct.bpf_insn* %incdec.ptr336, %struct.bpf_insn** %insn, align 8
  br label %for.cond301, !llvm.loop !187

for.end337:                                       ; preds = %for.cond301
  %293 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %294 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %295 = load i32, i32* %i, align 4
  %idxprom338 = sext i32 %295 to i64
  %arrayidx339 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %294, i64 %idxprom338
  %296 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx339, align 8
  %aux340 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %296, i32 0, i32 10
  %297 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux340, align 8
  %func341 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %297, i32 0, i32 30
  store %struct.bpf_prog** %293, %struct.bpf_prog*** %func341, align 8
  %298 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt342 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %298, i32 0, i32 31
  %299 = load i32, i32* %subprog_cnt342, align 4
  %300 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %301 = load i32, i32* %i, align 4
  %idxprom343 = sext i32 %301 to i64
  %arrayidx344 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %300, i64 %idxprom343
  %302 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx344, align 8
  %aux345 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %302, i32 0, i32 10
  %303 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux345, align 8
  %func_cnt = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %303, i32 0, i32 8
  store i32 %299, i32* %func_cnt, align 4
  br label %for.inc346

for.inc346:                                       ; preds = %for.end337
  %304 = load i32, i32* %i, align 4
  %inc347 = add i32 %304, 1
  store i32 %inc347, i32* %i, align 4
  br label %for.cond292, !llvm.loop !188

for.end348:                                       ; preds = %for.cond292
  store i32 0, i32* %i, align 4
  br label %for.cond349

for.cond349:                                      ; preds = %for.inc373, %for.end348
  %305 = load i32, i32* %i, align 4
  %306 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt350 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %306, i32 0, i32 31
  %307 = load i32, i32* %subprog_cnt350, align 4
  %cmp351 = icmp ult i32 %305, %307
  br i1 %cmp351, label %for.body353, label %for.end375

for.body353:                                      ; preds = %for.cond349
  %308 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %309 = load i32, i32* %i, align 4
  %idxprom354 = sext i32 %309 to i64
  %arrayidx355 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %308, i64 %idxprom354
  %310 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx355, align 8
  %bpf_func356 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %310, i32 0, i32 9
  %311 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func356, align 8
  %312 = bitcast i32 (i8*, %struct.bpf_insn*)* %311 to i8*
  store i8* %312, i8** %old_bpf_func, align 8
  %313 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %314 = load i32, i32* %i, align 4
  %idxprom357 = sext i32 %314 to i64
  %arrayidx358 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %313, i64 %idxprom357
  %315 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx358, align 8
  %call359 = call %struct.bpf_prog* @bpf_int_jit_compile(%struct.bpf_prog* noundef %315) #20
  store %struct.bpf_prog* %call359, %struct.bpf_prog** %tmp, align 8
  %316 = load %struct.bpf_prog*, %struct.bpf_prog** %tmp, align 8
  %317 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %318 = load i32, i32* %i, align 4
  %idxprom360 = sext i32 %318 to i64
  %arrayidx361 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %317, i64 %idxprom360
  %319 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx361, align 8
  %cmp362 = icmp ne %struct.bpf_prog* %316, %319
  br i1 %cmp362, label %if.then369, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body353
  %320 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %321 = load i32, i32* %i, align 4
  %idxprom364 = sext i32 %321 to i64
  %arrayidx365 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %320, i64 %idxprom364
  %322 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx365, align 8
  %bpf_func366 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %322, i32 0, i32 9
  %323 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func366, align 8
  %324 = load i8*, i8** %old_bpf_func, align 8
  %325 = bitcast i8* %324 to i32 (i8*, %struct.bpf_insn*)*
  %cmp367 = icmp ne i32 (i8*, %struct.bpf_insn*)* %323, %325
  br i1 %cmp367, label %if.then369, label %if.end370

if.then369:                                       ; preds = %lor.lhs.false, %for.body353
  %326 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %327 = bitcast %struct.bpf_verifier_env* %326 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %327, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.508, i64 0, i64 0)) #20
  store i32 -524, i32* %err, align 4
  br label %out_free

if.end370:                                        ; preds = %lor.lhs.false
  call void @__might_resched(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 noundef 15703, i32 noundef 0) #20
  store i32 ()* @__SCT__cond_resched, i32 ()** %tmp.i, align 8
  %328 = load i32 ()*, i32 ()** %tmp.i, align 8
  %call.i = call i32 %328() #22
  store i32 %call.i, i32* %tmp371, align 4
  %329 = load i32, i32* %tmp371, align 4
  br label %for.inc373

for.inc373:                                       ; preds = %if.end370
  %330 = load i32, i32* %i, align 4
  %inc374 = add i32 %330, 1
  store i32 %inc374, i32* %i, align 4
  br label %for.cond349, !llvm.loop !189

for.end375:                                       ; preds = %for.cond349
  store i32 0, i32* %i, align 4
  br label %for.cond376

for.cond376:                                      ; preds = %for.inc385, %for.end375
  %331 = load i32, i32* %i, align 4
  %332 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt377 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %332, i32 0, i32 31
  %333 = load i32, i32* %subprog_cnt377, align 4
  %cmp378 = icmp ult i32 %331, %333
  br i1 %cmp378, label %for.body380, label %for.end387

for.body380:                                      ; preds = %for.cond376
  %334 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %335 = load i32, i32* %i, align 4
  %idxprom381 = sext i32 %335 to i64
  %arrayidx382 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %334, i64 %idxprom381
  %336 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx382, align 8
  call void @bpf_prog_lock_ro(%struct.bpf_prog* noundef %336) #20
  %337 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %338 = load i32, i32* %i, align 4
  %idxprom383 = sext i32 %338 to i64
  %arrayidx384 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %337, i64 %idxprom383
  %339 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx384, align 8
  call void @bpf_prog_kallsyms_add(%struct.bpf_prog* noundef %339) #20
  br label %for.inc385

for.inc385:                                       ; preds = %for.body380
  %340 = load i32, i32* %i, align 4
  %inc386 = add i32 %340, 1
  store i32 %inc386, i32* %i, align 4
  br label %for.cond376, !llvm.loop !190

for.end387:                                       ; preds = %for.cond376
  store i32 0, i32* %i, align 4
  %341 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %342 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %341, i32 0, i32 12
  %343 = bitcast %union.anon.198* %342 to %struct.anon.201*
  %insnsi388 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %343, i32 0, i32 1
  %arraydecay389 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi388, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay389, %struct.bpf_insn** %insn, align 8
  br label %for.cond390

for.cond390:                                      ; preds = %for.inc424, %for.end387
  %344 = load i32, i32* %i, align 4
  %345 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len391 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %345, i32 0, i32 4
  %346 = load i32, i32* %len391, align 4
  %cmp392 = icmp ult i32 %344, %346
  br i1 %cmp392, label %for.body394, label %for.end427

for.body394:                                      ; preds = %for.cond390
  %347 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call395 = call zeroext i1 @bpf_pseudo_func(%struct.bpf_insn* noundef %347) #20
  br i1 %call395, label %if.then396, label %if.end408

if.then396:                                       ; preds = %for.body394
  %348 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data397 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %348, i32 0, i32 24
  %349 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data397, align 8
  %350 = load i32, i32* %i, align 4
  %idxprom398 = sext i32 %350 to i64
  %arrayidx399 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %349, i64 %idxprom398
  %351 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx399, i32 0, i32 0
  %call_imm400 = bitcast %union.anon.210* %351 to i32*
  %352 = load i32, i32* %call_imm400, align 8
  %353 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx401 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %353, i64 0
  %imm402 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx401, i32 0, i32 3
  store i32 %352, i32* %imm402, align 4
  %354 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off403 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %354, i32 0, i32 2
  %355 = load i16, i16* %off403, align 2
  %conv404 = sext i16 %355 to i32
  %356 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx405 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %356, i64 1
  %imm406 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx405, i32 0, i32 3
  store i32 %conv404, i32* %imm406, align 4
  %357 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off407 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %357, i32 0, i32 2
  store i16 0, i16* %off407, align 2
  br label %for.inc424

if.end408:                                        ; preds = %for.body394
  %358 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call409 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %358) #20
  br i1 %call409, label %if.end411, label %if.then410

if.then410:                                       ; preds = %if.end408
  br label %for.inc424

if.end411:                                        ; preds = %if.end408
  %359 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data412 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %359, i32 0, i32 24
  %360 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data412, align 8
  %361 = load i32, i32* %i, align 4
  %idxprom413 = sext i32 %361 to i64
  %arrayidx414 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %360, i64 %idxprom413
  %362 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx414, i32 0, i32 0
  %call_imm415 = bitcast %union.anon.210* %362 to i32*
  %363 = load i32, i32* %call_imm415, align 8
  %conv416 = trunc i32 %363 to i16
  %364 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off417 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %364, i32 0, i32 2
  store i16 %conv416, i16* %off417, align 2
  %365 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %366 = load i32, i32* %i, align 4
  %367 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off418 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %367, i32 0, i32 2
  %368 = load i16, i16* %off418, align 2
  %conv419 = sext i16 %368 to i32
  %add420 = add i32 %366, %conv419
  %add421 = add i32 %add420, 1
  %call422 = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %365, i32 noundef %add421) #20
  store i32 %call422, i32* %subprog, align 4
  %369 = load i32, i32* %subprog, align 4
  %370 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm423 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %370, i32 0, i32 3
  store i32 %369, i32* %imm423, align 4
  br label %for.inc424

for.inc424:                                       ; preds = %if.end411, %if.then410, %if.then396
  %371 = load i32, i32* %i, align 4
  %inc425 = add i32 %371, 1
  store i32 %inc425, i32* %i, align 4
  %372 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr426 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %372, i32 1
  store %struct.bpf_insn* %incdec.ptr426, %struct.bpf_insn** %insn, align 8
  br label %for.cond390, !llvm.loop !191

for.end427:                                       ; preds = %for.cond390
  %373 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jited428 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %373, i32 0, i32 1
  %bf.load429 = load i16, i16* %jited428, align 2
  %bf.clear430 = and i16 %bf.load429, -2
  %bf.set431 = or i16 %bf.clear430, 1
  store i16 %bf.set431, i16* %jited428, align 2
  %374 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %arrayidx432 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %374, i64 0
  %375 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx432, align 8
  %bpf_func433 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %375, i32 0, i32 9
  %376 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func433, align 8
  %377 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %bpf_func434 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %377, i32 0, i32 9
  store i32 (i8*, %struct.bpf_insn*)* %376, i32 (i8*, %struct.bpf_insn*)** %bpf_func434, align 8
  %378 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %arrayidx435 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %378, i64 0
  %379 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx435, align 8
  %jited_len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %379, i32 0, i32 5
  %380 = load i32, i32* %jited_len, align 8
  %381 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jited_len436 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %381, i32 0, i32 5
  store i32 %380, i32* %jited_len436, align 8
  %382 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %383 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux437 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %383, i32 0, i32 10
  %384 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux437, align 8
  %func438 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %384, i32 0, i32 30
  store %struct.bpf_prog** %382, %struct.bpf_prog*** %func438, align 8
  %385 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt439 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %385, i32 0, i32 31
  %386 = load i32, i32* %subprog_cnt439, align 4
  %387 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux440 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %387, i32 0, i32 10
  %388 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux440, align 8
  %func_cnt441 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %388, i32 0, i32 8
  store i32 %386, i32* %func_cnt441, align 4
  %389 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  call void @bpf_prog_jit_attempt_done(%struct.bpf_prog* noundef %389) #20
  store i32 0, i32* %retval, align 4
  br label %return

out_free:                                         ; preds = %if.then369, %if.then285, %if.then122, %if.then102
  store i32 0, i32* %i, align 4
  br label %for.cond442

for.cond442:                                      ; preds = %for.inc453, %out_free
  %390 = load i32, i32* %i, align 4
  %391 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux443 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %391, i32 0, i32 10
  %392 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux443, align 8
  %size_poke_tab444 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %392, i32 0, i32 35
  %393 = load i32, i32* %size_poke_tab444, align 8
  %cmp445 = icmp ult i32 %390, %393
  br i1 %cmp445, label %for.body447, label %for.end455

for.body447:                                      ; preds = %for.cond442
  %394 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux448 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %394, i32 0, i32 10
  %395 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux448, align 8
  %poke_tab449 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %395, i32 0, i32 32
  %396 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab449, align 8
  %397 = load i32, i32* %i, align 4
  %idxprom450 = sext i32 %397 to i64
  %arrayidx451 = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %396, i64 %idxprom450
  %398 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %arrayidx451, i32 0, i32 4
  %tail_call = bitcast %union.anon.138* %398 to %struct.anon.139*
  %map = getelementptr inbounds %struct.anon.139, %struct.anon.139* %tail_call, i32 0, i32 0
  %399 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  store %struct.bpf_map* %399, %struct.bpf_map** %map_ptr, align 8
  %400 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %400, i32 0, i32 0
  %401 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_poke_untrack = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %401, i32 0, i32 26
  %402 = load void (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_untrack, align 8
  %403 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %404 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux452 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %404, i32 0, i32 10
  %405 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux452, align 8
  call void %402(%struct.bpf_map* noundef %403, %struct.bpf_prog_aux* noundef %405) #20
  br label %for.inc453

for.inc453:                                       ; preds = %for.body447
  %406 = load i32, i32* %i, align 4
  %inc454 = add i32 %406, 1
  store i32 %inc454, i32* %i, align 4
  br label %for.cond442, !llvm.loop !192

for.end455:                                       ; preds = %for.cond442
  store i32 0, i32* %i, align 4
  br label %for.cond456

for.cond456:                                      ; preds = %for.inc472, %for.end455
  %407 = load i32, i32* %i, align 4
  %408 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt457 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %408, i32 0, i32 31
  %409 = load i32, i32* %subprog_cnt457, align 4
  %cmp458 = icmp ult i32 %407, %409
  br i1 %cmp458, label %for.body460, label %for.end474

for.body460:                                      ; preds = %for.cond456
  %410 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %411 = load i32, i32* %i, align 4
  %idxprom461 = sext i32 %411 to i64
  %arrayidx462 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %410, i64 %idxprom461
  %412 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx462, align 8
  %tobool463 = icmp ne %struct.bpf_prog* %412, null
  br i1 %tobool463, label %if.end465, label %if.then464

if.then464:                                       ; preds = %for.body460
  br label %for.inc472

if.end465:                                        ; preds = %for.body460
  %413 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %414 = load i32, i32* %i, align 4
  %idxprom466 = sext i32 %414 to i64
  %arrayidx467 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %413, i64 %idxprom466
  %415 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx467, align 8
  %aux468 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %415, i32 0, i32 10
  %416 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux468, align 8
  %poke_tab469 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %416, i32 0, i32 32
  store %struct.bpf_jit_poke_descriptor* null, %struct.bpf_jit_poke_descriptor** %poke_tab469, align 8
  %417 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %418 = load i32, i32* %i, align 4
  %idxprom470 = sext i32 %418 to i64
  %arrayidx471 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %417, i64 %idxprom470
  %419 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx471, align 8
  call void @bpf_jit_free(%struct.bpf_prog* noundef %419) #20
  br label %for.inc472

for.inc472:                                       ; preds = %if.end465, %if.then464
  %420 = load i32, i32* %i, align 4
  %inc473 = add i32 %420, 1
  store i32 %inc473, i32* %i, align 4
  br label %for.cond456, !llvm.loop !193

for.end474:                                       ; preds = %for.cond456
  %421 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %422 = bitcast %struct.bpf_prog** %421 to i8*
  call void @kfree(i8* noundef %422) #20
  br label %out_undo_insn

out_undo_insn:                                    ; preds = %for.end474, %if.then85, %if.then79
  %423 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested475 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %423, i32 0, i32 1
  %bf.load476 = load i16, i16* %jit_requested475, align 2
  %bf.clear477 = and i16 %bf.load476, -3
  %bf.set478 = or i16 %bf.clear477, 0
  store i16 %bf.set478, i16* %jit_requested475, align 2
  %424 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %blinding_requested479 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %424, i32 0, i32 1
  %bf.load480 = load i16, i16* %blinding_requested479, align 2
  %bf.clear481 = and i16 %bf.load480, -33
  %bf.set482 = or i16 %bf.clear481, 0
  store i16 %bf.set482, i16* %blinding_requested479, align 2
  store i32 0, i32* %i, align 4
  %425 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %426 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %425, i32 0, i32 12
  %427 = bitcast %union.anon.198* %426 to %struct.anon.201*
  %insnsi483 = getelementptr inbounds %struct.anon.201, %struct.anon.201* %427, i32 0, i32 1
  %arraydecay484 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi483, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay484, %struct.bpf_insn** %insn, align 8
  br label %for.cond485

for.cond485:                                      ; preds = %for.inc499, %out_undo_insn
  %428 = load i32, i32* %i, align 4
  %429 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len486 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %429, i32 0, i32 4
  %430 = load i32, i32* %len486, align 4
  %cmp487 = icmp ult i32 %428, %430
  br i1 %cmp487, label %for.body489, label %for.end502

for.body489:                                      ; preds = %for.cond485
  %431 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call490 = call zeroext i1 @bpf_pseudo_call(%struct.bpf_insn* noundef %431) #20
  br i1 %call490, label %if.end492, label %if.then491

if.then491:                                       ; preds = %for.body489
  br label %for.inc499

if.end492:                                        ; preds = %for.body489
  %432 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off493 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %432, i32 0, i32 2
  store i16 0, i16* %off493, align 2
  %433 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data494 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %433, i32 0, i32 24
  %434 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data494, align 8
  %435 = load i32, i32* %i, align 4
  %idxprom495 = sext i32 %435 to i64
  %arrayidx496 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %434, i64 %idxprom495
  %436 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx496, i32 0, i32 0
  %call_imm497 = bitcast %union.anon.210* %436 to i32*
  %437 = load i32, i32* %call_imm497, align 8
  %438 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm498 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %438, i32 0, i32 3
  store i32 %437, i32* %imm498, align 4
  br label %for.inc499

for.inc499:                                       ; preds = %if.end492, %if.then491
  %439 = load i32, i32* %i, align 4
  %inc500 = add i32 %439, 1
  store i32 %inc500, i32* %i, align 4
  %440 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr501 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %440, i32 1
  store %struct.bpf_insn* %incdec.ptr501, %struct.bpf_insn** %insn, align 8
  br label %for.cond485, !llvm.loop !194

for.end502:                                       ; preds = %for.cond485
  %441 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  call void @bpf_prog_jit_attempt_done(%struct.bpf_prog* noundef %441) #20
  %442 = load i32, i32* %err, align 4
  store i32 %442, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end502, %for.end427, %if.end60, %if.then
  %443 = load i32, i32* %retval, align 4
  ret i32 %443
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @get_callee_stack_depth(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32 noundef %idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %idx.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %subprog = alloca i32, align 4
  %__ret_do_once = alloca i8, align 1
  %__ret_cond = alloca i8, align 1
  %__ret_once = alloca i8, align 1
  %tmp = alloca i64, align 8
  %__ret_warn_on = alloca i32, align 4
  %__flags = alloca i32, align 4
  %tmp39 = alloca i64, align 8
  %tmp47 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load i32, i32* %idx.addr, align 4
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 3
  %2 = load i32, i32* %imm, align 4
  %add = add i32 %0, %2
  %add1 = add i32 %add, 1
  store i32 %add1, i32* %start, align 4
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = load i32, i32* %start, align 4
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %3, i32 noundef %4) #20
  store i32 %call, i32* %subprog, align 4
  %5 = load i32, i32* %subprog, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end54

if.then:                                          ; preds = %entry
  store i8 1, i8* %__ret_do_once, align 1
  %6 = load i8, i8* %__ret_do_once, align 1
  %tobool = trunc i8 %6 to i1
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %frombool = zext i1 %lnot2 to i8
  store i8 %frombool, i8* %__ret_cond, align 1
  store i8 0, i8* %__ret_once, align 1
  %7 = load i8, i8* %__ret_cond, align 1
  %tobool3 = trunc i8 %7 to i1
  br i1 %tobool3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then
  %8 = load i8, i8* @get_callee_stack_depth.__already_done, align 1
  %tobool4 = trunc i8 %8 to i1
  %lnot5 = xor i1 %tobool4, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then
  %9 = phi i1 [ false, %if.then ], [ %lnot5, %land.rhs ]
  %lnot6 = xor i1 %9, true
  %lnot7 = xor i1 %lnot6, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool8 = icmp ne i64 %conv, 0
  br i1 %tobool8, label %if.then9, label %if.end

if.then9:                                         ; preds = %land.end
  store i8 1, i8* @get_callee_stack_depth.__already_done, align 1
  store i8 1, i8* %__ret_once, align 1
  br label %if.end

if.end:                                           ; preds = %if.then9, %land.end
  %10 = load i8, i8* %__ret_once, align 1
  %tobool10 = trunc i8 %10 to i1
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  store i64 %conv15, i64* %tmp, align 8
  %11 = load i64, i64* %tmp, align 8
  %tobool16 = icmp ne i64 %11, 0
  br i1 %tobool16, label %if.then17, label %if.end46

if.then17:                                        ; preds = %if.end
  store i32 1, i32* %__ret_warn_on, align 4
  %12 = load i32, i32* %__ret_warn_on, align 4
  %tobool18 = icmp ne i32 %12, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %tobool24 = icmp ne i64 %conv23, 0
  br i1 %tobool24, label %if.then25, label %if.end38

if.then25:                                        ; preds = %if.then17
  br label %do.body

do.body:                                          ; preds = %if.then25
  br label %do.body26

do.body26:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body26
  %13 = load i32, i32* %start, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.350, i64 0, i64 0), i32 noundef %13) #20
  br label %do.body27

do.body27:                                        ; preds = %do.end
  store i32 2313, i32* %__flags, align 4
  br label %do.body28

do.body28:                                        ; preds = %do.body27
  br label %do.end29

do.end29:                                         ; preds = %do.body28
  br label %do.body30

do.body30:                                        ; preds = %do.end29
  %14 = load i32, i32* %__flags, align 4
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - .\09# bug_entry::bug_addr\0A\09.long ${0:c} - .\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection\0A998:\0A\09.pushsection .discard.reachable\0A\09.long 998b - .\0A\09.popsection\0A\09", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 4439, i32 %14, i64 12) #19, !srcloc !195
  br label %do.end31

do.end31:                                         ; preds = %do.body30
  br label %do.body32

do.body32:                                        ; preds = %do.end31
  br label %do.end33

do.end33:                                         ; preds = %do.body32
  br label %do.end34

do.end34:                                         ; preds = %do.end33
  br label %do.body35

do.body35:                                        ; preds = %do.end34
  br label %do.end36

do.end36:                                         ; preds = %do.body35
  br label %do.end37

do.end37:                                         ; preds = %do.end36
  br label %if.end38

if.end38:                                         ; preds = %do.end37, %if.then17
  %15 = load i32, i32* %__ret_warn_on, align 4
  %tobool40 = icmp ne i32 %15, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  store i64 %conv45, i64* %tmp39, align 8
  %16 = load i64, i64* %tmp39, align 8
  br label %if.end46

if.end46:                                         ; preds = %if.end38, %if.end
  %17 = load i8, i8* %__ret_do_once, align 1
  %tobool48 = trunc i8 %17 to i1
  %lnot49 = xor i1 %tobool48, true
  %lnot51 = xor i1 %lnot49, true
  %lnot.ext52 = zext i1 %lnot51 to i32
  %conv53 = sext i32 %lnot.ext52 to i64
  store i64 %conv53, i64* %tmp47, align 8
  %18 = load i64, i64* %tmp47, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %entry
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 27
  %20 = load i32, i32* %subprog, align 4
  %idxprom = sext i32 %20 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %21 = load i16, i16* %stack_depth, align 8
  %conv55 = zext i16 %21 to i32
  store i32 %conv55, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end54, %if.end46
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_patch_call_args(%struct.bpf_insn* noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_alloc_jited_linfo(%struct.bpf_prog* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_prog* @bpf_prog_alloc_no_stats(i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_prog_size(i32 noundef %proglen) #0 {
entry:
  %proglen.addr = alloca i32, align 4
  %__UNIQUE_ID___x502 = alloca i64, align 8
  %__UNIQUE_ID___y503 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store i32 %proglen, i32* %proglen.addr, align 4
  store i64 72, i64* %__UNIQUE_ID___x502, align 8
  %0 = load i32, i32* %proglen.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = mul i64 %conv, 8
  %2 = add i64 72, %1
  store i64 %2, i64* %__UNIQUE_ID___y503, align 8
  %3 = load i64, i64* %__UNIQUE_ID___x502, align 8
  %4 = load i64, i64* %__UNIQUE_ID___y503, align 8
  %cmp = icmp ugt i64 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, i64* %__UNIQUE_ID___x502, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, i64* %__UNIQUE_ID___y503, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %6, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %7 = load i64, i64* %tmp, align 8
  %conv2 = trunc i64 %7 to i32
  ret i32 %conv2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_prog* @bpf_int_jit_compile(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_prog_lock_ro(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %jited = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 1
  %bf.load = load i16, i16* %jited, align 2
  %bf.clear = and i16 %bf.load, 1
  %tobool = icmp ne i16 %bf.clear, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %2 = bitcast %struct.bpf_prog* %1 to i8*
  call void @set_vm_flush_reset_perms(i8* noundef %2) #20
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %4 = ptrtoint %struct.bpf_prog* %3 to i64
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %pages = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 0
  %6 = load i16, i16* %pages, align 8
  %conv = zext i16 %6 to i32
  %call = call i32 @set_memory_ro(i64 noundef %4, i32 noundef %conv) #20
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_prog_kallsyms_add(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_jit_attempt_done(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_jit_free(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  call void @bpf_prog_unlock_free(%struct.bpf_prog* noundef %0) #20
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @set_vm_flush_reset_perms(i8* noundef %addr) #0 {
entry:
  %addr.addr = alloca i8*, align 8
  %vm = alloca %struct.vm_struct*, align 8
  store i8* %addr, i8** %addr.addr, align 8
  %0 = load i8*, i8** %addr.addr, align 8
  %call = call %struct.vm_struct* @find_vm_area(i8* noundef %0) #20
  store %struct.vm_struct* %call, %struct.vm_struct** %vm, align 8
  %1 = load %struct.vm_struct*, %struct.vm_struct** %vm, align 8
  %tobool = icmp ne %struct.vm_struct* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.vm_struct*, %struct.vm_struct** %vm, align 8
  %flags = getelementptr inbounds %struct.vm_struct, %struct.vm_struct* %2, i32 0, i32 3
  %3 = load i64, i64* %flags, align 8
  %or = or i64 %3, 256
  store i64 %or, i64* %flags, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @set_memory_ro(i64 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.vm_struct* @find_vm_area(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_prog_unlock_free(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  call void @__bpf_prog_free(%struct.bpf_prog* noundef %0) #20
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bpf_prog_free(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @div_u64(i64 noundef %dividend, i32 noundef %divisor) #0 {
entry:
  %dividend.addr = alloca i64, align 8
  %divisor.addr = alloca i32, align 4
  %remainder = alloca i32, align 4
  store i64 %dividend, i64* %dividend.addr, align 8
  store i32 %divisor, i32* %divisor.addr, align 4
  %0 = load i64, i64* %dividend.addr, align 8
  %1 = load i32, i32* %divisor.addr, align 4
  %call = call i64 @div_u64_rem(i64 noundef %0, i32 noundef %1, i32* noundef %remainder) #20
  ret i64 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @div_u64_rem(i64 noundef %dividend, i32 noundef %divisor, i32* noundef %remainder) #0 {
entry:
  %dividend.addr = alloca i64, align 8
  %divisor.addr = alloca i32, align 4
  %remainder.addr = alloca i32*, align 8
  store i64 %dividend, i64* %dividend.addr, align 8
  store i32 %divisor, i32* %divisor.addr, align 4
  store i32* %remainder, i32** %remainder.addr, align 8
  %0 = load i64, i64* %dividend.addr, align 8
  %1 = load i32, i32* %divisor.addr, align 4
  %conv = zext i32 %1 to i64
  %rem = urem i64 %0, %conv
  %conv1 = trunc i64 %rem to i32
  %2 = load i32*, i32** %remainder.addr, align 8
  store i32 %conv1, i32* %2, align 4
  %3 = load i64, i64* %dividend.addr, align 8
  %4 = load i32, i32* %divisor.addr, align 4
  %conv2 = zext i32 %4 to i64
  %div = udiv i64 %3, %conv2
  ret i64 %div
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bpf_free_used_maps(%struct.bpf_prog_aux* noundef, %struct.bpf_map** noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bpf_free_used_btfs(%struct.bpf_prog_aux* noundef, %struct.btf_mod_pair* noundef, i32 noundef) #1

attributes #0 = { noinline noredzone nounwind null_pointer_is_valid sspstrong "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" "warn-stack-size"="2048" }
attributes #1 = { noredzone null_pointer_is_valid "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #2 = { cold noredzone null_pointer_is_valid "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #3 = { nofree nosync nounwind willreturn }
attributes #4 = { argmemonly nofree nounwind willreturn writeonly }
attributes #5 = { argmemonly nofree nounwind willreturn }
attributes #6 = { noinline noredzone nounwind null_pointer_is_valid sspstrong allocsize(0) "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" "warn-stack-size"="2048" }
attributes #7 = { noredzone null_pointer_is_valid allocsize(0) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #8 = { noinline noredzone nounwind null_pointer_is_valid sspstrong allocsize(0,1) "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" "warn-stack-size"="2048" }
attributes #9 = { nofree nosync nounwind readnone speculatable willreturn }
attributes #10 = { convergent nofree nosync nounwind readnone willreturn }
attributes #11 = { noredzone null_pointer_is_valid "dontcall-error"="copy source size is too small" "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #12 = { noredzone null_pointer_is_valid "dontcall-error"="copy destination size is too small" "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #13 = { noinline noredzone nounwind null_pointer_is_valid sspstrong allocsize(1,2) "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" "warn-stack-size"="2048" }
attributes #14 = { noredzone null_pointer_is_valid allocsize(1) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #15 = { noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" "warn-stack-size"="2048" }
attributes #16 = { noredzone null_pointer_is_valid allocsize(2) "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #17 = { nofree nosync nounwind readnone willreturn }
attributes #18 = { nounwind readonly }
attributes #19 = { nounwind }
attributes #20 = { noredzone }
attributes #21 = { cold noredzone }
attributes #22 = { noredzone nounwind }
attributes #23 = { noredzone nounwind readnone willreturn }
attributes #24 = { noredzone allocsize(0) }
attributes #25 = { noredzone allocsize(0,1) }
attributes #26 = { noredzone nounwind allocsize(0) }
attributes #27 = { noredzone nounwind allocsize(2) }
attributes #28 = { noredzone allocsize(1,2) }
attributes #29 = { noredzone allocsize(1) }
attributes #30 = { nounwind readnone }

!llvm.named.register.rsp = !{!0}
!llvm.module.flags = !{!1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{!"rsp"}
!1 = !{i32 1, !"wchar_size", i32 2}
!2 = !{i32 1, !"Code Model", i32 2}
!3 = !{i32 1, !"override-stack-alignment", i32 8}
!4 = !{i32 4, !"SkipRaxSetup", i32 1}
!5 = !{!"Ubuntu clang version 14.0.0-1ubuntu1.1"}
!6 = !{i64 2158136534, i64 2158136563, i64 2158136609, i64 2158136667, i64 2158136721, i64 2158136775, i64 2158136830, i64 2158136861, i64 2158137173, i64 2158137179, i64 2158137226, i64 2158137253, i64 2158137279}
!7 = !{i32 2677498}
!8 = !{i32 2677527}
!9 = !{i64 2150176651, i64 2150176680, i64 2150176726, i64 2150176784, i64 2150176838, i64 2150176892, i64 2150176947, i64 2150176978, i64 2150177290, i64 2150177296, i64 2150177343, i64 2150177370, i64 2150177396}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
!12 = distinct !{!12, !11}
!13 = !{i64 2158208985, i64 2158209014, i64 2158209060, i64 2158209118, i64 2158209172, i64 2158209226, i64 2158209281, i64 2158209312, i64 2158209624, i64 2158209630, i64 2158209677, i64 2158209704, i64 2158209730}
!14 = !{i64 2158211761, i64 2158211790, i64 2158211836, i64 2158211894, i64 2158211948, i64 2158212002, i64 2158212057, i64 2158212088, i64 2158212400, i64 2158212406, i64 2158212453, i64 2158212480, i64 2158212506}
!15 = distinct !{!15, !11}
!16 = distinct !{!16, !11}
!17 = !{i64 2158233686, i64 2158233715, i64 2158233761, i64 2158233819, i64 2158233873, i64 2158233927, i64 2158233982, i64 2158234013, i64 2158234325, i64 2158234331, i64 2158234378, i64 2158234405, i64 2158234431}
!18 = distinct !{!18, !11}
!19 = distinct !{!19, !11}
!20 = !{i64 2153816601, i64 2153816630, i64 2153816676, i64 2153816734, i64 2153816788, i64 2153816842, i64 2153816897, i64 2153816928}
!21 = distinct !{!21, !11}
!22 = distinct !{!22, !11}
!23 = distinct !{!23, !11}
!24 = distinct !{!24, !11}
!25 = distinct !{!25, !11}
!26 = distinct !{!26, !11}
!27 = distinct !{!27, !11}
!28 = !{i64 2158388064, i64 2158388093, i64 2158388139, i64 2158388197, i64 2158388251, i64 2158388305, i64 2158388360, i64 2158388391, i64 2158388703, i64 2158388709, i64 2158388756, i64 2158388783, i64 2158388809}
!29 = distinct !{!29, !11}
!30 = !{i64 2158222368, i64 2158222397, i64 2158222443, i64 2158222501, i64 2158222555, i64 2158222609, i64 2158222664, i64 2158222695, i64 2158223007, i64 2158223013, i64 2158223060, i64 2158223087, i64 2158223113}
!31 = distinct !{!31, !11}
!32 = distinct !{!32, !11}
!33 = distinct !{!33, !11}
!34 = distinct !{!34, !11}
!35 = distinct !{!35, !11}
!36 = distinct !{!36, !11}
!37 = distinct !{!37, !11}
!38 = distinct !{!38, !11}
!39 = !{i64 2158348813, i64 2158348842, i64 2158348888, i64 2158348946, i64 2158349000, i64 2158349054, i64 2158349109, i64 2158349140, i64 2158349452, i64 2158349458, i64 2158349505, i64 2158349532, i64 2158349558}
!40 = distinct !{!40, !11}
!41 = distinct !{!41, !11}
!42 = distinct !{!42, !11}
!43 = !{i64 2158345591, i64 2158345620, i64 2158345666, i64 2158345724, i64 2158345778, i64 2158345832, i64 2158345887, i64 2158345918, i64 2158346230, i64 2158346236, i64 2158346283, i64 2158346310, i64 2158346336}
!44 = distinct !{!44, !11}
!45 = distinct !{!45, !11}
!46 = distinct !{!46, !11}
!47 = distinct !{!47, !11}
!48 = distinct !{!48, !11}
!49 = !{i64 2158201230, i64 2158201259, i64 2158201305, i64 2158201363, i64 2158201417, i64 2158201471, i64 2158201526, i64 2158201557, i64 2158201869, i64 2158201875, i64 2158201922, i64 2158201949, i64 2158201975}
!50 = !{i64 2158203820, i64 2158203849, i64 2158203895, i64 2158203953, i64 2158204007, i64 2158204061, i64 2158204116, i64 2158204147, i64 2158204459, i64 2158204465, i64 2158204512, i64 2158204539, i64 2158204565}
!51 = !{i64 2158206409, i64 2158206438, i64 2158206484, i64 2158206542, i64 2158206596, i64 2158206650, i64 2158206705, i64 2158206736, i64 2158207048, i64 2158207054, i64 2158207101, i64 2158207128, i64 2158207154}
!52 = distinct !{!52, !11}
!53 = distinct !{!53, !11}
!54 = distinct !{!54, !11}
!55 = distinct !{!55, !11}
!56 = !{i64 1714518}
!57 = distinct !{!57, !11}
!58 = distinct !{!58, !11}
!59 = distinct !{!59, !11}
!60 = distinct !{!60, !11}
!61 = distinct !{!61, !11}
!62 = distinct !{!62, !11}
!63 = distinct !{!63, !11}
!64 = distinct !{!64, !11}
!65 = !{i64 2158195116, i64 2158195145, i64 2158195191, i64 2158195249, i64 2158195303, i64 2158195357, i64 2158195412, i64 2158195443, i64 2158195755, i64 2158195761, i64 2158195808, i64 2158195835, i64 2158195861}
!66 = distinct !{!66, !11}
!67 = !{i64 2158159755, i64 2158159784, i64 2158159830, i64 2158159888, i64 2158159942, i64 2158159996, i64 2158160051, i64 2158160082, i64 2158160394, i64 2158160400, i64 2158160447, i64 2158160474, i64 2158160500}
!68 = distinct !{!68, !11}
!69 = distinct !{!69, !11}
!70 = distinct !{!70, !11}
!71 = distinct !{!71, !11}
!72 = distinct !{!72, !11}
!73 = distinct !{!73, !11}
!74 = distinct !{!74, !11}
!75 = distinct !{!75, !11}
!76 = distinct !{!76, !11}
!77 = distinct !{!77, !11}
!78 = distinct !{!78, !11}
!79 = distinct !{!79, !11}
!80 = distinct !{!80, !11}
!81 = distinct !{!81, !11}
!82 = distinct !{!82, !11}
!83 = distinct !{!83, !11}
!84 = distinct !{!84, !11}
!85 = distinct !{!85, !11}
!86 = distinct !{!86, !11}
!87 = distinct !{!87, !11}
!88 = distinct !{!88, !11}
!89 = distinct !{!89, !11}
!90 = !{i64 2149419550}
!91 = distinct !{!91, !11}
!92 = !{i64 2158140145}
!93 = distinct !{!93, !11}
!94 = distinct !{!94, !11}
!95 = distinct !{!95, !11}
!96 = distinct !{!96, !11}
!97 = !{i64 2158196657, i64 2158196686, i64 2158196732, i64 2158196790, i64 2158196844, i64 2158196898, i64 2158196953, i64 2158196984, i64 2158197296, i64 2158197302, i64 2158197349, i64 2158197376, i64 2158197402}
!98 = distinct !{!98, !11}
!99 = !{i64 2158338072, i64 2158338101, i64 2158338147, i64 2158338205, i64 2158338259, i64 2158338313, i64 2158338368, i64 2158338399, i64 2158338711, i64 2158338717, i64 2158338764, i64 2158338791, i64 2158338817}
!100 = distinct !{!100, !11}
!101 = !{i64 2158341070, i64 2158341099, i64 2158341145, i64 2158341203, i64 2158341257, i64 2158341311, i64 2158341366, i64 2158341397, i64 2158341709, i64 2158341715, i64 2158341762, i64 2158341789, i64 2158341815}
!102 = distinct !{!102, !11}
!103 = distinct !{!103, !11}
!104 = distinct !{!104, !11}
!105 = distinct !{!105, !11}
!106 = distinct !{!106, !11}
!107 = distinct !{!107, !11}
!108 = distinct !{!108, !11}
!109 = distinct !{!109, !11}
!110 = distinct !{!110, !11}
!111 = distinct !{!111, !11}
!112 = distinct !{!112, !11}
!113 = distinct !{!113, !11}
!114 = distinct !{!114, !11}
!115 = !{i64 2158157918, i64 2158157947, i64 2158157993, i64 2158158051, i64 2158158105, i64 2158158159, i64 2158158214, i64 2158158245, i64 2158158557, i64 2158158563, i64 2158158610, i64 2158158637, i64 2158158663}
!116 = distinct !{!116, !11}
!117 = !{i64 2158313401, i64 2158313430, i64 2158313476, i64 2158313534, i64 2158313588, i64 2158313642, i64 2158313697, i64 2158313728, i64 2158314040, i64 2158314046, i64 2158314093, i64 2158314120, i64 2158314146}
!118 = !{i64 2158314974, i64 2158315003, i64 2158315049, i64 2158315107, i64 2158315161, i64 2158315215, i64 2158315270, i64 2158315301, i64 2158315613, i64 2158315619, i64 2158315666, i64 2158315693, i64 2158315719}
!119 = distinct !{!119, !11}
!120 = distinct !{!120, !11}
!121 = distinct !{!121, !11}
!122 = distinct !{!122, !11}
!123 = distinct !{!123, !11}
!124 = !{i64 2158334691, i64 2158334720, i64 2158334766, i64 2158334824, i64 2158334878, i64 2158334932, i64 2158334987, i64 2158335018, i64 2158335330, i64 2158335336, i64 2158335383, i64 2158335410, i64 2158335436}
!125 = distinct !{!125, !11}
!126 = distinct !{!126, !11}
!127 = distinct !{!127, !11}
!128 = distinct !{!128, !11}
!129 = distinct !{!129, !11}
!130 = distinct !{!130, !11}
!131 = distinct !{!131, !11}
!132 = distinct !{!132, !11}
!133 = distinct !{!133, !11}
!134 = distinct !{!134, !11}
!135 = distinct !{!135, !11}
!136 = distinct !{!136, !11}
!137 = distinct !{!137, !11}
!138 = distinct !{!138, !11}
!139 = !{i64 2158331059, i64 2158331088, i64 2158331134, i64 2158331192, i64 2158331246, i64 2158331300, i64 2158331355, i64 2158331386, i64 2158331698, i64 2158331704, i64 2158331751, i64 2158331778, i64 2158331804}
!140 = !{i64 2149218782, i64 2149218856}
!141 = !{i64 2158260449, i64 2158260478, i64 2158260524, i64 2158260582, i64 2158260636, i64 2158260690, i64 2158260745, i64 2158260776, i64 2158261088, i64 2158261094, i64 2158261141, i64 2158261168, i64 2158261194}
!142 = !{i64 2158261954, i64 2158261983, i64 2158262029, i64 2158262087, i64 2158262141, i64 2158262195, i64 2158262250, i64 2158262281, i64 2158262593, i64 2158262599, i64 2158262646, i64 2158262673, i64 2158262699}
!143 = distinct !{!143, !11}
!144 = distinct !{!144, !11}
!145 = distinct !{!145, !11}
!146 = distinct !{!146, !11}
!147 = distinct !{!147, !11}
!148 = distinct !{!148, !11}
!149 = distinct !{!149, !11}
!150 = distinct !{!150, !11}
!151 = distinct !{!151, !11}
!152 = distinct !{!152, !11}
!153 = distinct !{!153, !11}
!154 = distinct !{!154, !11}
!155 = distinct !{!155, !11}
!156 = distinct !{!156, !11}
!157 = distinct !{!157, !11}
!158 = distinct !{!158, !11}
!159 = distinct !{!159, !11}
!160 = distinct !{!160, !11}
!161 = distinct !{!161, !11}
!162 = distinct !{!162, !11}
!163 = !{i64 2158307993, i64 2158308022, i64 2158308068, i64 2158308126, i64 2158308180, i64 2158308234, i64 2158308289, i64 2158308320, i64 2158308632, i64 2158308638, i64 2158308685, i64 2158308712, i64 2158308738}
!164 = distinct !{!164, !11}
!165 = distinct !{!165, !11}
!166 = distinct !{!166, !11}
!167 = !{i64 2158304818, i64 2158304847, i64 2158304893, i64 2158304951, i64 2158305005, i64 2158305059, i64 2158305114, i64 2158305145, i64 2158305457, i64 2158305463, i64 2158305510, i64 2158305537, i64 2158305563}
!168 = !{i64 2158306436, i64 2158306465, i64 2158306511, i64 2158306569, i64 2158306623, i64 2158306677, i64 2158306732, i64 2158306763, i64 2158307075, i64 2158307081, i64 2158307128, i64 2158307155, i64 2158307181}
!169 = distinct !{!169, !11}
!170 = distinct !{!170, !11}
!171 = distinct !{!171, !11}
!172 = distinct !{!172, !11}
!173 = distinct !{!173, !11}
!174 = distinct !{!174, !11}
!175 = distinct !{!175, !11}
!176 = distinct !{!176, !11}
!177 = distinct !{!177, !11}
!178 = distinct !{!178, !11}
!179 = distinct !{!179, !11}
!180 = distinct !{!180, !11}
!181 = distinct !{!181, !11}
!182 = !{i64 2158353127, i64 2158353156, i64 2158353202, i64 2158353260, i64 2158353314, i64 2158353368, i64 2158353423, i64 2158353454, i64 2158353766, i64 2158353772, i64 2158353819, i64 2158353846, i64 2158353872}
!183 = distinct !{!183, !11}
!184 = distinct !{!184, !11}
!185 = distinct !{!185, !11}
!186 = distinct !{!186, !11}
!187 = distinct !{!187, !11}
!188 = distinct !{!188, !11}
!189 = distinct !{!189, !11}
!190 = distinct !{!190, !11}
!191 = distinct !{!191, !11}
!192 = distinct !{!192, !11}
!193 = distinct !{!193, !11}
!194 = distinct !{!194, !11}
!195 = !{i64 2158229128, i64 2158229157, i64 2158229203, i64 2158229261, i64 2158229315, i64 2158229369, i64 2158229424, i64 2158229455, i64 2158229767, i64 2158229773, i64 2158229820, i64 2158229847, i64 2158229873}
