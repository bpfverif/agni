; ModuleID = 'llvm-link'
source_filename = "llvm-link"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_tnum_strn:\09\09\09\09\09"
module asm "\09.asciz \09\22tnum_strn\22\09\09\09\09\09"
module asm "__kstrtabns_tnum_strn:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___ksymtab_gpl+tnum_strn\22, \22a\22\09"
module asm "\09.balign\094\09\09\09\09\09"
module asm "__ksymtab_tnum_strn:\09\09\09\09"
module asm "\09.long\09tnum_strn- .\09\09\09\09"
module asm "\09.long\09__kstrtab_tnum_strn- .\09\09\09"
module asm "\09.long\09__kstrtabns_tnum_strn- .\09\09\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22__ksymtab_strings\22,\22aMS\22,%progbits,1\09"
module asm "__kstrtab_bpf_verifier_log_write:\09\09\09\09\09"
module asm "\09.asciz \09\22bpf_verifier_log_write\22\09\09\09\09\09"
module asm "__kstrtabns_bpf_verifier_log_write:\09\09\09\09\09"
module asm "\09.asciz \09\22\22\09\09\09\09\09"
module asm "\09.previous\09\09\09\09\09\09"
module asm "\09.section \22___ksymtab_gpl+bpf_verifier_log_write\22, \22a\22\09"
module asm "\09.balign\094\09\09\09\09\09"
module asm "__ksymtab_bpf_verifier_log_write:\09\09\09\09"
module asm "\09.long\09bpf_verifier_log_write- .\09\09\09\09"
module asm "\09.long\09__kstrtab_bpf_verifier_log_write- .\09\09\09"
module asm "\09.long\09__kstrtabns_bpf_verifier_log_write- .\09\09\09"
module asm "\09.previous\09\09\09\09\09"

%struct.btf = type opaque
%struct.bpf_insn = type { i8, i8, i16, i32 }
%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %union.anon.0, %struct.list_head }
%struct.atomic64_t = type { i64 }
%struct.spinlock = type { %union.anon }
%union.anon = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.qspinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.bpf_verifier_ops = type { %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, %struct.bpf_insn*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (%struct.bpf_verifier_log*, %struct.btf_type*, i32, i32, i32, i32*)* }
%struct.bpf_func_proto = type { i64 (i64, i64, i64, i64, i64)*, i8, i8, i32, %union.anon.168, %union.anon.170, i32*, i1 (%struct.bpf_prog*)* }
%union.anon.168 = type { %struct.gnet_stats_queue }
%struct.gnet_stats_queue = type { i32, i32, i32, i32, i32 }
%union.anon.170 = type { %struct.anon.171 }
%struct.anon.171 = type { i32*, i32*, i32*, i32*, i32* }
%struct.bpf_prog = type { i16, i16, i32, i32, i32, i32, [8 x i8], %struct.bpf_prog_aux*, %struct.sock_fprog_kern*, i32 (i8*, %struct.bpf_insn*)*, [0 x %struct.sock_filter], [0 x %struct.bpf_insn] }
%struct.bpf_prog_aux = type { %struct.atomic64_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.bpf_ctx_arg_aux*, %struct.mutex, %struct.bpf_prog*, %struct.bpf_trampoline*, i32, i32, i8, i8, i8, i8, i8, i8, i32, %struct.hlist_node, %struct.btf_type*, i8*, %struct.bpf_prog**, i8*, %struct.bpf_jit_poke_descriptor*, i32, %struct.bpf_ksym, %struct.bpf_prog_ops*, %struct.bpf_map**, %struct.mutex, %struct.bpf_prog*, %struct.user_struct*, i64, [2 x %struct.bpf_map*], [16 x i8], i8*, %struct.bpf_prog_offload*, %struct.btf*, %struct.util_est*, %struct.bpf_func_info_aux*, %struct.ethtool_pauseparam*, i8**, i32, i32, i32, i32, %struct.bpf_ctx_arg_aux*, %struct.bpf_prog_stats*, %union.anon.167 }
%struct.bpf_trampoline = type { %struct.hlist_node, %struct.mutex, %union.anon.0, i64, %struct.anon.2, %struct.bpf_prog*, [3 x %struct.hlist_head], [3 x i32], i8*, i64, %struct.bpf_ksym }
%struct.anon.2 = type { %struct.btf_func_model, i8*, i8 }
%struct.btf_func_model = type { i8, i8, [12 x i8] }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.btf_type = type { i32, i32, %struct.atomic_t }
%struct.bpf_jit_poke_descriptor = type { i8*, i8*, i8*, %union.anon.4, i8, i8, i16, i32 }
%union.anon.4 = type { %struct.anon.5 }
%struct.anon.5 = type { %struct.bpf_map*, i32 }
%struct.bpf_map = type { %struct.bpf_map_ops*, %struct.bpf_map*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.btf*, %struct.bpf_map_memory, [16 x i8], i32, i8, i8, [18 x i8], %struct.atomic64_t, %struct.atomic64_t, %struct.work_struct, %struct.mutex, i64, [40 x i8] }
%struct.bpf_map_ops = type { i32 (%union.bpf_attr*)*, %struct.bpf_map* (%union.bpf_attr*)*, void (%struct.bpf_map*, %struct.file*)*, void (%struct.bpf_map*)*, i32 (%struct.bpf_map*, i8*, i8*)*, void (%struct.bpf_map*)*, i8* (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i32 (%struct.bpf_map*, %union.bpf_attr*, %union.bpf_attr*)*, i8* (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*, i64)*, i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)*, i8* (%struct.bpf_map*, %struct.file*, i32)*, void (i8*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (i8*)*, void (%struct.bpf_map*, i8*, %struct.seq_file*)*, i32 (%struct.bpf_map*, %struct.btf*, %struct.btf_type*, %struct.btf_type*)*, i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)*, i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64, i32*)*, i32 (%struct.bpf_map*, %struct.vm_area_struct*)*, i32 (%struct.bpf_map*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.bpf_local_storage_map*, i8*, i32)*, void (%struct.bpf_local_storage_map*, i8*, i32)*, %struct.bpf_local_storage** (i8*)*, i1 (%struct.bpf_map*, %struct.bpf_map*)*, i8*, i32*, %struct.bpf_iter_seq_info* }
%union.bpf_attr = type { %struct.anon.10 }
%struct.anon.10 = type { i32, i32, i64, i64, i32, i32, i64, i32, i32, [16 x i8], i32, i32, i32, i32, i64, i32, i32, i64, i32, i32, i32 }
%struct.file = type { %union.anon.30, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i32, i32 }
%union.anon.30 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %union.anon.0, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.local_t, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.sysv_shm, %struct.list_head, %struct.list_head, %union.anon.92 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %struct.atomic64_t, i8* }
%struct.local_t = type { %struct.atomic64_t }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, i8*, i32, i64, i64, i32, %struct.fsnotify_mark_connector*, [32 x i8], %union.anon.149, i32, i32, %struct.mutex, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, %struct.atomic64_t, i32, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, %struct.list_lru, %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, i32 (%struct.fs_context*)*, %struct.fs_parameter_spec*, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.u64_stats_sync, %struct.u64_stats_sync, %struct.u64_stats_sync, [3 x %struct.u64_stats_sync], %struct.u64_stats_sync, %struct.u64_stats_sync, %struct.u64_stats_sync }
%struct.fs_context = type opaque
%struct.fs_parameter_spec = type opaque
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.bpf_ctx_arg_aux*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.bpf_ctx_arg_aux*, i32*, i8, i8, %struct.bpf_ctx_arg_aux*, i32*, i32, i32, %struct.bpf_ctx_arg_aux*, i32 ()*, [40 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i8*, i32, i32, i32*, i32, %struct.srcu_struct**, i32, %struct.bpf_raw_event_map*, %struct.jump_entry*, i32, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_eval_map**, i32, i8*, i32, i64*, i32, i32, %struct.util_est*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, %struct.thread_info*, i32, [60 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.qspinlock, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [64 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.attribute_group**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)*, void (%struct.kobject*, %struct.atomic_t*, %struct.atomic_t*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.atomic64_t, i64, %struct.timerqueue_node, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.atomic64_t, %struct.mempolicy*, %struct.u64_stats_sync }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.mm_struct = type { %struct.anon.33, [0 x i64] }
%struct.anon.33 = type { %struct.vm_area_struct*, %struct.rb_root, i64, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, i64, i64, %struct.atomic64_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, %struct.atomic64_t, i64, i64, i64, i64, %struct.spinlock, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_subscriptions*, %struct.atomic_t, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct, i32 }
%struct.rb_root = type { %struct.rb_node* }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i64, %struct.atomic64_t, %struct.rw_semaphore, %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %union.anon.0, i32, i32, i32, %struct.__call_single_node, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, i32, i32, i32, %struct.cpumask*, %struct.cpumask, i32, i32, %struct.atomic_t, i8, %struct.list_head, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.pid*, [4 x %struct.hlist_node], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.posix_cputimers, %struct.posix_cputimers_work, %struct.cred*, %struct.cred*, %struct.cred*, %struct.key*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, %struct.fs_struct*, %struct.files_struct*, %struct.io_uring_task*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.cpumask, %struct.cpumask, %struct.cpumask, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.atomic_t, i32, %struct.seccomp, i64, i64, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root_cached, %struct.task_struct*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, %struct.capture_control*, i64, %struct.kernel_siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.cpumask, %union.anon.0, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, %struct.mutex, i32, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.rseq*, i32, i64, %struct.tlbflush_unmap_batch, %union.anon.30, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, %struct.uprobe_task*, i32, %struct.task_struct*, %struct.vm_struct*, %union.anon.0, i8*, i8*, i64, i64, i64, %struct.callback_head, [24 x i8], %struct.thread_struct }
%struct.thread_info = type { i64, i32 }
%struct.__call_single_node = type { %struct.llist_node, %struct.atomic_t, i16, i16 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.thread_info, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, i64, [24 x i8], %struct.sched_avg }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i64, i32, i32, i64, i64, i64, %struct.util_est }
%struct.util_est = type { i32, i32 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i64, i32, i8, %struct.hrtimer, %struct.hrtimer, %struct.sched_dl_entity* }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8, i8, i8 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %union.anon.0, %struct.hrtimer*, %struct.timerqueue_head, i64 ()*, i64 }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, i32, i8, i32, i16, i16, i32, i64, %struct.hrtimer*, i64, %struct.hrtimer*, [8 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root_cached }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.vmacache = type { i64, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.36 }
%union.anon.36 = type { %struct.anon.37 }
%struct.anon.37 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid = type { %union.anon.0, i32, %struct.spinlock, [4 x %struct.hlist_head], %struct.hlist_head, %struct.wait_queue_head, %struct.callback_head, [1 x %struct.upid] }
%struct.wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.upid = type { i32, %struct.pid_namespace* }
%struct.pid_namespace = type { %struct.qspinlock, %struct.idr, %struct.callback_head, i32, %struct.task_struct*, %struct.kmem_cache*, i32, %struct.pid_namespace*, %struct.fs_pin*, %struct.user_namespace*, %struct.ucounts*, i32, %struct.ns_common }
%struct.idr = type { %struct.xarray, i32, i32 }
%struct.xarray = type { %struct.spinlock, i32, i8* }
%struct.kmem_cache = type opaque
%struct.fs_pin = type opaque
%struct.ucounts = type { %struct.hlist_node, %struct.user_namespace*, %struct.atomic_t, i32, [10 x %struct.atomic_t] }
%struct.ns_common = type { %struct.atomic64_t, %struct.proc_ns_operations*, i32 }
%struct.proc_ns_operations = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.posix_cputimers = type { [3 x %struct.posix_cputimer_base], i32, i32 }
%struct.posix_cputimer_base = type { i64, %struct.timerqueue_head }
%struct.posix_cputimers_work = type { %struct.callback_head, i32 }
%struct.key = type { %union.anon.0, i32, %union.anon.43, %struct.rw_semaphore, %struct.key_user*, i8*, %struct.atomic64_t, i64, %struct.atomic_t, %struct.atomic_t, i32, i16, i16, i16, i64, %union.anon.45, %union.anon.49, %struct.key_restriction* }
%union.anon.43 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.45 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { i64, %struct.atomic64_t, %struct.key_type*, %struct.key_tag*, i8* }
%struct.key_type = type opaque
%struct.key_tag = type { %struct.callback_head, %union.anon.0, i8 }
%union.anon.49 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.key_restriction = type { i32 (%struct.key*, %struct.key_type*, %union.key_payload*, %struct.key*)*, %struct.key*, %struct.key_type* }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.io_uring_task = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net*, %struct.time_namespace*, %struct.time_namespace*, %struct.cgroup_namespace* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type { %union.anon.0, %union.anon.0, %struct.spinlock, i32, i32, i32, %struct.spinlock, %struct.atomic_t, %struct.list_head, %struct.list_head, %struct.llist_node, %struct.key_tag*, %struct.user_namespace*, %struct.ucounts*, %struct.idr, %struct.ns_common, %struct.list_head, %struct.proc_dir_entry*, %struct.proc_dir_entry*, %struct.ctl_table_set, %struct.sock*, %struct.sock*, %struct.uevent_sock*, %struct.hlist_head*, %struct.hlist_head*, %struct.raw_notifier_head, i32, %struct.net_device*, %struct.list_head, %struct.netns_core, %struct.netns_mib, %struct.netns_packet, %struct.netns_unix, %struct.netns_nexthop, [24 x i8], %struct.netns_ipv4, %struct.netns_ipv6, %struct.netns_nf, %struct.netns_xt, %struct.netns_ct, %struct.netns_nf_frag, %struct.ctl_table_header*, %struct.sock*, %struct.sock*, %struct.net_generic*, %struct.netns_bpf, %struct.netns_xfrm, %struct.atomic64_t, %struct.sock*, [48 x i8] }
%struct.proc_dir_entry = type opaque
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_table_header = type { %union.anon.51, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node*, %struct.hlist_head }
%union.anon.51 = type { %struct.anon.52 }
%struct.anon.52 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.wait_queue_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*)*, void (%struct.ctl_table_header*, %struct.ctl_table*, %struct.atomic_t*, %struct.atomic_t*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.uevent_sock = type opaque
%struct.raw_notifier_head = type { %struct.notifier_block* }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.net_device = type { [16 x i8], %struct.netdev_name_node*, %struct.dev_ifalias*, i64, i64, i64, i32, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.anon.148, i64, i64, i64, i64, i64, i64, i64, i32, i32, %struct.net_device_stats, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic_t, %struct.atomic_t, %struct.net_device_ops*, %struct.ethtool_ops*, %struct.ndisc_ops*, %struct.header_ops*, i32, i32, i16, i16, i8, i8, i8, i8, i32, i32, i32, i16, i16, i8, i8, i16, i16, [32 x i8], i8, i8, i8, i8, i16, i16, i16, %struct.spinlock, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.kset*, i32, i32, i8, %struct.in_device*, %struct.inet6_dev*, %struct.wireless_dev*, %struct.wpan_dev*, i8*, %struct.netdev_rx_queue*, i32, i32, %struct.bpf_prog*, i64, i32, i32 (%struct.sk_buff**)*, i8*, %struct.mini_Qdisc*, %struct.netdev_queue*, %struct.nf_hook_entries*, [32 x i8], %struct.cpu_rmap*, %struct.hlist_node, [24 x i8], %struct.netdev_queue*, i32, i32, %struct.Qdisc*, i32, %struct.spinlock, %struct.xdp_dev_bulk_queue*, %struct.xps_dev_maps*, %struct.xps_dev_maps*, %struct.mini_Qdisc*, [16 x %struct.hlist_head], %struct.timer_list, i32, i32, %struct.list_head, i32*, %struct.list_head, i8, i8, i16, i8, void (%struct.net_device*)*, %struct.netpoll_info*, %struct.possible_net_t, %union.anon.152, %struct.device, [4 x %struct.attribute_group*], %struct.attribute_group*, %struct.rtnl_link_ops*, i32, i16, i16, [16 x %struct.nlattr], [16 x i8], %struct.phy_device*, %struct.sfp_bus*, %struct.u64_stats_sync*, %struct.u64_stats_sync*, i8, i8, %struct.list_head, %struct.udp_tunnel_nic_info*, %struct.udp_tunnel_nic*, [3 x %struct.bpf_xdp_entity], [40 x i8] }
%struct.netdev_name_node = type { %struct.hlist_node, %struct.list_head, %struct.net_device*, i8* }
%struct.dev_ifalias = type { %struct.callback_head, [0 x i8] }
%struct.anon.148 = type { %struct.list_head, %struct.list_head }
%struct.net_device_stats = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.net_device_ops = type { i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.sk_buff*, %struct.net_device*, i64)*, i16 (%struct.net_device*, %struct.sk_buff*, %struct.net_device*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i8*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifmap*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.neigh_parms*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*, %struct.rtnl_link_stats64*)*, i1 (%struct.net_device*, i32)*, i32 (i32, %struct.net_device*, i8*)*, %struct.net_device_stats* (%struct.net_device*)*, i32 (%struct.net_device*, i16, i16)*, i32 (%struct.net_device*, i16, i16)*, void (%struct.net_device*)*, i32 (%struct.net_device*, %struct.netpoll_info*)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i16, i8, i16)*, i32 (%struct.net_device*, i32, i32, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_info*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_stats*)*, i32 (%struct.net_device*, i32, %struct.nlattr**)*, i32 (%struct.net_device*, i32, %struct.sk_buff*)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_guid*, %struct.ifla_vf_guid*)*, i32 (%struct.net_device*, i32, i64, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, %struct.sk_buff*, i16, i32)*, i32 (%struct.net_device*, %struct.net_device*, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.net_device*)*, %struct.net_device* (%struct.net_device*, %struct.sk_buff*, i1)*, i64 (%struct.net_device*, i64)*, i32 (%struct.net_device*, i64)*, i32 (%struct.net_device*, %struct.neighbour*)*, void (%struct.net_device*, %struct.neighbour*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16, i16, %struct.netlink_ext_ack*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16)*, i32 (%struct.sk_buff*, %struct.netlink_callback*, %struct.net_device*, %struct.net_device*, i32*)*, i32 (%struct.sk_buff*, %struct.nlattr**, %struct.net_device*, i8*, i16, i32, i32, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16, %struct.netlink_ext_ack*)*, i32 (%struct.sk_buff*, i32, i32, %struct.net_device*, i32, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.netdev_phys_item_id*)*, i32 (%struct.net_device*, %struct.netdev_phys_item_id*)*, i32 (%struct.net_device*, i8*, i64)*, void (%struct.net_device*, %struct.udp_tunnel_info*)*, void (%struct.net_device*, %struct.udp_tunnel_info*)*, i8* (%struct.net_device*, %struct.net_device*)*, void (%struct.net_device*, i8*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.sk_buff*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.netdev_bpf*)*, i32 (%struct.net_device*, i32, %struct.xdp_frame**, i32)*, i32 (%struct.net_device*, i32, i32)*, %struct.devlink_port* (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ip_tunnel_parm*, i32)*, %struct.net_device* (%struct.net_device*)* }
%struct.sk_buff = type { %union.anon.56, %union.anon.59, %struct.atomic64_t, [48 x i8], %union.anon.61, i64, i32, i32, i16, i16, i16, [0 x i8], i8, i8, [0 x i32], [0 x i8], i16, [0 x i8], i16, i16, %struct.atomic_t, i32, i32, i32, i16, i16, %struct.atomic_t, i32, %struct.atomic_t, %union.anon.67, i16, i16, i16, i16, i16, i16, i16, [0 x i32], i32, i32, i8*, i8*, i32, %union.anon.0, %struct.skb_ext* }
%union.anon.56 = type { %struct.anon.57 }
%struct.anon.57 = type { %struct.sk_buff*, %struct.sk_buff*, %union.anon.58 }
%union.anon.58 = type { %struct.net_device* }
%union.anon.59 = type { %struct.sock* }
%union.anon.61 = type { %struct.anon.62 }
%struct.anon.62 = type { i64, void (%struct.sk_buff*)* }
%union.anon.67 = type { i16 }
%struct.skb_ext = type { %union.anon.0, [1 x i8], i8, [2 x i8], [0 x i8] }
%struct.ifreq = type { %union.anon.149, %union.anon.150 }
%union.anon.150 = type { %struct.ifmap }
%struct.ifmap = type { i64, i64, i16, i8, i8, i8 }
%struct.neigh_parms = type opaque
%struct.rtnl_link_stats64 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ifla_vf_info = type { i32, [32 x i8], i32, i32, i32, i32, i32, i32, i32, i32, i16 }
%struct.ifla_vf_stats = type { i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.nlattr = type { i16, i16 }
%struct.ifla_vf_guid = type { i32, i64 }
%struct.netlink_ext_ack = type { i8*, %struct.nlattr*, %struct.nla_policy*, [20 x i8], i8 }
%struct.nla_policy = type { i8, i8, i16, %union.anon.152 }
%struct.neighbour = type opaque
%struct.ndmsg = type { i8, i8, i16, i32, i16, i8, i8 }
%struct.netlink_callback = type { %struct.sk_buff*, %struct.nlmsghdr*, i32 (%struct.sk_buff*, %struct.netlink_callback*)*, i32 (%struct.netlink_callback*)*, i8*, %struct.module*, %struct.netlink_ext_ack*, i16, i16, i32, i32, i32, i8, %union.anon.154 }
%struct.nlmsghdr = type { i32, i16, i16, i32, i32 }
%union.anon.154 = type { [6 x i64] }
%struct.netdev_phys_item_id = type { [32 x i8], i8 }
%struct.udp_tunnel_info = type opaque
%struct.netdev_bpf = type { i32, %union.anon.155 }
%union.anon.155 = type { %struct.anon.156 }
%struct.anon.156 = type { i32, %struct.bpf_prog*, %struct.netlink_ext_ack* }
%struct.xdp_frame = type { i8*, i16, i16, i32, %struct.util_est, %struct.net_device* }
%struct.devlink_port = type opaque
%struct.ip_tunnel_parm = type opaque
%struct.ethtool_ops = type { i32, void (%struct.net_device*, %struct.ethtool_drvinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, %struct.ethtool_regs*, i8*)*, void (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ethtool_link_ext_state_info*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, void (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_ringparam*)*, void (%struct.net_device*, %struct.tnum*)*, void (%struct.net_device*, %struct.ethtool_pauseparam*)*, i32 (%struct.net_device*, %struct.ethtool_pauseparam*)*, void (%struct.net_device*, %struct.ethtool_test*, i64*)*, void (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32)*, void (%struct.net_device*, %struct.ethtool_stats*, i64*)*, i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*, i32*)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*)*, i32 (%struct.net_device*, %struct.ethtool_flash*)*, i32 (%struct.net_device*, i32*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32*, i8*, i8*)*, i32 (%struct.net_device*, i32*, i8*, i8)*, i32 (%struct.net_device*, i32*, i8*, i8*, i32)*, i32 (%struct.net_device*, i32*, i8*, i8, i32*, i1)*, void (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*)*, i32 (%struct.net_device*, %struct.ethtool_ts_info*)*, i32 (%struct.net_device*, %struct.ethtool_modinfo*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)*, i32 (%struct.net_device*, %struct.ethtool_tunable*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_tunable*, i8*)*, i32 (%struct.net_device*, i32, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, i32, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, %struct.ethtool_link_ksettings*)*, i32 (%struct.net_device*, %struct.ethtool_link_ksettings*)*, i32 (%struct.net_device*, %struct.ethtool_pauseparam*)*, i32 (%struct.net_device*, %struct.ethtool_pauseparam*)*, void (%struct.net_device*, %struct.ethtool_stats*, i64*)*, i32 (%struct.net_device*, %struct.ethtool_tunable*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_tunable*, i8*)* }
%struct.ethtool_drvinfo = type { i32, [32 x i8], [32 x i8], [32 x i8], [32 x i8], [32 x i8], [12 x i8], i32, i32, i32, i32, i32 }
%struct.ethtool_regs = type { i32, i32, i32, [0 x i8] }
%struct.ethtool_wolinfo = type { i32, i32, i32, [6 x i8] }
%struct.ethtool_link_ext_state_info = type { i32, %struct.atomic_t }
%struct.ethtool_coalesce = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.tnum = type { i64, i64 }
%struct.ethtool_test = type { i32, i32, i32, i32, [0 x i64] }
%struct.ethtool_rxnfc = type { i32, i32, i64, %struct.ethtool_rx_flow_spec, %struct.atomic_t, [0 x i32] }
%struct.ethtool_rx_flow_spec = type { i32, %union.ethtool_flow_union, %struct.ethtool_flow_ext, %union.ethtool_flow_union, %struct.ethtool_flow_ext, i64, i32 }
%union.ethtool_flow_union = type { %struct.ethtool_tcpip6_spec, [12 x i8] }
%struct.ethtool_tcpip6_spec = type { [4 x i32], [4 x i32], i16, i16, i8 }
%struct.ethtool_flow_ext = type { [2 x i8], [6 x i8], i16, i16, [2 x i32] }
%struct.ethtool_flash = type { i32, i32, [128 x i8] }
%struct.ethtool_ringparam = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_eeprom = type { i32, i32, i32, i32, [0 x i8] }
%struct.ethtool_ts_info = type { i32, i32, i32, i32, [3 x i32], i32, [3 x i32] }
%struct.ethtool_modinfo = type { i32, i32, i32, [8 x i32] }
%struct.ethtool_eee = type { i32, i32, i32, i32, i32, i32, i32, i32, [2 x i32] }
%struct.ethtool_link_ksettings = type { %struct.ethtool_link_settings, %struct.anon.161 }
%struct.ethtool_link_settings = type { i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, [1 x i8], [7 x i32], [0 x i32] }
%struct.anon.161 = type { [2 x i64], [2 x i64], [2 x i64] }
%struct.ethtool_stats = type { i32, i32, [0 x i64] }
%struct.ethtool_tunable = type { i32, i32, i32, i32, [0 x i8*] }
%struct.ndisc_ops = type opaque
%struct.header_ops = type { i32 (%struct.sk_buff*, %struct.net_device*, i16, i8*, i8*, i32)*, i32 (%struct.sk_buff*, i8*)*, i32 (%struct.neighbour*, %struct.hh_cache*, i16)*, void (%struct.hh_cache*, %struct.net_device*, i8*)*, i1 (i8*, i32)*, i16 (%struct.sk_buff*)* }
%struct.hh_cache = type { i32, %struct.seqlock_t, [12 x i64] }
%struct.seqlock_t = type { %union.anon.0, %struct.spinlock }
%struct.netdev_hw_addr_list = type { %struct.list_head, i32 }
%struct.in_device = type opaque
%struct.inet6_dev = type opaque
%struct.wireless_dev = type opaque
%struct.wpan_dev = type opaque
%struct.netdev_rx_queue = type { %struct.rps_map*, %struct.rps_dev_flow_table*, %struct.kobject, %struct.net_device*, [40 x i8], %struct.xdp_rxq_info }
%struct.rps_map = type { i32, %struct.callback_head, [0 x i16] }
%struct.rps_dev_flow_table = type { i32, %struct.callback_head, [0 x %struct.rps_dev_flow] }
%struct.rps_dev_flow = type { i16, i16, i32 }
%struct.xdp_rxq_info = type { %struct.net_device*, i32, i32, %struct.util_est, [40 x i8] }
%struct.nf_hook_entries = type opaque
%struct.cpu_rmap = type opaque
%struct.netdev_queue = type { %struct.net_device*, %struct.Qdisc*, %struct.Qdisc*, %struct.kobject, i32, i64, i64, %struct.net_device*, [8 x i8], %struct.spinlock, i32, i64, i64, [40 x i8], %struct.dql }
%struct.dql = type { i32, i32, i32, [52 x i8], i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, [20 x i8] }
%struct.Qdisc = type { i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, i32, i32, %struct.Qdisc_ops*, %struct.qdisc_size_table*, %struct.hlist_node, i32, i32, %struct.netdev_queue*, %struct.net_rate_estimator*, %struct.gnet_stats_basic_cpu*, %struct.gnet_stats_queue*, i32, %union.anon.0, [24 x i8], %struct.sk_buff_head, %struct.sk_buff_head, %struct.tnum, %struct.atomic_t, %struct.gnet_stats_queue, i64, %struct.Qdisc*, %struct.sk_buff_head, %struct.spinlock, %struct.spinlock, i8, %struct.callback_head, [32 x i8], [0 x i64] }
%struct.Qdisc_ops = type { %struct.Qdisc_ops*, %struct.Qdisc_class_ops*, [16 x i8], i32, i32, i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, %struct.sk_buff* (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*, %struct.netlink_ext_ack*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*, %struct.sk_buff*)*, i32 (%struct.Qdisc*, %struct.gnet_dump*)*, void (%struct.Qdisc*, i32)*, void (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*)*, i32 (%struct.Qdisc*)*, %struct.module* }
%struct.Qdisc_class_ops = type { i32, %struct.netdev_queue* (%struct.Qdisc*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.Qdisc*, %struct.Qdisc**, %struct.netlink_ext_ack*)*, %struct.Qdisc* (%struct.Qdisc*, i64)*, void (%struct.Qdisc*, i64)*, i64 (%struct.Qdisc*, i32)*, i32 (%struct.Qdisc*, i32, i32, %struct.nlattr**, i64*, %struct.netlink_ext_ack*)*, i32 (%struct.Qdisc*, i64)*, void (%struct.Qdisc*, %struct.qdisc_walker*)*, %struct.tcf_block* (%struct.Qdisc*, i64, %struct.netlink_ext_ack*)*, i64 (%struct.Qdisc*, i64, i32)*, void (%struct.Qdisc*, i64)*, i32 (%struct.Qdisc*, i64, %struct.sk_buff*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.gnet_dump*)* }
%struct.tcmsg = type { i8, i8, i16, i32, i32, i32, i32 }
%struct.qdisc_walker = type opaque
%struct.tcf_block = type { %struct.mutex, %struct.list_head, i32, i32, %union.anon.0, %struct.net*, %struct.Qdisc*, %struct.rw_semaphore, %struct.sysv_shm, %struct.list_head, i8, %struct.atomic_t, i32, i32, %struct.anon.165, %struct.callback_head, [128 x %struct.hlist_head], %struct.mutex }
%struct.anon.165 = type { %struct.tcf_chain*, %struct.list_head }
%struct.tcf_chain = type { %struct.mutex, %struct.tcf_proto*, %struct.list_head, %struct.tcf_block*, i32, i32, i32, i8, i8, %struct.tcf_proto_ops*, i8*, %struct.callback_head }
%struct.tcf_proto = type { %struct.tcf_proto*, i8*, i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.tcf_result*)*, i16, i32, i8*, %struct.tcf_proto_ops*, %struct.tcf_chain*, %struct.spinlock, i8, %union.anon.0, %struct.callback_head, %struct.hlist_node }
%struct.tcf_result = type { %union.anon.162 }
%union.anon.162 = type { %struct.thread_info }
%struct.tcf_proto_ops = type { %struct.list_head, [16 x i8], i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.tcf_result*)*, i32 (%struct.tcf_proto*)*, void (%struct.tcf_proto*, i1, %struct.netlink_ext_ack*)*, i8* (%struct.tcf_proto*, i32)*, void (%struct.tcf_proto*, i8*)*, i32 (%struct.net*, %struct.sk_buff*, %struct.tcf_proto*, i64, i32, %struct.nlattr**, i8**, i1, i1, %struct.netlink_ext_ack*)*, i32 (%struct.tcf_proto*, i8*, i8*, i1, %struct.netlink_ext_ack*)*, i1 (%struct.tcf_proto*)*, void (%struct.tcf_proto*, %struct.tcf_walker*, i1)*, i32 (%struct.tcf_proto*, i1, i32 (i32, i8*, i8*)*, i8*, %struct.netlink_ext_ack*)*, void (%struct.tcf_proto*, i8*)*, void (%struct.tcf_proto*, i8*)*, void (i8*, i32, i64, i8*, i64)*, i8* (%struct.net*, %struct.tcf_chain*, %struct.nlattr**, %struct.netlink_ext_ack*)*, void (i8*)*, i32 (%struct.net*, %struct.tcf_proto*, i8*, %struct.sk_buff*, %struct.tcmsg*, i1)*, i32 (%struct.net*, %struct.tcf_proto*, i8*, %struct.sk_buff*, %struct.tcmsg*, i1)*, i32 (%struct.sk_buff*, %struct.net*, i8*)*, %struct.module*, i32 }
%struct.tcf_walker = type opaque
%struct.gnet_dump = type { %struct.spinlock*, %struct.sk_buff*, %struct.nlattr*, i32, i32, i32, i8*, i32, %struct.tc_stats }
%struct.tc_stats = type { i64, i32, i32, i32, i32, i32, i32, i32 }
%struct.qdisc_size_table = type { %struct.callback_head, %struct.list_head, %struct.tc_sizespec, i32, [0 x i16] }
%struct.tc_sizespec = type { i8, i8, i16, i32, i32, i32, i32, i32 }
%struct.net_rate_estimator = type opaque
%struct.gnet_stats_basic_cpu = type { %struct.tnum, %struct.u64_stats_sync }
%struct.sk_buff_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.xdp_dev_bulk_queue = type opaque
%struct.xps_dev_maps = type { %struct.callback_head, [0 x %struct.xps_map*] }
%struct.xps_map = type { i32, i32, %struct.callback_head, [0 x i16] }
%struct.mini_Qdisc = type { %struct.tcf_proto*, %struct.tcf_block*, %struct.gnet_stats_basic_cpu*, %struct.gnet_stats_queue*, %struct.callback_head }
%struct.timer_list = type { %struct.hlist_node, i64, void (%struct.timer_list*)*, i32 }
%struct.netpoll_info = type opaque
%struct.possible_net_t = type { %struct.net* }
%union.anon.152 = type { i8* }
%struct.device = type { %struct.kobject, %struct.device*, %struct.device_private*, i8*, %struct.device_type*, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.mutex, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.list_head, %struct.dma_map_ops*, i64*, i64, i64, %struct.bus_dma_region*, %struct.ifla_vf_guid*, %struct.list_head, %struct.u64_stats_sync, %struct.device_node*, %struct.fwnode_handle*, i32, i32, i32, %struct.spinlock, %struct.list_head, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.dev_iommu*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.u64_stats_sync, i8 }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.attribute_group**, %struct.dev_pm_ops*, void (%struct.device*)*, %struct.driver_private* }
%struct.of_device_id = type opaque
%struct.acpi_device_id = type opaque
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, i8, i32 }
%struct.dev_pm_info = type { %struct.atomic_t, i16, i32, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.hrtimer, i64, %struct.work_struct, %struct.wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, i32, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.device*, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, i32 (%struct.device*)*, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dma_map_ops = type opaque
%struct.bus_dma_region = type opaque
%struct.device_node = type opaque
%struct.fwnode_handle = type { %struct.fwnode_handle*, %struct.fwnode_operations*, %struct.device* }
%struct.fwnode_operations = type { %struct.fwnode_handle* (%struct.fwnode_handle*)*, void (%struct.fwnode_handle*)*, i1 (%struct.fwnode_handle*)*, i8* (%struct.fwnode_handle*, %struct.device*)*, i1 (%struct.fwnode_handle*, i8*)*, i32 (%struct.fwnode_handle*, i8*, i32, i8*, i64)*, i32 (%struct.fwnode_handle*, i8*, i8**, i64)*, i8* (%struct.fwnode_handle*)*, i8* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, %struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, i8*)*, i32 (%struct.fwnode_handle*, i8*, i8*, i32, i32, %struct.fwnode_reference_args*)*, %struct.fwnode_handle* (%struct.fwnode_handle*, %struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, %struct.fwnode_handle* (%struct.fwnode_handle*)*, i32 (%struct.fwnode_handle*, %struct.fwnode_endpoint*)*, i32 (%struct.fwnode_handle*, %struct.device*)* }
%struct.fwnode_reference_args = type { %struct.fwnode_handle*, i32, [8 x i64] }
%struct.fwnode_endpoint = type { i32, i32, %struct.fwnode_handle* }
%struct.class = type { i8*, %struct.module*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, void (%struct.device*, %struct.atomic_t*, %struct.atomic_t*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.iommu_group = type opaque
%struct.dev_iommu = type opaque
%struct.rtnl_link_ops = type { %struct.list_head, i8*, i64, void (%struct.net_device*)*, i32, %struct.nla_policy*, i32 (%struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i32 (%struct.net*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i32 (%struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, void (%struct.net_device*, %struct.list_head*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i32 ()*, i32 ()*, i32, %struct.nla_policy*, i32 (%struct.net_device*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**, %struct.netlink_ext_ack*)*, i64 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*, %struct.net_device*)*, %struct.net* (%struct.net_device*)*, i64 (%struct.net_device*, i32)*, i32 (%struct.sk_buff*, %struct.net_device*, i32*, i32)* }
%struct.phy_device = type opaque
%struct.sfp_bus = type opaque
%struct.udp_tunnel_nic_info = type opaque
%struct.udp_tunnel_nic = type opaque
%struct.bpf_xdp_entity = type { %struct.bpf_prog*, %struct.bpf_xdp_link* }
%struct.bpf_xdp_link = type opaque
%struct.netns_core = type { %struct.ctl_table_header*, i32, i32*, %struct.prot_inuse* }
%struct.prot_inuse = type opaque
%struct.netns_mib = type { %struct.tcp_mib*, %struct.ipstats_mib*, %struct.linux_mib*, %struct.udp_mib*, %struct.udp_mib*, %struct.icmp_mib*, %struct.icmpmsg_mib*, %struct.proc_dir_entry*, %struct.udp_mib*, %struct.udp_mib*, %struct.ipstats_mib*, %union.anon.154*, %struct.icmpmsg_mib* }
%struct.tcp_mib = type { [16 x i64] }
%struct.linux_mib = type { [124 x i64] }
%struct.icmp_mib = type { [28 x i64] }
%struct.udp_mib = type { [9 x i64] }
%struct.ipstats_mib = type { [37 x i64], %struct.u64_stats_sync }
%struct.icmpmsg_mib = type { [512 x %struct.atomic64_t] }
%struct.netns_packet = type { %struct.mutex, %struct.hlist_head }
%struct.netns_unix = type { i32, %struct.ctl_table_header* }
%struct.netns_nexthop = type { %struct.rb_root, %struct.hlist_head*, i32, i32, %struct.blocking_notifier_head }
%struct.blocking_notifier_head = type { %struct.rw_semaphore, %struct.notifier_block* }
%struct.netns_ipv4 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ipv4_devconf*, %struct.ipv4_devconf*, %struct.ip_ra_chain*, %struct.mutex, %struct.fib_rules_ops*, i8, i32, %struct.fib_table*, %struct.fib_table*, i8, %struct.hlist_head*, i8, %struct.sock*, %struct.sock**, %struct.sock*, %struct.inet_peer_base*, %struct.sock**, %struct.fqdir*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, i32, i32, i32, i32, i32, i32, %struct.local_ports, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [3 x i32], [3 x i32], i32, i64, i64, [48 x i8], %struct.inet_timewait_death_row, i32, i32, %struct.tcp_congestion_ops*, %struct.tcp_fastopen_context*, %struct.spinlock, i32, %struct.atomic_t, i64, i32, i32, i32, i32, i32, i32, i32, %struct.ping_group_range, %struct.atomic_t, i64*, i32, %struct.mr_table*, i32, i32, %struct.fib_notifier_ops*, i32, %struct.fib_notifier_ops*, i32, %struct.atomic_t, %struct.siphash_key_t, [16 x i8] }
%struct.ipv4_devconf = type opaque
%struct.ip_ra_chain = type opaque
%struct.fib_rules_ops = type opaque
%struct.fib_table = type opaque
%struct.inet_peer_base = type opaque
%struct.fqdir = type { i64, i64, i32, i32, %struct.inet_frags*, %struct.net*, i8, [23 x i8], %struct.rhashtable, [56 x i8], %struct.atomic64_t, %struct.work_struct, [24 x i8] }
%struct.inet_frags = type { i32, void (%struct.inet_frag_queue*, i8*)*, void (%struct.inet_frag_queue*)*, void (%struct.timer_list*)*, %struct.kmem_cache*, i8*, %struct.rhashtable_params, %union.anon.0, %struct.completion }
%struct.inet_frag_queue = type { %struct.rhash_head, %union.anon.54, %struct.timer_list, %struct.spinlock, %union.anon.0, %struct.rb_root, %struct.sk_buff*, %struct.sk_buff*, i64, i32, i32, i8, i16, %struct.fqdir*, %struct.callback_head }
%struct.rhash_head = type { %struct.rhash_head* }
%union.anon.54 = type { %struct.frag_v6_compare_key }
%struct.frag_v6_compare_key = type { %struct.in6_addr, %struct.in6_addr, i32, i32, i32 }
%struct.in6_addr = type { %union.anon.55 }
%union.anon.55 = type { [4 x i32] }
%struct.rhashtable_params = type { i16, i16, i16, i16, i32, i16, i8, i32 (i8*, i32, i32)*, i32 (i8*, i32, i32)*, i32 (%struct.rhashtable_compare_arg*, i8*)* }
%struct.rhashtable_compare_arg = type { %struct.rhashtable*, i8* }
%struct.rhashtable = type { %struct.bucket_table*, i32, i32, %struct.rhashtable_params, i8, %struct.work_struct, %struct.mutex, %struct.spinlock, %struct.atomic_t }
%struct.bucket_table = type opaque
%struct.xt_table = type opaque
%struct.local_ports = type { %struct.seqlock_t, [2 x i32], i8 }
%struct.inet_timewait_death_row = type { %struct.atomic_t, [60 x i8], %struct.inet_hashinfo*, i32, [52 x i8] }
%struct.inet_hashinfo = type opaque
%struct.tcp_congestion_ops = type opaque
%struct.tcp_fastopen_context = type opaque
%struct.ping_group_range = type { %struct.seqlock_t, [2 x %struct.atomic_t] }
%struct.mr_table = type opaque
%struct.fib_notifier_ops = type opaque
%struct.siphash_key_t = type { [2 x i64] }
%struct.netns_ipv6 = type { %struct.netns_sysctl_ipv6, %struct.ipv6_devconf*, %struct.ipv6_devconf*, %struct.inet_peer_base*, %struct.fqdir*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.fib6_info*, %struct.rt6_info*, %struct.rt6_statistics*, %struct.timer_list, %struct.hlist_head*, %struct.fib6_table*, %struct.list_head, [16 x i8], %struct.dst_ops, %struct.rwlock_t, %struct.spinlock, i32, i64, %struct.sock**, %struct.sock*, %struct.sock*, %struct.sock*, %struct.sock*, %struct.atomic_t, %struct.atomic_t, %struct.seg6_pernet_data*, %struct.fib_notifier_ops*, %struct.fib_notifier_ops*, i32, %struct.anon.70, [8 x i8] }
%struct.netns_sysctl_ipv6 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [4 x i64], i64*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8 }
%struct.ipv6_devconf = type opaque
%struct.fib6_info = type opaque
%struct.rt6_info = type opaque
%struct.rt6_statistics = type opaque
%struct.fib6_table = type opaque
%struct.dst_ops = type { i16, i32, i32 (%struct.dst_ops*)*, %struct.dst_entry* (%struct.dst_entry*, i32)*, i32 (%struct.dst_entry*)*, i32 (%struct.dst_entry*)*, i32* (%struct.dst_entry*, i64)*, void (%struct.dst_entry*)*, void (%struct.dst_entry*, %struct.net_device*, i32)*, %struct.dst_entry* (%struct.dst_entry*)*, void (%struct.sk_buff*)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*, i32, i1)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*)*, i32 (%struct.net*, %struct.sock*, %struct.sk_buff*)*, %struct.neighbour* (%struct.dst_entry*, %struct.sk_buff*, i8*)*, void (%struct.dst_entry*, i8*)*, %struct.kmem_cache*, %struct.percpu_counter, [24 x i8] }
%struct.dst_entry = type opaque
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %union.anon.0, %struct.qspinlock }
%struct.seg6_pernet_data = type opaque
%struct.anon.70 = type { %struct.hlist_head, %struct.spinlock, i32 }
%struct.netns_nf = type { %struct.proc_dir_entry*, %struct.nf_queue_handler*, [13 x %struct.nf_logger*], %struct.ctl_table_header*, [5 x %struct.nf_hook_entries*], [5 x %struct.nf_hook_entries*], i8, i8 }
%struct.nf_queue_handler = type opaque
%struct.nf_logger = type opaque
%struct.netns_xt = type { [13 x %struct.list_head], i8, i8 }
%struct.netns_ct = type { %struct.atomic_t, i32, i8, %struct.ctl_table_header*, i32, i32, i32, i32, i32, i32, %struct.ct_pcpu*, %struct.ip_conntrack_stat*, %struct.nf_ct_event_notifier*, %struct.nf_exp_event_notifier*, %struct.nf_ip_net }
%struct.ct_pcpu = type { %struct.spinlock, %struct.hlist_nulls_head, %struct.hlist_nulls_head }
%struct.hlist_nulls_head = type { %struct.hlist_nulls_node* }
%struct.hlist_nulls_node = type { %struct.hlist_nulls_node*, %struct.hlist_nulls_node** }
%struct.ip_conntrack_stat = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.nf_ct_event_notifier = type opaque
%struct.nf_exp_event_notifier = type opaque
%struct.nf_ip_net = type { %struct.atomic_t, %struct.nf_tcp_net, %struct.kernel_cap_struct, %struct.atomic_t, %struct.atomic_t }
%struct.nf_tcp_net = type { [14 x i32], i32, i32, i32 }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.netns_nf_frag = type { %struct.fqdir* }
%struct.net_generic = type opaque
%struct.netns_bpf = type { [2 x %struct.bpf_prog_array*], [2 x %struct.bpf_prog*], [2 x %struct.list_head] }
%struct.bpf_prog_array = type { %struct.callback_head, [0 x %struct.bpf_prog_array_item] }
%struct.bpf_prog_array_item = type { %struct.bpf_prog*, [2 x %struct.bpf_cgroup_storage*] }
%struct.bpf_cgroup_storage = type opaque
%struct.netns_xfrm = type { %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, %struct.hlist_head*, i32, i32, %struct.work_struct, %struct.list_head, %struct.hlist_head*, i32, [3 x %struct.hlist_head], [3 x %struct.xfrm_policy_hash], [6 x i32], %struct.work_struct, %struct.xfrm_policy_hthresh, %struct.list_head, %struct.sock*, %struct.sock*, i32, i32, i32, i32, %struct.ctl_table_header*, [40 x i8], %struct.dst_ops, %struct.dst_ops, %struct.spinlock, %struct.spinlock, %struct.mutex, [24 x i8] }
%struct.xfrm_policy_hash = type { %struct.hlist_head*, i32, i8, i8, i8, i8 }
%struct.xfrm_policy_hthresh = type { %struct.work_struct, %struct.seqlock_t, i8, i8, i8, i8 }
%struct.sock = type opaque
%struct.time_namespace = type opaque
%struct.cgroup_namespace = type { %union.anon.0, %struct.ns_common, %struct.user_namespace*, %struct.ucounts*, %struct.css_set* }
%struct.signal_struct = type { %union.anon.0, %struct.atomic_t, i32, %struct.list_head, %struct.wait_queue_head, %struct.task_struct*, %struct.sigpending, %struct.hlist_head, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.tnum], %struct.thread_group_cputimer, %struct.posix_cputimers, [4 x %struct.pid*], %struct.pid*, i32, %struct.tty_struct*, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.tnum], %struct.pacct_struct, %struct.taskstats*, i32, %struct.tty_audit_buf*, i8, i16, i16, %struct.mm_struct*, %struct.mutex, %struct.mutex }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic }
%struct.task_cputime_atomic = type { %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t }
%struct.tty_struct = type opaque
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type { i16, i32, i8, i8, i64, i64, i64, i64, i64, i64, i64, i64, [32 x i8], i8, [3 x i8], [4 x i8], i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.spinlock, %union.anon.0, %struct.wait_queue_head, [64 x %struct.k_sigaction] }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.cpumask }
%struct.sigpending = type { %struct.list_head, %struct.cpumask }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.atomic_t, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root_cached = type { %struct.rb_root, %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type { %struct.atomic64_t, %struct.atomic_t, %struct.atomic_t, %struct.spinlock, i16, %struct.xarray, %struct.io_cq*, %struct.hlist_head, %struct.work_struct }
%struct.io_cq = type { %struct.request_queue*, %struct.io_context*, %struct.sysv_shm, %union.anon.92, i32 }
%struct.request_queue = type opaque
%struct.capture_control = type opaque
%struct.kernel_siginfo = type { %struct.anon.93 }
%struct.anon.93 = type { i32, i32, i32, %union.__sifields }
%union.__sifields = type { %struct.anon.97 }
%struct.anon.97 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.cpumask = type { [1 x i64] }
%struct.css_set = type { [4 x %struct.cgroup_subsys_state*], %union.anon.0, %struct.css_set*, %struct.cgroup*, i32, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, [4 x %struct.list_head], %struct.list_head, %struct.list_head, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.cgroup*, %struct.cgroup*, %struct.css_set*, i8, %struct.callback_head }
%struct.cgroup_subsys_state = type { %struct.cgroup*, %struct.cgroup_subsys*, %struct.percpu_ref, %struct.list_head, %struct.list_head, %struct.list_head, i32, i32, i64, %struct.atomic_t, %struct.work_struct, %struct.rcu_work, %struct.cgroup_subsys_state* }
%struct.cgroup_subsys = type { %struct.cgroup_subsys_state* (%struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*, i32)*, i32 (%struct.seq_file*, %struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_taskset*)*, void (%struct.cgroup_taskset*)*, void (%struct.cgroup_taskset*)*, void ()*, i32 (%struct.task_struct*, %struct.css_set*)*, void (%struct.task_struct*, %struct.css_set*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.cgroup_subsys_state*)*, i8, i32, i8*, i8*, %struct.cgroup_root*, %struct.idr, %struct.list_head, %struct.cftype*, %struct.cftype*, i32 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.cgroup_taskset = type opaque
%struct.cgroup_root = type { %struct.kernfs_root*, i32, i32, %struct.cgroup, i64, %struct.atomic_t, %struct.list_head, i32, [4096 x i8], [64 x i8] }
%struct.kernfs_root = type { %struct.kernfs_node*, i32, %struct.idr, i32, i32, %struct.kernfs_syscall_ops*, %struct.list_head, %struct.wait_queue_head }
%struct.kernfs_syscall_ops = type { i32 (%struct.seq_file*, %struct.kernfs_root*)*, i32 (%struct.kernfs_node*, i8*, i16)*, i32 (%struct.kernfs_node*)*, i32 (%struct.kernfs_node*, %struct.kernfs_node*, i8*)*, i32 (%struct.seq_file*, %struct.kernfs_node*, %struct.kernfs_root*)* }
%struct.cgroup = type { %struct.cgroup_subsys_state, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernfs_node*, %struct.cgroup_file, %struct.cgroup_file, i16, i16, i16, i16, [4 x %struct.cgroup_subsys_state*], %struct.cgroup_root*, %struct.list_head, [4 x %struct.list_head], %struct.cgroup*, %struct.cgroup*, %struct.cgroup_rstat_cpu*, %struct.list_head, %struct.cgroup_base_stat, %struct.cgroup_base_stat, %struct.prev_cputime, %struct.list_head, %struct.mutex, %struct.wait_queue_head, %struct.work_struct, %struct.u64_stats_sync, %struct.u64_stats_sync, %struct.atomic_t, %struct.cgroup_freezer_state, [0 x i64] }
%struct.cgroup_file = type { %struct.kernfs_node*, i64, %struct.timer_list }
%struct.cgroup_rstat_cpu = type { %struct.u64_stats_sync, %struct.cgroup_base_stat, %struct.cgroup_base_stat, %struct.cgroup*, %struct.cgroup* }
%struct.cgroup_base_stat = type { %struct.task_cputime }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cgroup_freezer_state = type { i8, i32, i32, i32 }
%struct.cftype = type { [64 x i8], i64, i64, i32, i32, %struct.cgroup_subsys*, %struct.list_head, %struct.kernfs_ops*, i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.poll_table_struct*)* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.poll_table_struct*)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.poll_table_struct = type opaque
%struct.percpu_ref = type { i64, %struct.percpu_ref_data* }
%struct.percpu_ref_data = type { %struct.atomic64_t, void (%struct.percpu_ref*)*, void (%struct.percpu_ref*)*, i8, %struct.callback_head, %struct.percpu_ref* }
%struct.rcu_work = type { %struct.work_struct, %struct.callback_head, %struct.workqueue_struct* }
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.atomic_t, i32, i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type { %struct.pmu*, %struct.raw_spinlock, %struct.mutex, %struct.list_head, %struct.perf_event_groups, %struct.perf_event_groups, %struct.list_head, %struct.list_head, %struct.list_head, i32, i32, i32, i32, i32, i32, i32, %union.anon.0, %struct.task_struct*, i64, i64, %struct.perf_event_context*, i64, i64, i32, i8*, %struct.callback_head }
%struct.pmu = type { %struct.list_head, %struct.module*, %struct.device*, %struct.attribute_group**, %struct.attribute_group**, i8*, i32, i32, i32*, %struct.perf_cpu_context*, %struct.atomic_t, i32, i32, i32, void (%struct.pmu*)*, void (%struct.pmu*)*, i32 (%struct.perf_event*)*, void (%struct.perf_event*, %struct.mm_struct*)*, void (%struct.perf_event*, %struct.mm_struct*)*, i32 (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*, i32)*, void (%struct.perf_event*)*, void (%struct.pmu*, i32)*, i32 (%struct.pmu*)*, void (%struct.pmu*)*, i32 (%struct.perf_event*)*, void (%struct.perf_event_context*, i1)*, %struct.kmem_cache*, void (%struct.perf_event_context*, %struct.perf_event_context*)*, i8* (%struct.perf_event*, i8**, i32, i1)*, void (i8*)*, i64 (%struct.perf_event*, %struct.perf_output_handle*, i64)*, i32 (%struct.list_head*)*, void (%struct.perf_event*)*, i32 (%struct.perf_event*)*, i32 (%struct.perf_event*)*, i32 (%struct.perf_event*, i64)* }
%struct.perf_cpu_context = type { %struct.perf_event_context, %struct.perf_event_context*, i32, i32, %struct.raw_spinlock, %struct.hrtimer, i64, i32, i32, i32, i32, %struct.perf_event**, [2 x %struct.perf_event*] }
%struct.perf_event = type { %struct.list_head, %struct.list_head, %struct.list_head, %struct.rb_node, i64, %struct.list_head, %struct.hlist_node, %struct.list_head, i32, i32, i32, %struct.perf_event*, %struct.pmu*, i8*, i32, i32, %struct.local64_t, %struct.atomic64_t, i64, i64, i64, i64, %struct.perf_event_attr, i16, i16, i16, %struct.hw_perf_event, %struct.perf_event_context*, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t, %struct.mutex, %struct.list_head, %struct.perf_event*, i32, i32, %struct.list_head, %struct.task_struct*, %struct.mutex, %struct.atomic_t, %struct.perf_buffer*, %struct.list_head, i64, i32, %struct.wait_queue_head, %struct.fasync_struct*, i32, i32, i32, %struct.irq_work, %struct.atomic_t, %struct.perf_addr_filters_head, %struct.tnum*, i64, %struct.perf_event*, void (%struct.perf_event*)*, %struct.callback_head, %struct.pid_namespace*, i64, i64 ()*, void (%struct.perf_event*, %struct.perf_sample_data*, %struct.pt_regs*)*, i8*, void (%struct.perf_event*, %struct.perf_sample_data*, %struct.pt_regs*)*, %struct.bpf_prog*, %struct.trace_event_call*, %struct.event_filter*, i8*, %struct.list_head }
%struct.local64_t = type { %struct.local_t }
%struct.perf_event_attr = type { i32, i32, i64, %struct.atomic64_t, i64, i64, i64, %struct.atomic_t, i32, %struct.atomic64_t, %struct.atomic64_t, i64, i64, i32, i32, i64, i32, i16, i16, i32, i32 }
%struct.hw_perf_event = type { %union.anon.108, %struct.task_struct*, i8*, i64, i32, %struct.local64_t, i64, %union.anon.115, i64, i64, i64, i64 }
%union.anon.108 = type { %struct.anon.109 }
%struct.anon.109 = type { i64, i64, i64, i64, i32, i32, i32, i32, %struct.hw_perf_event_extra, %struct.hw_perf_event_extra }
%struct.hw_perf_event_extra = type { i64, i32, i32, i32 }
%union.anon.115 = type { %struct.anon.116 }
%struct.anon.116 = type { i64, %struct.local64_t }
%struct.perf_buffer = type opaque
%struct.fasync_struct = type { %struct.rwlock_t, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.irq_work = type { %union.anon.118, void (%struct.irq_work*)* }
%union.anon.118 = type { %struct.__call_single_node }
%struct.perf_addr_filters_head = type { %struct.list_head, %struct.raw_spinlock, i32 }
%struct.perf_sample_data = type { i64, %struct.perf_raw_record*, %struct.perf_branch_stack*, i64, i64, i64, %struct.atomic64_t, i64, i64, %struct.util_est, i64, i64, i64, %struct.util_est, %struct.perf_callchain_entry*, i64, %struct.perf_regs, %struct.perf_regs, i64, i64, i64, [8 x i8] }
%struct.perf_raw_record = type { %struct.perf_raw_frag, i32 }
%struct.perf_raw_frag = type <{ %union.anon.120, i64 (i8*, i8*, i64, i64)*, i8*, i32 }>
%union.anon.120 = type { %struct.perf_raw_frag* }
%struct.perf_branch_stack = type { i64, i64, [0 x %struct.task_cputime] }
%struct.perf_callchain_entry = type { i64, [0 x i64] }
%struct.perf_regs = type { i64, %struct.pt_regs* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.trace_event_call = type opaque
%struct.event_filter = type opaque
%struct.perf_output_handle = type { %struct.perf_event*, %struct.perf_buffer*, i64, i64, i64, %union.anon.152, i32 }
%struct.perf_event_groups = type { %struct.rb_root, i64 }
%struct.rseq = type { i32, i32, %struct.atomic64_t, i32, [12 x i8] }
%struct.tlbflush_unmap_batch = type { %struct.arch_tlbflush_unmap_batch, i8, i8 }
%struct.arch_tlbflush_unmap_batch = type { %struct.cpumask }
%struct.pipe_inode_info = type { %struct.mutex, %struct.wait_queue_head, %struct.wait_queue_head, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.page*, %struct.fasync_struct*, %struct.fasync_struct*, %struct.pipe_buffer*, %struct.user_struct* }
%struct.page = type { i64, %union.anon.72, %union.anon.0, %struct.atomic_t, [8 x i8] }
%union.anon.72 = type { %struct.anon.73 }
%struct.anon.73 = type { %struct.list_head, %struct.address_space*, i64, i64 }
%struct.pipe_buffer = type { %struct.page*, i32, i32, %struct.pipe_buf_operations*, i32, i64 }
%struct.pipe_buf_operations = type { i32 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, void (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, i1 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, i1 (%struct.pipe_inode_info*, %struct.pipe_buffer*)* }
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.uprobe_task = type { i32, %union.anon.127, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.127 = type { %struct.anon.128 }
%struct.anon.128 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.vm_struct = type { %struct.vm_struct*, i8*, i64, i64, %struct.page**, i32, i64, i8* }
%struct.thread_struct = type { [3 x %struct.rps_dev_flow], i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.io_bitmap*, i64, i8, [47 x i8], %struct.fpu }
%struct.io_bitmap = type opaque
%struct.fpu = type { i32, i64, [48 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.130, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.133 }
%union.anon.130 = type { %struct.tnum }
%union.anon.133 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.completion = type { i32, %struct.swait_queue_head }
%struct.swait_queue_head = type { %struct.raw_spinlock, %struct.list_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_subscriptions = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i64 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %struct.atomic64_t*, %struct.atomic64_t*, %struct.atomic64_t, %struct.page*, %struct.page*, %struct.atomic64_t*, %struct.spinlock*, %struct.page* }
%struct.mempolicy = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon.71, i8*, i64, i16, i16, %struct.kernfs_iattrs* }
%union.anon.71 = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.152 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type { i32, i32*, %struct.orc_entry* }
%struct.orc_entry = type { i16, i16, i16 }
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8*, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.srcu_struct = type { [5 x %struct.srcu_node], [3 x %struct.srcu_node*], %struct.mutex, %struct.spinlock, %struct.mutex, i32, i64, i64, i64, i64, %struct.srcu_data*, i64, %struct.mutex, %struct.completion, %struct.atomic_t, %struct.delayed_work }
%struct.srcu_node = type { %struct.spinlock, [4 x i64], [4 x i64], i64, %struct.srcu_node*, i32, i32 }
%struct.srcu_data = type { [2 x i64], [2 x i64], [32 x i8], %struct.spinlock, %struct.rcu_segcblist, i64, i64, i8, %struct.timer_list, %struct.work_struct, %struct.callback_head, %struct.srcu_node*, i64, i32, %struct.srcu_struct*, [16 x i8] }
%struct.rcu_segcblist = type { %struct.callback_head*, [4 x %struct.callback_head**], [4 x i64], i64, i8, i8 }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.bpf_raw_event_map = type { %struct.tracepoint*, i8*, i32, i32, [8 x i8] }
%struct.tracepoint = type { i8*, %struct.static_key, %struct.static_call_key*, i8*, i8*, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t, %struct.atomic64_t }
%struct.static_call_key = type opaque
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.jump_entry = type { i32, i32, i64 }
%struct.trace_eval_map = type opaque
%struct.u64_stats_sync = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.spinlock, %struct.atomic_t, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.0, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.shrink_control = type { i32, i32, i64, i64, %struct.mem_cgroup* }
%struct.mem_cgroup = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.atomic_t*)*, i32 (%struct.inode*, i64*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.atomic64_t, %union.anon.0, %struct.raw_spinlock, %struct.list_head }
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.rw_semaphore, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rcuwait, %struct.wait_queue_head, %struct.atomic_t }
%struct.rcu_sync = type { i32, i32, %struct.wait_queue_head, %struct.callback_head }
%struct.rcuwait = type { %struct.task_struct* }
%struct.fsnotify_mark_connector = type opaque
%union.anon.149 = type { [16 x i8] }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i64, i32, i32, %struct.list_head, %struct.atomic64_t* }
%struct.workqueue_struct = type opaque
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.atomic_t, %struct.user_namespace*, i32, %struct.atomic_t, %struct.atomic_t, %struct.ns_common, i64, %struct.list_head, %struct.key*, %struct.rw_semaphore, %struct.work_struct, %struct.ctl_table_set, %struct.ctl_table_header*, %struct.ucounts*, [10 x i32] }
%struct.uid_gid_map = type { i32, %union.anon.41 }
%union.anon.41 = type { %struct.anon.42, [48 x i8] }
%struct.anon.42 = type { %struct.bpf_ctx_arg_aux*, %struct.bpf_ctx_arg_aux* }
%struct.list_lru = type { %struct.list_lru_node* }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, i64, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.sysv_shm = type { %struct.list_head }
%union.anon.92 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.atomic_t, %struct.atomic_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %struct.atomic_t, i32, i64, %struct.tnum, %struct.tnum, %struct.tnum, %struct.spinlock, i16, i8, i8, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.30, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon.140, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.143, i32, i32, %struct.fsnotify_mark_connector*, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.tnum*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.atomic_t, %struct.atomic_t, i64, %struct.tnum, %struct.tnum, %struct.tnum, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.atomic_t, %struct.atomic_t, i64, %struct.tnum, %struct.tnum, %struct.tnum, %struct.tnum, i64, i64 }
%struct.fiemap_extent_info = type opaque
%union.anon.140 = type { %struct.file_operations* }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.xarray, i32, %struct.atomic_t, %struct.rb_root_cached, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, i32, %struct.spinlock, %struct.list_head, i8* }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, void (%struct.readahead_control*)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.readahead_control = type opaque
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32, i16, i16, %union.anon.74 }
%union.anon.74 = type { %struct.wait_page_queue* }
%struct.wait_page_queue = type opaque
%struct.iov_iter = type { i32, i64, i64, %union.anon.75, %struct.atomic64_t }
%union.anon.75 = type { %struct.iovec* }
%struct.iovec = type { i8*, i64 }
%struct.swap_info_struct = type opaque
%union.anon.143 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.kiocb*, i1)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i64, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, i64, i32)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, %struct.list_head, i8*, i32, i8, i32, i32, %struct.wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.141 }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)*, i1 (%struct.file_lock*)* }
%union.anon.141 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.atomic_t, %struct.atomic_t, i32 }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %union.anon.30 }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.atomic_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.bpf_local_storage_map = type opaque
%struct.bpf_local_storage = type opaque
%struct.bpf_iter_seq_info = type { %struct.seq_operations*, i32 (i8*, %struct.bpf_iter_aux_info*)*, void (i8*)*, i32 }
%struct.bpf_iter_aux_info = type { %struct.bpf_map* }
%struct.bpf_map_memory = type { i32, %struct.user_struct* }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.bpf_ksym = type { i64, i64, [128 x i8], %struct.list_head, %struct.latch_tree_node, i8 }
%struct.bpf_prog_ops = type { i32 (%struct.bpf_prog*, %union.bpf_attr*, %union.bpf_attr*)* }
%struct.user_struct = type { %union.anon.0, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, i64, %struct.atomic64_t, %struct.hlist_node, %struct.atomic_t, %struct.atomic64_t, %struct.ratelimit_state }
%struct.ratelimit_state = type { %struct.raw_spinlock, i32, i32, i32, i32, i64, i64 }
%struct.bpf_prog_offload = type { %struct.bpf_prog*, %struct.net_device*, %struct.bpf_offload_dev*, i8*, %struct.list_head, i8, i8, i8*, i32 }
%struct.bpf_offload_dev = type opaque
%struct.bpf_func_info_aux = type { i16, i8 }
%struct.ethtool_pauseparam = type { i32, i32, i32, i32 }
%struct.bpf_ctx_arg_aux = type { i32, i32, i32 }
%struct.bpf_prog_stats = type { i64, i64, %struct.u64_stats_sync }
%union.anon.167 = type { %struct.work_struct }
%struct.sock_fprog_kern = type { i16, %struct.sock_filter* }
%struct.sock_filter = type { i16, i8, i8, i32 }
%struct.bpf_insn_access_aux = type { i32, %struct.atomic_t, %struct.bpf_verifier_log* }
%struct.bpf_verifier_log = type { i32, [1024 x i8], i8*, i32, i32 }
%struct.btf_id_set = type { i32, [0 x i32] }
%struct.bpf_reg_types = type { [10 x i32], i32* }
%struct.bpf_verifier_env = type { i32, i32, %struct.bpf_prog*, %struct.bpf_verifier_ops*, %struct.bpf_verifier_stack_elem*, i32, i8, i8, %struct.bpf_verifier_state*, %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*, [64 x %struct.bpf_map*], i32, i32, i8, i8, i8, i8, i8, i8, %struct.bpf_insn_aux_data*, %struct.ethtool_pauseparam*, %struct.bpf_verifier_log, [257 x %struct.bpf_subprog_info], %struct.anon.178, i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32 }
%struct.bpf_verifier_stack_elem = type { %struct.bpf_verifier_state, i32, i32, %struct.bpf_verifier_stack_elem*, i32 }
%struct.bpf_verifier_state = type { [8 x %struct.bpf_func_state*], %struct.bpf_verifier_state*, i32, i32, i32, i32, i8, i32, i32, %struct.util_est*, i32 }
%struct.bpf_func_state = type { [11 x %struct.bpf_reg_state], i32, i32, i32, i32, %struct.util_est*, i32, %struct.bpf_stack_state* }
%struct.bpf_reg_state = type { i32, %struct.bpf_iter_aux_info, i32, i32, i32, %struct.tnum, i64, i64, i64, i64, i32, i32, i32, i32, %struct.bpf_reg_state*, i32, i32, i32, i8 }
%struct.bpf_stack_state = type { %struct.bpf_reg_state, [8 x i8] }
%struct.bpf_verifier_state_list = type { %struct.bpf_verifier_state, %struct.bpf_verifier_state_list*, i32, i32 }
%struct.bpf_insn_aux_data = type { %struct.atomic64_t, i64, i32, i32, i32, i8, i8, i32, i8 }
%struct.bpf_subprog_info = type { i32, i32, i16, i8, i8, i8 }
%struct.anon.178 = type { i32*, i32*, i32 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.bpf_attach_target_info = type { %struct.btf_func_model, i64, i8*, %struct.btf_type* }
%struct.fd = type { %struct.file*, i32 }
%struct.bpf_array = type { %struct.bpf_map, i32, i32, %struct.bpf_array_aux*, %union.anon.179, [48 x i8] }
%struct.bpf_array_aux = type { i32, i8, %struct.list_head, %struct.bpf_map*, %struct.mutex, %struct.work_struct }
%union.anon.179 = type { [0 x i8*] }
%struct.bpf_insn_cbs = type { void (i8*, i8*, ...)*, i8* (i8*, %struct.bpf_insn*)*, i8* (i8*, %struct.bpf_insn*, i64)*, i8* }
%struct.bpf_call_arg_meta = type { %struct.bpf_map*, i8, i8, i32, i32, i32, i64, i32, i32, i32, i32 }
%struct.bpf_struct_ops = type { %struct.bpf_verifier_ops*, i32 (%struct.btf*)*, i32 (%struct.btf_type*, %struct.bpf_ctx_arg_aux*)*, i32 (%struct.btf_type*, %struct.bpf_ctx_arg_aux*, i8*, i8*)*, i32 (i8*)*, void (i8*)*, %struct.btf_type*, %struct.btf_type*, i8*, [64 x %struct.btf_func_model], i32, i32 }

@llvm.compiler.used = appending global [2 x i8*] [i8* bitcast (i8** @__UNIQUE_ID___addressable_tnum_strn0 to i8*), i8* bitcast (i8** @__UNIQUE_ID___addressable_bpf_verifier_log_write374 to i8*)], section "llvm.metadata"
@.str = private unnamed_addr constant [15 x i8] c"(%#llx; %#llx)\00", align 1
@__UNIQUE_ID___addressable_tnum_strn0 = internal global i8* bitcast (i32 (i8*, i64, i64, i64)* @tnum_strn to i8*), section ".discard.addressable", align 8
@bpf_verifier_vlog.__warned = internal global i8 0, section ".data.once", align 1
@.str.2 = private unnamed_addr constant [54 x i8] c"verifier log line truncated - local buffer too short\0A\00", align 1
@.str.1 = private unnamed_addr constant [22 x i8] c"kernel/bpf/verifier.c\00", align 1
@.str.2.3 = private unnamed_addr constant [10 x i8] c"\013BPF:%s\0A\00", align 1
@__UNIQUE_ID___addressable_bpf_verifier_log_write374 = internal global i8* bitcast (void (%struct.bpf_verifier_env*, i8*, ...)* @bpf_verifier_log_write to i8*), section ".discard.addressable", align 8
@btf_vmlinux = dso_local global %struct.btf* null, align 8
@.str.3 = private unnamed_addr constant [55 x i8] c"dereference of modified ctx ptr R%d off=%d disallowed\0A\00", align 1
@.str.4 = private unnamed_addr constant [43 x i8] c"variable ctx access var_off=%s disallowed\0A\00", align 1
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD.insn = private unnamed_addr constant %struct.bpf_insn { i8 15, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB.insn = private unnamed_addr constant %struct.bpf_insn { i8 31, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_OR.insn = private unnamed_addr constant %struct.bpf_insn { i8 79, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_AND.insn = private unnamed_addr constant %struct.bpf_insn { i8 95, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH.insn = private unnamed_addr constant %struct.bpf_insn { i8 111, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH.insn = private unnamed_addr constant %struct.bpf_insn { i8 127, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR.insn = private unnamed_addr constant %struct.bpf_insn { i8 -81, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH.insn = private unnamed_addr constant %struct.bpf_insn { i8 -49, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 12, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 28, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_OR_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 76, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_AND_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 92, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 108, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 124, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 -84, i8 33, i16 0, i32 0 }, align 4
@__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH_32.insn = private unnamed_addr constant %struct.bpf_insn { i8 -52, i8 33, i16 0, i32 0 }, align 4
@__const.bpf_check_attach_target.prefix = private unnamed_addr constant [11 x i8] c"btf_trace_\00", align 1
@.str.5 = private unnamed_addr constant [38 x i8] c"Tracing programs must provide btf_id\0A\00", align 1
@.str.6 = private unnamed_addr constant [81 x i8] c"FENTRY/FEXIT program can only be attached to another program annotated with BTF\0A\00", align 1
@.str.7 = private unnamed_addr constant [29 x i8] c"attach_btf_id %u is invalid\0A\00", align 1
@.str.8 = private unnamed_addr constant [38 x i8] c"attach_btf_id %u doesn't have a name\0A\00", align 1
@.str.9 = private unnamed_addr constant [26 x i8] c"Subprog %s doesn't exist\0A\00", align 1
@.str.10 = private unnamed_addr constant [33 x i8] c"Cannot replace static functions\0A\00", align 1
@.str.11 = private unnamed_addr constant [36 x i8] c"Extension programs should be JITed\0A\00", align 1
@.str.12 = private unnamed_addr constant [32 x i8] c"Can attach to only JITed progs\0A\00", align 1
@.str.13 = private unnamed_addr constant [27 x i8] c"Cannot recursively attach\0A\00", align 1
@.str.14 = private unnamed_addr constant [28 x i8] c"Cannot extend fentry/fexit\0A\00", align 1
@.str.15 = private unnamed_addr constant [33 x i8] c"Cannot replace kernel functions\0A\00", align 1
@.str.16 = private unnamed_addr constant [60 x i8] c"Only FENTRY/FEXIT progs are attachable to another BPF prog\0A\00", align 1
@.str.17 = private unnamed_addr constant [35 x i8] c"attach_btf_id %u is not a typedef\0A\00", align 1
@.str.18 = private unnamed_addr constant [47 x i8] c"attach_btf_id %u points to wrong type name %s\0A\00", align 1
@.str.19 = private unnamed_addr constant [36 x i8] c"attach_btf_id %u is not a function\0A\00", align 1
@.str.20 = private unnamed_addr constant [44 x i8] c"The address of function %s cannot be found\0A\00", align 1
@.str.21 = private unnamed_addr constant [21 x i8] c"%s is not sleepable\0A\00", align 1
@.str.22 = private unnamed_addr constant [43 x i8] c"can't modify return codes of BPF programs\0A\00", align 1
@.str.23 = private unnamed_addr constant [24 x i8] c"%s() is not modifiable\0A\00", align 1
@bpf_verifier_lock = internal global %struct.mutex { %struct.atomic64_t zeroinitializer, %struct.spinlock zeroinitializer, %union.anon.0 zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @bpf_verifier_lock to i8*), i64 16) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @bpf_verifier_lock to i8*), i64 16) to %struct.list_head*) } }, align 8
@bpf_verifier_ops = internal constant [31 x %struct.bpf_verifier_ops*] [%struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_filter_verifier_ops, %struct.bpf_verifier_ops* @kprobe_verifier_ops, %struct.bpf_verifier_ops* @tc_cls_act_verifier_ops, %struct.bpf_verifier_ops* @tc_cls_act_verifier_ops, %struct.bpf_verifier_ops* @tracepoint_verifier_ops, %struct.bpf_verifier_ops* @xdp_verifier_ops, %struct.bpf_verifier_ops* @perf_event_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @lwt_in_verifier_ops, %struct.bpf_verifier_ops* @lwt_out_verifier_ops, %struct.bpf_verifier_ops* @lwt_xmit_verifier_ops, %struct.bpf_verifier_ops* @sock_ops_verifier_ops, %struct.bpf_verifier_ops* @sk_skb_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_msg_verifier_ops, %struct.bpf_verifier_ops* @raw_tracepoint_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @lwt_seg6local_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_reuseport_verifier_ops, %struct.bpf_verifier_ops* @flow_dissector_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @raw_tracepoint_writable_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @tracing_verifier_ops, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* null, %struct.bpf_verifier_ops* @sk_lookup_verifier_ops], align 16
@.str.24 = private unnamed_addr constant [28 x i8] c"in-kernel BTF is malformed\0A\00", align 1
@.str.25 = private unnamed_addr constant [28 x i8] c"include/linux/thread_info.h\00", align 1
@.str.26 = private unnamed_addr constant [38 x i8] c"Buffer overflow detected (%d < %lu)!\0A\00", align 1
@.str.27 = private unnamed_addr constant [53 x i8] c"R%d tried to add from different pointers or scalars\0A\00", align 1
@.str.28 = private unnamed_addr constant [53 x i8] c"R%d tried to sub from different pointers or scalars\0A\00", align 1
@tnum_unknown = dso_local constant %struct.tnum { i64 0, i64 -1 }, align 8
@reg_set_min_max_inv.opcode_flip = internal constant [16 x i8] c"\00\10\A0\B0@P\C0\D0\00\00 0`p\00\00", align 16
@btf_non_sleepable_error_inject = internal global %struct.btf_id_set zeroinitializer, align 4
@btf_sleepable_lsm_hooks = internal global %struct.btf_id_set zeroinitializer, align 4
@.str.29 = private unnamed_addr constant [10 x i8] c"security_\00", align 1
@kmalloc_caches = external dso_local global [3 x [14 x %struct.kmem_cache*]], align 16
@.str.30 = private unnamed_addr constant [21 x i8] c"include/linux/slab.h\00", align 1
@sk_filter_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@kprobe_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@tc_cls_act_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@tracepoint_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@xdp_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@perf_event_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_in_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_out_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_xmit_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sock_ops_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_skb_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_msg_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@raw_tracepoint_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@lwt_seg6local_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_reuseport_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@flow_dissector_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@raw_tracepoint_writable_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@tracing_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@sk_lookup_verifier_ops = external dso_local constant %struct.bpf_verifier_ops, align 8
@.str.31 = private unnamed_addr constant [81 x i8] c"function calls to other bpf functions are allowed for CAP_BPF and CAP_SYS_ADMIN\0A\00", align 1
@.str.32 = private unnamed_addr constant [13 x i8] c"func#%d @%d\0A\00", align 1
@.str.33 = private unnamed_addr constant [38 x i8] c"jump out of range from insn %d to %d\0A\00", align 1
@.str.34 = private unnamed_addr constant [33 x i8] c"last insn is not an exit or jmp\0A\00", align 1
@.str.35 = private unnamed_addr constant [29 x i8] c"call to invalid destination\0A\00", align 1
@.str.36 = private unnamed_addr constant [22 x i8] c"too many subprograms\0A\00", align 1
@.str.37 = private unnamed_addr constant [47 x i8] c"LD_ABS is not allowed in subprogs without BTF\0A\00", align 1
@.str.38 = private unnamed_addr constant [50 x i8] c"tail_call is not allowed in subprogs without BTF\0A\00", align 1
@.str.39 = private unnamed_addr constant [63 x i8] c"number of funcs in func_info doesn't match number of subprogs\0A\00", align 1
@.str.40 = private unnamed_addr constant [31 x i8] c"invalid func info rec size %u\0A\00", align 1
@.str.41 = private unnamed_addr constant [36 x i8] c"nonzero tailing record in func info\00", align 1
@.str.42 = private unnamed_addr constant [51 x i8] c"nonzero insn_off %u for the first func info record\00", align 1
@.str.43 = private unnamed_addr constant [69 x i8] c"same or smaller insn offset (%u) than previous func info record (%u)\00", align 1
@.str.44 = private unnamed_addr constant [67 x i8] c"func_info BTF section doesn't match subprog layout in BPF program\0A\00", align 1
@.str.45 = private unnamed_addr constant [32 x i8] c"invalid type id %d in func info\00", align 1
@.str.46 = private unnamed_addr constant [56 x i8] c"LD_ABS is only allowed in functions that return 'int'.\0A\00", align 1
@.str.47 = private unnamed_addr constant [59 x i8] c"tail_call is only allowed in functions that return 'int'.\0A\00", align 1
@.str.48 = private unnamed_addr constant [36 x i8] c"nonzero tailing record in line_info\00", align 1
@.str.49 = private unnamed_addr constant [65 x i8] c"Invalid line_info[%u].insn_off:%u (prev_offset:%u prog->len:%u)\0A\00", align 1
@.str.50 = private unnamed_addr constant [45 x i8] c"Invalid insn code at line_info[%u].insn_off\0A\00", align 1
@.str.51 = private unnamed_addr constant [50 x i8] c"Invalid line_info[%u].line_off or .file_name_off\0A\00", align 1
@.str.52 = private unnamed_addr constant [35 x i8] c"missing bpf_line_info for func#%u\0A\00", align 1
@.str.53 = private unnamed_addr constant [58 x i8] c"missing bpf_line_info for %u funcs starting from func#%u\0A\00", align 1
@.str.54 = private unnamed_addr constant [62 x i8] c"Only fentry/fexit/fmod_ret and lsm programs can be sleepable\0A\00", align 1
@.str.55 = private unnamed_addr constant [44 x i8] c"attach_btf_id %u is not a supported struct\0A\00", align 1
@.str.56 = private unnamed_addr constant [46 x i8] c"attach to invalid member idx %u of struct %s\0A\00", align 1
@.str.57 = private unnamed_addr constant [51 x i8] c"attach to invalid member %s(@idx %u) of struct %s\0A\00", align 1
@.str.58 = private unnamed_addr constant [46 x i8] c"attach to unsupported member %s of struct %s\0A\00", align 1
@.str.59 = private unnamed_addr constant [30 x i8] c"BPF_LDX uses reserved fields\0A\00", align 1
@.str.60 = private unnamed_addr constant [30 x i8] c"BPF_STX uses reserved fields\0A\00", align 1
@.str.61 = private unnamed_addr constant [27 x i8] c"invalid bpf_ld_imm64 insn\0A\00", align 1
@.str.62 = private unnamed_addr constant [32 x i8] c"unrecognized bpf_ld_imm64 insn\0A\00", align 1
@.str.63 = private unnamed_addr constant [40 x i8] c"fd %d is not pointing to valid bpf_map\0A\00", align 1
@.str.64 = private unnamed_addr constant [42 x i8] c"direct value offset of %u is not allowed\0A\00", align 1
@.str.65 = private unnamed_addr constant [50 x i8] c"no direct value access support for this map type\0A\00", align 1
@.str.66 = private unnamed_addr constant [59 x i8] c"invalid access to map value pointer, value_size=%u off=%u\0A\00", align 1
@.str.67 = private unnamed_addr constant [49 x i8] c"only one cgroup storage of each type is allowed\0A\00", align 1
@.str.68 = private unnamed_addr constant [21 x i8] c"unknown opcode %02x\0A\00", align 1
@.str.69 = private unnamed_addr constant [83 x i8] c"kernel is missing BTF, make sure CONFIG_DEBUG_INFO_BTF=y is specified in Kconfig.\0A\00", align 1
@.str.70 = private unnamed_addr constant [69 x i8] c"reserved field (insn[1].imm) is used in pseudo_btf_id ldimm64 insn.\0A\00", align 1
@.str.71 = private unnamed_addr constant [43 x i8] c"ldimm64 insn specifies invalid btf_id %d.\0A\00", align 1
@.str.72 = private unnamed_addr constant [45 x i8] c"pseudo btf_id %d in ldimm64 isn't KIND_VAR.\0A\00", align 1
@.str.73 = private unnamed_addr constant [60 x i8] c"ldimm64 failed to find the address for kernel symbol '%s'.\0A\00", align 1
@.str.74 = private unnamed_addr constant [14 x i8] c".data..percpu\00", align 1
@.str.75 = private unnamed_addr constant [54 x i8] c"ldimm64 unable to resolve the size of type '%s': %ld\0A\00", align 1
@.str.76 = private unnamed_addr constant [56 x i8] c"perf_event programs can only use preallocated hash map\0A\00", align 1
@check_map_prog_compatibility.__warned = internal global i8 0, section ".data.once", align 1
@.str.77 = private unnamed_addr constant [49 x i8] c"trace type BPF program uses run-time allocation\0A\00", align 1
@.str.78 = private unnamed_addr constant [101 x i8] c"trace type programs with run-time allocated hash maps are unsafe. Switch to preallocated hash maps.\0A\00", align 1
@.str.79 = private unnamed_addr constant [44 x i8] c"tracing progs cannot use bpf_spin_lock yet\0A\00", align 1
@.str.80 = private unnamed_addr constant [46 x i8] c"offload device mismatch between prog and map\0A\00", align 1
@.str.81 = private unnamed_addr constant [43 x i8] c"bpf_struct_ops map cannot be used in prog\0A\00", align 1
@.str.82 = private unnamed_addr constant [56 x i8] c"Sleepable programs can only use preallocated hash maps\0A\00", align 1
@.str.83 = private unnamed_addr constant [53 x i8] c"Sleepable programs can only use array and hash maps\0A\00", align 1
@bpf_map_offload_ops = external dso_local constant %struct.bpf_map_ops, align 8
@.str.84 = private unnamed_addr constant [24 x i8] c"pop stack internal bug\0A\00", align 1
@.str.85 = private unnamed_addr constant [21 x i8] c"unreachable insn %d\0A\00", align 1
@.str.86 = private unnamed_addr constant [5 x i8] c"%d: \00", align 1
@.str.87 = private unnamed_addr constant [30 x i8] c"back-edge from insn %d to %d\0A\00", align 1
@.str.88 = private unnamed_addr constant [25 x i8] c"insn state internal bug\0A\00", align 1
@.str.89 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@_ctype = external dso_local constant [0 x i8], align 1
@.str.90 = private unnamed_addr constant [55 x i8] c"Func#%d is safe for any args that match its prototype\0A\00", align 1
@.str.91 = private unnamed_addr constant [29 x i8] c"mark_reg_not_init(regs, %u)\0A\00", align 1
@.str.92 = private unnamed_addr constant [31 x i8] c"mark_reg_known_zero(regs, %u)\0A\00", align 1
@.str.93 = private unnamed_addr constant [28 x i8] c"mark_reg_unknown(regs, %u)\0A\00", align 1
@.str.94 = private unnamed_addr constant [33 x i8] c"invalid insn idx %d insn_cnt %d\0A\00", align 1
@.str.95 = private unnamed_addr constant [45 x i8] c"BPF program is too large. Processed %d insn\0A\00", align 1
@.str.96 = private unnamed_addr constant [24 x i8] c"\0Afrom %d to %d%s: safe\0A\00", align 1
@.str.97 = private unnamed_addr constant [25 x i8] c" (speculative execution)\00", align 1
@.str.98 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.99 = private unnamed_addr constant [10 x i8] c"%d: safe\0A\00", align 1
@.str.100 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.101 = private unnamed_addr constant [18 x i8] c"\0Afrom %d to %d%s:\00", align 1
@.str.102 = private unnamed_addr constant [3 x i8] c"; \00", align 1
@.str.103 = private unnamed_addr constant [50 x i8] c"same insn cannot be used with different pointers\0A\00", align 1
@.str.104 = private unnamed_addr constant [29 x i8] c"BPF_ST uses reserved fields\0A\00", align 1
@.str.105 = private unnamed_addr constant [42 x i8] c"BPF_ST stores into R%d %s is not allowed\0A\00", align 1
@reg_type_str = internal constant [28 x i8*] [i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.254, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.255, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.256, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.257, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.258, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.259, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.260, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.261, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.262, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.263, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.264, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.265, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.266, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.267, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.268, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.269, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.270, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.271, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.272, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.273, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.274, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.275, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.276, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.277, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.278, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.279, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.280, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.281, i32 0, i32 0)], align 16
@.str.106 = private unnamed_addr constant [31 x i8] c"BPF_CALL uses reserved fields\0A\00", align 1
@.str.107 = private unnamed_addr constant [53 x i8] c"function calls are not allowed while holding a lock\0A\00", align 1
@.str.108 = private unnamed_addr constant [29 x i8] c"BPF_JA uses reserved fields\0A\00", align 1
@.str.109 = private unnamed_addr constant [31 x i8] c"BPF_EXIT uses reserved fields\0A\00", align 1
@.str.110 = private unnamed_addr constant [28 x i8] c"bpf_spin_unlock is missing\0A\00", align 1
@.str.111 = private unnamed_addr constant [21 x i8] c"invalid BPF_LD mode\0A\00", align 1
@.str.112 = private unnamed_addr constant [23 x i8] c"unknown insn class %d\0A\00", align 1
@.str.113 = private unnamed_addr constant [35 x i8] c"infinite loop detected at insn %d\0A\00", align 1
@is_state_visited.__warned = internal global i8 0, section ".data.once", align 1
@.str.114 = private unnamed_addr constant [42 x i8] c"BUG live_done but branches_to_explore %d\0A\00", align 1
@is_state_visited.__warned.115 = internal global i8 0, section ".data.once", align 1
@.str.116 = private unnamed_addr constant [53 x i8] c"BUG is_state_visited:branches_to_explore=%d insn %d\0A\00", align 1
@.str.117 = private unnamed_addr constant [50 x i8] c"propagate_live: parent frame %d current frame %d\0A\00", align 1
@.str.118 = private unnamed_addr constant [42 x i8] c"verifier BUG type %s var_off %lld off %d\0A\00", align 1
@.str.119 = private unnamed_addr constant [17 x i8] c"propagating r%d\0A\00", align 1
@.str.120 = private unnamed_addr constant [18 x i8] c"propagating fp%d\0A\00", align 1
@__mark_chain_precision.__warned = internal global i8 0, section ".data.once", align 1
@.str.121 = private unnamed_addr constant [19 x i8] c"backtracing misuse\00", align 1
@.str.122 = private unnamed_addr constant [26 x i8] c"last_idx %d first_idx %d\0A\00", align 1
@.str.123 = private unnamed_addr constant [25 x i8] c"BUG backtracking idx %d\0A\00", align 1
@__mark_chain_precision.__warned.124 = internal global i8 0, section ".data.once", align 1
@.str.125 = private unnamed_addr constant [26 x i8] c"verifier backtracking bug\00", align 1
@.str.126 = private unnamed_addr constant [36 x i8] c"parent %s regs=%x stack=%llx marks\0A\00", align 1
@.str.127 = private unnamed_addr constant [12 x i8] c"didn't have\00", align 1
@.str.128 = private unnamed_addr constant [12 x i8] c"already had\00", align 1
@.str.129 = private unnamed_addr constant [27 x i8] c"regs=%x stack=%llx before \00", align 1
@.str.130 = private unnamed_addr constant [12 x i8] c"BUG spi %d\0A\00", align 1
@backtrack_insn.__warned = internal global i8 0, section ".data.once", align 1
@backtrack_insn.__warned.131 = internal global i8 0, section ".data.once", align 1
@.str.132 = private unnamed_addr constant [13 x i8] c"BUG regs %x\0A\00", align 1
@backtrack_insn.__warned.133 = internal global i8 0, section ".data.once", align 1
@current_task = external dso_local global %struct.task_struct*, section ".data..percpu", align 8
@.str.134 = private unnamed_addr constant [10 x i8] c" frame%d:\00", align 1
@.str.135 = private unnamed_addr constant [5 x i8] c" R%d\00", align 1
@.str.136 = private unnamed_addr constant [4 x i8] c"=%s\00", align 1
@.str.137 = private unnamed_addr constant [2 x i8] c"P\00", align 1
@.str.138 = private unnamed_addr constant [5 x i8] c"%lld\00", align 1
@.str.139 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.140 = private unnamed_addr constant [7 x i8] c"(id=%d\00", align 1
@.str.141 = private unnamed_addr constant [15 x i8] c",ref_obj_id=%d\00", align 1
@.str.142 = private unnamed_addr constant [8 x i8] c",off=%d\00", align 1
@.str.143 = private unnamed_addr constant [6 x i8] c",r=%d\00", align 1
@.str.144 = private unnamed_addr constant [13 x i8] c",ks=%d,vs=%d\00", align 1
@.str.145 = private unnamed_addr constant [10 x i8] c",imm=%llx\00", align 1
@.str.146 = private unnamed_addr constant [17 x i8] c",smin_value=%lld\00", align 1
@.str.147 = private unnamed_addr constant [17 x i8] c",smax_value=%lld\00", align 1
@.str.148 = private unnamed_addr constant [17 x i8] c",umin_value=%llu\00", align 1
@.str.149 = private unnamed_addr constant [17 x i8] c",umax_value=%llu\00", align 1
@.str.150 = private unnamed_addr constant [12 x i8] c",var_off=%s\00", align 1
@.str.151 = private unnamed_addr constant [18 x i8] c",s32_min_value=%d\00", align 1
@.str.152 = private unnamed_addr constant [18 x i8] c",s32_max_value=%d\00", align 1
@.str.153 = private unnamed_addr constant [18 x i8] c",u32_min_value=%d\00", align 1
@.str.154 = private unnamed_addr constant [18 x i8] c",u32_max_value=%d\00", align 1
@.str.155 = private unnamed_addr constant [2 x i8] c")\00", align 1
@slot_type_char = internal global [4 x i8] c"?rm0", align 1
@.str.156 = private unnamed_addr constant [6 x i8] c" fp%d\00", align 1
@.str.157 = private unnamed_addr constant [9 x i8] c" refs=%d\00", align 1
@.str.158 = private unnamed_addr constant [4 x i8] c",%d\00", align 1
@.str.159 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.160 = private unnamed_addr constant [2 x i8] c"_\00", align 1
@.str.161 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.162 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.163 = private unnamed_addr constant [2 x i8] c"D\00", align 1
@.str.164 = private unnamed_addr constant [30 x i8] c"BPF_NEG uses reserved fields\0A\00", align 1
@.str.165 = private unnamed_addr constant [30 x i8] c"BPF_END uses reserved fields\0A\00", align 1
@.str.166 = private unnamed_addr constant [35 x i8] c"R%d pointer arithmetic prohibited\0A\00", align 1
@.str.167 = private unnamed_addr constant [30 x i8] c"BPF_MOV uses reserved fields\0A\00", align 1
@.str.168 = private unnamed_addr constant [29 x i8] c"R%d partial copy of pointer\0A\00", align 1
@.str.169 = private unnamed_addr constant [27 x i8] c"invalid BPF_ALU opcode %x\0A\00", align 1
@.str.170 = private unnamed_addr constant [30 x i8] c"BPF_ALU uses reserved fields\0A\00", align 1
@.str.171 = private unnamed_addr constant [13 x i8] c"div by zero\0A\00", align 1
@.str.172 = private unnamed_addr constant [18 x i8] c"invalid shift %d\0A\00", align 1
@.str.173 = private unnamed_addr constant [35 x i8] c"R%d pointer %s pointer prohibited\0A\00", align 1
@bpf_alu_string = external dso_local constant [16 x i8*], align 16
@.str.174 = private unnamed_addr constant [45 x i8] c"verifier internal error: unexpected ptr_reg\0A\00", align 1
@.str.175 = private unnamed_addr constant [37 x i8] c"verifier internal error: no src_reg\0A\00", align 1
@.str.176 = private unnamed_addr constant [42 x i8] c"R%d 32-bit pointer arithmetic prohibited\0A\00", align 1
@.str.177 = private unnamed_addr constant [62 x i8] c"R%d pointer arithmetic on %s prohibited, null-check it first\0A\00", align 1
@.str.178 = private unnamed_addr constant [41 x i8] c"R%d pointer arithmetic on %s prohibited\0A\00", align 1
@.str.179 = private unnamed_addr constant [98 x i8] c"R%d has unknown scalar with mixed signed bounds, pointer arithmetic with it prohibited for !root\0A\00", align 1
@.str.180 = private unnamed_addr constant [47 x i8] c"R%d tried to add from different maps or paths\0A\00", align 1
@.str.181 = private unnamed_addr constant [47 x i8] c"R%d tried to sub from different maps or paths\0A\00", align 1
@.str.182 = private unnamed_addr constant [43 x i8] c"R%d tried to subtract pointer from scalar\0A\00", align 1
@.str.183 = private unnamed_addr constant [47 x i8] c"R%d subtraction from stack pointer prohibited\0A\00", align 1
@.str.184 = private unnamed_addr constant [47 x i8] c"R%d bitwise operator %s on pointer prohibited\0A\00", align 1
@.str.185 = private unnamed_addr constant [52 x i8] c"R%d pointer arithmetic with %s operator prohibited\0A\00", align 1
@.str.186 = private unnamed_addr constant [77 x i8] c"R%d pointer arithmetic of map value goes out of range, prohibited for !root\0A\00", align 1
@.str.187 = private unnamed_addr constant [70 x i8] c"R%d stack pointer arithmetic goes out of range, prohibited for !root\0A\00", align 1
@.str.188 = private unnamed_addr constant [49 x i8] c"math between %s pointer and %lld is not allowed\0A\00", align 1
@.str.189 = private unnamed_addr constant [37 x i8] c"%s pointer offset %d is not allowed\0A\00", align 1
@.str.190 = private unnamed_addr constant [78 x i8] c"math between %s pointer and register with unbounded min value is not allowed\0A\00", align 1
@.str.191 = private unnamed_addr constant [46 x i8] c"value %lld makes %s pointer be out of bounds\0A\00", align 1
@.str.192 = private unnamed_addr constant [42 x i8] c"The sequence of %d jumps is too complex.\0A\00", align 1
@.str.193 = private unnamed_addr constant [57 x i8] c"bpf_spin_lock cannot be accessed directly by load/store\0A\00", align 1
@.str.194 = private unnamed_addr constant [84 x i8] c"R%d min value is negative, either use unsigned index or do a if (index >=0) check.\0A\00", align 1
@.str.195 = private unnamed_addr constant [54 x i8] c"R%d min value is outside of the allowed memory range\0A\00", align 1
@.str.196 = private unnamed_addr constant [72 x i8] c"R%d unbounded memory access, make sure to bounds check any such access\0A\00", align 1
@.str.197 = private unnamed_addr constant [54 x i8] c"R%d max value is outside of the allowed memory range\0A\00", align 1
@.str.198 = private unnamed_addr constant [59 x i8] c"invalid access to map value, value_size=%d off=%d size=%d\0A\00", align 1
@.str.199 = private unnamed_addr constant [66 x i8] c"invalid access to packet, off=%d size=%d, R%d(id=%d,off=%d,r=%d)\0A\00", align 1
@.str.200 = private unnamed_addr constant [54 x i8] c"invalid access to memory, mem_size=%u off=%d size=%d\0A\00", align 1
@.str.201 = private unnamed_addr constant [49 x i8] c"variable stack access var_off=%s off=%d size=%d\0A\00", align 1
@.str.202 = private unnamed_addr constant [30 x i8] c"invalid stack off=%d size=%d\0A\00", align 1
@.str.203 = private unnamed_addr constant [16 x i8] c"R%d is invalid\0A\00", align 1
@.str.204 = private unnamed_addr constant [14 x i8] c"R%d !read_ok\0A\00", align 1
@.str.205 = private unnamed_addr constant [28 x i8] c"frame pointer is read only\0A\00", align 1
@.str.206 = private unnamed_addr constant [25 x i8] c"R%d leaks addr into map\0A\00", align 1
@.str.207 = private unnamed_addr constant [25 x i8] c"R%d leaks addr into mem\0A\00", align 1
@.str.208 = private unnamed_addr constant [25 x i8] c"R%d leaks addr into ctx\0A\00", align 1
@.str.209 = private unnamed_addr constant [26 x i8] c"cannot write into packet\0A\00", align 1
@.str.210 = private unnamed_addr constant [28 x i8] c"R%d leaks addr into packet\0A\00", align 1
@.str.211 = private unnamed_addr constant [31 x i8] c"R%d leaks addr into flow keys\0A\00", align 1
@.str.212 = private unnamed_addr constant [26 x i8] c"R%d cannot write into %s\0A\00", align 1
@.str.213 = private unnamed_addr constant [7 x i8] c"rdonly\00", align 1
@.str.214 = private unnamed_addr constant [5 x i8] c"rdwr\00", align 1
@.str.215 = private unnamed_addr constant [29 x i8] c"R%d invalid mem access '%s'\0A\00", align 1
@.str.216 = private unnamed_addr constant [11 x i8] c"flow keys \00", align 1
@.str.217 = private unnamed_addr constant [7 x i8] c"value \00", align 1
@.str.218 = private unnamed_addr constant [9 x i8] c"context \00", align 1
@.str.219 = private unnamed_addr constant [7 x i8] c"stack \00", align 1
@.str.220 = private unnamed_addr constant [6 x i8] c"sock \00", align 1
@.str.221 = private unnamed_addr constant [13 x i8] c"sock_common \00", align 1
@.str.222 = private unnamed_addr constant [10 x i8] c"tcp_sock \00", align 1
@.str.223 = private unnamed_addr constant [10 x i8] c"xdp_sock \00", align 1
@.str.224 = private unnamed_addr constant [50 x i8] c"misaligned packet access off %d+%s+%d+%d size %d\0A\00", align 1
@.str.225 = private unnamed_addr constant [42 x i8] c"misaligned %saccess off %s+%d+%d size %d\0A\00", align 1
@.str.226 = private unnamed_addr constant [56 x i8] c"write into map forbidden, value_size=%d off=%d size=%d\0A\00", align 1
@.str.227 = private unnamed_addr constant [55 x i8] c"read from map forbidden, value_size=%d off=%d size=%d\0A\00", align 1
@.str.228 = private unnamed_addr constant [43 x i8] c"invalid bpf_context access off=%d size=%d\0A\00", align 1
@.str.229 = private unnamed_addr constant [45 x i8] c"attempt to corrupt spilled pointer on stack\0A\00", align 1
@.str.230 = private unnamed_addr constant [32 x i8] c"invalid size of register spill\0A\00", align 1
@.str.231 = private unnamed_addr constant [63 x i8] c"cannot spill pointers to stack into stack frame of the caller\0A\00", align 1
@.str.232 = private unnamed_addr constant [52 x i8] c"insn %d cannot access two stack slots fp%d and fp%d\00", align 1
@.str.233 = private unnamed_addr constant [42 x i8] c"invalid read from stack off %d+0 size %d\0A\00", align 1
@.str.234 = private unnamed_addr constant [31 x i8] c"invalid size of register fill\0A\00", align 1
@.str.235 = private unnamed_addr constant [24 x i8] c"corrupted spill memory\0A\00", align 1
@.str.236 = private unnamed_addr constant [35 x i8] c"leaking pointer from stack off %d\0A\00", align 1
@.str.237 = private unnamed_addr constant [43 x i8] c"invalid read from stack off %d+%d size %d\0A\00", align 1
@.str.238 = private unnamed_addr constant [37 x i8] c"R%d offset is outside of the packet\0A\00", align 1
@.str.239 = private unnamed_addr constant [44 x i8] c"invalid access to flow keys off=%d size=%d\0A\00", align 1
@.str.240 = private unnamed_addr constant [38 x i8] c"R%d invalid %s access off=%d size=%d\0A\00", align 1
@.str.241 = private unnamed_addr constant [11 x i8] c"tracepoint\00", align 1
@.str.242 = private unnamed_addr constant [47 x i8] c"R%d invalid %s buffer access: off=%d, size=%d\0A\00", align 1
@.str.243 = private unnamed_addr constant [56 x i8] c"R%d invalid variable buffer offset: off=%d, var_off=%s\0A\00", align 1
@.str.244 = private unnamed_addr constant [47 x i8] c"R%d is ptr_%s invalid negative access: off=%d\0A\00", align 1
@.str.245 = private unnamed_addr constant [59 x i8] c"R%d is ptr_%s invalid variable offset: off=%d, var_off=%s\0A\00", align 1
@.str.246 = private unnamed_addr constant [24 x i8] c"only read is supported\0A\00", align 1
@.str.247 = private unnamed_addr constant [60 x i8] c"map_ptr access not supported without CONFIG_DEBUG_INFO_BTF\0A\00", align 1
@.str.248 = private unnamed_addr constant [46 x i8] c"map_ptr access not supported for map type %d\0A\00", align 1
@.str.249 = private unnamed_addr constant [60 x i8] c"%s access is allowed only to CAP_PERFMON and CAP_SYS_ADMIN\0A\00", align 1
@.str.250 = private unnamed_addr constant [43 x i8] c"R%d is %s invalid negative access: off=%d\0A\00", align 1
@.str.251 = private unnamed_addr constant [32 x i8] c"only read from %s is supported\0A\00", align 1
@.str.252 = private unnamed_addr constant [31 x i8] c"BPF_XADD uses reserved fields\0A\00", align 1
@.str.253 = private unnamed_addr constant [44 x i8] c"BPF_XADD stores into R%d %s is not allowed\0A\00", align 1
@.str.254 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.255 = private unnamed_addr constant [4 x i8] c"inv\00", align 1
@.str.256 = private unnamed_addr constant [4 x i8] c"ctx\00", align 1
@.str.257 = private unnamed_addr constant [8 x i8] c"map_ptr\00", align 1
@.str.258 = private unnamed_addr constant [10 x i8] c"map_value\00", align 1
@.str.259 = private unnamed_addr constant [18 x i8] c"map_value_or_null\00", align 1
@.str.260 = private unnamed_addr constant [3 x i8] c"fp\00", align 1
@.str.261 = private unnamed_addr constant [9 x i8] c"pkt_meta\00", align 1
@.str.262 = private unnamed_addr constant [4 x i8] c"pkt\00", align 1
@.str.263 = private unnamed_addr constant [8 x i8] c"pkt_end\00", align 1
@.str.264 = private unnamed_addr constant [10 x i8] c"flow_keys\00", align 1
@.str.265 = private unnamed_addr constant [5 x i8] c"sock\00", align 1
@.str.266 = private unnamed_addr constant [13 x i8] c"sock_or_null\00", align 1
@.str.267 = private unnamed_addr constant [12 x i8] c"sock_common\00", align 1
@.str.268 = private unnamed_addr constant [20 x i8] c"sock_common_or_null\00", align 1
@.str.269 = private unnamed_addr constant [9 x i8] c"tcp_sock\00", align 1
@.str.270 = private unnamed_addr constant [17 x i8] c"tcp_sock_or_null\00", align 1
@.str.271 = private unnamed_addr constant [10 x i8] c"tp_buffer\00", align 1
@.str.272 = private unnamed_addr constant [9 x i8] c"xdp_sock\00", align 1
@.str.273 = private unnamed_addr constant [5 x i8] c"ptr_\00", align 1
@.str.274 = private unnamed_addr constant [13 x i8] c"ptr_or_null_\00", align 1
@.str.275 = private unnamed_addr constant [4 x i8] c"mem\00", align 1
@.str.276 = private unnamed_addr constant [12 x i8] c"mem_or_null\00", align 1
@.str.277 = private unnamed_addr constant [11 x i8] c"rdonly_buf\00", align 1
@.str.278 = private unnamed_addr constant [19 x i8] c"rdonly_buf_or_null\00", align 1
@.str.279 = private unnamed_addr constant [9 x i8] c"rdwr_buf\00", align 1
@.str.280 = private unnamed_addr constant [17 x i8] c"rdwr_buf_or_null\00", align 1
@.str.281 = private unnamed_addr constant [12 x i8] c"percpu_ptr_\00", align 1
@.str.282 = private unnamed_addr constant [41 x i8] c"the call stack of %d frames is too deep\0A\00", align 1
@.str.283 = private unnamed_addr constant [44 x i8] c"verifier bug. No program starts at insn %d\0A\00", align 1
@.str.284 = private unnamed_addr constant [42 x i8] c"verifier bug. Frame %d already allocated\0A\00", align 1
@.str.285 = private unnamed_addr constant [41 x i8] c"Caller passes invalid args into func#%d\0A\00", align 1
@.str.286 = private unnamed_addr constant [40 x i8] c"Func#%d is global and valid. Skipping.\0A\00", align 1
@.str.287 = private unnamed_addr constant [9 x i8] c"caller:\0A\00", align 1
@.str.288 = private unnamed_addr constant [9 x i8] c"callee:\0A\00", align 1
@caller_saved = internal constant [6 x i32] [i32 0, i32 1, i32 2, i32 3, i32 4, i32 5], align 16
@.str.289 = private unnamed_addr constant [20 x i8] c"invalid func %s#%d\0A\00", align 1
@.str.290 = private unnamed_addr constant [20 x i8] c"unknown func %s#%d\0A\00", align 1
@.str.291 = private unnamed_addr constant [69 x i8] c"cannot call GPL-restricted function from non-GPL compatible program\0A\00", align 1
@.str.292 = private unnamed_addr constant [37 x i8] c"helper call is not allowed in probe\0A\00", align 1
@.str.293 = private unnamed_addr constant [54 x i8] c"kernel subsystem misconfigured func %s#%d: r1 != ctx\0A\00", align 1
@.str.294 = private unnamed_addr constant [43 x i8] c"kernel subsystem misconfigured func %s#%d\0A\00", align 1
@.str.295 = private unnamed_addr constant [40 x i8] c"tail_call would lead to reference leak\0A\00", align 1
@.str.296 = private unnamed_addr constant [51 x i8] c"func %s#%d reference has not been acquired before\0A\00", align 1
@.str.297 = private unnamed_addr constant [52 x i8] c"get_local_storage() doesn't support non-zero flags\0A\00", align 1
@.str.298 = private unnamed_addr constant [41 x i8] c"kernel subsystem misconfigured verifier\0A\00", align 1
@.str.299 = private unnamed_addr constant [46 x i8] c"unable to resolve the size of type '%s': %ld\0A\00", align 1
@.str.300 = private unnamed_addr constant [38 x i8] c"invalid return type %d of func %s#%d\0A\00", align 1
@.str.301 = private unnamed_addr constant [38 x i8] c"unknown return type %d of func %s#%d\0A\00", align 1
@sysctl_perf_event_max_stack = external dso_local global i32, align 4
@.str.302 = private unnamed_addr constant [44 x i8] c"cannot get callchain buffer for func %s#%d\0A\00", align 1
@.str.303 = private unnamed_addr constant [37 x i8] c"R%d leaks addr into helper function\0A\00", align 1
@.str.304 = private unnamed_addr constant [44 x i8] c"helper access to the packet is not allowed\0A\00", align 1
@.str.305 = private unnamed_addr constant [70 x i8] c"verifier internal error: more than one arg with ref_obj_id R%d %u %u\0A\00", align 1
@.str.306 = private unnamed_addr constant [36 x i8] c"invalid map_ptr to access map->key\0A\00", align 1
@.str.307 = private unnamed_addr constant [38 x i8] c"invalid map_ptr to access map->value\0A\00", align 1
@.str.308 = private unnamed_addr constant [34 x i8] c"Helper has invalid btf_id in R%d\0A\00", align 1
@.str.309 = private unnamed_addr constant [25 x i8] c"verifier internal error\0A\00", align 1
@.str.310 = private unnamed_addr constant [66 x i8] c"R%d min value is negative, either use unsigned or 'var &= const'\0A\00", align 1
@.str.311 = private unnamed_addr constant [71 x i8] c"R%d unbounded memory access, use 'var &= const' or 'if (var < const)'\0A\00", align 1
@.str.312 = private unnamed_addr constant [62 x i8] c"R%d unbounded size, use 'var &= const' or 'if (var < const)'\0A\00", align 1
@.str.313 = private unnamed_addr constant [37 x i8] c"invalid map_ptr to access map->type\0A\00", align 1
@.str.314 = private unnamed_addr constant [39 x i8] c"invalid arg_type for sockmap/sockhash\0A\00", align 1
@compatible_reg_types = internal global [26 x %struct.bpf_reg_types*] [%struct.bpf_reg_types* null, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @const_map_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* @map_key_value_types, %struct.bpf_reg_types* @map_key_value_types, %struct.bpf_reg_types* @map_key_value_types, %struct.bpf_reg_types* @map_key_value_types, %struct.bpf_reg_types* @mem_types, %struct.bpf_reg_types* @mem_types, %struct.bpf_reg_types* @mem_types, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @scalar_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @scalar_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @context_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @context_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* null, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @spin_lock_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* @sock_types, %struct.bpf_reg_types* @int_ptr_types, %struct.bpf_reg_types* @int_ptr_types, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @fullsock_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @fullsock_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @btf_ptr_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @alloc_mem_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @alloc_mem_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @scalar_types to %struct.bpf_reg_types*), %struct.bpf_reg_types* @btf_id_sock_common_types, %struct.bpf_reg_types* bitcast ({ <{ i32, [9 x i32] }>, i32* }* @percpu_btf_ptr_types to %struct.bpf_reg_types*)], align 16
@.str.315 = private unnamed_addr constant [50 x i8] c"verifier internal error: unsupported arg type %d\0A\00", align 1
@.str.316 = private unnamed_addr constant [22 x i8] c"R%d type=%s expected=\00", align 1
@.str.317 = private unnamed_addr constant [5 x i8] c"%s, \00", align 1
@.str.318 = private unnamed_addr constant [56 x i8] c"verifier internal error: missing arg compatible BTF ID\0A\00", align 1
@.str.319 = private unnamed_addr constant [38 x i8] c"R%d is of type %s but %s is expected\0A\00", align 1
@.str.320 = private unnamed_addr constant [59 x i8] c"R%d is a pointer to in-kernel struct with non-zero offset\0A\00", align 1
@map_key_value_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 6, i32 8, i32 7, i32 4, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0], i32* null }, align 8
@mem_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 6, i32 8, i32 7, i32 4, i32 21, i32 23, i32 25, i32 0, i32 0, i32 0], i32* null }, align 8
@sock_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 13, i32 11, i32 15, i32 18, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0], i32* null }, align 8
@int_ptr_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 6, i32 8, i32 7, i32 4, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0], i32* null }, align 8
@btf_id_sock_common_types = internal constant %struct.bpf_reg_types { [10 x i32] [i32 13, i32 11, i32 15, i32 18, i32 19, i32 0, i32 0, i32 0, i32 0, i32 0], i32* bitcast (i8* getelementptr (i8, i8* bitcast ([0 x i32]* @btf_sock_ids to i8*), i64 24) to i32*) }, align 8
@const_map_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 3, [9 x i32] zeroinitializer }>, i32* null }, align 8
@scalar_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 1, [9 x i32] zeroinitializer }>, i32* null }, align 8
@context_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 2, [9 x i32] zeroinitializer }>, i32* null }, align 8
@spin_lock_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 4, [9 x i32] zeroinitializer }>, i32* null }, align 8
@fullsock_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 11, [9 x i32] zeroinitializer }>, i32* null }, align 8
@btf_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 19, [9 x i32] zeroinitializer }>, i32* null }, align 8
@alloc_mem_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 21, [9 x i32] zeroinitializer }>, i32* null }, align 8
@btf_sock_ids = external dso_local global [0 x i32], align 4
@percpu_btf_ptr_types = internal constant { <{ i32, [9 x i32] }>, i32* } { <{ i32, [9 x i32] }> <{ i32 27, [9 x i32] zeroinitializer }>, i32* null }, align 8
@.str.329 = private unnamed_addr constant [25 x i8] c"R%d type=%s expected=%s\0A\00", align 1
@.str.330 = private unnamed_addr constant [76 x i8] c"R%d indirect variable offset stack access prohibited for !root, var_off=%s\0A\00", align 1
@.str.331 = private unnamed_addr constant [53 x i8] c"R%d unbounded indirect variable offset stack access\0A\00", align 1
@.str.332 = private unnamed_addr constant [41 x i8] c"R%d min value is outside of stack bound\0A\00", align 1
@.str.333 = private unnamed_addr constant [41 x i8] c"R%d max value is outside of stack bound\0A\00", align 1
@.str.334 = private unnamed_addr constant [52 x i8] c"invalid indirect read from stack off %d+%d size %d\0A\00", align 1
@.str.335 = private unnamed_addr constant [56 x i8] c"invalid indirect read from stack var_off %s+%d size %d\0A\00", align 1
@.str.336 = private unnamed_addr constant [46 x i8] c"invalid stack type R%d off=%d access_size=%d\0A\00", align 1
@.str.337 = private unnamed_addr constant [50 x i8] c"invalid stack type R%d var_off=%s access_size=%d\0A\00", align 1
@.str.338 = private unnamed_addr constant [82 x i8] c"R%d doesn't have constant offset. bpf_spin_lock has to be at the constant offset\0A\00", align 1
@.str.339 = private unnamed_addr constant [56 x i8] c"map '%s' has to have BTF in order to use bpf_spin_lock\0A\00", align 1
@.str.340 = private unnamed_addr constant [51 x i8] c"map '%s' has more than one 'struct bpf_spin_lock'\0A\00", align 1
@.str.341 = private unnamed_addr constant [46 x i8] c"map '%s' doesn't have 'struct bpf_spin_lock'\0A\00", align 1
@.str.342 = private unnamed_addr constant [59 x i8] c"map '%s' is not a struct type or bpf_spin_lock is mangled\0A\00", align 1
@.str.343 = private unnamed_addr constant [50 x i8] c"off %lld doesn't point to 'struct bpf_spin_lock'\0A\00", align 1
@.str.344 = private unnamed_addr constant [44 x i8] c"Locking two bpf_spin_locks are not allowed\0A\00", align 1
@.str.345 = private unnamed_addr constant [39 x i8] c"bpf_spin_unlock without taking a lock\0A\00", align 1
@.str.346 = private unnamed_addr constant [35 x i8] c"bpf_spin_unlock of different lock\0A\00", align 1
@.str.347 = private unnamed_addr constant [26 x i8] c"write into map forbidden\0A\00", align 1
@.str.348 = private unnamed_addr constant [72 x i8] c"tail_calls are not allowed in non-JITed programs with bpf-to-bpf calls\0A\00", align 1
@.str.349 = private unnamed_addr constant [41 x i8] c"cannot pass map_type %d into func %s#%d\0A\00", align 1
@.str.350 = private unnamed_addr constant [39 x i8] c"cannot update sockmap in this context\0A\00", align 1
@.str.351 = private unnamed_addr constant [43 x i8] c"cannot return stack pointer to the caller\0A\00", align 1
@.str.352 = private unnamed_addr constant [24 x i8] c"returning from callee:\0A\00", align 1
@.str.353 = private unnamed_addr constant [18 x i8] c"to caller at %d:\0A\00", align 1
@.str.354 = private unnamed_addr constant [42 x i8] c"Unreleased reference id=%d alloc_insn=%d\0A\00", align 1
@.str.355 = private unnamed_addr constant [31 x i8] c"R0 leaks addr as return value\0A\00", align 1
@.str.356 = private unnamed_addr constant [63 x i8] c"At subprogram exit the register R0 is not a scalar value (%s)\0A\00", align 1
@.str.357 = private unnamed_addr constant [59 x i8] c"At program exit the register R0 is not a known value (%s)\0A\00", align 1
@.str.358 = private unnamed_addr constant [33 x i8] c"At program exit the register R0 \00", align 1
@.str.359 = private unnamed_addr constant [13 x i8] c"has value %s\00", align 1
@.str.360 = private unnamed_addr constant [25 x i8] c"has unknown scalar value\00", align 1
@.str.361 = private unnamed_addr constant [25 x i8] c" should have been in %s\0A\00", align 1
@update_branch_counts.__warned = internal global i8 0, section ".data.once", align 1
@.str.362 = private unnamed_addr constant [49 x i8] c"BUG update_branch_counts:branches_to_explore=%d\0A\00", align 1
@.str.363 = private unnamed_addr constant [33 x i8] c"invalid BPF_JMP/JMP32 opcode %x\0A\00", align 1
@.str.364 = private unnamed_addr constant [36 x i8] c"BPF_JMP/JMP32 uses reserved fields\0A\00", align 1
@.str.365 = private unnamed_addr constant [35 x i8] c"R%d pointer comparison prohibited\0A\00", align 1
@.str.366 = private unnamed_addr constant [65 x i8] c"BPF_LD_[ABS|IND] instructions not allowed for this program type\0A\00", align 1
@.str.367 = private unnamed_addr constant [31 x i8] c"bpf verifier is misconfigured\0A\00", align 1
@.str.368 = private unnamed_addr constant [39 x i8] c"BPF_LD_[ABS|IND] uses reserved fields\0A\00", align 1
@.str.369 = private unnamed_addr constant [57 x i8] c"BPF_LD_[ABS|IND] cannot be mixed with socket references\0A\00", align 1
@.str.370 = private unnamed_addr constant [64 x i8] c"BPF_LD_[ABS|IND] cannot be used inside bpf_spin_lock-ed region\0A\00", align 1
@.str.371 = private unnamed_addr constant [52 x i8] c"at the time of BPF_LD_ABS|IND R6 != pointer to skb\0A\00", align 1
@.str.372 = private unnamed_addr constant [25 x i8] c"invalid BPF_LD_IMM insn\0A\00", align 1
@.str.373 = private unnamed_addr constant [35 x i8] c"BPF_LD_IMM64 uses reserved fields\0A\00", align 1
@.str.374 = private unnamed_addr constant [86 x i8] c"tail_calls are not allowed when call stack of previous frames is %d bytes. Too large\0A\00", align 1
@.str.375 = private unnamed_addr constant [50 x i8] c"combined stack size of %d calls is %d. Too large\0A\00", align 1
@check_max_stack_depth.__warned = internal global i8 0, section ".data.once", align 1
@.str.376 = private unnamed_addr constant [43 x i8] c"the call stack of %d frames is too deep !\0A\00", align 1
@__const.opt_hard_wire_dead_code_branches.ja = private unnamed_addr constant %struct.bpf_insn { i8 5, i8 0, i16 0, i32 0 }, align 4
@__const.opt_remove_nops.ja = private unnamed_addr constant %struct.bpf_insn { i8 5, i8 0, i16 0, i32 0 }, align 4
@__const.sanitize_dead_code.trap = private unnamed_addr constant %struct.bpf_insn { i8 5, i8 0, i16 -1, i32 0 }, align 4
@.str.377 = private unnamed_addr constant [45 x i8] c"Writes through BTF pointers are not allowed\0A\00", align 1
@.str.378 = private unnamed_addr constant [46 x i8] c"bpf verifier narrow ctx access misconfigured\0A\00", align 1
@.str.379 = private unnamed_addr constant [47 x i8] c"insn %d cannot be patched due to 16-bit range\0A\00", align 1
@.str.380 = private unnamed_addr constant [41 x i8] c"adding tail call poke descriptor failed\0A\00", align 1
@.str.381 = private unnamed_addr constant [27 x i8] c"tail_call abusing map_ptr\0A\00", align 1
@jiffies = external dso_local global i64, section ".data..cacheline_aligned", align 64
@.str.382 = private unnamed_addr constant [32 x i8] c"tracking tail call prog failed\0A\00", align 1
@jit_subprogs.__warned = internal global i8 0, section ".data.once", align 1
@.str.383 = private unnamed_addr constant [38 x i8] c"JIT doesn't support bpf-to-bpf calls\0A\00", align 1
@get_callee_stack_depth.__warned = internal global i8 0, section ".data.once", align 1
@.str.384 = private unnamed_addr constant [29 x i8] c"verification time %lld usec\0A\00", align 1
@.str.385 = private unnamed_addr constant [13 x i8] c"stack depth \00", align 1
@.str.386 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.387 = private unnamed_addr constant [2 x i8] c"+\00", align 1
@.str.388 = private unnamed_addr constant [98 x i8] c"processed %d insns (limit %d) max_states_per_insn %d total_states %d peak_states %d mark_read %d\0A\00", align 1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @tnum_strn(i8* noundef %str, i64 noundef %size, i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %str.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i8* %str, i8** %str.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = load i8*, i8** %str.addr, align 8
  %4 = load i64, i64* %size.addr, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %5 = load i64, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %6 = load i64, i64* %mask, align 8
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* noundef %3, i64 noundef %4, i8* noundef getelementptr inbounds ([15 x i8], [15 x i8]* @.str, i64 0, i64 0), i64 noundef %5, i64 noundef %6) #11
  ret i32 %call
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @snprintf(i8* noundef, i64 noundef, i8* noundef, ...) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_const(i64 noundef %value) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %value.addr = alloca i64, align 8
  store i64 %value, i64* %value.addr, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %0 = load i64, i64* %value.addr, align 8
  store i64 %0, i64* %value1, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  store i64 0, i64* %mask, align 8
  %1 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %2 = load { i64, i64 }, { i64, i64 }* %1, align 8
  ret { i64, i64 } %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_range(i64 noundef %min, i64 noundef %max) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %min.addr = alloca i64, align 8
  %max.addr = alloca i64, align 8
  %chi = alloca i64, align 8
  %delta = alloca i64, align 8
  %bits = alloca i8, align 1
  store i64 %min, i64* %min.addr, align 8
  store i64 %max, i64* %max.addr, align 8
  %0 = load i64, i64* %min.addr, align 8
  %1 = load i64, i64* %max.addr, align 8
  %xor = xor i64 %0, %1
  store i64 %xor, i64* %chi, align 8
  %2 = load i64, i64* %chi, align 8
  %call = call i32 @fls64___(i64 noundef %2) #11
  %conv = trunc i32 %call to i8
  store i8 %conv, i8* %bits, align 1
  %3 = load i8, i8* %bits, align 1
  %conv1 = zext i8 %3 to i32
  %cmp = icmp sgt i32 %conv1, 63
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = bitcast %struct.tnum* %retval to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %4, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i8, i8* %bits, align 1
  %conv3 = zext i8 %5 to i32
  %sh_prom = zext i32 %conv3 to i64
  %shl = shl i64 1, %sh_prom
  %sub = sub i64 %shl, 1
  store i64 %sub, i64* %delta, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %6 = load i64, i64* %min.addr, align 8
  %7 = load i64, i64* %delta, align 8
  %neg = xor i64 %7, -1
  %and = and i64 %6, %neg
  store i64 %and, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %8 = load i64, i64* %delta, align 8
  store i64 %8, i64* %mask, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %10 = load { i64, i64 }, { i64, i64 }* %9, align 8
  ret { i64, i64 } %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @fls64___(i64 noundef %x) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca i64, align 8
  store i64 %x, i64* %x.addr, align 8
  %0 = load i64, i64* %x.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %x.addr, align 8
  %call = call i32 @generic___fls___(i64 noundef %1) #11
  %add = add i32 %call, 1
  store i32 %add, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: argmemonly nofree nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #2

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @generic___fls___(i64 noundef %word) #0 {
entry:
  %word.addr = alloca i64, align 8
  %num = alloca i32, align 4
  store i64 %word, i64* %word.addr, align 8
  store i32 63, i32* %num, align 4
  %0 = load i64, i64* %word.addr, align 8
  %and = and i64 %0, -4294967296
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %num, align 4
  %sub = sub i32 %1, 32
  store i32 %sub, i32* %num, align 4
  %2 = load i64, i64* %word.addr, align 8
  %shl = shl i64 %2, 32
  store i64 %shl, i64* %word.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i64, i64* %word.addr, align 8
  %and1 = and i64 %3, -281474976710656
  %tobool2 = icmp ne i64 %and1, 0
  br i1 %tobool2, label %if.end6, label %if.then3

if.then3:                                         ; preds = %if.end
  %4 = load i32, i32* %num, align 4
  %sub4 = sub i32 %4, 16
  store i32 %sub4, i32* %num, align 4
  %5 = load i64, i64* %word.addr, align 8
  %shl5 = shl i64 %5, 16
  store i64 %shl5, i64* %word.addr, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then3, %if.end
  %6 = load i64, i64* %word.addr, align 8
  %and7 = and i64 %6, -72057594037927936
  %tobool8 = icmp ne i64 %and7, 0
  br i1 %tobool8, label %if.end12, label %if.then9

if.then9:                                         ; preds = %if.end6
  %7 = load i32, i32* %num, align 4
  %sub10 = sub i32 %7, 8
  store i32 %sub10, i32* %num, align 4
  %8 = load i64, i64* %word.addr, align 8
  %shl11 = shl i64 %8, 8
  store i64 %shl11, i64* %word.addr, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.end6
  %9 = load i64, i64* %word.addr, align 8
  %and13 = and i64 %9, -1152921504606846976
  %tobool14 = icmp ne i64 %and13, 0
  br i1 %tobool14, label %if.end18, label %if.then15

if.then15:                                        ; preds = %if.end12
  %10 = load i32, i32* %num, align 4
  %sub16 = sub i32 %10, 4
  store i32 %sub16, i32* %num, align 4
  %11 = load i64, i64* %word.addr, align 8
  %shl17 = shl i64 %11, 4
  store i64 %shl17, i64* %word.addr, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then15, %if.end12
  %12 = load i64, i64* %word.addr, align 8
  %and19 = and i64 %12, -4611686018427387904
  %tobool20 = icmp ne i64 %and19, 0
  br i1 %tobool20, label %if.end24, label %if.then21

if.then21:                                        ; preds = %if.end18
  %13 = load i32, i32* %num, align 4
  %sub22 = sub i32 %13, 2
  store i32 %sub22, i32* %num, align 4
  %14 = load i64, i64* %word.addr, align 8
  %shl23 = shl i64 %14, 2
  store i64 %shl23, i64* %word.addr, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end18
  %15 = load i64, i64* %word.addr, align 8
  %and25 = and i64 %15, -9223372036854775808
  %tobool26 = icmp ne i64 %and25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %if.end24
  %16 = load i32, i32* %num, align 4
  %sub28 = sub i32 %16, 1
  store i32 %sub28, i32* %num, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.then27, %if.end24
  %17 = load i32, i32* %num, align 4
  ret i32 %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_lshift(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %shift) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %shift.addr = alloca i8, align 1
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i8 %shift, i8* %shift.addr, align 1
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %3 = load i64, i64* %value1, align 8
  %4 = load i8, i8* %shift.addr, align 1
  %conv = zext i8 %4 to i32
  %sh_prom = zext i32 %conv to i64
  %shl = shl i64 %3, %sh_prom
  store i64 %shl, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %5 = load i64, i64* %mask2, align 8
  %6 = load i8, i8* %shift.addr, align 1
  %conv3 = zext i8 %6 to i32
  %sh_prom4 = zext i32 %conv3 to i64
  %shl5 = shl i64 %5, %sh_prom4
  store i64 %shl5, i64* %mask, align 8
  %7 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %8 = load { i64, i64 }, { i64, i64 }* %7, align 8
  ret { i64, i64 } %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_rshift(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %shift) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %shift.addr = alloca i8, align 1
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i8 %shift, i8* %shift.addr, align 1
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %3 = load i64, i64* %value1, align 8
  %4 = load i8, i8* %shift.addr, align 1
  %conv = zext i8 %4 to i32
  %sh_prom = zext i32 %conv to i64
  %shr = lshr i64 %3, %sh_prom
  store i64 %shr, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %5 = load i64, i64* %mask2, align 8
  %6 = load i8, i8* %shift.addr, align 1
  %conv3 = zext i8 %6 to i32
  %sh_prom4 = zext i32 %conv3 to i64
  %shr5 = lshr i64 %5, %sh_prom4
  store i64 %shr5, i64* %mask, align 8
  %7 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %8 = load { i64, i64 }, { i64, i64 }* %7, align 8
  ret { i64, i64 } %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_arshift(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %min_shift, i8 noundef zeroext %insn_bitness) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %min_shift.addr = alloca i8, align 1
  %insn_bitness.addr = alloca i8, align 1
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i8 %min_shift, i8* %min_shift.addr, align 1
  store i8 %insn_bitness, i8* %insn_bitness.addr, align 1
  %3 = load i8, i8* %insn_bitness.addr, align 1
  %conv = zext i8 %3 to i32
  %cmp = icmp eq i32 %conv, 32
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %value2 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %4 = load i64, i64* %value2, align 8
  %conv3 = trunc i64 %4 to i32
  %5 = load i8, i8* %min_shift.addr, align 1
  %conv4 = zext i8 %5 to i32
  %shr = ashr i32 %conv3, %conv4
  %conv5 = zext i32 %shr to i64
  store i64 %conv5, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %6 = load i64, i64* %mask6, align 8
  %conv7 = trunc i64 %6 to i32
  %7 = load i8, i8* %min_shift.addr, align 1
  %conv8 = zext i8 %7 to i32
  %shr9 = ashr i32 %conv7, %conv8
  %conv10 = zext i32 %shr9 to i64
  store i64 %conv10, i64* %mask, align 8
  br label %return

if.else:                                          ; preds = %entry
  %value11 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %value12 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %8 = load i64, i64* %value12, align 8
  %9 = load i8, i8* %min_shift.addr, align 1
  %conv13 = zext i8 %9 to i32
  %sh_prom = zext i32 %conv13 to i64
  %shr14 = ashr i64 %8, %sh_prom
  store i64 %shr14, i64* %value11, align 8
  %mask15 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %mask16 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %10 = load i64, i64* %mask16, align 8
  %11 = load i8, i8* %min_shift.addr, align 1
  %conv17 = zext i8 %11 to i32
  %sh_prom18 = zext i32 %conv17 to i64
  %shr19 = ashr i64 %10, %sh_prom18
  store i64 %shr19, i64* %mask15, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %12 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %13 = load { i64, i64 }, { i64, i64 }* %12, align 8
  ret { i64, i64 } %13
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_add(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %sm = alloca i64, align 8
  %sv = alloca i64, align 8
  %sigma = alloca i64, align 8
  %chi = alloca i64, align 8
  %mu = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %6 = load i64, i64* %mask, align 8
  %mask1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %7 = load i64, i64* %mask1, align 8
  %add = add i64 %6, %7
  store i64 %add, i64* %sm, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %8 = load i64, i64* %value, align 8
  %value2 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %9 = load i64, i64* %value2, align 8
  %add3 = add i64 %8, %9
  store i64 %add3, i64* %sv, align 8
  %10 = load i64, i64* %sm, align 8
  %11 = load i64, i64* %sv, align 8
  %add4 = add i64 %10, %11
  store i64 %add4, i64* %sigma, align 8
  %12 = load i64, i64* %sigma, align 8
  %13 = load i64, i64* %sv, align 8
  %xor = xor i64 %12, %13
  store i64 %xor, i64* %chi, align 8
  %14 = load i64, i64* %chi, align 8
  %mask5 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %15 = load i64, i64* %mask5, align 8
  %or = or i64 %14, %15
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %16 = load i64, i64* %mask6, align 8
  %or7 = or i64 %or, %16
  store i64 %or7, i64* %mu, align 8
  %value8 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %17 = load i64, i64* %sv, align 8
  %18 = load i64, i64* %mu, align 8
  %neg = xor i64 %18, -1
  %and = and i64 %17, %neg
  store i64 %and, i64* %value8, align 8
  %mask9 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %19 = load i64, i64* %mu, align 8
  store i64 %19, i64* %mask9, align 8
  %20 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %21 = load { i64, i64 }, { i64, i64 }* %20, align 8
  ret { i64, i64 } %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_sub(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %dv = alloca i64, align 8
  %alpha = alloca i64, align 8
  %beta = alloca i64, align 8
  %chi = alloca i64, align 8
  %mu = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %6 = load i64, i64* %value, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %7 = load i64, i64* %value1, align 8
  %sub = sub i64 %6, %7
  store i64 %sub, i64* %dv, align 8
  %8 = load i64, i64* %dv, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %9 = load i64, i64* %mask, align 8
  %add = add i64 %8, %9
  store i64 %add, i64* %alpha, align 8
  %10 = load i64, i64* %dv, align 8
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %11 = load i64, i64* %mask2, align 8
  %sub3 = sub i64 %10, %11
  store i64 %sub3, i64* %beta, align 8
  %12 = load i64, i64* %alpha, align 8
  %13 = load i64, i64* %beta, align 8
  %xor = xor i64 %12, %13
  store i64 %xor, i64* %chi, align 8
  %14 = load i64, i64* %chi, align 8
  %mask4 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %15 = load i64, i64* %mask4, align 8
  %or = or i64 %14, %15
  %mask5 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %16 = load i64, i64* %mask5, align 8
  %or6 = or i64 %or, %16
  store i64 %or6, i64* %mu, align 8
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %17 = load i64, i64* %dv, align 8
  %18 = load i64, i64* %mu, align 8
  %neg = xor i64 %18, -1
  %and = and i64 %17, %neg
  store i64 %and, i64* %value7, align 8
  %mask8 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %19 = load i64, i64* %mu, align 8
  store i64 %19, i64* %mask8, align 8
  %20 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %21 = load { i64, i64 }, { i64, i64 }* %20, align 8
  ret { i64, i64 } %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_and(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %alpha = alloca i64, align 8
  %beta = alloca i64, align 8
  %v = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %6 = load i64, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %7 = load i64, i64* %mask, align 8
  %or = or i64 %6, %7
  store i64 %or, i64* %alpha, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %8 = load i64, i64* %value1, align 8
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %9 = load i64, i64* %mask2, align 8
  %or3 = or i64 %8, %9
  store i64 %or3, i64* %beta, align 8
  %value4 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %10 = load i64, i64* %value4, align 8
  %value5 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %11 = load i64, i64* %value5, align 8
  %and = and i64 %10, %11
  store i64 %and, i64* %v, align 8
  %value6 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %12 = load i64, i64* %v, align 8
  store i64 %12, i64* %value6, align 8
  %mask7 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %13 = load i64, i64* %alpha, align 8
  %14 = load i64, i64* %beta, align 8
  %and8 = and i64 %13, %14
  %15 = load i64, i64* %v, align 8
  %neg = xor i64 %15, -1
  %and9 = and i64 %and8, %neg
  store i64 %and9, i64* %mask7, align 8
  %16 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %17 = load { i64, i64 }, { i64, i64 }* %16, align 8
  ret { i64, i64 } %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_or(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %v = alloca i64, align 8
  %mu = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %6 = load i64, i64* %value, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %7 = load i64, i64* %value1, align 8
  %or = or i64 %6, %7
  store i64 %or, i64* %v, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %8 = load i64, i64* %mask, align 8
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %9 = load i64, i64* %mask2, align 8
  %or3 = or i64 %8, %9
  store i64 %or3, i64* %mu, align 8
  %value4 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %10 = load i64, i64* %v, align 8
  store i64 %10, i64* %value4, align 8
  %mask5 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %11 = load i64, i64* %mu, align 8
  %12 = load i64, i64* %v, align 8
  %neg = xor i64 %12, -1
  %and = and i64 %11, %neg
  store i64 %and, i64* %mask5, align 8
  %13 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %14 = load { i64, i64 }, { i64, i64 }* %13, align 8
  ret { i64, i64 } %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_xor(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %v = alloca i64, align 8
  %mu = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %6 = load i64, i64* %value, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %7 = load i64, i64* %value1, align 8
  %xor = xor i64 %6, %7
  store i64 %xor, i64* %v, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %8 = load i64, i64* %mask, align 8
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %9 = load i64, i64* %mask2, align 8
  %or = or i64 %8, %9
  store i64 %or, i64* %mu, align 8
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %10 = load i64, i64* %v, align 8
  %11 = load i64, i64* %mu, align 8
  %neg = xor i64 %11, -1
  %and = and i64 %10, %neg
  store i64 %and, i64* %value3, align 8
  %mask4 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %12 = load i64, i64* %mu, align 8
  store i64 %12, i64* %mask4, align 8
  %13 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %14 = load { i64, i64 }, { i64, i64 }* %13, align 8
  ret { i64, i64 } %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_mul(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %acc = alloca %struct.tnum, align 8
  %pi = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  %.compoundliteral = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %6 = load i64, i64* %value, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %7 = load i64, i64* %value1, align 8
  %mul = mul i64 %6, %7
  store i64 %mul, i64* %pi, align 8
  %value2 = getelementptr inbounds %struct.tnum, %struct.tnum* %.compoundliteral, i32 0, i32 0
  %8 = load i64, i64* %pi, align 8
  store i64 %8, i64* %value2, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %.compoundliteral, i32 0, i32 1
  store i64 0, i64* %mask, align 8
  %mask3 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %9 = load i64, i64* %mask3, align 8
  %mask4 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %10 = load i64, i64* %mask4, align 8
  %value5 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %11 = load i64, i64* %value5, align 8
  %or = or i64 %10, %11
  %12 = bitcast %struct.tnum* %.compoundliteral to { i64, i64 }*
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = load i64, i64* %13, align 8
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %call = call { i64, i64 } @hma(i64 %14, i64 %16, i64 noundef %9, i64 noundef %or) #11
  %17 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i64, i64 } %call, 0
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i64, i64 } %call, 1
  store i64 %21, i64* %20, align 8
  %22 = bitcast %struct.tnum* %acc to i8*
  %23 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %23, i64 16, i1 false)
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %24 = load i64, i64* %mask6, align 8
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %25 = load i64, i64* %value7, align 8
  %26 = bitcast %struct.tnum* %acc to { i64, i64 }*
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 0
  %28 = load i64, i64* %27, align 8
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 1
  %30 = load i64, i64* %29, align 8
  %call8 = call { i64, i64 } @hma(i64 %28, i64 %30, i64 noundef %24, i64 noundef %25) #11
  %31 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = extractvalue { i64, i64 } %call8, 0
  store i64 %33, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = extractvalue { i64, i64 } %call8, 1
  store i64 %35, i64* %34, align 8
  %36 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %37 = load { i64, i64 }, { i64, i64 }* %36, align 8
  ret { i64, i64 } %37
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { i64, i64 } @hma(i64 %acc.coerce0, i64 %acc.coerce1, i64 noundef %value, i64 noundef %mask) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %acc = alloca %struct.tnum, align 8
  %value.addr = alloca i64, align 8
  %mask.addr = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  %.compoundliteral = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %acc to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %acc.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %acc.coerce1, i64* %2, align 8
  store i64 %value, i64* %value.addr, align 8
  store i64 %mask, i64* %mask.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %3 = load i64, i64* %mask.addr, align 8
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i64, i64* %mask.addr, align 8
  %and = and i64 %4, 1
  %tobool1 = icmp ne i64 %and, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %value2 = getelementptr inbounds %struct.tnum, %struct.tnum* %.compoundliteral, i32 0, i32 0
  store i64 0, i64* %value2, align 8
  %mask3 = getelementptr inbounds %struct.tnum, %struct.tnum* %.compoundliteral, i32 0, i32 1
  %5 = load i64, i64* %value.addr, align 8
  store i64 %5, i64* %mask3, align 8
  %6 = bitcast %struct.tnum* %acc to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %11 = bitcast %struct.tnum* %.compoundliteral to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call = call { i64, i64 } @tnum_add(i64 %8, i64 %10, i64 %13, i64 %15) #11
  %16 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call, 1
  store i64 %20, i64* %19, align 8
  %21 = bitcast %struct.tnum* %acc to i8*
  %22 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %22, i64 16, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %23 = load i64, i64* %mask.addr, align 8
  %shr = lshr i64 %23, 1
  store i64 %shr, i64* %mask.addr, align 8
  %24 = load i64, i64* %value.addr, align 8
  %shl = shl i64 %24, 1
  store i64 %shl, i64* %value.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %25 = bitcast %struct.tnum* %retval to i8*
  %26 = bitcast %struct.tnum* %acc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %25, i8* align 8 %26, i64 16, i1 false)
  %27 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %28 = load { i64, i64 }, { i64, i64 }* %27, align 8
  ret { i64, i64 } %28
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_intersect(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %v = alloca i64, align 8
  %mu = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %6 = load i64, i64* %value, align 8
  %value1 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %7 = load i64, i64* %value1, align 8
  %or = or i64 %6, %7
  store i64 %or, i64* %v, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %8 = load i64, i64* %mask, align 8
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %9 = load i64, i64* %mask2, align 8
  %and = and i64 %8, %9
  store i64 %and, i64* %mu, align 8
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 0
  %10 = load i64, i64* %v, align 8
  %11 = load i64, i64* %mu, align 8
  %neg = xor i64 %11, -1
  %and4 = and i64 %10, %neg
  store i64 %and4, i64* %value3, align 8
  %mask5 = getelementptr inbounds %struct.tnum, %struct.tnum* %retval, i32 0, i32 1
  %12 = load i64, i64* %mu, align 8
  store i64 %12, i64* %mask5, align 8
  %13 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %14 = load { i64, i64 }, { i64, i64 }* %13, align 8
  ret { i64, i64 } %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_cast(i64 %a.coerce0, i64 %a.coerce1, i8 noundef zeroext %size) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %size.addr = alloca i8, align 1
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i8 %size, i8* %size.addr, align 1
  %3 = load i8, i8* %size.addr, align 1
  %conv = zext i8 %3 to i32
  %mul = mul i32 %conv, 8
  %sh_prom = zext i32 %mul to i64
  %shl = shl i64 1, %sh_prom
  %sub = sub i64 %shl, 1
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %4 = load i64, i64* %value, align 8
  %and = and i64 %4, %sub
  store i64 %and, i64* %value, align 8
  %5 = load i8, i8* %size.addr, align 1
  %conv1 = zext i8 %5 to i32
  %mul2 = mul i32 %conv1, 8
  %sh_prom3 = zext i32 %mul2 to i64
  %shl4 = shl i64 1, %sh_prom3
  %sub5 = sub i64 %shl4, 1
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %6 = load i64, i64* %mask, align 8
  %and6 = and i64 %6, %sub5
  store i64 %and6, i64* %mask, align 8
  %7 = bitcast %struct.tnum* %retval to i8*
  %8 = bitcast %struct.tnum* %a to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %8, i64 16, i1 false)
  %9 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %10 = load { i64, i64 }, { i64, i64 }* %9, align 8
  ret { i64, i64 } %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local zeroext i1 @tnum_is_aligned(i64 %a.coerce0, i64 %a.coerce1, i64 noundef %size) #0 {
entry:
  %retval = alloca i1, align 1
  %a = alloca %struct.tnum, align 8
  %size.addr = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i64 %size, i64* %size.addr, align 8
  %3 = load i64, i64* %size.addr, align 8
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %4 = load i64, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %5 = load i64, i64* %mask, align 8
  %or = or i64 %4, %5
  %6 = load i64, i64* %size.addr, align 8
  %sub = sub i64 %6, 1
  %and = and i64 %or, %sub
  %tobool1 = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool1, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local zeroext i1 @tnum_in(i64 %a.coerce0, i64 %a.coerce1, i64 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca i1, align 1
  %a = alloca %struct.tnum, align 8
  %b = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %b to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  store i64 %b.coerce0, i64* %4, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 1
  %6 = load i64, i64* %mask, align 8
  %mask1 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %7 = load i64, i64* %mask1, align 8
  %neg = xor i64 %7, -1
  %and = and i64 %6, %neg
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %mask2 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %8 = load i64, i64* %mask2, align 8
  %neg3 = xor i64 %8, -1
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %9 = load i64, i64* %value, align 8
  %and4 = and i64 %9, %neg3
  store i64 %and4, i64* %value, align 8
  %value5 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %10 = load i64, i64* %value5, align 8
  %value6 = getelementptr inbounds %struct.tnum, %struct.tnum* %b, i32 0, i32 0
  %11 = load i64, i64* %value6, align 8
  %cmp = icmp eq i64 %10, %11
  store i1 %cmp, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i1, i1* %retval, align 1
  ret i1 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @tnum_sbin(i8* noundef %str, i64 noundef %size, i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %str.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %n = alloca i64, align 8
  %__UNIQUE_ID___x1 = alloca i64, align 8
  %__UNIQUE_ID___y2 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i8* %str, i8** %str.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i64 64, i64* %n, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i64, i64* %n, align 8
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, i64* %n, align 8
  %5 = load i64, i64* %size.addr, align 8
  %cmp = icmp ult i64 %4, %5
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %for.body
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %6 = load i64, i64* %mask, align 8
  %and = and i64 %6, 1
  %tobool1 = icmp ne i64 %and, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %7 = load i8*, i8** %str.addr, align 8
  %8 = load i64, i64* %n, align 8
  %sub = sub i64 %8, 1
  %arrayidx = getelementptr i8, i8* %7, i64 %sub
  store i8 120, i8* %arrayidx, align 1
  br label %if.end11

if.else:                                          ; preds = %if.then
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %9 = load i64, i64* %value, align 8
  %and3 = and i64 %9, 1
  %tobool4 = icmp ne i64 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else
  %10 = load i8*, i8** %str.addr, align 8
  %11 = load i64, i64* %n, align 8
  %sub6 = sub i64 %11, 1
  %arrayidx7 = getelementptr i8, i8* %10, i64 %sub6
  store i8 49, i8* %arrayidx7, align 1
  br label %if.end

if.else8:                                         ; preds = %if.else
  %12 = load i8*, i8** %str.addr, align 8
  %13 = load i64, i64* %n, align 8
  %sub9 = sub i64 %13, 1
  %arrayidx10 = getelementptr i8, i8* %12, i64 %sub9
  store i8 48, i8* %arrayidx10, align 1
  br label %if.end

if.end:                                           ; preds = %if.else8, %if.then5
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then2
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %for.body
  %mask13 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %14 = load i64, i64* %mask13, align 8
  %shr = lshr i64 %14, 1
  store i64 %shr, i64* %mask13, align 8
  %value14 = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %15 = load i64, i64* %value14, align 8
  %shr15 = lshr i64 %15, 1
  store i64 %shr15, i64* %value14, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %16 = load i64, i64* %n, align 8
  %dec = add i64 %16, -1
  store i64 %dec, i64* %n, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i8*, i8** %str.addr, align 8
  %18 = load i64, i64* %size.addr, align 8
  %sub16 = sub i64 %18, 1
  store i64 %sub16, i64* %__UNIQUE_ID___x1, align 8
  store i64 64, i64* %__UNIQUE_ID___y2, align 8
  %19 = load i64, i64* %__UNIQUE_ID___x1, align 8
  %20 = load i64, i64* %__UNIQUE_ID___y2, align 8
  %cmp17 = icmp ult i64 %19, %20
  br i1 %cmp17, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %21 = load i64, i64* %__UNIQUE_ID___x1, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.end
  %22 = load i64, i64* %__UNIQUE_ID___y2, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %21, %cond.true ], [ %22, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %23 = load i64, i64* %tmp, align 8
  %arrayidx18 = getelementptr i8, i8* %17, i64 %23
  store i8 0, i8* %arrayidx18, align 1
  ret i32 64
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_subreg(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %a to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_cast(i64 %5, i64 %7, i8 noundef zeroext 4) #11
  %8 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %13 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %14 = load { i64, i64 }, { i64, i64 }* %13, align 8
  ret { i64, i64 } %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_clear_subreg(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %a to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_rshift(i64 %5, i64 %7, i8 noundef zeroext 32) #11
  %8 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %13 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call1 = call { i64, i64 } @tnum_lshift(i64 %15, i64 %17, i8 noundef zeroext 32) #11
  %18 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call1, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call1, 1
  store i64 %22, i64* %21, align 8
  %23 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %24 = load { i64, i64 }, { i64, i64 }* %23, align 8
  ret { i64, i64 } %24
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local { i64, i64 } @tnum_const_subreg(i64 %a.coerce0, i64 %a.coerce1, i32 noundef %value) #0 {
entry:
  %retval = alloca %struct.tnum, align 8
  %a = alloca %struct.tnum, align 8
  %value.addr = alloca i32, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %agg.tmp1 = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i32 %value, i32* %value.addr, align 4
  %3 = bitcast %struct.tnum* %a to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_clear_subreg(i64 %5, i64 %7) #11
  %8 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %13 = load i32, i32* %value.addr, align 4
  %conv = zext i32 %13 to i64
  %call2 = call { i64, i64 } @tnum_const(i64 noundef %conv) #11
  %14 = bitcast %struct.tnum* %agg.tmp1 to { i64, i64 }*
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 0
  %16 = extractvalue { i64, i64 } %call2, 0
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 1
  %18 = extractvalue { i64, i64 } %call2, 1
  store i64 %18, i64* %17, align 8
  %19 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %24 = bitcast %struct.tnum* %agg.tmp1 to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = load i64, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = load i64, i64* %27, align 8
  %call3 = call { i64, i64 } @tnum_or(i64 %21, i64 %23, i64 %26, i64 %28) #11
  %29 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = extractvalue { i64, i64 } %call3, 0
  store i64 %31, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = extractvalue { i64, i64 } %call3, 1
  store i64 %33, i64* %32, align 8
  %34 = bitcast %struct.tnum* %retval to { i64, i64 }*
  %35 = load { i64, i64 }, { i64, i64 }* %34, align 8
  ret { i64, i64 } %35
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @bpf_verifier_log_write(%struct.bpf_verifier_env* noundef %env, i8* noundef %fmt, ...) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %fmt.addr = alloca i8*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 22
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #11
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 22
  %2 = load i8*, i8** %fmt.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log2, i8* noundef %2, %struct.__va_list_tag* noundef %arraydecay3) #11
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %tobool = icmp ne %struct.bpf_verifier_log* %0, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %1, i32 0, i32 0
  %2 = load i32, i32* %level, align 8
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %land.rhs
  %3 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %3, i32 0, i32 2
  %4 = load i8*, i8** %ubuf, align 8
  %tobool2 = icmp ne i8* %4, null
  br i1 %tobool2, label %land.lhs.true3, label %lor.rhs

land.lhs.true3:                                   ; preds = %land.lhs.true
  %5 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %call = call zeroext i1 @bpf_verifier_log_full(%struct.bpf_verifier_log* noundef %5) #11
  br i1 %call, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.lhs.true3, %land.lhs.true, %land.rhs
  %6 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %level4 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %6, i32 0, i32 0
  %7 = load i32, i32* %level4, align 8
  %cmp = icmp eq i32 %7, 8
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true3
  %8 = phi i1 [ true, %land.lhs.true3 ], [ %cmp, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %entry
  %9 = phi i1 [ false, %entry ], [ %8, %lor.end ]
  ret i1 %9
}

; Function Attrs: nofree nosync nounwind willreturn
declare void @llvm.va_start(i8*) #3

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log, i8* noundef %fmt, %struct.__va_list_tag* noundef %args) #0 {
entry:
  %retval.i = alloca i1, align 1
  %addr.addr.i = alloca i8*, align 8
  %bytes.addr.i = alloca i64, align 8
  %is_source.addr.i = alloca i8, align 1
  %sz.i = alloca i32, align 4
  %__ret_warn_on.i = alloca i32, align 4
  %tmp.i = alloca i64, align 8
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %fmt.addr = alloca i8*, align 8
  %args.addr = alloca %struct.__va_list_tag*, align 8
  %n = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp37 = alloca i64, align 8
  %__UNIQUE_ID___x372 = alloca i32, align 4
  %__UNIQUE_ID___y373 = alloca i32, align 4
  %tmp45 = alloca i32, align 4
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  store %struct.__va_list_tag* %args, %struct.__va_list_tag** %args.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %kbuf, i64 0, i64 0
  %1 = load i8*, i8** %fmt.addr, align 8
  %2 = load %struct.__va_list_tag*, %struct.__va_list_tag** %args.addr, align 8
  %call = call i32 @vscnprintf(i8* noundef %arraydecay, i64 noundef 1024, i8* noundef %1, %struct.__va_list_tag* noundef %2) #11
  store i32 %call, i32* %n, align 4
  %3 = load i32, i32* %n, align 4
  %cmp = icmp uge i32 %3, 1023
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_once, align 4
  %4 = load i32, i32* %__ret_warn_once, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %5 = load i8, i8* @bpf_verifier_vlog.__warned, align 1
  %tobool2 = trunc i8 %5 to i1
  %lnot3 = xor i1 %tobool2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %lnot3, %land.rhs ]
  %lnot5 = xor i1 %6, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %tobool9 = icmp ne i64 %conv, 0
  br i1 %tobool9, label %if.then, label %if.end36

if.then:                                          ; preds = %land.end
  store i8 1, i8* @bpf_verifier_vlog.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool10 = icmp ne i32 %7, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %tobool16 = icmp ne i64 %conv15, 0
  br i1 %tobool16, label %if.then17, label %if.end

if.then17:                                        ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then17
  br label %do.body18

do.body18:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body18
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.2, i64 0, i64 0)) #11
  br label %do.body19

do.body19:                                        ; preds = %do.end
  br label %do.body20

do.body20:                                        ; preds = %do.body19
  br label %do.end21

do.end21:                                         ; preds = %do.body20
  br label %do.body22

do.body22:                                        ; preds = %do.end21
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 364, i32 2313, i64 12) #10, !srcloc !6
  br label %do.end23

do.end23:                                         ; preds = %do.body22
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 371) #10, !srcloc !7
  br label %do.body24

do.body24:                                        ; preds = %do.end23
  br label %do.end25

do.end25:                                         ; preds = %do.body24
  br label %do.end26

do.end26:                                         ; preds = %do.end25
  br label %do.body27

do.body27:                                        ; preds = %do.end26
  br label %do.end28

do.end28:                                         ; preds = %do.body27
  br label %do.end29

do.end29:                                         ; preds = %do.end28
  br label %if.end

if.end:                                           ; preds = %do.end29, %if.then
  %8 = load i32, i32* %__ret_warn_on, align 4
  %tobool30 = icmp ne i32 %8, 0
  %lnot31 = xor i1 %tobool30, true
  %lnot33 = xor i1 %lnot31, true
  %lnot.ext34 = zext i1 %lnot33 to i32
  %conv35 = sext i32 %lnot.ext34 to i64
  store i64 %conv35, i64* %tmp, align 8
  %9 = load i64, i64* %tmp, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.end, %land.end
  %10 = load i32, i32* %__ret_warn_once, align 4
  %tobool38 = icmp ne i32 %10, 0
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  store i64 %conv43, i64* %tmp37, align 8
  %11 = load i64, i64* %tmp37, align 8
  %12 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %12, i32 0, i32 4
  %13 = load i32, i32* %len_total, align 4
  %14 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %14, i32 0, i32 3
  %15 = load i32, i32* %len_used, align 8
  %sub = sub i32 %13, %15
  %sub44 = sub i32 %sub, 1
  store i32 %sub44, i32* %__UNIQUE_ID___x372, align 4
  %16 = load i32, i32* %n, align 4
  store i32 %16, i32* %__UNIQUE_ID___y373, align 4
  %17 = load i32, i32* %__UNIQUE_ID___x372, align 4
  %18 = load i32, i32* %__UNIQUE_ID___y373, align 4
  %cmp46 = icmp ult i32 %17, %18
  br i1 %cmp46, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end36
  %19 = load i32, i32* %__UNIQUE_ID___x372, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end36
  %20 = load i32, i32* %__UNIQUE_ID___y373, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %19, %cond.true ], [ %20, %cond.false ]
  store i32 %cond, i32* %tmp45, align 4
  %21 = load i32, i32* %tmp45, align 4
  store i32 %21, i32* %n, align 4
  %22 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf48 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %22, i32 0, i32 1
  %23 = load i32, i32* %n, align 4
  %idxprom = zext i32 %23 to i64
  %arrayidx = getelementptr [1024 x i8], [1024 x i8]* %kbuf48, i64 0, i64 %idxprom
  store i8 0, i8* %arrayidx, align 1
  %24 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %24, i32 0, i32 0
  %25 = load i32, i32* %level, align 8
  %cmp49 = icmp eq i32 %25, 8
  br i1 %cmp49, label %if.then51, label %if.end55

if.then51:                                        ; preds = %cond.end
  %26 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf52 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %26, i32 0, i32 1
  %arraydecay53 = getelementptr inbounds [1024 x i8], [1024 x i8]* %kbuf52, i64 0, i64 0
  %call54 = call i32 (i8*, ...) @printk(i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2.3, i64 0, i64 0), i8* noundef %arraydecay53) #12
  br label %if.end66

if.end55:                                         ; preds = %cond.end
  %27 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %27, i32 0, i32 2
  %28 = load i8*, i8** %ubuf, align 8
  %29 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used56 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %29, i32 0, i32 3
  %30 = load i32, i32* %len_used56, align 8
  %idx.ext = zext i32 %30 to i64
  %add.ptr = getelementptr i8, i8* %28, i64 %idx.ext
  %31 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %kbuf57 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %31, i32 0, i32 1
  %arraydecay58 = getelementptr inbounds [1024 x i8], [1024 x i8]* %kbuf57, i64 0, i64 0
  %32 = load i32, i32* %n, align 4
  %add = add i32 %32, 1
  %conv59 = zext i32 %add to i64
  store i8* %add.ptr, i8** %to.addr.i, align 8
  store i8* %arraydecay58, i8** %from.addr.i, align 8
  store i64 %conv59, i64* %n.addr.i, align 8
  %33 = load i8*, i8** %from.addr.i, align 8
  %34 = load i64, i64* %n.addr.i, align 8
  store i8* %33, i8** %addr.addr.i, align 8
  store i64 %34, i64* %bytes.addr.i, align 8
  store i8 1, i8* %is_source.addr.i, align 1
  store i32 -1, i32* %sz.i, align 4
  %35 = load i32, i32* %sz.i, align 4
  %cmp.i = icmp sge i32 %35, 0
  br i1 %cmp.i, label %land.rhs.i, label %land.end.i

land.rhs.i:                                       ; preds = %if.end55
  %36 = load i32, i32* %sz.i, align 4
  %conv.i67 = sext i32 %36 to i64
  %37 = load i64, i64* %bytes.addr.i, align 8
  %cmp1.i = icmp ult i64 %conv.i67, %37
  br label %land.end.i

land.end.i:                                       ; preds = %land.rhs.i, %if.end55
  %38 = phi i1 [ false, %if.end55 ], [ %cmp1.i, %land.rhs.i ]
  %lnot.i68 = xor i1 %38, true
  %lnot.ext.i69 = zext i1 %38 to i32
  %conv4.i = sext i32 %lnot.ext.i69 to i64
  br i1 %38, label %if.then.i70, label %if.end10.i

if.then.i70:                                      ; preds = %land.end.i
  %39 = load i64, i64* %bytes.addr.i, align 8
  %40 = call i1 @llvm.is.constant.i64(i64 %39) #10
  br i1 %40, label %if.else.i, label %if.then5.i

if.then5.i:                                       ; preds = %if.then.i70
  %41 = load i32, i32* %sz.i, align 4
  %42 = load i64, i64* %bytes.addr.i, align 8
  call void @copy_overflow(i32 noundef %41, i64 noundef %42) #13
  br label %if.end9.i

if.else.i:                                        ; preds = %if.then.i70
  %43 = load i8, i8* %is_source.addr.i, align 1
  %tobool6.i = trunc i8 %43 to i1
  br i1 %tobool6.i, label %if.then7.i, label %if.else8.i

if.then7.i:                                       ; preds = %if.else.i
  call void @__bad_copy_from() #13
  br label %if.end.i

if.else8.i:                                       ; preds = %if.else.i
  call void @__bad_copy_to() #13
  br label %if.end.i

if.end.i:                                         ; preds = %if.else8.i, %if.then7.i
  br label %if.end9.i

if.end9.i:                                        ; preds = %if.end.i, %if.then5.i
  store i1 false, i1* %retval.i, align 1
  br label %check_copy_size.exit

if.end10.i:                                       ; preds = %land.end.i
  %44 = load i64, i64* %bytes.addr.i, align 8
  %cmp11.i = icmp ugt i64 %44, 2147483647
  %lnot13.i = xor i1 %cmp11.i, true
  %lnot.ext16.i = zext i1 %cmp11.i to i32
  store i32 %lnot.ext16.i, i32* %__ret_warn_on.i, align 4
  %45 = load i32, i32* %__ret_warn_on.i, align 4
  %tobool17.i = icmp ne i32 %45, 0
  %lnot18.i = xor i1 %tobool17.i, true
  %lnot.ext21.i = zext i1 %tobool17.i to i32
  %conv22.i = sext i32 %lnot.ext21.i to i64
  br i1 %tobool17.i, label %if.then24.i, label %if.end31.i

if.then24.i:                                      ; preds = %if.end10.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.25, i64 0, i64 0), i32 150, i32 2307, i64 12) #10, !srcloc !8
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 33) #10, !srcloc !9
  br label %if.end31.i

if.end31.i:                                       ; preds = %if.then24.i, %if.end10.i
  %46 = load i32, i32* %__ret_warn_on.i, align 4
  %tobool32.i = icmp ne i32 %46, 0
  %lnot33.i = xor i1 %tobool32.i, true
  %lnot.ext36.i = zext i1 %tobool32.i to i32
  %conv37.i = sext i32 %lnot.ext36.i to i64
  store i64 %conv37.i, i64* %tmp.i, align 8
  %47 = load i64, i64* %tmp.i, align 8
  %tobool38.i = icmp ne i64 %47, 0
  br i1 %tobool38.i, label %if.then39.i, label %if.end40.i

if.then39.i:                                      ; preds = %if.end31.i
  store i1 false, i1* %retval.i, align 1
  br label %check_copy_size.exit

if.end40.i:                                       ; preds = %if.end31.i
  %48 = load i8*, i8** %addr.addr.i, align 8
  %49 = load i64, i64* %bytes.addr.i, align 8
  %50 = load i8, i8* %is_source.addr.i, align 1
  %tobool41.i = trunc i8 %50 to i1
  call void @check_object_size(i8* noundef %48, i64 noundef %49, i1 noundef zeroext %tobool41.i) #13
  store i1 true, i1* %retval.i, align 1
  br label %check_copy_size.exit

check_copy_size.exit:                             ; preds = %if.end40.i, %if.then39.i, %if.end9.i
  %51 = load i1, i1* %retval.i, align 1
  %lnot.i = xor i1 %51, true
  %lnot.ext.i = zext i1 %51 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %51, label %if.then.i, label %copy_to_user.exit

if.then.i:                                        ; preds = %check_copy_size.exit
  %52 = load i8*, i8** %to.addr.i, align 8
  %53 = load i8*, i8** %from.addr.i, align 8
  %54 = load i64, i64* %n.addr.i, align 8
  %call2.i = call i64 @_copy_to_user(i8* noundef %52, i8* noundef %53, i64 noundef %54) #13
  store i64 %call2.i, i64* %n.addr.i, align 8
  br label %copy_to_user.exit

copy_to_user.exit:                                ; preds = %if.then.i, %check_copy_size.exit
  %55 = load i64, i64* %n.addr.i, align 8
  %tobool61 = icmp ne i64 %55, 0
  br i1 %tobool61, label %if.else, label %if.then62

if.then62:                                        ; preds = %copy_to_user.exit
  %56 = load i32, i32* %n, align 4
  %57 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used63 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %57, i32 0, i32 3
  %58 = load i32, i32* %len_used63, align 8
  %add64 = add i32 %58, %56
  store i32 %add64, i32* %len_used63, align 8
  br label %if.end66

if.else:                                          ; preds = %copy_to_user.exit
  %59 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf65 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %59, i32 0, i32 2
  store i8* null, i8** %ubuf65, align 8
  br label %if.end66

if.end66:                                         ; preds = %if.else, %if.then62, %if.then51
  ret void
}

; Function Attrs: nofree nosync nounwind willreturn
declare void @llvm.va_end(i8*) #3

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @vscnprintf(i8* noundef, i64 noundef, i8* noundef, %struct.__va_list_tag* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__warn_printk(i8* noundef, ...) #1

; Function Attrs: cold noredzone null_pointer_is_valid
declare dso_local i32 @printk(i8* noundef, ...) #4

; Function Attrs: convergent nofree nosync nounwind readnone willreturn
declare i1 @llvm.is.constant.i64(i64) #5

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @copy_overflow(i32 noundef %size, i64 noundef %count) #0 {
entry:
  %size.addr = alloca i32, align 4
  %count.addr = alloca i64, align 8
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store i32 %size, i32* %size.addr, align 4
  store i64 %count, i64* %count.addr, align 8
  store i32 1, i32* %__ret_warn_on, align 4
  %0 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body3

do.body3:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body3
  %1 = load i32, i32* %size.addr, align 4
  %2 = load i64, i64* %count.addr, align 8
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.26, i64 0, i64 0), i32 noundef %1, i64 noundef %2) #11
  br label %do.body4

do.body4:                                         ; preds = %do.end
  br label %do.body5

do.body5:                                         ; preds = %do.body4
  br label %do.end6

do.end6:                                          ; preds = %do.body5
  br label %do.body7

do.body7:                                         ; preds = %do.end6
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.25, i64 0, i64 0), i32 134, i32 2313, i64 12) #10, !srcloc !10
  br label %do.end8

do.end8:                                          ; preds = %do.body7
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 32) #10, !srcloc !11
  br label %do.body9

do.body9:                                         ; preds = %do.end8
  br label %do.end10

do.end10:                                         ; preds = %do.body9
  br label %do.end11

do.end11:                                         ; preds = %do.end10
  br label %do.body12

do.body12:                                        ; preds = %do.end11
  br label %do.end13

do.end13:                                         ; preds = %do.body12
  br label %do.end14

do.end14:                                         ; preds = %do.end13
  br label %if.end

if.end:                                           ; preds = %do.end14, %entry
  %3 = load i32, i32* %__ret_warn_on, align 4
  %tobool15 = icmp ne i32 %3, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  store i64 %conv20, i64* %tmp, align 8
  %4 = load i64, i64* %tmp, align 8
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bad_copy_from() #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bad_copy_to() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @check_object_size(i8* noundef %ptr, i64 noundef %n, i1 noundef zeroext %to_user) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %to_user.addr = alloca i8, align 1
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  %frombool = zext i1 %to_user to i8
  store i8 %frombool, i8* %to_user.addr, align 1
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @_copy_to_user(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_verifier_log_full(%struct.bpf_verifier_log* noundef %log) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %0, i32 0, i32 3
  %1 = load i32, i32* %len_used, align 8
  %2 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %2, i32 0, i32 4
  %3 = load i32, i32* %len_total, align 4
  %sub = sub i32 %3, 1
  %cmp = icmp uge i32 %1, %sub
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @bpf_log(%struct.bpf_verifier_log* noundef %log, i8* noundef %fmt, ...) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %fmt.addr = alloca i8*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %0) #11
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %1 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %2 = load i8*, i8** %fmt.addr, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %1, i8* noundef %2, %struct.__va_list_tag* noundef %arraydecay2) #11
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay34 = bitcast %struct.__va_list_tag* %arraydecay3 to i8*
  call void @llvm.va_end(i8* %arraydecay34)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i8* @kernel_type_name(i32 noundef %id) #0 {
entry:
  %id.addr = alloca i32, align 4
  store i32 %id, i32* %id.addr, align 4
  %0 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %1 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %2 = load i32, i32* %id.addr, align 4
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %1, i32 noundef %2) #11
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %call, i32 0, i32 0
  %3 = load i32, i32* %name_off, align 4
  %call1 = call i8* @btf_name_by_offset(%struct.btf* noundef %0, i32 noundef %3) #11
  ret i8* %call1
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_type_by_id(%struct.btf* noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @btf_name_by_offset(%struct.btf* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @check_ctx_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 2
  %1 = load i32, i32* %off, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load i32, i32* %regno.addr, align 4
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 2
  %6 = load i32, i32* %off1, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.3, i64 0, i64 0), i32 noundef %4, i32 noundef %6) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #11
  br i1 %call, label %lor.lhs.false, label %if.then4

lor.lhs.false:                                    ; preds = %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off2, i32 0, i32 0
  %14 = load i64, i64* %value, align 8
  %tobool3 = icmp ne i64 %14, 0
  br i1 %tobool3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %lor.lhs.false, %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %16 = bitcast %struct.tnum* %var_off5 to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call6 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %18, i64 %20) #11
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  %arraydecay7 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.4, i64 0, i64 0), i8* noundef %arraydecay7) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then4, %if.then
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @verbose(i8* noundef %private_data, i8* noundef %fmt, ...) #0 {
entry:
  %private_data.addr = alloca i8*, align 8
  %fmt.addr = alloca i8*, align 8
  %env = alloca %struct.bpf_verifier_env*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store i8* %private_data, i8** %private_data.addr, align 8
  store i8* %fmt, i8** %fmt.addr, align 8
  %0 = load i8*, i8** %private_data.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_verifier_env*
  store %struct.bpf_verifier_env* %1, %struct.bpf_verifier_env** %env, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 22
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #11
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 22
  %4 = load i8*, i8** %fmt.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log2, i8* noundef %4, %struct.__va_list_tag* noundef %arraydecay3) #11
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay45 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  call void @llvm.va_end(i8* %arraydecay45)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_is_const(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %3 = load i64, i64* %mask, align 8
  %tobool = icmp ne i64 %3, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @reg_bounds_sync___(%struct.bpf_reg_state* noundef %dst_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %0) #11
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %1) #11
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %2) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__update_reg_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %0) #11
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg64_bounds(%struct.bpf_reg_state* noundef %1) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg32_deduce_bounds(%struct.bpf_reg_state* noundef %0) #11
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg64_deduce_bounds(%struct.bpf_reg_state* noundef %1) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_bound_offset(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %var64_off = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %var32_off = alloca %struct.tnum, align 8
  %agg.tmp2 = alloca %struct.tnum, align 8
  %agg.tmp5 = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp10 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 8
  %2 = load i64, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 9
  %4 = load i64, i64* %umax_value, align 8
  %call = call { i64, i64 } @tnum_range(i64 noundef %2, i64 noundef %4) #11
  %5 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %15 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = load i64, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = load i64, i64* %18, align 8
  %call1 = call { i64, i64 } @tnum_intersect(i64 %12, i64 %14, i64 %17, i64 %19) #11
  %20 = bitcast %struct.tnum* %var64_off to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = extractvalue { i64, i64 } %call1, 0
  store i64 %22, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = extractvalue { i64, i64 } %call1, 1
  store i64 %24, i64* %23, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 5
  %26 = bitcast %struct.tnum* %var_off3 to { i64, i64 }*
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 0
  %28 = load i64, i64* %27, align 8
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %26, i32 0, i32 1
  %30 = load i64, i64* %29, align 8
  %call4 = call { i64, i64 } @tnum_subreg(i64 %28, i64 %30) #11
  %31 = bitcast %struct.tnum* %agg.tmp2 to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = extractvalue { i64, i64 } %call4, 0
  store i64 %33, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = extractvalue { i64, i64 } %call4, 1
  store i64 %35, i64* %34, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 12
  %37 = load i32, i32* %u32_min_value, align 8
  %conv = zext i32 %37 to i64
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 13
  %39 = load i32, i32* %u32_max_value, align 4
  %conv6 = zext i32 %39 to i64
  %call7 = call { i64, i64 } @tnum_range(i64 noundef %conv, i64 noundef %conv6) #11
  %40 = bitcast %struct.tnum* %agg.tmp5 to { i64, i64 }*
  %41 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %40, i32 0, i32 0
  %42 = extractvalue { i64, i64 } %call7, 0
  store i64 %42, i64* %41, align 8
  %43 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %40, i32 0, i32 1
  %44 = extractvalue { i64, i64 } %call7, 1
  store i64 %44, i64* %43, align 8
  %45 = bitcast %struct.tnum* %agg.tmp2 to { i64, i64 }*
  %46 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %45, i32 0, i32 0
  %47 = load i64, i64* %46, align 8
  %48 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %45, i32 0, i32 1
  %49 = load i64, i64* %48, align 8
  %50 = bitcast %struct.tnum* %agg.tmp5 to { i64, i64 }*
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 0
  %52 = load i64, i64* %51, align 8
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 1
  %54 = load i64, i64* %53, align 8
  %call8 = call { i64, i64 } @tnum_intersect(i64 %47, i64 %49, i64 %52, i64 %54) #11
  %55 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 0
  %57 = extractvalue { i64, i64 } %call8, 0
  store i64 %57, i64* %56, align 8
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 1
  %59 = extractvalue { i64, i64 } %call8, 1
  store i64 %59, i64* %58, align 8
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i32 0, i32 5
  %61 = bitcast %struct.tnum* %var64_off to { i64, i64 }*
  %62 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 0
  %63 = load i64, i64* %62, align 8
  %64 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %61, i32 0, i32 1
  %65 = load i64, i64* %64, align 8
  %call11 = call { i64, i64 } @tnum_clear_subreg(i64 %63, i64 %65) #11
  %66 = bitcast %struct.tnum* %agg.tmp10 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = extractvalue { i64, i64 } %call11, 0
  store i64 %68, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = extractvalue { i64, i64 } %call11, 1
  store i64 %70, i64* %69, align 8
  %71 = bitcast %struct.tnum* %agg.tmp10 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %76 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %77 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 0
  %78 = load i64, i64* %77, align 8
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 1
  %80 = load i64, i64* %79, align 8
  %call12 = call { i64, i64 } @tnum_or(i64 %73, i64 %75, i64 %78, i64 %80) #11
  %81 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %82 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 0
  %83 = extractvalue { i64, i64 } %call12, 0
  store i64 %83, i64* %82, align 8
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 1
  %85 = extractvalue { i64, i64 } %call12, 1
  store i64 %85, i64* %84, align 8
  %86 = bitcast %struct.tnum* %var_off9 to i8*
  %87 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %86, i8* align 8 %87, i64 16, i1 false)
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg32_deduce_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x395 = alloca i32, align 4
  %__UNIQUE_ID___y396 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__UNIQUE_ID___x397 = alloca i32, align 4
  %__UNIQUE_ID___y398 = alloca i32, align 4
  %tmp7 = alloca i32, align 4
  %__UNIQUE_ID___x399 = alloca i32, align 4
  %__UNIQUE_ID___y400 = alloca i32, align 4
  %tmp22 = alloca i32, align 4
  %__UNIQUE_ID___x401 = alloca i32, align 4
  %__UNIQUE_ID___y402 = alloca i32, align 4
  %tmp35 = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  %1 = load i32, i32* %s32_min_value, align 8
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 11
  %3 = load i32, i32* %s32_max_value, align 4
  %cmp1 = icmp slt i32 %3, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 10
  %5 = load i32, i32* %s32_min_value2, align 8
  store i32 %5, i32* %__UNIQUE_ID___x395, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 12
  %7 = load i32, i32* %u32_min_value, align 8
  store i32 %7, i32* %__UNIQUE_ID___y396, align 4
  %8 = load i32, i32* %__UNIQUE_ID___x395, align 4
  %9 = load i32, i32* %__UNIQUE_ID___y396, align 4
  %cmp3 = icmp ugt i32 %8, %9
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %10 = load i32, i32* %__UNIQUE_ID___x395, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %11 = load i32, i32* %__UNIQUE_ID___y396, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %12 = load i32, i32* %tmp, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 12
  store i32 %12, i32* %u32_min_value4, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  store i32 %12, i32* %s32_min_value5, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 11
  %16 = load i32, i32* %s32_max_value6, align 4
  store i32 %16, i32* %__UNIQUE_ID___x397, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 13
  %18 = load i32, i32* %u32_max_value, align 4
  store i32 %18, i32* %__UNIQUE_ID___y398, align 4
  %19 = load i32, i32* %__UNIQUE_ID___x397, align 4
  %20 = load i32, i32* %__UNIQUE_ID___y398, align 4
  %cmp8 = icmp ult i32 %19, %20
  br i1 %cmp8, label %cond.true9, label %cond.false10

cond.true9:                                       ; preds = %cond.end
  %21 = load i32, i32* %__UNIQUE_ID___x397, align 4
  br label %cond.end11

cond.false10:                                     ; preds = %cond.end
  %22 = load i32, i32* %__UNIQUE_ID___y398, align 4
  br label %cond.end11

cond.end11:                                       ; preds = %cond.false10, %cond.true9
  %cond12 = phi i32 [ %21, %cond.true9 ], [ %22, %cond.false10 ]
  store i32 %cond12, i32* %tmp7, align 4
  %23 = load i32, i32* %tmp7, align 4
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 13
  store i32 %23, i32* %u32_max_value13, align 4
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 11
  store i32 %23, i32* %s32_max_value14, align 4
  br label %if.end46

if.end:                                           ; preds = %lor.lhs.false
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 13
  %27 = load i32, i32* %u32_max_value15, align 4
  %cmp16 = icmp sge i32 %27, 0
  br i1 %cmp16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 12
  %29 = load i32, i32* %u32_min_value18, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 10
  store i32 %29, i32* %s32_min_value19, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 11
  %32 = load i32, i32* %s32_max_value20, align 4
  store i32 %32, i32* %__UNIQUE_ID___x399, align 4
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 13
  %34 = load i32, i32* %u32_max_value21, align 4
  store i32 %34, i32* %__UNIQUE_ID___y400, align 4
  %35 = load i32, i32* %__UNIQUE_ID___x399, align 4
  %36 = load i32, i32* %__UNIQUE_ID___y400, align 4
  %cmp23 = icmp ult i32 %35, %36
  br i1 %cmp23, label %cond.true24, label %cond.false25

cond.true24:                                      ; preds = %if.then17
  %37 = load i32, i32* %__UNIQUE_ID___x399, align 4
  br label %cond.end26

cond.false25:                                     ; preds = %if.then17
  %38 = load i32, i32* %__UNIQUE_ID___y400, align 4
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false25, %cond.true24
  %cond27 = phi i32 [ %37, %cond.true24 ], [ %38, %cond.false25 ]
  store i32 %cond27, i32* %tmp22, align 4
  %39 = load i32, i32* %tmp22, align 4
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 13
  store i32 %39, i32* %u32_max_value28, align 4
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 11
  store i32 %39, i32* %s32_max_value29, align 4
  br label %if.end46

if.else:                                          ; preds = %if.end
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 12
  %43 = load i32, i32* %u32_min_value30, align 8
  %cmp31 = icmp slt i32 %43, 0
  br i1 %cmp31, label %if.then32, label %if.end45

if.then32:                                        ; preds = %if.else
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 10
  %45 = load i32, i32* %s32_min_value33, align 8
  store i32 %45, i32* %__UNIQUE_ID___x401, align 4
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 12
  %47 = load i32, i32* %u32_min_value34, align 8
  store i32 %47, i32* %__UNIQUE_ID___y402, align 4
  %48 = load i32, i32* %__UNIQUE_ID___x401, align 4
  %49 = load i32, i32* %__UNIQUE_ID___y402, align 4
  %cmp36 = icmp ugt i32 %48, %49
  br i1 %cmp36, label %cond.true37, label %cond.false38

cond.true37:                                      ; preds = %if.then32
  %50 = load i32, i32* %__UNIQUE_ID___x401, align 4
  br label %cond.end39

cond.false38:                                     ; preds = %if.then32
  %51 = load i32, i32* %__UNIQUE_ID___y402, align 4
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true37
  %cond40 = phi i32 [ %50, %cond.true37 ], [ %51, %cond.false38 ]
  store i32 %cond40, i32* %tmp35, align 4
  %52 = load i32, i32* %tmp35, align 4
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 12
  store i32 %52, i32* %u32_min_value41, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 10
  store i32 %52, i32* %s32_min_value42, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 13
  %56 = load i32, i32* %u32_max_value43, align 4
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 11
  store i32 %56, i32* %s32_max_value44, align 4
  br label %if.end45

if.end45:                                         ; preds = %cond.end39, %if.else
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %cond.end26, %cond.end11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg64_deduce_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x403 = alloca i64, align 8
  %__UNIQUE_ID___y404 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__UNIQUE_ID___x405 = alloca i64, align 8
  %__UNIQUE_ID___y406 = alloca i64, align 8
  %tmp7 = alloca i64, align 8
  %__UNIQUE_ID___x407 = alloca i64, align 8
  %__UNIQUE_ID___y408 = alloca i64, align 8
  %tmp22 = alloca i64, align 8
  %__UNIQUE_ID___x409 = alloca i64, align 8
  %__UNIQUE_ID___y410 = alloca i64, align 8
  %tmp35 = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  %cmp = icmp sge i64 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 7
  %3 = load i64, i64* %smax_value, align 8
  %cmp1 = icmp slt i64 %3, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 6
  %5 = load i64, i64* %smin_value2, align 8
  store i64 %5, i64* %__UNIQUE_ID___x403, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 8
  %7 = load i64, i64* %umin_value, align 8
  store i64 %7, i64* %__UNIQUE_ID___y404, align 8
  %8 = load i64, i64* %__UNIQUE_ID___x403, align 8
  %9 = load i64, i64* %__UNIQUE_ID___y404, align 8
  %cmp3 = icmp ugt i64 %8, %9
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %10 = load i64, i64* %__UNIQUE_ID___x403, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %11 = load i64, i64* %__UNIQUE_ID___y404, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %10, %cond.true ], [ %11, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %12 = load i64, i64* %tmp, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 8
  store i64 %12, i64* %umin_value4, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 %12, i64* %smin_value5, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  %16 = load i64, i64* %smax_value6, align 8
  store i64 %16, i64* %__UNIQUE_ID___x405, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 9
  %18 = load i64, i64* %umax_value, align 8
  store i64 %18, i64* %__UNIQUE_ID___y406, align 8
  %19 = load i64, i64* %__UNIQUE_ID___x405, align 8
  %20 = load i64, i64* %__UNIQUE_ID___y406, align 8
  %cmp8 = icmp ult i64 %19, %20
  br i1 %cmp8, label %cond.true9, label %cond.false10

cond.true9:                                       ; preds = %cond.end
  %21 = load i64, i64* %__UNIQUE_ID___x405, align 8
  br label %cond.end11

cond.false10:                                     ; preds = %cond.end
  %22 = load i64, i64* %__UNIQUE_ID___y406, align 8
  br label %cond.end11

cond.end11:                                       ; preds = %cond.false10, %cond.true9
  %cond12 = phi i64 [ %21, %cond.true9 ], [ %22, %cond.false10 ]
  store i64 %cond12, i64* %tmp7, align 8
  %23 = load i64, i64* %tmp7, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 9
  store i64 %23, i64* %umax_value13, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 7
  store i64 %23, i64* %smax_value14, align 8
  br label %if.end46

if.end:                                           ; preds = %lor.lhs.false
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  %27 = load i64, i64* %umax_value15, align 8
  %cmp16 = icmp sge i64 %27, 0
  br i1 %cmp16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 8
  %29 = load i64, i64* %umin_value18, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 6
  store i64 %29, i64* %smin_value19, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 7
  %32 = load i64, i64* %smax_value20, align 8
  store i64 %32, i64* %__UNIQUE_ID___x407, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 9
  %34 = load i64, i64* %umax_value21, align 8
  store i64 %34, i64* %__UNIQUE_ID___y408, align 8
  %35 = load i64, i64* %__UNIQUE_ID___x407, align 8
  %36 = load i64, i64* %__UNIQUE_ID___y408, align 8
  %cmp23 = icmp ult i64 %35, %36
  br i1 %cmp23, label %cond.true24, label %cond.false25

cond.true24:                                      ; preds = %if.then17
  %37 = load i64, i64* %__UNIQUE_ID___x407, align 8
  br label %cond.end26

cond.false25:                                     ; preds = %if.then17
  %38 = load i64, i64* %__UNIQUE_ID___y408, align 8
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false25, %cond.true24
  %cond27 = phi i64 [ %37, %cond.true24 ], [ %38, %cond.false25 ]
  store i64 %cond27, i64* %tmp22, align 8
  %39 = load i64, i64* %tmp22, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 9
  store i64 %39, i64* %umax_value28, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 7
  store i64 %39, i64* %smax_value29, align 8
  br label %if.end46

if.else:                                          ; preds = %if.end
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 8
  %43 = load i64, i64* %umin_value30, align 8
  %cmp31 = icmp slt i64 %43, 0
  br i1 %cmp31, label %if.then32, label %if.end45

if.then32:                                        ; preds = %if.else
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 6
  %45 = load i64, i64* %smin_value33, align 8
  store i64 %45, i64* %__UNIQUE_ID___x409, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 8
  %47 = load i64, i64* %umin_value34, align 8
  store i64 %47, i64* %__UNIQUE_ID___y410, align 8
  %48 = load i64, i64* %__UNIQUE_ID___x409, align 8
  %49 = load i64, i64* %__UNIQUE_ID___y410, align 8
  %cmp36 = icmp ugt i64 %48, %49
  br i1 %cmp36, label %cond.true37, label %cond.false38

cond.true37:                                      ; preds = %if.then32
  %50 = load i64, i64* %__UNIQUE_ID___x409, align 8
  br label %cond.end39

cond.false38:                                     ; preds = %if.then32
  %51 = load i64, i64* %__UNIQUE_ID___y410, align 8
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true37
  %cond40 = phi i64 [ %50, %cond.true37 ], [ %51, %cond.false38 ]
  store i64 %cond40, i64* %tmp35, align 8
  %52 = load i64, i64* %tmp35, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 8
  store i64 %52, i64* %umin_value41, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 6
  store i64 %52, i64* %smin_value42, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %55, i32 0, i32 9
  %56 = load i64, i64* %umax_value43, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 7
  store i64 %56, i64* %smax_value44, align 8
  br label %if.end45

if.end45:                                         ; preds = %cond.end39, %if.else
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %cond.end26, %cond.end11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %var32_off = alloca %struct.tnum, align 8
  %__UNIQUE_ID___x379 = alloca i32, align 4
  %__UNIQUE_ID___y380 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__UNIQUE_ID___x381 = alloca i32, align 4
  %__UNIQUE_ID___y382 = alloca i32, align 4
  %tmp8 = alloca i32, align 4
  %__UNIQUE_ID___x383 = alloca i32, align 4
  %__UNIQUE_ID___y384 = alloca i32, align 4
  %tmp18 = alloca i32, align 4
  %__UNIQUE_ID___x385 = alloca i32, align 4
  %__UNIQUE_ID___y386 = alloca i32, align 4
  %tmp30 = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %3, i64 %5) #11
  %6 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 10
  %12 = load i32, i32* %s32_min_value, align 8
  store i32 %12, i32* %__UNIQUE_ID___x379, align 4
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %13 = load i64, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %14 = load i64, i64* %mask, align 8
  %and = and i64 %14, -2147483648
  %or = or i64 %13, %and
  %conv = trunc i64 %or to i32
  store i32 %conv, i32* %__UNIQUE_ID___y380, align 4
  %15 = load i32, i32* %__UNIQUE_ID___x379, align 4
  %16 = load i32, i32* %__UNIQUE_ID___y380, align 4
  %cmp = icmp sgt i32 %15, %16
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %17 = load i32, i32* %__UNIQUE_ID___x379, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %18 = load i32, i32* %__UNIQUE_ID___y380, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %17, %cond.true ], [ %18, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %19 = load i32, i32* %tmp, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 10
  store i32 %19, i32* %s32_min_value2, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 11
  %22 = load i32, i32* %s32_max_value, align 4
  store i32 %22, i32* %__UNIQUE_ID___x381, align 4
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %23 = load i64, i64* %value3, align 8
  %mask4 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %24 = load i64, i64* %mask4, align 8
  %and5 = and i64 %24, 2147483647
  %or6 = or i64 %23, %and5
  %conv7 = trunc i64 %or6 to i32
  store i32 %conv7, i32* %__UNIQUE_ID___y382, align 4
  %25 = load i32, i32* %__UNIQUE_ID___x381, align 4
  %26 = load i32, i32* %__UNIQUE_ID___y382, align 4
  %cmp9 = icmp slt i32 %25, %26
  br i1 %cmp9, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.end
  %27 = load i32, i32* %__UNIQUE_ID___x381, align 4
  br label %cond.end13

cond.false12:                                     ; preds = %cond.end
  %28 = load i32, i32* %__UNIQUE_ID___y382, align 4
  br label %cond.end13

cond.end13:                                       ; preds = %cond.false12, %cond.true11
  %cond14 = phi i32 [ %27, %cond.true11 ], [ %28, %cond.false12 ]
  store i32 %cond14, i32* %tmp8, align 4
  %29 = load i32, i32* %tmp8, align 4
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 11
  store i32 %29, i32* %s32_max_value15, align 4
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 12
  %32 = load i32, i32* %u32_min_value, align 8
  store i32 %32, i32* %__UNIQUE_ID___x383, align 4
  %value16 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %33 = load i64, i64* %value16, align 8
  %conv17 = trunc i64 %33 to i32
  store i32 %conv17, i32* %__UNIQUE_ID___y384, align 4
  %34 = load i32, i32* %__UNIQUE_ID___x383, align 4
  %35 = load i32, i32* %__UNIQUE_ID___y384, align 4
  %cmp19 = icmp ugt i32 %34, %35
  br i1 %cmp19, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.end13
  %36 = load i32, i32* %__UNIQUE_ID___x383, align 4
  br label %cond.end23

cond.false22:                                     ; preds = %cond.end13
  %37 = load i32, i32* %__UNIQUE_ID___y384, align 4
  br label %cond.end23

cond.end23:                                       ; preds = %cond.false22, %cond.true21
  %cond24 = phi i32 [ %36, %cond.true21 ], [ %37, %cond.false22 ]
  store i32 %cond24, i32* %tmp18, align 4
  %38 = load i32, i32* %tmp18, align 4
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 12
  store i32 %38, i32* %u32_min_value25, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 13
  %41 = load i32, i32* %u32_max_value, align 4
  store i32 %41, i32* %__UNIQUE_ID___x385, align 4
  %value26 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %42 = load i64, i64* %value26, align 8
  %mask27 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %43 = load i64, i64* %mask27, align 8
  %or28 = or i64 %42, %43
  %conv29 = trunc i64 %or28 to i32
  store i32 %conv29, i32* %__UNIQUE_ID___y386, align 4
  %44 = load i32, i32* %__UNIQUE_ID___x385, align 4
  %45 = load i32, i32* %__UNIQUE_ID___y386, align 4
  %cmp31 = icmp ult i32 %44, %45
  br i1 %cmp31, label %cond.true33, label %cond.false34

cond.true33:                                      ; preds = %cond.end23
  %46 = load i32, i32* %__UNIQUE_ID___x385, align 4
  br label %cond.end35

cond.false34:                                     ; preds = %cond.end23
  %47 = load i32, i32* %__UNIQUE_ID___y386, align 4
  br label %cond.end35

cond.end35:                                       ; preds = %cond.false34, %cond.true33
  %cond36 = phi i32 [ %46, %cond.true33 ], [ %47, %cond.false34 ]
  store i32 %cond36, i32* %tmp30, align 4
  %48 = load i32, i32* %tmp30, align 4
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value37 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 13
  store i32 %48, i32* %u32_max_value37, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__update_reg64_bounds(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x387 = alloca i64, align 8
  %__UNIQUE_ID___y388 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__UNIQUE_ID___x389 = alloca i64, align 8
  %__UNIQUE_ID___y390 = alloca i64, align 8
  %tmp9 = alloca i64, align 8
  %__UNIQUE_ID___x391 = alloca i64, align 8
  %__UNIQUE_ID___y392 = alloca i64, align 8
  %tmp18 = alloca i64, align 8
  %__UNIQUE_ID___x393 = alloca i64, align 8
  %__UNIQUE_ID___y394 = alloca i64, align 8
  %tmp30 = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %__UNIQUE_ID___x387, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %3 = load i64, i64* %value, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off1, i32 0, i32 1
  %5 = load i64, i64* %mask, align 8
  %and = and i64 %5, -9223372036854775808
  %or = or i64 %3, %and
  store i64 %or, i64* %__UNIQUE_ID___y388, align 8
  %6 = load i64, i64* %__UNIQUE_ID___x387, align 8
  %7 = load i64, i64* %__UNIQUE_ID___y388, align 8
  %cmp = icmp sgt i64 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i64, i64* %__UNIQUE_ID___x387, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load i64, i64* %__UNIQUE_ID___y388, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %8, %cond.true ], [ %9, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %10 = load i64, i64* %tmp, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 6
  store i64 %10, i64* %smin_value2, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  store i64 %13, i64* %__UNIQUE_ID___x389, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %value4 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off3, i32 0, i32 0
  %15 = load i64, i64* %value4, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 5
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 1
  %17 = load i64, i64* %mask6, align 8
  %and7 = and i64 %17, 9223372036854775807
  %or8 = or i64 %15, %and7
  store i64 %or8, i64* %__UNIQUE_ID___y390, align 8
  %18 = load i64, i64* %__UNIQUE_ID___x389, align 8
  %19 = load i64, i64* %__UNIQUE_ID___y390, align 8
  %cmp10 = icmp slt i64 %18, %19
  br i1 %cmp10, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.end
  %20 = load i64, i64* %__UNIQUE_ID___x389, align 8
  br label %cond.end13

cond.false12:                                     ; preds = %cond.end
  %21 = load i64, i64* %__UNIQUE_ID___y390, align 8
  br label %cond.end13

cond.end13:                                       ; preds = %cond.false12, %cond.true11
  %cond14 = phi i64 [ %20, %cond.true11 ], [ %21, %cond.false12 ]
  store i64 %cond14, i64* %tmp9, align 8
  %22 = load i64, i64* %tmp9, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 7
  store i64 %22, i64* %smax_value15, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 8
  %25 = load i64, i64* %umin_value, align 8
  store i64 %25, i64* %__UNIQUE_ID___x391, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 5
  %value17 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off16, i32 0, i32 0
  %27 = load i64, i64* %value17, align 8
  store i64 %27, i64* %__UNIQUE_ID___y392, align 8
  %28 = load i64, i64* %__UNIQUE_ID___x391, align 8
  %29 = load i64, i64* %__UNIQUE_ID___y392, align 8
  %cmp19 = icmp ugt i64 %28, %29
  br i1 %cmp19, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %cond.end13
  %30 = load i64, i64* %__UNIQUE_ID___x391, align 8
  br label %cond.end22

cond.false21:                                     ; preds = %cond.end13
  %31 = load i64, i64* %__UNIQUE_ID___y392, align 8
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false21, %cond.true20
  %cond23 = phi i64 [ %30, %cond.true20 ], [ %31, %cond.false21 ]
  store i64 %cond23, i64* %tmp18, align 8
  %32 = load i64, i64* %tmp18, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 8
  store i64 %32, i64* %umin_value24, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 9
  %35 = load i64, i64* %umax_value, align 8
  store i64 %35, i64* %__UNIQUE_ID___x393, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 5
  %value26 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off25, i32 0, i32 0
  %37 = load i64, i64* %value26, align 8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 5
  %mask28 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off27, i32 0, i32 1
  %39 = load i64, i64* %mask28, align 8
  %or29 = or i64 %37, %39
  store i64 %or29, i64* %__UNIQUE_ID___y394, align 8
  %40 = load i64, i64* %__UNIQUE_ID___x393, align 8
  %41 = load i64, i64* %__UNIQUE_ID___y394, align 8
  %cmp31 = icmp ult i64 %40, %41
  br i1 %cmp31, label %cond.true32, label %cond.false33

cond.true32:                                      ; preds = %cond.end22
  %42 = load i64, i64* %__UNIQUE_ID___x393, align 8
  br label %cond.end34

cond.false33:                                     ; preds = %cond.end22
  %43 = load i64, i64* %__UNIQUE_ID___y394, align 8
  br label %cond.end34

cond.end34:                                       ; preds = %cond.false33, %cond.true32
  %cond35 = phi i64 [ %42, %cond.true32 ], [ %43, %cond.false33 ]
  store i64 %cond35, i64* %tmp30, align 8
  %44 = load i64, i64* %tmp30, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value36 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 9
  store i64 %44, i64* %umax_value36, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ADD(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %src_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %opcode = alloca i8, align 1
  %src_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  %s32_min_val = alloca i32, align 4
  %s32_max_val = alloca i32, align 4
  %u32_min_val = alloca i32, align 4
  %u32_max_val = alloca i32, align 4
  %insn_bitness = alloca i64, align 8
  %dst = alloca i32, align 4
  %ret = alloca i32, align 4
  %alu32 = alloca i8, align 1
  %tmp = alloca %struct.tnum, align 8
  %tmp81 = alloca %struct.tnum, align 8
  %tmp87 = alloca %struct.tnum, align 8
  %tmp93 = alloca %struct.tnum, align 8
  %tmp99 = alloca %struct.tnum, align 8
  %tmp105 = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 0
  %2 = load i8, i8* %code, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %opcode, align 1
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %3, i32 0, i32 0
  %4 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %4 to i32
  %and4 = and i32 %conv3, 7
  %cmp = icmp eq i32 %and4, 7
  %5 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 64, i32 32
  %conv6 = sext i32 %cond to i64
  store i64 %conv6, i64* %insn_bitness, align 8
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg7, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv8 = zext i8 %bf.clear to i32
  store i32 %conv8, i32* %dst, align 4
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 0
  %8 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %8 to i32
  %and11 = and i32 %conv10, 7
  %cmp12 = icmp ne i32 %and11, 7
  %frombool = zext i1 %cmp12 to i8
  store i8 %frombool, i8* %alu32, align 1
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  store i64 %9, i64* %smin_val, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 7
  %10 = load i64, i64* %smax_value, align 8
  store i64 %10, i64* %smax_val, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 8
  %11 = load i64, i64* %umin_value, align 8
  store i64 %11, i64* %umin_val, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 9
  %12 = load i64, i64* %umax_value, align 8
  store i64 %12, i64* %umax_val, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 10
  %13 = load i32, i32* %s32_min_value, align 8
  store i32 %13, i32* %s32_min_val, align 4
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 11
  %14 = load i32, i32* %s32_max_value, align 4
  store i32 %14, i32* %s32_max_val, align 4
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 12
  %15 = load i32, i32* %u32_min_value, align 8
  store i32 %15, i32* %u32_min_val, align 4
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 13
  %16 = load i32, i32* %u32_max_value, align 4
  store i32 %16, i32* %u32_max_val, align 4
  %17 = load i8, i8* %alu32, align 1
  %tobool = trunc i8 %17 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %18 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = load i64, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = load i64, i64* %21, align 8
  %call14 = call zeroext i1 @tnum_subreg_is_const(i64 %20, i64 %22) #11
  %frombool15 = zext i1 %call14 to i8
  store i8 %frombool15, i8* %src_known, align 1
  %23 = load i8, i8* %src_known, align 1
  %tobool16 = trunc i8 %23 to i1
  br i1 %tobool16, label %land.lhs.true, label %lor.lhs.false22

land.lhs.true:                                    ; preds = %if.then
  %24 = load i32, i32* %s32_min_val, align 4
  %25 = load i32, i32* %s32_max_val, align 4
  %cmp18 = icmp ne i32 %24, %25
  br i1 %cmp18, label %if.then28, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %26 = load i32, i32* %u32_min_val, align 4
  %27 = load i32, i32* %u32_max_val, align 4
  %cmp20 = icmp ne i32 %26, %27
  br i1 %cmp20, label %if.then28, label %lor.lhs.false22

lor.lhs.false22:                                  ; preds = %lor.lhs.false, %if.then
  %28 = load i32, i32* %s32_min_val, align 4
  %29 = load i32, i32* %s32_max_val, align 4
  %cmp23 = icmp sgt i32 %28, %29
  br i1 %cmp23, label %if.then28, label %lor.lhs.false25

lor.lhs.false25:                                  ; preds = %lor.lhs.false22
  %30 = load i32, i32* %u32_min_val, align 4
  %31 = load i32, i32* %u32_max_val, align 4
  %cmp26 = icmp ugt i32 %30, %31
  br i1 %cmp26, label %if.then28, label %if.end

if.then28:                                        ; preds = %lor.lhs.false25, %lor.lhs.false22, %lor.lhs.false, %land.lhs.true
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %32, %struct.bpf_reg_state* noundef %33) #11
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false25
  br label %if.end48

if.else:                                          ; preds = %entry
  %var_off29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %34 = bitcast %struct.tnum* %var_off29 to { i64, i64 }*
  %35 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %34, i32 0, i32 0
  %36 = load i64, i64* %35, align 8
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %34, i32 0, i32 1
  %38 = load i64, i64* %37, align 8
  %call30 = call zeroext i1 @tnum_is_const(i64 %36, i64 %38) #11
  %frombool31 = zext i1 %call30 to i8
  store i8 %frombool31, i8* %src_known, align 1
  %39 = load i8, i8* %src_known, align 1
  %tobool32 = trunc i8 %39 to i1
  br i1 %tobool32, label %land.lhs.true34, label %lor.lhs.false40

land.lhs.true34:                                  ; preds = %if.else
  %40 = load i64, i64* %smin_val, align 8
  %41 = load i64, i64* %smax_val, align 8
  %cmp35 = icmp ne i64 %40, %41
  br i1 %cmp35, label %if.then46, label %lor.lhs.false37

lor.lhs.false37:                                  ; preds = %land.lhs.true34
  %42 = load i64, i64* %umin_val, align 8
  %43 = load i64, i64* %umax_val, align 8
  %cmp38 = icmp ne i64 %42, %43
  br i1 %cmp38, label %if.then46, label %lor.lhs.false40

lor.lhs.false40:                                  ; preds = %lor.lhs.false37, %if.else
  %44 = load i64, i64* %smin_val, align 8
  %45 = load i64, i64* %smax_val, align 8
  %cmp41 = icmp sgt i64 %44, %45
  br i1 %cmp41, label %if.then46, label %lor.lhs.false43

lor.lhs.false43:                                  ; preds = %lor.lhs.false40
  %46 = load i64, i64* %umin_val, align 8
  %47 = load i64, i64* %umax_val, align 8
  %cmp44 = icmp ugt i64 %46, %47
  br i1 %cmp44, label %if.then46, label %if.end47

if.then46:                                        ; preds = %lor.lhs.false43, %lor.lhs.false40, %lor.lhs.false37, %land.lhs.true34
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %48, %struct.bpf_reg_state* noundef %49) #11
  store i32 0, i32* %retval, align 4
  br label %return

if.end47:                                         ; preds = %lor.lhs.false43
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.end
  %50 = load i8, i8* %src_known, align 1
  %tobool49 = trunc i8 %50 to i1
  br i1 %tobool49, label %if.end63, label %land.lhs.true50

land.lhs.true50:                                  ; preds = %if.end48
  %51 = load i8, i8* %opcode, align 1
  %conv51 = zext i8 %51 to i32
  %cmp52 = icmp ne i32 %conv51, 0
  br i1 %cmp52, label %land.lhs.true54, label %if.end63

land.lhs.true54:                                  ; preds = %land.lhs.true50
  %52 = load i8, i8* %opcode, align 1
  %conv55 = zext i8 %52 to i32
  %cmp56 = icmp ne i32 %conv55, 16
  br i1 %cmp56, label %land.lhs.true58, label %if.end63

land.lhs.true58:                                  ; preds = %land.lhs.true54
  %53 = load i8, i8* %opcode, align 1
  %conv59 = zext i8 %53 to i32
  %cmp60 = icmp ne i32 %conv59, 80
  br i1 %cmp60, label %if.then62, label %if.end63

if.then62:                                        ; preds = %land.lhs.true58
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %54, %struct.bpf_reg_state* noundef %55) #11
  store i32 0, i32* %retval, align 4
  br label %return

if.end63:                                         ; preds = %land.lhs.true58, %land.lhs.true54, %land.lhs.true50, %if.end48
  %56 = load i8, i8* %opcode, align 1
  %conv64 = zext i8 %56 to i32
  switch i32 %conv64, label %sw.default [
    i32 0, label %sw.bb
    i32 16, label %sw.bb74
    i32 32, label %sw.bb85
    i32 80, label %sw.bb91
    i32 64, label %sw.bb97
    i32 160, label %sw.bb103
    i32 96, label %sw.bb109
    i32 112, label %sw.bb118
    i32 192, label %sw.bb127
  ]

sw.bb:                                            ; preds = %if.end63
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call65 = call i32 @sanitize_val_alu(%struct.bpf_verifier_env* noundef %57, %struct.bpf_insn* noundef %58) #11
  store i32 %call65, i32* %ret, align 4
  %59 = load i32, i32* %ret, align 4
  %cmp66 = icmp slt i32 %59, 0
  br i1 %cmp66, label %if.then68, label %if.end69

if.then68:                                        ; preds = %sw.bb
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = bitcast %struct.bpf_verifier_env* %60 to i8*
  %62 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %61, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.27, i64 0, i64 0), i32 noundef %62) #11
  %63 = load i32, i32* %ret, align 4
  store i32 %63, i32* %retval, align 4
  br label %return

if.end69:                                         ; preds = %sw.bb
  %64 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_add(%struct.bpf_reg_state* noundef %64, %struct.bpf_reg_state* noundef %src_reg) #11
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_add(%struct.bpf_reg_state* noundef %65, %struct.bpf_reg_state* noundef %src_reg) #11
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 5
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off71 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i32 0, i32 5
  %var_off72 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %68 = bitcast %struct.tnum* %var_off71 to { i64, i64 }*
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %68, i32 0, i32 0
  %70 = load i64, i64* %69, align 8
  %71 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %68, i32 0, i32 1
  %72 = load i64, i64* %71, align 8
  %73 = bitcast %struct.tnum* %var_off72 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = load i64, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = load i64, i64* %76, align 8
  %call73 = call { i64, i64 } @tnum_add(i64 %70, i64 %72, i64 %75, i64 %77) #11
  %78 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = extractvalue { i64, i64 } %call73, 0
  store i64 %80, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = extractvalue { i64, i64 } %call73, 1
  store i64 %82, i64* %81, align 8
  %83 = bitcast %struct.tnum* %var_off70 to i8*
  %84 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %83, i8* align 8 %84, i64 16, i1 false)
  br label %sw.epilog

sw.bb74:                                          ; preds = %if.end63
  %85 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %86 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call75 = call i32 @sanitize_val_alu(%struct.bpf_verifier_env* noundef %85, %struct.bpf_insn* noundef %86) #11
  store i32 %call75, i32* %ret, align 4
  %87 = load i32, i32* %ret, align 4
  %cmp76 = icmp slt i32 %87, 0
  br i1 %cmp76, label %if.then78, label %if.end79

if.then78:                                        ; preds = %sw.bb74
  %88 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %89 = bitcast %struct.bpf_verifier_env* %88 to i8*
  %90 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %89, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.28, i64 0, i64 0), i32 noundef %90) #11
  %91 = load i32, i32* %ret, align 4
  store i32 %91, i32* %retval, align 4
  br label %return

if.end79:                                         ; preds = %sw.bb74
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_sub(%struct.bpf_reg_state* noundef %92, %struct.bpf_reg_state* noundef %src_reg) #11
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_sub(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %src_reg) #11
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %94, i32 0, i32 5
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off82 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %var_off83 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %96 = bitcast %struct.tnum* %var_off82 to { i64, i64 }*
  %97 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %96, i32 0, i32 0
  %98 = load i64, i64* %97, align 8
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %96, i32 0, i32 1
  %100 = load i64, i64* %99, align 8
  %101 = bitcast %struct.tnum* %var_off83 to { i64, i64 }*
  %102 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %101, i32 0, i32 0
  %103 = load i64, i64* %102, align 8
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %101, i32 0, i32 1
  %105 = load i64, i64* %104, align 8
  %call84 = call { i64, i64 } @tnum_sub(i64 %98, i64 %100, i64 %103, i64 %105) #11
  %106 = bitcast %struct.tnum* %tmp81 to { i64, i64 }*
  %107 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %106, i32 0, i32 0
  %108 = extractvalue { i64, i64 } %call84, 0
  store i64 %108, i64* %107, align 8
  %109 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %106, i32 0, i32 1
  %110 = extractvalue { i64, i64 } %call84, 1
  store i64 %110, i64* %109, align 8
  %111 = bitcast %struct.tnum* %var_off80 to i8*
  %112 = bitcast %struct.tnum* %tmp81 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %111, i8* align 8 %112, i64 16, i1 false)
  br label %sw.epilog

sw.bb85:                                          ; preds = %if.end63
  %113 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %113, i32 0, i32 5
  %114 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %114, i32 0, i32 5
  %var_off89 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %115 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %116 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %115, i32 0, i32 0
  %117 = load i64, i64* %116, align 8
  %118 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %115, i32 0, i32 1
  %119 = load i64, i64* %118, align 8
  %120 = bitcast %struct.tnum* %var_off89 to { i64, i64 }*
  %121 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %120, i32 0, i32 0
  %122 = load i64, i64* %121, align 8
  %123 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %120, i32 0, i32 1
  %124 = load i64, i64* %123, align 8
  %call90 = call { i64, i64 } @tnum_mul(i64 %117, i64 %119, i64 %122, i64 %124) #11
  %125 = bitcast %struct.tnum* %tmp87 to { i64, i64 }*
  %126 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %125, i32 0, i32 0
  %127 = extractvalue { i64, i64 } %call90, 0
  store i64 %127, i64* %126, align 8
  %128 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %125, i32 0, i32 1
  %129 = extractvalue { i64, i64 } %call90, 1
  store i64 %129, i64* %128, align 8
  %130 = bitcast %struct.tnum* %var_off86 to i8*
  %131 = bitcast %struct.tnum* %tmp87 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %130, i8* align 8 %131, i64 16, i1 false)
  %132 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_mul(%struct.bpf_reg_state* noundef %132, %struct.bpf_reg_state* noundef %src_reg) #11
  %133 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_mul(%struct.bpf_reg_state* noundef %133, %struct.bpf_reg_state* noundef %src_reg) #11
  br label %sw.epilog

sw.bb91:                                          ; preds = %if.end63
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %134, i32 0, i32 5
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off94 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %135, i32 0, i32 5
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %136 = bitcast %struct.tnum* %var_off94 to { i64, i64 }*
  %137 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %136, i32 0, i32 0
  %138 = load i64, i64* %137, align 8
  %139 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %136, i32 0, i32 1
  %140 = load i64, i64* %139, align 8
  %141 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %141, i32 0, i32 0
  %143 = load i64, i64* %142, align 8
  %144 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %141, i32 0, i32 1
  %145 = load i64, i64* %144, align 8
  %call96 = call { i64, i64 } @tnum_and(i64 %138, i64 %140, i64 %143, i64 %145) #11
  %146 = bitcast %struct.tnum* %tmp93 to { i64, i64 }*
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %146, i32 0, i32 0
  %148 = extractvalue { i64, i64 } %call96, 0
  store i64 %148, i64* %147, align 8
  %149 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %146, i32 0, i32 1
  %150 = extractvalue { i64, i64 } %call96, 1
  store i64 %150, i64* %149, align 8
  %151 = bitcast %struct.tnum* %var_off92 to i8*
  %152 = bitcast %struct.tnum* %tmp93 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %151, i8* align 8 %152, i64 16, i1 false)
  %153 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_and(%struct.bpf_reg_state* noundef %153, %struct.bpf_reg_state* noundef %src_reg) #11
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_and(%struct.bpf_reg_state* noundef %154, %struct.bpf_reg_state* noundef %src_reg) #11
  br label %sw.epilog

sw.bb97:                                          ; preds = %if.end63
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off98 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %155, i32 0, i32 5
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off100 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i32 0, i32 5
  %var_off101 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %157 = bitcast %struct.tnum* %var_off100 to { i64, i64 }*
  %158 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %157, i32 0, i32 0
  %159 = load i64, i64* %158, align 8
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %157, i32 0, i32 1
  %161 = load i64, i64* %160, align 8
  %162 = bitcast %struct.tnum* %var_off101 to { i64, i64 }*
  %163 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %162, i32 0, i32 0
  %164 = load i64, i64* %163, align 8
  %165 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %162, i32 0, i32 1
  %166 = load i64, i64* %165, align 8
  %call102 = call { i64, i64 } @tnum_or(i64 %159, i64 %161, i64 %164, i64 %166) #11
  %167 = bitcast %struct.tnum* %tmp99 to { i64, i64 }*
  %168 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %167, i32 0, i32 0
  %169 = extractvalue { i64, i64 } %call102, 0
  store i64 %169, i64* %168, align 8
  %170 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %167, i32 0, i32 1
  %171 = extractvalue { i64, i64 } %call102, 1
  store i64 %171, i64* %170, align 8
  %172 = bitcast %struct.tnum* %var_off98 to i8*
  %173 = bitcast %struct.tnum* %tmp99 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %172, i8* align 8 %173, i64 16, i1 false)
  %174 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_or(%struct.bpf_reg_state* noundef %174, %struct.bpf_reg_state* noundef %src_reg) #11
  %175 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_or(%struct.bpf_reg_state* noundef %175, %struct.bpf_reg_state* noundef %src_reg) #11
  br label %sw.epilog

sw.bb103:                                         ; preds = %if.end63
  %176 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off104 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %176, i32 0, i32 5
  %177 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off106 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %177, i32 0, i32 5
  %var_off107 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %src_reg, i32 0, i32 5
  %178 = bitcast %struct.tnum* %var_off106 to { i64, i64 }*
  %179 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %178, i32 0, i32 0
  %180 = load i64, i64* %179, align 8
  %181 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %178, i32 0, i32 1
  %182 = load i64, i64* %181, align 8
  %183 = bitcast %struct.tnum* %var_off107 to { i64, i64 }*
  %184 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %183, i32 0, i32 0
  %185 = load i64, i64* %184, align 8
  %186 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %183, i32 0, i32 1
  %187 = load i64, i64* %186, align 8
  %call108 = call { i64, i64 } @tnum_xor(i64 %180, i64 %182, i64 %185, i64 %187) #11
  %188 = bitcast %struct.tnum* %tmp105 to { i64, i64 }*
  %189 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %188, i32 0, i32 0
  %190 = extractvalue { i64, i64 } %call108, 0
  store i64 %190, i64* %189, align 8
  %191 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %188, i32 0, i32 1
  %192 = extractvalue { i64, i64 } %call108, 1
  store i64 %192, i64* %191, align 8
  %193 = bitcast %struct.tnum* %var_off104 to i8*
  %194 = bitcast %struct.tnum* %tmp105 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %193, i8* align 8 %194, i64 16, i1 false)
  %195 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_xor(%struct.bpf_reg_state* noundef %195, %struct.bpf_reg_state* noundef %src_reg) #11
  %196 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_xor(%struct.bpf_reg_state* noundef %196, %struct.bpf_reg_state* noundef %src_reg) #11
  br label %sw.epilog

sw.bb109:                                         ; preds = %if.end63
  %197 = load i64, i64* %umax_val, align 8
  %198 = load i64, i64* %insn_bitness, align 8
  %cmp110 = icmp uge i64 %197, %198
  br i1 %cmp110, label %if.then112, label %if.end113

if.then112:                                       ; preds = %sw.bb109
  %199 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %199) #11
  br label %sw.epilog

if.end113:                                        ; preds = %sw.bb109
  %200 = load i8, i8* %alu32, align 1
  %tobool114 = trunc i8 %200 to i1
  br i1 %tobool114, label %if.then115, label %if.else116

if.then115:                                       ; preds = %if.end113
  %201 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %201, %struct.bpf_reg_state* noundef %src_reg) #11
  br label %if.end117

if.else116:                                       ; preds = %if.end113
  %202 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_lsh(%struct.bpf_reg_state* noundef %202, %struct.bpf_reg_state* noundef %src_reg) #11
  br label %if.end117

if.end117:                                        ; preds = %if.else116, %if.then115
  br label %sw.epilog

sw.bb118:                                         ; preds = %if.end63
  %203 = load i64, i64* %umax_val, align 8
  %204 = load i64, i64* %insn_bitness, align 8
  %cmp119 = icmp uge i64 %203, %204
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %sw.bb118
  %205 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %205) #11
  br label %sw.epilog

if.end122:                                        ; preds = %sw.bb118
  %206 = load i8, i8* %alu32, align 1
  %tobool123 = trunc i8 %206 to i1
  br i1 %tobool123, label %if.then124, label %if.else125

if.then124:                                       ; preds = %if.end122
  %207 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_rsh(%struct.bpf_reg_state* noundef %207, %struct.bpf_reg_state* noundef %src_reg) #11
  br label %if.end126

if.else125:                                       ; preds = %if.end122
  %208 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_rsh(%struct.bpf_reg_state* noundef %208, %struct.bpf_reg_state* noundef %src_reg) #11
  br label %if.end126

if.end126:                                        ; preds = %if.else125, %if.then124
  br label %sw.epilog

sw.bb127:                                         ; preds = %if.end63
  %209 = load i64, i64* %umax_val, align 8
  %210 = load i64, i64* %insn_bitness, align 8
  %cmp128 = icmp uge i64 %209, %210
  br i1 %cmp128, label %if.then130, label %if.end131

if.then130:                                       ; preds = %sw.bb127
  %211 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %211) #11
  br label %sw.epilog

if.end131:                                        ; preds = %sw.bb127
  %212 = load i8, i8* %alu32, align 1
  %tobool132 = trunc i8 %212 to i1
  br i1 %tobool132, label %if.then133, label %if.else134

if.then133:                                       ; preds = %if.end131
  %213 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar32_min_max_arsh(%struct.bpf_reg_state* noundef %213, %struct.bpf_reg_state* noundef %src_reg) #11
  br label %if.end135

if.else134:                                       ; preds = %if.end131
  %214 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @scalar_min_max_arsh(%struct.bpf_reg_state* noundef %214, %struct.bpf_reg_state* noundef %src_reg) #11
  br label %if.end135

if.end135:                                        ; preds = %if.else134, %if.then133
  br label %sw.epilog

sw.default:                                       ; preds = %if.end63
  %215 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %215) #11
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end135, %if.then130, %if.end126, %if.then121, %if.end117, %if.then112, %sw.bb103, %sw.bb97, %sw.bb91, %sw.bb85, %if.end79, %if.end69
  %216 = load i8, i8* %alu32, align 1
  %tobool136 = trunc i8 %216 to i1
  br i1 %tobool136, label %if.then137, label %if.end138

if.then137:                                       ; preds = %sw.epilog
  %217 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @zext_32_to_64(%struct.bpf_reg_state* noundef %217) #11
  br label %if.end138

if.end138:                                        ; preds = %if.then137, %sw.epilog
  %218 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %218) #11
  %219 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %219) #11
  %220 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %220) #11
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end138, %if.then78, %if.then68, %if.then62, %if.then46, %if.then28
  %221 = load i32, i32* %retval, align 4
  ret i32 %221
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #11
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %call, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  ret %struct.bpf_reg_state* %arraydecay
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_subreg_is_const(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %3 = bitcast %struct.tnum* %a to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %5, i64 %7) #11
  %8 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 1
  %13 = load i64, i64* %mask, align 8
  %tobool = icmp ne i64 %13, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = bitcast %struct.tnum* %var_off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 15
  store i32 0, i32* %frameno, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 26
  %5 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ugt i32 %5, 1
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 16
  %7 = load i8, i8* %bpf_capable, align 2
  %tobool = trunc i8 %7 to i1
  %lnot = xor i1 %tobool, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %8 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 18
  %frombool = zext i1 %8 to i8
  store i8 %frombool, i8* %precise, align 4
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %10) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @sanitize_val_alu(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_insn_aux_data* %call, %struct.bpf_insn_aux_data** %aux, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call1 = call zeroext i1 @can_skip_alu_sanitation(%struct.bpf_verifier_env* noundef %1, %struct.bpf_insn* noundef %2) #11
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call2 = call i32 @update_alu_sanitation_state(%struct.bpf_insn_aux_data* noundef %3, i32 noundef 8, i32 noundef 0) #11
  store i32 %call2, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, i32* %retval, align 4
  ret i32 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_add(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i32, align 4
  %smax_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %umax_val = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  %1 = load i32, i32* %s32_min_value, align 8
  store i32 %1, i32* %smin_val, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 11
  %3 = load i32, i32* %s32_max_value, align 4
  store i32 %3, i32* %smax_val, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 12
  %5 = load i32, i32* %u32_min_value, align 8
  store i32 %5, i32* %umin_val, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 13
  %7 = load i32, i32* %u32_max_value, align 4
  store i32 %7, i32* %umax_val, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 10
  %9 = load i32, i32* %s32_min_value1, align 8
  %conv = sext i32 %9 to i64
  %10 = load i32, i32* %smin_val, align 4
  %conv2 = sext i32 %10 to i64
  %call = call zeroext i1 @signed_add32_overflows(i64 noundef %conv, i64 noundef %conv2) #11
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 11
  %12 = load i32, i32* %s32_max_value4, align 4
  %conv5 = sext i32 %12 to i64
  %13 = load i32, i32* %smax_val, align 4
  %conv6 = sext i32 %13 to i64
  %call7 = call zeroext i1 @signed_add32_overflows(i64 noundef %conv5, i64 noundef %conv6) #11
  br i1 %call7, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value9, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value10, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %16 = load i32, i32* %smin_val, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 10
  %18 = load i32, i32* %s32_min_value11, align 8
  %add = add i32 %18, %16
  store i32 %add, i32* %s32_min_value11, align 8
  %19 = load i32, i32* %smax_val, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 11
  %21 = load i32, i32* %s32_max_value12, align 4
  %add13 = add i32 %21, %19
  store i32 %add13, i32* %s32_max_value12, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 12
  %23 = load i32, i32* %u32_min_value14, align 8
  %24 = load i32, i32* %umin_val, align 4
  %add15 = add i32 %23, %24
  %25 = load i32, i32* %umin_val, align 4
  %cmp = icmp ult i32 %add15, %25
  br i1 %cmp, label %if.then22, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %if.end
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 13
  %27 = load i32, i32* %u32_max_value18, align 4
  %28 = load i32, i32* %umax_val, align 4
  %add19 = add i32 %27, %28
  %29 = load i32, i32* %umax_val, align 4
  %cmp20 = icmp ult i32 %add19, %29
  br i1 %cmp20, label %if.then22, label %if.else25

if.then22:                                        ; preds = %lor.lhs.false17, %if.end
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 12
  store i32 0, i32* %u32_min_value23, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 13
  store i32 -1, i32* %u32_max_value24, align 4
  br label %if.end30

if.else25:                                        ; preds = %lor.lhs.false17
  %32 = load i32, i32* %umin_val, align 4
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value26 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 12
  %34 = load i32, i32* %u32_min_value26, align 8
  %add27 = add i32 %34, %32
  store i32 %add27, i32* %u32_min_value26, align 8
  %35 = load i32, i32* %umax_val, align 4
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 13
  %37 = load i32, i32* %u32_max_value28, align 4
  %add29 = add i32 %37, %35
  store i32 %add29, i32* %u32_max_value28, align 4
  br label %if.end30

if.end30:                                         ; preds = %if.else25, %if.then22
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_add(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %smin_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 7
  %3 = load i64, i64* %smax_value, align 8
  store i64 %3, i64* %smax_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 8
  %5 = load i64, i64* %umin_value, align 8
  store i64 %5, i64* %umin_val, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 9
  %7 = load i64, i64* %umax_value, align 8
  store i64 %7, i64* %umax_val, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value1, align 8
  %10 = load i64, i64* %smin_val, align 8
  %call = call zeroext i1 @signed_add_overflows(i64 noundef %9, i64 noundef %10) #11
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 7
  %12 = load i64, i64* %smax_value2, align 8
  %13 = load i64, i64* %smax_val, align 8
  %call3 = call zeroext i1 @signed_add_overflows(i64 noundef %12, i64 noundef %13) #11
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value4, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value5, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %16 = load i64, i64* %smin_val, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value6, align 8
  %add = add i64 %18, %16
  store i64 %add, i64* %smin_value6, align 8
  %19 = load i64, i64* %smax_val, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 7
  %21 = load i64, i64* %smax_value7, align 8
  %add8 = add i64 %21, %19
  store i64 %add8, i64* %smax_value7, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 8
  %23 = load i64, i64* %umin_value9, align 8
  %24 = load i64, i64* %umin_val, align 8
  %add10 = add i64 %23, %24
  %25 = load i64, i64* %umin_val, align 8
  %cmp = icmp ult i64 %add10, %25
  br i1 %cmp, label %if.then15, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %if.end
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  %27 = load i64, i64* %umax_value12, align 8
  %28 = load i64, i64* %umax_val, align 8
  %add13 = add i64 %27, %28
  %29 = load i64, i64* %umax_val, align 8
  %cmp14 = icmp ult i64 %add13, %29
  br i1 %cmp14, label %if.then15, label %if.else18

if.then15:                                        ; preds = %lor.lhs.false11, %if.end
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 8
  store i64 0, i64* %umin_value16, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 9
  store i64 -1, i64* %umax_value17, align 8
  br label %if.end23

if.else18:                                        ; preds = %lor.lhs.false11
  %32 = load i64, i64* %umin_val, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 8
  %34 = load i64, i64* %umin_value19, align 8
  %add20 = add i64 %34, %32
  store i64 %add20, i64* %umin_value19, align 8
  %35 = load i64, i64* %umax_val, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 9
  %37 = load i64, i64* %umax_value21, align 8
  %add22 = add i64 %37, %35
  store i64 %add22, i64* %umax_value21, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.else18, %if.then15
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_sub(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i32, align 4
  %smax_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %umax_val = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  %1 = load i32, i32* %s32_min_value, align 8
  store i32 %1, i32* %smin_val, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 11
  %3 = load i32, i32* %s32_max_value, align 4
  store i32 %3, i32* %smax_val, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 12
  %5 = load i32, i32* %u32_min_value, align 8
  store i32 %5, i32* %umin_val, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 13
  %7 = load i32, i32* %u32_max_value, align 4
  store i32 %7, i32* %umax_val, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 10
  %9 = load i32, i32* %s32_min_value1, align 8
  %10 = load i32, i32* %smax_val, align 4
  %call = call zeroext i1 @signed_sub32_overflows(i32 noundef %9, i32 noundef %10) #11
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 11
  %12 = load i32, i32* %s32_max_value2, align 4
  %13 = load i32, i32* %smin_val, align 4
  %call3 = call zeroext i1 @signed_sub32_overflows(i32 noundef %12, i32 noundef %13) #11
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value4, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value5, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %16 = load i32, i32* %smax_val, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 10
  %18 = load i32, i32* %s32_min_value6, align 8
  %sub = sub i32 %18, %16
  store i32 %sub, i32* %s32_min_value6, align 8
  %19 = load i32, i32* %smin_val, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 11
  %21 = load i32, i32* %s32_max_value7, align 4
  %sub8 = sub i32 %21, %19
  store i32 %sub8, i32* %s32_max_value7, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 12
  %23 = load i32, i32* %u32_min_value9, align 8
  %24 = load i32, i32* %umax_val, align 4
  %cmp = icmp ult i32 %23, %24
  br i1 %cmp, label %if.then10, label %if.else13

if.then10:                                        ; preds = %if.end
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 12
  store i32 0, i32* %u32_min_value11, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 13
  store i32 -1, i32* %u32_max_value12, align 4
  br label %if.end18

if.else13:                                        ; preds = %if.end
  %27 = load i32, i32* %umax_val, align 4
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 12
  %29 = load i32, i32* %u32_min_value14, align 8
  %sub15 = sub i32 %29, %27
  store i32 %sub15, i32* %u32_min_value14, align 8
  %30 = load i32, i32* %umin_val, align 4
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 13
  %32 = load i32, i32* %u32_max_value16, align 4
  %sub17 = sub i32 %32, %30
  store i32 %sub17, i32* %u32_max_value16, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.else13, %if.then10
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_sub(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %smin_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 7
  %3 = load i64, i64* %smax_value, align 8
  store i64 %3, i64* %smax_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 8
  %5 = load i64, i64* %umin_value, align 8
  store i64 %5, i64* %umin_val, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 9
  %7 = load i64, i64* %umax_value, align 8
  store i64 %7, i64* %umax_val, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value1, align 8
  %conv = trunc i64 %9 to i32
  %10 = load i64, i64* %smax_val, align 8
  %conv2 = trunc i64 %10 to i32
  %call = call zeroext i1 @signed_sub_overflows(i32 noundef %conv, i32 noundef %conv2) #11
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 7
  %12 = load i64, i64* %smax_value4, align 8
  %conv5 = trunc i64 %12 to i32
  %13 = load i64, i64* %smin_val, align 8
  %conv6 = trunc i64 %13 to i32
  %call7 = call zeroext i1 @signed_sub_overflows(i32 noundef %conv5, i32 noundef %conv6) #11
  br i1 %call7, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value9, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value10, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %16 = load i64, i64* %smax_val, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value11, align 8
  %sub = sub i64 %18, %16
  store i64 %sub, i64* %smin_value11, align 8
  %19 = load i64, i64* %smin_val, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 7
  %21 = load i64, i64* %smax_value12, align 8
  %sub13 = sub i64 %21, %19
  store i64 %sub13, i64* %smax_value12, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 8
  %23 = load i64, i64* %umin_value14, align 8
  %24 = load i64, i64* %umax_val, align 8
  %cmp = icmp ult i64 %23, %24
  br i1 %cmp, label %if.then16, label %if.else19

if.then16:                                        ; preds = %if.end
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 8
  store i64 0, i64* %umin_value17, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  store i64 -1, i64* %umax_value18, align 8
  br label %if.end24

if.else19:                                        ; preds = %if.end
  %27 = load i64, i64* %umax_val, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 8
  %29 = load i64, i64* %umin_value20, align 8
  %sub21 = sub i64 %29, %27
  store i64 %sub21, i64* %umin_value20, align 8
  %30 = load i64, i64* %umin_val, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 9
  %32 = load i64, i64* %umax_value22, align 8
  %sub23 = sub i64 %32, %30
  store i64 %sub23, i64* %umax_value22, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.else19, %if.then16
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_mul(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %umax_val = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  %1 = load i32, i32* %s32_min_value, align 8
  store i32 %1, i32* %smin_val, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 12
  %3 = load i32, i32* %u32_min_value, align 8
  store i32 %3, i32* %umin_val, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 13
  %5 = load i32, i32* %u32_max_value, align 4
  store i32 %5, i32* %umax_val, align 4
  %6 = load i32, i32* %smin_val, align 4
  %cmp = icmp slt i32 %6, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 10
  %8 = load i32, i32* %s32_min_value1, align 8
  %cmp2 = icmp slt i32 %8, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %9) #11
  br label %if.end20

if.end:                                           ; preds = %lor.lhs.false
  %10 = load i32, i32* %umax_val, align 4
  %cmp3 = icmp ugt i32 %10, 65535
  br i1 %cmp3, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 13
  %12 = load i32, i32* %u32_max_value5, align 4
  %cmp6 = icmp ugt i32 %12, 65535
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %lor.lhs.false4, %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %13) #11
  br label %if.end20

if.end8:                                          ; preds = %lor.lhs.false4
  %14 = load i32, i32* %umin_val, align 4
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 12
  %16 = load i32, i32* %u32_min_value9, align 8
  %mul = mul i32 %16, %14
  store i32 %mul, i32* %u32_min_value9, align 8
  %17 = load i32, i32* %umax_val, align 4
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 13
  %19 = load i32, i32* %u32_max_value10, align 4
  %mul11 = mul i32 %19, %17
  store i32 %mul11, i32* %u32_max_value10, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 13
  %21 = load i32, i32* %u32_max_value12, align 4
  %cmp13 = icmp ugt i32 %21, 2147483647
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value15, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  br label %if.end20

if.else:                                          ; preds = %if.end8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 12
  %25 = load i32, i32* %u32_min_value16, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 10
  store i32 %25, i32* %s32_min_value17, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 13
  %28 = load i32, i32* %u32_max_value18, align 4
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 11
  store i32 %28, i32* %s32_max_value19, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then14, %if.then7, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_mul(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %smin_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  %1 = load i64, i64* %smin_value, align 8
  store i64 %1, i64* %smin_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value, align 8
  store i64 %3, i64* %umin_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 9
  %5 = load i64, i64* %umax_value, align 8
  store i64 %5, i64* %umax_val, align 8
  %6 = load i64, i64* %smin_val, align 8
  %cmp = icmp slt i64 %6, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 6
  %8 = load i64, i64* %smin_value1, align 8
  %cmp2 = icmp slt i64 %8, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %9) #11
  br label %if.end20

if.end:                                           ; preds = %lor.lhs.false
  %10 = load i64, i64* %umax_val, align 8
  %cmp3 = icmp ugt i64 %10, 4294967295
  br i1 %cmp3, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 9
  %12 = load i64, i64* %umax_value5, align 8
  %cmp6 = icmp ugt i64 %12, 4294967295
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %lor.lhs.false4, %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %13) #11
  br label %if.end20

if.end8:                                          ; preds = %lor.lhs.false4
  %14 = load i64, i64* %umin_val, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 8
  %16 = load i64, i64* %umin_value9, align 8
  %mul = mul i64 %16, %14
  store i64 %mul, i64* %umin_value9, align 8
  %17 = load i64, i64* %umax_val, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 9
  %19 = load i64, i64* %umax_value10, align 8
  %mul11 = mul i64 %19, %17
  store i64 %mul11, i64* %umax_value10, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  %21 = load i64, i64* %umax_value12, align 8
  %cmp13 = icmp ugt i64 %21, 9223372036854775807
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value15, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  br label %if.end20

if.else:                                          ; preds = %if.end8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 8
  %25 = load i64, i64* %umin_value16, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 6
  store i64 %25, i64* %smin_value17, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 9
  %28 = load i64, i64* %umax_value18, align 8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 7
  store i64 %28, i64* %smax_value19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then14, %if.then7, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_and(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %var32_off = alloca %struct.tnum, align 8
  %smin_val = alloca i32, align 4
  %umax_val = alloca i32, align 4
  %__UNIQUE_ID___x426 = alloca i32, align 4
  %__UNIQUE_ID___y427 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_subreg_is_const(i64 %3, i64 %5) #11
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_subreg_is_const(i64 %9, i64 %11) #11
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %13 = bitcast %struct.tnum* %var_off4 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call5 = call { i64, i64 } @tnum_subreg(i64 %15, i64 %17) #11
  %18 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call5, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call5, 1
  store i64 %22, i64* %21, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 10
  %24 = load i32, i32* %s32_min_value, align 8
  store i32 %24, i32* %smin_val, align 4
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 13
  %26 = load i32, i32* %u32_max_value, align 4
  store i32 %26, i32* %umax_val, align 4
  %27 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %27 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %28 = load i8, i8* %dst_known, align 1
  %tobool6 = trunc i8 %28 to i1
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %if.end21

if.end:                                           ; preds = %land.lhs.true, %entry
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %29 = load i64, i64* %value, align 8
  %conv = trunc i64 %29 to i32
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 12
  store i32 %conv, i32* %u32_min_value, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 13
  %32 = load i32, i32* %u32_max_value7, align 4
  store i32 %32, i32* %__UNIQUE_ID___x426, align 4
  %33 = load i32, i32* %umax_val, align 4
  store i32 %33, i32* %__UNIQUE_ID___y427, align 4
  %34 = load i32, i32* %__UNIQUE_ID___x426, align 4
  %35 = load i32, i32* %__UNIQUE_ID___y427, align 4
  %cmp = icmp ult i32 %34, %35
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %36 = load i32, i32* %__UNIQUE_ID___x426, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %37 = load i32, i32* %__UNIQUE_ID___y427, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %36, %cond.true ], [ %37, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %38 = load i32, i32* %tmp, align 4
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 13
  store i32 %38, i32* %u32_max_value9, align 4
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 10
  %41 = load i32, i32* %s32_min_value10, align 8
  %cmp11 = icmp slt i32 %41, 0
  br i1 %cmp11, label %if.then15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %42 = load i32, i32* %smin_val, align 4
  %cmp13 = icmp slt i32 %42, 0
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %lor.lhs.false, %cond.end
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value16, align 8
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  br label %if.end21

if.else:                                          ; preds = %lor.lhs.false
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 12
  %46 = load i32, i32* %u32_min_value17, align 8
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 10
  store i32 %46, i32* %s32_min_value18, align 8
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 13
  %49 = load i32, i32* %u32_max_value19, align 4
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 11
  store i32 %49, i32* %s32_max_value20, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then15, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_and(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  %__UNIQUE_ID___x428 = alloca i64, align 8
  %__UNIQUE_ID___y429 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #11
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %9, i64 %11) #11
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value, align 8
  store i64 %13, i64* %smin_val, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 9
  %15 = load i64, i64* %umax_value, align 8
  store i64 %15, i64* %umax_val, align 8
  %16 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %17 = load i8, i8* %dst_known, align 1
  %tobool4 = trunc i8 %17 to i1
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %20 = load i64, i64* %value, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %18, i64 noundef %20) #11
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 5
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off6, i32 0, i32 0
  %22 = load i64, i64* %value7, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 8
  store i64 %22, i64* %umin_value, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 9
  %25 = load i64, i64* %umax_value8, align 8
  store i64 %25, i64* %__UNIQUE_ID___x428, align 8
  %26 = load i64, i64* %umax_val, align 8
  store i64 %26, i64* %__UNIQUE_ID___y429, align 8
  %27 = load i64, i64* %__UNIQUE_ID___x428, align 8
  %28 = load i64, i64* %__UNIQUE_ID___y429, align 8
  %cmp = icmp ult i64 %27, %28
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %29 = load i64, i64* %__UNIQUE_ID___x428, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %30 = load i64, i64* %__UNIQUE_ID___y429, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %29, %cond.true ], [ %30, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %31 = load i64, i64* %tmp, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 9
  store i64 %31, i64* %umax_value9, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 6
  %34 = load i64, i64* %smin_value10, align 8
  %cmp11 = icmp slt i64 %34, 0
  br i1 %cmp11, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %35 = load i64, i64* %smin_val, align 8
  %cmp12 = icmp slt i64 %35, 0
  br i1 %cmp12, label %if.then13, label %if.else

if.then13:                                        ; preds = %lor.lhs.false, %cond.end
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value14, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  br label %if.end19

if.else:                                          ; preds = %lor.lhs.false
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 8
  %39 = load i64, i64* %umin_value15, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 6
  store i64 %39, i64* %smin_value16, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 9
  %42 = load i64, i64* %umax_value17, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 7
  store i64 %42, i64* %smax_value18, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then13
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %44) #11
  br label %return

return:                                           ; preds = %if.end19, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_or(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %var32_off = alloca %struct.tnum, align 8
  %smin_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %__UNIQUE_ID___x430 = alloca i32, align 4
  %__UNIQUE_ID___y431 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_subreg_is_const(i64 %3, i64 %5) #11
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_subreg_is_const(i64 %9, i64 %11) #11
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %13 = bitcast %struct.tnum* %var_off4 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call5 = call { i64, i64 } @tnum_subreg(i64 %15, i64 %17) #11
  %18 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call5, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call5, 1
  store i64 %22, i64* %21, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 10
  %24 = load i32, i32* %s32_min_value, align 8
  store i32 %24, i32* %smin_val, align 4
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 12
  %26 = load i32, i32* %u32_min_value, align 8
  store i32 %26, i32* %umin_val, align 4
  %27 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %27 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %28 = load i8, i8* %dst_known, align 1
  %tobool6 = trunc i8 %28 to i1
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %if.end20

if.end:                                           ; preds = %land.lhs.true, %entry
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 12
  %30 = load i32, i32* %u32_min_value7, align 8
  store i32 %30, i32* %__UNIQUE_ID___x430, align 4
  %31 = load i32, i32* %umin_val, align 4
  store i32 %31, i32* %__UNIQUE_ID___y431, align 4
  %32 = load i32, i32* %__UNIQUE_ID___x430, align 4
  %33 = load i32, i32* %__UNIQUE_ID___y431, align 4
  %cmp = icmp ugt i32 %32, %33
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %34 = load i32, i32* %__UNIQUE_ID___x430, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %35 = load i32, i32* %__UNIQUE_ID___y431, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %34, %cond.true ], [ %35, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %36 = load i32, i32* %tmp, align 4
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 12
  store i32 %36, i32* %u32_min_value8, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %38 = load i64, i64* %value, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %39 = load i64, i64* %mask, align 8
  %or = or i64 %38, %39
  %conv = trunc i64 %or to i32
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 13
  store i32 %conv, i32* %u32_max_value, align 4
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 10
  %42 = load i32, i32* %s32_min_value9, align 8
  %cmp10 = icmp slt i32 %42, 0
  br i1 %cmp10, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %43 = load i32, i32* %smin_val, align 4
  %cmp12 = icmp slt i32 %43, 0
  br i1 %cmp12, label %if.then14, label %if.else

if.then14:                                        ; preds = %lor.lhs.false, %cond.end
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value15, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  br label %if.end20

if.else:                                          ; preds = %lor.lhs.false
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 12
  %47 = load i32, i32* %u32_min_value16, align 8
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 10
  store i32 %47, i32* %s32_min_value17, align 8
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 13
  %50 = load i32, i32* %u32_max_value18, align 4
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %51, i32 0, i32 11
  store i32 %50, i32* %s32_max_value19, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then14, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_or(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %__UNIQUE_ID___x432 = alloca i64, align 8
  %__UNIQUE_ID___y433 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #11
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %9, i64 %11) #11
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value, align 8
  store i64 %13, i64* %smin_val, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 8
  %15 = load i64, i64* %umin_value, align 8
  store i64 %15, i64* %umin_val, align 8
  %16 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %17 = load i8, i8* %dst_known, align 1
  %tobool4 = trunc i8 %17 to i1
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %20 = load i64, i64* %value, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %18, i64 noundef %20) #11
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 8
  %22 = load i64, i64* %umin_value6, align 8
  store i64 %22, i64* %__UNIQUE_ID___x432, align 8
  %23 = load i64, i64* %umin_val, align 8
  store i64 %23, i64* %__UNIQUE_ID___y433, align 8
  %24 = load i64, i64* %__UNIQUE_ID___x432, align 8
  %25 = load i64, i64* %__UNIQUE_ID___y433, align 8
  %cmp = icmp ugt i64 %24, %25
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %26 = load i64, i64* %__UNIQUE_ID___x432, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %27 = load i64, i64* %__UNIQUE_ID___y433, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %26, %cond.true ], [ %27, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %28 = load i64, i64* %tmp, align 8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 8
  store i64 %28, i64* %umin_value7, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %value9 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off8, i32 0, i32 0
  %31 = load i64, i64* %value9, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off10, i32 0, i32 1
  %33 = load i64, i64* %mask, align 8
  %or = or i64 %31, %33
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 9
  store i64 %or, i64* %umax_value, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 6
  %36 = load i64, i64* %smin_value11, align 8
  %cmp12 = icmp slt i64 %36, 0
  br i1 %cmp12, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %37 = load i64, i64* %smin_val, align 8
  %cmp13 = icmp slt i64 %37, 0
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %lor.lhs.false, %cond.end
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value15, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  br label %if.end20

if.else:                                          ; preds = %lor.lhs.false
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 8
  %41 = load i64, i64* %umin_value16, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 6
  store i64 %41, i64* %smin_value17, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 9
  %44 = load i64, i64* %umax_value18, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 7
  store i64 %44, i64* %smax_value19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then14
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %46) #11
  br label %return

return:                                           ; preds = %if.end20, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_xor(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %var32_off = alloca %struct.tnum, align 8
  %smin_val = alloca i32, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_subreg_is_const(i64 %3, i64 %5) #11
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_subreg_is_const(i64 %9, i64 %11) #11
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 5
  %13 = bitcast %struct.tnum* %var_off4 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call5 = call { i64, i64 } @tnum_subreg(i64 %15, i64 %17) #11
  %18 = bitcast %struct.tnum* %var32_off to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call5, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call5, 1
  store i64 %22, i64* %21, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 10
  %24 = load i32, i32* %s32_min_value, align 8
  store i32 %24, i32* %smin_val, align 4
  %25 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %25 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %26 = load i8, i8* %dst_known, align 1
  %tobool6 = trunc i8 %26 to i1
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %if.end20

if.end:                                           ; preds = %land.lhs.true, %entry
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %27 = load i64, i64* %value, align 8
  %conv = trunc i64 %27 to i32
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 12
  store i32 %conv, i32* %u32_min_value, align 8
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 0
  %29 = load i64, i64* %value7, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var32_off, i32 0, i32 1
  %30 = load i64, i64* %mask, align 8
  %or = or i64 %29, %30
  %conv8 = trunc i64 %or to i32
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 13
  store i32 %conv8, i32* %u32_max_value, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 10
  %33 = load i32, i32* %s32_min_value9, align 8
  %cmp = icmp sge i32 %33, 0
  br i1 %cmp, label %land.lhs.true11, label %if.else

land.lhs.true11:                                  ; preds = %if.end
  %34 = load i32, i32* %smin_val, align 4
  %cmp12 = icmp sge i32 %34, 0
  br i1 %cmp12, label %if.then14, label %if.else

if.then14:                                        ; preds = %land.lhs.true11
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 12
  %36 = load i32, i32* %u32_min_value15, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 10
  store i32 %36, i32* %s32_min_value16, align 8
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 13
  %39 = load i32, i32* %u32_max_value17, align 4
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 11
  store i32 %39, i32* %s32_max_value, align 4
  br label %if.end20

if.else:                                          ; preds = %land.lhs.true11, %if.end
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value18, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value19, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then14, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_xor(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_known = alloca i8, align 1
  %dst_known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #11
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %src_known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %9, i64 %11) #11
  %frombool3 = zext i1 %call2 to i8
  store i8 %frombool3, i8* %dst_known, align 1
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value, align 8
  store i64 %13, i64* %smin_val, align 8
  %14 = load i8, i8* %src_known, align 1
  %tobool = trunc i8 %14 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %15 = load i8, i8* %dst_known, align 1
  %tobool4 = trunc i8 %15 to i1
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 0
  %18 = load i64, i64* %value, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %16, i64 noundef %18) #11
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 5
  %value7 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off6, i32 0, i32 0
  %20 = load i64, i64* %value7, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 8
  store i64 %20, i64* %umin_value, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 5
  %value9 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off8, i32 0, i32 0
  %23 = load i64, i64* %value9, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off10, i32 0, i32 1
  %25 = load i64, i64* %mask, align 8
  %or = or i64 %23, %25
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  store i64 %or, i64* %umax_value, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 6
  %28 = load i64, i64* %smin_value11, align 8
  %cmp = icmp sge i64 %28, 0
  br i1 %cmp, label %land.lhs.true12, label %if.else

land.lhs.true12:                                  ; preds = %if.end
  %29 = load i64, i64* %smin_val, align 8
  %cmp13 = icmp sge i64 %29, 0
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %land.lhs.true12
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 8
  %31 = load i64, i64* %umin_value15, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 6
  store i64 %31, i64* %smin_value16, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 9
  %34 = load i64, i64* %umax_value17, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 7
  store i64 %34, i64* %smax_value, align 8
  br label %if.end20

if.else:                                          ; preds = %land.lhs.true12, %if.end
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value18, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else, %if.then14
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %38) #11
  br label %return

return:                                           ; preds = %if.end20, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_unknown___(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = bitcast %struct.tnum* %var_off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %2, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %3) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umax_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %subreg = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 13
  %1 = load i32, i32* %u32_max_value, align 4
  store i32 %1, i32* %umax_val, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 12
  %3 = load i32, i32* %u32_min_value, align 8
  store i32 %3, i32* %umin_val, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %5 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = load i64, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %7, i64 %9) #11
  %10 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = extractvalue { i64, i64 } %call, 0
  store i64 %12, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = extractvalue { i64, i64 } %call, 1
  store i64 %14, i64* %13, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %16 = load i32, i32* %umin_val, align 4
  %conv = zext i32 %16 to i64
  %17 = load i32, i32* %umax_val, align 4
  %conv1 = zext i32 %17 to i64
  call void @__scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %15, i64 noundef %conv, i64 noundef %conv1) #11
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = load i32, i32* %umin_val, align 4
  %conv3 = trunc i32 %19 to i8
  %20 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = load i64, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = load i64, i64* %23, align 8
  %call4 = call { i64, i64 } @tnum_lshift(i64 %22, i64 %24, i8 noundef zeroext %conv3) #11
  %25 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 0
  %27 = extractvalue { i64, i64 } %call4, 0
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %25, i32 0, i32 1
  %29 = extractvalue { i64, i64 } %call4, 1
  store i64 %29, i64* %28, align 8
  %30 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call5 = call { i64, i64 } @tnum_subreg(i64 %32, i64 %34) #11
  %35 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 0
  %37 = extractvalue { i64, i64 } %call5, 0
  store i64 %37, i64* %36, align 8
  %38 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 1
  %39 = extractvalue { i64, i64 } %call5, 1
  store i64 %39, i64* %38, align 8
  %40 = bitcast %struct.tnum* %var_off2 to i8*
  %41 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %40, i8* align 8 %41, i64 16, i1 false)
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %42) #11
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %43) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_lsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 9
  %1 = load i64, i64* %umax_value, align 8
  store i64 %1, i64* %umax_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value, align 8
  store i64 %3, i64* %umin_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %5 = load i64, i64* %umin_val, align 8
  %6 = load i64, i64* %umax_val, align 8
  call void @__scalar64_min_max_lsh(%struct.bpf_reg_state* noundef %4, i64 noundef %5, i64 noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %8 = load i64, i64* %umin_val, align 8
  %9 = load i64, i64* %umax_val, align 8
  call void @__scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %7, i64 noundef %8, i64 noundef %9) #11
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 5
  %12 = load i64, i64* %umin_val, align 8
  %conv = trunc i64 %12 to i8
  %13 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call = call { i64, i64 } @tnum_lshift(i64 %15, i64 %17, i8 noundef zeroext %conv) #11
  %18 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 0
  %20 = extractvalue { i64, i64 } %call, 0
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %18, i32 0, i32 1
  %22 = extractvalue { i64, i64 } %call, 1
  store i64 %22, i64* %21, align 8
  %23 = bitcast %struct.tnum* %var_off to i8*
  %24 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %23, i8* align 8 %24, i64 16, i1 false)
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %25) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_rsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %subreg = alloca %struct.tnum, align 8
  %umax_val = alloca i32, align 4
  %umin_val = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %3, i64 %5) #11
  %6 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 13
  %12 = load i32, i32* %u32_max_value, align 4
  store i32 %12, i32* %umax_val, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 12
  %14 = load i32, i32* %u32_min_value, align 8
  store i32 %14, i32* %umin_val, align 4
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 5
  %18 = load i32, i32* %umin_val, align 4
  %conv = trunc i32 %18 to i8
  %19 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call2 = call { i64, i64 } @tnum_rshift(i64 %21, i64 %23, i8 noundef zeroext %conv) #11
  %24 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call2, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call2, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %var_off1 to i8*
  %30 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %29, i8* align 8 %30, i64 16, i1 false)
  %31 = load i32, i32* %umax_val, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 12
  %33 = load i32, i32* %u32_min_value3, align 8
  %shr = lshr i32 %33, %31
  store i32 %shr, i32* %u32_min_value3, align 8
  %34 = load i32, i32* %umin_val, align 4
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 13
  %36 = load i32, i32* %u32_max_value4, align 4
  %shr5 = lshr i32 %36, %34
  store i32 %shr5, i32* %u32_max_value4, align 4
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %37) #11
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %38) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_rsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umax_val = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 9
  %1 = load i64, i64* %umax_value, align 8
  store i64 %1, i64* %umax_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value, align 8
  store i64 %3, i64* %umin_val, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = load i64, i64* %umin_val, align 8
  %conv = trunc i64 %8 to i8
  %9 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %9, i32 0, i32 0
  %11 = load i64, i64* %10, align 8
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %9, i32 0, i32 1
  %13 = load i64, i64* %12, align 8
  %call = call { i64, i64 } @tnum_rshift(i64 %11, i64 %13, i8 noundef zeroext %conv) #11
  %14 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 0
  %16 = extractvalue { i64, i64 } %call, 0
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 1
  %18 = extractvalue { i64, i64 } %call, 1
  store i64 %18, i64* %17, align 8
  %19 = bitcast %struct.tnum* %var_off to i8*
  %20 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 %20, i64 16, i1 false)
  %21 = load i64, i64* %umax_val, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 8
  %23 = load i64, i64* %umin_value2, align 8
  %shr = lshr i64 %23, %21
  store i64 %shr, i64* %umin_value2, align 8
  %24 = load i64, i64* %umin_val, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 9
  %26 = load i64, i64* %umax_value3, align 8
  %shr4 = lshr i64 %26, %24
  store i64 %shr4, i64* %umax_value3, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %27) #11
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %28) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar32_min_max_arsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umin_val = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 12
  %1 = load i32, i32* %u32_min_value, align 8
  %conv = zext i32 %1 to i64
  store i64 %conv, i64* %umin_val, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 10
  %3 = load i32, i32* %s32_min_value, align 8
  %4 = load i64, i64* %umin_val, align 8
  %sh_prom = trunc i64 %4 to i32
  %shr = ashr i32 %3, %sh_prom
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 10
  store i32 %shr, i32* %s32_min_value1, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 11
  %7 = load i32, i32* %s32_max_value, align 4
  %8 = load i64, i64* %umin_val, align 8
  %sh_prom2 = trunc i64 %8 to i32
  %shr3 = ashr i32 %7, %sh_prom2
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 11
  store i32 %shr3, i32* %s32_max_value4, align 4
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 5
  %12 = bitcast %struct.tnum* %var_off5 to { i64, i64 }*
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = load i64, i64* %13, align 8
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %14, i64 %16) #11
  %17 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i64, i64 } %call, 0
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i64, i64 } %call, 1
  store i64 %21, i64* %20, align 8
  %22 = load i64, i64* %umin_val, align 8
  %conv6 = trunc i64 %22 to i8
  %23 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  %call7 = call { i64, i64 } @tnum_arshift(i64 %25, i64 %27, i8 noundef zeroext %conv6, i8 noundef zeroext 32) #11
  %28 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %29 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %28, i32 0, i32 0
  %30 = extractvalue { i64, i64 } %call7, 0
  store i64 %30, i64* %29, align 8
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %28, i32 0, i32 1
  %32 = extractvalue { i64, i64 } %call7, 1
  store i64 %32, i64* %31, align 8
  %33 = bitcast %struct.tnum* %var_off to i8*
  %34 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %33, i8* align 8 %34, i64 16, i1 false)
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 12
  store i32 0, i32* %u32_min_value8, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 13
  store i32 -1, i32* %u32_max_value, align 4
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %37) #11
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg32_bounds(%struct.bpf_reg_state* noundef %38) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @scalar_min_max_arsh(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umin_val = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 8
  %1 = load i64, i64* %umin_value, align 8
  store i64 %1, i64* %umin_val, align 8
  %2 = load i64, i64* %umin_val, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 6
  %4 = load i64, i64* %smin_value, align 8
  %shr = ashr i64 %4, %2
  store i64 %shr, i64* %smin_value, align 8
  %5 = load i64, i64* %umin_val, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 7
  %7 = load i64, i64* %smax_value, align 8
  %shr1 = ashr i64 %7, %5
  store i64 %shr1, i64* %smax_value, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 5
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 5
  %10 = load i64, i64* %umin_val, align 8
  %conv = trunc i64 %10 to i8
  %11 = bitcast %struct.tnum* %var_off2 to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call = call { i64, i64 } @tnum_arshift(i64 %13, i64 %15, i8 noundef zeroext %conv, i8 noundef zeroext 64) #11
  %16 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call, 1
  store i64 %20, i64* %19, align 8
  %21 = bitcast %struct.tnum* %var_off to i8*
  %22 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %21, i8* align 8 %22, i64 16, i1 false)
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 8
  store i64 0, i64* %umin_value3, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 9
  store i64 -1, i64* %umax_value, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %25) #11
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %26) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @zext_32_to_64(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = load i64, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = load i64, i64* %5, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %4, i64 %6) #11
  %7 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = extractvalue { i64, i64 } %call, 0
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = extractvalue { i64, i64 } %call, 1
  store i64 %11, i64* %10, align 8
  %12 = bitcast %struct.tnum* %var_off to i8*
  %13 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 8 %13, i64 16, i1 false)
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_assign_32_into_64(%struct.bpf_reg_state* noundef %14) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_assign_32_into_64(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 12
  %1 = load i32, i32* %u32_min_value, align 8
  %conv = zext i32 %1 to i64
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  store i64 %conv, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 13
  %4 = load i32, i32* %u32_max_value, align 4
  %conv1 = zext i32 %4 to i64
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 9
  store i64 %conv1, i64* %umax_value, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 10
  %7 = load i32, i32* %s32_min_value, align 8
  %cmp = icmp sge i32 %7, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 11
  %9 = load i32, i32* %s32_max_value, align 4
  %cmp3 = icmp sge i32 %9, 0
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 11
  %11 = load i32, i32* %s32_max_value5, align 4
  %conv6 = sext i32 %11 to i64
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  store i64 %conv6, i64* %smax_value, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 7
  store i64 4294967295, i64* %smax_value7, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  %15 = load i32, i32* %s32_min_value8, align 8
  %cmp9 = icmp sge i32 %15, 0
  br i1 %cmp9, label %if.then11, label %if.else14

if.then11:                                        ; preds = %if.end
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 10
  %17 = load i32, i32* %s32_min_value12, align 8
  %conv13 = sext i32 %17 to i64
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 6
  store i64 %conv13, i64* %smin_value, align 8
  br label %if.end16

if.else14:                                        ; preds = %if.end
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 6
  store i64 0, i64* %smin_value15, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.else14, %if.then11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 12
  store i32 0, i32* %u32_min_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 13
  store i32 -1, i32* %u32_max_value, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  store i64 0, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 9
  store i64 -1, i64* %umax_value, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__scalar64_min_max_lsh(%struct.bpf_reg_state* noundef %dst_reg, i64 noundef %umin_val, i64 noundef %umax_val) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umin_val.addr = alloca i64, align 8
  %umax_val.addr = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i64 %umin_val, i64* %umin_val.addr, align 8
  store i64 %umax_val, i64* %umax_val.addr, align 8
  %0 = load i64, i64* %umin_val.addr, align 8
  %cmp = icmp eq i64 %0, 32
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %umax_val.addr, align 8
  %cmp1 = icmp eq i64 %1, 32
  br i1 %cmp1, label %land.lhs.true2, label %if.else

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 11
  %3 = load i32, i32* %s32_max_value, align 4
  %cmp3 = icmp sge i32 %3, 0
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true2
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 11
  %5 = load i32, i32* %s32_max_value4, align 4
  %conv = sext i32 %5 to i64
  %shl = shl i64 %conv, 32
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 7
  store i64 %shl, i64* %smax_value, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true2, %land.lhs.true, %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value5, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %8 = load i64, i64* %umin_val.addr, align 8
  %cmp6 = icmp eq i64 %8, 32
  br i1 %cmp6, label %land.lhs.true8, label %if.else18

land.lhs.true8:                                   ; preds = %if.end
  %9 = load i64, i64* %umax_val.addr, align 8
  %cmp9 = icmp eq i64 %9, 32
  br i1 %cmp9, label %land.lhs.true11, label %if.else18

land.lhs.true11:                                  ; preds = %land.lhs.true8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 10
  %11 = load i32, i32* %s32_min_value, align 8
  %cmp12 = icmp sge i32 %11, 0
  br i1 %cmp12, label %if.then14, label %if.else18

if.then14:                                        ; preds = %land.lhs.true11
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 10
  %13 = load i32, i32* %s32_min_value15, align 8
  %conv16 = sext i32 %13 to i64
  %shl17 = shl i64 %conv16, 32
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  store i64 %shl17, i64* %smin_value, align 8
  br label %if.end20

if.else18:                                        ; preds = %land.lhs.true11, %land.lhs.true8, %if.end
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else18, %if.then14
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 9
  %17 = load i64, i64* %umax_value, align 8
  %18 = load i64, i64* %umax_val.addr, align 8
  %sub = sub i64 63, %18
  %shl21 = shl i64 1, %sub
  %cmp22 = icmp ugt i64 %17, %shl21
  br i1 %cmp22, label %if.then24, label %if.else26

if.then24:                                        ; preds = %if.end20
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 8
  store i64 0, i64* %umin_value, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  store i64 -1, i64* %umax_value25, align 8
  br label %if.end31

if.else26:                                        ; preds = %if.end20
  %21 = load i64, i64* %umin_val.addr, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 8
  %23 = load i64, i64* %umin_value27, align 8
  %shl28 = shl i64 %23, %21
  store i64 %shl28, i64* %umin_value27, align 8
  %24 = load i64, i64* %umax_val.addr, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 9
  %26 = load i64, i64* %umax_value29, align 8
  %shl30 = shl i64 %26, %24
  store i64 %shl30, i64* %umax_value29, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.else26, %if.then24
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__scalar32_min_max_lsh(%struct.bpf_reg_state* noundef %dst_reg, i64 noundef %umin_val, i64 noundef %umax_val) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %umin_val.addr = alloca i64, align 8
  %umax_val.addr = alloca i64, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i64 %umin_val, i64* %umin_val.addr, align 8
  store i64 %umax_val, i64* %umax_val.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  %2 = load i64, i64* %umax_val.addr, align 8
  %cmp = icmp ugt i64 %2, 31
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 13
  %4 = load i32, i32* %u32_max_value, align 4
  %conv = zext i32 %4 to i64
  %5 = load i64, i64* %umax_val.addr, align 8
  %sub = sub i64 31, %5
  %shl = shl i64 1, %sub
  %cmp1 = icmp ugt i64 %conv, %shl
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 12
  store i32 0, i32* %u32_min_value, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 13
  store i32 -1, i32* %u32_max_value3, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %8 = load i64, i64* %umin_val.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_min_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 12
  %10 = load i32, i32* %u32_min_value4, align 8
  %sh_prom = trunc i64 %8 to i32
  %shl5 = shl i32 %10, %sh_prom
  store i32 %shl5, i32* %u32_min_value4, align 8
  %11 = load i64, i64* %umax_val.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %u32_max_value6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 13
  %13 = load i32, i32* %u32_max_value6, align 4
  %sh_prom7 = trunc i64 %11 to i32
  %shl8 = shl i32 %13, %sh_prom7
  store i32 %shl8, i32* %u32_max_value6, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  store i64 0, i64* %umin_value, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 9
  store i64 -1, i64* %umax_value, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 10
  store i32 -2147483648, i32* %s32_min_value, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 11
  store i32 2147483647, i32* %s32_max_value, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 12
  store i32 0, i32* %u32_min_value, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 13
  store i32 -1, i32* %u32_max_value, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_known(%struct.bpf_reg_state* noundef %reg, i64 noundef %imm) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %imm.addr = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %imm, i64* %imm.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %1 = load i64, i64* %imm.addr, align 8
  call void @___mark_reg_known(%struct.bpf_reg_state* noundef %0, i64 noundef %1) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @___mark_reg_known(%struct.bpf_reg_state* noundef %reg, i64 noundef %imm) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %imm.addr = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %imm, i64* %imm.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load i64, i64* %imm.addr, align 8
  %call = call { i64, i64 } @tnum_const(i64 noundef %1) #11
  %2 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %3 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call, 1
  store i64 %6, i64* %5, align 8
  %7 = bitcast %struct.tnum* %var_off to i8*
  %8 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %7, i8* align 8 %8, i64 16, i1 false)
  %9 = load i64, i64* %imm.addr, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  store i64 %9, i64* %smin_value, align 8
  %11 = load i64, i64* %imm.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  store i64 %11, i64* %smax_value, align 8
  %13 = load i64, i64* %imm.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 8
  store i64 %13, i64* %umin_value, align 8
  %15 = load i64, i64* %imm.addr, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 9
  store i64 %15, i64* %umax_value, align 8
  %17 = load i64, i64* %imm.addr, align 8
  %conv = trunc i64 %17 to i32
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 10
  store i32 %conv, i32* %s32_min_value, align 8
  %19 = load i64, i64* %imm.addr, align 8
  %conv1 = trunc i64 %19 to i32
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 11
  store i32 %conv1, i32* %s32_max_value, align 4
  %21 = load i64, i64* %imm.addr, align 8
  %conv2 = trunc i64 %21 to i32
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 12
  store i32 %conv2, i32* %u32_min_value, align 8
  %23 = load i64, i64* %imm.addr, align 8
  %conv3 = trunc i64 %23 to i32
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 13
  store i32 %conv3, i32* %u32_max_value, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_sub_overflows(i32 noundef %a, i32 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i64, align 8
  store i32 %a, i32* %a.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  %0 = load i32, i32* %a.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load i32, i32* %b.addr, align 4
  %conv1 = sext i32 %1 to i64
  %sub = sub i64 %conv, %conv1
  store i64 %sub, i64* %res, align 8
  %2 = load i32, i32* %b.addr, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %res, align 8
  %4 = load i32, i32* %a.addr, align 4
  %conv3 = sext i32 %4 to i64
  %cmp4 = icmp slt i64 %3, %conv3
  store i1 %cmp4, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %res, align 8
  %6 = load i32, i32* %a.addr, align 4
  %conv6 = sext i32 %6 to i64
  %cmp7 = icmp sgt i64 %5, %conv6
  store i1 %cmp7, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_sub32_overflows(i32 noundef %a, i32 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  %0 = load i32, i32* %a.addr, align 4
  %1 = load i32, i32* %b.addr, align 4
  %sub = sub i32 %0, %1
  store i32 %sub, i32* %res, align 4
  %2 = load i32, i32* %b.addr, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %res, align 4
  %4 = load i32, i32* %a.addr, align 4
  %cmp1 = icmp slt i32 %3, %4
  store i1 %cmp1, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, i32* %res, align 4
  %6 = load i32, i32* %a.addr, align 4
  %cmp2 = icmp sgt i32 %5, %6
  store i1 %cmp2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_add_overflows(i64 noundef %a, i64 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %1 = load i64, i64* %b.addr, align 8
  %add = add i64 %0, %1
  store i64 %add, i64* %res, align 8
  %2 = load i64, i64* %b.addr, align 8
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %res, align 8
  %4 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp sgt i64 %3, %4
  store i1 %cmp1, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %res, align 8
  %6 = load i64, i64* %a.addr, align 8
  %cmp2 = icmp slt i64 %5, %6
  store i1 %cmp2, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @signed_add32_overflows(i64 noundef %a, i64 noundef %b) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %res = alloca i32, align 4
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %conv = trunc i64 %0 to i32
  %1 = load i64, i64* %b.addr, align 8
  %conv1 = trunc i64 %1 to i32
  %add = add i32 %conv, %conv1
  store i32 %add, i32* %res, align 4
  %2 = load i64, i64* %b.addr, align 8
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %res, align 4
  %conv3 = sext i32 %3 to i64
  %4 = load i64, i64* %a.addr, align 8
  %cmp4 = icmp sgt i64 %conv3, %4
  store i1 %cmp4, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, i32* %res, align 4
  %conv6 = sext i32 %5 to i64
  %6 = load i64, i64* %a.addr, align 8
  %cmp7 = icmp slt i64 %conv6, %6
  store i1 %cmp7, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 20
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 0
  %3 = load i32, i32* %insn_idx, align 8
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  ret %struct.bpf_insn_aux_data* %arrayidx
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @can_skip_alu_sanitation(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 17
  %1 = load i8, i8* %bypass_spec_v1, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code, align 4
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 8
  %cmp = icmp eq i32 %and, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @update_alu_sanitation_state(%struct.bpf_insn_aux_data* noundef %aux, i32 noundef %alu_state, i32 noundef %alu_limit) #0 {
entry:
  %retval = alloca i32, align 4
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %alu_state.addr = alloca i32, align 4
  %alu_limit.addr = alloca i32, align 4
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store i32 %alu_state, i32* %alu_state.addr, align 4
  store i32 %alu_limit, i32* %alu_limit.addr, align 4
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %alu_state1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 6
  %1 = load i8, i8* %alu_state1, align 1
  %conv = zext i8 %1 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %alu_state2 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %2, i32 0, i32 6
  %3 = load i8, i8* %alu_state2, align 1
  %conv3 = zext i8 %3 to i32
  %4 = load i32, i32* %alu_state.addr, align 4
  %cmp = icmp ne i32 %conv3, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %5 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %6 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %5, i32 0, i32 0
  %alu_limit5 = bitcast %struct.atomic64_t* %6 to i32*
  %7 = load i32, i32* %alu_limit5, align 8
  %8 = load i32, i32* %alu_limit.addr, align 4
  %cmp6 = icmp ne i32 %7, %8
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %9 = load i32, i32* %alu_state.addr, align 4
  %conv8 = trunc i32 %9 to i8
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %alu_state9 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %10, i32 0, i32 6
  store i8 %conv8, i8* %alu_state9, align 1
  %11 = load i32, i32* %alu_limit.addr, align 4
  %12 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %13 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %12, i32 0, i32 0
  %alu_limit10 = bitcast %struct.atomic64_t* %13 to i32*
  store i32 %11, i32* %alu_limit10, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  ret %struct.bpf_func_state* %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_SUB(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_OR(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_OR.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_AND(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_AND.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_LSH(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_RSH(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_XOR(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ARSH(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ADD_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ADD_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_SUB_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_SUB_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_OR_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_OR_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_AND_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_AND_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_LSH_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_LSH_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_RSH_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_RSH_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_XOR_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_XOR_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @adjust_scalar_min_max_vals_wrapper_BPF_ARSH_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %env = alloca %struct.bpf_verifier_env, align 8
  %insn = alloca %struct.bpf_insn, align 4
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.adjust_scalar_min_max_vals_wrapper_BPF_ARSH_32.insn, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %4) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JEQ(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 29, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @push_stack___(%struct.bpf_reg_state* noundef %to, %struct.bpf_reg_state* noundef %from) #0 {
entry:
  %to.addr = alloca %struct.bpf_reg_state*, align 8
  %from.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %to, %struct.bpf_reg_state** %to.addr, align 8
  store %struct.bpf_reg_state* %from, %struct.bpf_reg_state** %from.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 %1, i32* %type1, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %4 = load i64, i64* %value, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 5
  %value3 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off2, i32 0, i32 0
  store i64 %4, i64* %value3, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off4, i32 0, i32 1
  %7 = load i64, i64* %mask, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 5
  %mask6 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off5, i32 0, i32 1
  store i64 %7, i64* %mask6, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 6
  %10 = load i64, i64* %smin_value, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %smin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 6
  store i64 %10, i64* %smin_value7, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %smax_value8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 7
  store i64 %13, i64* %smax_value8, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 8
  %16 = load i64, i64* %umin_value, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 8
  store i64 %16, i64* %umin_value9, align 8
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 9
  %19 = load i64, i64* %umax_value, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %umax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  store i64 %19, i64* %umax_value10, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 10
  %22 = load i32, i32* %s32_min_value, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %s32_min_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 10
  store i32 %22, i32* %s32_min_value11, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 11
  %25 = load i32, i32* %s32_max_value, align 4
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %s32_max_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 11
  store i32 %25, i32* %s32_max_value12, align 4
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 12
  %28 = load i32, i32* %u32_min_value, align 8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %u32_min_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 12
  store i32 %28, i32* %u32_min_value13, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %from.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 13
  %31 = load i32, i32* %u32_max_value, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %to.addr, align 8
  %u32_max_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 13
  store i32 %31, i32* %u32_max_value14, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_branch_taken(%struct.bpf_reg_state* noundef %reg, i64 noundef %val, i8 noundef zeroext %opcode, i1 noundef zeroext %is_jmp32) #0 {
entry:
  %retval = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %opcode.addr = alloca i8, align 1
  %is_jmp32.addr = alloca i8, align 1
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %is_jmp32 to i8
  store i8 %frombool, i8* %is_jmp32.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %0) #11
  br i1 %call, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  %2 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @reg_type_not_null(i32 noundef %2) #11
  br i1 %call1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %3 = load i64, i64* %val.addr, align 8
  %cmp = icmp ne i64 %3, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %4 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %4 to i32
  switch i32 %conv, label %sw.default [
    i32 16, label %sw.bb
    i32 80, label %sw.bb5
  ]

sw.bb:                                            ; preds = %if.end4
  store i32 0, i32* %retval, align 4
  br label %return

sw.bb5:                                           ; preds = %if.end4
  store i32 1, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end4
  store i32 -1, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %entry
  %5 = load i8, i8* %is_jmp32.addr, align 1
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end6
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %7 = load i64, i64* %val.addr, align 8
  %conv8 = trunc i64 %7 to i32
  %8 = load i8, i8* %opcode.addr, align 1
  %call9 = call i32 @is_branch32_taken(%struct.bpf_reg_state* noundef %6, i32 noundef %conv8, i8 noundef zeroext %8) #11
  store i32 %call9, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %10 = load i64, i64* %val.addr, align 8
  %11 = load i8, i8* %opcode.addr, align 1
  %call11 = call i32 @is_branch64_taken(%struct.bpf_reg_state* noundef %9, i64 noundef %10, i8 noundef zeroext %11) #11
  store i32 %call11, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then7, %sw.default, %sw.bb5, %sw.bb, %if.then3, %if.then2
  %12 = load i32, i32* %retval, align 4
  ret i32 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_set_min_max(%struct.bpf_reg_state* noundef %true_reg, %struct.bpf_reg_state* noundef %false_reg, i64 noundef %val, i32 noundef %val32, i8 noundef zeroext %opcode, i1 noundef zeroext %is_jmp32) #0 {
entry:
  %true_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %false_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %val32.addr = alloca i32, align 4
  %opcode.addr = alloca i8, align 1
  %is_jmp32.addr = alloca i8, align 1
  %false_32off = alloca %struct.tnum, align 8
  %false_64off = alloca %struct.tnum, align 8
  %true_32off = alloca %struct.tnum, align 8
  %true_64off = alloca %struct.tnum, align 8
  %sval = alloca i64, align 8
  %sval32 = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tmp20 = alloca %struct.tnum, align 8
  %agg.tmp21 = alloca %struct.tnum, align 8
  %tmp27 = alloca %struct.tnum, align 8
  %agg.tmp28 = alloca %struct.tnum, align 8
  %tmp34 = alloca %struct.tnum, align 8
  %agg.tmp35 = alloca %struct.tnum, align 8
  %false_umax = alloca i32, align 4
  %true_umin = alloca i32, align 4
  %__UNIQUE_ID___x440 = alloca i32, align 4
  %__UNIQUE_ID___y441 = alloca i32, align 4
  %tmp57 = alloca i32, align 4
  %__UNIQUE_ID___x442 = alloca i32, align 4
  %__UNIQUE_ID___y443 = alloca i32, align 4
  %tmp65 = alloca i32, align 4
  %false_umax74 = alloca i64, align 8
  %true_umin83 = alloca i64, align 8
  %__UNIQUE_ID___x444 = alloca i64, align 8
  %__UNIQUE_ID___y445 = alloca i64, align 8
  %tmp92 = alloca i64, align 8
  %__UNIQUE_ID___x446 = alloca i64, align 8
  %__UNIQUE_ID___y447 = alloca i64, align 8
  %tmp100 = alloca i64, align 8
  %false_smax = alloca i32, align 4
  %true_smin = alloca i32, align 4
  %__UNIQUE_ID___x448 = alloca i32, align 4
  %__UNIQUE_ID___y449 = alloca i32, align 4
  %tmp128 = alloca i32, align 4
  %__UNIQUE_ID___x450 = alloca i32, align 4
  %__UNIQUE_ID___y451 = alloca i32, align 4
  %tmp136 = alloca i32, align 4
  %false_smax145 = alloca i64, align 8
  %true_smin154 = alloca i64, align 8
  %__UNIQUE_ID___x452 = alloca i64, align 8
  %__UNIQUE_ID___y453 = alloca i64, align 8
  %tmp163 = alloca i64, align 8
  %__UNIQUE_ID___x454 = alloca i64, align 8
  %__UNIQUE_ID___y455 = alloca i64, align 8
  %tmp171 = alloca i64, align 8
  %false_umin = alloca i32, align 4
  %true_umax = alloca i32, align 4
  %__UNIQUE_ID___x456 = alloca i32, align 4
  %__UNIQUE_ID___y457 = alloca i32, align 4
  %tmp200 = alloca i32, align 4
  %__UNIQUE_ID___x458 = alloca i32, align 4
  %__UNIQUE_ID___y459 = alloca i32, align 4
  %tmp209 = alloca i32, align 4
  %false_umin218 = alloca i64, align 8
  %true_umax227 = alloca i64, align 8
  %__UNIQUE_ID___x460 = alloca i64, align 8
  %__UNIQUE_ID___y461 = alloca i64, align 8
  %tmp237 = alloca i64, align 8
  %__UNIQUE_ID___x462 = alloca i64, align 8
  %__UNIQUE_ID___y463 = alloca i64, align 8
  %tmp246 = alloca i64, align 8
  %false_smin = alloca i32, align 4
  %true_smax = alloca i32, align 4
  %__UNIQUE_ID___x464 = alloca i32, align 4
  %__UNIQUE_ID___y465 = alloca i32, align 4
  %tmp275 = alloca i32, align 4
  %__UNIQUE_ID___x466 = alloca i32, align 4
  %__UNIQUE_ID___y467 = alloca i32, align 4
  %tmp284 = alloca i32, align 4
  %false_smin293 = alloca i64, align 8
  %true_smax302 = alloca i64, align 8
  %__UNIQUE_ID___x468 = alloca i64, align 8
  %__UNIQUE_ID___y469 = alloca i64, align 8
  %tmp312 = alloca i64, align 8
  %__UNIQUE_ID___x470 = alloca i64, align 8
  %__UNIQUE_ID___y471 = alloca i64, align 8
  %tmp321 = alloca i64, align 8
  %tmp333 = alloca %struct.tnum, align 8
  %agg.tmp334 = alloca %struct.tnum, align 8
  %agg.tmp336 = alloca %struct.tnum, align 8
  %tmp340 = alloca %struct.tnum, align 8
  %agg.tmp341 = alloca %struct.tnum, align 8
  %agg.tmp343 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %true_reg, %struct.bpf_reg_state** %true_reg.addr, align 8
  store %struct.bpf_reg_state* %false_reg, %struct.bpf_reg_state** %false_reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i32 %val32, i32* %val32.addr, align 4
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %is_jmp32 to i8
  store i8 %frombool, i8* %is_jmp32.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %3, i64 %5) #11
  %6 = bitcast %struct.tnum* %false_32off to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 5
  %12 = bitcast %struct.tnum* %false_64off to i8*
  %13 = bitcast %struct.tnum* %var_off1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 8 %13, i64 16, i1 false)
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %15 = bitcast %struct.tnum* %var_off2 to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = load i64, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = load i64, i64* %18, align 8
  %call3 = call { i64, i64 } @tnum_subreg(i64 %17, i64 %19) #11
  %20 = bitcast %struct.tnum* %true_32off to { i64, i64 }*
  %21 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = extractvalue { i64, i64 } %call3, 0
  store i64 %22, i64* %21, align 8
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = extractvalue { i64, i64 } %call3, 1
  store i64 %24, i64* %23, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 5
  %26 = bitcast %struct.tnum* %true_64off to i8*
  %27 = bitcast %struct.tnum* %var_off4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %26, i8* align 8 %27, i64 16, i1 false)
  %28 = load i64, i64* %val.addr, align 8
  store i64 %28, i64* %sval, align 8
  %29 = load i32, i32* %val32.addr, align 4
  store i32 %29, i32* %sval32, align 4
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %call5 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %30) #11
  br i1 %call5, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end349

if.end:                                           ; preds = %entry
  %31 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %31 to i32
  switch i32 %conv, label %sw.default [
    i32 16, label %sw.bb
    i32 80, label %sw.bb
    i32 64, label %sw.bb11
    i32 48, label %sw.bb40
    i32 32, label %sw.bb40
    i32 112, label %sw.bb109
    i32 96, label %sw.bb109
    i32 176, label %sw.bb180
    i32 160, label %sw.bb180
    i32 208, label %sw.bb255
    i32 192, label %sw.bb255
  ]

sw.bb:                                            ; preds = %if.end, %if.end
  %32 = load i8, i8* %opcode.addr, align 1
  %conv6 = zext i8 %32 to i32
  %cmp = icmp eq i32 %conv6, 16
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %sw.bb
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %33, %cond.true ], [ %34, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  %35 = load i8, i8* %is_jmp32.addr, align 1
  %tobool = trunc i8 %35 to i1
  br i1 %tobool, label %if.then8, label %if.else

if.then8:                                         ; preds = %cond.end
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %37 = load i32, i32* %val32.addr, align 4
  %conv9 = zext i32 %37 to i64
  call void @__mark_reg32_known(%struct.bpf_reg_state* noundef %36, i64 noundef %conv9) #11
  br label %if.end10

if.else:                                          ; preds = %cond.end
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %39 = load i64, i64* %val.addr, align 8
  call void @___mark_reg_known(%struct.bpf_reg_state* noundef %38, i64 noundef %39) #11
  br label %if.end10

if.end10:                                         ; preds = %if.else, %if.then8
  br label %sw.epilog

sw.bb11:                                          ; preds = %if.end
  %40 = load i8, i8* %is_jmp32.addr, align 1
  %tobool12 = trunc i8 %40 to i1
  br i1 %tobool12, label %if.then13, label %if.else26

if.then13:                                        ; preds = %sw.bb11
  %41 = load i32, i32* %val32.addr, align 4
  %neg = xor i32 %41, -1
  %conv14 = zext i32 %neg to i64
  %call15 = call { i64, i64 } @tnum_const(i64 noundef %conv14) #11
  %42 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %43 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %42, i32 0, i32 0
  %44 = extractvalue { i64, i64 } %call15, 0
  store i64 %44, i64* %43, align 8
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %42, i32 0, i32 1
  %46 = extractvalue { i64, i64 } %call15, 1
  store i64 %46, i64* %45, align 8
  %47 = bitcast %struct.tnum* %false_32off to { i64, i64 }*
  %48 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %47, i32 0, i32 0
  %49 = load i64, i64* %48, align 8
  %50 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %47, i32 0, i32 1
  %51 = load i64, i64* %50, align 8
  %52 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 0
  %54 = load i64, i64* %53, align 8
  %55 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 1
  %56 = load i64, i64* %55, align 8
  %call16 = call { i64, i64 } @tnum_and(i64 %49, i64 %51, i64 %54, i64 %56) #11
  %57 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 0
  %59 = extractvalue { i64, i64 } %call16, 0
  store i64 %59, i64* %58, align 8
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 1
  %61 = extractvalue { i64, i64 } %call16, 1
  store i64 %61, i64* %60, align 8
  %62 = bitcast %struct.tnum* %false_32off to i8*
  %63 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %62, i8* align 8 %63, i64 16, i1 false)
  %64 = load i32, i32* %val32.addr, align 4
  %conv17 = zext i32 %64 to i64
  %call18 = call zeroext i1 @is_power_of_2(i64 noundef %conv17) #14
  br i1 %call18, label %if.then19, label %if.end25

if.then19:                                        ; preds = %if.then13
  %65 = load i32, i32* %val32.addr, align 4
  %conv22 = zext i32 %65 to i64
  %call23 = call { i64, i64 } @tnum_const(i64 noundef %conv22) #11
  %66 = bitcast %struct.tnum* %agg.tmp21 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = extractvalue { i64, i64 } %call23, 0
  store i64 %68, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = extractvalue { i64, i64 } %call23, 1
  store i64 %70, i64* %69, align 8
  %71 = bitcast %struct.tnum* %true_32off to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %76 = bitcast %struct.tnum* %agg.tmp21 to { i64, i64 }*
  %77 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 0
  %78 = load i64, i64* %77, align 8
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %76, i32 0, i32 1
  %80 = load i64, i64* %79, align 8
  %call24 = call { i64, i64 } @tnum_or(i64 %73, i64 %75, i64 %78, i64 %80) #11
  %81 = bitcast %struct.tnum* %tmp20 to { i64, i64 }*
  %82 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 0
  %83 = extractvalue { i64, i64 } %call24, 0
  store i64 %83, i64* %82, align 8
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %81, i32 0, i32 1
  %85 = extractvalue { i64, i64 } %call24, 1
  store i64 %85, i64* %84, align 8
  %86 = bitcast %struct.tnum* %true_32off to i8*
  %87 = bitcast %struct.tnum* %tmp20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %86, i8* align 8 %87, i64 16, i1 false)
  br label %if.end25

if.end25:                                         ; preds = %if.then19, %if.then13
  br label %if.end39

if.else26:                                        ; preds = %sw.bb11
  %88 = load i64, i64* %val.addr, align 8
  %neg29 = xor i64 %88, -1
  %call30 = call { i64, i64 } @tnum_const(i64 noundef %neg29) #11
  %89 = bitcast %struct.tnum* %agg.tmp28 to { i64, i64 }*
  %90 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 0
  %91 = extractvalue { i64, i64 } %call30, 0
  store i64 %91, i64* %90, align 8
  %92 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %89, i32 0, i32 1
  %93 = extractvalue { i64, i64 } %call30, 1
  store i64 %93, i64* %92, align 8
  %94 = bitcast %struct.tnum* %false_64off to { i64, i64 }*
  %95 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %94, i32 0, i32 0
  %96 = load i64, i64* %95, align 8
  %97 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %94, i32 0, i32 1
  %98 = load i64, i64* %97, align 8
  %99 = bitcast %struct.tnum* %agg.tmp28 to { i64, i64 }*
  %100 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %99, i32 0, i32 0
  %101 = load i64, i64* %100, align 8
  %102 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %99, i32 0, i32 1
  %103 = load i64, i64* %102, align 8
  %call31 = call { i64, i64 } @tnum_and(i64 %96, i64 %98, i64 %101, i64 %103) #11
  %104 = bitcast %struct.tnum* %tmp27 to { i64, i64 }*
  %105 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %104, i32 0, i32 0
  %106 = extractvalue { i64, i64 } %call31, 0
  store i64 %106, i64* %105, align 8
  %107 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %104, i32 0, i32 1
  %108 = extractvalue { i64, i64 } %call31, 1
  store i64 %108, i64* %107, align 8
  %109 = bitcast %struct.tnum* %false_64off to i8*
  %110 = bitcast %struct.tnum* %tmp27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %109, i8* align 8 %110, i64 16, i1 false)
  %111 = load i64, i64* %val.addr, align 8
  %call32 = call zeroext i1 @is_power_of_2(i64 noundef %111) #14
  br i1 %call32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.else26
  %112 = load i64, i64* %val.addr, align 8
  %call36 = call { i64, i64 } @tnum_const(i64 noundef %112) #11
  %113 = bitcast %struct.tnum* %agg.tmp35 to { i64, i64 }*
  %114 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %113, i32 0, i32 0
  %115 = extractvalue { i64, i64 } %call36, 0
  store i64 %115, i64* %114, align 8
  %116 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %113, i32 0, i32 1
  %117 = extractvalue { i64, i64 } %call36, 1
  store i64 %117, i64* %116, align 8
  %118 = bitcast %struct.tnum* %true_64off to { i64, i64 }*
  %119 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %118, i32 0, i32 0
  %120 = load i64, i64* %119, align 8
  %121 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %118, i32 0, i32 1
  %122 = load i64, i64* %121, align 8
  %123 = bitcast %struct.tnum* %agg.tmp35 to { i64, i64 }*
  %124 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %123, i32 0, i32 0
  %125 = load i64, i64* %124, align 8
  %126 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %123, i32 0, i32 1
  %127 = load i64, i64* %126, align 8
  %call37 = call { i64, i64 } @tnum_or(i64 %120, i64 %122, i64 %125, i64 %127) #11
  %128 = bitcast %struct.tnum* %tmp34 to { i64, i64 }*
  %129 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %128, i32 0, i32 0
  %130 = extractvalue { i64, i64 } %call37, 0
  store i64 %130, i64* %129, align 8
  %131 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %128, i32 0, i32 1
  %132 = extractvalue { i64, i64 } %call37, 1
  store i64 %132, i64* %131, align 8
  %133 = bitcast %struct.tnum* %true_64off to i8*
  %134 = bitcast %struct.tnum* %tmp34 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %133, i8* align 8 %134, i64 16, i1 false)
  br label %if.end38

if.end38:                                         ; preds = %if.then33, %if.else26
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end25
  br label %sw.epilog

sw.bb40:                                          ; preds = %if.end, %if.end
  %135 = load i8, i8* %is_jmp32.addr, align 1
  %tobool41 = trunc i8 %135 to i1
  br i1 %tobool41, label %if.then42, label %if.else73

if.then42:                                        ; preds = %sw.bb40
  %136 = load i8, i8* %opcode.addr, align 1
  %conv43 = zext i8 %136 to i32
  %cmp44 = icmp eq i32 %conv43, 32
  br i1 %cmp44, label %cond.true46, label %cond.false47

cond.true46:                                      ; preds = %if.then42
  %137 = load i32, i32* %val32.addr, align 4
  br label %cond.end48

cond.false47:                                     ; preds = %if.then42
  %138 = load i32, i32* %val32.addr, align 4
  %sub = sub i32 %138, 1
  br label %cond.end48

cond.end48:                                       ; preds = %cond.false47, %cond.true46
  %cond49 = phi i32 [ %137, %cond.true46 ], [ %sub, %cond.false47 ]
  store i32 %cond49, i32* %false_umax, align 4
  %139 = load i8, i8* %opcode.addr, align 1
  %conv50 = zext i8 %139 to i32
  %cmp51 = icmp eq i32 %conv50, 32
  br i1 %cmp51, label %cond.true53, label %cond.false54

cond.true53:                                      ; preds = %cond.end48
  %140 = load i32, i32* %val32.addr, align 4
  %add = add i32 %140, 1
  br label %cond.end55

cond.false54:                                     ; preds = %cond.end48
  %141 = load i32, i32* %val32.addr, align 4
  br label %cond.end55

cond.end55:                                       ; preds = %cond.false54, %cond.true53
  %cond56 = phi i32 [ %add, %cond.true53 ], [ %141, %cond.false54 ]
  store i32 %cond56, i32* %true_umin, align 4
  %142 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %142, i32 0, i32 13
  %143 = load i32, i32* %u32_max_value, align 4
  store i32 %143, i32* %__UNIQUE_ID___x440, align 4
  %144 = load i32, i32* %false_umax, align 4
  store i32 %144, i32* %__UNIQUE_ID___y441, align 4
  %145 = load i32, i32* %__UNIQUE_ID___x440, align 4
  %146 = load i32, i32* %__UNIQUE_ID___y441, align 4
  %cmp58 = icmp ult i32 %145, %146
  br i1 %cmp58, label %cond.true60, label %cond.false61

cond.true60:                                      ; preds = %cond.end55
  %147 = load i32, i32* %__UNIQUE_ID___x440, align 4
  br label %cond.end62

cond.false61:                                     ; preds = %cond.end55
  %148 = load i32, i32* %__UNIQUE_ID___y441, align 4
  br label %cond.end62

cond.end62:                                       ; preds = %cond.false61, %cond.true60
  %cond63 = phi i32 [ %147, %cond.true60 ], [ %148, %cond.false61 ]
  store i32 %cond63, i32* %tmp57, align 4
  %149 = load i32, i32* %tmp57, align 4
  %150 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %u32_max_value64 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %150, i32 0, i32 13
  store i32 %149, i32* %u32_max_value64, align 4
  %151 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %151, i32 0, i32 12
  %152 = load i32, i32* %u32_min_value, align 8
  store i32 %152, i32* %__UNIQUE_ID___x442, align 4
  %153 = load i32, i32* %true_umin, align 4
  store i32 %153, i32* %__UNIQUE_ID___y443, align 4
  %154 = load i32, i32* %__UNIQUE_ID___x442, align 4
  %155 = load i32, i32* %__UNIQUE_ID___y443, align 4
  %cmp66 = icmp ugt i32 %154, %155
  br i1 %cmp66, label %cond.true68, label %cond.false69

cond.true68:                                      ; preds = %cond.end62
  %156 = load i32, i32* %__UNIQUE_ID___x442, align 4
  br label %cond.end70

cond.false69:                                     ; preds = %cond.end62
  %157 = load i32, i32* %__UNIQUE_ID___y443, align 4
  br label %cond.end70

cond.end70:                                       ; preds = %cond.false69, %cond.true68
  %cond71 = phi i32 [ %156, %cond.true68 ], [ %157, %cond.false69 ]
  store i32 %cond71, i32* %tmp65, align 4
  %158 = load i32, i32* %tmp65, align 4
  %159 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %u32_min_value72 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %159, i32 0, i32 12
  store i32 %158, i32* %u32_min_value72, align 8
  br label %if.end108

if.else73:                                        ; preds = %sw.bb40
  %160 = load i8, i8* %opcode.addr, align 1
  %conv75 = zext i8 %160 to i32
  %cmp76 = icmp eq i32 %conv75, 32
  br i1 %cmp76, label %cond.true78, label %cond.false79

cond.true78:                                      ; preds = %if.else73
  %161 = load i64, i64* %val.addr, align 8
  br label %cond.end81

cond.false79:                                     ; preds = %if.else73
  %162 = load i64, i64* %val.addr, align 8
  %sub80 = sub i64 %162, 1
  br label %cond.end81

cond.end81:                                       ; preds = %cond.false79, %cond.true78
  %cond82 = phi i64 [ %161, %cond.true78 ], [ %sub80, %cond.false79 ]
  store i64 %cond82, i64* %false_umax74, align 8
  %163 = load i8, i8* %opcode.addr, align 1
  %conv84 = zext i8 %163 to i32
  %cmp85 = icmp eq i32 %conv84, 32
  br i1 %cmp85, label %cond.true87, label %cond.false89

cond.true87:                                      ; preds = %cond.end81
  %164 = load i64, i64* %val.addr, align 8
  %add88 = add i64 %164, 1
  br label %cond.end90

cond.false89:                                     ; preds = %cond.end81
  %165 = load i64, i64* %val.addr, align 8
  br label %cond.end90

cond.end90:                                       ; preds = %cond.false89, %cond.true87
  %cond91 = phi i64 [ %add88, %cond.true87 ], [ %165, %cond.false89 ]
  store i64 %cond91, i64* %true_umin83, align 8
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %166, i32 0, i32 9
  %167 = load i64, i64* %umax_value, align 8
  store i64 %167, i64* %__UNIQUE_ID___x444, align 8
  %168 = load i64, i64* %false_umax74, align 8
  store i64 %168, i64* %__UNIQUE_ID___y445, align 8
  %169 = load i64, i64* %__UNIQUE_ID___x444, align 8
  %170 = load i64, i64* %__UNIQUE_ID___y445, align 8
  %cmp93 = icmp ult i64 %169, %170
  br i1 %cmp93, label %cond.true95, label %cond.false96

cond.true95:                                      ; preds = %cond.end90
  %171 = load i64, i64* %__UNIQUE_ID___x444, align 8
  br label %cond.end97

cond.false96:                                     ; preds = %cond.end90
  %172 = load i64, i64* %__UNIQUE_ID___y445, align 8
  br label %cond.end97

cond.end97:                                       ; preds = %cond.false96, %cond.true95
  %cond98 = phi i64 [ %171, %cond.true95 ], [ %172, %cond.false96 ]
  store i64 %cond98, i64* %tmp92, align 8
  %173 = load i64, i64* %tmp92, align 8
  %174 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umax_value99 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %174, i32 0, i32 9
  store i64 %173, i64* %umax_value99, align 8
  %175 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %175, i32 0, i32 8
  %176 = load i64, i64* %umin_value, align 8
  store i64 %176, i64* %__UNIQUE_ID___x446, align 8
  %177 = load i64, i64* %true_umin83, align 8
  store i64 %177, i64* %__UNIQUE_ID___y447, align 8
  %178 = load i64, i64* %__UNIQUE_ID___x446, align 8
  %179 = load i64, i64* %__UNIQUE_ID___y447, align 8
  %cmp101 = icmp ugt i64 %178, %179
  br i1 %cmp101, label %cond.true103, label %cond.false104

cond.true103:                                     ; preds = %cond.end97
  %180 = load i64, i64* %__UNIQUE_ID___x446, align 8
  br label %cond.end105

cond.false104:                                    ; preds = %cond.end97
  %181 = load i64, i64* %__UNIQUE_ID___y447, align 8
  br label %cond.end105

cond.end105:                                      ; preds = %cond.false104, %cond.true103
  %cond106 = phi i64 [ %180, %cond.true103 ], [ %181, %cond.false104 ]
  store i64 %cond106, i64* %tmp100, align 8
  %182 = load i64, i64* %tmp100, align 8
  %183 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umin_value107 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %183, i32 0, i32 8
  store i64 %182, i64* %umin_value107, align 8
  br label %if.end108

if.end108:                                        ; preds = %cond.end105, %cond.end70
  br label %sw.epilog

sw.bb109:                                         ; preds = %if.end, %if.end
  %184 = load i8, i8* %is_jmp32.addr, align 1
  %tobool110 = trunc i8 %184 to i1
  br i1 %tobool110, label %if.then111, label %if.else144

if.then111:                                       ; preds = %sw.bb109
  %185 = load i8, i8* %opcode.addr, align 1
  %conv112 = zext i8 %185 to i32
  %cmp113 = icmp eq i32 %conv112, 96
  br i1 %cmp113, label %cond.true115, label %cond.false116

cond.true115:                                     ; preds = %if.then111
  %186 = load i32, i32* %sval32, align 4
  br label %cond.end118

cond.false116:                                    ; preds = %if.then111
  %187 = load i32, i32* %sval32, align 4
  %sub117 = sub i32 %187, 1
  br label %cond.end118

cond.end118:                                      ; preds = %cond.false116, %cond.true115
  %cond119 = phi i32 [ %186, %cond.true115 ], [ %sub117, %cond.false116 ]
  store i32 %cond119, i32* %false_smax, align 4
  %188 = load i8, i8* %opcode.addr, align 1
  %conv120 = zext i8 %188 to i32
  %cmp121 = icmp eq i32 %conv120, 96
  br i1 %cmp121, label %cond.true123, label %cond.false125

cond.true123:                                     ; preds = %cond.end118
  %189 = load i32, i32* %sval32, align 4
  %add124 = add i32 %189, 1
  br label %cond.end126

cond.false125:                                    ; preds = %cond.end118
  %190 = load i32, i32* %sval32, align 4
  br label %cond.end126

cond.end126:                                      ; preds = %cond.false125, %cond.true123
  %cond127 = phi i32 [ %add124, %cond.true123 ], [ %190, %cond.false125 ]
  store i32 %cond127, i32* %true_smin, align 4
  %191 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %191, i32 0, i32 11
  %192 = load i32, i32* %s32_max_value, align 4
  store i32 %192, i32* %__UNIQUE_ID___x448, align 4
  %193 = load i32, i32* %false_smax, align 4
  store i32 %193, i32* %__UNIQUE_ID___y449, align 4
  %194 = load i32, i32* %__UNIQUE_ID___x448, align 4
  %195 = load i32, i32* %__UNIQUE_ID___y449, align 4
  %cmp129 = icmp slt i32 %194, %195
  br i1 %cmp129, label %cond.true131, label %cond.false132

cond.true131:                                     ; preds = %cond.end126
  %196 = load i32, i32* %__UNIQUE_ID___x448, align 4
  br label %cond.end133

cond.false132:                                    ; preds = %cond.end126
  %197 = load i32, i32* %__UNIQUE_ID___y449, align 4
  br label %cond.end133

cond.end133:                                      ; preds = %cond.false132, %cond.true131
  %cond134 = phi i32 [ %196, %cond.true131 ], [ %197, %cond.false132 ]
  store i32 %cond134, i32* %tmp128, align 4
  %198 = load i32, i32* %tmp128, align 4
  %199 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %s32_max_value135 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %199, i32 0, i32 11
  store i32 %198, i32* %s32_max_value135, align 4
  %200 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %200, i32 0, i32 10
  %201 = load i32, i32* %s32_min_value, align 8
  store i32 %201, i32* %__UNIQUE_ID___x450, align 4
  %202 = load i32, i32* %true_smin, align 4
  store i32 %202, i32* %__UNIQUE_ID___y451, align 4
  %203 = load i32, i32* %__UNIQUE_ID___x450, align 4
  %204 = load i32, i32* %__UNIQUE_ID___y451, align 4
  %cmp137 = icmp sgt i32 %203, %204
  br i1 %cmp137, label %cond.true139, label %cond.false140

cond.true139:                                     ; preds = %cond.end133
  %205 = load i32, i32* %__UNIQUE_ID___x450, align 4
  br label %cond.end141

cond.false140:                                    ; preds = %cond.end133
  %206 = load i32, i32* %__UNIQUE_ID___y451, align 4
  br label %cond.end141

cond.end141:                                      ; preds = %cond.false140, %cond.true139
  %cond142 = phi i32 [ %205, %cond.true139 ], [ %206, %cond.false140 ]
  store i32 %cond142, i32* %tmp136, align 4
  %207 = load i32, i32* %tmp136, align 4
  %208 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %s32_min_value143 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %208, i32 0, i32 10
  store i32 %207, i32* %s32_min_value143, align 8
  br label %if.end179

if.else144:                                       ; preds = %sw.bb109
  %209 = load i8, i8* %opcode.addr, align 1
  %conv146 = zext i8 %209 to i32
  %cmp147 = icmp eq i32 %conv146, 96
  br i1 %cmp147, label %cond.true149, label %cond.false150

cond.true149:                                     ; preds = %if.else144
  %210 = load i64, i64* %sval, align 8
  br label %cond.end152

cond.false150:                                    ; preds = %if.else144
  %211 = load i64, i64* %sval, align 8
  %sub151 = sub i64 %211, 1
  br label %cond.end152

cond.end152:                                      ; preds = %cond.false150, %cond.true149
  %cond153 = phi i64 [ %210, %cond.true149 ], [ %sub151, %cond.false150 ]
  store i64 %cond153, i64* %false_smax145, align 8
  %212 = load i8, i8* %opcode.addr, align 1
  %conv155 = zext i8 %212 to i32
  %cmp156 = icmp eq i32 %conv155, 96
  br i1 %cmp156, label %cond.true158, label %cond.false160

cond.true158:                                     ; preds = %cond.end152
  %213 = load i64, i64* %sval, align 8
  %add159 = add i64 %213, 1
  br label %cond.end161

cond.false160:                                    ; preds = %cond.end152
  %214 = load i64, i64* %sval, align 8
  br label %cond.end161

cond.end161:                                      ; preds = %cond.false160, %cond.true158
  %cond162 = phi i64 [ %add159, %cond.true158 ], [ %214, %cond.false160 ]
  store i64 %cond162, i64* %true_smin154, align 8
  %215 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %215, i32 0, i32 7
  %216 = load i64, i64* %smax_value, align 8
  store i64 %216, i64* %__UNIQUE_ID___x452, align 8
  %217 = load i64, i64* %false_smax145, align 8
  store i64 %217, i64* %__UNIQUE_ID___y453, align 8
  %218 = load i64, i64* %__UNIQUE_ID___x452, align 8
  %219 = load i64, i64* %__UNIQUE_ID___y453, align 8
  %cmp164 = icmp slt i64 %218, %219
  br i1 %cmp164, label %cond.true166, label %cond.false167

cond.true166:                                     ; preds = %cond.end161
  %220 = load i64, i64* %__UNIQUE_ID___x452, align 8
  br label %cond.end168

cond.false167:                                    ; preds = %cond.end161
  %221 = load i64, i64* %__UNIQUE_ID___y453, align 8
  br label %cond.end168

cond.end168:                                      ; preds = %cond.false167, %cond.true166
  %cond169 = phi i64 [ %220, %cond.true166 ], [ %221, %cond.false167 ]
  store i64 %cond169, i64* %tmp163, align 8
  %222 = load i64, i64* %tmp163, align 8
  %223 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smax_value170 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %223, i32 0, i32 7
  store i64 %222, i64* %smax_value170, align 8
  %224 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %224, i32 0, i32 6
  %225 = load i64, i64* %smin_value, align 8
  store i64 %225, i64* %__UNIQUE_ID___x454, align 8
  %226 = load i64, i64* %true_smin154, align 8
  store i64 %226, i64* %__UNIQUE_ID___y455, align 8
  %227 = load i64, i64* %__UNIQUE_ID___x454, align 8
  %228 = load i64, i64* %__UNIQUE_ID___y455, align 8
  %cmp172 = icmp sgt i64 %227, %228
  br i1 %cmp172, label %cond.true174, label %cond.false175

cond.true174:                                     ; preds = %cond.end168
  %229 = load i64, i64* %__UNIQUE_ID___x454, align 8
  br label %cond.end176

cond.false175:                                    ; preds = %cond.end168
  %230 = load i64, i64* %__UNIQUE_ID___y455, align 8
  br label %cond.end176

cond.end176:                                      ; preds = %cond.false175, %cond.true174
  %cond177 = phi i64 [ %229, %cond.true174 ], [ %230, %cond.false175 ]
  store i64 %cond177, i64* %tmp171, align 8
  %231 = load i64, i64* %tmp171, align 8
  %232 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smin_value178 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %232, i32 0, i32 6
  store i64 %231, i64* %smin_value178, align 8
  br label %if.end179

if.end179:                                        ; preds = %cond.end176, %cond.end141
  br label %sw.epilog

sw.bb180:                                         ; preds = %if.end, %if.end
  %233 = load i8, i8* %is_jmp32.addr, align 1
  %tobool181 = trunc i8 %233 to i1
  br i1 %tobool181, label %if.then182, label %if.else217

if.then182:                                       ; preds = %sw.bb180
  %234 = load i8, i8* %opcode.addr, align 1
  %conv183 = zext i8 %234 to i32
  %cmp184 = icmp eq i32 %conv183, 160
  br i1 %cmp184, label %cond.true186, label %cond.false187

cond.true186:                                     ; preds = %if.then182
  %235 = load i32, i32* %val32.addr, align 4
  br label %cond.end189

cond.false187:                                    ; preds = %if.then182
  %236 = load i32, i32* %val32.addr, align 4
  %add188 = add i32 %236, 1
  br label %cond.end189

cond.end189:                                      ; preds = %cond.false187, %cond.true186
  %cond190 = phi i32 [ %235, %cond.true186 ], [ %add188, %cond.false187 ]
  store i32 %cond190, i32* %false_umin, align 4
  %237 = load i8, i8* %opcode.addr, align 1
  %conv191 = zext i8 %237 to i32
  %cmp192 = icmp eq i32 %conv191, 160
  br i1 %cmp192, label %cond.true194, label %cond.false196

cond.true194:                                     ; preds = %cond.end189
  %238 = load i32, i32* %val32.addr, align 4
  %sub195 = sub i32 %238, 1
  br label %cond.end197

cond.false196:                                    ; preds = %cond.end189
  %239 = load i32, i32* %val32.addr, align 4
  br label %cond.end197

cond.end197:                                      ; preds = %cond.false196, %cond.true194
  %cond198 = phi i32 [ %sub195, %cond.true194 ], [ %239, %cond.false196 ]
  store i32 %cond198, i32* %true_umax, align 4
  %240 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %u32_min_value199 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %240, i32 0, i32 12
  %241 = load i32, i32* %u32_min_value199, align 8
  store i32 %241, i32* %__UNIQUE_ID___x456, align 4
  %242 = load i32, i32* %false_umin, align 4
  store i32 %242, i32* %__UNIQUE_ID___y457, align 4
  %243 = load i32, i32* %__UNIQUE_ID___x456, align 4
  %244 = load i32, i32* %__UNIQUE_ID___y457, align 4
  %cmp201 = icmp ugt i32 %243, %244
  br i1 %cmp201, label %cond.true203, label %cond.false204

cond.true203:                                     ; preds = %cond.end197
  %245 = load i32, i32* %__UNIQUE_ID___x456, align 4
  br label %cond.end205

cond.false204:                                    ; preds = %cond.end197
  %246 = load i32, i32* %__UNIQUE_ID___y457, align 4
  br label %cond.end205

cond.end205:                                      ; preds = %cond.false204, %cond.true203
  %cond206 = phi i32 [ %245, %cond.true203 ], [ %246, %cond.false204 ]
  store i32 %cond206, i32* %tmp200, align 4
  %247 = load i32, i32* %tmp200, align 4
  %248 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %u32_min_value207 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %248, i32 0, i32 12
  store i32 %247, i32* %u32_min_value207, align 8
  %249 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %u32_max_value208 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %249, i32 0, i32 13
  %250 = load i32, i32* %u32_max_value208, align 4
  store i32 %250, i32* %__UNIQUE_ID___x458, align 4
  %251 = load i32, i32* %true_umax, align 4
  store i32 %251, i32* %__UNIQUE_ID___y459, align 4
  %252 = load i32, i32* %__UNIQUE_ID___x458, align 4
  %253 = load i32, i32* %__UNIQUE_ID___y459, align 4
  %cmp210 = icmp ult i32 %252, %253
  br i1 %cmp210, label %cond.true212, label %cond.false213

cond.true212:                                     ; preds = %cond.end205
  %254 = load i32, i32* %__UNIQUE_ID___x458, align 4
  br label %cond.end214

cond.false213:                                    ; preds = %cond.end205
  %255 = load i32, i32* %__UNIQUE_ID___y459, align 4
  br label %cond.end214

cond.end214:                                      ; preds = %cond.false213, %cond.true212
  %cond215 = phi i32 [ %254, %cond.true212 ], [ %255, %cond.false213 ]
  store i32 %cond215, i32* %tmp209, align 4
  %256 = load i32, i32* %tmp209, align 4
  %257 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %u32_max_value216 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %257, i32 0, i32 13
  store i32 %256, i32* %u32_max_value216, align 4
  br label %if.end254

if.else217:                                       ; preds = %sw.bb180
  %258 = load i8, i8* %opcode.addr, align 1
  %conv219 = zext i8 %258 to i32
  %cmp220 = icmp eq i32 %conv219, 160
  br i1 %cmp220, label %cond.true222, label %cond.false223

cond.true222:                                     ; preds = %if.else217
  %259 = load i64, i64* %val.addr, align 8
  br label %cond.end225

cond.false223:                                    ; preds = %if.else217
  %260 = load i64, i64* %val.addr, align 8
  %add224 = add i64 %260, 1
  br label %cond.end225

cond.end225:                                      ; preds = %cond.false223, %cond.true222
  %cond226 = phi i64 [ %259, %cond.true222 ], [ %add224, %cond.false223 ]
  store i64 %cond226, i64* %false_umin218, align 8
  %261 = load i8, i8* %opcode.addr, align 1
  %conv228 = zext i8 %261 to i32
  %cmp229 = icmp eq i32 %conv228, 160
  br i1 %cmp229, label %cond.true231, label %cond.false233

cond.true231:                                     ; preds = %cond.end225
  %262 = load i64, i64* %val.addr, align 8
  %sub232 = sub i64 %262, 1
  br label %cond.end234

cond.false233:                                    ; preds = %cond.end225
  %263 = load i64, i64* %val.addr, align 8
  br label %cond.end234

cond.end234:                                      ; preds = %cond.false233, %cond.true231
  %cond235 = phi i64 [ %sub232, %cond.true231 ], [ %263, %cond.false233 ]
  store i64 %cond235, i64* %true_umax227, align 8
  %264 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umin_value236 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %264, i32 0, i32 8
  %265 = load i64, i64* %umin_value236, align 8
  store i64 %265, i64* %__UNIQUE_ID___x460, align 8
  %266 = load i64, i64* %false_umin218, align 8
  store i64 %266, i64* %__UNIQUE_ID___y461, align 8
  %267 = load i64, i64* %__UNIQUE_ID___x460, align 8
  %268 = load i64, i64* %__UNIQUE_ID___y461, align 8
  %cmp238 = icmp ugt i64 %267, %268
  br i1 %cmp238, label %cond.true240, label %cond.false241

cond.true240:                                     ; preds = %cond.end234
  %269 = load i64, i64* %__UNIQUE_ID___x460, align 8
  br label %cond.end242

cond.false241:                                    ; preds = %cond.end234
  %270 = load i64, i64* %__UNIQUE_ID___y461, align 8
  br label %cond.end242

cond.end242:                                      ; preds = %cond.false241, %cond.true240
  %cond243 = phi i64 [ %269, %cond.true240 ], [ %270, %cond.false241 ]
  store i64 %cond243, i64* %tmp237, align 8
  %271 = load i64, i64* %tmp237, align 8
  %272 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %umin_value244 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %272, i32 0, i32 8
  store i64 %271, i64* %umin_value244, align 8
  %273 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umax_value245 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %273, i32 0, i32 9
  %274 = load i64, i64* %umax_value245, align 8
  store i64 %274, i64* %__UNIQUE_ID___x462, align 8
  %275 = load i64, i64* %true_umax227, align 8
  store i64 %275, i64* %__UNIQUE_ID___y463, align 8
  %276 = load i64, i64* %__UNIQUE_ID___x462, align 8
  %277 = load i64, i64* %__UNIQUE_ID___y463, align 8
  %cmp247 = icmp ult i64 %276, %277
  br i1 %cmp247, label %cond.true249, label %cond.false250

cond.true249:                                     ; preds = %cond.end242
  %278 = load i64, i64* %__UNIQUE_ID___x462, align 8
  br label %cond.end251

cond.false250:                                    ; preds = %cond.end242
  %279 = load i64, i64* %__UNIQUE_ID___y463, align 8
  br label %cond.end251

cond.end251:                                      ; preds = %cond.false250, %cond.true249
  %cond252 = phi i64 [ %278, %cond.true249 ], [ %279, %cond.false250 ]
  store i64 %cond252, i64* %tmp246, align 8
  %280 = load i64, i64* %tmp246, align 8
  %281 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %umax_value253 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %281, i32 0, i32 9
  store i64 %280, i64* %umax_value253, align 8
  br label %if.end254

if.end254:                                        ; preds = %cond.end251, %cond.end214
  br label %sw.epilog

sw.bb255:                                         ; preds = %if.end, %if.end
  %282 = load i8, i8* %is_jmp32.addr, align 1
  %tobool256 = trunc i8 %282 to i1
  br i1 %tobool256, label %if.then257, label %if.else292

if.then257:                                       ; preds = %sw.bb255
  %283 = load i8, i8* %opcode.addr, align 1
  %conv258 = zext i8 %283 to i32
  %cmp259 = icmp eq i32 %conv258, 192
  br i1 %cmp259, label %cond.true261, label %cond.false262

cond.true261:                                     ; preds = %if.then257
  %284 = load i32, i32* %sval32, align 4
  br label %cond.end264

cond.false262:                                    ; preds = %if.then257
  %285 = load i32, i32* %sval32, align 4
  %add263 = add i32 %285, 1
  br label %cond.end264

cond.end264:                                      ; preds = %cond.false262, %cond.true261
  %cond265 = phi i32 [ %284, %cond.true261 ], [ %add263, %cond.false262 ]
  store i32 %cond265, i32* %false_smin, align 4
  %286 = load i8, i8* %opcode.addr, align 1
  %conv266 = zext i8 %286 to i32
  %cmp267 = icmp eq i32 %conv266, 192
  br i1 %cmp267, label %cond.true269, label %cond.false271

cond.true269:                                     ; preds = %cond.end264
  %287 = load i32, i32* %sval32, align 4
  %sub270 = sub i32 %287, 1
  br label %cond.end272

cond.false271:                                    ; preds = %cond.end264
  %288 = load i32, i32* %sval32, align 4
  br label %cond.end272

cond.end272:                                      ; preds = %cond.false271, %cond.true269
  %cond273 = phi i32 [ %sub270, %cond.true269 ], [ %288, %cond.false271 ]
  store i32 %cond273, i32* %true_smax, align 4
  %289 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %s32_min_value274 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %289, i32 0, i32 10
  %290 = load i32, i32* %s32_min_value274, align 8
  store i32 %290, i32* %__UNIQUE_ID___x464, align 4
  %291 = load i32, i32* %false_smin, align 4
  store i32 %291, i32* %__UNIQUE_ID___y465, align 4
  %292 = load i32, i32* %__UNIQUE_ID___x464, align 4
  %293 = load i32, i32* %__UNIQUE_ID___y465, align 4
  %cmp276 = icmp sgt i32 %292, %293
  br i1 %cmp276, label %cond.true278, label %cond.false279

cond.true278:                                     ; preds = %cond.end272
  %294 = load i32, i32* %__UNIQUE_ID___x464, align 4
  br label %cond.end280

cond.false279:                                    ; preds = %cond.end272
  %295 = load i32, i32* %__UNIQUE_ID___y465, align 4
  br label %cond.end280

cond.end280:                                      ; preds = %cond.false279, %cond.true278
  %cond281 = phi i32 [ %294, %cond.true278 ], [ %295, %cond.false279 ]
  store i32 %cond281, i32* %tmp275, align 4
  %296 = load i32, i32* %tmp275, align 4
  %297 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %s32_min_value282 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %297, i32 0, i32 10
  store i32 %296, i32* %s32_min_value282, align 8
  %298 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %s32_max_value283 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %298, i32 0, i32 11
  %299 = load i32, i32* %s32_max_value283, align 4
  store i32 %299, i32* %__UNIQUE_ID___x466, align 4
  %300 = load i32, i32* %true_smax, align 4
  store i32 %300, i32* %__UNIQUE_ID___y467, align 4
  %301 = load i32, i32* %__UNIQUE_ID___x466, align 4
  %302 = load i32, i32* %__UNIQUE_ID___y467, align 4
  %cmp285 = icmp slt i32 %301, %302
  br i1 %cmp285, label %cond.true287, label %cond.false288

cond.true287:                                     ; preds = %cond.end280
  %303 = load i32, i32* %__UNIQUE_ID___x466, align 4
  br label %cond.end289

cond.false288:                                    ; preds = %cond.end280
  %304 = load i32, i32* %__UNIQUE_ID___y467, align 4
  br label %cond.end289

cond.end289:                                      ; preds = %cond.false288, %cond.true287
  %cond290 = phi i32 [ %303, %cond.true287 ], [ %304, %cond.false288 ]
  store i32 %cond290, i32* %tmp284, align 4
  %305 = load i32, i32* %tmp284, align 4
  %306 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %s32_max_value291 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %306, i32 0, i32 11
  store i32 %305, i32* %s32_max_value291, align 4
  br label %if.end329

if.else292:                                       ; preds = %sw.bb255
  %307 = load i8, i8* %opcode.addr, align 1
  %conv294 = zext i8 %307 to i32
  %cmp295 = icmp eq i32 %conv294, 192
  br i1 %cmp295, label %cond.true297, label %cond.false298

cond.true297:                                     ; preds = %if.else292
  %308 = load i64, i64* %sval, align 8
  br label %cond.end300

cond.false298:                                    ; preds = %if.else292
  %309 = load i64, i64* %sval, align 8
  %add299 = add i64 %309, 1
  br label %cond.end300

cond.end300:                                      ; preds = %cond.false298, %cond.true297
  %cond301 = phi i64 [ %308, %cond.true297 ], [ %add299, %cond.false298 ]
  store i64 %cond301, i64* %false_smin293, align 8
  %310 = load i8, i8* %opcode.addr, align 1
  %conv303 = zext i8 %310 to i32
  %cmp304 = icmp eq i32 %conv303, 192
  br i1 %cmp304, label %cond.true306, label %cond.false308

cond.true306:                                     ; preds = %cond.end300
  %311 = load i64, i64* %sval, align 8
  %sub307 = sub i64 %311, 1
  br label %cond.end309

cond.false308:                                    ; preds = %cond.end300
  %312 = load i64, i64* %sval, align 8
  br label %cond.end309

cond.end309:                                      ; preds = %cond.false308, %cond.true306
  %cond310 = phi i64 [ %sub307, %cond.true306 ], [ %312, %cond.false308 ]
  store i64 %cond310, i64* %true_smax302, align 8
  %313 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smin_value311 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %313, i32 0, i32 6
  %314 = load i64, i64* %smin_value311, align 8
  store i64 %314, i64* %__UNIQUE_ID___x468, align 8
  %315 = load i64, i64* %false_smin293, align 8
  store i64 %315, i64* %__UNIQUE_ID___y469, align 8
  %316 = load i64, i64* %__UNIQUE_ID___x468, align 8
  %317 = load i64, i64* %__UNIQUE_ID___y469, align 8
  %cmp313 = icmp sgt i64 %316, %317
  br i1 %cmp313, label %cond.true315, label %cond.false316

cond.true315:                                     ; preds = %cond.end309
  %318 = load i64, i64* %__UNIQUE_ID___x468, align 8
  br label %cond.end317

cond.false316:                                    ; preds = %cond.end309
  %319 = load i64, i64* %__UNIQUE_ID___y469, align 8
  br label %cond.end317

cond.end317:                                      ; preds = %cond.false316, %cond.true315
  %cond318 = phi i64 [ %318, %cond.true315 ], [ %319, %cond.false316 ]
  store i64 %cond318, i64* %tmp312, align 8
  %320 = load i64, i64* %tmp312, align 8
  %321 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %smin_value319 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %321, i32 0, i32 6
  store i64 %320, i64* %smin_value319, align 8
  %322 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smax_value320 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %322, i32 0, i32 7
  %323 = load i64, i64* %smax_value320, align 8
  store i64 %323, i64* %__UNIQUE_ID___x470, align 8
  %324 = load i64, i64* %true_smax302, align 8
  store i64 %324, i64* %__UNIQUE_ID___y471, align 8
  %325 = load i64, i64* %__UNIQUE_ID___x470, align 8
  %326 = load i64, i64* %__UNIQUE_ID___y471, align 8
  %cmp322 = icmp slt i64 %325, %326
  br i1 %cmp322, label %cond.true324, label %cond.false325

cond.true324:                                     ; preds = %cond.end317
  %327 = load i64, i64* %__UNIQUE_ID___x470, align 8
  br label %cond.end326

cond.false325:                                    ; preds = %cond.end317
  %328 = load i64, i64* %__UNIQUE_ID___y471, align 8
  br label %cond.end326

cond.end326:                                      ; preds = %cond.false325, %cond.true324
  %cond327 = phi i64 [ %327, %cond.true324 ], [ %328, %cond.false325 ]
  store i64 %cond327, i64* %tmp321, align 8
  %329 = load i64, i64* %tmp321, align 8
  %330 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %smax_value328 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %330, i32 0, i32 7
  store i64 %329, i64* %smax_value328, align 8
  br label %if.end329

if.end329:                                        ; preds = %cond.end326, %cond.end289
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %if.end349

sw.epilog:                                        ; preds = %if.end329, %if.end254, %if.end179, %if.end108, %if.end39, %if.end10
  %331 = load i8, i8* %is_jmp32.addr, align 1
  %tobool330 = trunc i8 %331 to i1
  br i1 %tobool330, label %if.then331, label %if.else346

if.then331:                                       ; preds = %sw.epilog
  %332 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off332 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %332, i32 0, i32 5
  %333 = bitcast %struct.tnum* %false_64off to { i64, i64 }*
  %334 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %333, i32 0, i32 0
  %335 = load i64, i64* %334, align 8
  %336 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %333, i32 0, i32 1
  %337 = load i64, i64* %336, align 8
  %call335 = call { i64, i64 } @tnum_clear_subreg(i64 %335, i64 %337) #11
  %338 = bitcast %struct.tnum* %agg.tmp334 to { i64, i64 }*
  %339 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %338, i32 0, i32 0
  %340 = extractvalue { i64, i64 } %call335, 0
  store i64 %340, i64* %339, align 8
  %341 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %338, i32 0, i32 1
  %342 = extractvalue { i64, i64 } %call335, 1
  store i64 %342, i64* %341, align 8
  %343 = bitcast %struct.tnum* %false_32off to { i64, i64 }*
  %344 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %343, i32 0, i32 0
  %345 = load i64, i64* %344, align 8
  %346 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %343, i32 0, i32 1
  %347 = load i64, i64* %346, align 8
  %call337 = call { i64, i64 } @tnum_subreg(i64 %345, i64 %347) #11
  %348 = bitcast %struct.tnum* %agg.tmp336 to { i64, i64 }*
  %349 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %348, i32 0, i32 0
  %350 = extractvalue { i64, i64 } %call337, 0
  store i64 %350, i64* %349, align 8
  %351 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %348, i32 0, i32 1
  %352 = extractvalue { i64, i64 } %call337, 1
  store i64 %352, i64* %351, align 8
  %353 = bitcast %struct.tnum* %agg.tmp334 to { i64, i64 }*
  %354 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %353, i32 0, i32 0
  %355 = load i64, i64* %354, align 8
  %356 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %353, i32 0, i32 1
  %357 = load i64, i64* %356, align 8
  %358 = bitcast %struct.tnum* %agg.tmp336 to { i64, i64 }*
  %359 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %358, i32 0, i32 0
  %360 = load i64, i64* %359, align 8
  %361 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %358, i32 0, i32 1
  %362 = load i64, i64* %361, align 8
  %call338 = call { i64, i64 } @tnum_or(i64 %355, i64 %357, i64 %360, i64 %362) #11
  %363 = bitcast %struct.tnum* %tmp333 to { i64, i64 }*
  %364 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %363, i32 0, i32 0
  %365 = extractvalue { i64, i64 } %call338, 0
  store i64 %365, i64* %364, align 8
  %366 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %363, i32 0, i32 1
  %367 = extractvalue { i64, i64 } %call338, 1
  store i64 %367, i64* %366, align 8
  %368 = bitcast %struct.tnum* %var_off332 to i8*
  %369 = bitcast %struct.tnum* %tmp333 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %368, i8* align 8 %369, i64 16, i1 false)
  %370 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off339 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %370, i32 0, i32 5
  %371 = bitcast %struct.tnum* %true_64off to { i64, i64 }*
  %372 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %371, i32 0, i32 0
  %373 = load i64, i64* %372, align 8
  %374 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %371, i32 0, i32 1
  %375 = load i64, i64* %374, align 8
  %call342 = call { i64, i64 } @tnum_clear_subreg(i64 %373, i64 %375) #11
  %376 = bitcast %struct.tnum* %agg.tmp341 to { i64, i64 }*
  %377 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %376, i32 0, i32 0
  %378 = extractvalue { i64, i64 } %call342, 0
  store i64 %378, i64* %377, align 8
  %379 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %376, i32 0, i32 1
  %380 = extractvalue { i64, i64 } %call342, 1
  store i64 %380, i64* %379, align 8
  %381 = bitcast %struct.tnum* %true_32off to { i64, i64 }*
  %382 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %381, i32 0, i32 0
  %383 = load i64, i64* %382, align 8
  %384 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %381, i32 0, i32 1
  %385 = load i64, i64* %384, align 8
  %call344 = call { i64, i64 } @tnum_subreg(i64 %383, i64 %385) #11
  %386 = bitcast %struct.tnum* %agg.tmp343 to { i64, i64 }*
  %387 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %386, i32 0, i32 0
  %388 = extractvalue { i64, i64 } %call344, 0
  store i64 %388, i64* %387, align 8
  %389 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %386, i32 0, i32 1
  %390 = extractvalue { i64, i64 } %call344, 1
  store i64 %390, i64* %389, align 8
  %391 = bitcast %struct.tnum* %agg.tmp341 to { i64, i64 }*
  %392 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %391, i32 0, i32 0
  %393 = load i64, i64* %392, align 8
  %394 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %391, i32 0, i32 1
  %395 = load i64, i64* %394, align 8
  %396 = bitcast %struct.tnum* %agg.tmp343 to { i64, i64 }*
  %397 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %396, i32 0, i32 0
  %398 = load i64, i64* %397, align 8
  %399 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %396, i32 0, i32 1
  %400 = load i64, i64* %399, align 8
  %call345 = call { i64, i64 } @tnum_or(i64 %393, i64 %395, i64 %398, i64 %400) #11
  %401 = bitcast %struct.tnum* %tmp340 to { i64, i64 }*
  %402 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %401, i32 0, i32 0
  %403 = extractvalue { i64, i64 } %call345, 0
  store i64 %403, i64* %402, align 8
  %404 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %401, i32 0, i32 1
  %405 = extractvalue { i64, i64 } %call345, 1
  store i64 %405, i64* %404, align 8
  %406 = bitcast %struct.tnum* %var_off339 to i8*
  %407 = bitcast %struct.tnum* %tmp340 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %406, i8* align 8 %407, i64 16, i1 false)
  %408 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  call void @__reg_combine_32_into_64(%struct.bpf_reg_state* noundef %408) #11
  %409 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  call void @__reg_combine_32_into_64(%struct.bpf_reg_state* noundef %409) #11
  br label %if.end349

if.else346:                                       ; preds = %sw.epilog
  %410 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %var_off347 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %410, i32 0, i32 5
  %411 = bitcast %struct.tnum* %var_off347 to i8*
  %412 = bitcast %struct.tnum* %false_64off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %411, i8* align 8 %412, i64 16, i1 false)
  %413 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %var_off348 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %413, i32 0, i32 5
  %414 = bitcast %struct.tnum* %var_off348 to i8*
  %415 = bitcast %struct.tnum* %true_64off to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %414, i8* align 8 %415, i64 16, i1 false)
  %416 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  call void @__reg_combine_64_into_32(%struct.bpf_reg_state* noundef %416) #11
  %417 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  call void @__reg_combine_64_into_32(%struct.bpf_reg_state* noundef %417) #11
  br label %if.end349

if.end349:                                        ; preds = %if.else346, %if.then331, %sw.default, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %true_reg, %struct.bpf_reg_state* noundef %false_reg, i64 noundef %val, i32 noundef %val32, i8 noundef zeroext %opcode, i1 noundef zeroext %is_jmp32) #0 {
entry:
  %true_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %false_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %val32.addr = alloca i32, align 4
  %opcode.addr = alloca i8, align 1
  %is_jmp32.addr = alloca i8, align 1
  store %struct.bpf_reg_state* %true_reg, %struct.bpf_reg_state** %true_reg.addr, align 8
  store %struct.bpf_reg_state* %false_reg, %struct.bpf_reg_state** %false_reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i32 %val32, i32* %val32.addr, align 4
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %is_jmp32 to i8
  store i8 %frombool, i8* %is_jmp32.addr, align 1
  %0 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %0 to i32
  %shr = ashr i32 %conv, 4
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr [16 x i8], [16 x i8]* @reg_set_min_max_inv.opcode_flip, i64 0, i64 %idxprom
  %1 = load i8, i8* %arrayidx, align 1
  store i8 %1, i8* %opcode.addr, align 1
  %2 = load i8, i8* %opcode.addr, align 1
  %tobool = icmp ne i8 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_reg.addr, align 8
  %5 = load i64, i64* %val.addr, align 8
  %6 = load i32, i32* %val32.addr, align 4
  %7 = load i8, i8* %opcode.addr, align 1
  %8 = load i8, i8* %is_jmp32.addr, align 1
  %tobool1 = trunc i8 %8 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef %4, i64 noundef %5, i32 noundef %6, i8 noundef zeroext %7, i1 noundef zeroext %tobool1) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @reg_combine_min_max(%struct.bpf_reg_state* noundef %true_src, %struct.bpf_reg_state* noundef %true_dst, %struct.bpf_reg_state* noundef %false_src, %struct.bpf_reg_state* noundef %false_dst, i8 noundef zeroext %opcode) #0 {
entry:
  %true_src.addr = alloca %struct.bpf_reg_state*, align 8
  %true_dst.addr = alloca %struct.bpf_reg_state*, align 8
  %false_src.addr = alloca %struct.bpf_reg_state*, align 8
  %false_dst.addr = alloca %struct.bpf_reg_state*, align 8
  %opcode.addr = alloca i8, align 1
  store %struct.bpf_reg_state* %true_src, %struct.bpf_reg_state** %true_src.addr, align 8
  store %struct.bpf_reg_state* %true_dst, %struct.bpf_reg_state** %true_dst.addr, align 8
  store %struct.bpf_reg_state* %false_src, %struct.bpf_reg_state** %false_src.addr, align 8
  store %struct.bpf_reg_state* %false_dst, %struct.bpf_reg_state** %false_dst.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %0 to i32
  switch i32 %conv, label %sw.epilog [
    i32 16, label %sw.bb
    i32 80, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_src.addr, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %true_dst.addr, align 8
  call void @__reg_combine_min_max(%struct.bpf_reg_state* noundef %1, %struct.bpf_reg_state* noundef %2) #11
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_src.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %false_dst.addr, align 8
  call void @__reg_combine_min_max(%struct.bpf_reg_state* noundef %3, %struct.bpf_reg_state* noundef %4) #11
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb1, %sw.bb, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_combine_min_max(%struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %dst_reg) #0 {
entry:
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %__UNIQUE_ID___x472 = alloca i64, align 8
  %__UNIQUE_ID___y473 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %__UNIQUE_ID___x474 = alloca i64, align 8
  %__UNIQUE_ID___y475 = alloca i64, align 8
  %tmp5 = alloca i64, align 8
  %__UNIQUE_ID___x476 = alloca i64, align 8
  %__UNIQUE_ID___y477 = alloca i64, align 8
  %tmp14 = alloca i64, align 8
  %__UNIQUE_ID___x478 = alloca i64, align 8
  %__UNIQUE_ID___y479 = alloca i64, align 8
  %tmp23 = alloca i64, align 8
  %tmp32 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 8
  %1 = load i64, i64* %umin_value, align 8
  store i64 %1, i64* %__UNIQUE_ID___x472, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value1, align 8
  store i64 %3, i64* %__UNIQUE_ID___y473, align 8
  %4 = load i64, i64* %__UNIQUE_ID___x472, align 8
  %5 = load i64, i64* %__UNIQUE_ID___y473, align 8
  %cmp = icmp ugt i64 %4, %5
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load i64, i64* %__UNIQUE_ID___x472, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load i64, i64* %__UNIQUE_ID___y473, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %6, %cond.true ], [ %7, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 8
  store i64 %8, i64* %umin_value2, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umin_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 8
  store i64 %8, i64* %umin_value3, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 9
  %12 = load i64, i64* %umax_value, align 8
  store i64 %12, i64* %__UNIQUE_ID___x474, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 9
  %14 = load i64, i64* %umax_value4, align 8
  store i64 %14, i64* %__UNIQUE_ID___y475, align 8
  %15 = load i64, i64* %__UNIQUE_ID___x474, align 8
  %16 = load i64, i64* %__UNIQUE_ID___y475, align 8
  %cmp6 = icmp ult i64 %15, %16
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.end
  %17 = load i64, i64* %__UNIQUE_ID___x474, align 8
  br label %cond.end9

cond.false8:                                      ; preds = %cond.end
  %18 = load i64, i64* %__UNIQUE_ID___y475, align 8
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false8, %cond.true7
  %cond10 = phi i64 [ %17, %cond.true7 ], [ %18, %cond.false8 ]
  store i64 %cond10, i64* %tmp5, align 8
  %19 = load i64, i64* %tmp5, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 9
  store i64 %19, i64* %umax_value11, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 9
  store i64 %19, i64* %umax_value12, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 6
  %23 = load i64, i64* %smin_value, align 8
  store i64 %23, i64* %__UNIQUE_ID___x476, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 6
  %25 = load i64, i64* %smin_value13, align 8
  store i64 %25, i64* %__UNIQUE_ID___y477, align 8
  %26 = load i64, i64* %__UNIQUE_ID___x476, align 8
  %27 = load i64, i64* %__UNIQUE_ID___y477, align 8
  %cmp15 = icmp sgt i64 %26, %27
  br i1 %cmp15, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.end9
  %28 = load i64, i64* %__UNIQUE_ID___x476, align 8
  br label %cond.end18

cond.false17:                                     ; preds = %cond.end9
  %29 = load i64, i64* %__UNIQUE_ID___y477, align 8
  br label %cond.end18

cond.end18:                                       ; preds = %cond.false17, %cond.true16
  %cond19 = phi i64 [ %28, %cond.true16 ], [ %29, %cond.false17 ]
  store i64 %cond19, i64* %tmp14, align 8
  %30 = load i64, i64* %tmp14, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smin_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 6
  store i64 %30, i64* %smin_value20, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smin_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 6
  store i64 %30, i64* %smin_value21, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 7
  %34 = load i64, i64* %smax_value, align 8
  store i64 %34, i64* %__UNIQUE_ID___x478, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 7
  %36 = load i64, i64* %smax_value22, align 8
  store i64 %36, i64* %__UNIQUE_ID___y479, align 8
  %37 = load i64, i64* %__UNIQUE_ID___x478, align 8
  %38 = load i64, i64* %__UNIQUE_ID___y479, align 8
  %cmp24 = icmp slt i64 %37, %38
  br i1 %cmp24, label %cond.true25, label %cond.false26

cond.true25:                                      ; preds = %cond.end18
  %39 = load i64, i64* %__UNIQUE_ID___x478, align 8
  br label %cond.end27

cond.false26:                                     ; preds = %cond.end18
  %40 = load i64, i64* %__UNIQUE_ID___y479, align 8
  br label %cond.end27

cond.end27:                                       ; preds = %cond.false26, %cond.true25
  %cond28 = phi i64 [ %39, %cond.true25 ], [ %40, %cond.false26 ]
  store i64 %cond28, i64* %tmp23, align 8
  %41 = load i64, i64* %tmp23, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %smax_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 7
  store i64 %41, i64* %smax_value29, align 8
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %smax_value30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 7
  store i64 %41, i64* %smax_value30, align 8
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 5
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 5
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 5
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off34 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 5
  %48 = bitcast %struct.tnum* %var_off33 to { i64, i64 }*
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %48, i32 0, i32 0
  %50 = load i64, i64* %49, align 8
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %48, i32 0, i32 1
  %52 = load i64, i64* %51, align 8
  %53 = bitcast %struct.tnum* %var_off34 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call = call { i64, i64 } @tnum_intersect(i64 %50, i64 %52, i64 %55, i64 %57) #11
  %58 = bitcast %struct.tnum* %tmp32 to { i64, i64 }*
  %59 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %58, i32 0, i32 0
  %60 = extractvalue { i64, i64 } %call, 0
  store i64 %60, i64* %59, align 8
  %61 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %58, i32 0, i32 1
  %62 = extractvalue { i64, i64 } %call, 1
  store i64 %62, i64* %61, align 8
  %63 = bitcast %struct.tnum* %var_off31 to i8*
  %64 = bitcast %struct.tnum* %tmp32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %63, i8* align 8 %64, i64 16, i1 false)
  %65 = bitcast %struct.tnum* %var_off to i8*
  %66 = bitcast %struct.tnum* %var_off31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %65, i8* align 8 %66, i64 16, i1 false)
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %67) #11
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %68) #11
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %69) #11
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %70) #11
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %71) #11
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %72) #11
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %73) #11
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %74) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__is_pointer_value(i1 noundef zeroext %allow_ptr_leaks, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %retval = alloca i1, align 1
  %allow_ptr_leaks.addr = alloca i8, align 1
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %frombool = zext i1 %allow_ptr_leaks to i8
  store i8 %frombool, i8* %allow_ptr_leaks.addr, align 1
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load i8, i8* %allow_ptr_leaks.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  %2 = load i32, i32* %type, align 8
  %cmp = icmp ne i32 %2, 1
  store i1 %cmp, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i1, i1* %retval, align 1
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg32_known(%struct.bpf_reg_state* noundef %reg, i64 noundef %imm) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %imm.addr = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %imm, i64* %imm.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = load i64, i64* %imm.addr, align 8
  %conv = trunc i64 %2 to i32
  %3 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_const_subreg(i64 %5, i64 %7, i32 noundef %conv) #11
  %8 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %13 = bitcast %struct.tnum* %var_off to i8*
  %14 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 %14, i64 16, i1 false)
  %15 = load i64, i64* %imm.addr, align 8
  %conv2 = trunc i64 %15 to i32
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 10
  store i32 %conv2, i32* %s32_min_value, align 8
  %17 = load i64, i64* %imm.addr, align 8
  %conv3 = trunc i64 %17 to i32
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 11
  store i32 %conv3, i32* %s32_max_value, align 4
  %19 = load i64, i64* %imm.addr, align 8
  %conv4 = trunc i64 %19 to i32
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 12
  store i32 %conv4, i32* %u32_min_value, align 8
  %21 = load i64, i64* %imm.addr, align 8
  %conv5 = trunc i64 %21 to i32
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 13
  store i32 %conv5, i32* %u32_max_value, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn
define internal zeroext i1 @is_power_of_2(i64 noundef %n) #6 {
entry:
  %n.addr = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load i64, i64* %n.addr, align 8
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i64, i64* %n.addr, align 8
  %2 = load i64, i64* %n.addr, align 8
  %sub = sub i64 %2, 1
  %and = and i64 %1, %sub
  %cmp1 = icmp eq i64 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_combine_32_into_64(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_clear_subreg(i64 %3, i64 %5) #11
  %6 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %call1 = call zeroext i1 @tnum_equals_const(i64 %13, i64 %15, i64 noundef 0) #11
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_assign_32_into_64(%struct.bpf_reg_state* noundef %16) #11
  br label %if.end

if.else:                                          ; preds = %entry
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg64_unbounded(%struct.bpf_reg_state* noundef %17) #11
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %18) #11
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %19) #11
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %20) #11
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %21) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__reg_combine_64_into_32(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %0) #11
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 6
  %2 = load i64, i64* %smin_value, align 8
  %call = call zeroext i1 @__reg64_bound_s32(i64 noundef %2) #11
  br i1 %call, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 7
  %4 = load i64, i64* %smax_value, align 8
  %call1 = call zeroext i1 @__reg64_bound_s32(i64 noundef %4) #11
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 6
  %6 = load i64, i64* %smin_value2, align 8
  %conv = trunc i64 %6 to i32
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 10
  store i32 %conv, i32* %s32_min_value, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 7
  %9 = load i64, i64* %smax_value3, align 8
  %conv4 = trunc i64 %9 to i32
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 11
  store i32 %conv4, i32* %s32_max_value, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 8
  %12 = load i64, i64* %umin_value, align 8
  %call5 = call zeroext i1 @__reg64_bound_u32(i64 noundef %12) #11
  br i1 %call5, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 8
  %14 = load i64, i64* %umin_value7, align 8
  %conv8 = trunc i64 %14 to i32
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 12
  store i32 %conv8, i32* %u32_min_value, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then6, %if.end
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 9
  %17 = load i64, i64* %umax_value, align 8
  %call10 = call zeroext i1 @__reg64_bound_u32(i64 noundef %17) #11
  br i1 %call10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.end9
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 9
  %19 = load i64, i64* %umax_value12, align 8
  %conv13 = trunc i64 %19 to i32
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 13
  store i32 %conv13, i32* %u32_max_value, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %if.end9
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %21) #11
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %22) #11
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %23) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__reg64_bound_s32(i64 noundef %a) #0 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %cmp = icmp sgt i64 %0, -2147483648
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp slt i64 %1, 2147483647
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__reg64_bound_u32(i64 noundef %a) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %cmp = icmp ugt i64 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %a.addr, align 8
  %cmp1 = icmp ult i64 %1, 4294967295
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i1, i1* %retval, align 1
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_equals_const(i64 %a.coerce0, i64 %a.coerce1, i64 noundef %b) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %b.addr = alloca i64, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  store i64 %b, i64* %b.addr, align 8
  %3 = bitcast %struct.tnum* %a to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %5, i64 %7) #11
  br i1 %call, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 0
  %8 = load i64, i64* %value, align 8
  %9 = load i64, i64* %b.addr, align 8
  %cmp = icmp eq i64 %8, %9
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %10 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_not_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 11
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 15
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 4
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp4 = icmp eq i32 %3, 13
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false2, %lor.lhs.false, %entry
  %4 = phi i1 [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp4, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_branch32_taken(%struct.bpf_reg_state* noundef %reg, i32 noundef %val, i8 noundef zeroext %opcode) #0 {
entry:
  %retval = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i32, align 4
  %opcode.addr = alloca i8, align 1
  %subreg = alloca %struct.tnum, align 8
  %sval = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %val, i32* %val.addr, align 4
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call { i64, i64 } @tnum_subreg(i64 %3, i64 %5) #11
  %6 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = load i32, i32* %val.addr, align 4
  store i32 %11, i32* %sval, align 4
  %12 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %12 to i32
  switch i32 %conv, label %sw.epilog [
    i32 16, label %sw.bb
    i32 80, label %sw.bb5
    i32 64, label %sw.bb13
    i32 32, label %sw.bb25
    i32 96, label %sw.bb33
    i32 160, label %sw.bb43
    i32 192, label %sw.bb55
    i32 48, label %sw.bb67
    i32 112, label %sw.bb79
    i32 176, label %sw.bb91
    i32 208, label %sw.bb103
  ]

sw.bb:                                            ; preds = %entry
  %13 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = load i64, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = load i64, i64* %16, align 8
  %call1 = call zeroext i1 @tnum_is_const(i64 %15, i64 %17) #11
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %18 = load i32, i32* %val.addr, align 4
  %conv2 = zext i32 %18 to i64
  %19 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call3 = call zeroext i1 @tnum_equals_const(i64 %21, i64 %23, i64 noundef %conv2) #11
  %lnot = xor i1 %call3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  store i32 %lnot.ext, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %24 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = load i64, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = load i64, i64* %27, align 8
  %call6 = call zeroext i1 @tnum_is_const(i64 %26, i64 %28) #11
  br i1 %call6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %sw.bb5
  %29 = load i32, i32* %val.addr, align 4
  %conv8 = zext i32 %29 to i64
  %30 = bitcast %struct.tnum* %subreg to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call9 = call zeroext i1 @tnum_equals_const(i64 %32, i64 %34, i64 noundef %conv8) #11
  %lnot10 = xor i1 %call9, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  store i32 %lnot.ext11, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %sw.bb5
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %subreg, i32 0, i32 1
  %35 = load i64, i64* %mask, align 8
  %neg = xor i64 %35, -1
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %subreg, i32 0, i32 0
  %36 = load i64, i64* %value, align 8
  %and = and i64 %neg, %36
  %37 = load i32, i32* %val.addr, align 4
  %conv14 = zext i32 %37 to i64
  %and15 = and i64 %and, %conv14
  %tobool = icmp ne i64 %and15, 0
  br i1 %tobool, label %if.then16, label %if.end17

if.then16:                                        ; preds = %sw.bb13
  store i32 1, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %sw.bb13
  %mask18 = getelementptr inbounds %struct.tnum, %struct.tnum* %subreg, i32 0, i32 1
  %38 = load i64, i64* %mask18, align 8
  %value19 = getelementptr inbounds %struct.tnum, %struct.tnum* %subreg, i32 0, i32 0
  %39 = load i64, i64* %value19, align 8
  %or = or i64 %38, %39
  %40 = load i32, i32* %val.addr, align 4
  %conv20 = zext i32 %40 to i64
  %and21 = and i64 %or, %conv20
  %tobool22 = icmp ne i64 %and21, 0
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end17
  store i32 0, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end17
  br label %sw.epilog

sw.bb25:                                          ; preds = %entry
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 12
  %42 = load i32, i32* %u32_min_value, align 8
  %43 = load i32, i32* %val.addr, align 4
  %cmp = icmp ugt i32 %42, %43
  br i1 %cmp, label %if.then27, label %if.else

if.then27:                                        ; preds = %sw.bb25
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %sw.bb25
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 13
  %45 = load i32, i32* %u32_max_value, align 4
  %46 = load i32, i32* %val.addr, align 4
  %cmp28 = icmp ule i32 %45, %46
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.else
  br label %if.end32

if.end32:                                         ; preds = %if.end31
  br label %sw.epilog

sw.bb33:                                          ; preds = %entry
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 10
  %48 = load i32, i32* %s32_min_value, align 8
  %49 = load i32, i32* %sval, align 4
  %cmp34 = icmp sgt i32 %48, %49
  br i1 %cmp34, label %if.then36, label %if.else37

if.then36:                                        ; preds = %sw.bb33
  store i32 1, i32* %retval, align 4
  br label %return

if.else37:                                        ; preds = %sw.bb33
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 11
  %51 = load i32, i32* %s32_max_value, align 4
  %52 = load i32, i32* %sval, align 4
  %cmp38 = icmp slt i32 %51, %52
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.else37
  store i32 0, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.else37
  br label %if.end42

if.end42:                                         ; preds = %if.end41
  br label %sw.epilog

sw.bb43:                                          ; preds = %entry
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 13
  %54 = load i32, i32* %u32_max_value44, align 4
  %55 = load i32, i32* %val.addr, align 4
  %cmp45 = icmp ult i32 %54, %55
  br i1 %cmp45, label %if.then47, label %if.else48

if.then47:                                        ; preds = %sw.bb43
  store i32 1, i32* %retval, align 4
  br label %return

if.else48:                                        ; preds = %sw.bb43
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value49 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 12
  %57 = load i32, i32* %u32_min_value49, align 8
  %58 = load i32, i32* %val.addr, align 4
  %cmp50 = icmp uge i32 %57, %58
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.else48
  store i32 0, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.else48
  br label %if.end54

if.end54:                                         ; preds = %if.end53
  br label %sw.epilog

sw.bb55:                                          ; preds = %entry
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value56 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 11
  %60 = load i32, i32* %s32_max_value56, align 4
  %61 = load i32, i32* %sval, align 4
  %cmp57 = icmp slt i32 %60, %61
  br i1 %cmp57, label %if.then59, label %if.else60

if.then59:                                        ; preds = %sw.bb55
  store i32 1, i32* %retval, align 4
  br label %return

if.else60:                                        ; preds = %sw.bb55
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value61 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 10
  %63 = load i32, i32* %s32_min_value61, align 8
  %64 = load i32, i32* %sval, align 4
  %cmp62 = icmp sge i32 %63, %64
  br i1 %cmp62, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.else60
  store i32 0, i32* %retval, align 4
  br label %return

if.end65:                                         ; preds = %if.else60
  br label %if.end66

if.end66:                                         ; preds = %if.end65
  br label %sw.epilog

sw.bb67:                                          ; preds = %entry
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value68 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 12
  %66 = load i32, i32* %u32_min_value68, align 8
  %67 = load i32, i32* %val.addr, align 4
  %cmp69 = icmp uge i32 %66, %67
  br i1 %cmp69, label %if.then71, label %if.else72

if.then71:                                        ; preds = %sw.bb67
  store i32 1, i32* %retval, align 4
  br label %return

if.else72:                                        ; preds = %sw.bb67
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 13
  %69 = load i32, i32* %u32_max_value73, align 4
  %70 = load i32, i32* %val.addr, align 4
  %cmp74 = icmp ult i32 %69, %70
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.else72
  store i32 0, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %if.else72
  br label %if.end78

if.end78:                                         ; preds = %if.end77
  br label %sw.epilog

sw.bb79:                                          ; preds = %entry
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 10
  %72 = load i32, i32* %s32_min_value80, align 8
  %73 = load i32, i32* %sval, align 4
  %cmp81 = icmp sge i32 %72, %73
  br i1 %cmp81, label %if.then83, label %if.else84

if.then83:                                        ; preds = %sw.bb79
  store i32 1, i32* %retval, align 4
  br label %return

if.else84:                                        ; preds = %sw.bb79
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 11
  %75 = load i32, i32* %s32_max_value85, align 4
  %76 = load i32, i32* %sval, align 4
  %cmp86 = icmp slt i32 %75, %76
  br i1 %cmp86, label %if.then88, label %if.end89

if.then88:                                        ; preds = %if.else84
  store i32 0, i32* %retval, align 4
  br label %return

if.end89:                                         ; preds = %if.else84
  br label %if.end90

if.end90:                                         ; preds = %if.end89
  br label %sw.epilog

sw.bb91:                                          ; preds = %entry
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 13
  %78 = load i32, i32* %u32_max_value92, align 4
  %79 = load i32, i32* %val.addr, align 4
  %cmp93 = icmp ule i32 %78, %79
  br i1 %cmp93, label %if.then95, label %if.else96

if.then95:                                        ; preds = %sw.bb91
  store i32 1, i32* %retval, align 4
  br label %return

if.else96:                                        ; preds = %sw.bb91
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value97 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 12
  %81 = load i32, i32* %u32_min_value97, align 8
  %82 = load i32, i32* %val.addr, align 4
  %cmp98 = icmp ugt i32 %81, %82
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %if.else96
  store i32 0, i32* %retval, align 4
  br label %return

if.end101:                                        ; preds = %if.else96
  br label %if.end102

if.end102:                                        ; preds = %if.end101
  br label %sw.epilog

sw.bb103:                                         ; preds = %entry
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value104 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 11
  %84 = load i32, i32* %s32_max_value104, align 4
  %85 = load i32, i32* %sval, align 4
  %cmp105 = icmp sle i32 %84, %85
  br i1 %cmp105, label %if.then107, label %if.else108

if.then107:                                       ; preds = %sw.bb103
  store i32 1, i32* %retval, align 4
  br label %return

if.else108:                                       ; preds = %sw.bb103
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 10
  %87 = load i32, i32* %s32_min_value109, align 8
  %88 = load i32, i32* %sval, align 4
  %cmp110 = icmp sgt i32 %87, %88
  br i1 %cmp110, label %if.then112, label %if.end113

if.then112:                                       ; preds = %if.else108
  store i32 0, i32* %retval, align 4
  br label %return

if.end113:                                        ; preds = %if.else108
  br label %if.end114

if.end114:                                        ; preds = %if.end113
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end114, %if.end102, %if.end90, %if.end78, %if.end66, %if.end54, %if.end42, %if.end32, %if.end24, %if.end12, %if.end, %entry
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then112, %if.then107, %if.then100, %if.then95, %if.then88, %if.then83, %if.then76, %if.then71, %if.then64, %if.then59, %if.then52, %if.then47, %if.then40, %if.then36, %if.then30, %if.then27, %if.then23, %if.then16, %if.then7, %if.then
  %89 = load i32, i32* %retval, align 4
  ret i32 %89
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_branch64_taken(%struct.bpf_reg_state* noundef %reg, i64 noundef %val, i8 noundef zeroext %opcode) #0 {
entry:
  %retval = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %val.addr = alloca i64, align 8
  %opcode.addr = alloca i8, align 1
  %sval = alloca i64, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %0 = load i64, i64* %val.addr, align 8
  store i64 %0, i64* %sval, align 8
  %1 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %1 to i32
  switch i32 %conv, label %sw.epilog [
    i32 16, label %sw.bb
    i32 80, label %sw.bb4
    i32 64, label %sw.bb13
    i32 32, label %sw.bb27
    i32 96, label %sw.bb35
    i32 160, label %sw.bb45
    i32 192, label %sw.bb57
    i32 48, label %sw.bb69
    i32 112, label %sw.bb81
    i32 176, label %sw.bb93
    i32 208, label %sw.bb105
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %5, i64 %7) #11
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 5
  %9 = load i64, i64* %val.addr, align 8
  %10 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %call2 = call zeroext i1 @tnum_equals_const(i64 %12, i64 %14, i64 noundef %9) #11
  %lnot = xor i1 %call2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  store i32 %lnot.ext, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %16 = bitcast %struct.tnum* %var_off5 to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call6 = call zeroext i1 @tnum_is_const(i64 %18, i64 %20) #11
  br i1 %call6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %sw.bb4
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 5
  %22 = load i64, i64* %val.addr, align 8
  %23 = bitcast %struct.tnum* %var_off8 to { i64, i64 }*
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %23, i32 0, i32 1
  %27 = load i64, i64* %26, align 8
  %call9 = call zeroext i1 @tnum_equals_const(i64 %25, i64 %27, i64 noundef %22) #11
  %lnot10 = xor i1 %call9, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  store i32 %lnot.ext11, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %sw.bb4
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 5
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off14, i32 0, i32 1
  %29 = load i64, i64* %mask, align 8
  %neg = xor i64 %29, -1
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off15, i32 0, i32 0
  %31 = load i64, i64* %value, align 8
  %and = and i64 %neg, %31
  %32 = load i64, i64* %val.addr, align 8
  %and16 = and i64 %and, %32
  %tobool = icmp ne i64 %and16, 0
  br i1 %tobool, label %if.then17, label %if.end18

if.then17:                                        ; preds = %sw.bb13
  store i32 1, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %sw.bb13
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 5
  %mask20 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off19, i32 0, i32 1
  %34 = load i64, i64* %mask20, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %value22 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off21, i32 0, i32 0
  %36 = load i64, i64* %value22, align 8
  %or = or i64 %34, %36
  %37 = load i64, i64* %val.addr, align 8
  %and23 = and i64 %or, %37
  %tobool24 = icmp ne i64 %and23, 0
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end18
  store i32 0, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.end18
  br label %sw.epilog

sw.bb27:                                          ; preds = %entry
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 8
  %39 = load i64, i64* %umin_value, align 8
  %40 = load i64, i64* %val.addr, align 8
  %cmp = icmp ugt i64 %39, %40
  br i1 %cmp, label %if.then29, label %if.else

if.then29:                                        ; preds = %sw.bb27
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %sw.bb27
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 9
  %42 = load i64, i64* %umax_value, align 8
  %43 = load i64, i64* %val.addr, align 8
  %cmp30 = icmp ule i64 %42, %43
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.else
  store i32 0, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.else
  br label %if.end34

if.end34:                                         ; preds = %if.end33
  br label %sw.epilog

sw.bb35:                                          ; preds = %entry
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 6
  %45 = load i64, i64* %smin_value, align 8
  %46 = load i64, i64* %sval, align 8
  %cmp36 = icmp sgt i64 %45, %46
  br i1 %cmp36, label %if.then38, label %if.else39

if.then38:                                        ; preds = %sw.bb35
  store i32 1, i32* %retval, align 4
  br label %return

if.else39:                                        ; preds = %sw.bb35
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 7
  %48 = load i64, i64* %smax_value, align 8
  %49 = load i64, i64* %sval, align 8
  %cmp40 = icmp slt i64 %48, %49
  br i1 %cmp40, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.else39
  store i32 0, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.else39
  br label %if.end44

if.end44:                                         ; preds = %if.end43
  br label %sw.epilog

sw.bb45:                                          ; preds = %entry
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value46 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 9
  %51 = load i64, i64* %umax_value46, align 8
  %52 = load i64, i64* %val.addr, align 8
  %cmp47 = icmp ult i64 %51, %52
  br i1 %cmp47, label %if.then49, label %if.else50

if.then49:                                        ; preds = %sw.bb45
  store i32 1, i32* %retval, align 4
  br label %return

if.else50:                                        ; preds = %sw.bb45
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value51 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 8
  %54 = load i64, i64* %umin_value51, align 8
  %55 = load i64, i64* %val.addr, align 8
  %cmp52 = icmp uge i64 %54, %55
  br i1 %cmp52, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.else50
  store i32 0, i32* %retval, align 4
  br label %return

if.end55:                                         ; preds = %if.else50
  br label %if.end56

if.end56:                                         ; preds = %if.end55
  br label %sw.epilog

sw.bb57:                                          ; preds = %entry
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 7
  %57 = load i64, i64* %smax_value58, align 8
  %58 = load i64, i64* %sval, align 8
  %cmp59 = icmp slt i64 %57, %58
  br i1 %cmp59, label %if.then61, label %if.else62

if.then61:                                        ; preds = %sw.bb57
  store i32 1, i32* %retval, align 4
  br label %return

if.else62:                                        ; preds = %sw.bb57
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value63 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 6
  %60 = load i64, i64* %smin_value63, align 8
  %61 = load i64, i64* %sval, align 8
  %cmp64 = icmp sge i64 %60, %61
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.else62
  store i32 0, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.else62
  br label %if.end68

if.end68:                                         ; preds = %if.end67
  br label %sw.epilog

sw.bb69:                                          ; preds = %entry
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 8
  %63 = load i64, i64* %umin_value70, align 8
  %64 = load i64, i64* %val.addr, align 8
  %cmp71 = icmp uge i64 %63, %64
  br i1 %cmp71, label %if.then73, label %if.else74

if.then73:                                        ; preds = %sw.bb69
  store i32 1, i32* %retval, align 4
  br label %return

if.else74:                                        ; preds = %sw.bb69
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 9
  %66 = load i64, i64* %umax_value75, align 8
  %67 = load i64, i64* %val.addr, align 8
  %cmp76 = icmp ult i64 %66, %67
  br i1 %cmp76, label %if.then78, label %if.end79

if.then78:                                        ; preds = %if.else74
  store i32 0, i32* %retval, align 4
  br label %return

if.end79:                                         ; preds = %if.else74
  br label %if.end80

if.end80:                                         ; preds = %if.end79
  br label %sw.epilog

sw.bb81:                                          ; preds = %entry
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value82 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 6
  %69 = load i64, i64* %smin_value82, align 8
  %70 = load i64, i64* %sval, align 8
  %cmp83 = icmp sge i64 %69, %70
  br i1 %cmp83, label %if.then85, label %if.else86

if.then85:                                        ; preds = %sw.bb81
  store i32 1, i32* %retval, align 4
  br label %return

if.else86:                                        ; preds = %sw.bb81
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value87 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 7
  %72 = load i64, i64* %smax_value87, align 8
  %73 = load i64, i64* %sval, align 8
  %cmp88 = icmp slt i64 %72, %73
  br i1 %cmp88, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.else86
  store i32 0, i32* %retval, align 4
  br label %return

if.end91:                                         ; preds = %if.else86
  br label %if.end92

if.end92:                                         ; preds = %if.end91
  br label %sw.epilog

sw.bb93:                                          ; preds = %entry
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value94 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 9
  %75 = load i64, i64* %umax_value94, align 8
  %76 = load i64, i64* %val.addr, align 8
  %cmp95 = icmp ule i64 %75, %76
  br i1 %cmp95, label %if.then97, label %if.else98

if.then97:                                        ; preds = %sw.bb93
  store i32 1, i32* %retval, align 4
  br label %return

if.else98:                                        ; preds = %sw.bb93
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value99 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 8
  %78 = load i64, i64* %umin_value99, align 8
  %79 = load i64, i64* %val.addr, align 8
  %cmp100 = icmp ugt i64 %78, %79
  br i1 %cmp100, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.else98
  store i32 0, i32* %retval, align 4
  br label %return

if.end103:                                        ; preds = %if.else98
  br label %if.end104

if.end104:                                        ; preds = %if.end103
  br label %sw.epilog

sw.bb105:                                         ; preds = %entry
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value106 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %80, i32 0, i32 7
  %81 = load i64, i64* %smax_value106, align 8
  %82 = load i64, i64* %sval, align 8
  %cmp107 = icmp sle i64 %81, %82
  br i1 %cmp107, label %if.then109, label %if.else110

if.then109:                                       ; preds = %sw.bb105
  store i32 1, i32* %retval, align 4
  br label %return

if.else110:                                       ; preds = %sw.bb105
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value111 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 6
  %84 = load i64, i64* %smin_value111, align 8
  %85 = load i64, i64* %sval, align 8
  %cmp112 = icmp sgt i64 %84, %85
  br i1 %cmp112, label %if.then114, label %if.end115

if.then114:                                       ; preds = %if.else110
  store i32 0, i32* %retval, align 4
  br label %return

if.end115:                                        ; preds = %if.else110
  br label %if.end116

if.end116:                                        ; preds = %if.end115
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end116, %if.end104, %if.end92, %if.end80, %if.end68, %if.end56, %if.end44, %if.end34, %if.end26, %if.end12, %if.end, %entry
  store i32 -1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then114, %if.then109, %if.then102, %if.then97, %if.then90, %if.then85, %if.then78, %if.then73, %if.then66, %if.then61, %if.then54, %if.then49, %if.then42, %if.then38, %if.then32, %if.then29, %if.then25, %if.then17, %if.then7, %if.then
  %86 = load i32, i32* %retval, align 4
  ret i32 %86
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 45, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 61, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JNE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 93, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -83, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -67, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 109, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 125, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLT(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -51, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLE(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -35, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JEQ_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 30, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 46, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JGE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 62, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JNE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 94, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -82, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JLE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -66, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 110, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSGE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 126, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLT_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -50, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local void @check_cond_jmp_op_wrapper_BPF_JSLE_32(%struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_reg_state* noundef %other_branch_dst_reg, %struct.bpf_reg_state* noundef %other_branch_src_reg) #0 {
entry:
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %other_branch_src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %insn = alloca %struct.bpf_insn, align 4
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %agg.tmp80 = alloca %struct.tnum, align 8
  %coerce90 = alloca %struct.tnum, align 8
  %agg.tmp102 = alloca %struct.tnum, align 8
  %coerce112 = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_dst_reg, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  store %struct.bpf_reg_state* %other_branch_src_reg, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  store i32 -1, i32* %pred, align 4
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -34, i8* %code, align 4
  %dst_reg1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg1, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 1
  store i8 %bf.set, i8* %dst_reg1, align 1
  %src_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg2, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 32
  store i8 %bf.set5, i8* %src_reg2, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %0 = bitcast %struct.bpf_insn* %insn to i8*
  %1 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 %1, i64 8, i1 false)
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %2 = load i8, i8* %code6, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv7 = trunc i32 %and to i8
  store i8 %conv7, i8* %opcode, align 1
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  store i32 1, i32* %type8, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %5, %struct.bpf_reg_state* noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  call void @push_stack___(%struct.bpf_reg_state* noundef %7, %struct.bpf_reg_state* noundef %8) #11
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %9 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %9 to i32
  %and11 = and i32 %conv10, 7
  %cmp = icmp eq i32 %and11, 6
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %code13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %10 = load i8, i8* %code13, align 4
  %conv14 = zext i8 %10 to i32
  %and15 = and i32 %conv14, 8
  %cmp16 = icmp eq i32 %and15, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %12 = load i32, i32* %imm18, align 4
  %conv19 = sext i32 %12 to i64
  %13 = load i8, i8* %opcode, align 1
  %14 = load i8, i8* %is_jmp32, align 1
  %tobool = trunc i8 %14 to i1
  %call = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %11, i64 noundef %conv19, i8 noundef zeroext %13, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %pred, align 4
  br label %if.end50

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type20, align 8
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %land.lhs.true, label %if.else34

land.lhs.true:                                    ; preds = %if.else
  %17 = load i8, i8* %is_jmp32, align 1
  %tobool23 = trunc i8 %17 to i1
  br i1 %tobool23, label %land.lhs.true25, label %if.else34

land.lhs.true25:                                  ; preds = %land.lhs.true
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 5
  %19 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 8
  %call26 = call { i64, i64 } @tnum_subreg(i64 %21, i64 %23) #11
  %24 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = extractvalue { i64, i64 } %call26, 0
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = extractvalue { i64, i64 } %call26, 1
  store i64 %28, i64* %27, align 8
  %29 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call27 = call zeroext i1 @tnum_is_const(i64 %31, i64 %33) #11
  br i1 %call27, label %if.then29, label %if.else34

if.then29:                                        ; preds = %land.lhs.true25
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off30 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call31 = call { i64, i64 } @tnum_subreg(i64 %38, i64 %40) #11
  %41 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %42 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 0
  %43 = extractvalue { i64, i64 } %call31, 0
  store i64 %43, i64* %42, align 8
  %44 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %41, i32 0, i32 1
  %45 = extractvalue { i64, i64 } %call31, 1
  store i64 %45, i64* %44, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %46 = load i64, i64* %value, align 8
  %47 = load i8, i8* %opcode, align 1
  %48 = load i8, i8* %is_jmp32, align 1
  %tobool32 = trunc i8 %48 to i1
  %call33 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %34, i64 noundef %46, i8 noundef zeroext %47, i1 noundef zeroext %tobool32) #11
  store i32 %call33, i32* %pred, align 4
  br label %if.end49

if.else34:                                        ; preds = %land.lhs.true25, %land.lhs.true, %if.else
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  %50 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %50, 1
  br i1 %cmp36, label %land.lhs.true38, label %if.end

land.lhs.true38:                                  ; preds = %if.else34
  %51 = load i8, i8* %is_jmp32, align 1
  %tobool39 = trunc i8 %51 to i1
  br i1 %tobool39, label %if.end, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %land.lhs.true38
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 5
  %53 = bitcast %struct.tnum* %var_off41 to { i64, i64 }*
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 0
  %55 = load i64, i64* %54, align 8
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %53, i32 0, i32 1
  %57 = load i64, i64* %56, align 8
  %call42 = call zeroext i1 @tnum_is_const(i64 %55, i64 %57) #11
  br i1 %call42, label %if.then44, label %if.end

if.then44:                                        ; preds = %land.lhs.true40
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 5
  %value46 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %60 = load i64, i64* %value46, align 8
  %61 = load i8, i8* %opcode, align 1
  %62 = load i8, i8* %is_jmp32, align 1
  %tobool47 = trunc i8 %62 to i1
  %call48 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %58, i64 noundef %60, i8 noundef zeroext %61, i1 noundef zeroext %tobool47) #11
  store i32 %call48, i32* %pred, align 4
  br label %if.end

if.end:                                           ; preds = %if.then44, %land.lhs.true40, %land.lhs.true38, %if.else34
  br label %if.end49

if.end49:                                         ; preds = %if.end, %if.then29
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then
  %63 = load i32, i32* %pred, align 4
  %cmp51 = icmp eq i32 %63, 1
  br i1 %cmp51, label %if.then53, label %if.else54

if.then53:                                        ; preds = %if.end50
  br label %if.end141

if.else54:                                        ; preds = %if.end50
  %64 = load i32, i32* %pred, align 4
  %cmp55 = icmp eq i32 %64, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else54
  br label %if.end141

if.end58:                                         ; preds = %if.else54
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %65 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %65 to i32
  %and62 = and i32 %conv61, 8
  %cmp63 = icmp eq i32 %and62, 8
  br i1 %cmp63, label %if.then65, label %if.else131

if.then65:                                        ; preds = %if.end59
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type66, align 8
  %cmp67 = icmp eq i32 %67, 1
  br i1 %cmp67, label %land.lhs.true69, label %if.end130

land.lhs.true69:                                  ; preds = %if.then65
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  %69 = load i32, i32* %type70, align 8
  %cmp71 = icmp eq i32 %69, 1
  br i1 %cmp71, label %if.then73, label %if.end130

if.then73:                                        ; preds = %land.lhs.true69
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 5
  %71 = bitcast %struct.tnum* %var_off74 to { i64, i64 }*
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 0
  %73 = load i64, i64* %72, align 8
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 8
  %call75 = call zeroext i1 @tnum_is_const(i64 %73, i64 %75) #11
  br i1 %call75, label %if.then85, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then73
  %76 = load i8, i8* %is_jmp32, align 1
  %tobool77 = trunc i8 %76 to i1
  br i1 %tobool77, label %land.lhs.true79, label %if.else94

land.lhs.true79:                                  ; preds = %lor.lhs.false
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 5
  %78 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %79 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 8
  %call82 = call { i64, i64 } @tnum_subreg(i64 %80, i64 %82) #11
  %83 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call82, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call82, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.tnum* %agg.tmp80 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = load i64, i64* %91, align 8
  %call83 = call zeroext i1 @tnum_is_const(i64 %90, i64 %92) #11
  br i1 %call83, label %if.then85, label %if.else94

if.then85:                                        ; preds = %land.lhs.true79, %if.then73
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %value87 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off86, i32 0, i32 0
  %96 = load i64, i64* %value87, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %var_off88 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 5
  %98 = bitcast %struct.tnum* %var_off88 to { i64, i64 }*
  %99 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 0
  %100 = load i64, i64* %99, align 8
  %101 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %98, i32 0, i32 1
  %102 = load i64, i64* %101, align 8
  %call89 = call { i64, i64 } @tnum_subreg(i64 %100, i64 %102) #11
  %103 = bitcast %struct.tnum* %coerce90 to { i64, i64 }*
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 0
  %105 = extractvalue { i64, i64 } %call89, 0
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %103, i32 0, i32 1
  %107 = extractvalue { i64, i64 } %call89, 1
  store i64 %107, i64* %106, align 8
  %value91 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce90, i32 0, i32 0
  %108 = load i64, i64* %value91, align 8
  %conv92 = trunc i64 %108 to i32
  %109 = load i8, i8* %opcode, align 1
  %110 = load i8, i8* %is_jmp32, align 1
  %tobool93 = trunc i8 %110 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94, i64 noundef %96, i32 noundef %conv92, i8 noundef zeroext %109, i1 noundef zeroext %tobool93) #11
  br label %if.end129

if.else94:                                        ; preds = %land.lhs.true79, %lor.lhs.false
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 5
  %112 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %113 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 8
  %115 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 8
  %call96 = call zeroext i1 @tnum_is_const(i64 %114, i64 %116) #11
  br i1 %call96, label %if.then107, label %lor.lhs.false98

lor.lhs.false98:                                  ; preds = %if.else94
  %117 = load i8, i8* %is_jmp32, align 1
  %tobool99 = trunc i8 %117 to i1
  br i1 %tobool99, label %land.lhs.true101, label %if.else116

land.lhs.true101:                                 ; preds = %lor.lhs.false98
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 5
  %119 = bitcast %struct.tnum* %var_off103 to { i64, i64 }*
  %120 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 0
  %121 = load i64, i64* %120, align 8
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %119, i32 0, i32 1
  %123 = load i64, i64* %122, align 8
  %call104 = call { i64, i64 } @tnum_subreg(i64 %121, i64 %123) #11
  %124 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 0
  %126 = extractvalue { i64, i64 } %call104, 0
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %124, i32 0, i32 1
  %128 = extractvalue { i64, i64 } %call104, 1
  store i64 %128, i64* %127, align 8
  %129 = bitcast %struct.tnum* %agg.tmp102 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call105 = call zeroext i1 @tnum_is_const(i64 %131, i64 %133) #11
  br i1 %call105, label %if.then107, label %if.else116

if.then107:                                       ; preds = %land.lhs.true101, %if.else94
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 5
  %value109 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off108, i32 0, i32 0
  %137 = load i64, i64* %value109, align 8
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %var_off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 5
  %139 = bitcast %struct.tnum* %var_off110 to { i64, i64 }*
  %140 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 8
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 8
  %call111 = call { i64, i64 } @tnum_subreg(i64 %141, i64 %143) #11
  %144 = bitcast %struct.tnum* %coerce112 to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = extractvalue { i64, i64 } %call111, 0
  store i64 %146, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = extractvalue { i64, i64 } %call111, 1
  store i64 %148, i64* %147, align 8
  %value113 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce112, i32 0, i32 0
  %149 = load i64, i64* %value113, align 8
  %conv114 = trunc i64 %149 to i32
  %150 = load i8, i8* %opcode, align 1
  %151 = load i8, i8* %is_jmp32, align 1
  %tobool115 = trunc i8 %151 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %134, %struct.bpf_reg_state* noundef %135, i64 noundef %137, i32 noundef %conv114, i8 noundef zeroext %150, i1 noundef zeroext %tobool115) #11
  br label %if.end128

if.else116:                                       ; preds = %land.lhs.true101, %lor.lhs.false98
  %152 = load i8, i8* %is_jmp32, align 1
  %tobool117 = trunc i8 %152 to i1
  br i1 %tobool117, label %if.end127, label %land.lhs.true118

land.lhs.true118:                                 ; preds = %if.else116
  %153 = load i8, i8* %opcode, align 1
  %conv119 = zext i8 %153 to i32
  %cmp120 = icmp eq i32 %conv119, 16
  br i1 %cmp120, label %if.then126, label %lor.lhs.false122

lor.lhs.false122:                                 ; preds = %land.lhs.true118
  %154 = load i8, i8* %opcode, align 1
  %conv123 = zext i8 %154 to i32
  %cmp124 = icmp eq i32 %conv123, 80
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %lor.lhs.false122, %land.lhs.true118
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_src_reg.addr, align 8
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %159 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %155, %struct.bpf_reg_state* noundef %156, %struct.bpf_reg_state* noundef %157, %struct.bpf_reg_state* noundef %158, i8 noundef zeroext %159) #11
  br label %if.end127

if.end127:                                        ; preds = %if.then126, %lor.lhs.false122, %if.else116
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.then107
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %if.then85
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %land.lhs.true69, %if.then65
  br label %if.end141

if.else131:                                       ; preds = %if.end59
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 0
  %161 = load i32, i32* %type132, align 8
  %cmp133 = icmp eq i32 %161, 1
  br i1 %cmp133, label %if.then135, label %if.end140

if.then135:                                       ; preds = %if.else131
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_dst_reg.addr, align 8
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %imm136 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %164 = load i32, i32* %imm136, align 4
  %conv137 = sext i32 %164 to i64
  %imm138 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 3
  %165 = load i32, i32* %imm138, align 4
  %166 = load i8, i8* %opcode, align 1
  %167 = load i8, i8* %is_jmp32, align 1
  %tobool139 = trunc i8 %167 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %162, %struct.bpf_reg_state* noundef %163, i64 noundef %conv137, i32 noundef %165, i8 noundef zeroext %166, i1 noundef zeroext %tobool139) #11
  br label %if.end140

if.end140:                                        ; preds = %if.then135, %if.else131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end130, %if.then57, %if.then53
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @bpf_check_attach_target(%struct.bpf_verifier_log* noundef %log, %struct.bpf_prog* noundef %prog, %struct.bpf_prog* noundef %tgt_prog, i32 noundef %btf_id, %struct.bpf_attach_target_info* noundef %tgt_info) #0 {
entry:
  %retval = alloca i32, align 4
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %tgt_prog.addr = alloca %struct.bpf_prog*, align 8
  %btf_id.addr = alloca i32, align 4
  %tgt_info.addr = alloca %struct.bpf_attach_target_info*, align 8
  %prog_extension = alloca i8, align 1
  %prefix = alloca [11 x i8], align 1
  %ret = alloca i32, align 4
  %subprog = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca %struct.btf_type*, align 8
  %conservative = alloca i8, align 1
  %tname = alloca i8*, align 8
  %btf = alloca %struct.btf*, align 8
  %addr = alloca i64, align 8
  %aux15 = alloca %struct.bpf_prog_aux*, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store %struct.bpf_prog* %tgt_prog, %struct.bpf_prog** %tgt_prog.addr, align 8
  store i32 %btf_id, i32* %btf_id.addr, align 4
  store %struct.bpf_attach_target_info* %tgt_info, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 2
  %1 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %1, 28
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %prog_extension, align 1
  %2 = bitcast [11 x i8]* %prefix to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %2, i8* align 1 getelementptr inbounds ([11 x i8], [11 x i8]* @__const.bpf_check_attach_target.prefix, i32 0, i32 0), i64 11, i1 false)
  store i32 0, i32* %ret, align 4
  store i32 -1, i32* %subprog, align 4
  store i8 1, i8* %conservative, align 1
  store i64 0, i64* %addr, align 8
  %3 = load i32, i32* %btf_id.addr, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %4, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.5, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool1 = icmp ne %struct.bpf_prog* %5, null
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 7
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 44
  %8 = load %struct.btf*, %struct.btf** %btf2, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %9 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.btf* [ %8, %cond.true ], [ %9, %cond.false ]
  store %struct.btf* %cond, %struct.btf** %btf, align 8
  %10 = load %struct.btf*, %struct.btf** %btf, align 8
  %tobool3 = icmp ne %struct.btf* %10, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %cond.end
  %11 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %11, i8* noundef getelementptr inbounds ([81 x i8], [81 x i8]* @.str.6, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %cond.end
  %12 = load %struct.btf*, %struct.btf** %btf, align 8
  %13 = load i32, i32* %btf_id.addr, align 4
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %12, i32 noundef %13) #11
  store %struct.btf_type* %call, %struct.btf_type** %t, align 8
  %14 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %tobool6 = icmp ne %struct.btf_type* %14, null
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end5
  %15 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %16 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %15, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.7, i64 0, i64 0), i32 noundef %16) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end5
  %17 = load %struct.btf*, %struct.btf** %btf, align 8
  %18 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %18, i32 0, i32 0
  %19 = load i32, i32* %name_off, align 4
  %call9 = call i8* @btf_name_by_offset(%struct.btf* noundef %17, i32 noundef %19) #11
  store i8* %call9, i8** %tname, align 8
  %20 = load i8*, i8** %tname, align 8
  %tobool10 = icmp ne i8* %20, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end8
  %21 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %22 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %21, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.8, i64 0, i64 0), i32 noundef %22) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end8
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool13 = icmp ne %struct.bpf_prog* %23, null
  br i1 %tobool13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end12
  %24 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %aux16 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %24, i32 0, i32 7
  %25 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux16, align 8
  store %struct.bpf_prog_aux* %25, %struct.bpf_prog_aux** %aux15, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then14
  %26 = load i32, i32* %i, align 4
  %27 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux15, align 8
  %func_info_cnt = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %27, i32 0, i32 49
  %28 = load i32, i32* %func_info_cnt, align 8
  %cmp17 = icmp ult i32 %26, %28
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %29 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux15, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %29, i32 0, i32 45
  %30 = load %struct.util_est*, %struct.util_est** %func_info, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom = sext i32 %31 to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %30, i64 %idxprom
  %type_id = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 1
  %32 = load i32, i32* %type_id, align 4
  %33 = load i32, i32* %btf_id.addr, align 4
  %cmp18 = icmp eq i32 %32, %33
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %for.body
  %34 = load i32, i32* %i, align 4
  store i32 %34, i32* %subprog, align 4
  br label %for.end

if.end20:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %35 = load i32, i32* %i, align 4
  %inc = add i32 %35, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then19, %for.cond
  %36 = load i32, i32* %subprog, align 4
  %cmp21 = icmp eq i32 %36, -1
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %for.end
  %37 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %38 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %37, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.9, i64 0, i64 0), i8* noundef %38) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %for.end
  %39 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux15, align 8
  %func_info_aux = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %39, i32 0, i32 46
  %40 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %41 = load i32, i32* %subprog, align 4
  %idxprom24 = sext i32 %41 to i64
  %arrayidx25 = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %40, i64 %idxprom24
  %unreliable = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx25, i32 0, i32 1
  %42 = load i8, i8* %unreliable, align 2
  %tobool26 = trunc i8 %42 to i1
  %frombool27 = zext i1 %tobool26 to i8
  store i8 %frombool27, i8* %conservative, align 1
  %43 = load i8, i8* %prog_extension, align 1
  %tobool28 = trunc i8 %43 to i1
  br i1 %tobool28, label %if.then29, label %if.end36

if.then29:                                        ; preds = %if.end23
  %44 = load i8, i8* %conservative, align 1
  %tobool30 = trunc i8 %44 to i1
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.then29
  %45 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %45, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.10, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.then29
  %46 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %46, i32 0, i32 1
  %bf.load = load i16, i16* %jit_requested, align 2
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %tobool33 = icmp ne i16 %bf.clear, 0
  br i1 %tobool33, label %if.end35, label %if.then34

if.then34:                                        ; preds = %if.end32
  %47 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %47, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.11, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end35:                                         ; preds = %if.end32
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.end23
  %48 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %jited = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %48, i32 0, i32 1
  %bf.load37 = load i16, i16* %jited, align 2
  %bf.clear38 = and i16 %bf.load37, 1
  %tobool39 = icmp ne i16 %bf.clear38, 0
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.end36
  %49 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %49, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.12, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end36
  %50 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %type42 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %50, i32 0, i32 2
  %51 = load i32, i32* %type42, align 4
  %52 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type43 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %52, i32 0, i32 2
  %53 = load i32, i32* %type43, align 4
  %cmp44 = icmp eq i32 %51, %53
  br i1 %cmp44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.end41
  %54 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %54, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.13, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end46:                                         ; preds = %if.end41
  %55 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %type47 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %55, i32 0, i32 2
  %56 = load i32, i32* %type47, align 4
  %cmp48 = icmp eq i32 %56, 26
  br i1 %cmp48, label %land.lhs.true, label %if.end55

land.lhs.true:                                    ; preds = %if.end46
  %57 = load i8, i8* %prog_extension, align 1
  %tobool49 = trunc i8 %57 to i1
  br i1 %tobool49, label %land.lhs.true50, label %if.end55

land.lhs.true50:                                  ; preds = %land.lhs.true
  %58 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %58, i32 0, i32 3
  %59 = load i32, i32* %expected_attach_type, align 8
  %cmp51 = icmp eq i32 %59, 24
  br i1 %cmp51, label %if.then54, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true50
  %60 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %expected_attach_type52 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %60, i32 0, i32 3
  %61 = load i32, i32* %expected_attach_type52, align 8
  %cmp53 = icmp eq i32 %61, 25
  br i1 %cmp53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %lor.lhs.false, %land.lhs.true50
  %62 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %62, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.14, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end55:                                         ; preds = %lor.lhs.false, %land.lhs.true, %if.end46
  br label %if.end59

if.else:                                          ; preds = %if.end12
  %63 = load i8, i8* %prog_extension, align 1
  %tobool56 = trunc i8 %63 to i1
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.else
  %64 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %64, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.15, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end58:                                         ; preds = %if.else
  br label %if.end59

if.end59:                                         ; preds = %if.end58, %if.end55
  %65 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %expected_attach_type60 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %65, i32 0, i32 3
  %66 = load i32, i32* %expected_attach_type60, align 8
  switch i32 %66, label %sw.default [
    i32 23, label %sw.bb
    i32 28, label %sw.bb81
    i32 26, label %sw.bb97
    i32 27, label %sw.bb97
    i32 24, label %sw.bb97
    i32 25, label %sw.bb97
  ]

sw.bb:                                            ; preds = %if.end59
  %67 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool61 = icmp ne %struct.bpf_prog* %67, null
  br i1 %tobool61, label %if.then62, label %if.end63

if.then62:                                        ; preds = %sw.bb
  %68 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %68, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.16, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end63:                                         ; preds = %sw.bb
  %69 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call64 = call zeroext i1 @btf_type_is_typedef(%struct.btf_type* noundef %69) #11
  br i1 %call64, label %if.end66, label %if.then65

if.then65:                                        ; preds = %if.end63
  %70 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %71 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %70, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.17, i64 0, i64 0), i32 noundef %71) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end66:                                         ; preds = %if.end63
  %arraydecay = getelementptr inbounds [11 x i8], [11 x i8]* %prefix, i64 0, i64 0
  %72 = load i8*, i8** %tname, align 8
  %call67 = call i32 @strncmp(i8* noundef %arraydecay, i8* noundef %72, i64 noundef 10) #11
  %tobool68 = icmp ne i32 %call67, 0
  br i1 %tobool68, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.end66
  %73 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %74 = load i32, i32* %btf_id.addr, align 4
  %75 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %73, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.18, i64 0, i64 0), i32 noundef %74, i8* noundef %75) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end70:                                         ; preds = %if.end66
  %76 = load i8*, i8** %tname, align 8
  %add.ptr = getelementptr i8, i8* %76, i64 10
  store i8* %add.ptr, i8** %tname, align 8
  %77 = load %struct.btf*, %struct.btf** %btf, align 8
  %78 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %79 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %78, i32 0, i32 2
  %type71 = bitcast %struct.atomic_t* %79 to i32*
  %80 = load i32, i32* %type71, align 4
  %call72 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %77, i32 noundef %80) #11
  store %struct.btf_type* %call72, %struct.btf_type** %t, align 8
  %81 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call73 = call zeroext i1 @btf_type_is_ptr(%struct.btf_type* noundef %81) #11
  br i1 %call73, label %if.end75, label %if.then74

if.then74:                                        ; preds = %if.end70
  store i32 -22, i32* %retval, align 4
  br label %return

if.end75:                                         ; preds = %if.end70
  %82 = load %struct.btf*, %struct.btf** %btf, align 8
  %83 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %84 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %83, i32 0, i32 2
  %type76 = bitcast %struct.atomic_t* %84 to i32*
  %85 = load i32, i32* %type76, align 4
  %call77 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %82, i32 noundef %85) #11
  store %struct.btf_type* %call77, %struct.btf_type** %t, align 8
  %86 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call78 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %86) #11
  br i1 %call78, label %if.end80, label %if.then79

if.then79:                                        ; preds = %if.end75
  store i32 -22, i32* %retval, align 4
  br label %return

if.end80:                                         ; preds = %if.end75
  br label %sw.epilog190

sw.bb81:                                          ; preds = %if.end59
  %87 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call82 = call zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %87) #11
  br i1 %call82, label %if.end84, label %if.then83

if.then83:                                        ; preds = %sw.bb81
  %88 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %89 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %88, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.19, i64 0, i64 0), i32 noundef %89) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end84:                                         ; preds = %sw.bb81
  %90 = load %struct.btf*, %struct.btf** %btf, align 8
  %91 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %92 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %91, i32 0, i32 2
  %type85 = bitcast %struct.atomic_t* %92 to i32*
  %93 = load i32, i32* %type85, align 4
  %call86 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %90, i32 noundef %93) #11
  store %struct.btf_type* %call86, %struct.btf_type** %t, align 8
  %94 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call87 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %94) #11
  br i1 %call87, label %if.end89, label %if.then88

if.then88:                                        ; preds = %if.end84
  store i32 -22, i32* %retval, align 4
  br label %return

if.end89:                                         ; preds = %if.end84
  %95 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %96 = load %struct.btf*, %struct.btf** %btf, align 8
  %97 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %98 = load i8*, i8** %tname, align 8
  %99 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %fmodel = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %99, i32 0, i32 0
  %call90 = call i32 @btf_distill_func_proto(%struct.bpf_verifier_log* noundef %95, %struct.btf* noundef %96, %struct.btf_type* noundef %97, i8* noundef %98, %struct.btf_func_model* noundef %fmodel) #11
  store i32 %call90, i32* %ret, align 4
  %100 = load i32, i32* %ret, align 4
  %tobool91 = icmp ne i32 %100, 0
  br i1 %tobool91, label %if.then92, label %if.end93

if.then92:                                        ; preds = %if.end89
  %101 = load i32, i32* %ret, align 4
  store i32 %101, i32* %retval, align 4
  br label %return

if.end93:                                         ; preds = %if.end89
  br label %sw.epilog190

sw.default:                                       ; preds = %if.end59
  %102 = load i8, i8* %prog_extension, align 1
  %tobool94 = trunc i8 %102 to i1
  br i1 %tobool94, label %if.end96, label %if.then95

if.then95:                                        ; preds = %sw.default
  store i32 -22, i32* %retval, align 4
  br label %return

if.end96:                                         ; preds = %sw.default
  br label %sw.bb97

sw.bb97:                                          ; preds = %if.end96, %if.end59, %if.end59, %if.end59, %if.end59
  %103 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call98 = call zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %103) #11
  br i1 %call98, label %if.end100, label %if.then99

if.then99:                                        ; preds = %sw.bb97
  %104 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %105 = load i32, i32* %btf_id.addr, align 4
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %104, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.19, i64 0, i64 0), i32 noundef %105) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end100:                                        ; preds = %sw.bb97
  %106 = load i8, i8* %prog_extension, align 1
  %tobool101 = trunc i8 %106 to i1
  br i1 %tobool101, label %land.lhs.true102, label %if.end106

land.lhs.true102:                                 ; preds = %if.end100
  %107 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %108 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %109 = load %struct.btf*, %struct.btf** %btf, align 8
  %110 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call103 = call i32 @btf_check_type_match(%struct.bpf_verifier_log* noundef %107, %struct.bpf_prog* noundef %108, %struct.btf* noundef %109, %struct.btf_type* noundef %110) #11
  %tobool104 = icmp ne i32 %call103, 0
  br i1 %tobool104, label %if.then105, label %if.end106

if.then105:                                       ; preds = %land.lhs.true102
  store i32 -22, i32* %retval, align 4
  br label %return

if.end106:                                        ; preds = %land.lhs.true102, %if.end100
  %111 = load %struct.btf*, %struct.btf** %btf, align 8
  %112 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %113 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %112, i32 0, i32 2
  %type107 = bitcast %struct.atomic_t* %113 to i32*
  %114 = load i32, i32* %type107, align 4
  %call108 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %111, i32 noundef %114) #11
  store %struct.btf_type* %call108, %struct.btf_type** %t, align 8
  %115 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call109 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %115) #11
  br i1 %call109, label %if.end111, label %if.then110

if.then110:                                       ; preds = %if.end106
  store i32 -22, i32* %retval, align 4
  br label %return

if.end111:                                        ; preds = %if.end106
  %116 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux112 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %116, i32 0, i32 7
  %117 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux112, align 8
  %saved_dst_prog_type = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %117, i32 0, i32 17
  %118 = load i32, i32* %saved_dst_prog_type, align 8
  %tobool113 = icmp ne i32 %118, 0
  br i1 %tobool113, label %land.lhs.true117, label %lor.lhs.false114

lor.lhs.false114:                                 ; preds = %if.end111
  %119 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux115 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %119, i32 0, i32 7
  %120 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux115, align 8
  %saved_dst_attach_type = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %120, i32 0, i32 18
  %121 = load i32, i32* %saved_dst_attach_type, align 4
  %tobool116 = icmp ne i32 %121, 0
  br i1 %tobool116, label %land.lhs.true117, label %if.end130

land.lhs.true117:                                 ; preds = %lor.lhs.false114, %if.end111
  %122 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool118 = icmp ne %struct.bpf_prog* %122, null
  br i1 %tobool118, label %lor.lhs.false119, label %if.then129

lor.lhs.false119:                                 ; preds = %land.lhs.true117
  %123 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux120 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %123, i32 0, i32 7
  %124 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux120, align 8
  %saved_dst_prog_type121 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %124, i32 0, i32 17
  %125 = load i32, i32* %saved_dst_prog_type121, align 8
  %126 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %type122 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %126, i32 0, i32 2
  %127 = load i32, i32* %type122, align 4
  %cmp123 = icmp ne i32 %125, %127
  br i1 %cmp123, label %if.then129, label %lor.lhs.false124

lor.lhs.false124:                                 ; preds = %lor.lhs.false119
  %128 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux125 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %128, i32 0, i32 7
  %129 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux125, align 8
  %saved_dst_attach_type126 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %129, i32 0, i32 18
  %130 = load i32, i32* %saved_dst_attach_type126, align 4
  %131 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %expected_attach_type127 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %131, i32 0, i32 3
  %132 = load i32, i32* %expected_attach_type127, align 8
  %cmp128 = icmp ne i32 %130, %132
  br i1 %cmp128, label %if.then129, label %if.end130

if.then129:                                       ; preds = %lor.lhs.false124, %lor.lhs.false119, %land.lhs.true117
  store i32 -22, i32* %retval, align 4
  br label %return

if.end130:                                        ; preds = %lor.lhs.false124, %lor.lhs.false114
  %133 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool131 = icmp ne %struct.bpf_prog* %133, null
  br i1 %tobool131, label %land.lhs.true132, label %if.end135

land.lhs.true132:                                 ; preds = %if.end130
  %134 = load i8, i8* %conservative, align 1
  %tobool133 = trunc i8 %134 to i1
  br i1 %tobool133, label %if.then134, label %if.end135

if.then134:                                       ; preds = %land.lhs.true132
  store %struct.btf_type* null, %struct.btf_type** %t, align 8
  br label %if.end135

if.end135:                                        ; preds = %if.then134, %land.lhs.true132, %if.end130
  %135 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %136 = load %struct.btf*, %struct.btf** %btf, align 8
  %137 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %138 = load i8*, i8** %tname, align 8
  %139 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %fmodel136 = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %139, i32 0, i32 0
  %call137 = call i32 @btf_distill_func_proto(%struct.bpf_verifier_log* noundef %135, %struct.btf* noundef %136, %struct.btf_type* noundef %137, i8* noundef %138, %struct.btf_func_model* noundef %fmodel136) #11
  store i32 %call137, i32* %ret, align 4
  %140 = load i32, i32* %ret, align 4
  %cmp138 = icmp slt i32 %140, 0
  br i1 %cmp138, label %if.then139, label %if.end140

if.then139:                                       ; preds = %if.end135
  %141 = load i32, i32* %ret, align 4
  store i32 %141, i32* %retval, align 4
  br label %return

if.end140:                                        ; preds = %if.end135
  %142 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool141 = icmp ne %struct.bpf_prog* %142, null
  br i1 %tobool141, label %if.then142, label %if.else151

if.then142:                                       ; preds = %if.end140
  %143 = load i32, i32* %subprog, align 4
  %cmp143 = icmp eq i32 %143, 0
  br i1 %cmp143, label %if.then144, label %if.else145

if.then144:                                       ; preds = %if.then142
  %144 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %bpf_func = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %144, i32 0, i32 9
  %145 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func, align 8
  %146 = ptrtoint i32 (i8*, %struct.bpf_insn*)* %145 to i64
  store i64 %146, i64* %addr, align 8
  br label %if.end150

if.else145:                                       ; preds = %if.then142
  %147 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %aux146 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %147, i32 0, i32 7
  %148 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux146, align 8
  %func = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %148, i32 0, i32 29
  %149 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %150 = load i32, i32* %subprog, align 4
  %idxprom147 = sext i32 %150 to i64
  %arrayidx148 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %149, i64 %idxprom147
  %151 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx148, align 8
  %bpf_func149 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %151, i32 0, i32 9
  %152 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func149, align 8
  %153 = ptrtoint i32 (i8*, %struct.bpf_insn*)* %152 to i64
  store i64 %153, i64* %addr, align 8
  br label %if.end150

if.end150:                                        ; preds = %if.else145, %if.then144
  br label %if.end156

if.else151:                                       ; preds = %if.end140
  %154 = load i8*, i8** %tname, align 8
  %call152 = call i64 @kallsyms_lookup_name(i8* noundef %154) #11
  store i64 %call152, i64* %addr, align 8
  %155 = load i64, i64* %addr, align 8
  %tobool153 = icmp ne i64 %155, 0
  br i1 %tobool153, label %if.end155, label %if.then154

if.then154:                                       ; preds = %if.else151
  %156 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %157 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %156, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.20, i64 0, i64 0), i8* noundef %157) #11
  store i32 -2, i32* %retval, align 4
  br label %return

if.end155:                                        ; preds = %if.else151
  br label %if.end156

if.end156:                                        ; preds = %if.end155, %if.end150
  %158 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux157 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %158, i32 0, i32 7
  %159 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux157, align 8
  %sleepable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %159, i32 0, i32 23
  %160 = load i8, i8* %sleepable, align 4
  %tobool158 = trunc i8 %160 to i1
  br i1 %tobool158, label %if.then159, label %if.else177

if.then159:                                       ; preds = %if.end156
  store i32 -22, i32* %ret, align 4
  %161 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type160 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %161, i32 0, i32 2
  %162 = load i32, i32* %type160, align 4
  switch i32 %162, label %sw.default173 [
    i32 26, label %sw.bb161
    i32 29, label %sw.bb168
  ]

sw.bb161:                                         ; preds = %if.then159
  %163 = load i32, i32* %btf_id.addr, align 4
  %call162 = call i32 @check_non_sleepable_error_inject(i32 noundef %163) #11
  %tobool163 = icmp ne i32 %call162, 0
  br i1 %tobool163, label %if.end167, label %land.lhs.true164

land.lhs.true164:                                 ; preds = %sw.bb161
  %164 = load i64, i64* %addr, align 8
  %call165 = call zeroext i1 @within_error_injection_list(i64 noundef %164) #11
  br i1 %call165, label %if.then166, label %if.end167

if.then166:                                       ; preds = %land.lhs.true164
  store i32 0, i32* %ret, align 4
  br label %if.end167

if.end167:                                        ; preds = %if.then166, %land.lhs.true164, %sw.bb161
  br label %sw.epilog

sw.bb168:                                         ; preds = %if.then159
  %165 = load i32, i32* %btf_id.addr, align 4
  %call169 = call i32 @check_sleepable_lsm_hook(i32 noundef %165) #11
  %tobool170 = icmp ne i32 %call169, 0
  br i1 %tobool170, label %if.then171, label %if.end172

if.then171:                                       ; preds = %sw.bb168
  store i32 0, i32* %ret, align 4
  br label %if.end172

if.end172:                                        ; preds = %if.then171, %sw.bb168
  br label %sw.epilog

sw.default173:                                    ; preds = %if.then159
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default173, %if.end172, %if.end167
  %166 = load i32, i32* %ret, align 4
  %tobool174 = icmp ne i32 %166, 0
  br i1 %tobool174, label %if.then175, label %if.end176

if.then175:                                       ; preds = %sw.epilog
  %167 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %168 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %167, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.21, i64 0, i64 0), i8* noundef %168) #11
  %169 = load i32, i32* %ret, align 4
  store i32 %169, i32* %retval, align 4
  br label %return

if.end176:                                        ; preds = %sw.epilog
  br label %if.end189

if.else177:                                       ; preds = %if.end156
  %170 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %expected_attach_type178 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %170, i32 0, i32 3
  %171 = load i32, i32* %expected_attach_type178, align 8
  %cmp179 = icmp eq i32 %171, 26
  br i1 %cmp179, label %if.then180, label %if.end188

if.then180:                                       ; preds = %if.else177
  %172 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool181 = icmp ne %struct.bpf_prog* %172, null
  br i1 %tobool181, label %if.then182, label %if.end183

if.then182:                                       ; preds = %if.then180
  %173 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %173, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.22, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end183:                                        ; preds = %if.then180
  %174 = load i64, i64* %addr, align 8
  %175 = load i8*, i8** %tname, align 8
  %call184 = call i32 @check_attach_modify_return(i64 noundef %174, i8* noundef %175) #11
  store i32 %call184, i32* %ret, align 4
  %176 = load i32, i32* %ret, align 4
  %tobool185 = icmp ne i32 %176, 0
  br i1 %tobool185, label %if.then186, label %if.end187

if.then186:                                       ; preds = %if.end183
  %177 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %178 = load i8*, i8** %tname, align 8
  call void (%struct.bpf_verifier_log*, i8*, ...) @bpf_log(%struct.bpf_verifier_log* noundef %177, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.23, i64 0, i64 0), i8* noundef %178) #11
  %179 = load i32, i32* %ret, align 4
  store i32 %179, i32* %retval, align 4
  br label %return

if.end187:                                        ; preds = %if.end183
  br label %if.end188

if.end188:                                        ; preds = %if.end187, %if.else177
  br label %if.end189

if.end189:                                        ; preds = %if.end188, %if.end176
  br label %sw.epilog190

sw.epilog190:                                     ; preds = %if.end189, %if.end93, %if.end80
  %180 = load i64, i64* %addr, align 8
  %181 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %tgt_addr = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %181, i32 0, i32 1
  store i64 %180, i64* %tgt_addr, align 8
  %182 = load i8*, i8** %tname, align 8
  %183 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %tgt_name = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %183, i32 0, i32 2
  store i8* %182, i8** %tgt_name, align 8
  %184 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %185 = load %struct.bpf_attach_target_info*, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %tgt_type = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %185, i32 0, i32 3
  store %struct.btf_type* %184, %struct.btf_type** %tgt_type, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog190, %if.then186, %if.then182, %if.then175, %if.then154, %if.then139, %if.then129, %if.then110, %if.then105, %if.then99, %if.then95, %if.then92, %if.then88, %if.then83, %if.then79, %if.then74, %if.then69, %if.then65, %if.then62, %if.then57, %if.then54, %if.then45, %if.then40, %if.then34, %if.then31, %if.then22, %if.then11, %if.then7, %if.then4, %if.then
  %186 = load i32, i32* %retval, align 4
  ret i32 %186
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_typedef(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 15
  %cmp = icmp eq i32 %and, 8
  ret i1 %cmp
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @strncmp(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_ptr(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 15
  %cmp = icmp eq i32 %and, 2
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 15
  %cmp = icmp eq i32 %and, 13
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 15
  %cmp = icmp eq i32 %and, 12
  ret i1 %cmp
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_distill_func_proto(%struct.bpf_verifier_log* noundef, %struct.btf* noundef, %struct.btf_type* noundef, i8* noundef, %struct.btf_func_model* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_check_type_match(%struct.bpf_verifier_log* noundef, %struct.bpf_prog* noundef, %struct.btf* noundef, %struct.btf_type* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @kallsyms_lookup_name(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_non_sleepable_error_inject(i32 noundef %btf_id) #0 {
entry:
  %btf_id.addr = alloca i32, align 4
  store i32 %btf_id, i32* %btf_id.addr, align 4
  %0 = load i32, i32* %btf_id.addr, align 4
  %call = call zeroext i1 @btf_id_set_contains(%struct.btf_id_set* noundef @btf_non_sleepable_error_inject, i32 noundef %0) #11
  %conv = zext i1 %call to i32
  ret i32 %conv
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @within_error_injection_list(i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_sleepable_lsm_hook(i32 noundef %btf_id) #0 {
entry:
  %btf_id.addr = alloca i32, align 4
  store i32 %btf_id, i32* %btf_id.addr, align 4
  %0 = load i32, i32* %btf_id.addr, align 4
  %call = call zeroext i1 @btf_id_set_contains(%struct.btf_id_set* noundef @btf_sleepable_lsm_hooks, i32 noundef %0) #11
  %conv = zext i1 %call to i32
  ret i32 %conv
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_attach_modify_return(i64 noundef %addr, i8* noundef %func_name) #0 {
entry:
  %retval = alloca i32, align 4
  %addr.addr = alloca i64, align 8
  %func_name.addr = alloca i8*, align 8
  store i64 %addr, i64* %addr.addr, align 8
  store i8* %func_name, i8** %func_name.addr, align 8
  %0 = load i64, i64* %addr.addr, align 8
  %call = call zeroext i1 @within_error_injection_list(i64 noundef %0) #11
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8*, i8** %func_name.addr, align 8
  %call1 = call i32 @strncmp(i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.29, i64 0, i64 0), i8* noundef %1, i64 noundef 9) #11
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @btf_id_set_contains(%struct.btf_id_set* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local %struct.btf* @bpf_get_btf_vmlinux() #0 {
entry:
  %0 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool = icmp ne %struct.btf* %0, null
  br i1 %tobool, label %if.end3, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  br i1 false, label %if.then, label %if.end3

if.then:                                          ; preds = %land.lhs.true
  call void @mutex_lock(%struct.mutex* noundef @bpf_verifier_lock) #11
  %1 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool1 = icmp ne %struct.btf* %1, null
  br i1 %tobool1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  %call = call %struct.btf* @btf_parse_vmlinux() #11
  store %struct.btf* %call, %struct.btf** @btf_vmlinux, align 8
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  call void @mutex_unlock(%struct.mutex* noundef @bpf_verifier_lock) #11
  br label %if.end3

if.end3:                                          ; preds = %if.end, %land.lhs.true, %entry
  %2 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  ret %struct.btf* %2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @mutex_lock(%struct.mutex* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf* @btf_parse_vmlinux() #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @mutex_unlock(%struct.mutex* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define dso_local i32 @bpf_check(%struct.bpf_prog** noundef %prog, %union.bpf_attr* noundef %attr, %union.bpf_attr* noundef %uattr) #0 {
entry:
  %retval = alloca i32, align 4
  %prog.addr = alloca %struct.bpf_prog**, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %uattr.addr = alloca %union.bpf_attr*, align 8
  %start_time = alloca i64, align 8
  %env = alloca %struct.bpf_verifier_env*, align 8
  %log = alloca %struct.bpf_verifier_log*, align 8
  %i = alloca i32, align 4
  %len = alloca i32, align 4
  %ret = alloca i32, align 4
  %is_priv = alloca i8, align 1
  store %struct.bpf_prog** %prog, %struct.bpf_prog*** %prog.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  store %union.bpf_attr* %uattr, %union.bpf_attr** %uattr.addr, align 8
  %call = call i64 @ktime_get_ns() #11
  store i64 %call, i64* %start_time, align 8
  store i32 -22, i32* %ret, align 4
  %call1 = call i8* @kzalloc(i64 noundef 5840, i32 noundef 3264) #11
  %0 = bitcast i8* %call1 to %struct.bpf_verifier_env*
  store %struct.bpf_verifier_env* %0, %struct.bpf_verifier_env** %env, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %tobool = icmp ne %struct.bpf_verifier_env* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 22
  store %struct.bpf_verifier_log* %log2, %struct.bpf_verifier_log** %log, align 8
  %3 = load %struct.bpf_prog**, %struct.bpf_prog*** %prog.addr, align 8
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %3, align 8
  %len3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len3, align 4
  store i32 %5, i32* %len, align 4
  %6 = load i32, i32* %len, align 4
  %conv = sext i32 %6 to i64
  %call4 = call i64 @array_size(i64 noundef 40, i64 noundef %conv) #11
  %call5 = call i8* @vzalloc(i64 noundef %call4) #11
  %7 = bitcast i8* %call5 to %struct.bpf_insn_aux_data*
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 20
  store %struct.bpf_insn_aux_data* %7, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store i32 -12, i32* %ret, align 4
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 20
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data6, align 8
  %tobool7 = icmp ne %struct.bpf_insn_aux_data* %10, null
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  br label %err_free_env

if.end9:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %len, align 4
  %cmp = icmp slt i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32, i32* %i, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 20
  %15 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data11, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %15, i64 %idxprom
  %orig_idx = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 7
  store i32 %13, i32* %orig_idx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load %struct.bpf_prog**, %struct.bpf_prog*** %prog.addr, align 8
  %19 = load %struct.bpf_prog*, %struct.bpf_prog** %18, align 8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 2
  store %struct.bpf_prog* %19, %struct.bpf_prog** %prog12, align 8
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog13 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %21, i32 0, i32 2
  %22 = load %struct.bpf_prog*, %struct.bpf_prog** %prog13, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %22, i32 0, i32 2
  %23 = load i32, i32* %type, align 4
  %idxprom14 = zext i32 %23 to i64
  %arrayidx15 = getelementptr [31 x %struct.bpf_verifier_ops*], [31 x %struct.bpf_verifier_ops*]* @bpf_verifier_ops, i64 0, i64 %idxprom14
  %24 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %arrayidx15, align 8
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 3
  store %struct.bpf_verifier_ops* %24, %struct.bpf_verifier_ops** %ops, align 8
  %call16 = call zeroext i1 @bpf_capable() #11
  %frombool = zext i1 %call16 to i8
  store i8 %frombool, i8* %is_priv, align 1
  %call17 = call %struct.btf* @bpf_get_btf_vmlinux() #11
  %26 = load i8, i8* %is_priv, align 1
  %tobool18 = trunc i8 %26 to i1
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %for.end
  call void @mutex_lock(%struct.mutex* noundef @bpf_verifier_lock) #11
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %for.end
  %27 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %28 = bitcast %union.bpf_attr* %27 to %struct.anon.10*
  %log_level = getelementptr inbounds %struct.anon.10, %struct.anon.10* %28, i32 0, i32 4
  %29 = load i32, i32* %log_level, align 8
  %tobool21 = icmp ne i32 %29, 0
  br i1 %tobool21, label %if.then25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end20
  %30 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %31 = bitcast %union.bpf_attr* %30 to %struct.anon.10*
  %log_buf = getelementptr inbounds %struct.anon.10, %struct.anon.10* %31, i32 0, i32 6
  %32 = load i64, i64* %log_buf, align 8
  %tobool22 = icmp ne i64 %32, 0
  br i1 %tobool22, label %if.then25, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %lor.lhs.false
  %33 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %34 = bitcast %union.bpf_attr* %33 to %struct.anon.10*
  %log_size = getelementptr inbounds %struct.anon.10, %struct.anon.10* %34, i32 0, i32 5
  %35 = load i32, i32* %log_size, align 4
  %tobool24 = icmp ne i32 %35, 0
  br i1 %tobool24, label %if.then25, label %if.end47

if.then25:                                        ; preds = %lor.lhs.false23, %lor.lhs.false, %if.end20
  %36 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %37 = bitcast %union.bpf_attr* %36 to %struct.anon.10*
  %log_level26 = getelementptr inbounds %struct.anon.10, %struct.anon.10* %37, i32 0, i32 4
  %38 = load i32, i32* %log_level26, align 8
  %39 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %39, i32 0, i32 0
  store i32 %38, i32* %level, align 8
  %40 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %41 = bitcast %union.bpf_attr* %40 to %struct.anon.10*
  %log_buf27 = getelementptr inbounds %struct.anon.10, %struct.anon.10* %41, i32 0, i32 6
  %42 = load i64, i64* %log_buf27, align 8
  %43 = inttoptr i64 %42 to i8*
  %44 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %44, i32 0, i32 2
  store i8* %43, i8** %ubuf, align 8
  %45 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %46 = bitcast %union.bpf_attr* %45 to %struct.anon.10*
  %log_size28 = getelementptr inbounds %struct.anon.10, %struct.anon.10* %46, i32 0, i32 5
  %47 = load i32, i32* %log_size28, align 4
  %48 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %len_total = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %48, i32 0, i32 4
  store i32 %47, i32* %len_total, align 4
  store i32 -22, i32* %ret, align 4
  %49 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %len_total29 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %49, i32 0, i32 4
  %50 = load i32, i32* %len_total29, align 4
  %cmp30 = icmp ult i32 %50, 128
  br i1 %cmp30, label %if.then45, label %lor.lhs.false32

lor.lhs.false32:                                  ; preds = %if.then25
  %51 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %len_total33 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %51, i32 0, i32 4
  %52 = load i32, i32* %len_total33, align 4
  %cmp34 = icmp ugt i32 %52, 1073741823
  br i1 %cmp34, label %if.then45, label %lor.lhs.false36

lor.lhs.false36:                                  ; preds = %lor.lhs.false32
  %53 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level37 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %53, i32 0, i32 0
  %54 = load i32, i32* %level37, align 8
  %tobool38 = icmp ne i32 %54, 0
  br i1 %tobool38, label %lor.lhs.false39, label %if.then45

lor.lhs.false39:                                  ; preds = %lor.lhs.false36
  %55 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %ubuf40 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %55, i32 0, i32 2
  %56 = load i8*, i8** %ubuf40, align 8
  %tobool41 = icmp ne i8* %56, null
  br i1 %tobool41, label %lor.lhs.false42, label %if.then45

lor.lhs.false42:                                  ; preds = %lor.lhs.false39
  %57 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level43 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %57, i32 0, i32 0
  %58 = load i32, i32* %level43, align 8
  %and = and i32 %58, -8
  %tobool44 = icmp ne i32 %and, 0
  br i1 %tobool44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %lor.lhs.false42, %lor.lhs.false39, %lor.lhs.false36, %lor.lhs.false32, %if.then25
  br label %err_unlock

if.end46:                                         ; preds = %lor.lhs.false42
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %lor.lhs.false23
  %59 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %60 = bitcast %struct.btf* %59 to i8*
  %call48 = call zeroext i1 @IS_ERR(i8* noundef %60) #11
  br i1 %call48, label %if.then49, label %if.end52

if.then49:                                        ; preds = %if.end47
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %62 = bitcast %struct.bpf_verifier_env* %61 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %62, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.24, i64 0, i64 0)) #11
  %63 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %64 = bitcast %struct.btf* %63 to i8*
  %call50 = call i64 @PTR_ERR(i8* noundef %64) #11
  %conv51 = trunc i64 %call50 to i32
  store i32 %conv51, i32* %ret, align 4
  br label %skip_full_check

if.end52:                                         ; preds = %if.end47
  %65 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %66 = bitcast %union.bpf_attr* %65 to %struct.anon.10*
  %prog_flags = getelementptr inbounds %struct.anon.10, %struct.anon.10* %66, i32 0, i32 8
  %67 = load i32, i32* %prog_flags, align 4
  %and53 = and i32 %67, 1
  %tobool54 = icmp ne i32 %and53, 0
  %lnot = xor i1 %tobool54, true
  %lnot55 = xor i1 %lnot, true
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %strict_alignment = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %68, i32 0, i32 6
  %frombool56 = zext i1 %lnot55 to i8
  store i8 %frombool56, i8* %strict_alignment, align 4
  %69 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %70 = bitcast %union.bpf_attr* %69 to %struct.anon.10*
  %prog_flags57 = getelementptr inbounds %struct.anon.10, %struct.anon.10* %70, i32 0, i32 8
  %71 = load i32, i32* %prog_flags57, align 4
  %and58 = and i32 %71, 2
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %if.then60, label %if.end62

if.then60:                                        ; preds = %if.end52
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %strict_alignment61 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %72, i32 0, i32 6
  store i8 0, i8* %strict_alignment61, align 4
  br label %if.end62

if.end62:                                         ; preds = %if.then60, %if.end52
  %call63 = call zeroext i1 @bpf_allow_ptr_leaks() #11
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %73, i32 0, i32 14
  %frombool64 = zext i1 %call63 to i8
  store i8 %frombool64, i8* %allow_ptr_leaks, align 8
  %call65 = call zeroext i1 @bpf_allow_ptr_to_map_access() #11
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %allow_ptr_to_map_access = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %74, i32 0, i32 15
  %frombool66 = zext i1 %call65 to i8
  store i8 %frombool66, i8* %allow_ptr_to_map_access, align 1
  %call67 = call zeroext i1 @bpf_bypass_spec_v1() #11
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %75, i32 0, i32 17
  %frombool68 = zext i1 %call67 to i8
  store i8 %frombool68, i8* %bypass_spec_v1, align 1
  %call69 = call zeroext i1 @bpf_bypass_spec_v4() #11
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %bypass_spec_v4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %76, i32 0, i32 18
  %frombool70 = zext i1 %call69 to i8
  store i8 %frombool70, i8* %bypass_spec_v4, align 4
  %call71 = call zeroext i1 @bpf_capable() #11
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %77, i32 0, i32 16
  %frombool72 = zext i1 %call71 to i8
  store i8 %frombool72, i8* %bpf_capable, align 2
  %78 = load i8, i8* %is_priv, align 1
  %tobool73 = trunc i8 %78 to i1
  br i1 %tobool73, label %if.then74, label %if.end79

if.then74:                                        ; preds = %if.end62
  %79 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %80 = bitcast %union.bpf_attr* %79 to %struct.anon.10*
  %prog_flags75 = getelementptr inbounds %struct.anon.10, %struct.anon.10* %80, i32 0, i32 8
  %81 = load i32, i32* %prog_flags75, align 4
  %and76 = and i32 %81, 8
  %tobool77 = icmp ne i32 %and76, 0
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %test_state_freq = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %82, i32 0, i32 7
  %frombool78 = zext i1 %tobool77 to i8
  store i8 %frombool78, i8* %test_state_freq, align 1
  br label %if.end79

if.end79:                                         ; preds = %if.then74, %if.end62
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog80 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %83, i32 0, i32 2
  %84 = load %struct.bpf_prog*, %struct.bpf_prog** %prog80, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %84, i32 0, i32 7
  %85 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call81 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %85) #11
  br i1 %call81, label %if.then82, label %if.end88

if.then82:                                        ; preds = %if.end79
  %86 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog83 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %86, i32 0, i32 2
  %87 = load %struct.bpf_prog*, %struct.bpf_prog** %prog83, align 8
  %call84 = call i32 @bpf_prog_offload_verifier_prep(%struct.bpf_prog* noundef %87) #11
  store i32 %call84, i32* %ret, align 4
  %88 = load i32, i32* %ret, align 4
  %tobool85 = icmp ne i32 %88, 0
  br i1 %tobool85, label %if.then86, label %if.end87

if.then86:                                        ; preds = %if.then82
  br label %skip_full_check

if.end87:                                         ; preds = %if.then82
  br label %if.end88

if.end88:                                         ; preds = %if.end87, %if.end79
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call89 = call i32 @state_htab_size(%struct.bpf_verifier_env* noundef %89) #11
  %conv90 = zext i32 %call89 to i64
  %call91 = call i8* @kvcalloc(i64 noundef %conv90, i64 noundef 8, i32 noundef 1051840) #11
  %90 = bitcast i8* %call91 to %struct.bpf_verifier_state_list**
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %explored_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %91, i32 0, i32 9
  store %struct.bpf_verifier_state_list** %90, %struct.bpf_verifier_state_list*** %explored_states, align 8
  store i32 -12, i32* %ret, align 4
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %explored_states92 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %92, i32 0, i32 9
  %93 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states92, align 8
  %tobool93 = icmp ne %struct.bpf_verifier_state_list** %93, null
  br i1 %tobool93, label %if.end95, label %if.then94

if.then94:                                        ; preds = %if.end88
  br label %skip_full_check

if.end95:                                         ; preds = %if.end88
  %94 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call96 = call i32 @check_subprogs(%struct.bpf_verifier_env* noundef %94) #11
  store i32 %call96, i32* %ret, align 4
  %95 = load i32, i32* %ret, align 4
  %cmp97 = icmp slt i32 %95, 0
  br i1 %cmp97, label %if.then99, label %if.end100

if.then99:                                        ; preds = %if.end95
  br label %skip_full_check

if.end100:                                        ; preds = %if.end95
  %96 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %97 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %98 = load %union.bpf_attr*, %union.bpf_attr** %uattr.addr, align 8
  %call101 = call i32 @check_btf_info(%struct.bpf_verifier_env* noundef %96, %union.bpf_attr* noundef %97, %union.bpf_attr* noundef %98) #11
  store i32 %call101, i32* %ret, align 4
  %99 = load i32, i32* %ret, align 4
  %cmp102 = icmp slt i32 %99, 0
  br i1 %cmp102, label %if.then104, label %if.end105

if.then104:                                       ; preds = %if.end100
  br label %skip_full_check

if.end105:                                        ; preds = %if.end100
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call106 = call i32 @check_attach_btf_id(%struct.bpf_verifier_env* noundef %100) #11
  store i32 %call106, i32* %ret, align 4
  %101 = load i32, i32* %ret, align 4
  %tobool107 = icmp ne i32 %101, 0
  br i1 %tobool107, label %if.then108, label %if.end109

if.then108:                                       ; preds = %if.end105
  br label %skip_full_check

if.end109:                                        ; preds = %if.end105
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call110 = call i32 @resolve_pseudo_ldimm64(%struct.bpf_verifier_env* noundef %102) #11
  store i32 %call110, i32* %ret, align 4
  %103 = load i32, i32* %ret, align 4
  %cmp111 = icmp slt i32 %103, 0
  br i1 %cmp111, label %if.then113, label %if.end114

if.then113:                                       ; preds = %if.end109
  br label %skip_full_check

if.end114:                                        ; preds = %if.end109
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call115 = call i32 @check_cfg(%struct.bpf_verifier_env* noundef %104) #11
  store i32 %call115, i32* %ret, align 4
  %105 = load i32, i32* %ret, align 4
  %cmp116 = icmp slt i32 %105, 0
  br i1 %cmp116, label %if.then118, label %if.end119

if.then118:                                       ; preds = %if.end114
  br label %skip_full_check

if.end119:                                        ; preds = %if.end114
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call120 = call i32 @do_check_subprogs(%struct.bpf_verifier_env* noundef %106) #11
  store i32 %call120, i32* %ret, align 4
  %107 = load i32, i32* %ret, align 4
  %tobool121 = icmp ne i32 %107, 0
  br i1 %tobool121, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end119
  br label %cond.end

cond.false:                                       ; preds = %if.end119
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call122 = call i32 @do_check_main(%struct.bpf_verifier_env* noundef %108) #11
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %107, %cond.true ], [ %call122, %cond.false ]
  store i32 %cond, i32* %ret, align 4
  %109 = load i32, i32* %ret, align 4
  %cmp123 = icmp eq i32 %109, 0
  br i1 %cmp123, label %land.lhs.true, label %if.end131

land.lhs.true:                                    ; preds = %cond.end
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog125 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %110, i32 0, i32 2
  %111 = load %struct.bpf_prog*, %struct.bpf_prog** %prog125, align 8
  %aux126 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %111, i32 0, i32 7
  %112 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux126, align 8
  %call127 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %112) #11
  br i1 %call127, label %if.then129, label %if.end131

if.then129:                                       ; preds = %land.lhs.true
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call130 = call i32 @bpf_prog_offload_finalize(%struct.bpf_verifier_env* noundef %113) #11
  store i32 %call130, i32* %ret, align 4
  br label %if.end131

if.end131:                                        ; preds = %if.then129, %land.lhs.true, %cond.end
  br label %skip_full_check

skip_full_check:                                  ; preds = %if.end131, %if.then118, %if.then113, %if.then108, %if.then104, %if.then99, %if.then94, %if.then86, %if.then49
  %114 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %explored_states132 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %114, i32 0, i32 9
  %115 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states132, align 8
  %116 = bitcast %struct.bpf_verifier_state_list** %115 to i8*
  call void @kvfree(i8* noundef %116) #11
  %117 = load i32, i32* %ret, align 4
  %cmp133 = icmp eq i32 %117, 0
  br i1 %cmp133, label %if.then135, label %if.end137

if.then135:                                       ; preds = %skip_full_check
  %118 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call136 = call i32 @check_max_stack_depth(%struct.bpf_verifier_env* noundef %118) #11
  store i32 %call136, i32* %ret, align 4
  br label %if.end137

if.end137:                                        ; preds = %if.then135, %skip_full_check
  %119 = load i8, i8* %is_priv, align 1
  %tobool138 = trunc i8 %119 to i1
  br i1 %tobool138, label %if.then139, label %if.else

if.then139:                                       ; preds = %if.end137
  %120 = load i32, i32* %ret, align 4
  %cmp140 = icmp eq i32 %120, 0
  br i1 %cmp140, label %if.then142, label %if.end143

if.then142:                                       ; preds = %if.then139
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @opt_hard_wire_dead_code_branches(%struct.bpf_verifier_env* noundef %121) #11
  br label %if.end143

if.end143:                                        ; preds = %if.then142, %if.then139
  %122 = load i32, i32* %ret, align 4
  %cmp144 = icmp eq i32 %122, 0
  br i1 %cmp144, label %if.then146, label %if.end148

if.then146:                                       ; preds = %if.end143
  %123 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call147 = call i32 @opt_remove_dead_code(%struct.bpf_verifier_env* noundef %123) #11
  store i32 %call147, i32* %ret, align 4
  br label %if.end148

if.end148:                                        ; preds = %if.then146, %if.end143
  %124 = load i32, i32* %ret, align 4
  %cmp149 = icmp eq i32 %124, 0
  br i1 %cmp149, label %if.then151, label %if.end153

if.then151:                                       ; preds = %if.end148
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call152 = call i32 @opt_remove_nops(%struct.bpf_verifier_env* noundef %125) #11
  store i32 %call152, i32* %ret, align 4
  br label %if.end153

if.end153:                                        ; preds = %if.then151, %if.end148
  br label %if.end158

if.else:                                          ; preds = %if.end137
  %126 = load i32, i32* %ret, align 4
  %cmp154 = icmp eq i32 %126, 0
  br i1 %cmp154, label %if.then156, label %if.end157

if.then156:                                       ; preds = %if.else
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @sanitize_dead_code(%struct.bpf_verifier_env* noundef %127) #11
  br label %if.end157

if.end157:                                        ; preds = %if.then156, %if.else
  br label %if.end158

if.end158:                                        ; preds = %if.end157, %if.end153
  %128 = load i32, i32* %ret, align 4
  %cmp159 = icmp eq i32 %128, 0
  br i1 %cmp159, label %if.then161, label %if.end163

if.then161:                                       ; preds = %if.end158
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call162 = call i32 @convert_ctx_accesses(%struct.bpf_verifier_env* noundef %129) #11
  store i32 %call162, i32* %ret, align 4
  br label %if.end163

if.end163:                                        ; preds = %if.then161, %if.end158
  %130 = load i32, i32* %ret, align 4
  %cmp164 = icmp eq i32 %130, 0
  br i1 %cmp164, label %if.then166, label %if.end168

if.then166:                                       ; preds = %if.end163
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call167 = call i32 @fixup_bpf_calls(%struct.bpf_verifier_env* noundef %131) #11
  store i32 %call167, i32* %ret, align 4
  br label %if.end168

if.end168:                                        ; preds = %if.then166, %if.end163
  %132 = load i32, i32* %ret, align 4
  %cmp169 = icmp eq i32 %132, 0
  br i1 %cmp169, label %land.lhs.true171, label %if.end189

land.lhs.true171:                                 ; preds = %if.end168
  %133 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog172 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %133, i32 0, i32 2
  %134 = load %struct.bpf_prog*, %struct.bpf_prog** %prog172, align 8
  %aux173 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %134, i32 0, i32 7
  %135 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux173, align 8
  %call174 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %135) #11
  br i1 %call174, label %if.end189, label %if.then175

if.then175:                                       ; preds = %land.lhs.true171
  %136 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %137 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %call176 = call i32 @opt_subreg_zext_lo32_rnd_hi32(%struct.bpf_verifier_env* noundef %136, %union.bpf_attr* noundef %137) #11
  store i32 %call176, i32* %ret, align 4
  %call177 = call zeroext i1 @bpf_jit_needs_zext() #11
  br i1 %call177, label %cond.true179, label %cond.false182

cond.true179:                                     ; preds = %if.then175
  %138 = load i32, i32* %ret, align 4
  %tobool180 = icmp ne i32 %138, 0
  %lnot181 = xor i1 %tobool180, true
  %lnot.ext = zext i1 %lnot181 to i32
  br label %cond.end183

cond.false182:                                    ; preds = %if.then175
  br label %cond.end183

cond.end183:                                      ; preds = %cond.false182, %cond.true179
  %cond184 = phi i32 [ %lnot.ext, %cond.true179 ], [ 0, %cond.false182 ]
  %tobool185 = icmp ne i32 %cond184, 0
  %139 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog186 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %139, i32 0, i32 2
  %140 = load %struct.bpf_prog*, %struct.bpf_prog** %prog186, align 8
  %aux187 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %140, i32 0, i32 7
  %141 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux187, align 8
  %verifier_zext = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %141, i32 0, i32 19
  %frombool188 = zext i1 %tobool185 to i8
  store i8 %frombool188, i8* %verifier_zext, align 8
  br label %if.end189

if.end189:                                        ; preds = %cond.end183, %land.lhs.true171, %if.end168
  %142 = load i32, i32* %ret, align 4
  %cmp190 = icmp eq i32 %142, 0
  br i1 %cmp190, label %if.then192, label %if.end194

if.then192:                                       ; preds = %if.end189
  %143 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %call193 = call i32 @fixup_call_args(%struct.bpf_verifier_env* noundef %143) #11
  store i32 %call193, i32* %ret, align 4
  br label %if.end194

if.end194:                                        ; preds = %if.then192, %if.end189
  %call195 = call i64 @ktime_get_ns() #11
  %144 = load i64, i64* %start_time, align 8
  %sub = sub i64 %call195, %144
  %145 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %verification_time = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %145, i32 0, i32 31
  store i64 %sub, i64* %verification_time, align 8
  %146 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @print_verification_stats(%struct.bpf_verifier_env* noundef %146) #11
  %147 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level196 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %147, i32 0, i32 0
  %148 = load i32, i32* %level196, align 8
  %tobool197 = icmp ne i32 %148, 0
  br i1 %tobool197, label %land.lhs.true198, label %if.end202

land.lhs.true198:                                 ; preds = %if.end194
  %149 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %call199 = call zeroext i1 @bpf_verifier_log_full(%struct.bpf_verifier_log* noundef %149) #11
  br i1 %call199, label %if.then201, label %if.end202

if.then201:                                       ; preds = %land.lhs.true198
  store i32 -28, i32* %ret, align 4
  br label %if.end202

if.end202:                                        ; preds = %if.then201, %land.lhs.true198, %if.end194
  %150 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %level203 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %150, i32 0, i32 0
  %151 = load i32, i32* %level203, align 8
  %tobool204 = icmp ne i32 %151, 0
  br i1 %tobool204, label %land.lhs.true205, label %if.end209

land.lhs.true205:                                 ; preds = %if.end202
  %152 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log, align 8
  %ubuf206 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %152, i32 0, i32 2
  %153 = load i8*, i8** %ubuf206, align 8
  %tobool207 = icmp ne i8* %153, null
  br i1 %tobool207, label %if.end209, label %if.then208

if.then208:                                       ; preds = %land.lhs.true205
  store i32 -14, i32* %ret, align 4
  br label %err_release_maps

if.end209:                                        ; preds = %land.lhs.true205, %if.end202
  %154 = load i32, i32* %ret, align 4
  %cmp210 = icmp eq i32 %154, 0
  br i1 %cmp210, label %land.lhs.true212, label %if.end236

land.lhs.true212:                                 ; preds = %if.end209
  %155 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %155, i32 0, i32 12
  %156 = load i32, i32* %used_map_cnt, align 8
  %tobool213 = icmp ne i32 %156, 0
  br i1 %tobool213, label %if.then214, label %if.end236

if.then214:                                       ; preds = %land.lhs.true212
  %157 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt215 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %157, i32 0, i32 12
  %158 = load i32, i32* %used_map_cnt215, align 8
  %conv216 = zext i32 %158 to i64
  %call217 = call i8* @kmalloc_array(i64 noundef %conv216, i64 noundef 8, i32 noundef 3264) #11
  %159 = bitcast i8* %call217 to %struct.bpf_map**
  %160 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog218 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %160, i32 0, i32 2
  %161 = load %struct.bpf_prog*, %struct.bpf_prog** %prog218, align 8
  %aux219 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %161, i32 0, i32 7
  %162 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux219, align 8
  %used_maps = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %162, i32 0, i32 35
  store %struct.bpf_map** %159, %struct.bpf_map*** %used_maps, align 8
  %163 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog220 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %163, i32 0, i32 2
  %164 = load %struct.bpf_prog*, %struct.bpf_prog** %prog220, align 8
  %aux221 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %164, i32 0, i32 7
  %165 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux221, align 8
  %used_maps222 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %165, i32 0, i32 35
  %166 = load %struct.bpf_map**, %struct.bpf_map*** %used_maps222, align 8
  %tobool223 = icmp ne %struct.bpf_map** %166, null
  br i1 %tobool223, label %if.end225, label %if.then224

if.then224:                                       ; preds = %if.then214
  store i32 -12, i32* %ret, align 4
  br label %err_release_maps

if.end225:                                        ; preds = %if.then214
  %167 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog226 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %167, i32 0, i32 2
  %168 = load %struct.bpf_prog*, %struct.bpf_prog** %prog226, align 8
  %aux227 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %168, i32 0, i32 7
  %169 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux227, align 8
  %used_maps228 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %169, i32 0, i32 35
  %170 = load %struct.bpf_map**, %struct.bpf_map*** %used_maps228, align 8
  %171 = bitcast %struct.bpf_map** %170 to i8*
  %172 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_maps229 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %172, i32 0, i32 11
  %arraydecay = getelementptr inbounds [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps229, i64 0, i64 0
  %173 = bitcast %struct.bpf_map** %arraydecay to i8*
  %174 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt230 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %174, i32 0, i32 12
  %175 = load i32, i32* %used_map_cnt230, align 8
  %conv231 = zext i32 %175 to i64
  %mul = mul i64 8, %conv231
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %171, i8* align 8 %173, i64 %mul, i1 false)
  %176 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %used_map_cnt232 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %176, i32 0, i32 12
  %177 = load i32, i32* %used_map_cnt232, align 8
  %178 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog233 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %178, i32 0, i32 2
  %179 = load %struct.bpf_prog*, %struct.bpf_prog** %prog233, align 8
  %aux234 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %179, i32 0, i32 7
  %180 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux234, align 8
  %used_map_cnt235 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %180, i32 0, i32 1
  store i32 %177, i32* %used_map_cnt235, align 8
  %181 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @convert_pseudo_ld_imm64(%struct.bpf_verifier_env* noundef %181) #11
  br label %if.end236

if.end236:                                        ; preds = %if.end225, %land.lhs.true212, %if.end209
  %182 = load i32, i32* %ret, align 4
  %cmp237 = icmp eq i32 %182, 0
  br i1 %cmp237, label %if.then239, label %if.end240

if.then239:                                       ; preds = %if.end236
  %183 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @adjust_btf_func(%struct.bpf_verifier_env* noundef %183) #11
  br label %if.end240

if.end240:                                        ; preds = %if.then239, %if.end236
  br label %err_release_maps

err_release_maps:                                 ; preds = %if.end240, %if.then224, %if.then208
  %184 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog241 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %184, i32 0, i32 2
  %185 = load %struct.bpf_prog*, %struct.bpf_prog** %prog241, align 8
  %aux242 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %185, i32 0, i32 7
  %186 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux242, align 8
  %used_maps243 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %186, i32 0, i32 35
  %187 = load %struct.bpf_map**, %struct.bpf_map*** %used_maps243, align 8
  %tobool244 = icmp ne %struct.bpf_map** %187, null
  br i1 %tobool244, label %if.end246, label %if.then245

if.then245:                                       ; preds = %err_release_maps
  %188 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  call void @release_maps(%struct.bpf_verifier_env* noundef %188) #11
  br label %if.end246

if.end246:                                        ; preds = %if.then245, %err_release_maps
  %189 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog247 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %189, i32 0, i32 2
  %190 = load %struct.bpf_prog*, %struct.bpf_prog** %prog247, align 8
  %type248 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %190, i32 0, i32 2
  %191 = load i32, i32* %type248, align 4
  %cmp249 = icmp eq i32 %191, 28
  br i1 %cmp249, label %if.then251, label %if.end253

if.then251:                                       ; preds = %if.end246
  %192 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog252 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %192, i32 0, i32 2
  %193 = load %struct.bpf_prog*, %struct.bpf_prog** %prog252, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %193, i32 0, i32 3
  store i32 0, i32* %expected_attach_type, align 8
  br label %if.end253

if.end253:                                        ; preds = %if.then251, %if.end246
  %194 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %prog254 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %194, i32 0, i32 2
  %195 = load %struct.bpf_prog*, %struct.bpf_prog** %prog254, align 8
  %196 = load %struct.bpf_prog**, %struct.bpf_prog*** %prog.addr, align 8
  store %struct.bpf_prog* %195, %struct.bpf_prog** %196, align 8
  br label %err_unlock

err_unlock:                                       ; preds = %if.end253, %if.then45
  %197 = load i8, i8* %is_priv, align 1
  %tobool255 = trunc i8 %197 to i1
  br i1 %tobool255, label %if.end257, label %if.then256

if.then256:                                       ; preds = %err_unlock
  call void @mutex_unlock(%struct.mutex* noundef @bpf_verifier_lock) #11
  br label %if.end257

if.end257:                                        ; preds = %if.then256, %err_unlock
  %198 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %insn_aux_data258 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %198, i32 0, i32 20
  %199 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data258, align 8
  %200 = bitcast %struct.bpf_insn_aux_data* %199 to i8*
  call void @vfree(i8* noundef %200) #11
  br label %err_free_env

err_free_env:                                     ; preds = %if.end257, %if.then8
  %201 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env, align 8
  %202 = bitcast %struct.bpf_verifier_env* %201 to i8*
  call void @kfree(i8* noundef %202) #11
  %203 = load i32, i32* %ret, align 4
  store i32 %203, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free_env, %if.then
  %204 = load i32, i32* %retval, align 4
  ret i32 %204
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @ktime_get_ns() #0 {
entry:
  %call = call i64 @ktime_get() #11
  %call1 = call i64 @ktime_to_ns(i64 noundef %call) #11
  ret i64 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kzalloc(i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %retval.i11 = alloca i32, align 4
  %flags.addr.i12 = alloca i32, align 4
  %retval.i4 = alloca i32, align 4
  %size.addr.i5 = alloca i64, align 8
  %size.addr.i1 = alloca i64, align 8
  %flags.addr.i2 = alloca i32, align 4
  %order.i = alloca i32, align 4
  %retval.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %index.i = alloca i32, align 4
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %size.addr, align 8
  %1 = load i32, i32* %flags.addr, align 4
  %or = or i32 %1, 256
  store i64 %0, i64* %size.addr.i, align 8
  store i32 %or, i32* %flags.addr.i, align 4
  %2 = load i64, i64* %size.addr.i, align 8
  %3 = call i1 @llvm.is.constant.i64(i64 %2) #10
  br i1 %3, label %if.then.i, label %if.end9.i

if.then.i:                                        ; preds = %entry
  %4 = load i64, i64* %size.addr.i, align 8
  %cmp.i = icmp ugt i64 %4, 8192
  br i1 %cmp.i, label %if.then1.i, label %if.end.i

if.then1.i:                                       ; preds = %if.then.i
  %5 = load i64, i64* %size.addr.i, align 8
  %6 = load i32, i32* %flags.addr.i, align 4
  store i64 %5, i64* %size.addr.i1, align 8
  store i32 %6, i32* %flags.addr.i2, align 4
  %7 = load i64, i64* %size.addr.i1, align 8
  %call.i3 = call i32 @get_order(i64 noundef %7) #14
  store i32 %call.i3, i32* %order.i, align 4
  %8 = load i64, i64* %size.addr.i1, align 8
  %9 = load i32, i32* %flags.addr.i2, align 4
  %10 = load i32, i32* %order.i, align 4
  %call1.i = call noalias align 4096 i8* @kmalloc_order_trace(i64 noundef %8, i32 noundef %9, i32 noundef %10) #13
  store i8* %call1.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end.i:                                         ; preds = %if.then.i
  %11 = load i64, i64* %size.addr.i, align 8
  store i64 %11, i64* %size.addr.i5, align 8
  %12 = load i64, i64* %size.addr.i5, align 8
  %tobool.i6 = icmp ne i64 %12, 0
  br i1 %tobool.i6, label %if.end.i9, label %if.then.i7

if.then.i7:                                       ; preds = %if.end.i
  store i32 0, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end.i9:                                        ; preds = %if.end.i
  %13 = load i64, i64* %size.addr.i5, align 8
  %cmp.i8 = icmp ule i64 %13, 8
  br i1 %cmp.i8, label %if.then1.i10, label %if.end2.i

if.then1.i10:                                     ; preds = %if.end.i9
  store i32 3, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end2.i:                                        ; preds = %if.end.i9
  %14 = load i64, i64* %size.addr.i5, align 8
  %cmp3.i = icmp ugt i64 %14, 64
  br i1 %cmp3.i, label %land.lhs.true.i, label %if.end6.i

land.lhs.true.i:                                  ; preds = %if.end2.i
  %15 = load i64, i64* %size.addr.i5, align 8
  %cmp4.i = icmp ule i64 %15, 96
  br i1 %cmp4.i, label %if.then5.i, label %if.end6.i

if.then5.i:                                       ; preds = %land.lhs.true.i
  store i32 1, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end6.i:                                        ; preds = %land.lhs.true.i, %if.end2.i
  %16 = load i64, i64* %size.addr.i5, align 8
  %cmp7.i = icmp ugt i64 %16, 128
  br i1 %cmp7.i, label %land.lhs.true8.i, label %if.end11.i

land.lhs.true8.i:                                 ; preds = %if.end6.i
  %17 = load i64, i64* %size.addr.i5, align 8
  %cmp9.i = icmp ule i64 %17, 192
  br i1 %cmp9.i, label %if.then10.i, label %if.end11.i

if.then10.i:                                      ; preds = %land.lhs.true8.i
  store i32 2, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end11.i:                                       ; preds = %land.lhs.true8.i, %if.end6.i
  %18 = load i64, i64* %size.addr.i5, align 8
  %cmp12.i = icmp ule i64 %18, 8
  br i1 %cmp12.i, label %if.then13.i, label %if.end14.i

if.then13.i:                                      ; preds = %if.end11.i
  store i32 3, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end14.i:                                       ; preds = %if.end11.i
  %19 = load i64, i64* %size.addr.i5, align 8
  %cmp15.i = icmp ule i64 %19, 16
  br i1 %cmp15.i, label %if.then16.i, label %if.end17.i

if.then16.i:                                      ; preds = %if.end14.i
  store i32 4, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end17.i:                                       ; preds = %if.end14.i
  %20 = load i64, i64* %size.addr.i5, align 8
  %cmp18.i = icmp ule i64 %20, 32
  br i1 %cmp18.i, label %if.then19.i, label %if.end20.i

if.then19.i:                                      ; preds = %if.end17.i
  store i32 5, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end20.i:                                       ; preds = %if.end17.i
  %21 = load i64, i64* %size.addr.i5, align 8
  %cmp21.i = icmp ule i64 %21, 64
  br i1 %cmp21.i, label %if.then22.i, label %if.end23.i

if.then22.i:                                      ; preds = %if.end20.i
  store i32 6, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end23.i:                                       ; preds = %if.end20.i
  %22 = load i64, i64* %size.addr.i5, align 8
  %cmp24.i = icmp ule i64 %22, 128
  br i1 %cmp24.i, label %if.then25.i, label %if.end26.i

if.then25.i:                                      ; preds = %if.end23.i
  store i32 7, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end26.i:                                       ; preds = %if.end23.i
  %23 = load i64, i64* %size.addr.i5, align 8
  %cmp27.i = icmp ule i64 %23, 256
  br i1 %cmp27.i, label %if.then28.i, label %if.end29.i

if.then28.i:                                      ; preds = %if.end26.i
  store i32 8, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end29.i:                                       ; preds = %if.end26.i
  %24 = load i64, i64* %size.addr.i5, align 8
  %cmp30.i = icmp ule i64 %24, 512
  br i1 %cmp30.i, label %if.then31.i, label %if.end32.i

if.then31.i:                                      ; preds = %if.end29.i
  store i32 9, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end32.i:                                       ; preds = %if.end29.i
  %25 = load i64, i64* %size.addr.i5, align 8
  %cmp33.i = icmp ule i64 %25, 1024
  br i1 %cmp33.i, label %if.then34.i, label %if.end35.i

if.then34.i:                                      ; preds = %if.end32.i
  store i32 10, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end35.i:                                       ; preds = %if.end32.i
  %26 = load i64, i64* %size.addr.i5, align 8
  %cmp36.i = icmp ule i64 %26, 2048
  br i1 %cmp36.i, label %if.then37.i, label %if.end38.i

if.then37.i:                                      ; preds = %if.end35.i
  store i32 11, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end38.i:                                       ; preds = %if.end35.i
  %27 = load i64, i64* %size.addr.i5, align 8
  %cmp39.i = icmp ule i64 %27, 4096
  br i1 %cmp39.i, label %if.then40.i, label %if.end41.i

if.then40.i:                                      ; preds = %if.end38.i
  store i32 12, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end41.i:                                       ; preds = %if.end38.i
  %28 = load i64, i64* %size.addr.i5, align 8
  %cmp42.i = icmp ule i64 %28, 8192
  br i1 %cmp42.i, label %if.then43.i, label %if.end44.i

if.then43.i:                                      ; preds = %if.end41.i
  store i32 13, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end44.i:                                       ; preds = %if.end41.i
  %29 = load i64, i64* %size.addr.i5, align 8
  %cmp45.i = icmp ule i64 %29, 16384
  br i1 %cmp45.i, label %if.then46.i, label %if.end47.i

if.then46.i:                                      ; preds = %if.end44.i
  store i32 14, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end47.i:                                       ; preds = %if.end44.i
  %30 = load i64, i64* %size.addr.i5, align 8
  %cmp48.i = icmp ule i64 %30, 32768
  br i1 %cmp48.i, label %if.then49.i, label %if.end50.i

if.then49.i:                                      ; preds = %if.end47.i
  store i32 15, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end50.i:                                       ; preds = %if.end47.i
  %31 = load i64, i64* %size.addr.i5, align 8
  %cmp51.i = icmp ule i64 %31, 65536
  br i1 %cmp51.i, label %if.then52.i, label %if.end53.i

if.then52.i:                                      ; preds = %if.end50.i
  store i32 16, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end53.i:                                       ; preds = %if.end50.i
  %32 = load i64, i64* %size.addr.i5, align 8
  %cmp54.i = icmp ule i64 %32, 131072
  br i1 %cmp54.i, label %if.then55.i, label %if.end56.i

if.then55.i:                                      ; preds = %if.end53.i
  store i32 17, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end56.i:                                       ; preds = %if.end53.i
  %33 = load i64, i64* %size.addr.i5, align 8
  %cmp57.i = icmp ule i64 %33, 262144
  br i1 %cmp57.i, label %if.then58.i, label %if.end59.i

if.then58.i:                                      ; preds = %if.end56.i
  store i32 18, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end59.i:                                       ; preds = %if.end56.i
  %34 = load i64, i64* %size.addr.i5, align 8
  %cmp60.i = icmp ule i64 %34, 524288
  br i1 %cmp60.i, label %if.then61.i, label %if.end62.i

if.then61.i:                                      ; preds = %if.end59.i
  store i32 19, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end62.i:                                       ; preds = %if.end59.i
  %35 = load i64, i64* %size.addr.i5, align 8
  %cmp63.i = icmp ule i64 %35, 1048576
  br i1 %cmp63.i, label %if.then64.i, label %if.end65.i

if.then64.i:                                      ; preds = %if.end62.i
  store i32 20, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end65.i:                                       ; preds = %if.end62.i
  %36 = load i64, i64* %size.addr.i5, align 8
  %cmp66.i = icmp ule i64 %36, 2097152
  br i1 %cmp66.i, label %if.then67.i, label %if.end68.i

if.then67.i:                                      ; preds = %if.end65.i
  store i32 21, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end68.i:                                       ; preds = %if.end65.i
  %37 = load i64, i64* %size.addr.i5, align 8
  %cmp69.i = icmp ule i64 %37, 4194304
  br i1 %cmp69.i, label %if.then70.i, label %if.end71.i

if.then70.i:                                      ; preds = %if.end68.i
  store i32 22, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end71.i:                                       ; preds = %if.end68.i
  %38 = load i64, i64* %size.addr.i5, align 8
  %cmp72.i = icmp ule i64 %38, 8388608
  br i1 %cmp72.i, label %if.then73.i, label %if.end74.i

if.then73.i:                                      ; preds = %if.end71.i
  store i32 23, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end74.i:                                       ; preds = %if.end71.i
  %39 = load i64, i64* %size.addr.i5, align 8
  %cmp75.i = icmp ule i64 %39, 16777216
  br i1 %cmp75.i, label %if.then76.i, label %if.end77.i

if.then76.i:                                      ; preds = %if.end74.i
  store i32 24, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end77.i:                                       ; preds = %if.end74.i
  %40 = load i64, i64* %size.addr.i5, align 8
  %cmp78.i = icmp ule i64 %40, 33554432
  br i1 %cmp78.i, label %if.then79.i, label %if.end80.i

if.then79.i:                                      ; preds = %if.end77.i
  store i32 25, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end80.i:                                       ; preds = %if.end77.i
  %41 = load i64, i64* %size.addr.i5, align 8
  %cmp81.i = icmp ule i64 %41, 67108864
  br i1 %cmp81.i, label %if.then82.i, label %if.end83.i

if.then82.i:                                      ; preds = %if.end80.i
  store i32 26, i32* %retval.i4, align 4
  br label %kmalloc_index.exit

if.end83.i:                                       ; preds = %if.end80.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.30, i64 0, i64 0), i32 382, i32 0, i64 12) #10, !srcloc !12
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.unreachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 81) #10, !srcloc !13
  unreachable

kmalloc_index.exit:                               ; preds = %if.then82.i, %if.then79.i, %if.then76.i, %if.then73.i, %if.then70.i, %if.then67.i, %if.then64.i, %if.then61.i, %if.then58.i, %if.then55.i, %if.then52.i, %if.then49.i, %if.then46.i, %if.then43.i, %if.then40.i, %if.then37.i, %if.then34.i, %if.then31.i, %if.then28.i, %if.then25.i, %if.then22.i, %if.then19.i, %if.then16.i, %if.then13.i, %if.then10.i, %if.then5.i, %if.then1.i10, %if.then.i7
  %42 = load i32, i32* %retval.i4, align 4
  store i32 %42, i32* %index.i, align 4
  %43 = load i32, i32* %index.i, align 4
  %tobool.i = icmp ne i32 %43, 0
  br i1 %tobool.i, label %if.end4.i, label %if.then3.i

if.then3.i:                                       ; preds = %kmalloc_index.exit
  store i8* inttoptr (i64 16 to i8*), i8** %retval.i, align 8
  br label %kmalloc.exit

if.end4.i:                                        ; preds = %kmalloc_index.exit
  %44 = load i32, i32* %flags.addr.i, align 4
  store i32 %44, i32* %flags.addr.i12, align 4
  %45 = load i32, i32* %flags.addr.i12, align 4
  %and.i = and i32 %45, 17
  %cmp.i13 = icmp eq i32 %and.i, 0
  %lnot.i = xor i1 %cmp.i13, true
  %lnot.ext.i = zext i1 %cmp.i13 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %cmp.i13, label %if.then.i14, label %if.end.i15

if.then.i14:                                      ; preds = %if.end4.i
  store i32 0, i32* %retval.i11, align 4
  br label %kmalloc_type.exit

if.end.i15:                                       ; preds = %if.end4.i
  %46 = load i32, i32* %flags.addr.i12, align 4
  %and2.i = and i32 %46, 1
  %tobool3.i = icmp ne i32 %and2.i, 0
  %47 = zext i1 %tobool3.i to i64
  %cond.i = select i1 %tobool3.i, i32 2, i32 1
  store i32 %cond.i, i32* %retval.i11, align 4
  br label %kmalloc_type.exit

kmalloc_type.exit:                                ; preds = %if.end.i15, %if.then.i14
  %48 = load i32, i32* %retval.i11, align 4
  %idxprom.i = zext i32 %48 to i64
  %arrayidx.i = getelementptr [3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 %idxprom.i
  %49 = load i32, i32* %index.i, align 4
  %idxprom6.i = zext i32 %49 to i64
  %arrayidx7.i = getelementptr [14 x %struct.kmem_cache*], [14 x %struct.kmem_cache*]* %arrayidx.i, i64 0, i64 %idxprom6.i
  %50 = load %struct.kmem_cache*, %struct.kmem_cache** %arrayidx7.i, align 8
  %51 = load i32, i32* %flags.addr.i, align 4
  %52 = load i64, i64* %size.addr.i, align 8
  %call8.i = call noalias align 8 i8* @kmem_cache_alloc_trace(%struct.kmem_cache* noundef %50, i32 noundef %51, i64 noundef %52) #13
  store i8* %call8.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end9.i:                                        ; preds = %entry
  %53 = load i64, i64* %size.addr.i, align 8
  %54 = load i32, i32* %flags.addr.i, align 4
  %call10.i = call noalias align 8 i8* @__kmalloc(i64 noundef %53, i32 noundef %54) #13
  store i8* %call10.i, i8** %retval.i, align 8
  br label %kmalloc.exit

kmalloc.exit:                                     ; preds = %if.end9.i, %kmalloc_type.exit, %if.then3.i, %if.then1.i
  %55 = load i8*, i8** %retval.i, align 8
  ret i8* %55
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @array_size(i64 noundef %a, i64 noundef %b) #0 {
entry:
  %retval = alloca i64, align 8
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %bytes = alloca i64, align 8
  %__a = alloca i64, align 8
  %__b = alloca i64, align 8
  %__d = alloca i64*, align 8
  %tmp = alloca i8, align 1
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  store i64 %0, i64* %__a, align 8
  %1 = load i64, i64* %b.addr, align 8
  store i64 %1, i64* %__b, align 8
  store i64* %bytes, i64** %__d, align 8
  %cmp = icmp eq i64* %__a, %__b
  %conv = zext i1 %cmp to i32
  %2 = load i64*, i64** %__d, align 8
  %cmp1 = icmp eq i64* %__a, %2
  %conv2 = zext i1 %cmp1 to i32
  %3 = load i64, i64* %__a, align 8
  %4 = load i64, i64* %__b, align 8
  %5 = load i64*, i64** %__d, align 8
  %6 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %3, i64 %4)
  %7 = extractvalue { i64, i1 } %6, 1
  %8 = extractvalue { i64, i1 } %6, 0
  store i64 %8, i64* %5, align 8
  %frombool = zext i1 %7 to i8
  store i8 %frombool, i8* %tmp, align 1
  %9 = load i8, i8* %tmp, align 1
  %tobool = trunc i8 %9 to i1
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %tobool) #11
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 -1, i64* %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %bytes, align 8
  store i64 %10, i64* %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i64, i64* %retval, align 8
  ret i64 %11
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @vzalloc(i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_capable() #0 {
entry:
  %call = call zeroext i1 @capable(i32 noundef 39) #11
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %call1 = call zeroext i1 @capable(i32 noundef 21) #11
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %call1, %lor.rhs ]
  ret i1 %0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @IS_ERR(i8* noundef %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  %2 = inttoptr i64 %1 to i8*
  %3 = ptrtoint i8* %2 to i64
  %cmp = icmp uge i64 %3, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @PTR_ERR(i8* noundef %ptr) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %1 = ptrtoint i8* %0 to i64
  ret i64 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_allow_ptr_leaks() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #11
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_allow_ptr_to_map_access() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #11
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_bypass_spec_v1() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #11
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_bypass_spec_v4() #0 {
entry:
  %call = call zeroext i1 @perfmon_capable() #11
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_prog_aux*, align 8
  store %struct.bpf_prog_aux* %aux, %struct.bpf_prog_aux** %aux.addr, align 8
  %0 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux.addr, align 8
  %offload_requested = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %0, i32 0, i32 20
  %1 = load i8, i8* %offload_requested, align 1
  %tobool = trunc i8 %1 to i1
  ret i1 %tobool
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_offload_verifier_prep(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @state_htab_size(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 4
  %2 = load i32, i32* %len, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kvcalloc(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  %1 = load i64, i64* %size.addr, align 8
  %2 = load i32, i32* %flags.addr, align 4
  %or = or i32 %2, 256
  %call = call i8* @kvmalloc_array(i64 noundef %0, i64 noundef %1, i32 noundef %or) #11
  ret i8* %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %subprog_start = alloca i32, align 4
  %subprog_end = alloca i32, align 4
  %off = alloca i32, align 4
  %cur_subprog = alloca i32, align 4
  %subprog = alloca %struct.bpf_subprog_info*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %code52 = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 0, i32* %cur_subprog, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 23
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %subprog, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 11
  %arraydecay1 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay1, %struct.bpf_insn** %insn, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len, align 4
  store i32 %5, i32* %insn_cnt, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @add_subprog(%struct.bpf_verifier_env* noundef %6, i32 noundef 0) #11
  store i32 %call, i32* %ret, align 4
  %7 = load i32, i32* %ret, align 4
  %cmp = icmp slt i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load i32, i32* %ret, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %insn_cnt, align 4
  %cmp3 = icmp slt i32 %9, %10
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %11, i64 %idxprom
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 0
  %13 = load i8, i8* %code, align 4
  %conv = zext i8 %13 to i32
  %cmp4 = icmp ne i32 %conv, 133
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  br label %for.inc

if.end7:                                          ; preds = %for.body
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom8 = sext i32 %15 to i64
  %arrayidx9 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %14, i64 %idxprom8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx9, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv10 = zext i8 %bf.lshr to i32
  %cmp11 = icmp ne i32 %conv10, 1
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end7
  br label %for.inc

if.end14:                                         ; preds = %if.end7
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 16
  %17 = load i8, i8* %bpf_capable, align 2
  %tobool = trunc i8 %17 to i1
  br i1 %tobool, label %if.end16, label %if.then15

if.then15:                                        ; preds = %if.end14
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([81 x i8], [81 x i8]* @.str.31, i64 0, i64 0)) #11
  store i32 -1, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end14
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = load i32, i32* %i, align 4
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %23 = load i32, i32* %i, align 4
  %idxprom17 = sext i32 %23 to i64
  %arrayidx18 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %22, i64 %idxprom17
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx18, i32 0, i32 3
  %24 = load i32, i32* %imm, align 4
  %add = add i32 %21, %24
  %add19 = add i32 %add, 1
  %call20 = call i32 @add_subprog(%struct.bpf_verifier_env* noundef %20, i32 noundef %add19) #11
  store i32 %call20, i32* %ret, align 4
  %25 = load i32, i32* %ret, align 4
  %cmp21 = icmp slt i32 %25, 0
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end16
  %26 = load i32, i32* %ret, align 4
  store i32 %26, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end16
  br label %for.inc

for.inc:                                          ; preds = %if.end24, %if.then13, %if.then6
  %27 = load i32, i32* %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %28 = load i32, i32* %insn_cnt, align 4
  %29 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 26
  %31 = load i32, i32* %subprog_cnt, align 4
  %idxprom25 = zext i32 %31 to i64
  %arrayidx26 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %29, i64 %idxprom25
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx26, i32 0, i32 0
  store i32 %28, i32* %start, align 4
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %32, i32 0, i32 22
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %33 = load i32, i32* %level, align 8
  %and = and i32 %33, 2
  %tobool27 = icmp ne i32 %and, 0
  br i1 %tobool27, label %if.then28, label %if.end40

if.then28:                                        ; preds = %for.end
  store i32 0, i32* %i, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc37, %if.then28
  %34 = load i32, i32* %i, align 4
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 26
  %36 = load i32, i32* %subprog_cnt30, align 4
  %cmp31 = icmp ult i32 %34, %36
  br i1 %cmp31, label %for.body33, label %for.end39

for.body33:                                       ; preds = %for.cond29
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = bitcast %struct.bpf_verifier_env* %37 to i8*
  %39 = load i32, i32* %i, align 4
  %40 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %41 = load i32, i32* %i, align 4
  %idxprom34 = sext i32 %41 to i64
  %arrayidx35 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %40, i64 %idxprom34
  %start36 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx35, i32 0, i32 0
  %42 = load i32, i32* %start36, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %38, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.32, i64 0, i64 0), i32 noundef %39, i32 noundef %42) #11
  br label %for.inc37

for.inc37:                                        ; preds = %for.body33
  %43 = load i32, i32* %i, align 4
  %inc38 = add i32 %43, 1
  store i32 %inc38, i32* %i, align 4
  br label %for.cond29

for.end39:                                        ; preds = %for.cond29
  br label %if.end40

if.end40:                                         ; preds = %for.end39, %for.end
  %44 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %45 = load i32, i32* %cur_subprog, align 4
  %idxprom41 = sext i32 %45 to i64
  %arrayidx42 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %44, i64 %idxprom41
  %start43 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx42, i32 0, i32 0
  %46 = load i32, i32* %start43, align 4
  store i32 %46, i32* %subprog_start, align 4
  %47 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %48 = load i32, i32* %cur_subprog, align 4
  %add44 = add i32 %48, 1
  %idxprom45 = sext i32 %add44 to i64
  %arrayidx46 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %47, i64 %idxprom45
  %start47 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx46, i32 0, i32 0
  %49 = load i32, i32* %start47, align 4
  store i32 %49, i32* %subprog_end, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond48

for.cond48:                                       ; preds = %for.inc152, %if.end40
  %50 = load i32, i32* %i, align 4
  %51 = load i32, i32* %insn_cnt, align 4
  %cmp49 = icmp slt i32 %50, %51
  br i1 %cmp49, label %for.body51, label %for.end154

for.body51:                                       ; preds = %for.cond48
  %52 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %53 = load i32, i32* %i, align 4
  %idxprom53 = sext i32 %53 to i64
  %arrayidx54 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %52, i64 %idxprom53
  %code55 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx54, i32 0, i32 0
  %54 = load i8, i8* %code55, align 4
  store i8 %54, i8* %code52, align 1
  %55 = load i8, i8* %code52, align 1
  %conv56 = zext i8 %55 to i32
  %cmp57 = icmp eq i32 %conv56, 133
  br i1 %cmp57, label %land.lhs.true, label %if.end76

land.lhs.true:                                    ; preds = %for.body51
  %56 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %57 = load i32, i32* %i, align 4
  %idxprom59 = sext i32 %57 to i64
  %arrayidx60 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %56, i64 %idxprom59
  %imm61 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx60, i32 0, i32 3
  %58 = load i32, i32* %imm61, align 4
  %cmp62 = icmp eq i32 %58, 12
  br i1 %cmp62, label %land.lhs.true64, label %if.end76

land.lhs.true64:                                  ; preds = %land.lhs.true
  %59 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %60 = load i32, i32* %i, align 4
  %idxprom65 = sext i32 %60 to i64
  %arrayidx66 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %59, i64 %idxprom65
  %src_reg67 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx66, i32 0, i32 1
  %bf.load68 = load i8, i8* %src_reg67, align 1
  %bf.lshr69 = lshr i8 %bf.load68, 4
  %conv70 = zext i8 %bf.lshr69 to i32
  %cmp71 = icmp ne i32 %conv70, 1
  br i1 %cmp71, label %if.then73, label %if.end76

if.then73:                                        ; preds = %land.lhs.true64
  %61 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %62 = load i32, i32* %cur_subprog, align 4
  %idxprom74 = sext i32 %62 to i64
  %arrayidx75 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %61, i64 %idxprom74
  %has_tail_call = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx75, i32 0, i32 3
  store i8 1, i8* %has_tail_call, align 2
  br label %if.end76

if.end76:                                         ; preds = %if.then73, %land.lhs.true64, %land.lhs.true, %for.body51
  %63 = load i8, i8* %code52, align 1
  %conv77 = zext i8 %63 to i32
  %and78 = and i32 %conv77, 7
  %cmp79 = icmp eq i32 %and78, 0
  br i1 %cmp79, label %land.lhs.true81, label %if.end93

land.lhs.true81:                                  ; preds = %if.end76
  %64 = load i8, i8* %code52, align 1
  %conv82 = zext i8 %64 to i32
  %and83 = and i32 %conv82, 224
  %cmp84 = icmp eq i32 %and83, 32
  br i1 %cmp84, label %if.then90, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true81
  %65 = load i8, i8* %code52, align 1
  %conv86 = zext i8 %65 to i32
  %and87 = and i32 %conv86, 224
  %cmp88 = icmp eq i32 %and87, 64
  br i1 %cmp88, label %if.then90, label %if.end93

if.then90:                                        ; preds = %lor.lhs.false, %land.lhs.true81
  %66 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %67 = load i32, i32* %cur_subprog, align 4
  %idxprom91 = sext i32 %67 to i64
  %arrayidx92 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %66, i64 %idxprom91
  %has_ld_abs = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx92, i32 0, i32 5
  store i8 1, i8* %has_ld_abs, align 4
  br label %if.end93

if.end93:                                         ; preds = %if.then90, %lor.lhs.false, %if.end76
  %68 = load i8, i8* %code52, align 1
  %conv94 = zext i8 %68 to i32
  %and95 = and i32 %conv94, 7
  %cmp96 = icmp ne i32 %and95, 5
  br i1 %cmp96, label %land.lhs.true98, label %if.end104

land.lhs.true98:                                  ; preds = %if.end93
  %69 = load i8, i8* %code52, align 1
  %conv99 = zext i8 %69 to i32
  %and100 = and i32 %conv99, 7
  %cmp101 = icmp ne i32 %and100, 6
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %land.lhs.true98
  br label %next

if.end104:                                        ; preds = %land.lhs.true98, %if.end93
  %70 = load i8, i8* %code52, align 1
  %conv105 = zext i8 %70 to i32
  %and106 = and i32 %conv105, 240
  %cmp107 = icmp eq i32 %and106, 144
  br i1 %cmp107, label %if.then114, label %lor.lhs.false109

lor.lhs.false109:                                 ; preds = %if.end104
  %71 = load i8, i8* %code52, align 1
  %conv110 = zext i8 %71 to i32
  %and111 = and i32 %conv110, 240
  %cmp112 = icmp eq i32 %and111, 128
  br i1 %cmp112, label %if.then114, label %if.end115

if.then114:                                       ; preds = %lor.lhs.false109, %if.end104
  br label %next

if.end115:                                        ; preds = %lor.lhs.false109
  %72 = load i32, i32* %i, align 4
  %73 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %74 = load i32, i32* %i, align 4
  %idxprom116 = sext i32 %74 to i64
  %arrayidx117 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %73, i64 %idxprom116
  %off118 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx117, i32 0, i32 2
  %75 = load i16, i16* %off118, align 2
  %conv119 = sext i16 %75 to i32
  %add120 = add i32 %72, %conv119
  %add121 = add i32 %add120, 1
  store i32 %add121, i32* %off, align 4
  %76 = load i32, i32* %off, align 4
  %77 = load i32, i32* %subprog_start, align 4
  %cmp122 = icmp slt i32 %76, %77
  br i1 %cmp122, label %if.then127, label %lor.lhs.false124

lor.lhs.false124:                                 ; preds = %if.end115
  %78 = load i32, i32* %off, align 4
  %79 = load i32, i32* %subprog_end, align 4
  %cmp125 = icmp sge i32 %78, %79
  br i1 %cmp125, label %if.then127, label %if.end128

if.then127:                                       ; preds = %lor.lhs.false124, %if.end115
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %81 = bitcast %struct.bpf_verifier_env* %80 to i8*
  %82 = load i32, i32* %i, align 4
  %83 = load i32, i32* %off, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %81, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.33, i64 0, i64 0), i32 noundef %82, i32 noundef %83) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end128:                                        ; preds = %lor.lhs.false124
  br label %next

next:                                             ; preds = %if.end128, %if.then114, %if.then103
  %84 = load i32, i32* %i, align 4
  %85 = load i32, i32* %subprog_end, align 4
  %sub = sub i32 %85, 1
  %cmp129 = icmp eq i32 %84, %sub
  br i1 %cmp129, label %if.then131, label %if.end151

if.then131:                                       ; preds = %next
  %86 = load i8, i8* %code52, align 1
  %conv132 = zext i8 %86 to i32
  %cmp133 = icmp ne i32 %conv132, 149
  br i1 %cmp133, label %land.lhs.true135, label %if.end140

land.lhs.true135:                                 ; preds = %if.then131
  %87 = load i8, i8* %code52, align 1
  %conv136 = zext i8 %87 to i32
  %cmp137 = icmp ne i32 %conv136, 5
  br i1 %cmp137, label %if.then139, label %if.end140

if.then139:                                       ; preds = %land.lhs.true135
  %88 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %89 = bitcast %struct.bpf_verifier_env* %88 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %89, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.34, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end140:                                        ; preds = %land.lhs.true135, %if.then131
  %90 = load i32, i32* %subprog_end, align 4
  store i32 %90, i32* %subprog_start, align 4
  %91 = load i32, i32* %cur_subprog, align 4
  %inc141 = add i32 %91, 1
  store i32 %inc141, i32* %cur_subprog, align 4
  %92 = load i32, i32* %cur_subprog, align 4
  %93 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt142 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %93, i32 0, i32 26
  %94 = load i32, i32* %subprog_cnt142, align 4
  %cmp143 = icmp ult i32 %92, %94
  br i1 %cmp143, label %if.then145, label %if.end150

if.then145:                                       ; preds = %if.end140
  %95 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %96 = load i32, i32* %cur_subprog, align 4
  %add146 = add i32 %96, 1
  %idxprom147 = sext i32 %add146 to i64
  %arrayidx148 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %95, i64 %idxprom147
  %start149 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx148, i32 0, i32 0
  %97 = load i32, i32* %start149, align 4
  store i32 %97, i32* %subprog_end, align 4
  br label %if.end150

if.end150:                                        ; preds = %if.then145, %if.end140
  br label %if.end151

if.end151:                                        ; preds = %if.end150, %next
  br label %for.inc152

for.inc152:                                       ; preds = %if.end151
  %98 = load i32, i32* %i, align 4
  %inc153 = add i32 %98, 1
  store i32 %inc153, i32* %i, align 4
  br label %for.cond48

for.end154:                                       ; preds = %for.cond48
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end154, %if.then139, %if.then127, %if.then23, %if.then15, %if.then
  %99 = load i32, i32* %retval, align 4
  ret i32 %99
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_btf_info(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, %union.bpf_attr* noundef %uattr) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %uattr.addr = alloca %union.bpf_attr*, align 8
  %btf = alloca %struct.btf*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  store %union.bpf_attr* %uattr, %union.bpf_attr** %uattr.addr, align 8
  %0 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %1 = bitcast %union.bpf_attr* %0 to %struct.anon.10*
  %func_info_cnt = getelementptr inbounds %struct.anon.10, %struct.anon.10* %1, i32 0, i32 15
  %2 = load i32, i32* %func_info_cnt, align 8
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end4, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %3 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %4 = bitcast %union.bpf_attr* %3 to %struct.anon.10*
  %line_info_cnt = getelementptr inbounds %struct.anon.10, %struct.anon.10* %4, i32 0, i32 18
  %5 = load i32, i32* %line_info_cnt, align 8
  %tobool1 = icmp ne i32 %5, 0
  br i1 %tobool1, label %if.end4, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @check_abnormal_return(%struct.bpf_verifier_env* noundef %6) #11
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %entry
  %7 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %8 = bitcast %union.bpf_attr* %7 to %struct.anon.10*
  %prog_btf_fd = getelementptr inbounds %struct.anon.10, %struct.anon.10* %8, i32 0, i32 12
  %9 = load i32, i32* %prog_btf_fd, align 8
  %call5 = call %struct.btf* @btf_get_by_fd(i32 noundef %9) #11
  store %struct.btf* %call5, %struct.btf** %btf, align 8
  %10 = load %struct.btf*, %struct.btf** %btf, align 8
  %11 = bitcast %struct.btf* %10 to i8*
  %call6 = call zeroext i1 @IS_ERR(i8* noundef %11) #11
  br i1 %call6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end4
  %12 = load %struct.btf*, %struct.btf** %btf, align 8
  %13 = bitcast %struct.btf* %12 to i8*
  %call8 = call i64 @PTR_ERR(i8* noundef %13) #11
  %conv = trunc i64 %call8 to i32
  store i32 %conv, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end4
  %14 = load %struct.btf*, %struct.btf** %btf, align 8
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 2
  %16 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %16, i32 0, i32 7
  %17 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf10 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %17, i32 0, i32 44
  store %struct.btf* %14, %struct.btf** %btf10, align 8
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %20 = load %union.bpf_attr*, %union.bpf_attr** %uattr.addr, align 8
  %call11 = call i32 @check_btf_func(%struct.bpf_verifier_env* noundef %18, %union.bpf_attr* noundef %19, %union.bpf_attr* noundef %20) #11
  store i32 %call11, i32* %err, align 4
  %21 = load i32, i32* %err, align 4
  %tobool12 = icmp ne i32 %21, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  %22 = load i32, i32* %err, align 4
  store i32 %22, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end9
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %25 = load %union.bpf_attr*, %union.bpf_attr** %uattr.addr, align 8
  %call15 = call i32 @check_btf_line(%struct.bpf_verifier_env* noundef %23, %union.bpf_attr* noundef %24, %union.bpf_attr* noundef %25) #11
  store i32 %call15, i32* %err, align 4
  %26 = load i32, i32* %err, align 4
  %tobool16 = icmp ne i32 %26, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  %27 = load i32, i32* %err, align 4
  store i32 %27, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end14
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then17, %if.then13, %if.then7, %if.end, %if.then3
  %28 = load i32, i32* %retval, align 4
  ret i32 %28
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_attach_btf_id(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %tgt_prog = alloca %struct.bpf_prog*, align 8
  %tgt_info = alloca %struct.bpf_attach_target_info, align 8
  %btf_id = alloca i32, align 4
  %tr = alloca %struct.bpf_trampoline*, align 8
  %ret = alloca i32, align 4
  %key = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 7
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %dst_prog = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 15
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %dst_prog, align 8
  store %struct.bpf_prog* %4, %struct.bpf_prog** %tgt_prog, align 8
  %5 = bitcast %struct.bpf_attach_target_info* %tgt_info to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %5, i8 0, i64 40, i1 false)
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 7
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux2, align 8
  %attach_btf_id = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 9
  %8 = load i32, i32* %attach_btf_id, align 8
  store i32 %8, i32* %btf_id, align 4
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %9, i32 0, i32 7
  %10 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %sleepable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %10, i32 0, i32 23
  %11 = load i8, i8* %sleepable, align 4
  %tobool = trunc i8 %11 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %12 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %12, i32 0, i32 2
  %13 = load i32, i32* %type, align 4
  %cmp = icmp ne i32 %13, 26
  br i1 %cmp, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %14 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type5 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %14, i32 0, i32 2
  %15 = load i32, i32* %type5, align 4
  %cmp6 = icmp ne i32 %15, 29
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([62 x i8], [62 x i8]* @.str.54, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true, %entry
  %18 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type7 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %18, i32 0, i32 2
  %19 = load i32, i32* %type7, align 4
  %cmp8 = icmp eq i32 %19, 27
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @check_struct_ops_btf_id(%struct.bpf_verifier_env* noundef %20) #11
  store i32 %call, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type11 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 2
  %22 = load i32, i32* %type11, align 4
  %cmp12 = icmp ne i32 %22, 26
  br i1 %cmp12, label %land.lhs.true13, label %if.end20

land.lhs.true13:                                  ; preds = %if.end10
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type14 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %23, i32 0, i32 2
  %24 = load i32, i32* %type14, align 4
  %cmp15 = icmp ne i32 %24, 29
  br i1 %cmp15, label %land.lhs.true16, label %if.end20

land.lhs.true16:                                  ; preds = %land.lhs.true13
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type17 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %25, i32 0, i32 2
  %26 = load i32, i32* %type17, align 4
  %cmp18 = icmp ne i32 %26, 28
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true16
  store i32 0, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %land.lhs.true16, %land.lhs.true13, %if.end10
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 22
  %28 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %29 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %30 = load i32, i32* %btf_id, align 4
  %call21 = call i32 @bpf_check_attach_target(%struct.bpf_verifier_log* noundef %log, %struct.bpf_prog* noundef %28, %struct.bpf_prog* noundef %29, i32 noundef %30, %struct.bpf_attach_target_info* noundef %tgt_info) #11
  store i32 %call21, i32* %ret, align 4
  %31 = load i32, i32* %ret, align 4
  %tobool22 = icmp ne i32 %31, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  %32 = load i32, i32* %ret, align 4
  store i32 %32, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end20
  %33 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %tobool25 = icmp ne %struct.bpf_prog* %33, null
  br i1 %tobool25, label %land.lhs.true26, label %if.end32

land.lhs.true26:                                  ; preds = %if.end24
  %34 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type27 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %34, i32 0, i32 2
  %35 = load i32, i32* %type27, align 4
  %cmp28 = icmp eq i32 %35, 28
  br i1 %cmp28, label %if.then29, label %if.end32

if.then29:                                        ; preds = %land.lhs.true26
  %36 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %type30 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %36, i32 0, i32 2
  %37 = load i32, i32* %type30, align 4
  %idxprom = zext i32 %37 to i64
  %arrayidx = getelementptr [31 x %struct.bpf_verifier_ops*], [31 x %struct.bpf_verifier_ops*]* @bpf_verifier_ops, i64 0, i64 %idxprom
  %38 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %arrayidx, align 8
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %39, i32 0, i32 3
  store %struct.bpf_verifier_ops* %38, %struct.bpf_verifier_ops** %ops, align 8
  %40 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %40, i32 0, i32 3
  %41 = load i32, i32* %expected_attach_type, align 8
  %42 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type31 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %42, i32 0, i32 3
  store i32 %41, i32* %expected_attach_type31, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then29, %land.lhs.true26, %if.end24
  %tgt_type = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %tgt_info, i32 0, i32 3
  %43 = load %struct.btf_type*, %struct.btf_type** %tgt_type, align 8
  %44 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux33 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %44, i32 0, i32 7
  %45 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux33, align 8
  %attach_func_proto = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %45, i32 0, i32 27
  store %struct.btf_type* %43, %struct.btf_type** %attach_func_proto, align 8
  %tgt_name = getelementptr inbounds %struct.bpf_attach_target_info, %struct.bpf_attach_target_info* %tgt_info, i32 0, i32 2
  %46 = load i8*, i8** %tgt_name, align 8
  %47 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux34 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %47, i32 0, i32 7
  %48 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux34, align 8
  %attach_func_name = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %48, i32 0, i32 28
  store i8* %46, i8** %attach_func_name, align 8
  %49 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %tobool35 = icmp ne %struct.bpf_prog* %49, null
  br i1 %tobool35, label %if.then36, label %if.end41

if.then36:                                        ; preds = %if.end32
  %50 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %type37 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %50, i32 0, i32 2
  %51 = load i32, i32* %type37, align 4
  %52 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux38 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %52, i32 0, i32 7
  %53 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux38, align 8
  %saved_dst_prog_type = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %53, i32 0, i32 17
  store i32 %51, i32* %saved_dst_prog_type, align 8
  %54 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %expected_attach_type39 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %54, i32 0, i32 3
  %55 = load i32, i32* %expected_attach_type39, align 8
  %56 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux40 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %56, i32 0, i32 7
  %57 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux40, align 8
  %saved_dst_attach_type = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %57, i32 0, i32 18
  store i32 %55, i32* %saved_dst_attach_type, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.then36, %if.end32
  %58 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type42 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %58, i32 0, i32 3
  %59 = load i32, i32* %expected_attach_type42, align 8
  %cmp43 = icmp eq i32 %59, 23
  br i1 %cmp43, label %if.then44, label %if.else

if.then44:                                        ; preds = %if.end41
  %60 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux45 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %60, i32 0, i32 7
  %61 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux45, align 8
  %attach_btf_trace = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %61, i32 0, i32 21
  store i8 1, i8* %attach_btf_trace, align 2
  store i32 0, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end41
  %62 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type46 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %62, i32 0, i32 3
  %63 = load i32, i32* %expected_attach_type46, align 8
  %cmp47 = icmp eq i32 %63, 28
  br i1 %cmp47, label %if.then48, label %if.end52

if.then48:                                        ; preds = %if.else
  %64 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call49 = call zeroext i1 @bpf_iter_prog_supported(%struct.bpf_prog* noundef %64) #11
  br i1 %call49, label %if.end51, label %if.then50

if.then50:                                        ; preds = %if.then48
  store i32 -22, i32* %retval, align 4
  br label %return

if.end51:                                         ; preds = %if.then48
  store i32 0, i32* %retval, align 4
  br label %return

if.end52:                                         ; preds = %if.else
  br label %if.end53

if.end53:                                         ; preds = %if.end52
  %65 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type54 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %65, i32 0, i32 2
  %66 = load i32, i32* %type54, align 4
  %cmp55 = icmp eq i32 %66, 29
  br i1 %cmp55, label %if.then56, label %if.end62

if.then56:                                        ; preds = %if.end53
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log57 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %67, i32 0, i32 22
  %68 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call58 = call i32 @bpf_lsm_verify_prog(%struct.bpf_verifier_log* noundef %log57, %struct.bpf_prog* noundef %68) #11
  store i32 %call58, i32* %ret, align 4
  %69 = load i32, i32* %ret, align 4
  %cmp59 = icmp slt i32 %69, 0
  br i1 %cmp59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.then56
  %70 = load i32, i32* %ret, align 4
  store i32 %70, i32* %retval, align 4
  br label %return

if.end61:                                         ; preds = %if.then56
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %if.end53
  %71 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog, align 8
  %72 = load i32, i32* %btf_id, align 4
  %call63 = call i64 @bpf_trampoline_compute_key(%struct.bpf_prog* noundef %71, i32 noundef %72) #11
  store i64 %call63, i64* %key, align 8
  %73 = load i64, i64* %key, align 8
  %call64 = call %struct.bpf_trampoline* @bpf_trampoline_get(i64 noundef %73, %struct.bpf_attach_target_info* noundef %tgt_info) #11
  store %struct.bpf_trampoline* %call64, %struct.bpf_trampoline** %tr, align 8
  %74 = load %struct.bpf_trampoline*, %struct.bpf_trampoline** %tr, align 8
  %tobool65 = icmp ne %struct.bpf_trampoline* %74, null
  br i1 %tobool65, label %if.end67, label %if.then66

if.then66:                                        ; preds = %if.end62
  store i32 -12, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.end62
  %75 = load %struct.bpf_trampoline*, %struct.bpf_trampoline** %tr, align 8
  %76 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux68 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %76, i32 0, i32 7
  %77 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux68, align 8
  %dst_trampoline = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %77, i32 0, i32 16
  store %struct.bpf_trampoline* %75, %struct.bpf_trampoline** %dst_trampoline, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end67, %if.then66, %if.then60, %if.end51, %if.then50, %if.then44, %if.then23, %if.then19, %if.then9, %if.then
  %78 = load i32, i32* %retval, align 4
  ret i32 %78
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @resolve_pseudo_ldimm64(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %err = alloca i32, align 4
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %f = alloca %struct.fd, align 8
  %addr = alloca i64, align 8
  %tmp = alloca %struct.fd, align 8
  %off147 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %call = call i32 @bpf_prog_calc_tag(%struct.bpf_prog* noundef %6) #11
  store i32 %call, i32* %err, align 4
  %7 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load i32, i32* %err, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc210, %if.end
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end213

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 0
  %12 = load i8, i8* %code, align 4
  %conv = zext i8 %12 to i32
  %and = and i32 %conv, 7
  %cmp3 = icmp eq i32 %and, 1
  br i1 %cmp3, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %for.body
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code5 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 0
  %14 = load i8, i8* %code5, align 4
  %conv6 = zext i8 %14 to i32
  %and7 = and i32 %conv6, 224
  %cmp8 = icmp ne i32 %and7, 96
  br i1 %cmp8, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 3
  %16 = load i32, i32* %imm, align 4
  %cmp10 = icmp ne i32 %16, 0
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.59, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %lor.lhs.false, %for.body
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code14 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %19, i32 0, i32 0
  %20 = load i8, i8* %code14, align 4
  %conv15 = zext i8 %20 to i32
  %and16 = and i32 %conv15, 7
  %cmp17 = icmp eq i32 %and16, 3
  br i1 %cmp17, label %land.lhs.true19, label %if.end36

land.lhs.true19:                                  ; preds = %if.end13
  %21 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code20 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %21, i32 0, i32 0
  %22 = load i8, i8* %code20, align 4
  %conv21 = zext i8 %22 to i32
  %and22 = and i32 %conv21, 224
  %cmp23 = icmp ne i32 %and22, 96
  br i1 %cmp23, label %land.lhs.true25, label %lor.lhs.false31

land.lhs.true25:                                  ; preds = %land.lhs.true19
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code26 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %23, i32 0, i32 0
  %24 = load i8, i8* %code26, align 4
  %conv27 = zext i8 %24 to i32
  %and28 = and i32 %conv27, 224
  %cmp29 = icmp ne i32 %and28, 192
  br i1 %cmp29, label %if.then35, label %lor.lhs.false31

lor.lhs.false31:                                  ; preds = %land.lhs.true25, %land.lhs.true19
  %25 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm32 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %25, i32 0, i32 3
  %26 = load i32, i32* %imm32, align 4
  %cmp33 = icmp ne i32 %26, 0
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %lor.lhs.false31, %land.lhs.true25
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = bitcast %struct.bpf_verifier_env* %27 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %28, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.60, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %lor.lhs.false31, %if.end13
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %29, i64 0
  %code37 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 0
  %30 = load i8, i8* %code37, align 4
  %conv38 = zext i8 %30 to i32
  %cmp39 = icmp eq i32 %conv38, 24
  br i1 %cmp39, label %if.then41, label %if.end203

if.then41:                                        ; preds = %if.end36
  %31 = load i32, i32* %i, align 4
  %32 = load i32, i32* %insn_cnt, align 4
  %sub = sub i32 %32, 1
  %cmp42 = icmp eq i32 %31, %sub
  br i1 %cmp42, label %if.then66, label %lor.lhs.false44

lor.lhs.false44:                                  ; preds = %if.then41
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx45 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %33, i64 1
  %code46 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx45, i32 0, i32 0
  %34 = load i8, i8* %code46, align 4
  %conv47 = zext i8 %34 to i32
  %cmp48 = icmp ne i32 %conv47, 0
  br i1 %cmp48, label %if.then66, label %lor.lhs.false50

lor.lhs.false50:                                  ; preds = %lor.lhs.false44
  %35 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx51 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %35, i64 1
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx51, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv52 = zext i8 %bf.clear to i32
  %cmp53 = icmp ne i32 %conv52, 0
  br i1 %cmp53, label %if.then66, label %lor.lhs.false55

lor.lhs.false55:                                  ; preds = %lor.lhs.false50
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx56 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %36, i64 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx56, i32 0, i32 1
  %bf.load57 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load57, 4
  %conv58 = zext i8 %bf.lshr to i32
  %cmp59 = icmp ne i32 %conv58, 0
  br i1 %cmp59, label %if.then66, label %lor.lhs.false61

lor.lhs.false61:                                  ; preds = %lor.lhs.false55
  %37 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx62 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %37, i64 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx62, i32 0, i32 2
  %38 = load i16, i16* %off, align 2
  %conv63 = sext i16 %38 to i32
  %cmp64 = icmp ne i32 %conv63, 0
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %lor.lhs.false61, %lor.lhs.false55, %lor.lhs.false50, %lor.lhs.false44, %if.then41
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = bitcast %struct.bpf_verifier_env* %39 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %40, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.61, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %lor.lhs.false61
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx68 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %41, i64 0
  %src_reg69 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx68, i32 0, i32 1
  %bf.load70 = load i8, i8* %src_reg69, align 1
  %bf.lshr71 = lshr i8 %bf.load70, 4
  %conv72 = zext i8 %bf.lshr71 to i32
  %cmp73 = icmp eq i32 %conv72, 0
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %if.end67
  br label %next_insn

if.end76:                                         ; preds = %if.end67
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx77 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %42, i64 0
  %src_reg78 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx77, i32 0, i32 1
  %bf.load79 = load i8, i8* %src_reg78, align 1
  %bf.lshr80 = lshr i8 %bf.load79, 4
  %conv81 = zext i8 %bf.lshr80 to i32
  %cmp82 = icmp eq i32 %conv81, 3
  br i1 %cmp82, label %if.then84, label %if.end90

if.then84:                                        ; preds = %if.end76
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %43, i32 0, i32 20
  %44 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %45 = load i32, i32* %i, align 4
  %idxprom = sext i32 %45 to i64
  %arrayidx85 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %44, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx85, %struct.bpf_insn_aux_data** %aux, align 8
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %48 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call86 = call i32 @check_pseudo_btf_id(%struct.bpf_verifier_env* noundef %46, %struct.bpf_insn* noundef %47, %struct.bpf_insn_aux_data* noundef %48) #11
  store i32 %call86, i32* %err, align 4
  %49 = load i32, i32* %err, align 4
  %tobool87 = icmp ne i32 %49, 0
  br i1 %tobool87, label %if.then88, label %if.end89

if.then88:                                        ; preds = %if.then84
  %50 = load i32, i32* %err, align 4
  store i32 %50, i32* %retval, align 4
  br label %return

if.end89:                                         ; preds = %if.then84
  br label %next_insn

if.end90:                                         ; preds = %if.end76
  %51 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx91 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %51, i64 0
  %src_reg92 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx91, i32 0, i32 1
  %bf.load93 = load i8, i8* %src_reg92, align 1
  %bf.lshr94 = lshr i8 %bf.load93, 4
  %conv95 = zext i8 %bf.lshr94 to i32
  %cmp96 = icmp ne i32 %conv95, 1
  br i1 %cmp96, label %land.lhs.true98, label %lor.lhs.false106

land.lhs.true98:                                  ; preds = %if.end90
  %52 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx99 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %52, i64 0
  %src_reg100 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx99, i32 0, i32 1
  %bf.load101 = load i8, i8* %src_reg100, align 1
  %bf.lshr102 = lshr i8 %bf.load101, 4
  %conv103 = zext i8 %bf.lshr102 to i32
  %cmp104 = icmp ne i32 %conv103, 2
  br i1 %cmp104, label %if.then119, label %lor.lhs.false106

lor.lhs.false106:                                 ; preds = %land.lhs.true98, %if.end90
  %53 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx107 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %53, i64 0
  %src_reg108 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx107, i32 0, i32 1
  %bf.load109 = load i8, i8* %src_reg108, align 1
  %bf.lshr110 = lshr i8 %bf.load109, 4
  %conv111 = zext i8 %bf.lshr110 to i32
  %cmp112 = icmp eq i32 %conv111, 1
  br i1 %cmp112, label %land.lhs.true114, label %if.end120

land.lhs.true114:                                 ; preds = %lor.lhs.false106
  %54 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx115 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %54, i64 1
  %imm116 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx115, i32 0, i32 3
  %55 = load i32, i32* %imm116, align 4
  %cmp117 = icmp ne i32 %55, 0
  br i1 %cmp117, label %if.then119, label %if.end120

if.then119:                                       ; preds = %land.lhs.true114, %land.lhs.true98
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = bitcast %struct.bpf_verifier_env* %56 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %57, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.62, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end120:                                        ; preds = %land.lhs.true114, %lor.lhs.false106
  %58 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx121 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %58, i64 0
  %imm122 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx121, i32 0, i32 3
  %59 = load i32, i32* %imm122, align 4
  %call123 = call { %struct.file*, i32 } @fdget(i32 noundef %59) #11
  %60 = bitcast %struct.fd* %tmp to { %struct.file*, i32 }*
  %61 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %60, i32 0, i32 0
  %62 = extractvalue { %struct.file*, i32 } %call123, 0
  store %struct.file* %62, %struct.file** %61, align 8
  %63 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %60, i32 0, i32 1
  %64 = extractvalue { %struct.file*, i32 } %call123, 1
  store i32 %64, i32* %63, align 8
  %65 = bitcast %struct.fd* %f to i8*
  %66 = bitcast %struct.fd* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %65, i8* align 8 %66, i64 16, i1 false)
  %67 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %68 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %67, i32 0, i32 0
  %69 = load %struct.file*, %struct.file** %68, align 8
  %70 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %67, i32 0, i32 1
  %71 = load i32, i32* %70, align 8
  %call124 = call %struct.bpf_map* @__bpf_map_get(%struct.file* %69, i32 %71) #11
  store %struct.bpf_map* %call124, %struct.bpf_map** %map, align 8
  %72 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %73 = bitcast %struct.bpf_map* %72 to i8*
  %call125 = call zeroext i1 @IS_ERR(i8* noundef %73) #11
  br i1 %call125, label %if.then126, label %if.end131

if.then126:                                       ; preds = %if.end120
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = bitcast %struct.bpf_verifier_env* %74 to i8*
  %76 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx127 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %76, i64 0
  %imm128 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx127, i32 0, i32 3
  %77 = load i32, i32* %imm128, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %75, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.63, i64 0, i64 0), i32 noundef %77) #11
  %78 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %79 = bitcast %struct.bpf_map* %78 to i8*
  %call129 = call i64 @PTR_ERR(i8* noundef %79) #11
  %conv130 = trunc i64 %call129 to i32
  store i32 %conv130, i32* %retval, align 4
  br label %return

if.end131:                                        ; preds = %if.end120
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %81 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog132 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %82, i32 0, i32 2
  %83 = load %struct.bpf_prog*, %struct.bpf_prog** %prog132, align 8
  %call133 = call i32 @check_map_prog_compatibility(%struct.bpf_verifier_env* noundef %80, %struct.bpf_map* noundef %81, %struct.bpf_prog* noundef %83) #11
  store i32 %call133, i32* %err, align 4
  %84 = load i32, i32* %err, align 4
  %tobool134 = icmp ne i32 %84, 0
  br i1 %tobool134, label %if.then135, label %if.end136

if.then135:                                       ; preds = %if.end131
  %85 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %86 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %85, i32 0, i32 0
  %87 = load %struct.file*, %struct.file** %86, align 8
  %88 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %85, i32 0, i32 1
  %89 = load i32, i32* %88, align 8
  call void @fdput(%struct.file* %87, i32 %89) #11
  %90 = load i32, i32* %err, align 4
  store i32 %90, i32* %retval, align 4
  br label %return

if.end136:                                        ; preds = %if.end131
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data137 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %91, i32 0, i32 20
  %92 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data137, align 8
  %93 = load i32, i32* %i, align 4
  %idxprom138 = sext i32 %93 to i64
  %arrayidx139 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %92, i64 %idxprom138
  store %struct.bpf_insn_aux_data* %arrayidx139, %struct.bpf_insn_aux_data** %aux, align 8
  %94 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg140 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %94, i32 0, i32 1
  %bf.load141 = load i8, i8* %src_reg140, align 1
  %bf.lshr142 = lshr i8 %bf.load141, 4
  %conv143 = zext i8 %bf.lshr142 to i32
  %cmp144 = icmp eq i32 %conv143, 1
  br i1 %cmp144, label %if.then146, label %if.else

if.then146:                                       ; preds = %if.end136
  %95 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %96 = ptrtoint %struct.bpf_map* %95 to i64
  store i64 %96, i64* %addr, align 8
  br label %if.end164

if.else:                                          ; preds = %if.end136
  %97 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx148 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %97, i64 1
  %imm149 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx148, i32 0, i32 3
  %98 = load i32, i32* %imm149, align 4
  store i32 %98, i32* %off147, align 4
  %99 = load i32, i32* %off147, align 4
  %cmp150 = icmp uge i32 %99, 536870912
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.else
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %101 = bitcast %struct.bpf_verifier_env* %100 to i8*
  %102 = load i32, i32* %off147, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %101, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.64, i64 0, i64 0), i32 noundef %102) #11
  %103 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %104 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %103, i32 0, i32 0
  %105 = load %struct.file*, %struct.file** %104, align 8
  %106 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %103, i32 0, i32 1
  %107 = load i32, i32* %106, align 8
  call void @fdput(%struct.file* %105, i32 %107) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end153:                                        ; preds = %if.else
  %108 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %108, i32 0, i32 0
  %109 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %109, i32 0, i32 26
  %110 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %tobool154 = icmp ne i32 (%struct.bpf_map*, i64*, i32)* %110, null
  br i1 %tobool154, label %if.end156, label %if.then155

if.then155:                                       ; preds = %if.end153
  %111 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %112 = bitcast %struct.bpf_verifier_env* %111 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %112, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.65, i64 0, i64 0)) #11
  %113 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %114 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %113, i32 0, i32 0
  %115 = load %struct.file*, %struct.file** %114, align 8
  %116 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %113, i32 0, i32 1
  %117 = load i32, i32* %116, align 8
  call void @fdput(%struct.file* %115, i32 %117) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end156:                                        ; preds = %if.end153
  %118 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops157 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %118, i32 0, i32 0
  %119 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops157, align 64
  %map_direct_value_addr158 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %119, i32 0, i32 26
  %120 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr158, align 8
  %121 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %122 = load i32, i32* %off147, align 4
  %call159 = call i32 %120(%struct.bpf_map* noundef %121, i64* noundef %addr, i32 noundef %122) #11
  store i32 %call159, i32* %err, align 4
  %123 = load i32, i32* %err, align 4
  %tobool160 = icmp ne i32 %123, 0
  br i1 %tobool160, label %if.then161, label %if.end162

if.then161:                                       ; preds = %if.end156
  %124 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %125 = bitcast %struct.bpf_verifier_env* %124 to i8*
  %126 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %126, i32 0, i32 5
  %127 = load i32, i32* %value_size, align 32
  %128 = load i32, i32* %off147, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %125, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.66, i64 0, i64 0), i32 noundef %127, i32 noundef %128) #11
  %129 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %130 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %129, i32 0, i32 0
  %131 = load %struct.file*, %struct.file** %130, align 8
  %132 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %129, i32 0, i32 1
  %133 = load i32, i32* %132, align 8
  call void @fdput(%struct.file* %131, i32 %133) #11
  %134 = load i32, i32* %err, align 4
  store i32 %134, i32* %retval, align 4
  br label %return

if.end162:                                        ; preds = %if.end156
  %135 = load i32, i32* %off147, align 4
  %136 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %137 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %136, i32 0, i32 0
  %138 = bitcast %struct.atomic64_t* %137 to %struct.util_est*
  %map_off = getelementptr inbounds %struct.util_est, %struct.util_est* %138, i32 0, i32 1
  store i32 %135, i32* %map_off, align 4
  %139 = load i32, i32* %off147, align 4
  %conv163 = zext i32 %139 to i64
  %140 = load i64, i64* %addr, align 8
  %add = add i64 %140, %conv163
  store i64 %add, i64* %addr, align 8
  br label %if.end164

if.end164:                                        ; preds = %if.end162, %if.then146
  %141 = load i64, i64* %addr, align 8
  %conv165 = trunc i64 %141 to i32
  %142 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx166 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %142, i64 0
  %imm167 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx166, i32 0, i32 3
  store i32 %conv165, i32* %imm167, align 4
  %143 = load i64, i64* %addr, align 8
  %shr = lshr i64 %143, 32
  %conv168 = trunc i64 %shr to i32
  %144 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arrayidx169 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %144, i64 1
  %imm170 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx169, i32 0, i32 3
  store i32 %conv168, i32* %imm170, align 4
  store i32 0, i32* %j, align 4
  br label %for.cond171

for.cond171:                                      ; preds = %for.inc, %if.end164
  %145 = load i32, i32* %j, align 4
  %146 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %146, i32 0, i32 12
  %147 = load i32, i32* %used_map_cnt, align 8
  %cmp172 = icmp ult i32 %145, %147
  br i1 %cmp172, label %for.body174, label %for.end

for.body174:                                      ; preds = %for.cond171
  %148 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %148, i32 0, i32 11
  %149 = load i32, i32* %j, align 4
  %idxprom175 = sext i32 %149 to i64
  %arrayidx176 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps, i64 0, i64 %idxprom175
  %150 = load %struct.bpf_map*, %struct.bpf_map** %arrayidx176, align 8
  %151 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %cmp177 = icmp eq %struct.bpf_map* %150, %151
  br i1 %cmp177, label %if.then179, label %if.end180

if.then179:                                       ; preds = %for.body174
  %152 = load i32, i32* %j, align 4
  %153 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %154 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %153, i32 0, i32 0
  %155 = bitcast %struct.atomic64_t* %154 to %struct.util_est*
  %map_index = getelementptr inbounds %struct.util_est, %struct.util_est* %155, i32 0, i32 0
  store i32 %152, i32* %map_index, align 8
  %156 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %157 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %156, i32 0, i32 0
  %158 = load %struct.file*, %struct.file** %157, align 8
  %159 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %156, i32 0, i32 1
  %160 = load i32, i32* %159, align 8
  call void @fdput(%struct.file* %158, i32 %160) #11
  br label %next_insn

if.end180:                                        ; preds = %for.body174
  br label %for.inc

for.inc:                                          ; preds = %if.end180
  %161 = load i32, i32* %j, align 4
  %inc = add i32 %161, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond171

for.end:                                          ; preds = %for.cond171
  %162 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt181 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %162, i32 0, i32 12
  %163 = load i32, i32* %used_map_cnt181, align 8
  %cmp182 = icmp uge i32 %163, 64
  br i1 %cmp182, label %if.then184, label %if.end185

if.then184:                                       ; preds = %for.end
  %164 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %165 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %164, i32 0, i32 0
  %166 = load %struct.file*, %struct.file** %165, align 8
  %167 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %164, i32 0, i32 1
  %168 = load i32, i32* %167, align 8
  call void @fdput(%struct.file* %166, i32 %168) #11
  store i32 -7, i32* %retval, align 4
  br label %return

if.end185:                                        ; preds = %for.end
  %169 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  call void @bpf_map_inc(%struct.bpf_map* noundef %169) #11
  %170 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt186 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %170, i32 0, i32 12
  %171 = load i32, i32* %used_map_cnt186, align 8
  %172 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %173 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %172, i32 0, i32 0
  %174 = bitcast %struct.atomic64_t* %173 to %struct.util_est*
  %map_index187 = getelementptr inbounds %struct.util_est, %struct.util_est* %174, i32 0, i32 0
  store i32 %171, i32* %map_index187, align 8
  %175 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %176 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps188 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %176, i32 0, i32 11
  %177 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt189 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %177, i32 0, i32 12
  %178 = load i32, i32* %used_map_cnt189, align 8
  %inc190 = add i32 %178, 1
  store i32 %inc190, i32* %used_map_cnt189, align 8
  %idxprom191 = zext i32 %178 to i64
  %arrayidx192 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps188, i64 0, i64 %idxprom191
  store %struct.bpf_map* %175, %struct.bpf_map** %arrayidx192, align 8
  %179 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call193 = call zeroext i1 @bpf_map_is_cgroup_storage(%struct.bpf_map* noundef %179) #11
  br i1 %call193, label %land.lhs.true195, label %if.end201

land.lhs.true195:                                 ; preds = %if.end185
  %180 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog196 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %180, i32 0, i32 2
  %181 = load %struct.bpf_prog*, %struct.bpf_prog** %prog196, align 8
  %aux197 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %181, i32 0, i32 7
  %182 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux197, align 8
  %183 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call198 = call i32 @bpf_cgroup_storage_assign(%struct.bpf_prog_aux* noundef %182, %struct.bpf_map* noundef %183) #11
  %tobool199 = icmp ne i32 %call198, 0
  br i1 %tobool199, label %if.then200, label %if.end201

if.then200:                                       ; preds = %land.lhs.true195
  %184 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %185 = bitcast %struct.bpf_verifier_env* %184 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %185, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.67, i64 0, i64 0)) #11
  %186 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %187 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %186, i32 0, i32 0
  %188 = load %struct.file*, %struct.file** %187, align 8
  %189 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %186, i32 0, i32 1
  %190 = load i32, i32* %189, align 8
  call void @fdput(%struct.file* %188, i32 %190) #11
  store i32 -16, i32* %retval, align 4
  br label %return

if.end201:                                        ; preds = %land.lhs.true195, %if.end185
  %191 = bitcast %struct.fd* %f to { %struct.file*, i32 }*
  %192 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %191, i32 0, i32 0
  %193 = load %struct.file*, %struct.file** %192, align 8
  %194 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %191, i32 0, i32 1
  %195 = load i32, i32* %194, align 8
  call void @fdput(%struct.file* %193, i32 %195) #11
  br label %next_insn

next_insn:                                        ; preds = %if.end201, %if.then179, %if.end89, %if.then75
  %196 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %196, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  %197 = load i32, i32* %i, align 4
  %inc202 = add i32 %197, 1
  store i32 %inc202, i32* %i, align 4
  br label %for.inc210

if.end203:                                        ; preds = %if.end36
  %198 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code204 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %198, i32 0, i32 0
  %199 = load i8, i8* %code204, align 4
  %call205 = call zeroext i1 @bpf_opcode_in_insntable(i8 noundef zeroext %199) #11
  br i1 %call205, label %if.end209, label %if.then206

if.then206:                                       ; preds = %if.end203
  %200 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %201 = bitcast %struct.bpf_verifier_env* %200 to i8*
  %202 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code207 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %202, i32 0, i32 0
  %203 = load i8, i8* %code207, align 4
  %conv208 = zext i8 %203 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %201, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.68, i64 0, i64 0), i32 noundef %conv208) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end209:                                        ; preds = %if.end203
  br label %for.inc210

for.inc210:                                       ; preds = %if.end209, %next_insn
  %204 = load i32, i32* %i, align 4
  %inc211 = add i32 %204, 1
  store i32 %inc211, i32* %i, align 4
  %205 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr212 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %205, i32 1
  store %struct.bpf_insn* %incdec.ptr212, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end213:                                       ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end213, %if.then206, %if.then200, %if.then184, %if.then161, %if.then155, %if.then152, %if.then135, %if.then126, %if.then119, %if.then88, %if.then66, %if.then35, %if.then12, %if.then
  %206 = load i32, i32* %retval, align 4
  ret i32 %206
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_cfg(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insns = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %insn_stack = alloca i32*, align 8
  %insn_state = alloca i32*, align 8
  %ret = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  %opcode = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insns, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  store i32 0, i32* %ret, align 4
  %5 = load i32, i32* %insn_cnt, align 4
  %conv = sext i32 %5 to i64
  %call = call i8* @kvcalloc(i64 noundef %conv, i64 noundef 4, i32 noundef 3264) #11
  %6 = bitcast i8* %call to i32*
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 24
  %insn_state2 = getelementptr inbounds %struct.anon.178, %struct.anon.178* %cfg, i32 0, i32 0
  store i32* %6, i32** %insn_state2, align 8
  store i32* %6, i32** %insn_state, align 8
  %8 = load i32*, i32** %insn_state, align 8
  %tobool = icmp ne i32* %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load i32, i32* %insn_cnt, align 4
  %conv3 = sext i32 %9 to i64
  %call4 = call i8* @kvcalloc(i64 noundef %conv3, i64 noundef 4, i32 noundef 3264) #11
  %10 = bitcast i8* %call4 to i32*
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg5 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 24
  %insn_stack6 = getelementptr inbounds %struct.anon.178, %struct.anon.178* %cfg5, i32 0, i32 1
  store i32* %10, i32** %insn_stack6, align 8
  store i32* %10, i32** %insn_stack, align 8
  %12 = load i32*, i32** %insn_stack, align 8
  %tobool7 = icmp ne i32* %12, null
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  %13 = load i32*, i32** %insn_state, align 8
  %14 = bitcast i32* %13 to i8*
  call void @kvfree(i8* noundef %14) #11
  store i32 -12, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end
  %15 = load i32*, i32** %insn_state, align 8
  %arrayidx = getelementptr i32, i32* %15, i64 0
  store i32 16, i32* %arrayidx, align 4
  %16 = load i32*, i32** %insn_stack, align 8
  %arrayidx10 = getelementptr i32, i32* %16, i64 0
  store i32 0, i32* %arrayidx10, align 4
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 24
  %cur_stack = getelementptr inbounds %struct.anon.178, %struct.anon.178* %cfg11, i32 0, i32 2
  store i32 1, i32* %cur_stack, align 8
  br label %peek_stack

peek_stack:                                       ; preds = %if.end176, %if.then161, %if.then146, %if.then130, %if.then106, %if.then76, %if.then50, %if.end9
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 24
  %cur_stack13 = getelementptr inbounds %struct.anon.178, %struct.anon.178* %cfg12, i32 0, i32 2
  %19 = load i32, i32* %cur_stack13, align 8
  %cmp = icmp eq i32 %19, 0
  br i1 %cmp, label %if.then15, label %if.end16

if.then15:                                        ; preds = %peek_stack
  br label %check_state

if.end16:                                         ; preds = %peek_stack
  %20 = load i32*, i32** %insn_stack, align 8
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg17 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %21, i32 0, i32 24
  %cur_stack18 = getelementptr inbounds %struct.anon.178, %struct.anon.178* %cfg17, i32 0, i32 2
  %22 = load i32, i32* %cur_stack18, align 8
  %sub = sub i32 %22, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx19 = getelementptr i32, i32* %20, i64 %idxprom
  %23 = load i32, i32* %arrayidx19, align 4
  store i32 %23, i32* %t, align 4
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %25 = load i32, i32* %t, align 4
  %idxprom20 = sext i32 %25 to i64
  %arrayidx21 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %24, i64 %idxprom20
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx21, i32 0, i32 0
  %26 = load i8, i8* %code, align 4
  %conv22 = zext i8 %26 to i32
  %and = and i32 %conv22, 7
  %cmp23 = icmp eq i32 %and, 5
  br i1 %cmp23, label %if.then32, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end16
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %28 = load i32, i32* %t, align 4
  %idxprom25 = sext i32 %28 to i64
  %arrayidx26 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %27, i64 %idxprom25
  %code27 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx26, i32 0, i32 0
  %29 = load i8, i8* %code27, align 4
  %conv28 = zext i8 %29 to i32
  %and29 = and i32 %conv28, 7
  %cmp30 = icmp eq i32 %and29, 6
  br i1 %cmp30, label %if.then32, label %if.else156

if.then32:                                        ; preds = %lor.lhs.false, %if.end16
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %31 = load i32, i32* %t, align 4
  %idxprom33 = sext i32 %31 to i64
  %arrayidx34 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %30, i64 %idxprom33
  %code35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx34, i32 0, i32 0
  %32 = load i8, i8* %code35, align 4
  %conv36 = zext i8 %32 to i32
  %and37 = and i32 %conv36, 240
  %conv38 = trunc i32 %and37 to i8
  store i8 %conv38, i8* %opcode, align 1
  %33 = load i8, i8* %opcode, align 1
  %conv39 = zext i8 %33 to i32
  %cmp40 = icmp eq i32 %conv39, 144
  br i1 %cmp40, label %if.then42, label %if.else

if.then42:                                        ; preds = %if.then32
  br label %mark_explored

if.else:                                          ; preds = %if.then32
  %34 = load i8, i8* %opcode, align 1
  %conv43 = zext i8 %34 to i32
  %cmp44 = icmp eq i32 %conv43, 128
  br i1 %cmp44, label %if.then46, label %if.else84

if.then46:                                        ; preds = %if.else
  %35 = load i32, i32* %t, align 4
  %36 = load i32, i32* %t, align 4
  %add = add i32 %36, 1
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call47 = call i32 @push_insn(i32 noundef %35, i32 noundef %add, i32 noundef 1, %struct.bpf_verifier_env* noundef %37, i1 noundef zeroext false) #11
  store i32 %call47, i32* %ret, align 4
  %38 = load i32, i32* %ret, align 4
  %cmp48 = icmp eq i32 %38, 1
  br i1 %cmp48, label %if.then50, label %if.else51

if.then50:                                        ; preds = %if.then46
  br label %peek_stack

if.else51:                                        ; preds = %if.then46
  %39 = load i32, i32* %ret, align 4
  %cmp52 = icmp slt i32 %39, 0
  br i1 %cmp52, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.else51
  br label %err_free

if.end55:                                         ; preds = %if.else51
  br label %if.end56

if.end56:                                         ; preds = %if.end55
  %40 = load i32, i32* %t, align 4
  %add57 = add i32 %40, 1
  %41 = load i32, i32* %insn_cnt, align 4
  %cmp58 = icmp slt i32 %add57, %41
  br i1 %cmp58, label %if.then60, label %if.end62

if.then60:                                        ; preds = %if.end56
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %43 = load i32, i32* %t, align 4
  %add61 = add i32 %43, 1
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %42, i32 noundef %add61) #11
  br label %if.end62

if.end62:                                         ; preds = %if.then60, %if.end56
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %45 = load i32, i32* %t, align 4
  %idxprom63 = sext i32 %45 to i64
  %arrayidx64 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %44, i64 %idxprom63
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx64, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv65 = zext i8 %bf.lshr to i32
  %cmp66 = icmp eq i32 %conv65, 1
  br i1 %cmp66, label %if.then68, label %if.end83

if.then68:                                        ; preds = %if.end62
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = load i32, i32* %t, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %46, i32 noundef %47) #11
  %48 = load i32, i32* %t, align 4
  %49 = load i32, i32* %t, align 4
  %50 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %51 = load i32, i32* %t, align 4
  %idxprom69 = sext i32 %51 to i64
  %arrayidx70 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %50, i64 %idxprom69
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx70, i32 0, i32 3
  %52 = load i32, i32* %imm, align 4
  %add71 = add i32 %49, %52
  %add72 = add i32 %add71, 1
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call73 = call i32 @push_insn(i32 noundef %48, i32 noundef %add72, i32 noundef 2, %struct.bpf_verifier_env* noundef %53, i1 noundef zeroext false) #11
  store i32 %call73, i32* %ret, align 4
  %54 = load i32, i32* %ret, align 4
  %cmp74 = icmp eq i32 %54, 1
  br i1 %cmp74, label %if.then76, label %if.else77

if.then76:                                        ; preds = %if.then68
  br label %peek_stack

if.else77:                                        ; preds = %if.then68
  %55 = load i32, i32* %ret, align 4
  %cmp78 = icmp slt i32 %55, 0
  br i1 %cmp78, label %if.then80, label %if.end81

if.then80:                                        ; preds = %if.else77
  br label %err_free

if.end81:                                         ; preds = %if.else77
  br label %if.end82

if.end82:                                         ; preds = %if.end81
  br label %if.end83

if.end83:                                         ; preds = %if.end82, %if.end62
  br label %if.end154

if.else84:                                        ; preds = %if.else
  %56 = load i8, i8* %opcode, align 1
  %conv85 = zext i8 %56 to i32
  %cmp86 = icmp eq i32 %conv85, 0
  br i1 %cmp86, label %if.then88, label %if.else125

if.then88:                                        ; preds = %if.else84
  %57 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %58 = load i32, i32* %t, align 4
  %idxprom89 = sext i32 %58 to i64
  %arrayidx90 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %57, i64 %idxprom89
  %code91 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx90, i32 0, i32 0
  %59 = load i8, i8* %code91, align 4
  %conv92 = zext i8 %59 to i32
  %and93 = and i32 %conv92, 8
  %cmp94 = icmp ne i32 %and93, 0
  br i1 %cmp94, label %if.then96, label %if.end97

if.then96:                                        ; preds = %if.then88
  store i32 -22, i32* %ret, align 4
  br label %err_free

if.end97:                                         ; preds = %if.then88
  %60 = load i32, i32* %t, align 4
  %61 = load i32, i32* %t, align 4
  %62 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %63 = load i32, i32* %t, align 4
  %idxprom98 = sext i32 %63 to i64
  %arrayidx99 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %62, i64 %idxprom98
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx99, i32 0, i32 2
  %64 = load i16, i16* %off, align 2
  %conv100 = sext i16 %64 to i32
  %add101 = add i32 %61, %conv100
  %add102 = add i32 %add101, 1
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call103 = call i32 @push_insn(i32 noundef %60, i32 noundef %add102, i32 noundef 1, %struct.bpf_verifier_env* noundef %65, i1 noundef zeroext true) #11
  store i32 %call103, i32* %ret, align 4
  %66 = load i32, i32* %ret, align 4
  %cmp104 = icmp eq i32 %66, 1
  br i1 %cmp104, label %if.then106, label %if.else107

if.then106:                                       ; preds = %if.end97
  br label %peek_stack

if.else107:                                       ; preds = %if.end97
  %67 = load i32, i32* %ret, align 4
  %cmp108 = icmp slt i32 %67, 0
  br i1 %cmp108, label %if.then110, label %if.end111

if.then110:                                       ; preds = %if.else107
  br label %err_free

if.end111:                                        ; preds = %if.else107
  br label %if.end112

if.end112:                                        ; preds = %if.end111
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %69 = load i32, i32* %t, align 4
  %70 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %71 = load i32, i32* %t, align 4
  %idxprom113 = sext i32 %71 to i64
  %arrayidx114 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %70, i64 %idxprom113
  %off115 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx114, i32 0, i32 2
  %72 = load i16, i16* %off115, align 2
  %conv116 = sext i16 %72 to i32
  %add117 = add i32 %69, %conv116
  %add118 = add i32 %add117, 1
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %68, i32 noundef %add118) #11
  %73 = load i32, i32* %t, align 4
  %add119 = add i32 %73, 1
  %74 = load i32, i32* %insn_cnt, align 4
  %cmp120 = icmp slt i32 %add119, %74
  br i1 %cmp120, label %if.then122, label %if.end124

if.then122:                                       ; preds = %if.end112
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = load i32, i32* %t, align 4
  %add123 = add i32 %76, 1
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %75, i32 noundef %add123) #11
  br label %if.end124

if.end124:                                        ; preds = %if.then122, %if.end112
  br label %if.end153

if.else125:                                       ; preds = %if.else84
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %78 = load i32, i32* %t, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %77, i32 noundef %78) #11
  %79 = load i32, i32* %t, align 4
  %80 = load i32, i32* %t, align 4
  %add126 = add i32 %80, 1
  %81 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call127 = call i32 @push_insn(i32 noundef %79, i32 noundef %add126, i32 noundef 1, %struct.bpf_verifier_env* noundef %81, i1 noundef zeroext true) #11
  store i32 %call127, i32* %ret, align 4
  %82 = load i32, i32* %ret, align 4
  %cmp128 = icmp eq i32 %82, 1
  br i1 %cmp128, label %if.then130, label %if.else131

if.then130:                                       ; preds = %if.else125
  br label %peek_stack

if.else131:                                       ; preds = %if.else125
  %83 = load i32, i32* %ret, align 4
  %cmp132 = icmp slt i32 %83, 0
  br i1 %cmp132, label %if.then134, label %if.end135

if.then134:                                       ; preds = %if.else131
  br label %err_free

if.end135:                                        ; preds = %if.else131
  br label %if.end136

if.end136:                                        ; preds = %if.end135
  %84 = load i32, i32* %t, align 4
  %85 = load i32, i32* %t, align 4
  %86 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %87 = load i32, i32* %t, align 4
  %idxprom137 = sext i32 %87 to i64
  %arrayidx138 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %86, i64 %idxprom137
  %off139 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx138, i32 0, i32 2
  %88 = load i16, i16* %off139, align 2
  %conv140 = sext i16 %88 to i32
  %add141 = add i32 %85, %conv140
  %add142 = add i32 %add141, 1
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call143 = call i32 @push_insn(i32 noundef %84, i32 noundef %add142, i32 noundef 2, %struct.bpf_verifier_env* noundef %89, i1 noundef zeroext true) #11
  store i32 %call143, i32* %ret, align 4
  %90 = load i32, i32* %ret, align 4
  %cmp144 = icmp eq i32 %90, 1
  br i1 %cmp144, label %if.then146, label %if.else147

if.then146:                                       ; preds = %if.end136
  br label %peek_stack

if.else147:                                       ; preds = %if.end136
  %91 = load i32, i32* %ret, align 4
  %cmp148 = icmp slt i32 %91, 0
  br i1 %cmp148, label %if.then150, label %if.end151

if.then150:                                       ; preds = %if.else147
  br label %err_free

if.end151:                                        ; preds = %if.else147
  br label %if.end152

if.end152:                                        ; preds = %if.end151
  br label %if.end153

if.end153:                                        ; preds = %if.end152, %if.end124
  br label %if.end154

if.end154:                                        ; preds = %if.end153, %if.end83
  br label %if.end155

if.end155:                                        ; preds = %if.end154
  br label %if.end168

if.else156:                                       ; preds = %lor.lhs.false
  %92 = load i32, i32* %t, align 4
  %93 = load i32, i32* %t, align 4
  %add157 = add i32 %93, 1
  %94 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call158 = call i32 @push_insn(i32 noundef %92, i32 noundef %add157, i32 noundef 1, %struct.bpf_verifier_env* noundef %94, i1 noundef zeroext false) #11
  store i32 %call158, i32* %ret, align 4
  %95 = load i32, i32* %ret, align 4
  %cmp159 = icmp eq i32 %95, 1
  br i1 %cmp159, label %if.then161, label %if.else162

if.then161:                                       ; preds = %if.else156
  br label %peek_stack

if.else162:                                       ; preds = %if.else156
  %96 = load i32, i32* %ret, align 4
  %cmp163 = icmp slt i32 %96, 0
  br i1 %cmp163, label %if.then165, label %if.end166

if.then165:                                       ; preds = %if.else162
  br label %err_free

if.end166:                                        ; preds = %if.else162
  br label %if.end167

if.end167:                                        ; preds = %if.end166
  br label %if.end168

if.end168:                                        ; preds = %if.end167, %if.end155
  br label %mark_explored

mark_explored:                                    ; preds = %if.end168, %if.then42
  %97 = load i32*, i32** %insn_state, align 8
  %98 = load i32, i32* %t, align 4
  %idxprom169 = sext i32 %98 to i64
  %arrayidx170 = getelementptr i32, i32* %97, i64 %idxprom169
  store i32 32, i32* %arrayidx170, align 4
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg171 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %99, i32 0, i32 24
  %cur_stack172 = getelementptr inbounds %struct.anon.178, %struct.anon.178* %cfg171, i32 0, i32 2
  %100 = load i32, i32* %cur_stack172, align 8
  %dec = add i32 %100, -1
  store i32 %dec, i32* %cur_stack172, align 8
  %cmp173 = icmp sle i32 %100, 0
  br i1 %cmp173, label %if.then175, label %if.end176

if.then175:                                       ; preds = %mark_explored
  %101 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %102 = bitcast %struct.bpf_verifier_env* %101 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %102, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.84, i64 0, i64 0)) #11
  store i32 -14, i32* %ret, align 4
  br label %err_free

if.end176:                                        ; preds = %mark_explored
  br label %peek_stack

check_state:                                      ; preds = %if.then15
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %check_state
  %103 = load i32, i32* %i, align 4
  %104 = load i32, i32* %insn_cnt, align 4
  %cmp177 = icmp slt i32 %103, %104
  br i1 %cmp177, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %105 = load i32*, i32** %insn_state, align 8
  %106 = load i32, i32* %i, align 4
  %idxprom179 = sext i32 %106 to i64
  %arrayidx180 = getelementptr i32, i32* %105, i64 %idxprom179
  %107 = load i32, i32* %arrayidx180, align 4
  %cmp181 = icmp ne i32 %107, 32
  br i1 %cmp181, label %if.then183, label %if.end184

if.then183:                                       ; preds = %for.body
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %109 = bitcast %struct.bpf_verifier_env* %108 to i8*
  %110 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %109, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.85, i64 0, i64 0), i32 noundef %110) #11
  store i32 -22, i32* %ret, align 4
  br label %err_free

if.end184:                                        ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end184
  %111 = load i32, i32* %i, align 4
  %inc = add i32 %111, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %ret, align 4
  br label %err_free

err_free:                                         ; preds = %for.end, %if.then183, %if.then175, %if.then165, %if.then150, %if.then134, %if.then110, %if.then96, %if.then80, %if.then54
  %112 = load i32*, i32** %insn_state, align 8
  %113 = bitcast i32* %112 to i8*
  call void @kvfree(i8* noundef %113) #11
  %114 = load i32*, i32** %insn_stack, align 8
  %115 = bitcast i32* %114 to i8*
  call void @kvfree(i8* noundef %115) #11
  %116 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg185 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %116, i32 0, i32 24
  %insn_stack186 = getelementptr inbounds %struct.anon.178, %struct.anon.178* %cfg185, i32 0, i32 1
  store i32* null, i32** %insn_stack186, align 8
  %117 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg187 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %117, i32 0, i32 24
  %insn_state188 = getelementptr inbounds %struct.anon.178, %struct.anon.178* %cfg187, i32 0, i32 0
  store i32* null, i32** %insn_state188, align 8
  %118 = load i32, i32* %ret, align 4
  store i32 %118, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free, %if.then8, %if.then
  %119 = load i32, i32* %retval, align 4
  ret i32 %119
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux = alloca %struct.bpf_prog_aux*, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 7
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1, align 8
  store %struct.bpf_prog_aux* %2, %struct.bpf_prog_aux** %aux, align 8
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 45
  %4 = load %struct.util_est*, %struct.util_est** %func_info, align 8
  %tobool = icmp ne %struct.util_est* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, i32* %i, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 26
  %7 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %5, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_aux = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %8, i32 0, i32 46
  %9 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %10 = load i32, i32* %i, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %9, i64 %idxprom
  %linkage = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx, i32 0, i32 0
  %11 = load i16, i16* %linkage, align 2
  %conv = zext i16 %11 to i32
  %cmp2 = icmp ne i32 %conv, 1
  br i1 %cmp2, label %if.then4, label %if.end5

if.then4:                                         ; preds = %for.body
  br label %for.inc

if.end5:                                          ; preds = %for.body
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 23
  %13 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom6
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx7, i32 0, i32 0
  %14 = load i32, i32* %start, align 8
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 0
  store i32 %14, i32* %insn_idx, align 8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx8 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 0
  %17 = load i32, i32* %insn_idx8, align 8
  %cmp9 = icmp eq i32 %17, 0
  %lnot = xor i1 %cmp9, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %18 = load i32, i32* %__ret_warn_on, align 4
  %tobool12 = icmp ne i32 %18, 0
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %tobool18 = icmp ne i64 %conv17, 0
  br i1 %tobool18, label %if.then19, label %if.end26

if.then19:                                        ; preds = %if.end5
  br label %do.body

do.body:                                          ; preds = %if.then19
  br label %do.body20

do.body20:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body20
  br label %do.body21

do.body21:                                        ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 13302, i32 2307, i64 12) #10, !srcloc !14
  br label %do.end22

do.end22:                                         ; preds = %do.body21
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 505) #10, !srcloc !15
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  br label %do.end24

do.end24:                                         ; preds = %do.body23
  br label %do.end25

do.end25:                                         ; preds = %do.end24
  br label %if.end26

if.end26:                                         ; preds = %do.end25, %if.end5
  %19 = load i32, i32* %__ret_warn_on, align 4
  %tobool27 = icmp ne i32 %19, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  store i64 %conv32, i64* %tmp, align 8
  %20 = load i64, i64* %tmp, align 8
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load i32, i32* %i, align 4
  %call = call i32 @do_check_common(%struct.bpf_verifier_env* noundef %21, i32 noundef %22) #11
  store i32 %call, i32* %ret, align 4
  %23 = load i32, i32* %ret, align 4
  %tobool33 = icmp ne i32 %23, 0
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.end26
  %24 = load i32, i32* %ret, align 4
  store i32 %24, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end26
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 22
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %26 = load i32, i32* %level, align 8
  %and = and i32 %26, 3
  %tobool35 = icmp ne i32 %and, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.else
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = bitcast %struct.bpf_verifier_env* %27 to i8*
  %29 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %28, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.90, i64 0, i64 0), i32 noundef %29) #11
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %if.else
  br label %if.end38

if.end38:                                         ; preds = %if.end37
  br label %for.inc

for.inc:                                          ; preds = %if.end38, %if.then4
  %30 = load i32, i32* %i, align 4
  %inc = add i32 %30, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then34, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check_main(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ret = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 0
  store i32 0, i32* %insn_idx, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @do_check_common(%struct.bpf_verifier_env* noundef %1, i32 noundef 0) #11
  store i32 %call, i32* %ret, align 4
  %2 = load i32, i32* %ret, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 23
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %4 = load i16, i16* %stack_depth, align 8
  %conv = zext i16 %4 to i32
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 7
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %stack_depth1 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 5
  store i32 %conv, i32* %stack_depth1, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i32, i32* %ret, align 4
  ret i32 %8
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_offload_finalize(%struct.bpf_verifier_env* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @kvfree(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_max_stack_depth(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %depth = alloca i32, align 4
  %frame = alloca i32, align 4
  %idx = alloca i32, align 4
  %i = alloca i32, align 4
  %subprog_end = alloca i32, align 4
  %subprog = alloca %struct.bpf_subprog_info*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %tail_call_reachable = alloca i8, align 1
  %ret_insn = alloca [8 x i32], align 16
  %ret_prog = alloca [8 x i32], align 16
  %j = alloca i32, align 4
  %__UNIQUE_ID___x420 = alloca i32, align 4
  %__UNIQUE_ID___y421 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp73 = alloca i64, align 8
  %tmp81 = alloca i64, align 8
  %__UNIQUE_ID___x423 = alloca i32, align 4
  %__UNIQUE_ID___y424 = alloca i32, align 4
  %tmp123 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 0, i32* %depth, align 4
  store i32 0, i32* %frame, align 4
  store i32 0, i32* %idx, align 4
  store i32 0, i32* %i, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 23
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %subprog, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 11
  %arraydecay1 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay1, %struct.bpf_insn** %insn, align 8
  store i8 0, i8* %tail_call_reachable, align 1
  br label %process_func

process_func:                                     ; preds = %if.end98, %entry
  %3 = load i32, i32* %idx, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %process_func
  %4 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %5 = load i32, i32* %idx, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %4, i64 %idxprom
  %has_tail_call = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 3
  %6 = load i8, i8* %has_tail_call, align 2
  %tobool2 = trunc i8 %6 to i1
  br i1 %tobool2, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %7 = load i32, i32* %depth, align 4
  %cmp = icmp sge i32 %7, 256
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true3
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  %10 = load i32, i32* %depth, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([86 x i8], [86 x i8]* @.str.374, i64 0, i64 0), i32 noundef %10) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %process_func
  %11 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %12 = load i32, i32* %idx, align 4
  %idxprom4 = sext i32 %12 to i64
  %arrayidx5 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %11, i64 %idxprom4
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx5, i32 0, i32 2
  %13 = load i16, i16* %stack_depth, align 4
  %conv = zext i16 %13 to i32
  store i32 %conv, i32* %__UNIQUE_ID___x420, align 4
  store i32 1, i32* %__UNIQUE_ID___y421, align 4
  %14 = load i32, i32* %__UNIQUE_ID___x420, align 4
  %15 = load i32, i32* %__UNIQUE_ID___y421, align 4
  %cmp6 = icmp ugt i32 %14, %15
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %16 = load i32, i32* %__UNIQUE_ID___x420, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %17 = load i32, i32* %__UNIQUE_ID___y421, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %16, %cond.true ], [ %17, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %18 = load i32, i32* %tmp, align 4
  %sub = sub i32 %18, 1
  %or = or i32 %sub, 31
  %add = add i32 %or, 1
  %19 = load i32, i32* %depth, align 4
  %add8 = add i32 %19, %add
  store i32 %add8, i32* %depth, align 4
  %20 = load i32, i32* %depth, align 4
  %cmp9 = icmp sgt i32 %20, 512
  br i1 %cmp9, label %if.then11, label %if.end13

if.then11:                                        ; preds = %cond.end
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  %23 = load i32, i32* %frame, align 4
  %add12 = add i32 %23, 1
  %24 = load i32, i32* %depth, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.375, i64 0, i64 0), i32 noundef %add12, i32 noundef %24) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %cond.end
  br label %continue_func

continue_func:                                    ; preds = %cond.end128, %if.end13
  %25 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %26 = load i32, i32* %idx, align 4
  %add14 = add i32 %26, 1
  %idxprom15 = sext i32 %add14 to i64
  %arrayidx16 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %25, i64 %idxprom15
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx16, i32 0, i32 0
  %27 = load i32, i32* %start, align 4
  store i32 %27, i32* %subprog_end, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %continue_func
  %28 = load i32, i32* %i, align 4
  %29 = load i32, i32* %subprog_end, align 4
  %cmp17 = icmp slt i32 %28, %29
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom19 = sext i32 %31 to i64
  %arrayidx20 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %30, i64 %idxprom19
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx20, i32 0, i32 0
  %32 = load i8, i8* %code, align 4
  %conv21 = zext i8 %32 to i32
  %cmp22 = icmp ne i32 %conv21, 133
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %for.body
  br label %for.inc

if.end25:                                         ; preds = %for.body
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %34 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %34 to i64
  %arrayidx27 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %33, i64 %idxprom26
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx27, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv28 = zext i8 %bf.lshr to i32
  %cmp29 = icmp ne i32 %conv28, 1
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end25
  br label %for.inc

if.end32:                                         ; preds = %if.end25
  %35 = load i32, i32* %i, align 4
  %add33 = add i32 %35, 1
  %36 = load i32, i32* %frame, align 4
  %idxprom34 = sext i32 %36 to i64
  %arrayidx35 = getelementptr [8 x i32], [8 x i32]* %ret_insn, i64 0, i64 %idxprom34
  store i32 %add33, i32* %arrayidx35, align 4
  %37 = load i32, i32* %idx, align 4
  %38 = load i32, i32* %frame, align 4
  %idxprom36 = sext i32 %38 to i64
  %arrayidx37 = getelementptr [8 x i32], [8 x i32]* %ret_prog, i64 0, i64 %idxprom36
  store i32 %37, i32* %arrayidx37, align 4
  %39 = load i32, i32* %i, align 4
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %41 = load i32, i32* %i, align 4
  %idxprom38 = sext i32 %41 to i64
  %arrayidx39 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %40, i64 %idxprom38
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx39, i32 0, i32 3
  %42 = load i32, i32* %imm, align 4
  %add40 = add i32 %39, %42
  %add41 = add i32 %add40, 1
  store i32 %add41, i32* %i, align 4
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = load i32, i32* %i, align 4
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %43, i32 noundef %44) #11
  store i32 %call, i32* %idx, align 4
  %45 = load i32, i32* %idx, align 4
  %cmp42 = icmp slt i32 %45, 0
  br i1 %cmp42, label %if.then44, label %if.end88

if.then44:                                        ; preds = %if.end32
  store i32 1, i32* %__ret_warn_once, align 4
  %46 = load i32, i32* %__ret_warn_once, align 4
  %tobool45 = icmp ne i32 %46, 0
  br i1 %tobool45, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then44
  %47 = load i8, i8* @check_max_stack_depth.__warned, align 1
  %tobool46 = trunc i8 %47 to i1
  %lnot = xor i1 %tobool46, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then44
  %48 = phi i1 [ false, %if.then44 ], [ %lnot, %land.rhs ]
  %lnot47 = xor i1 %48, true
  %lnot48 = xor i1 %lnot47, true
  %lnot.ext = zext i1 %lnot48 to i32
  %conv49 = sext i32 %lnot.ext to i64
  %tobool50 = icmp ne i64 %conv49, 0
  br i1 %tobool50, label %if.then51, label %if.end80

if.then51:                                        ; preds = %land.end
  store i8 1, i8* @check_max_stack_depth.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %49 = load i32, i32* %__ret_warn_on, align 4
  %tobool52 = icmp ne i32 %49, 0
  %lnot53 = xor i1 %tobool52, true
  %lnot55 = xor i1 %lnot53, true
  %lnot.ext56 = zext i1 %lnot55 to i32
  %conv57 = sext i32 %lnot.ext56 to i64
  %tobool58 = icmp ne i64 %conv57, 0
  br i1 %tobool58, label %if.then59, label %if.end72

if.then59:                                        ; preds = %if.then51
  br label %do.body

do.body:                                          ; preds = %if.then59
  br label %do.body60

do.body60:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body60
  %50 = load i32, i32* %i, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.283, i64 0, i64 0), i32 noundef %50) #11
  br label %do.body61

do.body61:                                        ; preds = %do.end
  br label %do.body62

do.body62:                                        ; preds = %do.body61
  br label %do.end63

do.end63:                                         ; preds = %do.body62
  br label %do.body64

do.body64:                                        ; preds = %do.end63
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 3173, i32 2313, i64 12) #10, !srcloc !16
  br label %do.end65

do.end65:                                         ; preds = %do.body64
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 422) #10, !srcloc !17
  br label %do.body66

do.body66:                                        ; preds = %do.end65
  br label %do.end67

do.end67:                                         ; preds = %do.body66
  br label %do.end68

do.end68:                                         ; preds = %do.end67
  br label %do.body69

do.body69:                                        ; preds = %do.end68
  br label %do.end70

do.end70:                                         ; preds = %do.body69
  br label %do.end71

do.end71:                                         ; preds = %do.end70
  br label %if.end72

if.end72:                                         ; preds = %do.end71, %if.then51
  %51 = load i32, i32* %__ret_warn_on, align 4
  %tobool74 = icmp ne i32 %51, 0
  %lnot75 = xor i1 %tobool74, true
  %lnot77 = xor i1 %lnot75, true
  %lnot.ext78 = zext i1 %lnot77 to i32
  %conv79 = sext i32 %lnot.ext78 to i64
  store i64 %conv79, i64* %tmp73, align 8
  %52 = load i64, i64* %tmp73, align 8
  br label %if.end80

if.end80:                                         ; preds = %if.end72, %land.end
  %53 = load i32, i32* %__ret_warn_once, align 4
  %tobool82 = icmp ne i32 %53, 0
  %lnot83 = xor i1 %tobool82, true
  %lnot85 = xor i1 %lnot83, true
  %lnot.ext86 = zext i1 %lnot85 to i32
  %conv87 = sext i32 %lnot.ext86 to i64
  store i64 %conv87, i64* %tmp81, align 8
  %54 = load i64, i64* %tmp81, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end88:                                         ; preds = %if.end32
  %55 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %56 = load i32, i32* %idx, align 4
  %idxprom89 = sext i32 %56 to i64
  %arrayidx90 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %55, i64 %idxprom89
  %has_tail_call91 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx90, i32 0, i32 3
  %57 = load i8, i8* %has_tail_call91, align 2
  %tobool92 = trunc i8 %57 to i1
  br i1 %tobool92, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.end88
  store i8 1, i8* %tail_call_reachable, align 1
  br label %if.end94

if.end94:                                         ; preds = %if.then93, %if.end88
  %58 = load i32, i32* %frame, align 4
  %inc = add i32 %58, 1
  store i32 %inc, i32* %frame, align 4
  %59 = load i32, i32* %frame, align 4
  %cmp95 = icmp sge i32 %59, 8
  br i1 %cmp95, label %if.then97, label %if.end98

if.then97:                                        ; preds = %if.end94
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = bitcast %struct.bpf_verifier_env* %60 to i8*
  %62 = load i32, i32* %frame, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %61, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.376, i64 0, i64 0), i32 noundef %62) #11
  store i32 -7, i32* %retval, align 4
  br label %return

if.end98:                                         ; preds = %if.end94
  br label %process_func

for.inc:                                          ; preds = %if.then31, %if.then24
  %63 = load i32, i32* %i, align 4
  %inc99 = add i32 %63, 1
  store i32 %inc99, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %64 = load i8, i8* %tail_call_reachable, align 1
  %tobool100 = trunc i8 %64 to i1
  br i1 %tobool100, label %if.then101, label %if.end114

if.then101:                                       ; preds = %for.end
  store i32 0, i32* %j, align 4
  br label %for.cond102

for.cond102:                                      ; preds = %for.inc111, %if.then101
  %65 = load i32, i32* %j, align 4
  %66 = load i32, i32* %frame, align 4
  %cmp103 = icmp slt i32 %65, %66
  br i1 %cmp103, label %for.body105, label %for.end113

for.body105:                                      ; preds = %for.cond102
  %67 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %68 = load i32, i32* %j, align 4
  %idxprom106 = sext i32 %68 to i64
  %arrayidx107 = getelementptr [8 x i32], [8 x i32]* %ret_prog, i64 0, i64 %idxprom106
  %69 = load i32, i32* %arrayidx107, align 4
  %idxprom108 = sext i32 %69 to i64
  %arrayidx109 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %67, i64 %idxprom108
  %tail_call_reachable110 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx109, i32 0, i32 4
  store i8 1, i8* %tail_call_reachable110, align 1
  br label %for.inc111

for.inc111:                                       ; preds = %for.body105
  %70 = load i32, i32* %j, align 4
  %inc112 = add i32 %70, 1
  store i32 %inc112, i32* %j, align 4
  br label %for.cond102

for.end113:                                       ; preds = %for.cond102
  br label %if.end114

if.end114:                                        ; preds = %for.end113, %for.end
  %71 = load i32, i32* %frame, align 4
  %cmp115 = icmp eq i32 %71, 0
  br i1 %cmp115, label %if.then117, label %if.end118

if.then117:                                       ; preds = %if.end114
  store i32 0, i32* %retval, align 4
  br label %return

if.end118:                                        ; preds = %if.end114
  %72 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %subprog, align 8
  %73 = load i32, i32* %idx, align 4
  %idxprom119 = sext i32 %73 to i64
  %arrayidx120 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %72, i64 %idxprom119
  %stack_depth121 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx120, i32 0, i32 2
  %74 = load i16, i16* %stack_depth121, align 4
  %conv122 = zext i16 %74 to i32
  store i32 %conv122, i32* %__UNIQUE_ID___x423, align 4
  store i32 1, i32* %__UNIQUE_ID___y424, align 4
  %75 = load i32, i32* %__UNIQUE_ID___x423, align 4
  %76 = load i32, i32* %__UNIQUE_ID___y424, align 4
  %cmp124 = icmp ugt i32 %75, %76
  br i1 %cmp124, label %cond.true126, label %cond.false127

cond.true126:                                     ; preds = %if.end118
  %77 = load i32, i32* %__UNIQUE_ID___x423, align 4
  br label %cond.end128

cond.false127:                                    ; preds = %if.end118
  %78 = load i32, i32* %__UNIQUE_ID___y424, align 4
  br label %cond.end128

cond.end128:                                      ; preds = %cond.false127, %cond.true126
  %cond129 = phi i32 [ %77, %cond.true126 ], [ %78, %cond.false127 ]
  store i32 %cond129, i32* %tmp123, align 4
  %79 = load i32, i32* %tmp123, align 4
  %sub130 = sub i32 %79, 1
  %or131 = or i32 %sub130, 31
  %add132 = add i32 %or131, 1
  %80 = load i32, i32* %depth, align 4
  %sub133 = sub i32 %80, %add132
  store i32 %sub133, i32* %depth, align 4
  %81 = load i32, i32* %frame, align 4
  %dec = add i32 %81, -1
  store i32 %dec, i32* %frame, align 4
  %82 = load i32, i32* %frame, align 4
  %idxprom134 = sext i32 %82 to i64
  %arrayidx135 = getelementptr [8 x i32], [8 x i32]* %ret_insn, i64 0, i64 %idxprom134
  %83 = load i32, i32* %arrayidx135, align 4
  store i32 %83, i32* %i, align 4
  %84 = load i32, i32* %frame, align 4
  %idxprom136 = sext i32 %84 to i64
  %arrayidx137 = getelementptr [8 x i32], [8 x i32]* %ret_prog, i64 0, i64 %idxprom136
  %85 = load i32, i32* %arrayidx137, align 4
  store i32 %85, i32* %idx, align 4
  br label %continue_func

return:                                           ; preds = %if.then117, %if.then97, %if.end80, %if.then11, %if.then
  %86 = load i32, i32* %retval, align 4
  ret i32 %86
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @opt_hard_wire_dead_code_branches(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %ja = alloca %struct.bpf_insn, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 20
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = bitcast %struct.bpf_insn* %ja to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %2, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.opt_hard_wire_dead_code_branches.ja, i32 0, i32 0), i64 8, i1 false)
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 4
  %7 = load i32, i32* %len, align 4
  store i32 %7, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, i32* %i, align 4
  %9 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %10, i32 0, i32 0
  %11 = load i8, i8* %code, align 4
  %call = call zeroext i1 @insn_is_cond_jump(i8 noundef zeroext %11) #11
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %12 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %13 = load i32, i32* %i, align 4
  %add = add i32 %13, 1
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %12, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 4
  %14 = load i32, i32* %seen, align 8
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.end
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 2
  %16 = load i16, i16* %off, align 2
  %off3 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %ja, i32 0, i32 2
  store i16 %16, i16* %off3, align 2
  br label %if.end15

if.else:                                          ; preds = %if.end
  %17 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %18 = load i32, i32* %i, align 4
  %add4 = add i32 %18, 1
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off5 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %19, i32 0, i32 2
  %20 = load i16, i16* %off5, align 2
  %conv = sext i16 %20 to i32
  %add6 = add i32 %add4, %conv
  %idxprom7 = sext i32 %add6 to i64
  %arrayidx8 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %17, i64 %idxprom7
  %seen9 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx8, i32 0, i32 4
  %21 = load i32, i32* %seen9, align 8
  %tobool10 = icmp ne i32 %21, 0
  br i1 %tobool10, label %if.else13, label %if.then11

if.then11:                                        ; preds = %if.else
  %off12 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %ja, i32 0, i32 2
  store i16 0, i16* %off12, align 2
  br label %if.end14

if.else13:                                        ; preds = %if.else
  br label %for.inc

if.end14:                                         ; preds = %if.then11
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then2
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 2
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %prog16, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %23, i32 0, i32 7
  %24 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call17 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %24) #11
  br i1 %call17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load i32, i32* %i, align 4
  call void @bpf_prog_offload_replace_insn(%struct.bpf_verifier_env* noundef %25, i32 noundef %26, %struct.bpf_insn* noundef %ja) #11
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end15
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %28 = bitcast %struct.bpf_insn* %27 to i8*
  %29 = bitcast %struct.bpf_insn* %ja to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %28, i8* align 4 %29, i64 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end19, %if.else13, %if.then
  %30 = load i32, i32* %i, align 4
  %inc = add i32 %30, 1
  store i32 %inc, i32* %i, align 4
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %31, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @opt_remove_dead_code(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 20
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %i, align 4
  %6 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.body
  %7 = load i32, i32* %i, align 4
  %8 = load i32, i32* %j, align 4
  %add = add i32 %7, %8
  %9 = load i32, i32* %insn_cnt, align 4
  %cmp1 = icmp slt i32 %add, %9
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %j, align 4
  %add2 = add i32 %11, %12
  %idxprom = sext i32 %add2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %10, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 4
  %13 = load i32, i32* %seen, align 8
  %tobool = icmp ne i32 %13, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %14 = phi i1 [ false, %while.cond ], [ %lnot, %land.rhs ]
  br i1 %14, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %15 = load i32, i32* %j, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %j, align 4
  br label %while.cond

while.end:                                        ; preds = %land.end
  %16 = load i32, i32* %j, align 4
  %tobool3 = icmp ne i32 %16, 0
  br i1 %tobool3, label %if.end, label %if.then

if.then:                                          ; preds = %while.end
  br label %for.inc

if.end:                                           ; preds = %while.end
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %i, align 4
  %19 = load i32, i32* %j, align 4
  %call = call i32 @verifier_remove_insns(%struct.bpf_verifier_env* noundef %17, i32 noundef %18, i32 noundef %19) #11
  store i32 %call, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool4 = icmp ne i32 %20, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %21 = load i32, i32* %err, align 4
  store i32 %21, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 2
  %23 = load %struct.bpf_prog*, %struct.bpf_prog** %prog7, align 8
  %len8 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %23, i32 0, i32 4
  %24 = load i32, i32* %len8, align 4
  store i32 %24, i32* %insn_cnt, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end6, %if.then
  %25 = load i32, i32* %i, align 4
  %inc9 = add i32 %25, 1
  store i32 %inc9, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then5
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @opt_remove_nops(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ja = alloca %struct.bpf_insn, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = bitcast %struct.bpf_insn* %ja to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %0, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.opt_remove_nops.ja, i32 0, i32 0), i64 8, i1 false)
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len, align 4
  store i32 %5, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %9 = load i32, i32* %i, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %8, i64 %idxprom
  %10 = bitcast %struct.bpf_insn* %arrayidx to i8*
  %11 = bitcast %struct.bpf_insn* %ja to i8*
  %call = call i32 @memcmp(i8* noundef %10, i8* noundef %11, i64 noundef 8) #11
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load i32, i32* %i, align 4
  %call2 = call i32 @verifier_remove_insns(%struct.bpf_verifier_env* noundef %12, i32 noundef %13, i32 noundef 1) #11
  store i32 %call2, i32* %err, align 4
  %14 = load i32, i32* %err, align 4
  %tobool3 = icmp ne i32 %14, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %15 = load i32, i32* %err, align 4
  store i32 %15, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %16 = load i32, i32* %insn_cnt, align 4
  %dec = add i32 %16, -1
  store i32 %dec, i32* %insn_cnt, align 4
  %17 = load i32, i32* %i, align 4
  %dec6 = add i32 %17, -1
  store i32 %dec6, i32* %i, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end5, %if.then
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then4
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @sanitize_dead_code(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %trap = alloca %struct.bpf_insn, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 20
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = bitcast %struct.bpf_insn* %trap to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %2, i8* align 4 getelementptr inbounds (%struct.bpf_insn, %struct.bpf_insn* @__const.sanitize_dead_code.trap, i32 0, i32 0), i64 8, i1 false)
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 4
  %7 = load i32, i32* %len, align 4
  store i32 %7, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, i32* %i, align 4
  %9 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %11 = load i32, i32* %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %10, i64 %idxprom
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 4
  %12 = load i32, i32* %seen, align 8
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %14 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %14 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %13, i64 %idx.ext
  %15 = bitcast %struct.bpf_insn* %add.ptr to i8*
  %16 = bitcast %struct.bpf_insn* %trap to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %15, i8* align 4 %16, i64 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %17 = load i32, i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @convert_ctx_accesses(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ops = alloca %struct.bpf_verifier_ops*, align 8
  %i = alloca i32, align 4
  %cnt = alloca i32, align 4
  %size = alloca i32, align 4
  %ctx_field_size = alloca i32, align 4
  %delta = alloca i32, align 4
  %insn_cnt = alloca i32, align 4
  %insn_buf = alloca [16 x %struct.bpf_insn], align 16
  %insn = alloca %struct.bpf_insn*, align 8
  %target_size = alloca i32, align 4
  %size_default = alloca i32, align 4
  %off = alloca i32, align 4
  %new_prog = alloca %struct.bpf_prog*, align 8
  %type = alloca i32, align 4
  %is_narrower_load = alloca i8, align 1
  %convert_ctx_access = alloca i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, align 8
  %patch = alloca [2 x %struct.bpf_insn], align 16
  %__size = alloca i32, align 4
  %bytes = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp190 = alloca i64, align 8
  %tmp197 = alloca i32, align 4
  %size_code = alloca i8, align 1
  %shift = alloca i8, align 1
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %.compoundliteral278 = alloca %struct.bpf_insn, align 4
  %.compoundliteral302 = alloca %struct.bpf_insn, align 4
  %.compoundliteral323 = alloca %struct.bpf_insn, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 3
  %1 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops1, align 8
  store %struct.bpf_verifier_ops* %1, %struct.bpf_verifier_ops** %ops, align 8
  store i32 0, i32* %delta, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  %5 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_prologue = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %5, i32 0, i32 2
  %6 = load i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)** %gen_prologue, align 8
  %tobool = icmp ne i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)* %6, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 19
  %8 = load i8, i8* %seen_direct_write, align 1
  %tobool2 = trunc i8 %8 to i1
  br i1 %tobool2, label %if.then, label %if.end22

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_prologue3 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %9, i32 0, i32 2
  %10 = load i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)** %gen_prologue3, align 8
  %tobool4 = icmp ne i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)* %10, null
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.367, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %13 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_prologue6 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %13, i32 0, i32 2
  %14 = load i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)*, i32 (%struct.bpf_insn*, i1, %struct.bpf_prog*)** %gen_prologue6, align 8
  %arraydecay = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 19
  %16 = load i8, i8* %seen_direct_write7, align 1
  %tobool8 = trunc i8 %16 to i1
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog9 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 2
  %18 = load %struct.bpf_prog*, %struct.bpf_prog** %prog9, align 8
  %call = call i32 %14(%struct.bpf_insn* noundef %arraydecay, i1 noundef zeroext %tobool8, %struct.bpf_prog* noundef %18) #11
  store i32 %call, i32* %cnt, align 4
  %19 = load i32, i32* %cnt, align 4
  %conv = sext i32 %19 to i64
  %cmp = icmp uge i64 %conv, 16
  br i1 %cmp, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.367, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end
  %22 = load i32, i32* %cnt, align 4
  %tobool12 = icmp ne i32 %22, 0
  br i1 %tobool12, label %if.then13, label %if.end20

if.then13:                                        ; preds = %if.else
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %arraydecay14 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %24 = load i32, i32* %cnt, align 4
  %call15 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %23, i32 noundef 0, %struct.bpf_insn* noundef %arraydecay14, i32 noundef %24) #11
  store %struct.bpf_prog* %call15, %struct.bpf_prog** %new_prog, align 8
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool16 = icmp ne %struct.bpf_prog* %25, null
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.then13
  store i32 -12, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.then13
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog19 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 2
  store %struct.bpf_prog* %26, %struct.bpf_prog** %prog19, align 8
  %28 = load i32, i32* %cnt, align 4
  %sub = sub i32 %28, 1
  %29 = load i32, i32* %delta, align 4
  %add = add i32 %29, %sub
  store i32 %add, i32* %delta, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.end18, %if.else
  br label %if.end21

if.end21:                                         ; preds = %if.end20
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %lor.lhs.false
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog23 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 2
  %31 = load %struct.bpf_prog*, %struct.bpf_prog** %prog23, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %31, i32 0, i32 7
  %32 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call24 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %32) #11
  br i1 %call24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end22
  store i32 0, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.end22
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 2
  %34 = load %struct.bpf_prog*, %struct.bpf_prog** %prog27, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %34, i32 0, i32 11
  %arraydecay28 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  %35 = load i32, i32* %delta, align 4
  %idx.ext = sext i32 %35 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay28, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end26
  %36 = load i32, i32* %i, align 4
  %37 = load i32, i32* %insn_cnt, align 4
  %cmp29 = icmp slt i32 %36, %37
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 0
  %39 = load i8, i8* %code, align 4
  %conv31 = zext i8 %39 to i32
  %cmp32 = icmp eq i32 %conv31, 113
  br i1 %cmp32, label %if.then49, label %lor.lhs.false34

lor.lhs.false34:                                  ; preds = %for.body
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %40, i32 0, i32 0
  %41 = load i8, i8* %code35, align 4
  %conv36 = zext i8 %41 to i32
  %cmp37 = icmp eq i32 %conv36, 105
  br i1 %cmp37, label %if.then49, label %lor.lhs.false39

lor.lhs.false39:                                  ; preds = %lor.lhs.false34
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code40 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %42, i32 0, i32 0
  %43 = load i8, i8* %code40, align 4
  %conv41 = zext i8 %43 to i32
  %cmp42 = icmp eq i32 %conv41, 97
  br i1 %cmp42, label %if.then49, label %lor.lhs.false44

lor.lhs.false44:                                  ; preds = %lor.lhs.false39
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code45 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 0
  %45 = load i8, i8* %code45, align 4
  %conv46 = zext i8 %45 to i32
  %cmp47 = icmp eq i32 %conv46, 121
  br i1 %cmp47, label %if.then49, label %if.else50

if.then49:                                        ; preds = %lor.lhs.false44, %lor.lhs.false39, %lor.lhs.false34, %for.body
  store i32 1, i32* %type, align 4
  br label %if.end73

if.else50:                                        ; preds = %lor.lhs.false44
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code51 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 0
  %47 = load i8, i8* %code51, align 4
  %conv52 = zext i8 %47 to i32
  %cmp53 = icmp eq i32 %conv52, 115
  br i1 %cmp53, label %if.then70, label %lor.lhs.false55

lor.lhs.false55:                                  ; preds = %if.else50
  %48 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code56 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %48, i32 0, i32 0
  %49 = load i8, i8* %code56, align 4
  %conv57 = zext i8 %49 to i32
  %cmp58 = icmp eq i32 %conv57, 107
  br i1 %cmp58, label %if.then70, label %lor.lhs.false60

lor.lhs.false60:                                  ; preds = %lor.lhs.false55
  %50 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code61 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %50, i32 0, i32 0
  %51 = load i8, i8* %code61, align 4
  %conv62 = zext i8 %51 to i32
  %cmp63 = icmp eq i32 %conv62, 99
  br i1 %cmp63, label %if.then70, label %lor.lhs.false65

lor.lhs.false65:                                  ; preds = %lor.lhs.false60
  %52 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code66 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %52, i32 0, i32 0
  %53 = load i8, i8* %code66, align 4
  %conv67 = zext i8 %53 to i32
  %cmp68 = icmp eq i32 %conv67, 123
  br i1 %cmp68, label %if.then70, label %if.else71

if.then70:                                        ; preds = %lor.lhs.false65, %lor.lhs.false60, %lor.lhs.false55, %if.else50
  store i32 2, i32* %type, align 4
  br label %if.end72

if.else71:                                        ; preds = %lor.lhs.false65
  br label %for.inc

if.end72:                                         ; preds = %if.then70
  br label %if.end73

if.end73:                                         ; preds = %if.end72, %if.then49
  %54 = load i32, i32* %type, align 4
  %cmp74 = icmp eq i32 %54, 2
  br i1 %cmp74, label %land.lhs.true, label %if.end105

land.lhs.true:                                    ; preds = %if.end73
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %55, i32 0, i32 20
  %56 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %57 = load i32, i32* %i, align 4
  %58 = load i32, i32* %delta, align 4
  %add76 = add i32 %57, %58
  %idxprom = sext i32 %add76 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %56, i64 %idxprom
  %sanitize_stack_off = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 3
  %59 = load i32, i32* %sanitize_stack_off, align 4
  %tobool77 = icmp ne i32 %59, 0
  br i1 %tobool77, label %if.then78, label %if.end105

if.then78:                                        ; preds = %land.lhs.true
  %arrayinit.begin = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %patch, i64 0, i64 0
  %code79 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 0
  store i8 122, i8* %code79, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 10
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %bf.load80 = load i8, i8* %src_reg, align 1
  %bf.clear81 = and i8 %bf.load80, 15
  %bf.set82 = or i8 %bf.clear81, 0
  store i8 %bf.set82, i8* %src_reg, align 1
  %off83 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 2
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data84 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %60, i32 0, i32 20
  %61 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data84, align 8
  %62 = load i32, i32* %i, align 4
  %63 = load i32, i32* %delta, align 4
  %add85 = add i32 %62, %63
  %idxprom86 = sext i32 %add85 to i64
  %arrayidx87 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %61, i64 %idxprom86
  %sanitize_stack_off88 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx87, i32 0, i32 3
  %64 = load i32, i32* %sanitize_stack_off88, align 4
  %conv89 = trunc i32 %64 to i16
  store i16 %conv89, i16* %off83, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %arrayinit.element = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i64 1
  %65 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %66 = bitcast %struct.bpf_insn* %arrayinit.element to i8*
  %67 = bitcast %struct.bpf_insn* %65 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %66, i8* align 4 %67, i64 8, i1 false)
  store i32 2, i32* %cnt, align 4
  %68 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %69 = load i32, i32* %i, align 4
  %70 = load i32, i32* %delta, align 4
  %add90 = add i32 %69, %70
  %arraydecay91 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %patch, i64 0, i64 0
  %71 = load i32, i32* %cnt, align 4
  %call92 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %68, i32 noundef %add90, %struct.bpf_insn* noundef %arraydecay91, i32 noundef %71) #11
  store %struct.bpf_prog* %call92, %struct.bpf_prog** %new_prog, align 8
  %72 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool93 = icmp ne %struct.bpf_prog* %72, null
  br i1 %tobool93, label %if.end95, label %if.then94

if.then94:                                        ; preds = %if.then78
  store i32 -12, i32* %retval, align 4
  br label %return

if.end95:                                         ; preds = %if.then78
  %73 = load i32, i32* %cnt, align 4
  %sub96 = sub i32 %73, 1
  %74 = load i32, i32* %delta, align 4
  %add97 = add i32 %74, %sub96
  store i32 %add97, i32* %delta, align 4
  %75 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog98 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %76, i32 0, i32 2
  store %struct.bpf_prog* %75, %struct.bpf_prog** %prog98, align 8
  %77 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi99 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %77, i32 0, i32 11
  %arraydecay100 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi99, i64 0, i64 0
  %78 = load i32, i32* %i, align 4
  %idx.ext101 = sext i32 %78 to i64
  %add.ptr102 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay100, i64 %idx.ext101
  %79 = load i32, i32* %delta, align 4
  %idx.ext103 = sext i32 %79 to i64
  %add.ptr104 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr102, i64 %idx.ext103
  store %struct.bpf_insn* %add.ptr104, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end105:                                        ; preds = %land.lhs.true, %if.end73
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data106 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %80, i32 0, i32 20
  %81 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data106, align 8
  %82 = load i32, i32* %i, align 4
  %83 = load i32, i32* %delta, align 4
  %add107 = add i32 %82, %83
  %idxprom108 = sext i32 %add107 to i64
  %arrayidx109 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %81, i64 %idxprom108
  %84 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx109, i32 0, i32 0
  %ptr_type = bitcast %struct.atomic64_t* %84 to i32*
  %85 = load i32, i32* %ptr_type, align 8
  switch i32 %85, label %sw.default [
    i32 2, label %sw.bb
    i32 11, label %sw.bb115
    i32 13, label %sw.bb115
    i32 15, label %sw.bb116
    i32 18, label %sw.bb117
    i32 19, label %sw.bb118
  ]

sw.bb:                                            ; preds = %if.end105
  %86 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %convert_ctx_access110 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %86, i32 0, i32 4
  %87 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access110, align 8
  %tobool111 = icmp ne i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* %87, null
  br i1 %tobool111, label %if.end113, label %if.then112

if.then112:                                       ; preds = %sw.bb
  br label %for.inc

if.end113:                                        ; preds = %sw.bb
  %88 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %convert_ctx_access114 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %88, i32 0, i32 4
  %89 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access114, align 8
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* %89, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb115:                                         ; preds = %if.end105, %if.end105
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* @bpf_sock_convert_ctx_access, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb116:                                         ; preds = %if.end105
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* @bpf_tcp_sock_convert_ctx_access, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb117:                                         ; preds = %if.end105
  store i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)* @bpf_xdp_sock_convert_ctx_access, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  br label %sw.epilog

sw.bb118:                                         ; preds = %if.end105
  %90 = load i32, i32* %type, align 4
  %cmp119 = icmp eq i32 %90, 1
  br i1 %cmp119, label %if.then121, label %if.else128

if.then121:                                       ; preds = %sw.bb118
  %91 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code122 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %91, i32 0, i32 0
  %92 = load i8, i8* %code122, align 4
  %conv123 = zext i8 %92 to i32
  %and = and i32 %conv123, 24
  %or = or i32 33, %and
  %conv124 = trunc i32 %or to i8
  %93 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code125 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %93, i32 0, i32 0
  store i8 %conv124, i8* %code125, align 4
  %94 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog126 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %94, i32 0, i32 2
  %95 = load %struct.bpf_prog*, %struct.bpf_prog** %prog126, align 8
  %aux127 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %95, i32 0, i32 7
  %96 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux127, align 8
  %num_exentries = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %96, i32 0, i32 52
  %97 = load i32, i32* %num_exentries, align 4
  %inc = add i32 %97, 1
  store i32 %inc, i32* %num_exentries, align 4
  br label %if.end135

if.else128:                                       ; preds = %sw.bb118
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog129 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %98, i32 0, i32 2
  %99 = load %struct.bpf_prog*, %struct.bpf_prog** %prog129, align 8
  %call130 = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %99) #11
  %cmp131 = icmp ne i32 %call130, 27
  br i1 %cmp131, label %if.then133, label %if.end134

if.then133:                                       ; preds = %if.else128
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %101 = bitcast %struct.bpf_verifier_env* %100 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %101, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.377, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end134:                                        ; preds = %if.else128
  br label %if.end135

if.end135:                                        ; preds = %if.end134, %if.then121
  br label %for.inc

sw.default:                                       ; preds = %if.end105
  br label %for.inc

sw.epilog:                                        ; preds = %sw.bb117, %sw.bb116, %sw.bb115, %if.end113
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data136 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %102, i32 0, i32 20
  %103 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data136, align 8
  %104 = load i32, i32* %i, align 4
  %105 = load i32, i32* %delta, align 4
  %add137 = add i32 %104, %105
  %idxprom138 = sext i32 %add137 to i64
  %arrayidx139 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %103, i64 %idxprom138
  %ctx_field_size140 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx139, i32 0, i32 2
  %106 = load i32, i32* %ctx_field_size140, align 8
  store i32 %106, i32* %ctx_field_size, align 4
  store i32 -22, i32* %bytes, align 4
  %107 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code141 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %107, i32 0, i32 0
  %108 = load i8, i8* %code141, align 4
  %conv142 = zext i8 %108 to i32
  %and143 = and i32 %conv142, 24
  %cmp144 = icmp eq i32 %and143, 16
  br i1 %cmp144, label %if.then146, label %if.else147

if.then146:                                       ; preds = %sw.epilog
  store i32 1, i32* %bytes, align 4
  br label %if.end171

if.else147:                                       ; preds = %sw.epilog
  %109 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code148 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %109, i32 0, i32 0
  %110 = load i8, i8* %code148, align 4
  %conv149 = zext i8 %110 to i32
  %and150 = and i32 %conv149, 24
  %cmp151 = icmp eq i32 %and150, 8
  br i1 %cmp151, label %if.then153, label %if.else154

if.then153:                                       ; preds = %if.else147
  store i32 2, i32* %bytes, align 4
  br label %if.end170

if.else154:                                       ; preds = %if.else147
  %111 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code155 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %111, i32 0, i32 0
  %112 = load i8, i8* %code155, align 4
  %conv156 = zext i8 %112 to i32
  %and157 = and i32 %conv156, 24
  %cmp158 = icmp eq i32 %and157, 0
  br i1 %cmp158, label %if.then160, label %if.else161

if.then160:                                       ; preds = %if.else154
  store i32 4, i32* %bytes, align 4
  br label %if.end169

if.else161:                                       ; preds = %if.else154
  %113 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code162 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %113, i32 0, i32 0
  %114 = load i8, i8* %code162, align 4
  %conv163 = zext i8 %114 to i32
  %and164 = and i32 %conv163, 24
  %cmp165 = icmp eq i32 %and164, 24
  br i1 %cmp165, label %if.then167, label %if.end168

if.then167:                                       ; preds = %if.else161
  store i32 8, i32* %bytes, align 4
  br label %if.end168

if.end168:                                        ; preds = %if.then167, %if.else161
  br label %if.end169

if.end169:                                        ; preds = %if.end168, %if.then160
  br label %if.end170

if.end170:                                        ; preds = %if.end169, %if.then153
  br label %if.end171

if.end171:                                        ; preds = %if.end170, %if.then146
  %115 = load i32, i32* %bytes, align 4
  store i32 %115, i32* %tmp, align 4
  %116 = load i32, i32* %tmp, align 4
  store i32 %116, i32* %__size, align 4
  %117 = load i32, i32* %__size, align 4
  %cmp172 = icmp slt i32 %117, 0
  %lnot = xor i1 %cmp172, true
  %lnot174 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot174 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %118 = load i32, i32* %__ret_warn_on, align 4
  %tobool175 = icmp ne i32 %118, 0
  %lnot176 = xor i1 %tobool175, true
  %lnot178 = xor i1 %lnot176, true
  %lnot.ext179 = zext i1 %lnot178 to i32
  %conv180 = sext i32 %lnot.ext179 to i64
  %tobool181 = icmp ne i64 %conv180, 0
  br i1 %tobool181, label %if.then182, label %if.end189

if.then182:                                       ; preds = %if.end171
  br label %do.body

do.body:                                          ; preds = %if.then182
  br label %do.body183

do.body183:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body183
  br label %do.body184

do.body184:                                       ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 12443, i32 2305, i64 12) #10, !srcloc !18
  br label %do.end185

do.end185:                                        ; preds = %do.body184
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 496) #10, !srcloc !19
  br label %do.body186

do.body186:                                       ; preds = %do.end185
  br label %do.end187

do.end187:                                        ; preds = %do.body186
  br label %do.end188

do.end188:                                        ; preds = %do.end187
  br label %if.end189

if.end189:                                        ; preds = %do.end188, %if.end171
  %119 = load i32, i32* %__ret_warn_on, align 4
  %tobool191 = icmp ne i32 %119, 0
  %lnot192 = xor i1 %tobool191, true
  %lnot194 = xor i1 %lnot192, true
  %lnot.ext195 = zext i1 %lnot194 to i32
  %conv196 = sext i32 %lnot.ext195 to i64
  store i64 %conv196, i64* %tmp190, align 8
  %120 = load i64, i64* %tmp190, align 8
  %121 = load i32, i32* %__size, align 4
  store i32 %121, i32* %tmp197, align 4
  %122 = load i32, i32* %tmp197, align 4
  store i32 %122, i32* %size, align 4
  %123 = load i32, i32* %size, align 4
  %124 = load i32, i32* %ctx_field_size, align 4
  %cmp198 = icmp slt i32 %123, %124
  %frombool = zext i1 %cmp198 to i8
  store i8 %frombool, i8* %is_narrower_load, align 1
  %125 = load i32, i32* %ctx_field_size, align 4
  %call200 = call i32 @bpf_ctx_off_adjust_machine(i32 noundef %125) #11
  store i32 %call200, i32* %size_default, align 4
  %126 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off201 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %126, i32 0, i32 2
  %127 = load i16, i16* %off201, align 2
  %conv202 = sext i16 %127 to i32
  store i32 %conv202, i32* %off, align 4
  %128 = load i8, i8* %is_narrower_load, align 1
  %tobool203 = trunc i8 %128 to i1
  br i1 %tobool203, label %if.then204, label %if.end226

if.then204:                                       ; preds = %if.end189
  %129 = load i32, i32* %type, align 4
  %cmp205 = icmp eq i32 %129, 2
  br i1 %cmp205, label %if.then207, label %if.end208

if.then207:                                       ; preds = %if.then204
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %131 = bitcast %struct.bpf_verifier_env* %130 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %131, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.378, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end208:                                        ; preds = %if.then204
  store i8 8, i8* %size_code, align 1
  %132 = load i32, i32* %ctx_field_size, align 4
  %cmp209 = icmp eq i32 %132, 4
  br i1 %cmp209, label %if.then211, label %if.else212

if.then211:                                       ; preds = %if.end208
  store i8 0, i8* %size_code, align 1
  br label %if.end217

if.else212:                                       ; preds = %if.end208
  %133 = load i32, i32* %ctx_field_size, align 4
  %cmp213 = icmp eq i32 %133, 8
  br i1 %cmp213, label %if.then215, label %if.end216

if.then215:                                       ; preds = %if.else212
  store i8 24, i8* %size_code, align 1
  br label %if.end216

if.end216:                                        ; preds = %if.then215, %if.else212
  br label %if.end217

if.end217:                                        ; preds = %if.end216, %if.then211
  %134 = load i32, i32* %off, align 4
  %135 = load i32, i32* %size_default, align 4
  %sub218 = sub i32 %135, 1
  %neg = xor i32 %sub218, -1
  %and219 = and i32 %134, %neg
  %conv220 = trunc i32 %and219 to i16
  %136 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off221 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %136, i32 0, i32 2
  store i16 %conv220, i16* %off221, align 2
  %137 = load i8, i8* %size_code, align 1
  %conv222 = zext i8 %137 to i32
  %or223 = or i32 97, %conv222
  %conv224 = trunc i32 %or223 to i8
  %138 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code225 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %138, i32 0, i32 0
  store i8 %conv224, i8* %code225, align 4
  br label %if.end226

if.end226:                                        ; preds = %if.end217, %if.end189
  store i32 0, i32* %target_size, align 4
  %139 = load i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)*, i32 (i32, %struct.bpf_insn*, %struct.bpf_insn*, %struct.bpf_prog*, i32*)** %convert_ctx_access, align 8
  %140 = load i32, i32* %type, align 4
  %141 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arraydecay227 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog228 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %142, i32 0, i32 2
  %143 = load %struct.bpf_prog*, %struct.bpf_prog** %prog228, align 8
  %call229 = call i32 %139(i32 noundef %140, %struct.bpf_insn* noundef %141, %struct.bpf_insn* noundef %arraydecay227, %struct.bpf_prog* noundef %143, i32* noundef %target_size) #11
  store i32 %call229, i32* %cnt, align 4
  %144 = load i32, i32* %cnt, align 4
  %cmp230 = icmp eq i32 %144, 0
  br i1 %cmp230, label %if.then240, label %lor.lhs.false232

lor.lhs.false232:                                 ; preds = %if.end226
  %145 = load i32, i32* %cnt, align 4
  %conv233 = sext i32 %145 to i64
  %cmp234 = icmp uge i64 %conv233, 16
  br i1 %cmp234, label %if.then240, label %lor.lhs.false236

lor.lhs.false236:                                 ; preds = %lor.lhs.false232
  %146 = load i32, i32* %ctx_field_size, align 4
  %tobool237 = icmp ne i32 %146, 0
  br i1 %tobool237, label %land.lhs.true238, label %if.end241

land.lhs.true238:                                 ; preds = %lor.lhs.false236
  %147 = load i32, i32* %target_size, align 4
  %tobool239 = icmp ne i32 %147, 0
  br i1 %tobool239, label %if.end241, label %if.then240

if.then240:                                       ; preds = %land.lhs.true238, %lor.lhs.false232, %if.end226
  %148 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %149 = bitcast %struct.bpf_verifier_env* %148 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %149, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.367, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end241:                                        ; preds = %land.lhs.true238, %lor.lhs.false236
  %150 = load i8, i8* %is_narrower_load, align 1
  %tobool242 = trunc i8 %150 to i1
  br i1 %tobool242, label %land.lhs.true244, label %if.end344

land.lhs.true244:                                 ; preds = %if.end241
  %151 = load i32, i32* %size, align 4
  %152 = load i32, i32* %target_size, align 4
  %cmp245 = icmp ult i32 %151, %152
  br i1 %cmp245, label %if.then247, label %if.end344

if.then247:                                       ; preds = %land.lhs.true244
  %153 = load i32, i32* %off, align 4
  %154 = load i32, i32* %size, align 4
  %155 = load i32, i32* %size_default, align 4
  %call248 = call zeroext i8 @bpf_ctx_narrow_access_offset(i32 noundef %153, i32 noundef %154, i32 noundef %155) #11
  %conv249 = zext i8 %call248 to i32
  %mul = mul i32 %conv249, 8
  %conv250 = trunc i32 %mul to i8
  store i8 %conv250, i8* %shift, align 1
  %156 = load i32, i32* %ctx_field_size, align 4
  %cmp251 = icmp sle i32 %156, 4
  br i1 %cmp251, label %if.then253, label %if.else296

if.then253:                                       ; preds = %if.then247
  %157 = load i8, i8* %shift, align 1
  %tobool254 = icmp ne i8 %157, 0
  br i1 %tobool254, label %if.then255, label %if.end274

if.then255:                                       ; preds = %if.then253
  %158 = load i32, i32* %cnt, align 4
  %inc256 = add i32 %158, 1
  store i32 %inc256, i32* %cnt, align 4
  %idxprom257 = sext i32 %158 to i64
  %arrayidx258 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom257
  %code259 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 116, i8* %code259, align 4
  %dst_reg260 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %159 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg261 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %159, i32 0, i32 1
  %bf.load262 = load i8, i8* %dst_reg261, align 1
  %bf.clear263 = and i8 %bf.load262, 15
  %bf.load264 = load i8, i8* %dst_reg260, align 1
  %bf.value = and i8 %bf.clear263, 15
  %bf.clear265 = and i8 %bf.load264, -16
  %bf.set266 = or i8 %bf.clear265, %bf.value
  store i8 %bf.set266, i8* %dst_reg260, align 1
  %src_reg267 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load268 = load i8, i8* %src_reg267, align 1
  %bf.clear269 = and i8 %bf.load268, 15
  %bf.set270 = or i8 %bf.clear269, 0
  store i8 %bf.set270, i8* %src_reg267, align 1
  %off271 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off271, align 2
  %imm272 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  %160 = load i8, i8* %shift, align 1
  %conv273 = zext i8 %160 to i32
  store i32 %conv273, i32* %imm272, align 4
  %161 = bitcast %struct.bpf_insn* %arrayidx258 to i8*
  %162 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %161, i8* align 4 %162, i64 8, i1 false)
  br label %if.end274

if.end274:                                        ; preds = %if.then255, %if.then253
  %163 = load i32, i32* %cnt, align 4
  %inc275 = add i32 %163, 1
  store i32 %inc275, i32* %cnt, align 4
  %idxprom276 = sext i32 %163 to i64
  %arrayidx277 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom276
  %code279 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral278, i32 0, i32 0
  store i8 84, i8* %code279, align 4
  %dst_reg280 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral278, i32 0, i32 1
  %164 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg281 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %164, i32 0, i32 1
  %bf.load282 = load i8, i8* %dst_reg281, align 1
  %bf.clear283 = and i8 %bf.load282, 15
  %bf.load284 = load i8, i8* %dst_reg280, align 1
  %bf.value285 = and i8 %bf.clear283, 15
  %bf.clear286 = and i8 %bf.load284, -16
  %bf.set287 = or i8 %bf.clear286, %bf.value285
  store i8 %bf.set287, i8* %dst_reg280, align 1
  %src_reg288 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral278, i32 0, i32 1
  %bf.load289 = load i8, i8* %src_reg288, align 1
  %bf.clear290 = and i8 %bf.load289, 15
  %bf.set291 = or i8 %bf.clear290, 0
  store i8 %bf.set291, i8* %src_reg288, align 1
  %off292 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral278, i32 0, i32 2
  store i16 0, i16* %off292, align 2
  %imm293 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral278, i32 0, i32 3
  %165 = load i32, i32* %size, align 4
  %mul294 = mul i32 %165, 8
  %shl = shl i32 1, %mul294
  %sub295 = sub i32 %shl, 1
  store i32 %sub295, i32* %imm293, align 4
  %166 = bitcast %struct.bpf_insn* %arrayidx277 to i8*
  %167 = bitcast %struct.bpf_insn* %.compoundliteral278 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %166, i8* align 4 %167, i64 8, i1 false)
  br label %if.end343

if.else296:                                       ; preds = %if.then247
  %168 = load i8, i8* %shift, align 1
  %tobool297 = icmp ne i8 %168, 0
  br i1 %tobool297, label %if.then298, label %if.end319

if.then298:                                       ; preds = %if.else296
  %169 = load i32, i32* %cnt, align 4
  %inc299 = add i32 %169, 1
  store i32 %inc299, i32* %cnt, align 4
  %idxprom300 = sext i32 %169 to i64
  %arrayidx301 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom300
  %code303 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral302, i32 0, i32 0
  store i8 119, i8* %code303, align 4
  %dst_reg304 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral302, i32 0, i32 1
  %170 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg305 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %170, i32 0, i32 1
  %bf.load306 = load i8, i8* %dst_reg305, align 1
  %bf.clear307 = and i8 %bf.load306, 15
  %bf.load308 = load i8, i8* %dst_reg304, align 1
  %bf.value309 = and i8 %bf.clear307, 15
  %bf.clear310 = and i8 %bf.load308, -16
  %bf.set311 = or i8 %bf.clear310, %bf.value309
  store i8 %bf.set311, i8* %dst_reg304, align 1
  %src_reg312 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral302, i32 0, i32 1
  %bf.load313 = load i8, i8* %src_reg312, align 1
  %bf.clear314 = and i8 %bf.load313, 15
  %bf.set315 = or i8 %bf.clear314, 0
  store i8 %bf.set315, i8* %src_reg312, align 1
  %off316 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral302, i32 0, i32 2
  store i16 0, i16* %off316, align 2
  %imm317 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral302, i32 0, i32 3
  %171 = load i8, i8* %shift, align 1
  %conv318 = zext i8 %171 to i32
  store i32 %conv318, i32* %imm317, align 4
  %172 = bitcast %struct.bpf_insn* %arrayidx301 to i8*
  %173 = bitcast %struct.bpf_insn* %.compoundliteral302 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %172, i8* align 4 %173, i64 8, i1 false)
  br label %if.end319

if.end319:                                        ; preds = %if.then298, %if.else296
  %174 = load i32, i32* %cnt, align 4
  %inc320 = add i32 %174, 1
  store i32 %inc320, i32* %cnt, align 4
  %idxprom321 = sext i32 %174 to i64
  %arrayidx322 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 %idxprom321
  %code324 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral323, i32 0, i32 0
  store i8 87, i8* %code324, align 4
  %dst_reg325 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral323, i32 0, i32 1
  %175 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg326 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %175, i32 0, i32 1
  %bf.load327 = load i8, i8* %dst_reg326, align 1
  %bf.clear328 = and i8 %bf.load327, 15
  %bf.load329 = load i8, i8* %dst_reg325, align 1
  %bf.value330 = and i8 %bf.clear328, 15
  %bf.clear331 = and i8 %bf.load329, -16
  %bf.set332 = or i8 %bf.clear331, %bf.value330
  store i8 %bf.set332, i8* %dst_reg325, align 1
  %src_reg333 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral323, i32 0, i32 1
  %bf.load334 = load i8, i8* %src_reg333, align 1
  %bf.clear335 = and i8 %bf.load334, 15
  %bf.set336 = or i8 %bf.clear335, 0
  store i8 %bf.set336, i8* %src_reg333, align 1
  %off337 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral323, i32 0, i32 2
  store i16 0, i16* %off337, align 2
  %imm338 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral323, i32 0, i32 3
  %176 = load i32, i32* %size, align 4
  %mul339 = mul i32 %176, 8
  %sh_prom = zext i32 %mul339 to i64
  %shl340 = shl i64 1, %sh_prom
  %sub341 = sub i64 %shl340, 1
  %conv342 = trunc i64 %sub341 to i32
  store i32 %conv342, i32* %imm338, align 4
  %177 = bitcast %struct.bpf_insn* %arrayidx322 to i8*
  %178 = bitcast %struct.bpf_insn* %.compoundliteral323 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %177, i8* align 4 %178, i64 8, i1 false)
  br label %if.end343

if.end343:                                        ; preds = %if.end319, %if.end274
  br label %if.end344

if.end344:                                        ; preds = %if.end343, %land.lhs.true244, %if.end241
  %179 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %180 = load i32, i32* %i, align 4
  %181 = load i32, i32* %delta, align 4
  %add345 = add i32 %180, %181
  %arraydecay346 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %182 = load i32, i32* %cnt, align 4
  %call347 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %179, i32 noundef %add345, %struct.bpf_insn* noundef %arraydecay346, i32 noundef %182) #11
  store %struct.bpf_prog* %call347, %struct.bpf_prog** %new_prog, align 8
  %183 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool348 = icmp ne %struct.bpf_prog* %183, null
  br i1 %tobool348, label %if.end350, label %if.then349

if.then349:                                       ; preds = %if.end344
  store i32 -12, i32* %retval, align 4
  br label %return

if.end350:                                        ; preds = %if.end344
  %184 = load i32, i32* %cnt, align 4
  %sub351 = sub i32 %184, 1
  %185 = load i32, i32* %delta, align 4
  %add352 = add i32 %185, %sub351
  store i32 %add352, i32* %delta, align 4
  %186 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %187 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog353 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %187, i32 0, i32 2
  store %struct.bpf_prog* %186, %struct.bpf_prog** %prog353, align 8
  %188 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi354 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %188, i32 0, i32 11
  %arraydecay355 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi354, i64 0, i64 0
  %189 = load i32, i32* %i, align 4
  %idx.ext356 = sext i32 %189 to i64
  %add.ptr357 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay355, i64 %idx.ext356
  %190 = load i32, i32* %delta, align 4
  %idx.ext358 = sext i32 %190 to i64
  %add.ptr359 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr357, i64 %idx.ext358
  store %struct.bpf_insn* %add.ptr359, %struct.bpf_insn** %insn, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end350, %sw.default, %if.end135, %if.then112, %if.end95, %if.else71
  %191 = load i32, i32* %i, align 4
  %inc360 = add i32 %191, 1
  store i32 %inc360, i32* %i, align 4
  %192 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %192, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then349, %if.then240, %if.then207, %if.then133, %if.then94, %if.then25, %if.then17, %if.then11, %if.then5
  %193 = load i32, i32* %retval, align 4
  ret i32 %193
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @fixup_bpf_calls(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %expect_blinding = alloca i8, align 1
  %insn = alloca %struct.bpf_insn*, align 8
  %fn = alloca %struct.bpf_func_proto*, align 8
  %insn_cnt = alloca i32, align 4
  %ops = alloca %struct.bpf_map_ops*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %insn_buf = alloca [16 x %struct.bpf_insn], align 16
  %new_prog = alloca %struct.bpf_prog*, align 8
  %map_ptr = alloca %struct.bpf_map*, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %cnt = alloca i32, align 4
  %delta = alloca i32, align 4
  %is64 = alloca i8, align 1
  %mask_and_div = alloca [5 x %struct.bpf_insn], align 16
  %mask_and_mod = alloca [3 x %struct.bpf_insn], align 16
  %patchlet = alloca %struct.bpf_insn*, align 8
  %code_add = alloca i8, align 1
  %code_sub = alloca i8, align 1
  %insn_buf217 = alloca [16 x %struct.bpf_insn], align 16
  %patch = alloca %struct.bpf_insn*, align 8
  %issrc = alloca i8, align 1
  %isneg = alloca i8, align 1
  %off_reg = alloca i32, align 4
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %.compoundliteral267 = alloca %struct.bpf_insn, align 4
  %.compoundliteral281 = alloca %struct.bpf_insn, align 4
  %.compoundliteral297 = alloca %struct.bpf_insn, align 4
  %.compoundliteral313 = alloca %struct.bpf_insn, align 4
  %.compoundliteral326 = alloca %struct.bpf_insn, align 4
  %.compoundliteral341 = alloca %struct.bpf_insn, align 4
  %.compoundliteral362 = alloca %struct.bpf_insn, align 4
  %.compoundliteral395 = alloca %struct.bpf_insn, align 4
  %desc = alloca %struct.bpf_jit_poke_descriptor, align 8
  %.compoundliteral519 = alloca %struct.bpf_insn, align 4
  %.compoundliteral532 = alloca %struct.bpf_insn, align 4
  %__mptr = alloca i8*, align 8
  %tmp = alloca %struct.bpf_array*, align 8
  %ld_jiffies_addr = alloca [2 x %struct.bpf_insn], align 16
  %.compoundliteral723 = alloca %struct.bpf_insn, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call zeroext i1 @bpf_jit_blinding_enabled(%struct.bpf_prog* noundef %2) #11
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %expect_blinding, align 1
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len, align 4
  store i32 %5, i32* %insn_cnt, align 4
  store i32 0, i32* %delta, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 0
  %9 = load i8, i8* %code, align 4
  %conv = zext i8 %9 to i32
  %cmp2 = icmp eq i32 %conv, 159
  br i1 %cmp2, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code4 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %10, i32 0, i32 0
  %11 = load i8, i8* %code4, align 4
  %conv5 = zext i8 %11 to i32
  %cmp6 = icmp eq i32 %conv5, 63
  br i1 %cmp6, label %if.then, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %12, i32 0, i32 0
  %13 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %13 to i32
  %cmp11 = icmp eq i32 %conv10, 156
  br i1 %cmp11, label %if.then, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false8
  %14 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code14 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %14, i32 0, i32 0
  %15 = load i8, i8* %code14, align 4
  %conv15 = zext i8 %15 to i32
  %cmp16 = icmp eq i32 %conv15, 60
  br i1 %cmp16, label %if.then, label %if.end162

if.then:                                          ; preds = %lor.lhs.false13, %lor.lhs.false8, %lor.lhs.false, %for.body
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 0
  %17 = load i8, i8* %code18, align 4
  %conv19 = zext i8 %17 to i32
  %and = and i32 %conv19, 7
  %cmp20 = icmp eq i32 %and, 7
  %frombool22 = zext i1 %cmp20 to i8
  store i8 %frombool22, i8* %is64, align 1
  %arrayinit.begin = getelementptr inbounds [5 x %struct.bpf_insn], [5 x %struct.bpf_insn]* %mask_and_div, i64 0, i64 0
  %code23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 0
  store i8 -68, i8* %code23, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.load24 = load i8, i8* %dst_reg, align 1
  %bf.value = and i8 %bf.lshr, 15
  %bf.clear = and i8 %bf.load24, -16
  %bf.set = or i8 %bf.clear, %bf.value
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg25 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 1
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg26 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %19, i32 0, i32 1
  %bf.load27 = load i8, i8* %src_reg26, align 1
  %bf.lshr28 = lshr i8 %bf.load27, 4
  %bf.load29 = load i8, i8* %src_reg25, align 1
  %bf.value30 = and i8 %bf.lshr28, 15
  %bf.shl = shl i8 %bf.value30, 4
  %bf.clear31 = and i8 %bf.load29, 15
  %bf.set32 = or i8 %bf.clear31, %bf.shl
  store i8 %bf.set32, i8* %src_reg25, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i32 0, i32 3
  store i32 0, i32* %imm, align 4
  %arrayinit.element = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin, i64 1
  %code33 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 0
  store i8 85, i8* %code33, align 8
  %dst_reg34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 1
  %bf.load36 = load i8, i8* %src_reg35, align 1
  %bf.lshr37 = lshr i8 %bf.load36, 4
  %bf.load38 = load i8, i8* %dst_reg34, align 1
  %bf.value39 = and i8 %bf.lshr37, 15
  %bf.clear40 = and i8 %bf.load38, -16
  %bf.set41 = or i8 %bf.clear40, %bf.value39
  store i8 %bf.set41, i8* %dst_reg34, align 1
  %src_reg42 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 1
  %bf.load43 = load i8, i8* %src_reg42, align 1
  %bf.clear44 = and i8 %bf.load43, 15
  %bf.set45 = or i8 %bf.clear44, 0
  store i8 %bf.set45, i8* %src_reg42, align 1
  %off46 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 2
  store i16 2, i16* %off46, align 2
  %imm47 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i32 0, i32 3
  store i32 0, i32* %imm47, align 4
  %arrayinit.element48 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element, i64 1
  %code49 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element48, i32 0, i32 0
  store i8 -84, i8* %code49, align 8
  %dst_reg50 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element48, i32 0, i32 1
  %21 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg51 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %21, i32 0, i32 1
  %bf.load52 = load i8, i8* %dst_reg51, align 1
  %bf.clear53 = and i8 %bf.load52, 15
  %bf.load54 = load i8, i8* %dst_reg50, align 1
  %bf.value55 = and i8 %bf.clear53, 15
  %bf.clear56 = and i8 %bf.load54, -16
  %bf.set57 = or i8 %bf.clear56, %bf.value55
  store i8 %bf.set57, i8* %dst_reg50, align 1
  %src_reg58 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element48, i32 0, i32 1
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg59 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 1
  %bf.load60 = load i8, i8* %dst_reg59, align 1
  %bf.clear61 = and i8 %bf.load60, 15
  %bf.load62 = load i8, i8* %src_reg58, align 1
  %bf.value63 = and i8 %bf.clear61, 15
  %bf.shl64 = shl i8 %bf.value63, 4
  %bf.clear65 = and i8 %bf.load62, 15
  %bf.set66 = or i8 %bf.clear65, %bf.shl64
  store i8 %bf.set66, i8* %src_reg58, align 1
  %off67 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element48, i32 0, i32 2
  store i16 0, i16* %off67, align 2
  %imm68 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element48, i32 0, i32 3
  store i32 0, i32* %imm68, align 4
  %arrayinit.element69 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element48, i64 1
  %code70 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element69, i32 0, i32 0
  store i8 5, i8* %code70, align 8
  %dst_reg71 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element69, i32 0, i32 1
  %bf.load72 = load i8, i8* %dst_reg71, align 1
  %bf.clear73 = and i8 %bf.load72, -16
  %bf.set74 = or i8 %bf.clear73, 0
  store i8 %bf.set74, i8* %dst_reg71, align 1
  %src_reg75 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element69, i32 0, i32 1
  %bf.load76 = load i8, i8* %src_reg75, align 1
  %bf.clear77 = and i8 %bf.load76, 15
  %bf.set78 = or i8 %bf.clear77, 0
  store i8 %bf.set78, i8* %src_reg75, align 1
  %off79 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element69, i32 0, i32 2
  store i16 1, i16* %off79, align 2
  %imm80 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element69, i32 0, i32 3
  store i32 0, i32* %imm80, align 4
  %arrayinit.element81 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element69, i64 1
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %24 = bitcast %struct.bpf_insn* %arrayinit.element81 to i8*
  %25 = bitcast %struct.bpf_insn* %23 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %24, i8* align 4 %25, i64 8, i1 false)
  %arrayinit.begin82 = getelementptr inbounds [3 x %struct.bpf_insn], [3 x %struct.bpf_insn]* %mask_and_mod, i64 0, i64 0
  %code83 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin82, i32 0, i32 0
  store i8 -68, i8* %code83, align 8
  %dst_reg84 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin82, i32 0, i32 1
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg85 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %26, i32 0, i32 1
  %bf.load86 = load i8, i8* %src_reg85, align 1
  %bf.lshr87 = lshr i8 %bf.load86, 4
  %bf.load88 = load i8, i8* %dst_reg84, align 1
  %bf.value89 = and i8 %bf.lshr87, 15
  %bf.clear90 = and i8 %bf.load88, -16
  %bf.set91 = or i8 %bf.clear90, %bf.value89
  store i8 %bf.set91, i8* %dst_reg84, align 1
  %src_reg92 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin82, i32 0, i32 1
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg93 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %27, i32 0, i32 1
  %bf.load94 = load i8, i8* %src_reg93, align 1
  %bf.lshr95 = lshr i8 %bf.load94, 4
  %bf.load96 = load i8, i8* %src_reg92, align 1
  %bf.value97 = and i8 %bf.lshr95, 15
  %bf.shl98 = shl i8 %bf.value97, 4
  %bf.clear99 = and i8 %bf.load96, 15
  %bf.set100 = or i8 %bf.clear99, %bf.shl98
  store i8 %bf.set100, i8* %src_reg92, align 1
  %off101 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin82, i32 0, i32 2
  store i16 0, i16* %off101, align 2
  %imm102 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin82, i32 0, i32 3
  store i32 0, i32* %imm102, align 4
  %arrayinit.element103 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin82, i64 1
  %code104 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element103, i32 0, i32 0
  store i8 21, i8* %code104, align 8
  %dst_reg105 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element103, i32 0, i32 1
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg106 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %28, i32 0, i32 1
  %bf.load107 = load i8, i8* %src_reg106, align 1
  %bf.lshr108 = lshr i8 %bf.load107, 4
  %bf.load109 = load i8, i8* %dst_reg105, align 1
  %bf.value110 = and i8 %bf.lshr108, 15
  %bf.clear111 = and i8 %bf.load109, -16
  %bf.set112 = or i8 %bf.clear111, %bf.value110
  store i8 %bf.set112, i8* %dst_reg105, align 1
  %src_reg113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element103, i32 0, i32 1
  %bf.load114 = load i8, i8* %src_reg113, align 1
  %bf.clear115 = and i8 %bf.load114, 15
  %bf.set116 = or i8 %bf.clear115, 0
  store i8 %bf.set116, i8* %src_reg113, align 1
  %off117 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element103, i32 0, i32 2
  store i16 1, i16* %off117, align 2
  %imm118 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element103, i32 0, i32 3
  store i32 0, i32* %imm118, align 4
  %arrayinit.element119 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element103, i64 1
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %30 = bitcast %struct.bpf_insn* %arrayinit.element119 to i8*
  %31 = bitcast %struct.bpf_insn* %29 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* align 4 %31, i64 8, i1 false)
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code120 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %32, i32 0, i32 0
  %33 = load i8, i8* %code120, align 4
  %conv121 = zext i8 %33 to i32
  %cmp122 = icmp eq i32 %conv121, 63
  br i1 %cmp122, label %if.then129, label %lor.lhs.false124

lor.lhs.false124:                                 ; preds = %if.then
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code125 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %34, i32 0, i32 0
  %35 = load i8, i8* %code125, align 4
  %conv126 = zext i8 %35 to i32
  %cmp127 = icmp eq i32 %conv126, 60
  br i1 %cmp127, label %if.then129, label %if.else

if.then129:                                       ; preds = %lor.lhs.false124, %if.then
  %arraydecay130 = getelementptr inbounds [5 x %struct.bpf_insn], [5 x %struct.bpf_insn]* %mask_and_div, i64 0, i64 0
  %36 = load i8, i8* %is64, align 1
  %tobool = trunc i8 %36 to i1
  %37 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %idx.ext = sext i32 %cond to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay130, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %patchlet, align 8
  %38 = load i8, i8* %is64, align 1
  %tobool132 = trunc i8 %38 to i1
  %39 = zext i1 %tobool132 to i64
  %cond134 = select i1 %tobool132, i32 1, i32 0
  %conv135 = sext i32 %cond134 to i64
  %sub = sub i64 5, %conv135
  %conv136 = trunc i64 %sub to i32
  store i32 %conv136, i32* %cnt, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false124
  %arraydecay137 = getelementptr inbounds [3 x %struct.bpf_insn], [3 x %struct.bpf_insn]* %mask_and_mod, i64 0, i64 0
  %40 = load i8, i8* %is64, align 1
  %tobool138 = trunc i8 %40 to i1
  %41 = zext i1 %tobool138 to i64
  %cond140 = select i1 %tobool138, i32 1, i32 0
  %idx.ext141 = sext i32 %cond140 to i64
  %add.ptr142 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay137, i64 %idx.ext141
  store %struct.bpf_insn* %add.ptr142, %struct.bpf_insn** %patchlet, align 8
  %42 = load i8, i8* %is64, align 1
  %tobool143 = trunc i8 %42 to i1
  %43 = zext i1 %tobool143 to i64
  %cond145 = select i1 %tobool143, i32 1, i32 0
  %conv146 = sext i32 %cond145 to i64
  %sub147 = sub i64 3, %conv146
  %conv148 = trunc i64 %sub147 to i32
  store i32 %conv148, i32* %cnt, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then129
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load i32, i32* %i, align 4
  %46 = load i32, i32* %delta, align 4
  %add = add i32 %45, %46
  %47 = load %struct.bpf_insn*, %struct.bpf_insn** %patchlet, align 8
  %48 = load i32, i32* %cnt, align 4
  %call149 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %44, i32 noundef %add, %struct.bpf_insn* noundef %47, i32 noundef %48) #11
  store %struct.bpf_prog* %call149, %struct.bpf_prog** %new_prog, align 8
  %49 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool150 = icmp ne %struct.bpf_prog* %49, null
  br i1 %tobool150, label %if.end152, label %if.then151

if.then151:                                       ; preds = %if.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end152:                                        ; preds = %if.end
  %50 = load i32, i32* %cnt, align 4
  %sub153 = sub i32 %50, 1
  %51 = load i32, i32* %delta, align 4
  %add154 = add i32 %51, %sub153
  store i32 %add154, i32* %delta, align 4
  %52 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %52, %struct.bpf_prog** %prog, align 8
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog155 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %53, i32 0, i32 2
  store %struct.bpf_prog* %52, %struct.bpf_prog** %prog155, align 8
  %54 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi156 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %54, i32 0, i32 11
  %arraydecay157 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi156, i64 0, i64 0
  %55 = load i32, i32* %i, align 4
  %idx.ext158 = sext i32 %55 to i64
  %add.ptr159 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay157, i64 %idx.ext158
  %56 = load i32, i32* %delta, align 4
  %idx.ext160 = sext i32 %56 to i64
  %add.ptr161 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr159, i64 %idx.ext160
  store %struct.bpf_insn* %add.ptr161, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end162:                                        ; preds = %lor.lhs.false13
  %57 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code163 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %57, i32 0, i32 0
  %58 = load i8, i8* %code163, align 4
  %conv164 = zext i8 %58 to i32
  %and165 = and i32 %conv164, 7
  %cmp166 = icmp eq i32 %and165, 0
  br i1 %cmp166, label %land.lhs.true, label %if.end206

land.lhs.true:                                    ; preds = %if.end162
  %59 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code168 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %59, i32 0, i32 0
  %60 = load i8, i8* %code168, align 4
  %conv169 = zext i8 %60 to i32
  %and170 = and i32 %conv169, 224
  %cmp171 = icmp eq i32 %and170, 32
  br i1 %cmp171, label %if.then179, label %lor.lhs.false173

lor.lhs.false173:                                 ; preds = %land.lhs.true
  %61 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code174 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %61, i32 0, i32 0
  %62 = load i8, i8* %code174, align 4
  %conv175 = zext i8 %62 to i32
  %and176 = and i32 %conv175, 224
  %cmp177 = icmp eq i32 %and176, 64
  br i1 %cmp177, label %if.then179, label %if.end206

if.then179:                                       ; preds = %lor.lhs.false173, %land.lhs.true
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops180 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %63, i32 0, i32 3
  %64 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops180, align 8
  %gen_ld_abs = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %64, i32 0, i32 3
  %65 = load i32 (%struct.bpf_insn*, %struct.bpf_insn*)*, i32 (%struct.bpf_insn*, %struct.bpf_insn*)** %gen_ld_abs, align 8
  %66 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %arraydecay181 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %call182 = call i32 %65(%struct.bpf_insn* noundef %66, %struct.bpf_insn* noundef %arraydecay181) #11
  store i32 %call182, i32* %cnt, align 4
  %67 = load i32, i32* %cnt, align 4
  %cmp183 = icmp eq i32 %67, 0
  br i1 %cmp183, label %if.then189, label %lor.lhs.false185

lor.lhs.false185:                                 ; preds = %if.then179
  %68 = load i32, i32* %cnt, align 4
  %conv186 = sext i32 %68 to i64
  %cmp187 = icmp uge i64 %conv186, 16
  br i1 %cmp187, label %if.then189, label %if.end190

if.then189:                                       ; preds = %lor.lhs.false185, %if.then179
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %70 = bitcast %struct.bpf_verifier_env* %69 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %70, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.367, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end190:                                        ; preds = %lor.lhs.false185
  %71 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %72 = load i32, i32* %i, align 4
  %73 = load i32, i32* %delta, align 4
  %add191 = add i32 %72, %73
  %arraydecay192 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %74 = load i32, i32* %cnt, align 4
  %call193 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %71, i32 noundef %add191, %struct.bpf_insn* noundef %arraydecay192, i32 noundef %74) #11
  store %struct.bpf_prog* %call193, %struct.bpf_prog** %new_prog, align 8
  %75 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool194 = icmp ne %struct.bpf_prog* %75, null
  br i1 %tobool194, label %if.end196, label %if.then195

if.then195:                                       ; preds = %if.end190
  store i32 -12, i32* %retval, align 4
  br label %return

if.end196:                                        ; preds = %if.end190
  %76 = load i32, i32* %cnt, align 4
  %sub197 = sub i32 %76, 1
  %77 = load i32, i32* %delta, align 4
  %add198 = add i32 %77, %sub197
  store i32 %add198, i32* %delta, align 4
  %78 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %78, %struct.bpf_prog** %prog, align 8
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog199 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %79, i32 0, i32 2
  store %struct.bpf_prog* %78, %struct.bpf_prog** %prog199, align 8
  %80 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi200 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %80, i32 0, i32 11
  %arraydecay201 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi200, i64 0, i64 0
  %81 = load i32, i32* %i, align 4
  %idx.ext202 = sext i32 %81 to i64
  %add.ptr203 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay201, i64 %idx.ext202
  %82 = load i32, i32* %delta, align 4
  %idx.ext204 = sext i32 %82 to i64
  %add.ptr205 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr203, i64 %idx.ext204
  store %struct.bpf_insn* %add.ptr205, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end206:                                        ; preds = %lor.lhs.false173, %if.end162
  %83 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code207 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %83, i32 0, i32 0
  %84 = load i8, i8* %code207, align 4
  %conv208 = zext i8 %84 to i32
  %cmp209 = icmp eq i32 %conv208, 15
  br i1 %cmp209, label %if.then216, label %lor.lhs.false211

lor.lhs.false211:                                 ; preds = %if.end206
  %85 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code212 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %85, i32 0, i32 0
  %86 = load i8, i8* %code212, align 4
  %conv213 = zext i8 %86 to i32
  %cmp214 = icmp eq i32 %conv213, 31
  br i1 %cmp214, label %if.then216, label %if.end427

if.then216:                                       ; preds = %lor.lhs.false211, %if.end206
  store i8 15, i8* %code_add, align 1
  store i8 31, i8* %code_sub, align 1
  %arrayidx = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf217, i64 0, i64 0
  store %struct.bpf_insn* %arrayidx, %struct.bpf_insn** %patch, align 8
  %87 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %87, i32 0, i32 20
  %88 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %89 = load i32, i32* %i, align 4
  %90 = load i32, i32* %delta, align 4
  %add218 = add i32 %89, %90
  %idxprom = sext i32 %add218 to i64
  %arrayidx219 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %88, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx219, %struct.bpf_insn_aux_data** %aux, align 8
  %91 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %91, i32 0, i32 6
  %92 = load i8, i8* %alu_state, align 1
  %tobool220 = icmp ne i8 %92, 0
  br i1 %tobool220, label %lor.lhs.false221, label %if.then226

lor.lhs.false221:                                 ; preds = %if.then216
  %93 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state222 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %93, i32 0, i32 6
  %94 = load i8, i8* %alu_state222, align 1
  %conv223 = zext i8 %94 to i32
  %cmp224 = icmp eq i32 %conv223, 8
  br i1 %cmp224, label %if.then226, label %if.end227

if.then226:                                       ; preds = %lor.lhs.false221, %if.then216
  br label %for.inc

if.end227:                                        ; preds = %lor.lhs.false221
  %95 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state228 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %95, i32 0, i32 6
  %96 = load i8, i8* %alu_state228, align 1
  %conv229 = zext i8 %96 to i32
  %and230 = and i32 %conv229, 4
  %tobool231 = icmp ne i32 %and230, 0
  %frombool232 = zext i1 %tobool231 to i8
  store i8 %frombool232, i8* %isneg, align 1
  %97 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %alu_state233 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %97, i32 0, i32 6
  %98 = load i8, i8* %alu_state233, align 1
  %conv234 = zext i8 %98 to i32
  %and235 = and i32 %conv234, 3
  %cmp236 = icmp eq i32 %and235, 1
  %frombool238 = zext i1 %cmp236 to i8
  store i8 %frombool238, i8* %issrc, align 1
  %99 = load i8, i8* %issrc, align 1
  %tobool239 = trunc i8 %99 to i1
  br i1 %tobool239, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end227
  %100 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg241 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %100, i32 0, i32 1
  %bf.load242 = load i8, i8* %src_reg241, align 1
  %bf.lshr243 = lshr i8 %bf.load242, 4
  %conv244 = zext i8 %bf.lshr243 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end227
  %101 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg245 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %101, i32 0, i32 1
  %bf.load246 = load i8, i8* %dst_reg245, align 1
  %bf.clear247 = and i8 %bf.load246, 15
  %conv248 = zext i8 %bf.clear247 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond249 = phi i32 [ %conv244, %cond.true ], [ %conv248, %cond.false ]
  store i32 %cond249, i32* %off_reg, align 4
  %102 = load i8, i8* %isneg, align 1
  %tobool250 = trunc i8 %102 to i1
  br i1 %tobool250, label %if.then251, label %if.end265

if.then251:                                       ; preds = %cond.end
  %103 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %103, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %patch, align 8
  %code252 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 39, i8* %code252, align 4
  %dst_reg253 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %104 = load i32, i32* %off_reg, align 4
  %conv254 = trunc i32 %104 to i8
  %bf.load255 = load i8, i8* %dst_reg253, align 1
  %bf.value256 = and i8 %conv254, 15
  %bf.clear257 = and i8 %bf.load255, -16
  %bf.set258 = or i8 %bf.clear257, %bf.value256
  store i8 %bf.set258, i8* %dst_reg253, align 1
  %src_reg259 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load260 = load i8, i8* %src_reg259, align 1
  %bf.clear261 = and i8 %bf.load260, 15
  %bf.set262 = or i8 %bf.clear261, 0
  store i8 %bf.set262, i8* %src_reg259, align 1
  %off263 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off263, align 2
  %imm264 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 -1, i32* %imm264, align 4
  %105 = bitcast %struct.bpf_insn* %103 to i8*
  %106 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %105, i8* align 4 %106, i64 8, i1 false)
  br label %if.end265

if.end265:                                        ; preds = %if.then251, %cond.end
  %107 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr266 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %107, i32 1
  store %struct.bpf_insn* %incdec.ptr266, %struct.bpf_insn** %patch, align 8
  %code268 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral267, i32 0, i32 0
  store i8 -76, i8* %code268, align 4
  %dst_reg269 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral267, i32 0, i32 1
  %bf.load270 = load i8, i8* %dst_reg269, align 1
  %bf.clear271 = and i8 %bf.load270, -16
  %bf.set272 = or i8 %bf.clear271, 11
  store i8 %bf.set272, i8* %dst_reg269, align 1
  %src_reg273 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral267, i32 0, i32 1
  %bf.load274 = load i8, i8* %src_reg273, align 1
  %bf.clear275 = and i8 %bf.load274, 15
  %bf.set276 = or i8 %bf.clear275, 0
  store i8 %bf.set276, i8* %src_reg273, align 1
  %off277 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral267, i32 0, i32 2
  store i16 0, i16* %off277, align 2
  %imm278 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral267, i32 0, i32 3
  %108 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %109 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %108, i32 0, i32 0
  %alu_limit = bitcast %struct.atomic64_t* %109 to i32*
  %110 = load i32, i32* %alu_limit, align 8
  %sub279 = sub i32 %110, 1
  store i32 %sub279, i32* %imm278, align 4
  %111 = bitcast %struct.bpf_insn* %107 to i8*
  %112 = bitcast %struct.bpf_insn* %.compoundliteral267 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %111, i8* align 4 %112, i64 8, i1 false)
  %113 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr280 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %113, i32 1
  store %struct.bpf_insn* %incdec.ptr280, %struct.bpf_insn** %patch, align 8
  %code282 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral281, i32 0, i32 0
  store i8 31, i8* %code282, align 4
  %dst_reg283 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral281, i32 0, i32 1
  %bf.load284 = load i8, i8* %dst_reg283, align 1
  %bf.clear285 = and i8 %bf.load284, -16
  %bf.set286 = or i8 %bf.clear285, 11
  store i8 %bf.set286, i8* %dst_reg283, align 1
  %src_reg287 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral281, i32 0, i32 1
  %114 = load i32, i32* %off_reg, align 4
  %conv288 = trunc i32 %114 to i8
  %bf.load289 = load i8, i8* %src_reg287, align 1
  %bf.value290 = and i8 %conv288, 15
  %bf.shl291 = shl i8 %bf.value290, 4
  %bf.clear292 = and i8 %bf.load289, 15
  %bf.set293 = or i8 %bf.clear292, %bf.shl291
  store i8 %bf.set293, i8* %src_reg287, align 1
  %off294 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral281, i32 0, i32 2
  store i16 0, i16* %off294, align 2
  %imm295 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral281, i32 0, i32 3
  store i32 0, i32* %imm295, align 4
  %115 = bitcast %struct.bpf_insn* %113 to i8*
  %116 = bitcast %struct.bpf_insn* %.compoundliteral281 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %115, i8* align 4 %116, i64 8, i1 false)
  %117 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr296 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %117, i32 1
  store %struct.bpf_insn* %incdec.ptr296, %struct.bpf_insn** %patch, align 8
  %code298 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral297, i32 0, i32 0
  store i8 79, i8* %code298, align 4
  %dst_reg299 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral297, i32 0, i32 1
  %bf.load300 = load i8, i8* %dst_reg299, align 1
  %bf.clear301 = and i8 %bf.load300, -16
  %bf.set302 = or i8 %bf.clear301, 11
  store i8 %bf.set302, i8* %dst_reg299, align 1
  %src_reg303 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral297, i32 0, i32 1
  %118 = load i32, i32* %off_reg, align 4
  %conv304 = trunc i32 %118 to i8
  %bf.load305 = load i8, i8* %src_reg303, align 1
  %bf.value306 = and i8 %conv304, 15
  %bf.shl307 = shl i8 %bf.value306, 4
  %bf.clear308 = and i8 %bf.load305, 15
  %bf.set309 = or i8 %bf.clear308, %bf.shl307
  store i8 %bf.set309, i8* %src_reg303, align 1
  %off310 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral297, i32 0, i32 2
  store i16 0, i16* %off310, align 2
  %imm311 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral297, i32 0, i32 3
  store i32 0, i32* %imm311, align 4
  %119 = bitcast %struct.bpf_insn* %117 to i8*
  %120 = bitcast %struct.bpf_insn* %.compoundliteral297 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %119, i8* align 4 %120, i64 8, i1 false)
  %121 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr312 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %121, i32 1
  store %struct.bpf_insn* %incdec.ptr312, %struct.bpf_insn** %patch, align 8
  %code314 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral313, i32 0, i32 0
  store i8 -121, i8* %code314, align 4
  %dst_reg315 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral313, i32 0, i32 1
  %bf.load316 = load i8, i8* %dst_reg315, align 1
  %bf.clear317 = and i8 %bf.load316, -16
  %bf.set318 = or i8 %bf.clear317, 11
  store i8 %bf.set318, i8* %dst_reg315, align 1
  %src_reg319 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral313, i32 0, i32 1
  %bf.load320 = load i8, i8* %src_reg319, align 1
  %bf.clear321 = and i8 %bf.load320, 15
  %bf.set322 = or i8 %bf.clear321, 0
  store i8 %bf.set322, i8* %src_reg319, align 1
  %off323 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral313, i32 0, i32 2
  store i16 0, i16* %off323, align 2
  %imm324 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral313, i32 0, i32 3
  store i32 0, i32* %imm324, align 4
  %122 = bitcast %struct.bpf_insn* %121 to i8*
  %123 = bitcast %struct.bpf_insn* %.compoundliteral313 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %122, i8* align 4 %123, i64 8, i1 false)
  %124 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr325 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %124, i32 1
  store %struct.bpf_insn* %incdec.ptr325, %struct.bpf_insn** %patch, align 8
  %code327 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral326, i32 0, i32 0
  store i8 -57, i8* %code327, align 4
  %dst_reg328 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral326, i32 0, i32 1
  %bf.load329 = load i8, i8* %dst_reg328, align 1
  %bf.clear330 = and i8 %bf.load329, -16
  %bf.set331 = or i8 %bf.clear330, 11
  store i8 %bf.set331, i8* %dst_reg328, align 1
  %src_reg332 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral326, i32 0, i32 1
  %bf.load333 = load i8, i8* %src_reg332, align 1
  %bf.clear334 = and i8 %bf.load333, 15
  %bf.set335 = or i8 %bf.clear334, 0
  store i8 %bf.set335, i8* %src_reg332, align 1
  %off336 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral326, i32 0, i32 2
  store i16 0, i16* %off336, align 2
  %imm337 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral326, i32 0, i32 3
  store i32 63, i32* %imm337, align 4
  %125 = bitcast %struct.bpf_insn* %124 to i8*
  %126 = bitcast %struct.bpf_insn* %.compoundliteral326 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %125, i8* align 4 %126, i64 8, i1 false)
  %127 = load i8, i8* %issrc, align 1
  %tobool338 = trunc i8 %127 to i1
  br i1 %tobool338, label %if.then339, label %if.else360

if.then339:                                       ; preds = %if.end265
  %128 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr340 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %128, i32 1
  store %struct.bpf_insn* %incdec.ptr340, %struct.bpf_insn** %patch, align 8
  %code342 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral341, i32 0, i32 0
  store i8 95, i8* %code342, align 4
  %dst_reg343 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral341, i32 0, i32 1
  %bf.load344 = load i8, i8* %dst_reg343, align 1
  %bf.clear345 = and i8 %bf.load344, -16
  %bf.set346 = or i8 %bf.clear345, 11
  store i8 %bf.set346, i8* %dst_reg343, align 1
  %src_reg347 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral341, i32 0, i32 1
  %129 = load i32, i32* %off_reg, align 4
  %conv348 = trunc i32 %129 to i8
  %bf.load349 = load i8, i8* %src_reg347, align 1
  %bf.value350 = and i8 %conv348, 15
  %bf.shl351 = shl i8 %bf.value350, 4
  %bf.clear352 = and i8 %bf.load349, 15
  %bf.set353 = or i8 %bf.clear352, %bf.shl351
  store i8 %bf.set353, i8* %src_reg347, align 1
  %off354 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral341, i32 0, i32 2
  store i16 0, i16* %off354, align 2
  %imm355 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral341, i32 0, i32 3
  store i32 0, i32* %imm355, align 4
  %130 = bitcast %struct.bpf_insn* %128 to i8*
  %131 = bitcast %struct.bpf_insn* %.compoundliteral341 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %130, i8* align 4 %131, i64 8, i1 false)
  %132 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg356 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %132, i32 0, i32 1
  %bf.load357 = load i8, i8* %src_reg356, align 1
  %bf.clear358 = and i8 %bf.load357, 15
  %bf.set359 = or i8 %bf.clear358, -80
  store i8 %bf.set359, i8* %src_reg356, align 1
  br label %if.end376

if.else360:                                       ; preds = %if.end265
  %133 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr361 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %133, i32 1
  store %struct.bpf_insn* %incdec.ptr361, %struct.bpf_insn** %patch, align 8
  %code363 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral362, i32 0, i32 0
  store i8 95, i8* %code363, align 4
  %dst_reg364 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral362, i32 0, i32 1
  %134 = load i32, i32* %off_reg, align 4
  %conv365 = trunc i32 %134 to i8
  %bf.load366 = load i8, i8* %dst_reg364, align 1
  %bf.value367 = and i8 %conv365, 15
  %bf.clear368 = and i8 %bf.load366, -16
  %bf.set369 = or i8 %bf.clear368, %bf.value367
  store i8 %bf.set369, i8* %dst_reg364, align 1
  %src_reg370 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral362, i32 0, i32 1
  %bf.load371 = load i8, i8* %src_reg370, align 1
  %bf.clear372 = and i8 %bf.load371, 15
  %bf.set373 = or i8 %bf.clear372, -80
  store i8 %bf.set373, i8* %src_reg370, align 1
  %off374 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral362, i32 0, i32 2
  store i16 0, i16* %off374, align 2
  %imm375 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral362, i32 0, i32 3
  store i32 0, i32* %imm375, align 4
  %135 = bitcast %struct.bpf_insn* %133 to i8*
  %136 = bitcast %struct.bpf_insn* %.compoundliteral362 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %135, i8* align 4 %136, i64 8, i1 false)
  br label %if.end376

if.end376:                                        ; preds = %if.else360, %if.then339
  %137 = load i8, i8* %isneg, align 1
  %tobool377 = trunc i8 %137 to i1
  br i1 %tobool377, label %if.then378, label %if.end386

if.then378:                                       ; preds = %if.end376
  %138 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code379 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %138, i32 0, i32 0
  %139 = load i8, i8* %code379, align 4
  %conv380 = zext i8 %139 to i32
  %cmp381 = icmp eq i32 %conv380, 15
  %140 = zext i1 %cmp381 to i64
  %cond383 = select i1 %cmp381, i32 31, i32 15
  %conv384 = trunc i32 %cond383 to i8
  %141 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code385 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %141, i32 0, i32 0
  store i8 %conv384, i8* %code385, align 4
  br label %if.end386

if.end386:                                        ; preds = %if.then378, %if.end376
  %142 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr387 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %142, i32 1
  store %struct.bpf_insn* %incdec.ptr387, %struct.bpf_insn** %patch, align 8
  %143 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %144 = bitcast %struct.bpf_insn* %142 to i8*
  %145 = bitcast %struct.bpf_insn* %143 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %144, i8* align 4 %145, i64 8, i1 false)
  %146 = load i8, i8* %issrc, align 1
  %tobool388 = trunc i8 %146 to i1
  br i1 %tobool388, label %land.lhs.true390, label %if.end409

land.lhs.true390:                                 ; preds = %if.end386
  %147 = load i8, i8* %isneg, align 1
  %tobool391 = trunc i8 %147 to i1
  br i1 %tobool391, label %if.then393, label %if.end409

if.then393:                                       ; preds = %land.lhs.true390
  %148 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %incdec.ptr394 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %148, i32 1
  store %struct.bpf_insn* %incdec.ptr394, %struct.bpf_insn** %patch, align 8
  %code396 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral395, i32 0, i32 0
  store i8 39, i8* %code396, align 4
  %dst_reg397 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral395, i32 0, i32 1
  %149 = load i32, i32* %off_reg, align 4
  %conv398 = trunc i32 %149 to i8
  %bf.load399 = load i8, i8* %dst_reg397, align 1
  %bf.value400 = and i8 %conv398, 15
  %bf.clear401 = and i8 %bf.load399, -16
  %bf.set402 = or i8 %bf.clear401, %bf.value400
  store i8 %bf.set402, i8* %dst_reg397, align 1
  %src_reg403 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral395, i32 0, i32 1
  %bf.load404 = load i8, i8* %src_reg403, align 1
  %bf.clear405 = and i8 %bf.load404, 15
  %bf.set406 = or i8 %bf.clear405, 0
  store i8 %bf.set406, i8* %src_reg403, align 1
  %off407 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral395, i32 0, i32 2
  store i16 0, i16* %off407, align 2
  %imm408 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral395, i32 0, i32 3
  store i32 -1, i32* %imm408, align 4
  %150 = bitcast %struct.bpf_insn* %148 to i8*
  %151 = bitcast %struct.bpf_insn* %.compoundliteral395 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %150, i8* align 4 %151, i64 8, i1 false)
  br label %if.end409

if.end409:                                        ; preds = %if.then393, %land.lhs.true390, %if.end386
  %152 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %arraydecay410 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf217, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint %struct.bpf_insn* %152 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.bpf_insn* %arraydecay410 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv411 = trunc i64 %sub.ptr.div to i32
  store i32 %conv411, i32* %cnt, align 4
  %153 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %154 = load i32, i32* %i, align 4
  %155 = load i32, i32* %delta, align 4
  %add412 = add i32 %154, %155
  %arraydecay413 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf217, i64 0, i64 0
  %156 = load i32, i32* %cnt, align 4
  %call414 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %153, i32 noundef %add412, %struct.bpf_insn* noundef %arraydecay413, i32 noundef %156) #11
  store %struct.bpf_prog* %call414, %struct.bpf_prog** %new_prog, align 8
  %157 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool415 = icmp ne %struct.bpf_prog* %157, null
  br i1 %tobool415, label %if.end417, label %if.then416

if.then416:                                       ; preds = %if.end409
  store i32 -12, i32* %retval, align 4
  br label %return

if.end417:                                        ; preds = %if.end409
  %158 = load i32, i32* %cnt, align 4
  %sub418 = sub i32 %158, 1
  %159 = load i32, i32* %delta, align 4
  %add419 = add i32 %159, %sub418
  store i32 %add419, i32* %delta, align 4
  %160 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %160, %struct.bpf_prog** %prog, align 8
  %161 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog420 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %161, i32 0, i32 2
  store %struct.bpf_prog* %160, %struct.bpf_prog** %prog420, align 8
  %162 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi421 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %162, i32 0, i32 11
  %arraydecay422 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi421, i64 0, i64 0
  %163 = load i32, i32* %i, align 4
  %idx.ext423 = sext i32 %163 to i64
  %add.ptr424 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay422, i64 %idx.ext423
  %164 = load i32, i32* %delta, align 4
  %idx.ext425 = sext i32 %164 to i64
  %add.ptr426 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr424, i64 %idx.ext425
  store %struct.bpf_insn* %add.ptr426, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end427:                                        ; preds = %lor.lhs.false211
  %165 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code428 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %165, i32 0, i32 0
  %166 = load i8, i8* %code428, align 4
  %conv429 = zext i8 %166 to i32
  %cmp430 = icmp ne i32 %conv429, 133
  br i1 %cmp430, label %if.then432, label %if.end433

if.then432:                                       ; preds = %if.end427
  br label %for.inc

if.end433:                                        ; preds = %if.end427
  %167 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg434 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %167, i32 0, i32 1
  %bf.load435 = load i8, i8* %src_reg434, align 1
  %bf.lshr436 = lshr i8 %bf.load435, 4
  %conv437 = zext i8 %bf.lshr436 to i32
  %cmp438 = icmp eq i32 %conv437, 1
  br i1 %cmp438, label %if.then440, label %if.end441

if.then440:                                       ; preds = %if.end433
  br label %for.inc

if.end441:                                        ; preds = %if.end433
  %168 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm442 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %168, i32 0, i32 3
  %169 = load i32, i32* %imm442, align 4
  %cmp443 = icmp eq i32 %169, 24
  br i1 %cmp443, label %if.then445, label %if.end449

if.then445:                                       ; preds = %if.end441
  %170 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %dst_needed = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %170, i32 0, i32 1
  %bf.load446 = load i16, i16* %dst_needed, align 2
  %bf.clear447 = and i16 %bf.load446, -17
  %bf.set448 = or i16 %bf.clear447, 16
  store i16 %bf.set448, i16* %dst_needed, align 2
  br label %if.end449

if.end449:                                        ; preds = %if.then445, %if.end441
  %171 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm450 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %171, i32 0, i32 3
  %172 = load i32, i32* %imm450, align 4
  %cmp451 = icmp eq i32 %172, 7
  br i1 %cmp451, label %if.then453, label %if.end454

if.then453:                                       ; preds = %if.end449
  call void @bpf_user_rnd_init_once() #11
  br label %if.end454

if.end454:                                        ; preds = %if.then453, %if.end449
  %173 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm455 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %173, i32 0, i32 3
  %174 = load i32, i32* %imm455, align 4
  %cmp456 = icmp eq i32 %174, 58
  br i1 %cmp456, label %if.then458, label %if.end462

if.then458:                                       ; preds = %if.end454
  %175 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %kprobe_override = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %175, i32 0, i32 1
  %bf.load459 = load i16, i16* %kprobe_override, align 2
  %bf.clear460 = and i16 %bf.load459, -129
  %bf.set461 = or i16 %bf.clear460, 128
  store i16 %bf.set461, i16* %kprobe_override, align 2
  br label %if.end462

if.end462:                                        ; preds = %if.then458, %if.end454
  %176 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm463 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %176, i32 0, i32 3
  %177 = load i32, i32* %imm463, align 4
  %cmp464 = icmp eq i32 %177, 12
  br i1 %cmp464, label %if.then466, label %if.end561

if.then466:                                       ; preds = %if.end462
  %178 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %cb_access = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %178, i32 0, i32 1
  %bf.load467 = load i16, i16* %cb_access, align 2
  %bf.clear468 = and i16 %bf.load467, -9
  %bf.set469 = or i16 %bf.clear468, 8
  store i16 %bf.set469, i16* %cb_access, align 2
  %179 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call470 = call zeroext i1 @allow_tail_call_in_subprogs(%struct.bpf_verifier_env* noundef %179) #11
  br i1 %call470, label %if.end473, label %if.then471

if.then471:                                       ; preds = %if.then466
  %180 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux472 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %180, i32 0, i32 7
  %181 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux472, align 8
  %stack_depth = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %181, i32 0, i32 5
  store i32 512, i32* %stack_depth, align 8
  br label %if.end473

if.end473:                                        ; preds = %if.then471, %if.then466
  %182 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux474 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %182, i32 0, i32 7
  %183 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux474, align 8
  %max_pkt_offset = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %183, i32 0, i32 3
  store i32 65535, i32* %max_pkt_offset, align 8
  %184 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm475 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %184, i32 0, i32 3
  store i32 0, i32* %imm475, align 4
  %185 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code476 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %185, i32 0, i32 0
  store i8 -11, i8* %code476, align 4
  %186 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data477 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %186, i32 0, i32 20
  %187 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data477, align 8
  %188 = load i32, i32* %i, align 4
  %189 = load i32, i32* %delta, align 4
  %add478 = add i32 %188, %189
  %idxprom479 = sext i32 %add478 to i64
  %arrayidx480 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %187, i64 %idxprom479
  store %struct.bpf_insn_aux_data* %arrayidx480, %struct.bpf_insn_aux_data** %aux, align 8
  %190 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %190, i32 0, i32 16
  %191 = load i8, i8* %bpf_capable, align 2
  %tobool481 = trunc i8 %191 to i1
  br i1 %tobool481, label %land.lhs.true483, label %if.end509

land.lhs.true483:                                 ; preds = %if.end473
  %192 = load i8, i8* %expect_blinding, align 1
  %tobool484 = trunc i8 %192 to i1
  br i1 %tobool484, label %if.end509, label %land.lhs.true485

land.lhs.true485:                                 ; preds = %land.lhs.true483
  %193 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %193, i32 0, i32 1
  %bf.load486 = load i16, i16* %jit_requested, align 2
  %bf.lshr487 = lshr i16 %bf.load486, 1
  %bf.clear488 = and i16 %bf.lshr487, 1
  %conv489 = zext i16 %bf.clear488 to i32
  %tobool490 = icmp ne i32 %conv489, 0
  br i1 %tobool490, label %land.lhs.true491, label %if.end509

land.lhs.true491:                                 ; preds = %land.lhs.true485
  %194 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call492 = call zeroext i1 @bpf_map_key_poisoned(%struct.bpf_insn_aux_data* noundef %194) #11
  br i1 %call492, label %if.end509, label %land.lhs.true493

land.lhs.true493:                                 ; preds = %land.lhs.true491
  %195 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call494 = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %195) #11
  br i1 %call494, label %if.end509, label %land.lhs.true495

land.lhs.true495:                                 ; preds = %land.lhs.true493
  %196 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call496 = call zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %196) #11
  br i1 %call496, label %if.end509, label %if.then497

if.then497:                                       ; preds = %land.lhs.true495
  %tailcall_target = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 0
  store i8* null, i8** %tailcall_target, align 8
  %tailcall_bypass = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 1
  store i8* null, i8** %tailcall_bypass, align 8
  %bypass_addr = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 2
  store i8* null, i8** %bypass_addr, align 8
  %197 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 3
  %tail_call = bitcast %union.anon.4* %197 to %struct.anon.5*
  %map = getelementptr inbounds %struct.anon.5, %struct.anon.5* %tail_call, i32 0, i32 0
  %198 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %199 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %198, i32 0, i32 0
  %map_ptr_state = bitcast %struct.atomic64_t* %199 to i64*
  %200 = load i64, i64* %map_ptr_state, align 8
  %and498 = and i64 %200, -2
  %201 = inttoptr i64 %and498 to %struct.bpf_map*
  store %struct.bpf_map* %201, %struct.bpf_map** %map, align 8
  %key = getelementptr inbounds %struct.anon.5, %struct.anon.5* %tail_call, i32 0, i32 1
  %202 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call499 = call i64 @bpf_map_key_immediate(%struct.bpf_insn_aux_data* noundef %202) #11
  %conv500 = trunc i64 %call499 to i32
  store i32 %conv500, i32* %key, align 8
  %tailcall_target_stable = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 4
  store i8 0, i8* %tailcall_target_stable, align 8
  %adj_off = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 5
  store i8 0, i8* %adj_off, align 1
  %reason = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 6
  store i16 0, i16* %reason, align 2
  %insn_idx = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %desc, i32 0, i32 7
  %203 = load i32, i32* %i, align 4
  %204 = load i32, i32* %delta, align 4
  %add501 = add i32 %203, %204
  store i32 %add501, i32* %insn_idx, align 4
  %205 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call502 = call i32 @bpf_jit_add_poke_descriptor(%struct.bpf_prog* noundef %205, %struct.bpf_jit_poke_descriptor* noundef %desc) #11
  store i32 %call502, i32* %ret, align 4
  %206 = load i32, i32* %ret, align 4
  %cmp503 = icmp slt i32 %206, 0
  br i1 %cmp503, label %if.then505, label %if.end506

if.then505:                                       ; preds = %if.then497
  %207 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %208 = bitcast %struct.bpf_verifier_env* %207 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %208, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.380, i64 0, i64 0)) #11
  %209 = load i32, i32* %ret, align 4
  store i32 %209, i32* %retval, align 4
  br label %return

if.end506:                                        ; preds = %if.then497
  %210 = load i32, i32* %ret, align 4
  %add507 = add i32 %210, 1
  %211 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm508 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %211, i32 0, i32 3
  store i32 %add507, i32* %imm508, align 4
  br label %for.inc

if.end509:                                        ; preds = %land.lhs.true495, %land.lhs.true493, %land.lhs.true491, %land.lhs.true485, %land.lhs.true483, %if.end473
  %212 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call510 = call zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %212) #11
  br i1 %call510, label %if.end512, label %if.then511

if.then511:                                       ; preds = %if.end509
  br label %for.inc

if.end512:                                        ; preds = %if.end509
  %213 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call513 = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %213) #11
  br i1 %call513, label %if.then514, label %if.end515

if.then514:                                       ; preds = %if.end512
  %214 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %215 = bitcast %struct.bpf_verifier_env* %214 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %215, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.381, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end515:                                        ; preds = %if.end512
  %216 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %217 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %216, i32 0, i32 0
  %map_ptr_state516 = bitcast %struct.atomic64_t* %217 to i64*
  %218 = load i64, i64* %map_ptr_state516, align 8
  %and517 = and i64 %218, -2
  %219 = inttoptr i64 %and517 to %struct.bpf_map*
  store %struct.bpf_map* %219, %struct.bpf_map** %map_ptr, align 8
  %arrayidx518 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %code520 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral519, i32 0, i32 0
  store i8 53, i8* %code520, align 4
  %dst_reg521 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral519, i32 0, i32 1
  %bf.load522 = load i8, i8* %dst_reg521, align 1
  %bf.clear523 = and i8 %bf.load522, -16
  %bf.set524 = or i8 %bf.clear523, 3
  store i8 %bf.set524, i8* %dst_reg521, align 1
  %src_reg525 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral519, i32 0, i32 1
  %bf.load526 = load i8, i8* %src_reg525, align 1
  %bf.clear527 = and i8 %bf.load526, 15
  %bf.set528 = or i8 %bf.clear527, 0
  store i8 %bf.set528, i8* %src_reg525, align 1
  %off529 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral519, i32 0, i32 2
  store i16 2, i16* %off529, align 2
  %imm530 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral519, i32 0, i32 3
  %220 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %max_entries = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %220, i32 0, i32 6
  %221 = load i32, i32* %max_entries, align 4
  store i32 %221, i32* %imm530, align 4
  %222 = bitcast %struct.bpf_insn* %arrayidx518 to i8*
  %223 = bitcast %struct.bpf_insn* %.compoundliteral519 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %222, i8* align 4 %223, i64 8, i1 false)
  %arrayidx531 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 1
  %code533 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral532, i32 0, i32 0
  store i8 84, i8* %code533, align 4
  %dst_reg534 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral532, i32 0, i32 1
  %bf.load535 = load i8, i8* %dst_reg534, align 1
  %bf.clear536 = and i8 %bf.load535, -16
  %bf.set537 = or i8 %bf.clear536, 3
  store i8 %bf.set537, i8* %dst_reg534, align 1
  %src_reg538 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral532, i32 0, i32 1
  %bf.load539 = load i8, i8* %src_reg538, align 1
  %bf.clear540 = and i8 %bf.load539, 15
  %bf.set541 = or i8 %bf.clear540, 0
  store i8 %bf.set541, i8* %src_reg538, align 1
  %off542 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral532, i32 0, i32 2
  store i16 0, i16* %off542, align 2
  %imm543 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral532, i32 0, i32 3
  %224 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %225 = bitcast %struct.bpf_map* %224 to i8*
  store i8* %225, i8** %__mptr, align 8
  br label %do.body

do.body:                                          ; preds = %if.end515
  br label %do.end

do.end:                                           ; preds = %do.body
  %226 = load i8*, i8** %__mptr, align 8
  %add.ptr544 = getelementptr i8, i8* %226, i64 0
  %227 = bitcast i8* %add.ptr544 to %struct.bpf_array*
  store %struct.bpf_array* %227, %struct.bpf_array** %tmp, align 8
  %228 = load %struct.bpf_array*, %struct.bpf_array** %tmp, align 8
  %index_mask = getelementptr inbounds %struct.bpf_array, %struct.bpf_array* %228, i32 0, i32 2
  %229 = load i32, i32* %index_mask, align 4
  store i32 %229, i32* %imm543, align 4
  %230 = bitcast %struct.bpf_insn* %arrayidx531 to i8*
  %231 = bitcast %struct.bpf_insn* %.compoundliteral532 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %230, i8* align 4 %231, i64 8, i1 false)
  %arrayidx545 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 2
  %232 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %233 = bitcast %struct.bpf_insn* %arrayidx545 to i8*
  %234 = bitcast %struct.bpf_insn* %232 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %233, i8* align 4 %234, i64 8, i1 false)
  store i32 3, i32* %cnt, align 4
  %235 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %236 = load i32, i32* %i, align 4
  %237 = load i32, i32* %delta, align 4
  %add546 = add i32 %236, %237
  %arraydecay547 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %238 = load i32, i32* %cnt, align 4
  %call548 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %235, i32 noundef %add546, %struct.bpf_insn* noundef %arraydecay547, i32 noundef %238) #11
  store %struct.bpf_prog* %call548, %struct.bpf_prog** %new_prog, align 8
  %239 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool549 = icmp ne %struct.bpf_prog* %239, null
  br i1 %tobool549, label %if.end551, label %if.then550

if.then550:                                       ; preds = %do.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end551:                                        ; preds = %do.end
  %240 = load i32, i32* %cnt, align 4
  %sub552 = sub i32 %240, 1
  %241 = load i32, i32* %delta, align 4
  %add553 = add i32 %241, %sub552
  store i32 %add553, i32* %delta, align 4
  %242 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %242, %struct.bpf_prog** %prog, align 8
  %243 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog554 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %243, i32 0, i32 2
  store %struct.bpf_prog* %242, %struct.bpf_prog** %prog554, align 8
  %244 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi555 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %244, i32 0, i32 11
  %arraydecay556 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi555, i64 0, i64 0
  %245 = load i32, i32* %i, align 4
  %idx.ext557 = sext i32 %245 to i64
  %add.ptr558 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay556, i64 %idx.ext557
  %246 = load i32, i32* %delta, align 4
  %idx.ext559 = sext i32 %246 to i64
  %add.ptr560 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr558, i64 %idx.ext559
  store %struct.bpf_insn* %add.ptr560, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end561:                                        ; preds = %if.end462
  %247 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested562 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %247, i32 0, i32 1
  %bf.load563 = load i16, i16* %jit_requested562, align 2
  %bf.lshr564 = lshr i16 %bf.load563, 1
  %bf.clear565 = and i16 %bf.lshr564, 1
  %conv566 = zext i16 %bf.clear565 to i32
  %tobool567 = icmp ne i32 %conv566, 0
  br i1 %tobool567, label %land.lhs.true568, label %if.end682

land.lhs.true568:                                 ; preds = %if.end561
  %248 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm569 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %248, i32 0, i32 3
  %249 = load i32, i32* %imm569, align 4
  %cmp570 = icmp eq i32 %249, 1
  br i1 %cmp570, label %if.then592, label %lor.lhs.false572

lor.lhs.false572:                                 ; preds = %land.lhs.true568
  %250 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm573 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %250, i32 0, i32 3
  %251 = load i32, i32* %imm573, align 4
  %cmp574 = icmp eq i32 %251, 2
  br i1 %cmp574, label %if.then592, label %lor.lhs.false576

lor.lhs.false576:                                 ; preds = %lor.lhs.false572
  %252 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm577 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %252, i32 0, i32 3
  %253 = load i32, i32* %imm577, align 4
  %cmp578 = icmp eq i32 %253, 3
  br i1 %cmp578, label %if.then592, label %lor.lhs.false580

lor.lhs.false580:                                 ; preds = %lor.lhs.false576
  %254 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm581 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %254, i32 0, i32 3
  %255 = load i32, i32* %imm581, align 4
  %cmp582 = icmp eq i32 %255, 87
  br i1 %cmp582, label %if.then592, label %lor.lhs.false584

lor.lhs.false584:                                 ; preds = %lor.lhs.false580
  %256 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm585 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %256, i32 0, i32 3
  %257 = load i32, i32* %imm585, align 4
  %cmp586 = icmp eq i32 %257, 88
  br i1 %cmp586, label %if.then592, label %lor.lhs.false588

lor.lhs.false588:                                 ; preds = %lor.lhs.false584
  %258 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm589 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %258, i32 0, i32 3
  %259 = load i32, i32* %imm589, align 4
  %cmp590 = icmp eq i32 %259, 89
  br i1 %cmp590, label %if.then592, label %if.end682

if.then592:                                       ; preds = %lor.lhs.false588, %lor.lhs.false584, %lor.lhs.false580, %lor.lhs.false576, %lor.lhs.false572, %land.lhs.true568
  %260 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data593 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %260, i32 0, i32 20
  %261 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data593, align 8
  %262 = load i32, i32* %i, align 4
  %263 = load i32, i32* %delta, align 4
  %add594 = add i32 %262, %263
  %idxprom595 = sext i32 %add594 to i64
  %arrayidx596 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %261, i64 %idxprom595
  store %struct.bpf_insn_aux_data* %arrayidx596, %struct.bpf_insn_aux_data** %aux, align 8
  %264 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call597 = call zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %264) #11
  br i1 %call597, label %if.then598, label %if.end599

if.then598:                                       ; preds = %if.then592
  br label %patch_call_imm

if.end599:                                        ; preds = %if.then592
  %265 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %266 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %265, i32 0, i32 0
  %map_ptr_state600 = bitcast %struct.atomic64_t* %266 to i64*
  %267 = load i64, i64* %map_ptr_state600, align 8
  %and601 = and i64 %267, -2
  %268 = inttoptr i64 %and601 to %struct.bpf_map*
  store %struct.bpf_map* %268, %struct.bpf_map** %map_ptr, align 8
  %269 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops602 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %269, i32 0, i32 0
  %270 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops602, align 64
  store %struct.bpf_map_ops* %270, %struct.bpf_map_ops** %ops, align 8
  %271 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm603 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %271, i32 0, i32 3
  %272 = load i32, i32* %imm603, align 4
  %cmp604 = icmp eq i32 %272, 1
  br i1 %cmp604, label %land.lhs.true606, label %if.end639

land.lhs.true606:                                 ; preds = %if.end599
  %273 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_gen_lookup = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %273, i32 0, i32 19
  %274 = load i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)** %map_gen_lookup, align 8
  %tobool607 = icmp ne i32 (%struct.bpf_map*, %struct.bpf_insn*)* %274, null
  br i1 %tobool607, label %if.then608, label %if.end639

if.then608:                                       ; preds = %land.lhs.true606
  %275 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_gen_lookup609 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %275, i32 0, i32 19
  %276 = load i32 (%struct.bpf_map*, %struct.bpf_insn*)*, i32 (%struct.bpf_map*, %struct.bpf_insn*)** %map_gen_lookup609, align 8
  %277 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %arraydecay610 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %call611 = call i32 %276(%struct.bpf_map* noundef %277, %struct.bpf_insn* noundef %arraydecay610) #11
  store i32 %call611, i32* %cnt, align 4
  %278 = load i32, i32* %cnt, align 4
  %cmp612 = icmp eq i32 %278, -95
  br i1 %cmp612, label %if.then614, label %if.end615

if.then614:                                       ; preds = %if.then608
  br label %patch_map_ops_generic

if.end615:                                        ; preds = %if.then608
  %279 = load i32, i32* %cnt, align 4
  %cmp616 = icmp sle i32 %279, 0
  br i1 %cmp616, label %if.then622, label %lor.lhs.false618

lor.lhs.false618:                                 ; preds = %if.end615
  %280 = load i32, i32* %cnt, align 4
  %conv619 = sext i32 %280 to i64
  %cmp620 = icmp uge i64 %conv619, 16
  br i1 %cmp620, label %if.then622, label %if.end623

if.then622:                                       ; preds = %lor.lhs.false618, %if.end615
  %281 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %282 = bitcast %struct.bpf_verifier_env* %281 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %282, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.367, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end623:                                        ; preds = %lor.lhs.false618
  %283 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %284 = load i32, i32* %i, align 4
  %285 = load i32, i32* %delta, align 4
  %add624 = add i32 %284, %285
  %arraydecay625 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %286 = load i32, i32* %cnt, align 4
  %call626 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %283, i32 noundef %add624, %struct.bpf_insn* noundef %arraydecay625, i32 noundef %286) #11
  store %struct.bpf_prog* %call626, %struct.bpf_prog** %new_prog, align 8
  %287 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool627 = icmp ne %struct.bpf_prog* %287, null
  br i1 %tobool627, label %if.end629, label %if.then628

if.then628:                                       ; preds = %if.end623
  store i32 -12, i32* %retval, align 4
  br label %return

if.end629:                                        ; preds = %if.end623
  %288 = load i32, i32* %cnt, align 4
  %sub630 = sub i32 %288, 1
  %289 = load i32, i32* %delta, align 4
  %add631 = add i32 %289, %sub630
  store i32 %add631, i32* %delta, align 4
  %290 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %290, %struct.bpf_prog** %prog, align 8
  %291 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog632 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %291, i32 0, i32 2
  store %struct.bpf_prog* %290, %struct.bpf_prog** %prog632, align 8
  %292 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi633 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %292, i32 0, i32 11
  %arraydecay634 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi633, i64 0, i64 0
  %293 = load i32, i32* %i, align 4
  %idx.ext635 = sext i32 %293 to i64
  %add.ptr636 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay634, i64 %idx.ext635
  %294 = load i32, i32* %delta, align 4
  %idx.ext637 = sext i32 %294 to i64
  %add.ptr638 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr636, i64 %idx.ext637
  store %struct.bpf_insn* %add.ptr638, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end639:                                        ; preds = %land.lhs.true606, %if.end599
  br label %do.body640

do.body640:                                       ; preds = %if.end639
  br label %do.end641

do.end641:                                        ; preds = %do.body640
  br label %do.body642

do.body642:                                       ; preds = %do.end641
  br label %do.end643

do.end643:                                        ; preds = %do.body642
  br label %do.body644

do.body644:                                       ; preds = %do.end643
  br label %do.end645

do.end645:                                        ; preds = %do.body644
  br label %do.body646

do.body646:                                       ; preds = %do.end645
  br label %do.end647

do.end647:                                        ; preds = %do.body646
  br label %do.body648

do.body648:                                       ; preds = %do.end647
  br label %do.end649

do.end649:                                        ; preds = %do.body648
  br label %do.body650

do.body650:                                       ; preds = %do.end649
  br label %do.end651

do.end651:                                        ; preds = %do.body650
  br label %patch_map_ops_generic

patch_map_ops_generic:                            ; preds = %do.end651, %if.then614
  %295 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm652 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %295, i32 0, i32 3
  %296 = load i32, i32* %imm652, align 4
  switch i32 %296, label %sw.epilog [
    i32 1, label %sw.bb
    i32 2, label %sw.bb657
    i32 3, label %sw.bb662
    i32 87, label %sw.bb667
    i32 88, label %sw.bb672
    i32 89, label %sw.bb677
  ]

sw.bb:                                            ; preds = %patch_map_ops_generic
  %297 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_lookup_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %297, i32 0, i32 11
  %298 = load i8* (%struct.bpf_map*, i8*)*, i8* (%struct.bpf_map*, i8*)** %map_lookup_elem, align 8
  %299 = bitcast i8* (%struct.bpf_map*, i8*)* %298 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast653 = ptrtoint i64 (i64, i64, i64, i64, i64)* %299 to i64
  %sub.ptr.sub654 = sub i64 %sub.ptr.lhs.cast653, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv655 = trunc i64 %sub.ptr.sub654 to i32
  %300 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm656 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %300, i32 0, i32 3
  store i32 %conv655, i32* %imm656, align 4
  br label %for.inc

sw.bb657:                                         ; preds = %patch_map_ops_generic
  %301 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_update_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %301, i32 0, i32 12
  %302 = load i32 (%struct.bpf_map*, i8*, i8*, i64)*, i32 (%struct.bpf_map*, i8*, i8*, i64)** %map_update_elem, align 8
  %303 = bitcast i32 (%struct.bpf_map*, i8*, i8*, i64)* %302 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast658 = ptrtoint i64 (i64, i64, i64, i64, i64)* %303 to i64
  %sub.ptr.sub659 = sub i64 %sub.ptr.lhs.cast658, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv660 = trunc i64 %sub.ptr.sub659 to i32
  %304 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm661 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %304, i32 0, i32 3
  store i32 %conv660, i32* %imm661, align 4
  br label %for.inc

sw.bb662:                                         ; preds = %patch_map_ops_generic
  %305 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_delete_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %305, i32 0, i32 13
  %306 = load i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)** %map_delete_elem, align 8
  %307 = bitcast i32 (%struct.bpf_map*, i8*)* %306 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast663 = ptrtoint i64 (i64, i64, i64, i64, i64)* %307 to i64
  %sub.ptr.sub664 = sub i64 %sub.ptr.lhs.cast663, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv665 = trunc i64 %sub.ptr.sub664 to i32
  %308 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm666 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %308, i32 0, i32 3
  store i32 %conv665, i32* %imm666, align 4
  br label %for.inc

sw.bb667:                                         ; preds = %patch_map_ops_generic
  %309 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_push_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %309, i32 0, i32 14
  %310 = load i32 (%struct.bpf_map*, i8*, i64)*, i32 (%struct.bpf_map*, i8*, i64)** %map_push_elem, align 8
  %311 = bitcast i32 (%struct.bpf_map*, i8*, i64)* %310 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast668 = ptrtoint i64 (i64, i64, i64, i64, i64)* %311 to i64
  %sub.ptr.sub669 = sub i64 %sub.ptr.lhs.cast668, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv670 = trunc i64 %sub.ptr.sub669 to i32
  %312 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm671 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %312, i32 0, i32 3
  store i32 %conv670, i32* %imm671, align 4
  br label %for.inc

sw.bb672:                                         ; preds = %patch_map_ops_generic
  %313 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_pop_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %313, i32 0, i32 15
  %314 = load i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)** %map_pop_elem, align 8
  %315 = bitcast i32 (%struct.bpf_map*, i8*)* %314 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast673 = ptrtoint i64 (i64, i64, i64, i64, i64)* %315 to i64
  %sub.ptr.sub674 = sub i64 %sub.ptr.lhs.cast673, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv675 = trunc i64 %sub.ptr.sub674 to i32
  %316 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm676 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %316, i32 0, i32 3
  store i32 %conv675, i32* %imm676, align 4
  br label %for.inc

sw.bb677:                                         ; preds = %patch_map_ops_generic
  %317 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 8
  %map_peek_elem = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %317, i32 0, i32 16
  %318 = load i32 (%struct.bpf_map*, i8*)*, i32 (%struct.bpf_map*, i8*)** %map_peek_elem, align 8
  %319 = bitcast i32 (%struct.bpf_map*, i8*)* %318 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast678 = ptrtoint i64 (i64, i64, i64, i64, i64)* %319 to i64
  %sub.ptr.sub679 = sub i64 %sub.ptr.lhs.cast678, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv680 = trunc i64 %sub.ptr.sub679 to i32
  %320 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm681 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %320, i32 0, i32 3
  store i32 %conv680, i32* %imm681, align 4
  br label %for.inc

sw.epilog:                                        ; preds = %patch_map_ops_generic
  br label %patch_call_imm

if.end682:                                        ; preds = %lor.lhs.false588, %if.end561
  %321 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested683 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %321, i32 0, i32 1
  %bf.load684 = load i16, i16* %jit_requested683, align 2
  %bf.lshr685 = lshr i16 %bf.load684, 1
  %bf.clear686 = and i16 %bf.lshr685, 1
  %conv687 = zext i16 %bf.clear686 to i32
  %tobool688 = icmp ne i32 %conv687, 0
  br i1 %tobool688, label %land.lhs.true689, label %if.end750

land.lhs.true689:                                 ; preds = %if.end682
  %322 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm690 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %322, i32 0, i32 3
  %323 = load i32, i32* %imm690, align 4
  %cmp691 = icmp eq i32 %323, 118
  br i1 %cmp691, label %if.then693, label %if.end750

if.then693:                                       ; preds = %land.lhs.true689
  %arrayinit.begin694 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_jiffies_addr, i64 0, i64 0
  %code695 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin694, i32 0, i32 0
  store i8 24, i8* %code695, align 8
  %dst_reg696 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin694, i32 0, i32 1
  %bf.load697 = load i8, i8* %dst_reg696, align 1
  %bf.clear698 = and i8 %bf.load697, -16
  %bf.set699 = or i8 %bf.clear698, 0
  store i8 %bf.set699, i8* %dst_reg696, align 1
  %src_reg700 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin694, i32 0, i32 1
  %bf.load701 = load i8, i8* %src_reg700, align 1
  %bf.clear702 = and i8 %bf.load701, 15
  %bf.set703 = or i8 %bf.clear702, 0
  store i8 %bf.set703, i8* %src_reg700, align 1
  %off704 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin694, i32 0, i32 2
  store i16 0, i16* %off704, align 2
  %imm705 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin694, i32 0, i32 3
  store i32 ptrtoint (i64* @jiffies to i32), i32* %imm705, align 4
  %arrayinit.element706 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.begin694, i64 1
  %code707 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element706, i32 0, i32 0
  store i8 0, i8* %code707, align 8
  %dst_reg708 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element706, i32 0, i32 1
  %bf.load709 = load i8, i8* %dst_reg708, align 1
  %bf.clear710 = and i8 %bf.load709, -16
  %bf.set711 = or i8 %bf.clear710, 0
  store i8 %bf.set711, i8* %dst_reg708, align 1
  %src_reg712 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element706, i32 0, i32 1
  %bf.load713 = load i8, i8* %src_reg712, align 1
  %bf.clear714 = and i8 %bf.load713, 15
  %bf.set715 = or i8 %bf.clear714, 0
  store i8 %bf.set715, i8* %src_reg712, align 1
  %off716 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element706, i32 0, i32 2
  store i16 0, i16* %off716, align 2
  %imm717 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayinit.element706, i32 0, i32 3
  store i32 trunc (i64 lshr (i64 ptrtoint (i64* @jiffies to i64), i64 32) to i32), i32* %imm717, align 4
  %arrayidx718 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %arrayidx719 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_jiffies_addr, i64 0, i64 0
  %324 = bitcast %struct.bpf_insn* %arrayidx718 to i8*
  %325 = bitcast %struct.bpf_insn* %arrayidx719 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %324, i8* align 16 %325, i64 8, i1 false)
  %arrayidx720 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 1
  %arrayidx721 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %ld_jiffies_addr, i64 0, i64 1
  %326 = bitcast %struct.bpf_insn* %arrayidx720 to i8*
  %327 = bitcast %struct.bpf_insn* %arrayidx721 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %326, i8* align 8 %327, i64 8, i1 false)
  %arrayidx722 = getelementptr [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 2
  %code724 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral723, i32 0, i32 0
  store i8 121, i8* %code724, align 4
  %dst_reg725 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral723, i32 0, i32 1
  %bf.load726 = load i8, i8* %dst_reg725, align 1
  %bf.clear727 = and i8 %bf.load726, -16
  %bf.set728 = or i8 %bf.clear727, 0
  store i8 %bf.set728, i8* %dst_reg725, align 1
  %src_reg729 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral723, i32 0, i32 1
  %bf.load730 = load i8, i8* %src_reg729, align 1
  %bf.clear731 = and i8 %bf.load730, 15
  %bf.set732 = or i8 %bf.clear731, 0
  store i8 %bf.set732, i8* %src_reg729, align 1
  %off733 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral723, i32 0, i32 2
  store i16 0, i16* %off733, align 2
  %imm734 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral723, i32 0, i32 3
  store i32 0, i32* %imm734, align 4
  %328 = bitcast %struct.bpf_insn* %arrayidx722 to i8*
  %329 = bitcast %struct.bpf_insn* %.compoundliteral723 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %328, i8* align 4 %329, i64 8, i1 false)
  store i32 3, i32* %cnt, align 4
  %330 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %331 = load i32, i32* %i, align 4
  %332 = load i32, i32* %delta, align 4
  %add735 = add i32 %331, %332
  %arraydecay736 = getelementptr inbounds [16 x %struct.bpf_insn], [16 x %struct.bpf_insn]* %insn_buf, i64 0, i64 0
  %333 = load i32, i32* %cnt, align 4
  %call737 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %330, i32 noundef %add735, %struct.bpf_insn* noundef %arraydecay736, i32 noundef %333) #11
  store %struct.bpf_prog* %call737, %struct.bpf_prog** %new_prog, align 8
  %334 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool738 = icmp ne %struct.bpf_prog* %334, null
  br i1 %tobool738, label %if.end740, label %if.then739

if.then739:                                       ; preds = %if.then693
  store i32 -12, i32* %retval, align 4
  br label %return

if.end740:                                        ; preds = %if.then693
  %335 = load i32, i32* %cnt, align 4
  %sub741 = sub i32 %335, 1
  %336 = load i32, i32* %delta, align 4
  %add742 = add i32 %336, %sub741
  store i32 %add742, i32* %delta, align 4
  %337 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %337, %struct.bpf_prog** %prog, align 8
  %338 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog743 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %338, i32 0, i32 2
  store %struct.bpf_prog* %337, %struct.bpf_prog** %prog743, align 8
  %339 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi744 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %339, i32 0, i32 11
  %arraydecay745 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi744, i64 0, i64 0
  %340 = load i32, i32* %i, align 4
  %idx.ext746 = sext i32 %340 to i64
  %add.ptr747 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay745, i64 %idx.ext746
  %341 = load i32, i32* %delta, align 4
  %idx.ext748 = sext i32 %341 to i64
  %add.ptr749 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr747, i64 %idx.ext748
  store %struct.bpf_insn* %add.ptr749, %struct.bpf_insn** %insn, align 8
  br label %for.inc

if.end750:                                        ; preds = %land.lhs.true689, %if.end682
  br label %patch_call_imm

patch_call_imm:                                   ; preds = %if.end750, %sw.epilog, %if.then598
  %342 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops751 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %342, i32 0, i32 3
  %343 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops751, align 8
  %get_func_proto = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %343, i32 0, i32 0
  %344 = load %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, %struct.bpf_func_proto* (i32, %struct.bpf_prog*)** %get_func_proto, align 8
  %345 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm752 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %345, i32 0, i32 3
  %346 = load i32, i32* %imm752, align 4
  %347 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog753 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %347, i32 0, i32 2
  %348 = load %struct.bpf_prog*, %struct.bpf_prog** %prog753, align 8
  %call754 = call %struct.bpf_func_proto* %344(i32 noundef %346, %struct.bpf_prog* noundef %348) #11
  store %struct.bpf_func_proto* %call754, %struct.bpf_func_proto** %fn, align 8
  %349 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %func = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %349, i32 0, i32 0
  %350 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %func, align 8
  %tobool755 = icmp ne i64 (i64, i64, i64, i64, i64)* %350, null
  br i1 %tobool755, label %if.end760, label %if.then756

if.then756:                                       ; preds = %patch_call_imm
  %351 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %352 = bitcast %struct.bpf_verifier_env* %351 to i8*
  %353 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm757 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %353, i32 0, i32 3
  %354 = load i32, i32* %imm757, align 4
  %call758 = call i8* @func_id_name(i32 noundef %354) #11
  %355 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm759 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %355, i32 0, i32 3
  %356 = load i32, i32* %imm759, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %352, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.294, i64 0, i64 0), i8* noundef %call758, i32 noundef %356) #11
  store i32 -14, i32* %retval, align 4
  br label %return

if.end760:                                        ; preds = %patch_call_imm
  %357 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %func761 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %357, i32 0, i32 0
  %358 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %func761, align 8
  %sub.ptr.lhs.cast762 = ptrtoint i64 (i64, i64, i64, i64, i64)* %358 to i64
  %sub.ptr.sub763 = sub i64 %sub.ptr.lhs.cast762, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv764 = trunc i64 %sub.ptr.sub763 to i32
  %359 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm765 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %359, i32 0, i32 3
  store i32 %conv764, i32* %imm765, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end760, %if.end740, %sw.bb677, %sw.bb672, %sw.bb667, %sw.bb662, %sw.bb657, %sw.bb, %if.end629, %if.end551, %if.then511, %if.end506, %if.then440, %if.then432, %if.end417, %if.then226, %if.end196, %if.end152
  %360 = load i32, i32* %i, align 4
  %inc = add i32 %360, 1
  store i32 %inc, i32* %i, align 4
  %361 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr766 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %361, i32 1
  store %struct.bpf_insn* %incdec.ptr766, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond767

for.cond767:                                      ; preds = %for.inc795, %for.end
  %362 = load i32, i32* %i, align 4
  %363 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux768 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %363, i32 0, i32 7
  %364 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux768, align 8
  %size_poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %364, i32 0, i32 32
  %365 = load i32, i32* %size_poke_tab, align 8
  %cmp769 = icmp ult i32 %362, %365
  br i1 %cmp769, label %for.body771, label %for.end797

for.body771:                                      ; preds = %for.cond767
  %366 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux772 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %366, i32 0, i32 7
  %367 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux772, align 8
  %poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %367, i32 0, i32 31
  %368 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab, align 8
  %369 = load i32, i32* %i, align 4
  %idxprom773 = sext i32 %369 to i64
  %arrayidx774 = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %368, i64 %idxprom773
  %370 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %arrayidx774, i32 0, i32 3
  %tail_call775 = bitcast %union.anon.4* %370 to %struct.anon.5*
  %map776 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %tail_call775, i32 0, i32 0
  %371 = load %struct.bpf_map*, %struct.bpf_map** %map776, align 8
  store %struct.bpf_map* %371, %struct.bpf_map** %map_ptr, align 8
  %372 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops777 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %372, i32 0, i32 0
  %373 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops777, align 64
  %map_poke_track = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %373, i32 0, i32 23
  %374 = load i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)*, i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_track, align 8
  %tobool778 = icmp ne i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)* %374, null
  br i1 %tobool778, label %lor.lhs.false779, label %if.then785

lor.lhs.false779:                                 ; preds = %for.body771
  %375 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops780 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %375, i32 0, i32 0
  %376 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops780, align 64
  %map_poke_untrack = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %376, i32 0, i32 24
  %377 = load void (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_untrack, align 8
  %tobool781 = icmp ne void (%struct.bpf_map*, %struct.bpf_prog_aux*)* %377, null
  br i1 %tobool781, label %lor.lhs.false782, label %if.then785

lor.lhs.false782:                                 ; preds = %lor.lhs.false779
  %378 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops783 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %378, i32 0, i32 0
  %379 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops783, align 64
  %map_poke_run = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %379, i32 0, i32 25
  %380 = load void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)*, void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)** %map_poke_run, align 8
  %tobool784 = icmp ne void (%struct.bpf_map*, i32, %struct.bpf_prog*, %struct.bpf_prog*)* %380, null
  br i1 %tobool784, label %if.end786, label %if.then785

if.then785:                                       ; preds = %lor.lhs.false782, %lor.lhs.false779, %for.body771
  %381 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %382 = bitcast %struct.bpf_verifier_env* %381 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %382, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.367, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end786:                                        ; preds = %lor.lhs.false782
  %383 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops787 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %383, i32 0, i32 0
  %384 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops787, align 64
  %map_poke_track788 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %384, i32 0, i32 23
  %385 = load i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)*, i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_track788, align 8
  %386 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %387 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux789 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %387, i32 0, i32 7
  %388 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux789, align 8
  %call790 = call i32 %385(%struct.bpf_map* noundef %386, %struct.bpf_prog_aux* noundef %388) #11
  store i32 %call790, i32* %ret, align 4
  %389 = load i32, i32* %ret, align 4
  %cmp791 = icmp slt i32 %389, 0
  br i1 %cmp791, label %if.then793, label %if.end794

if.then793:                                       ; preds = %if.end786
  %390 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %391 = bitcast %struct.bpf_verifier_env* %390 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %391, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.382, i64 0, i64 0)) #11
  %392 = load i32, i32* %ret, align 4
  store i32 %392, i32* %retval, align 4
  br label %return

if.end794:                                        ; preds = %if.end786
  br label %for.inc795

for.inc795:                                       ; preds = %if.end794
  %393 = load i32, i32* %i, align 4
  %inc796 = add i32 %393, 1
  store i32 %inc796, i32* %i, align 4
  br label %for.cond767

for.end797:                                       ; preds = %for.cond767
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end797, %if.then793, %if.then785, %if.then756, %if.then739, %if.then628, %if.then622, %if.then550, %if.then514, %if.then505, %if.then416, %if.then195, %if.then189, %if.then151
  %394 = load i32, i32* %retval, align 4
  ret i32 %394
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @opt_subreg_zext_lo32_rnd_hi32(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %patch = alloca %struct.bpf_insn*, align 8
  %zext_patch = alloca [2 x %struct.bpf_insn], align 16
  %rnd_hi32_patch = alloca [4 x %struct.bpf_insn], align 16
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %i = alloca i32, align 4
  %patch_len = alloca i32, align 4
  %delta = alloca i32, align 4
  %len = alloca i32, align 4
  %insns = alloca %struct.bpf_insn*, align 8
  %new_prog = alloca %struct.bpf_prog*, align 8
  %rnd_hi32 = alloca i8, align 1
  %.compoundliteral = alloca %struct.bpf_insn, align 4
  %.compoundliteral7 = alloca %struct.bpf_insn, align 4
  %.compoundliteral20 = alloca %struct.bpf_insn, align 4
  %.compoundliteral33 = alloca %struct.bpf_insn, align 4
  %adj_idx = alloca i32, align 4
  %insn = alloca %struct.bpf_insn, align 4
  %code49 = alloca i8, align 1
  %class = alloca i8, align 1
  %imm_rnd = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 20
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux, align 8
  store i32 0, i32* %delta, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len1, align 4
  store i32 %4, i32* %len, align 4
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insns, align 8
  %7 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %8 = bitcast %union.bpf_attr* %7 to %struct.anon.10*
  %prog_flags = getelementptr inbounds %struct.anon.10, %struct.anon.10* %8, i32 0, i32 8
  %9 = load i32, i32* %prog_flags, align 4
  %and = and i32 %9, 4
  %tobool = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* %rnd_hi32, align 1
  %arrayidx = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 1
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 0
  store i8 -68, i8* %code, align 4
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, -16
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, i8* %dst_reg, align 1
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 1
  %bf.load3 = load i8, i8* %src_reg, align 1
  %bf.clear4 = and i8 %bf.load3, 15
  %bf.set5 = or i8 %bf.clear4, 0
  store i8 %bf.set5, i8* %src_reg, align 1
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 2
  store i16 0, i16* %off, align 2
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral, i32 0, i32 3
  store i32 1, i32* %imm, align 4
  %10 = bitcast %struct.bpf_insn* %arrayidx to i8*
  %11 = bitcast %struct.bpf_insn* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %10, i8* align 4 %11, i64 8, i1 false)
  %arrayidx6 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 1
  %code8 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 0
  store i8 -73, i8* %code8, align 4
  %dst_reg9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 1
  %bf.load10 = load i8, i8* %dst_reg9, align 1
  %bf.clear11 = and i8 %bf.load10, -16
  %bf.set12 = or i8 %bf.clear11, 11
  store i8 %bf.set12, i8* %dst_reg9, align 1
  %src_reg13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 1
  %bf.load14 = load i8, i8* %src_reg13, align 1
  %bf.clear15 = and i8 %bf.load14, 15
  %bf.set16 = or i8 %bf.clear15, 0
  store i8 %bf.set16, i8* %src_reg13, align 1
  %off17 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 2
  store i16 0, i16* %off17, align 2
  %imm18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral7, i32 0, i32 3
  store i32 0, i32* %imm18, align 4
  %12 = bitcast %struct.bpf_insn* %arrayidx6 to i8*
  %13 = bitcast %struct.bpf_insn* %.compoundliteral7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %12, i8* align 4 %13, i64 8, i1 false)
  %arrayidx19 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 2
  %code21 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 0
  store i8 103, i8* %code21, align 4
  %dst_reg22 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 1
  %bf.load23 = load i8, i8* %dst_reg22, align 1
  %bf.clear24 = and i8 %bf.load23, -16
  %bf.set25 = or i8 %bf.clear24, 11
  store i8 %bf.set25, i8* %dst_reg22, align 1
  %src_reg26 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 1
  %bf.load27 = load i8, i8* %src_reg26, align 1
  %bf.clear28 = and i8 %bf.load27, 15
  %bf.set29 = or i8 %bf.clear28, 0
  store i8 %bf.set29, i8* %src_reg26, align 1
  %off30 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 2
  store i16 0, i16* %off30, align 2
  %imm31 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral20, i32 0, i32 3
  store i32 32, i32* %imm31, align 4
  %14 = bitcast %struct.bpf_insn* %arrayidx19 to i8*
  %15 = bitcast %struct.bpf_insn* %.compoundliteral20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %14, i8* align 4 %15, i64 8, i1 false)
  %arrayidx32 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 3
  %code34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 0
  store i8 79, i8* %code34, align 4
  %dst_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 1
  %bf.load36 = load i8, i8* %dst_reg35, align 1
  %bf.clear37 = and i8 %bf.load36, -16
  %bf.set38 = or i8 %bf.clear37, 0
  store i8 %bf.set38, i8* %dst_reg35, align 1
  %src_reg39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 1
  %bf.load40 = load i8, i8* %src_reg39, align 1
  %bf.clear41 = and i8 %bf.load40, 15
  %bf.set42 = or i8 %bf.clear41, -80
  store i8 %bf.set42, i8* %src_reg39, align 1
  %off43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 2
  store i16 0, i16* %off43, align 2
  %imm44 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %.compoundliteral33, i32 0, i32 3
  store i32 0, i32* %imm44, align 4
  %16 = bitcast %struct.bpf_insn* %arrayidx32 to i8*
  %17 = bitcast %struct.bpf_insn* %.compoundliteral33 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 4 %17, i64 8, i1 false)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %18 = load i32, i32* %i, align 4
  %19 = load i32, i32* %len, align 4
  %cmp = icmp slt i32 %18, %19
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load i32, i32* %i, align 4
  %21 = load i32, i32* %delta, align 4
  %add = add i32 %20, %21
  store i32 %add, i32* %adj_idx, align 4
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %23 = load i32, i32* %adj_idx, align 4
  %idxprom = sext i32 %23 to i64
  %arrayidx45 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %22, i64 %idxprom
  %24 = bitcast %struct.bpf_insn* %insn to i8*
  %25 = bitcast %struct.bpf_insn* %arrayidx45 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %24, i8* align 4 %25, i64 8, i1 false)
  %26 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %27 = load i32, i32* %adj_idx, align 4
  %idxprom46 = sext i32 %27 to i64
  %arrayidx47 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %26, i64 %idxprom46
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx47, i32 0, i32 5
  %28 = load i8, i8* %zext_dst, align 4
  %tobool48 = trunc i8 %28 to i1
  br i1 %tobool48, label %if.end96, label %if.then

if.then:                                          ; preds = %for.body
  %29 = load i8, i8* %rnd_hi32, align 1
  %tobool50 = trunc i8 %29 to i1
  br i1 %tobool50, label %if.end, label %if.then51

if.then51:                                        ; preds = %if.then
  br label %for.inc

if.end:                                           ; preds = %if.then
  %code52 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 0
  %30 = load i8, i8* %code52, align 4
  store i8 %30, i8* %code49, align 1
  %31 = load i8, i8* %code49, align 1
  %conv = zext i8 %31 to i32
  %and53 = and i32 %conv, 7
  %conv54 = trunc i32 %and53 to i8
  store i8 %conv54, i8* %class, align 1
  %call = call zeroext i1 @insn_no_def(%struct.bpf_insn* noundef %insn) #11
  br i1 %call, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end
  br label %for.inc

if.end56:                                         ; preds = %if.end
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %dst_reg57 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 1
  %bf.load58 = load i8, i8* %dst_reg57, align 1
  %bf.clear59 = and i8 %bf.load58, 15
  %conv60 = zext i8 %bf.clear59 to i32
  %call61 = call zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %32, %struct.bpf_insn* noundef %insn, i32 noundef %conv60, %struct.bpf_reg_state* noundef null, i32 noundef 1) #11
  br i1 %call61, label %if.then62, label %if.end72

if.then62:                                        ; preds = %if.end56
  %33 = load i8, i8* %class, align 1
  %conv63 = zext i8 %33 to i32
  %cmp64 = icmp eq i32 %conv63, 0
  br i1 %cmp64, label %land.lhs.true, label %if.end71

land.lhs.true:                                    ; preds = %if.then62
  %34 = load i8, i8* %code49, align 1
  %conv66 = zext i8 %34 to i32
  %and67 = and i32 %conv66, 224
  %cmp68 = icmp eq i32 %and67, 0
  br i1 %cmp68, label %if.then70, label %if.end71

if.then70:                                        ; preds = %land.lhs.true
  %35 = load i32, i32* %i, align 4
  %inc = add i32 %35, 1
  store i32 %inc, i32* %i, align 4
  br label %if.end71

if.end71:                                         ; preds = %if.then70, %land.lhs.true, %if.then62
  br label %for.inc

if.end72:                                         ; preds = %if.end56
  %36 = load i8, i8* %class, align 1
  %conv73 = zext i8 %36 to i32
  %cmp74 = icmp eq i32 %conv73, 1
  br i1 %cmp74, label %land.lhs.true76, label %if.end82

land.lhs.true76:                                  ; preds = %if.end72
  %37 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %38 = load i32, i32* %adj_idx, align 4
  %idxprom77 = sext i32 %38 to i64
  %arrayidx78 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %37, i64 %idxprom77
  %39 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx78, i32 0, i32 0
  %ptr_type = bitcast %struct.atomic64_t* %39 to i32*
  %40 = load i32, i32* %ptr_type, align 8
  %cmp79 = icmp eq i32 %40, 2
  br i1 %cmp79, label %if.then81, label %if.end82

if.then81:                                        ; preds = %land.lhs.true76
  br label %for.inc

if.end82:                                         ; preds = %land.lhs.true76, %if.end72
  %call83 = call i32 @get_random_int() #11
  store i32 %call83, i32* %imm_rnd, align 4
  %arrayidx84 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 0
  %41 = bitcast %struct.bpf_insn* %arrayidx84 to i8*
  %42 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %41, i8* align 4 %42, i64 8, i1 false)
  %43 = load i32, i32* %imm_rnd, align 4
  %arrayidx85 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 1
  %imm86 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx85, i32 0, i32 3
  store i32 %43, i32* %imm86, align 4
  %dst_reg87 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 1
  %bf.load88 = load i8, i8* %dst_reg87, align 1
  %bf.clear89 = and i8 %bf.load88, 15
  %arrayidx90 = getelementptr [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 3
  %dst_reg91 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx90, i32 0, i32 1
  %bf.load92 = load i8, i8* %dst_reg91, align 1
  %bf.value = and i8 %bf.clear89, 15
  %bf.clear93 = and i8 %bf.load92, -16
  %bf.set94 = or i8 %bf.clear93, %bf.value
  store i8 %bf.set94, i8* %dst_reg91, align 1
  %arraydecay95 = getelementptr inbounds [4 x %struct.bpf_insn], [4 x %struct.bpf_insn]* %rnd_hi32_patch, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay95, %struct.bpf_insn** %patch, align 8
  store i32 4, i32* %patch_len, align 4
  br label %apply_patch_buffer

if.end96:                                         ; preds = %for.body
  %call97 = call zeroext i1 @bpf_jit_needs_zext() #11
  br i1 %call97, label %if.end99, label %if.then98

if.then98:                                        ; preds = %if.end96
  br label %for.inc

if.end99:                                         ; preds = %if.end96
  %arrayidx100 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 0
  %44 = bitcast %struct.bpf_insn* %arrayidx100 to i8*
  %45 = bitcast %struct.bpf_insn* %insn to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %44, i8* align 4 %45, i64 8, i1 false)
  %dst_reg101 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 1
  %bf.load102 = load i8, i8* %dst_reg101, align 1
  %bf.clear103 = and i8 %bf.load102, 15
  %arrayidx104 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 1
  %dst_reg105 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx104, i32 0, i32 1
  %bf.load106 = load i8, i8* %dst_reg105, align 1
  %bf.value107 = and i8 %bf.clear103, 15
  %bf.clear108 = and i8 %bf.load106, -16
  %bf.set109 = or i8 %bf.clear108, %bf.value107
  store i8 %bf.set109, i8* %dst_reg105, align 1
  %dst_reg110 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %insn, i32 0, i32 1
  %bf.load111 = load i8, i8* %dst_reg110, align 1
  %bf.clear112 = and i8 %bf.load111, 15
  %arrayidx113 = getelementptr [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 1
  %src_reg114 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx113, i32 0, i32 1
  %bf.load115 = load i8, i8* %src_reg114, align 1
  %bf.value116 = and i8 %bf.clear112, 15
  %bf.shl = shl i8 %bf.value116, 4
  %bf.clear117 = and i8 %bf.load115, 15
  %bf.set118 = or i8 %bf.clear117, %bf.shl
  store i8 %bf.set118, i8* %src_reg114, align 1
  %arraydecay119 = getelementptr inbounds [2 x %struct.bpf_insn], [2 x %struct.bpf_insn]* %zext_patch, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay119, %struct.bpf_insn** %patch, align 8
  store i32 2, i32* %patch_len, align 4
  br label %apply_patch_buffer

apply_patch_buffer:                               ; preds = %if.end99, %if.end82
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = load i32, i32* %adj_idx, align 4
  %48 = load %struct.bpf_insn*, %struct.bpf_insn** %patch, align 8
  %49 = load i32, i32* %patch_len, align 4
  %call120 = call %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %46, i32 noundef %47, %struct.bpf_insn* noundef %48, i32 noundef %49) #11
  store %struct.bpf_prog* %call120, %struct.bpf_prog** %new_prog, align 8
  %50 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %tobool121 = icmp ne %struct.bpf_prog* %50, null
  br i1 %tobool121, label %if.end123, label %if.then122

if.then122:                                       ; preds = %apply_patch_buffer
  store i32 -12, i32* %retval, align 4
  br label %return

if.end123:                                        ; preds = %apply_patch_buffer
  %51 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog124 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %52, i32 0, i32 2
  store %struct.bpf_prog* %51, %struct.bpf_prog** %prog124, align 8
  %53 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %insnsi125 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %53, i32 0, i32 11
  %arraydecay126 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi125, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay126, %struct.bpf_insn** %insns, align 8
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data127 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %54, i32 0, i32 20
  %55 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data127, align 8
  store %struct.bpf_insn_aux_data* %55, %struct.bpf_insn_aux_data** %aux, align 8
  %56 = load i32, i32* %patch_len, align 4
  %sub = sub i32 %56, 1
  %57 = load i32, i32* %delta, align 4
  %add128 = add i32 %57, %sub
  store i32 %add128, i32* %delta, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end123, %if.then98, %if.then81, %if.end71, %if.then55, %if.then51
  %58 = load i32, i32* %i, align 4
  %inc129 = add i32 %58, 1
  store i32 %inc129, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then122
  %59 = load i32, i32* %retval, align 4
  ret i32 %59
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_jit_needs_zext() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @fixup_call_args(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %i = alloca i32, align 4
  %depth = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %err, align 4
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 1
  %bf.load = load i16, i16* %jit_requested, align 2
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %conv = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog3, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 7
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %7) #11
  br i1 %call, label %if.end11, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call4 = call i32 @jit_subprogs(%struct.bpf_verifier_env* noundef %8) #11
  store i32 %call4, i32* %err, align 4
  %9 = load i32, i32* %err, align 4
  %cmp = icmp eq i32 %9, 0
  br i1 %cmp, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %10 = load i32, i32* %err, align 4
  %cmp7 = icmp eq i32 %10, -14
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %11 = load i32, i32* %err, align 4
  store i32 %11, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %land.lhs.true, %entry
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 26
  %13 = load i32, i32* %subprog_cnt, align 4
  %cmp12 = icmp ugt i32 %13, 1
  br i1 %cmp12, label %land.lhs.true14, label %if.end20

land.lhs.true14:                                  ; preds = %if.end11
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog15 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 2
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog15, align 8
  %aux16 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %15, i32 0, i32 7
  %16 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux16, align 8
  %tail_call_reachable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %16, i32 0, i32 24
  %17 = load i8, i8* %tail_call_reachable, align 1
  %tobool17 = trunc i8 %17 to i1
  br i1 %tobool17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true14
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([72 x i8], [72 x i8]* @.str.348, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %land.lhs.true14, %if.end11
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end20
  %20 = load i32, i32* %i, align 4
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 4
  %22 = load i32, i32* %len, align 4
  %cmp21 = icmp ult i32 %20, %22
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %23, i32 0, i32 0
  %24 = load i8, i8* %code, align 4
  %conv23 = zext i8 %24 to i32
  %cmp24 = icmp ne i32 %conv23, 133
  br i1 %cmp24, label %if.then31, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %25 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %25, i32 0, i32 1
  %bf.load26 = load i8, i8* %src_reg, align 1
  %bf.lshr27 = lshr i8 %bf.load26, 4
  %conv28 = zext i8 %bf.lshr27 to i32
  %cmp29 = icmp ne i32 %conv28, 1
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end32:                                         ; preds = %lor.lhs.false
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %28 = load i32, i32* %i, align 4
  %call33 = call i32 @get_callee_stack_depth(%struct.bpf_verifier_env* noundef %26, %struct.bpf_insn* noundef %27, i32 noundef %28) #11
  store i32 %call33, i32* %depth, align 4
  %29 = load i32, i32* %depth, align 4
  %cmp34 = icmp slt i32 %29, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end32
  %30 = load i32, i32* %depth, align 4
  store i32 %30, i32* %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end32
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %32 = load i32, i32* %depth, align 4
  call void @bpf_patch_call_args(%struct.bpf_insn* noundef %31, i32 noundef %32) #11
  br label %for.inc

for.inc:                                          ; preds = %if.end37, %if.then31
  %33 = load i32, i32* %i, align 4
  %inc = add i32 %33, 1
  store i32 %inc, i32* %i, align 4
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %34, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %err, align 4
  %35 = load i32, i32* %err, align 4
  store i32 %35, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then36, %if.then19, %if.then9, %if.then6
  %36 = load i32, i32* %retval, align 4
  ret i32 %36
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_verification_stats(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %i = alloca i32, align 4
  %depth = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 22
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %1 = load i32, i32* %level, align 8
  %and = and i32 %1, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %verification_time = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 31
  %5 = load i64, i64* %verification_time, align 8
  %call = call i64 @div_u64(i64 noundef %5, i32 noundef 1000) #11
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.384, i64 0, i64 0), i64 noundef %call) #11
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.385, i64 0, i64 0)) #11
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %8 = load i32, i32* %i, align 4
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 26
  %10 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %8, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 23
  %12 = load i32, i32* %i, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %13 = load i16, i16* %stack_depth, align 8
  %conv = zext i16 %13 to i32
  store i32 %conv, i32* %depth, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load i32, i32* %depth, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.386, i64 0, i64 0), i32 noundef %16) #11
  %17 = load i32, i32* %i, align 4
  %add = add i32 %17, 1
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 26
  %19 = load i32, i32* %subprog_cnt1, align 4
  %cmp2 = icmp ult i32 %add, %19
  br i1 %cmp2, label %if.then4, label %if.end

if.then4:                                         ; preds = %for.body
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.387, i64 0, i64 0)) #11
  br label %if.end

if.end:                                           ; preds = %if.then4, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i32, i32* %i, align 4
  %inc = add i32 %22, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.159, i64 0, i64 0)) #11
  br label %if.end5

if.end5:                                          ; preds = %for.end, %entry
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 28
  %28 = load i32, i32* %insn_processed, align 4
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %max_states_per_insn = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 32
  %30 = load i32, i32* %max_states_per_insn, align 8
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %total_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 33
  %32 = load i32, i32* %total_states, align 4
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %peak_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 34
  %34 = load i32, i32* %peak_states, align 8
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %longest_mark_read_walk = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 35
  %36 = load i32, i32* %longest_mark_read_walk, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([98 x i8], [98 x i8]* @.str.388, i64 0, i64 0), i32 noundef %28, i32 noundef 1000000, i32 noundef %30, i32 noundef %32, i32 noundef %34, i32 noundef %36) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kmalloc_array(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %retval.i20 = alloca i32, align 4
  %flags.addr.i21 = alloca i32, align 4
  %retval.i13 = alloca i32, align 4
  %size.addr.i14 = alloca i64, align 8
  %size.addr.i10 = alloca i64, align 8
  %flags.addr.i11 = alloca i32, align 4
  %order.i = alloca i32, align 4
  %retval.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %index.i = alloca i32, align 4
  %retval = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca i64, align 8
  %__a = alloca i64, align 8
  %__b = alloca i64, align 8
  %__d = alloca i64*, align 8
  %tmp = alloca i8, align 1
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  store i64 %0, i64* %__a, align 8
  %1 = load i64, i64* %size.addr, align 8
  store i64 %1, i64* %__b, align 8
  store i64* %bytes, i64** %__d, align 8
  %cmp = icmp eq i64* %__a, %__b
  %conv = zext i1 %cmp to i32
  %2 = load i64*, i64** %__d, align 8
  %cmp1 = icmp eq i64* %__a, %2
  %conv2 = zext i1 %cmp1 to i32
  %3 = load i64, i64* %__a, align 8
  %4 = load i64, i64* %__b, align 8
  %5 = load i64*, i64** %__d, align 8
  %6 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %3, i64 %4)
  %7 = extractvalue { i64, i1 } %6, 1
  %8 = extractvalue { i64, i1 } %6, 0
  store i64 %8, i64* %5, align 8
  %frombool = zext i1 %7 to i8
  store i8 %frombool, i8* %tmp, align 1
  %9 = load i8, i8* %tmp, align 1
  %tobool = trunc i8 %9 to i1
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %tobool) #11
  %lnot = xor i1 %call, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %n.addr, align 8
  %11 = call i1 @llvm.is.constant.i64(i64 %10)
  br i1 %11, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.end
  %12 = load i64, i64* %size.addr, align 8
  %13 = call i1 @llvm.is.constant.i64(i64 %12)
  br i1 %13, label %if.then6, label %if.end8

if.then6:                                         ; preds = %land.lhs.true
  %14 = load i64, i64* %bytes, align 8
  %15 = load i32, i32* %flags.addr, align 4
  store i64 %14, i64* %size.addr.i, align 8
  store i32 %15, i32* %flags.addr.i, align 4
  %16 = load i64, i64* %size.addr.i, align 8
  %17 = call i1 @llvm.is.constant.i64(i64 %16) #10
  br i1 %17, label %if.then.i, label %if.end9.i

if.then.i:                                        ; preds = %if.then6
  %18 = load i64, i64* %size.addr.i, align 8
  %cmp.i = icmp ugt i64 %18, 8192
  br i1 %cmp.i, label %if.then1.i, label %if.end.i

if.then1.i:                                       ; preds = %if.then.i
  %19 = load i64, i64* %size.addr.i, align 8
  %20 = load i32, i32* %flags.addr.i, align 4
  store i64 %19, i64* %size.addr.i10, align 8
  store i32 %20, i32* %flags.addr.i11, align 4
  %21 = load i64, i64* %size.addr.i10, align 8
  %call.i12 = call i32 @get_order(i64 noundef %21) #14
  store i32 %call.i12, i32* %order.i, align 4
  %22 = load i64, i64* %size.addr.i10, align 8
  %23 = load i32, i32* %flags.addr.i11, align 4
  %24 = load i32, i32* %order.i, align 4
  %call1.i = call noalias align 4096 i8* @kmalloc_order_trace(i64 noundef %22, i32 noundef %23, i32 noundef %24) #13
  store i8* %call1.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end.i:                                         ; preds = %if.then.i
  %25 = load i64, i64* %size.addr.i, align 8
  store i64 %25, i64* %size.addr.i14, align 8
  %26 = load i64, i64* %size.addr.i14, align 8
  %tobool.i15 = icmp ne i64 %26, 0
  br i1 %tobool.i15, label %if.end.i18, label %if.then.i16

if.then.i16:                                      ; preds = %if.end.i
  store i32 0, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end.i18:                                       ; preds = %if.end.i
  %27 = load i64, i64* %size.addr.i14, align 8
  %cmp.i17 = icmp ule i64 %27, 8
  br i1 %cmp.i17, label %if.then1.i19, label %if.end2.i

if.then1.i19:                                     ; preds = %if.end.i18
  store i32 3, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end2.i:                                        ; preds = %if.end.i18
  %28 = load i64, i64* %size.addr.i14, align 8
  %cmp3.i = icmp ugt i64 %28, 64
  br i1 %cmp3.i, label %land.lhs.true.i, label %if.end6.i

land.lhs.true.i:                                  ; preds = %if.end2.i
  %29 = load i64, i64* %size.addr.i14, align 8
  %cmp4.i = icmp ule i64 %29, 96
  br i1 %cmp4.i, label %if.then5.i, label %if.end6.i

if.then5.i:                                       ; preds = %land.lhs.true.i
  store i32 1, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end6.i:                                        ; preds = %land.lhs.true.i, %if.end2.i
  %30 = load i64, i64* %size.addr.i14, align 8
  %cmp7.i = icmp ugt i64 %30, 128
  br i1 %cmp7.i, label %land.lhs.true8.i, label %if.end11.i

land.lhs.true8.i:                                 ; preds = %if.end6.i
  %31 = load i64, i64* %size.addr.i14, align 8
  %cmp9.i = icmp ule i64 %31, 192
  br i1 %cmp9.i, label %if.then10.i, label %if.end11.i

if.then10.i:                                      ; preds = %land.lhs.true8.i
  store i32 2, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end11.i:                                       ; preds = %land.lhs.true8.i, %if.end6.i
  %32 = load i64, i64* %size.addr.i14, align 8
  %cmp12.i = icmp ule i64 %32, 8
  br i1 %cmp12.i, label %if.then13.i, label %if.end14.i

if.then13.i:                                      ; preds = %if.end11.i
  store i32 3, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end14.i:                                       ; preds = %if.end11.i
  %33 = load i64, i64* %size.addr.i14, align 8
  %cmp15.i = icmp ule i64 %33, 16
  br i1 %cmp15.i, label %if.then16.i, label %if.end17.i

if.then16.i:                                      ; preds = %if.end14.i
  store i32 4, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end17.i:                                       ; preds = %if.end14.i
  %34 = load i64, i64* %size.addr.i14, align 8
  %cmp18.i = icmp ule i64 %34, 32
  br i1 %cmp18.i, label %if.then19.i, label %if.end20.i

if.then19.i:                                      ; preds = %if.end17.i
  store i32 5, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end20.i:                                       ; preds = %if.end17.i
  %35 = load i64, i64* %size.addr.i14, align 8
  %cmp21.i = icmp ule i64 %35, 64
  br i1 %cmp21.i, label %if.then22.i, label %if.end23.i

if.then22.i:                                      ; preds = %if.end20.i
  store i32 6, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end23.i:                                       ; preds = %if.end20.i
  %36 = load i64, i64* %size.addr.i14, align 8
  %cmp24.i = icmp ule i64 %36, 128
  br i1 %cmp24.i, label %if.then25.i, label %if.end26.i

if.then25.i:                                      ; preds = %if.end23.i
  store i32 7, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end26.i:                                       ; preds = %if.end23.i
  %37 = load i64, i64* %size.addr.i14, align 8
  %cmp27.i = icmp ule i64 %37, 256
  br i1 %cmp27.i, label %if.then28.i, label %if.end29.i

if.then28.i:                                      ; preds = %if.end26.i
  store i32 8, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end29.i:                                       ; preds = %if.end26.i
  %38 = load i64, i64* %size.addr.i14, align 8
  %cmp30.i = icmp ule i64 %38, 512
  br i1 %cmp30.i, label %if.then31.i, label %if.end32.i

if.then31.i:                                      ; preds = %if.end29.i
  store i32 9, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end32.i:                                       ; preds = %if.end29.i
  %39 = load i64, i64* %size.addr.i14, align 8
  %cmp33.i = icmp ule i64 %39, 1024
  br i1 %cmp33.i, label %if.then34.i, label %if.end35.i

if.then34.i:                                      ; preds = %if.end32.i
  store i32 10, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end35.i:                                       ; preds = %if.end32.i
  %40 = load i64, i64* %size.addr.i14, align 8
  %cmp36.i = icmp ule i64 %40, 2048
  br i1 %cmp36.i, label %if.then37.i, label %if.end38.i

if.then37.i:                                      ; preds = %if.end35.i
  store i32 11, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end38.i:                                       ; preds = %if.end35.i
  %41 = load i64, i64* %size.addr.i14, align 8
  %cmp39.i = icmp ule i64 %41, 4096
  br i1 %cmp39.i, label %if.then40.i, label %if.end41.i

if.then40.i:                                      ; preds = %if.end38.i
  store i32 12, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end41.i:                                       ; preds = %if.end38.i
  %42 = load i64, i64* %size.addr.i14, align 8
  %cmp42.i = icmp ule i64 %42, 8192
  br i1 %cmp42.i, label %if.then43.i, label %if.end44.i

if.then43.i:                                      ; preds = %if.end41.i
  store i32 13, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end44.i:                                       ; preds = %if.end41.i
  %43 = load i64, i64* %size.addr.i14, align 8
  %cmp45.i = icmp ule i64 %43, 16384
  br i1 %cmp45.i, label %if.then46.i, label %if.end47.i

if.then46.i:                                      ; preds = %if.end44.i
  store i32 14, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end47.i:                                       ; preds = %if.end44.i
  %44 = load i64, i64* %size.addr.i14, align 8
  %cmp48.i = icmp ule i64 %44, 32768
  br i1 %cmp48.i, label %if.then49.i, label %if.end50.i

if.then49.i:                                      ; preds = %if.end47.i
  store i32 15, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end50.i:                                       ; preds = %if.end47.i
  %45 = load i64, i64* %size.addr.i14, align 8
  %cmp51.i = icmp ule i64 %45, 65536
  br i1 %cmp51.i, label %if.then52.i, label %if.end53.i

if.then52.i:                                      ; preds = %if.end50.i
  store i32 16, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end53.i:                                       ; preds = %if.end50.i
  %46 = load i64, i64* %size.addr.i14, align 8
  %cmp54.i = icmp ule i64 %46, 131072
  br i1 %cmp54.i, label %if.then55.i, label %if.end56.i

if.then55.i:                                      ; preds = %if.end53.i
  store i32 17, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end56.i:                                       ; preds = %if.end53.i
  %47 = load i64, i64* %size.addr.i14, align 8
  %cmp57.i = icmp ule i64 %47, 262144
  br i1 %cmp57.i, label %if.then58.i, label %if.end59.i

if.then58.i:                                      ; preds = %if.end56.i
  store i32 18, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end59.i:                                       ; preds = %if.end56.i
  %48 = load i64, i64* %size.addr.i14, align 8
  %cmp60.i = icmp ule i64 %48, 524288
  br i1 %cmp60.i, label %if.then61.i, label %if.end62.i

if.then61.i:                                      ; preds = %if.end59.i
  store i32 19, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end62.i:                                       ; preds = %if.end59.i
  %49 = load i64, i64* %size.addr.i14, align 8
  %cmp63.i = icmp ule i64 %49, 1048576
  br i1 %cmp63.i, label %if.then64.i, label %if.end65.i

if.then64.i:                                      ; preds = %if.end62.i
  store i32 20, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end65.i:                                       ; preds = %if.end62.i
  %50 = load i64, i64* %size.addr.i14, align 8
  %cmp66.i = icmp ule i64 %50, 2097152
  br i1 %cmp66.i, label %if.then67.i, label %if.end68.i

if.then67.i:                                      ; preds = %if.end65.i
  store i32 21, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end68.i:                                       ; preds = %if.end65.i
  %51 = load i64, i64* %size.addr.i14, align 8
  %cmp69.i = icmp ule i64 %51, 4194304
  br i1 %cmp69.i, label %if.then70.i, label %if.end71.i

if.then70.i:                                      ; preds = %if.end68.i
  store i32 22, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end71.i:                                       ; preds = %if.end68.i
  %52 = load i64, i64* %size.addr.i14, align 8
  %cmp72.i = icmp ule i64 %52, 8388608
  br i1 %cmp72.i, label %if.then73.i, label %if.end74.i

if.then73.i:                                      ; preds = %if.end71.i
  store i32 23, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end74.i:                                       ; preds = %if.end71.i
  %53 = load i64, i64* %size.addr.i14, align 8
  %cmp75.i = icmp ule i64 %53, 16777216
  br i1 %cmp75.i, label %if.then76.i, label %if.end77.i

if.then76.i:                                      ; preds = %if.end74.i
  store i32 24, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end77.i:                                       ; preds = %if.end74.i
  %54 = load i64, i64* %size.addr.i14, align 8
  %cmp78.i = icmp ule i64 %54, 33554432
  br i1 %cmp78.i, label %if.then79.i, label %if.end80.i

if.then79.i:                                      ; preds = %if.end77.i
  store i32 25, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end80.i:                                       ; preds = %if.end77.i
  %55 = load i64, i64* %size.addr.i14, align 8
  %cmp81.i = icmp ule i64 %55, 67108864
  br i1 %cmp81.i, label %if.then82.i, label %if.end83.i

if.then82.i:                                      ; preds = %if.end80.i
  store i32 26, i32* %retval.i13, align 4
  br label %kmalloc_index.exit

if.end83.i:                                       ; preds = %if.end80.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.30, i64 0, i64 0), i32 382, i32 0, i64 12) #10, !srcloc !12
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.unreachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 81) #10, !srcloc !13
  unreachable

kmalloc_index.exit:                               ; preds = %if.then82.i, %if.then79.i, %if.then76.i, %if.then73.i, %if.then70.i, %if.then67.i, %if.then64.i, %if.then61.i, %if.then58.i, %if.then55.i, %if.then52.i, %if.then49.i, %if.then46.i, %if.then43.i, %if.then40.i, %if.then37.i, %if.then34.i, %if.then31.i, %if.then28.i, %if.then25.i, %if.then22.i, %if.then19.i, %if.then16.i, %if.then13.i, %if.then10.i, %if.then5.i, %if.then1.i19, %if.then.i16
  %56 = load i32, i32* %retval.i13, align 4
  store i32 %56, i32* %index.i, align 4
  %57 = load i32, i32* %index.i, align 4
  %tobool.i = icmp ne i32 %57, 0
  br i1 %tobool.i, label %if.end4.i, label %if.then3.i

if.then3.i:                                       ; preds = %kmalloc_index.exit
  store i8* inttoptr (i64 16 to i8*), i8** %retval.i, align 8
  br label %kmalloc.exit

if.end4.i:                                        ; preds = %kmalloc_index.exit
  %58 = load i32, i32* %flags.addr.i, align 4
  store i32 %58, i32* %flags.addr.i21, align 4
  %59 = load i32, i32* %flags.addr.i21, align 4
  %and.i = and i32 %59, 17
  %cmp.i22 = icmp eq i32 %and.i, 0
  %lnot.i = xor i1 %cmp.i22, true
  %lnot.ext.i = zext i1 %cmp.i22 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %cmp.i22, label %if.then.i23, label %if.end.i24

if.then.i23:                                      ; preds = %if.end4.i
  store i32 0, i32* %retval.i20, align 4
  br label %kmalloc_type.exit

if.end.i24:                                       ; preds = %if.end4.i
  %60 = load i32, i32* %flags.addr.i21, align 4
  %and2.i = and i32 %60, 1
  %tobool3.i = icmp ne i32 %and2.i, 0
  %61 = zext i1 %tobool3.i to i64
  %cond.i = select i1 %tobool3.i, i32 2, i32 1
  store i32 %cond.i, i32* %retval.i20, align 4
  br label %kmalloc_type.exit

kmalloc_type.exit:                                ; preds = %if.end.i24, %if.then.i23
  %62 = load i32, i32* %retval.i20, align 4
  %idxprom.i = zext i32 %62 to i64
  %arrayidx.i = getelementptr [3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 %idxprom.i
  %63 = load i32, i32* %index.i, align 4
  %idxprom6.i = zext i32 %63 to i64
  %arrayidx7.i = getelementptr [14 x %struct.kmem_cache*], [14 x %struct.kmem_cache*]* %arrayidx.i, i64 0, i64 %idxprom6.i
  %64 = load %struct.kmem_cache*, %struct.kmem_cache** %arrayidx7.i, align 8
  %65 = load i32, i32* %flags.addr.i, align 4
  %66 = load i64, i64* %size.addr.i, align 8
  %call8.i = call noalias align 8 i8* @kmem_cache_alloc_trace(%struct.kmem_cache* noundef %64, i32 noundef %65, i64 noundef %66) #13
  store i8* %call8.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end9.i:                                        ; preds = %if.then6
  %67 = load i64, i64* %size.addr.i, align 8
  %68 = load i32, i32* %flags.addr.i, align 4
  %call10.i = call noalias align 8 i8* @__kmalloc(i64 noundef %67, i32 noundef %68) #13
  store i8* %call10.i, i8** %retval.i, align 8
  br label %kmalloc.exit

kmalloc.exit:                                     ; preds = %if.end9.i, %kmalloc_type.exit, %if.then3.i, %if.then1.i
  %69 = load i8*, i8** %retval.i, align 8
  store i8* %69, i8** %retval, align 8
  br label %return

if.end8:                                          ; preds = %land.lhs.true, %if.end
  %70 = load i64, i64* %bytes, align 8
  %71 = load i32, i32* %flags.addr, align 4
  %call9 = call noalias align 8 i8* @__kmalloc(i64 noundef %70, i32 noundef %71) #11
  store i8* %call9, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %kmalloc.exit, %if.then
  %72 = load i8*, i8** %retval, align 8
  ret i8* %72
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @convert_pseudo_ld_imm64(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %insn_cnt = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %insn_cnt, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %i, align 4
  %6 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 0
  %8 = load i8, i8* %code, align 4
  %conv = zext i8 %8 to i32
  %cmp2 = icmp eq i32 %conv, 24
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %bf.set = or i8 %bf.clear, 0
  store i8 %bf.set, i8* %src_reg, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i32, i32* %i, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %i, align 4
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %11, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_btf_func(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %aux = alloca %struct.bpf_prog_aux*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 7
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1, align 8
  store %struct.bpf_prog_aux* %2, %struct.bpf_prog_aux** %aux, align 8
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 45
  %4 = load %struct.util_est*, %struct.util_est** %func_info, align 8
  %tobool = icmp ne %struct.util_est* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, i32* %i, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 26
  %7 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %5, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 23
  %9 = load i32, i32* %i, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %10 = load i32, i32* %start, align 8
  %11 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %11, i32 0, i32 45
  %12 = load %struct.util_est*, %struct.util_est** %func_info2, align 8
  %13 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %13 to i64
  %arrayidx4 = getelementptr %struct.util_est, %struct.util_est* %12, i64 %idxprom3
  %insn_off = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx4, i32 0, i32 0
  store i32 %10, i32* %insn_off, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @release_maps(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 7
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 11
  %arraydecay = getelementptr inbounds [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps, i64 0, i64 0
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_map_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 12
  %5 = load i32, i32* %used_map_cnt, align 8
  call void @__bpf_free_used_maps(%struct.bpf_prog_aux* noundef %2, %struct.bpf_map** noundef %arraydecay, i32 noundef %5) #11
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @vfree(i8* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @kfree(i8* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bpf_free_used_maps(%struct.bpf_prog_aux* noundef, %struct.bpf_map** noundef, i32 noundef) #1

; Function Attrs: nofree nosync nounwind readnone speculatable willreturn
declare { i64, i1 } @llvm.umul.with.overflow.i64(i64, i64) #7

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__must_check_overflow(i1 noundef zeroext %overflow) #0 {
entry:
  %overflow.addr = alloca i8, align 1
  %frombool = zext i1 %overflow to i8
  store i8 %frombool, i8* %overflow.addr, align 1
  %0 = load i8, i8* %overflow.addr, align 1
  %tobool = trunc i8 %0 to i1
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  ret i1 %tobool2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn
define internal i32 @get_order(i64 noundef %size) #6 {
entry:
  %x.addr.i = alloca i64, align 8
  %bitpos.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %size.addr = alloca i64, align 8
  store i64 %size, i64* %size.addr, align 8
  %0 = load i64, i64* %size.addr, align 8
  %1 = call i1 @llvm.is.constant.i64(i64 %0)
  br i1 %1, label %if.then, label %if.end447

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %size.addr, align 8
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.end, label %if.then1

if.then1:                                         ; preds = %if.then
  store i32 52, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %3 = load i64, i64* %size.addr, align 8
  %cmp = icmp ult i64 %3, 4096
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load i64, i64* %size.addr, align 8
  %sub = sub i64 %4, 1
  %5 = call i1 @llvm.is.constant.i64(i64 %sub)
  br i1 %5, label %cond.true, label %cond.false442

cond.true:                                        ; preds = %if.end3
  %6 = load i64, i64* %size.addr, align 8
  %sub4 = sub i64 %6, 1
  %7 = call i1 @llvm.is.constant.i64(i64 %sub4)
  br i1 %7, label %cond.true5, label %cond.false439

cond.true5:                                       ; preds = %cond.true
  %8 = load i64, i64* %size.addr, align 8
  %sub6 = sub i64 %8, 1
  %cmp7 = icmp ult i64 %sub6, 2
  br i1 %cmp7, label %cond.true8, label %cond.false

cond.true8:                                       ; preds = %cond.true5
  br label %cond.end437

cond.false:                                       ; preds = %cond.true5
  %9 = load i64, i64* %size.addr, align 8
  %sub9 = sub i64 %9, 1
  %and = and i64 %sub9, -9223372036854775808
  %tobool10 = icmp ne i64 %and, 0
  br i1 %tobool10, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false
  br label %cond.end435

cond.false12:                                     ; preds = %cond.false
  %10 = load i64, i64* %size.addr, align 8
  %sub13 = sub i64 %10, 1
  %and14 = and i64 %sub13, 4611686018427387904
  %tobool15 = icmp ne i64 %and14, 0
  br i1 %tobool15, label %cond.true16, label %cond.false17

cond.true16:                                      ; preds = %cond.false12
  br label %cond.end433

cond.false17:                                     ; preds = %cond.false12
  %11 = load i64, i64* %size.addr, align 8
  %sub18 = sub i64 %11, 1
  %and19 = and i64 %sub18, 2305843009213693952
  %tobool20 = icmp ne i64 %and19, 0
  br i1 %tobool20, label %cond.true21, label %cond.false22

cond.true21:                                      ; preds = %cond.false17
  br label %cond.end431

cond.false22:                                     ; preds = %cond.false17
  %12 = load i64, i64* %size.addr, align 8
  %sub23 = sub i64 %12, 1
  %and24 = and i64 %sub23, 1152921504606846976
  %tobool25 = icmp ne i64 %and24, 0
  br i1 %tobool25, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %cond.false22
  br label %cond.end429

cond.false27:                                     ; preds = %cond.false22
  %13 = load i64, i64* %size.addr, align 8
  %sub28 = sub i64 %13, 1
  %and29 = and i64 %sub28, 576460752303423488
  %tobool30 = icmp ne i64 %and29, 0
  br i1 %tobool30, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %cond.false27
  br label %cond.end427

cond.false32:                                     ; preds = %cond.false27
  %14 = load i64, i64* %size.addr, align 8
  %sub33 = sub i64 %14, 1
  %and34 = and i64 %sub33, 288230376151711744
  %tobool35 = icmp ne i64 %and34, 0
  br i1 %tobool35, label %cond.true36, label %cond.false37

cond.true36:                                      ; preds = %cond.false32
  br label %cond.end425

cond.false37:                                     ; preds = %cond.false32
  %15 = load i64, i64* %size.addr, align 8
  %sub38 = sub i64 %15, 1
  %and39 = and i64 %sub38, 144115188075855872
  %tobool40 = icmp ne i64 %and39, 0
  br i1 %tobool40, label %cond.true41, label %cond.false42

cond.true41:                                      ; preds = %cond.false37
  br label %cond.end423

cond.false42:                                     ; preds = %cond.false37
  %16 = load i64, i64* %size.addr, align 8
  %sub43 = sub i64 %16, 1
  %and44 = and i64 %sub43, 72057594037927936
  %tobool45 = icmp ne i64 %and44, 0
  br i1 %tobool45, label %cond.true46, label %cond.false47

cond.true46:                                      ; preds = %cond.false42
  br label %cond.end421

cond.false47:                                     ; preds = %cond.false42
  %17 = load i64, i64* %size.addr, align 8
  %sub48 = sub i64 %17, 1
  %and49 = and i64 %sub48, 36028797018963968
  %tobool50 = icmp ne i64 %and49, 0
  br i1 %tobool50, label %cond.true51, label %cond.false52

cond.true51:                                      ; preds = %cond.false47
  br label %cond.end419

cond.false52:                                     ; preds = %cond.false47
  %18 = load i64, i64* %size.addr, align 8
  %sub53 = sub i64 %18, 1
  %and54 = and i64 %sub53, 18014398509481984
  %tobool55 = icmp ne i64 %and54, 0
  br i1 %tobool55, label %cond.true56, label %cond.false57

cond.true56:                                      ; preds = %cond.false52
  br label %cond.end417

cond.false57:                                     ; preds = %cond.false52
  %19 = load i64, i64* %size.addr, align 8
  %sub58 = sub i64 %19, 1
  %and59 = and i64 %sub58, 9007199254740992
  %tobool60 = icmp ne i64 %and59, 0
  br i1 %tobool60, label %cond.true61, label %cond.false62

cond.true61:                                      ; preds = %cond.false57
  br label %cond.end415

cond.false62:                                     ; preds = %cond.false57
  %20 = load i64, i64* %size.addr, align 8
  %sub63 = sub i64 %20, 1
  %and64 = and i64 %sub63, 4503599627370496
  %tobool65 = icmp ne i64 %and64, 0
  br i1 %tobool65, label %cond.true66, label %cond.false67

cond.true66:                                      ; preds = %cond.false62
  br label %cond.end413

cond.false67:                                     ; preds = %cond.false62
  %21 = load i64, i64* %size.addr, align 8
  %sub68 = sub i64 %21, 1
  %and69 = and i64 %sub68, 2251799813685248
  %tobool70 = icmp ne i64 %and69, 0
  br i1 %tobool70, label %cond.true71, label %cond.false72

cond.true71:                                      ; preds = %cond.false67
  br label %cond.end411

cond.false72:                                     ; preds = %cond.false67
  %22 = load i64, i64* %size.addr, align 8
  %sub73 = sub i64 %22, 1
  %and74 = and i64 %sub73, 1125899906842624
  %tobool75 = icmp ne i64 %and74, 0
  br i1 %tobool75, label %cond.true76, label %cond.false77

cond.true76:                                      ; preds = %cond.false72
  br label %cond.end409

cond.false77:                                     ; preds = %cond.false72
  %23 = load i64, i64* %size.addr, align 8
  %sub78 = sub i64 %23, 1
  %and79 = and i64 %sub78, 562949953421312
  %tobool80 = icmp ne i64 %and79, 0
  br i1 %tobool80, label %cond.true81, label %cond.false82

cond.true81:                                      ; preds = %cond.false77
  br label %cond.end407

cond.false82:                                     ; preds = %cond.false77
  %24 = load i64, i64* %size.addr, align 8
  %sub83 = sub i64 %24, 1
  %and84 = and i64 %sub83, 281474976710656
  %tobool85 = icmp ne i64 %and84, 0
  br i1 %tobool85, label %cond.true86, label %cond.false87

cond.true86:                                      ; preds = %cond.false82
  br label %cond.end405

cond.false87:                                     ; preds = %cond.false82
  %25 = load i64, i64* %size.addr, align 8
  %sub88 = sub i64 %25, 1
  %and89 = and i64 %sub88, 140737488355328
  %tobool90 = icmp ne i64 %and89, 0
  br i1 %tobool90, label %cond.true91, label %cond.false92

cond.true91:                                      ; preds = %cond.false87
  br label %cond.end403

cond.false92:                                     ; preds = %cond.false87
  %26 = load i64, i64* %size.addr, align 8
  %sub93 = sub i64 %26, 1
  %and94 = and i64 %sub93, 70368744177664
  %tobool95 = icmp ne i64 %and94, 0
  br i1 %tobool95, label %cond.true96, label %cond.false97

cond.true96:                                      ; preds = %cond.false92
  br label %cond.end401

cond.false97:                                     ; preds = %cond.false92
  %27 = load i64, i64* %size.addr, align 8
  %sub98 = sub i64 %27, 1
  %and99 = and i64 %sub98, 35184372088832
  %tobool100 = icmp ne i64 %and99, 0
  br i1 %tobool100, label %cond.true101, label %cond.false102

cond.true101:                                     ; preds = %cond.false97
  br label %cond.end399

cond.false102:                                    ; preds = %cond.false97
  %28 = load i64, i64* %size.addr, align 8
  %sub103 = sub i64 %28, 1
  %and104 = and i64 %sub103, 17592186044416
  %tobool105 = icmp ne i64 %and104, 0
  br i1 %tobool105, label %cond.true106, label %cond.false107

cond.true106:                                     ; preds = %cond.false102
  br label %cond.end397

cond.false107:                                    ; preds = %cond.false102
  %29 = load i64, i64* %size.addr, align 8
  %sub108 = sub i64 %29, 1
  %and109 = and i64 %sub108, 8796093022208
  %tobool110 = icmp ne i64 %and109, 0
  br i1 %tobool110, label %cond.true111, label %cond.false112

cond.true111:                                     ; preds = %cond.false107
  br label %cond.end395

cond.false112:                                    ; preds = %cond.false107
  %30 = load i64, i64* %size.addr, align 8
  %sub113 = sub i64 %30, 1
  %and114 = and i64 %sub113, 4398046511104
  %tobool115 = icmp ne i64 %and114, 0
  br i1 %tobool115, label %cond.true116, label %cond.false117

cond.true116:                                     ; preds = %cond.false112
  br label %cond.end393

cond.false117:                                    ; preds = %cond.false112
  %31 = load i64, i64* %size.addr, align 8
  %sub118 = sub i64 %31, 1
  %and119 = and i64 %sub118, 2199023255552
  %tobool120 = icmp ne i64 %and119, 0
  br i1 %tobool120, label %cond.true121, label %cond.false122

cond.true121:                                     ; preds = %cond.false117
  br label %cond.end391

cond.false122:                                    ; preds = %cond.false117
  %32 = load i64, i64* %size.addr, align 8
  %sub123 = sub i64 %32, 1
  %and124 = and i64 %sub123, 1099511627776
  %tobool125 = icmp ne i64 %and124, 0
  br i1 %tobool125, label %cond.true126, label %cond.false127

cond.true126:                                     ; preds = %cond.false122
  br label %cond.end389

cond.false127:                                    ; preds = %cond.false122
  %33 = load i64, i64* %size.addr, align 8
  %sub128 = sub i64 %33, 1
  %and129 = and i64 %sub128, 549755813888
  %tobool130 = icmp ne i64 %and129, 0
  br i1 %tobool130, label %cond.true131, label %cond.false132

cond.true131:                                     ; preds = %cond.false127
  br label %cond.end387

cond.false132:                                    ; preds = %cond.false127
  %34 = load i64, i64* %size.addr, align 8
  %sub133 = sub i64 %34, 1
  %and134 = and i64 %sub133, 274877906944
  %tobool135 = icmp ne i64 %and134, 0
  br i1 %tobool135, label %cond.true136, label %cond.false137

cond.true136:                                     ; preds = %cond.false132
  br label %cond.end385

cond.false137:                                    ; preds = %cond.false132
  %35 = load i64, i64* %size.addr, align 8
  %sub138 = sub i64 %35, 1
  %and139 = and i64 %sub138, 137438953472
  %tobool140 = icmp ne i64 %and139, 0
  br i1 %tobool140, label %cond.true141, label %cond.false142

cond.true141:                                     ; preds = %cond.false137
  br label %cond.end383

cond.false142:                                    ; preds = %cond.false137
  %36 = load i64, i64* %size.addr, align 8
  %sub143 = sub i64 %36, 1
  %and144 = and i64 %sub143, 68719476736
  %tobool145 = icmp ne i64 %and144, 0
  br i1 %tobool145, label %cond.true146, label %cond.false147

cond.true146:                                     ; preds = %cond.false142
  br label %cond.end381

cond.false147:                                    ; preds = %cond.false142
  %37 = load i64, i64* %size.addr, align 8
  %sub148 = sub i64 %37, 1
  %and149 = and i64 %sub148, 34359738368
  %tobool150 = icmp ne i64 %and149, 0
  br i1 %tobool150, label %cond.true151, label %cond.false152

cond.true151:                                     ; preds = %cond.false147
  br label %cond.end379

cond.false152:                                    ; preds = %cond.false147
  %38 = load i64, i64* %size.addr, align 8
  %sub153 = sub i64 %38, 1
  %and154 = and i64 %sub153, 17179869184
  %tobool155 = icmp ne i64 %and154, 0
  br i1 %tobool155, label %cond.true156, label %cond.false157

cond.true156:                                     ; preds = %cond.false152
  br label %cond.end377

cond.false157:                                    ; preds = %cond.false152
  %39 = load i64, i64* %size.addr, align 8
  %sub158 = sub i64 %39, 1
  %and159 = and i64 %sub158, 8589934592
  %tobool160 = icmp ne i64 %and159, 0
  br i1 %tobool160, label %cond.true161, label %cond.false162

cond.true161:                                     ; preds = %cond.false157
  br label %cond.end375

cond.false162:                                    ; preds = %cond.false157
  %40 = load i64, i64* %size.addr, align 8
  %sub163 = sub i64 %40, 1
  %and164 = and i64 %sub163, 4294967296
  %tobool165 = icmp ne i64 %and164, 0
  br i1 %tobool165, label %cond.true166, label %cond.false167

cond.true166:                                     ; preds = %cond.false162
  br label %cond.end373

cond.false167:                                    ; preds = %cond.false162
  %41 = load i64, i64* %size.addr, align 8
  %sub168 = sub i64 %41, 1
  %and169 = and i64 %sub168, 2147483648
  %tobool170 = icmp ne i64 %and169, 0
  br i1 %tobool170, label %cond.true171, label %cond.false172

cond.true171:                                     ; preds = %cond.false167
  br label %cond.end371

cond.false172:                                    ; preds = %cond.false167
  %42 = load i64, i64* %size.addr, align 8
  %sub173 = sub i64 %42, 1
  %and174 = and i64 %sub173, 1073741824
  %tobool175 = icmp ne i64 %and174, 0
  br i1 %tobool175, label %cond.true176, label %cond.false177

cond.true176:                                     ; preds = %cond.false172
  br label %cond.end369

cond.false177:                                    ; preds = %cond.false172
  %43 = load i64, i64* %size.addr, align 8
  %sub178 = sub i64 %43, 1
  %and179 = and i64 %sub178, 536870912
  %tobool180 = icmp ne i64 %and179, 0
  br i1 %tobool180, label %cond.true181, label %cond.false182

cond.true181:                                     ; preds = %cond.false177
  br label %cond.end367

cond.false182:                                    ; preds = %cond.false177
  %44 = load i64, i64* %size.addr, align 8
  %sub183 = sub i64 %44, 1
  %and184 = and i64 %sub183, 268435456
  %tobool185 = icmp ne i64 %and184, 0
  br i1 %tobool185, label %cond.true186, label %cond.false187

cond.true186:                                     ; preds = %cond.false182
  br label %cond.end365

cond.false187:                                    ; preds = %cond.false182
  %45 = load i64, i64* %size.addr, align 8
  %sub188 = sub i64 %45, 1
  %and189 = and i64 %sub188, 134217728
  %tobool190 = icmp ne i64 %and189, 0
  br i1 %tobool190, label %cond.true191, label %cond.false192

cond.true191:                                     ; preds = %cond.false187
  br label %cond.end363

cond.false192:                                    ; preds = %cond.false187
  %46 = load i64, i64* %size.addr, align 8
  %sub193 = sub i64 %46, 1
  %and194 = and i64 %sub193, 67108864
  %tobool195 = icmp ne i64 %and194, 0
  br i1 %tobool195, label %cond.true196, label %cond.false197

cond.true196:                                     ; preds = %cond.false192
  br label %cond.end361

cond.false197:                                    ; preds = %cond.false192
  %47 = load i64, i64* %size.addr, align 8
  %sub198 = sub i64 %47, 1
  %and199 = and i64 %sub198, 33554432
  %tobool200 = icmp ne i64 %and199, 0
  br i1 %tobool200, label %cond.true201, label %cond.false202

cond.true201:                                     ; preds = %cond.false197
  br label %cond.end359

cond.false202:                                    ; preds = %cond.false197
  %48 = load i64, i64* %size.addr, align 8
  %sub203 = sub i64 %48, 1
  %and204 = and i64 %sub203, 16777216
  %tobool205 = icmp ne i64 %and204, 0
  br i1 %tobool205, label %cond.true206, label %cond.false207

cond.true206:                                     ; preds = %cond.false202
  br label %cond.end357

cond.false207:                                    ; preds = %cond.false202
  %49 = load i64, i64* %size.addr, align 8
  %sub208 = sub i64 %49, 1
  %and209 = and i64 %sub208, 8388608
  %tobool210 = icmp ne i64 %and209, 0
  br i1 %tobool210, label %cond.true211, label %cond.false212

cond.true211:                                     ; preds = %cond.false207
  br label %cond.end355

cond.false212:                                    ; preds = %cond.false207
  %50 = load i64, i64* %size.addr, align 8
  %sub213 = sub i64 %50, 1
  %and214 = and i64 %sub213, 4194304
  %tobool215 = icmp ne i64 %and214, 0
  br i1 %tobool215, label %cond.true216, label %cond.false217

cond.true216:                                     ; preds = %cond.false212
  br label %cond.end353

cond.false217:                                    ; preds = %cond.false212
  %51 = load i64, i64* %size.addr, align 8
  %sub218 = sub i64 %51, 1
  %and219 = and i64 %sub218, 2097152
  %tobool220 = icmp ne i64 %and219, 0
  br i1 %tobool220, label %cond.true221, label %cond.false222

cond.true221:                                     ; preds = %cond.false217
  br label %cond.end351

cond.false222:                                    ; preds = %cond.false217
  %52 = load i64, i64* %size.addr, align 8
  %sub223 = sub i64 %52, 1
  %and224 = and i64 %sub223, 1048576
  %tobool225 = icmp ne i64 %and224, 0
  br i1 %tobool225, label %cond.true226, label %cond.false227

cond.true226:                                     ; preds = %cond.false222
  br label %cond.end349

cond.false227:                                    ; preds = %cond.false222
  %53 = load i64, i64* %size.addr, align 8
  %sub228 = sub i64 %53, 1
  %and229 = and i64 %sub228, 524288
  %tobool230 = icmp ne i64 %and229, 0
  br i1 %tobool230, label %cond.true231, label %cond.false232

cond.true231:                                     ; preds = %cond.false227
  br label %cond.end347

cond.false232:                                    ; preds = %cond.false227
  %54 = load i64, i64* %size.addr, align 8
  %sub233 = sub i64 %54, 1
  %and234 = and i64 %sub233, 262144
  %tobool235 = icmp ne i64 %and234, 0
  br i1 %tobool235, label %cond.true236, label %cond.false237

cond.true236:                                     ; preds = %cond.false232
  br label %cond.end345

cond.false237:                                    ; preds = %cond.false232
  %55 = load i64, i64* %size.addr, align 8
  %sub238 = sub i64 %55, 1
  %and239 = and i64 %sub238, 131072
  %tobool240 = icmp ne i64 %and239, 0
  br i1 %tobool240, label %cond.true241, label %cond.false242

cond.true241:                                     ; preds = %cond.false237
  br label %cond.end343

cond.false242:                                    ; preds = %cond.false237
  %56 = load i64, i64* %size.addr, align 8
  %sub243 = sub i64 %56, 1
  %and244 = and i64 %sub243, 65536
  %tobool245 = icmp ne i64 %and244, 0
  br i1 %tobool245, label %cond.true246, label %cond.false247

cond.true246:                                     ; preds = %cond.false242
  br label %cond.end341

cond.false247:                                    ; preds = %cond.false242
  %57 = load i64, i64* %size.addr, align 8
  %sub248 = sub i64 %57, 1
  %and249 = and i64 %sub248, 32768
  %tobool250 = icmp ne i64 %and249, 0
  br i1 %tobool250, label %cond.true251, label %cond.false252

cond.true251:                                     ; preds = %cond.false247
  br label %cond.end339

cond.false252:                                    ; preds = %cond.false247
  %58 = load i64, i64* %size.addr, align 8
  %sub253 = sub i64 %58, 1
  %and254 = and i64 %sub253, 16384
  %tobool255 = icmp ne i64 %and254, 0
  br i1 %tobool255, label %cond.true256, label %cond.false257

cond.true256:                                     ; preds = %cond.false252
  br label %cond.end337

cond.false257:                                    ; preds = %cond.false252
  %59 = load i64, i64* %size.addr, align 8
  %sub258 = sub i64 %59, 1
  %and259 = and i64 %sub258, 8192
  %tobool260 = icmp ne i64 %and259, 0
  br i1 %tobool260, label %cond.true261, label %cond.false262

cond.true261:                                     ; preds = %cond.false257
  br label %cond.end335

cond.false262:                                    ; preds = %cond.false257
  %60 = load i64, i64* %size.addr, align 8
  %sub263 = sub i64 %60, 1
  %and264 = and i64 %sub263, 4096
  %tobool265 = icmp ne i64 %and264, 0
  br i1 %tobool265, label %cond.true266, label %cond.false267

cond.true266:                                     ; preds = %cond.false262
  br label %cond.end333

cond.false267:                                    ; preds = %cond.false262
  %61 = load i64, i64* %size.addr, align 8
  %sub268 = sub i64 %61, 1
  %and269 = and i64 %sub268, 2048
  %tobool270 = icmp ne i64 %and269, 0
  br i1 %tobool270, label %cond.true271, label %cond.false272

cond.true271:                                     ; preds = %cond.false267
  br label %cond.end331

cond.false272:                                    ; preds = %cond.false267
  %62 = load i64, i64* %size.addr, align 8
  %sub273 = sub i64 %62, 1
  %and274 = and i64 %sub273, 1024
  %tobool275 = icmp ne i64 %and274, 0
  br i1 %tobool275, label %cond.true276, label %cond.false277

cond.true276:                                     ; preds = %cond.false272
  br label %cond.end329

cond.false277:                                    ; preds = %cond.false272
  %63 = load i64, i64* %size.addr, align 8
  %sub278 = sub i64 %63, 1
  %and279 = and i64 %sub278, 512
  %tobool280 = icmp ne i64 %and279, 0
  br i1 %tobool280, label %cond.true281, label %cond.false282

cond.true281:                                     ; preds = %cond.false277
  br label %cond.end327

cond.false282:                                    ; preds = %cond.false277
  %64 = load i64, i64* %size.addr, align 8
  %sub283 = sub i64 %64, 1
  %and284 = and i64 %sub283, 256
  %tobool285 = icmp ne i64 %and284, 0
  br i1 %tobool285, label %cond.true286, label %cond.false287

cond.true286:                                     ; preds = %cond.false282
  br label %cond.end325

cond.false287:                                    ; preds = %cond.false282
  %65 = load i64, i64* %size.addr, align 8
  %sub288 = sub i64 %65, 1
  %and289 = and i64 %sub288, 128
  %tobool290 = icmp ne i64 %and289, 0
  br i1 %tobool290, label %cond.true291, label %cond.false292

cond.true291:                                     ; preds = %cond.false287
  br label %cond.end323

cond.false292:                                    ; preds = %cond.false287
  %66 = load i64, i64* %size.addr, align 8
  %sub293 = sub i64 %66, 1
  %and294 = and i64 %sub293, 64
  %tobool295 = icmp ne i64 %and294, 0
  br i1 %tobool295, label %cond.true296, label %cond.false297

cond.true296:                                     ; preds = %cond.false292
  br label %cond.end321

cond.false297:                                    ; preds = %cond.false292
  %67 = load i64, i64* %size.addr, align 8
  %sub298 = sub i64 %67, 1
  %and299 = and i64 %sub298, 32
  %tobool300 = icmp ne i64 %and299, 0
  br i1 %tobool300, label %cond.true301, label %cond.false302

cond.true301:                                     ; preds = %cond.false297
  br label %cond.end319

cond.false302:                                    ; preds = %cond.false297
  %68 = load i64, i64* %size.addr, align 8
  %sub303 = sub i64 %68, 1
  %and304 = and i64 %sub303, 16
  %tobool305 = icmp ne i64 %and304, 0
  br i1 %tobool305, label %cond.true306, label %cond.false307

cond.true306:                                     ; preds = %cond.false302
  br label %cond.end317

cond.false307:                                    ; preds = %cond.false302
  %69 = load i64, i64* %size.addr, align 8
  %sub308 = sub i64 %69, 1
  %and309 = and i64 %sub308, 8
  %tobool310 = icmp ne i64 %and309, 0
  br i1 %tobool310, label %cond.true311, label %cond.false312

cond.true311:                                     ; preds = %cond.false307
  br label %cond.end

cond.false312:                                    ; preds = %cond.false307
  %70 = load i64, i64* %size.addr, align 8
  %sub313 = sub i64 %70, 1
  %and314 = and i64 %sub313, 4
  %tobool315 = icmp ne i64 %and314, 0
  %71 = zext i1 %tobool315 to i64
  %cond = select i1 %tobool315, i32 2, i32 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false312, %cond.true311
  %cond316 = phi i32 [ 3, %cond.true311 ], [ %cond, %cond.false312 ]
  br label %cond.end317

cond.end317:                                      ; preds = %cond.end, %cond.true306
  %cond318 = phi i32 [ 4, %cond.true306 ], [ %cond316, %cond.end ]
  br label %cond.end319

cond.end319:                                      ; preds = %cond.end317, %cond.true301
  %cond320 = phi i32 [ 5, %cond.true301 ], [ %cond318, %cond.end317 ]
  br label %cond.end321

cond.end321:                                      ; preds = %cond.end319, %cond.true296
  %cond322 = phi i32 [ 6, %cond.true296 ], [ %cond320, %cond.end319 ]
  br label %cond.end323

cond.end323:                                      ; preds = %cond.end321, %cond.true291
  %cond324 = phi i32 [ 7, %cond.true291 ], [ %cond322, %cond.end321 ]
  br label %cond.end325

cond.end325:                                      ; preds = %cond.end323, %cond.true286
  %cond326 = phi i32 [ 8, %cond.true286 ], [ %cond324, %cond.end323 ]
  br label %cond.end327

cond.end327:                                      ; preds = %cond.end325, %cond.true281
  %cond328 = phi i32 [ 9, %cond.true281 ], [ %cond326, %cond.end325 ]
  br label %cond.end329

cond.end329:                                      ; preds = %cond.end327, %cond.true276
  %cond330 = phi i32 [ 10, %cond.true276 ], [ %cond328, %cond.end327 ]
  br label %cond.end331

cond.end331:                                      ; preds = %cond.end329, %cond.true271
  %cond332 = phi i32 [ 11, %cond.true271 ], [ %cond330, %cond.end329 ]
  br label %cond.end333

cond.end333:                                      ; preds = %cond.end331, %cond.true266
  %cond334 = phi i32 [ 12, %cond.true266 ], [ %cond332, %cond.end331 ]
  br label %cond.end335

cond.end335:                                      ; preds = %cond.end333, %cond.true261
  %cond336 = phi i32 [ 13, %cond.true261 ], [ %cond334, %cond.end333 ]
  br label %cond.end337

cond.end337:                                      ; preds = %cond.end335, %cond.true256
  %cond338 = phi i32 [ 14, %cond.true256 ], [ %cond336, %cond.end335 ]
  br label %cond.end339

cond.end339:                                      ; preds = %cond.end337, %cond.true251
  %cond340 = phi i32 [ 15, %cond.true251 ], [ %cond338, %cond.end337 ]
  br label %cond.end341

cond.end341:                                      ; preds = %cond.end339, %cond.true246
  %cond342 = phi i32 [ 16, %cond.true246 ], [ %cond340, %cond.end339 ]
  br label %cond.end343

cond.end343:                                      ; preds = %cond.end341, %cond.true241
  %cond344 = phi i32 [ 17, %cond.true241 ], [ %cond342, %cond.end341 ]
  br label %cond.end345

cond.end345:                                      ; preds = %cond.end343, %cond.true236
  %cond346 = phi i32 [ 18, %cond.true236 ], [ %cond344, %cond.end343 ]
  br label %cond.end347

cond.end347:                                      ; preds = %cond.end345, %cond.true231
  %cond348 = phi i32 [ 19, %cond.true231 ], [ %cond346, %cond.end345 ]
  br label %cond.end349

cond.end349:                                      ; preds = %cond.end347, %cond.true226
  %cond350 = phi i32 [ 20, %cond.true226 ], [ %cond348, %cond.end347 ]
  br label %cond.end351

cond.end351:                                      ; preds = %cond.end349, %cond.true221
  %cond352 = phi i32 [ 21, %cond.true221 ], [ %cond350, %cond.end349 ]
  br label %cond.end353

cond.end353:                                      ; preds = %cond.end351, %cond.true216
  %cond354 = phi i32 [ 22, %cond.true216 ], [ %cond352, %cond.end351 ]
  br label %cond.end355

cond.end355:                                      ; preds = %cond.end353, %cond.true211
  %cond356 = phi i32 [ 23, %cond.true211 ], [ %cond354, %cond.end353 ]
  br label %cond.end357

cond.end357:                                      ; preds = %cond.end355, %cond.true206
  %cond358 = phi i32 [ 24, %cond.true206 ], [ %cond356, %cond.end355 ]
  br label %cond.end359

cond.end359:                                      ; preds = %cond.end357, %cond.true201
  %cond360 = phi i32 [ 25, %cond.true201 ], [ %cond358, %cond.end357 ]
  br label %cond.end361

cond.end361:                                      ; preds = %cond.end359, %cond.true196
  %cond362 = phi i32 [ 26, %cond.true196 ], [ %cond360, %cond.end359 ]
  br label %cond.end363

cond.end363:                                      ; preds = %cond.end361, %cond.true191
  %cond364 = phi i32 [ 27, %cond.true191 ], [ %cond362, %cond.end361 ]
  br label %cond.end365

cond.end365:                                      ; preds = %cond.end363, %cond.true186
  %cond366 = phi i32 [ 28, %cond.true186 ], [ %cond364, %cond.end363 ]
  br label %cond.end367

cond.end367:                                      ; preds = %cond.end365, %cond.true181
  %cond368 = phi i32 [ 29, %cond.true181 ], [ %cond366, %cond.end365 ]
  br label %cond.end369

cond.end369:                                      ; preds = %cond.end367, %cond.true176
  %cond370 = phi i32 [ 30, %cond.true176 ], [ %cond368, %cond.end367 ]
  br label %cond.end371

cond.end371:                                      ; preds = %cond.end369, %cond.true171
  %cond372 = phi i32 [ 31, %cond.true171 ], [ %cond370, %cond.end369 ]
  br label %cond.end373

cond.end373:                                      ; preds = %cond.end371, %cond.true166
  %cond374 = phi i32 [ 32, %cond.true166 ], [ %cond372, %cond.end371 ]
  br label %cond.end375

cond.end375:                                      ; preds = %cond.end373, %cond.true161
  %cond376 = phi i32 [ 33, %cond.true161 ], [ %cond374, %cond.end373 ]
  br label %cond.end377

cond.end377:                                      ; preds = %cond.end375, %cond.true156
  %cond378 = phi i32 [ 34, %cond.true156 ], [ %cond376, %cond.end375 ]
  br label %cond.end379

cond.end379:                                      ; preds = %cond.end377, %cond.true151
  %cond380 = phi i32 [ 35, %cond.true151 ], [ %cond378, %cond.end377 ]
  br label %cond.end381

cond.end381:                                      ; preds = %cond.end379, %cond.true146
  %cond382 = phi i32 [ 36, %cond.true146 ], [ %cond380, %cond.end379 ]
  br label %cond.end383

cond.end383:                                      ; preds = %cond.end381, %cond.true141
  %cond384 = phi i32 [ 37, %cond.true141 ], [ %cond382, %cond.end381 ]
  br label %cond.end385

cond.end385:                                      ; preds = %cond.end383, %cond.true136
  %cond386 = phi i32 [ 38, %cond.true136 ], [ %cond384, %cond.end383 ]
  br label %cond.end387

cond.end387:                                      ; preds = %cond.end385, %cond.true131
  %cond388 = phi i32 [ 39, %cond.true131 ], [ %cond386, %cond.end385 ]
  br label %cond.end389

cond.end389:                                      ; preds = %cond.end387, %cond.true126
  %cond390 = phi i32 [ 40, %cond.true126 ], [ %cond388, %cond.end387 ]
  br label %cond.end391

cond.end391:                                      ; preds = %cond.end389, %cond.true121
  %cond392 = phi i32 [ 41, %cond.true121 ], [ %cond390, %cond.end389 ]
  br label %cond.end393

cond.end393:                                      ; preds = %cond.end391, %cond.true116
  %cond394 = phi i32 [ 42, %cond.true116 ], [ %cond392, %cond.end391 ]
  br label %cond.end395

cond.end395:                                      ; preds = %cond.end393, %cond.true111
  %cond396 = phi i32 [ 43, %cond.true111 ], [ %cond394, %cond.end393 ]
  br label %cond.end397

cond.end397:                                      ; preds = %cond.end395, %cond.true106
  %cond398 = phi i32 [ 44, %cond.true106 ], [ %cond396, %cond.end395 ]
  br label %cond.end399

cond.end399:                                      ; preds = %cond.end397, %cond.true101
  %cond400 = phi i32 [ 45, %cond.true101 ], [ %cond398, %cond.end397 ]
  br label %cond.end401

cond.end401:                                      ; preds = %cond.end399, %cond.true96
  %cond402 = phi i32 [ 46, %cond.true96 ], [ %cond400, %cond.end399 ]
  br label %cond.end403

cond.end403:                                      ; preds = %cond.end401, %cond.true91
  %cond404 = phi i32 [ 47, %cond.true91 ], [ %cond402, %cond.end401 ]
  br label %cond.end405

cond.end405:                                      ; preds = %cond.end403, %cond.true86
  %cond406 = phi i32 [ 48, %cond.true86 ], [ %cond404, %cond.end403 ]
  br label %cond.end407

cond.end407:                                      ; preds = %cond.end405, %cond.true81
  %cond408 = phi i32 [ 49, %cond.true81 ], [ %cond406, %cond.end405 ]
  br label %cond.end409

cond.end409:                                      ; preds = %cond.end407, %cond.true76
  %cond410 = phi i32 [ 50, %cond.true76 ], [ %cond408, %cond.end407 ]
  br label %cond.end411

cond.end411:                                      ; preds = %cond.end409, %cond.true71
  %cond412 = phi i32 [ 51, %cond.true71 ], [ %cond410, %cond.end409 ]
  br label %cond.end413

cond.end413:                                      ; preds = %cond.end411, %cond.true66
  %cond414 = phi i32 [ 52, %cond.true66 ], [ %cond412, %cond.end411 ]
  br label %cond.end415

cond.end415:                                      ; preds = %cond.end413, %cond.true61
  %cond416 = phi i32 [ 53, %cond.true61 ], [ %cond414, %cond.end413 ]
  br label %cond.end417

cond.end417:                                      ; preds = %cond.end415, %cond.true56
  %cond418 = phi i32 [ 54, %cond.true56 ], [ %cond416, %cond.end415 ]
  br label %cond.end419

cond.end419:                                      ; preds = %cond.end417, %cond.true51
  %cond420 = phi i32 [ 55, %cond.true51 ], [ %cond418, %cond.end417 ]
  br label %cond.end421

cond.end421:                                      ; preds = %cond.end419, %cond.true46
  %cond422 = phi i32 [ 56, %cond.true46 ], [ %cond420, %cond.end419 ]
  br label %cond.end423

cond.end423:                                      ; preds = %cond.end421, %cond.true41
  %cond424 = phi i32 [ 57, %cond.true41 ], [ %cond422, %cond.end421 ]
  br label %cond.end425

cond.end425:                                      ; preds = %cond.end423, %cond.true36
  %cond426 = phi i32 [ 58, %cond.true36 ], [ %cond424, %cond.end423 ]
  br label %cond.end427

cond.end427:                                      ; preds = %cond.end425, %cond.true31
  %cond428 = phi i32 [ 59, %cond.true31 ], [ %cond426, %cond.end425 ]
  br label %cond.end429

cond.end429:                                      ; preds = %cond.end427, %cond.true26
  %cond430 = phi i32 [ 60, %cond.true26 ], [ %cond428, %cond.end427 ]
  br label %cond.end431

cond.end431:                                      ; preds = %cond.end429, %cond.true21
  %cond432 = phi i32 [ 61, %cond.true21 ], [ %cond430, %cond.end429 ]
  br label %cond.end433

cond.end433:                                      ; preds = %cond.end431, %cond.true16
  %cond434 = phi i32 [ 62, %cond.true16 ], [ %cond432, %cond.end431 ]
  br label %cond.end435

cond.end435:                                      ; preds = %cond.end433, %cond.true11
  %cond436 = phi i32 [ 63, %cond.true11 ], [ %cond434, %cond.end433 ]
  br label %cond.end437

cond.end437:                                      ; preds = %cond.end435, %cond.true8
  %cond438 = phi i32 [ 0, %cond.true8 ], [ %cond436, %cond.end435 ]
  br label %cond.end440

cond.false439:                                    ; preds = %cond.true
  br label %cond.end440

cond.end440:                                      ; preds = %cond.false439, %cond.end437
  %cond441 = phi i32 [ %cond438, %cond.end437 ], [ -1, %cond.false439 ]
  br label %cond.end444

cond.false442:                                    ; preds = %if.end3
  %72 = load i64, i64* %size.addr, align 8
  %sub443 = sub i64 %72, 1
  %call = call i32 @__ilog2_u64(i64 noundef %sub443) #14
  br label %cond.end444

cond.end444:                                      ; preds = %cond.false442, %cond.end440
  %cond445 = phi i32 [ %cond441, %cond.end440 ], [ %call, %cond.false442 ]
  %sub446 = sub i32 %cond445, 12
  %add = add i32 %sub446, 1
  store i32 %add, i32* %retval, align 4
  br label %return

if.end447:                                        ; preds = %entry
  %73 = load i64, i64* %size.addr, align 8
  %dec = add i64 %73, -1
  store i64 %dec, i64* %size.addr, align 8
  %74 = load i64, i64* %size.addr, align 8
  %shr = lshr i64 %74, 12
  store i64 %shr, i64* %size.addr, align 8
  %75 = load i64, i64* %size.addr, align 8
  store i64 %75, i64* %x.addr.i, align 8
  store i32 -1, i32* %bitpos.i, align 4
  %76 = load i32, i32* %bitpos.i, align 4
  %77 = load i64, i64* %x.addr.i, align 8
  %78 = call i32 asm "bsrq $1,${0:q}", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i64 %77, i32 %76) #9, !srcloc !20
  store i32 %78, i32* %bitpos.i, align 4
  %79 = load i32, i32* %bitpos.i, align 4
  %add.i = add i32 %79, 1
  store i32 %add.i, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end447, %cond.end444, %if.then2, %if.then1
  %80 = load i32, i32* %retval, align 4
  ret i32 %80
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local noalias i8* @kmalloc_order_trace(i64 noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local noalias i8* @kmem_cache_alloc_trace(%struct.kmem_cache* noundef, i32 noundef, i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local noalias i8* @__kmalloc(i64 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn
define internal i32 @__ilog2_u64(i64 noundef %n) #6 {
entry:
  %x.addr.i = alloca i64, align 8
  %bitpos.i = alloca i32, align 4
  %n.addr = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load i64, i64* %n.addr, align 8
  store i64 %0, i64* %x.addr.i, align 8
  store i32 -1, i32* %bitpos.i, align 4
  %1 = load i32, i32* %bitpos.i, align 4
  %2 = load i64, i64* %x.addr.i, align 8
  %3 = call i32 asm "bsrq $1,${0:q}", "=r,rm,0,~{dirflag},~{fpsr},~{flags}"(i64 %2, i32 %1) #9, !srcloc !20
  store i32 %3, i32* %bitpos.i, align 4
  %4 = load i32, i32* %bitpos.i, align 4
  %add.i = add i32 %4, 1
  %sub = sub i32 %add.i, 1
  ret i32 %sub
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @div_u64(i64 noundef %dividend, i32 noundef %divisor) #0 {
entry:
  %dividend.addr = alloca i64, align 8
  %divisor.addr = alloca i32, align 4
  %remainder = alloca i32, align 4
  store i64 %dividend, i64* %dividend.addr, align 8
  store i32 %divisor, i32* %divisor.addr, align 4
  %0 = load i64, i64* %dividend.addr, align 8
  %1 = load i32, i32* %divisor.addr, align 4
  %call = call i64 @div_u64_rem(i64 noundef %0, i32 noundef %1, i32* noundef %remainder) #11
  ret i64 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @div_u64_rem(i64 noundef %dividend, i32 noundef %divisor, i32* noundef %remainder) #0 {
entry:
  %dividend.addr = alloca i64, align 8
  %divisor.addr = alloca i32, align 4
  %remainder.addr = alloca i32*, align 8
  store i64 %dividend, i64* %dividend.addr, align 8
  store i32 %divisor, i32* %divisor.addr, align 4
  store i32* %remainder, i32** %remainder.addr, align 8
  %0 = load i64, i64* %dividend.addr, align 8
  %1 = load i32, i32* %divisor.addr, align 4
  %conv = zext i32 %1 to i64
  %rem = urem i64 %0, %conv
  %conv1 = trunc i64 %rem to i32
  %2 = load i32*, i32** %remainder.addr, align 8
  store i32 %conv1, i32* %2, align 4
  %3 = load i64, i64* %dividend.addr, align 8
  %4 = load i32, i32* %divisor.addr, align 4
  %conv2 = zext i32 %4 to i64
  %div = udiv i64 %3, %conv2
  ret i64 %div
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @jit_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %func = alloca %struct.bpf_prog**, align 8
  %tmp = alloca %struct.bpf_prog*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %subprog_start = alloca i32, align 4
  %subprog_end = alloca i32, align 4
  %len = alloca i32, align 4
  %subprog = alloca i32, align 4
  %map_ptr = alloca %struct.bpf_map*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %old_bpf_func = alloca i8*, align 8
  %err = alloca i32, align 4
  %num_exentries = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp45 = alloca i64, align 8
  %tmp53 = alloca i64, align 8
  %insn_idx = alloca i32, align 4
  %ret = alloca i32, align 4
  %tmp268 = alloca i32, align 4
  %tmp363 = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  store i32 0, i32* %subprog_end, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 26
  %3 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ule i32 %3, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, i32* %i, align 4
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len2 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 4
  %7 = load i32, i32* %len2, align 4
  %cmp3 = icmp ult i32 %5, %7
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 0
  %9 = load i8, i8* %code, align 4
  %conv = zext i8 %9 to i32
  %cmp4 = icmp ne i32 %conv, 133
  br i1 %cmp4, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %10, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv6 = zext i8 %bf.lshr to i32
  %cmp7 = icmp ne i32 %conv6, 1
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end10:                                         ; preds = %lor.lhs.false
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 3
  %14 = load i32, i32* %imm, align 4
  %add = add i32 %12, %14
  %add11 = add i32 %add, 1
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %11, i32 noundef %add11) #11
  store i32 %call, i32* %subprog, align 4
  %15 = load i32, i32* %subprog, align 4
  %cmp12 = icmp slt i32 %15, 0
  br i1 %cmp12, label %if.then14, label %if.end60

if.then14:                                        ; preds = %if.end10
  store i32 1, i32* %__ret_warn_once, align 4
  %16 = load i32, i32* %__ret_warn_once, align 4
  %tobool = icmp ne i32 %16, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then14
  %17 = load i8, i8* @jit_subprogs.__warned, align 1
  %tobool15 = trunc i8 %17 to i1
  %lnot = xor i1 %tobool15, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then14
  %18 = phi i1 [ false, %if.then14 ], [ %lnot, %land.rhs ]
  %lnot16 = xor i1 %18, true
  %lnot17 = xor i1 %lnot16, true
  %lnot.ext = zext i1 %lnot17 to i32
  %conv18 = sext i32 %lnot.ext to i64
  %tobool19 = icmp ne i64 %conv18, 0
  br i1 %tobool19, label %if.then20, label %if.end52

if.then20:                                        ; preds = %land.end
  store i8 1, i8* @jit_subprogs.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %19 = load i32, i32* %__ret_warn_on, align 4
  %tobool21 = icmp ne i32 %19, 0
  %lnot22 = xor i1 %tobool21, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  %conv26 = sext i32 %lnot.ext25 to i64
  %tobool27 = icmp ne i64 %conv26, 0
  br i1 %tobool27, label %if.then28, label %if.end44

if.then28:                                        ; preds = %if.then20
  br label %do.body

do.body:                                          ; preds = %if.then28
  br label %do.body29

do.body29:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body29
  %20 = load i32, i32* %i, align 4
  %21 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm30 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %21, i32 0, i32 3
  %22 = load i32, i32* %imm30, align 4
  %add31 = add i32 %20, %22
  %add32 = add i32 %add31, 1
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.283, i64 0, i64 0), i32 noundef %add32) #11
  br label %do.body33

do.body33:                                        ; preds = %do.end
  br label %do.body34

do.body34:                                        ; preds = %do.body33
  br label %do.end35

do.end35:                                         ; preds = %do.body34
  br label %do.body36

do.body36:                                        ; preds = %do.end35
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 12537, i32 2313, i64 12) #10, !srcloc !21
  br label %do.end37

do.end37:                                         ; preds = %do.body36
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 497) #10, !srcloc !22
  br label %do.body38

do.body38:                                        ; preds = %do.end37
  br label %do.end39

do.end39:                                         ; preds = %do.body38
  br label %do.end40

do.end40:                                         ; preds = %do.end39
  br label %do.body41

do.body41:                                        ; preds = %do.end40
  br label %do.end42

do.end42:                                         ; preds = %do.body41
  br label %do.end43

do.end43:                                         ; preds = %do.end42
  br label %if.end44

if.end44:                                         ; preds = %do.end43, %if.then20
  %23 = load i32, i32* %__ret_warn_on, align 4
  %tobool46 = icmp ne i32 %23, 0
  %lnot47 = xor i1 %tobool46, true
  %lnot49 = xor i1 %lnot47, true
  %lnot.ext50 = zext i1 %lnot49 to i32
  %conv51 = sext i32 %lnot.ext50 to i64
  store i64 %conv51, i64* %tmp45, align 8
  %24 = load i64, i64* %tmp45, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.end44, %land.end
  %25 = load i32, i32* %__ret_warn_once, align 4
  %tobool54 = icmp ne i32 %25, 0
  %lnot55 = xor i1 %tobool54, true
  %lnot57 = xor i1 %lnot55, true
  %lnot.ext58 = zext i1 %lnot57 to i32
  %conv59 = sext i32 %lnot.ext58 to i64
  store i64 %conv59, i64* %tmp53, align 8
  %26 = load i64, i64* %tmp53, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end60:                                         ; preds = %if.end10
  %27 = load i32, i32* %subprog, align 4
  %conv61 = trunc i32 %27 to i16
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %28, i32 0, i32 2
  store i16 %conv61, i16* %off, align 2
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm62 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 3
  %30 = load i32, i32* %imm62, align 4
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 20
  %32 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %33 = load i32, i32* %i, align 4
  %idxprom = sext i32 %33 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %32, i64 %idxprom
  %34 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 0
  %call_imm = bitcast %struct.atomic64_t* %34 to i32*
  store i32 %30, i32* %call_imm, align 8
  %35 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm63 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %35, i32 0, i32 3
  store i32 1, i32* %imm63, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end60, %if.then9
  %36 = load i32, i32* %i, align 4
  %inc = add i32 %36, 1
  store i32 %inc, i32* %i, align 4
  %37 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %37, i32 1
  store %struct.bpf_insn* %incdec.ptr, %struct.bpf_insn** %insn, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %38 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call64 = call i32 @bpf_prog_alloc_jited_linfo(%struct.bpf_prog* noundef %38) #11
  store i32 %call64, i32* %err, align 4
  %39 = load i32, i32* %err, align 4
  %tobool65 = icmp ne i32 %39, 0
  br i1 %tobool65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %for.end
  br label %out_undo_insn

if.end67:                                         ; preds = %for.end
  store i32 -12, i32* %err, align 4
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt68 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %40, i32 0, i32 26
  %41 = load i32, i32* %subprog_cnt68, align 4
  %conv69 = zext i32 %41 to i64
  %call70 = call i8* @kcalloc(i64 noundef %conv69, i64 noundef 8, i32 noundef 3264) #11
  %42 = bitcast i8* %call70 to %struct.bpf_prog**
  store %struct.bpf_prog** %42, %struct.bpf_prog*** %func, align 8
  %43 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %tobool71 = icmp ne %struct.bpf_prog** %43, null
  br i1 %tobool71, label %if.end73, label %if.then72

if.then72:                                        ; preds = %if.end67
  br label %out_undo_insn

if.end73:                                         ; preds = %if.end67
  store i32 0, i32* %i, align 4
  br label %for.cond74

for.cond74:                                       ; preds = %for.inc270, %if.end73
  %44 = load i32, i32* %i, align 4
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt75 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %45, i32 0, i32 26
  %46 = load i32, i32* %subprog_cnt75, align 4
  %cmp76 = icmp ult i32 %44, %46
  br i1 %cmp76, label %for.body78, label %for.end272

for.body78:                                       ; preds = %for.cond74
  %47 = load i32, i32* %subprog_end, align 4
  store i32 %47, i32* %subprog_start, align 4
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %48, i32 0, i32 23
  %49 = load i32, i32* %i, align 4
  %add79 = add i32 %49, 1
  %idxprom80 = sext i32 %add79 to i64
  %arrayidx81 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom80
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx81, i32 0, i32 0
  %50 = load i32, i32* %start, align 8
  store i32 %50, i32* %subprog_end, align 4
  %51 = load i32, i32* %subprog_end, align 4
  %52 = load i32, i32* %subprog_start, align 4
  %sub = sub i32 %51, %52
  store i32 %sub, i32* %len, align 4
  %53 = load i32, i32* %len, align 4
  %call82 = call i32 @bpf_prog_size(i32 noundef %53) #11
  %call83 = call %struct.bpf_prog* @bpf_prog_alloc_no_stats(i32 noundef %call82, i32 noundef 1051840) #11
  %54 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %55 = load i32, i32* %i, align 4
  %idxprom84 = sext i32 %55 to i64
  %arrayidx85 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %54, i64 %idxprom84
  store %struct.bpf_prog* %call83, %struct.bpf_prog** %arrayidx85, align 8
  %56 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %57 = load i32, i32* %i, align 4
  %idxprom86 = sext i32 %57 to i64
  %arrayidx87 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %56, i64 %idxprom86
  %58 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx87, align 8
  %tobool88 = icmp ne %struct.bpf_prog* %58, null
  br i1 %tobool88, label %if.end90, label %if.then89

if.then89:                                        ; preds = %for.body78
  br label %out_free

if.end90:                                         ; preds = %for.body78
  %59 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %60 = load i32, i32* %i, align 4
  %idxprom91 = sext i32 %60 to i64
  %arrayidx92 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %59, i64 %idxprom91
  %61 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx92, align 8
  %insnsi93 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %61, i32 0, i32 11
  %arraydecay94 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi93, i64 0, i64 0
  %62 = bitcast %struct.bpf_insn* %arraydecay94 to i8*
  %63 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi95 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %63, i32 0, i32 11
  %64 = load i32, i32* %subprog_start, align 4
  %idxprom96 = sext i32 %64 to i64
  %arrayidx97 = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi95, i64 0, i64 %idxprom96
  %65 = bitcast %struct.bpf_insn* %arrayidx97 to i8*
  %66 = load i32, i32* %len, align 4
  %conv98 = sext i32 %66 to i64
  %mul = mul i64 %conv98, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %62, i8* align 8 %65, i64 %mul, i1 false)
  %67 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %67, i32 0, i32 2
  %68 = load i32, i32* %type, align 4
  %69 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %70 = load i32, i32* %i, align 4
  %idxprom99 = sext i32 %70 to i64
  %arrayidx100 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %69, i64 %idxprom99
  %71 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx100, align 8
  %type101 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %71, i32 0, i32 2
  store i32 %68, i32* %type101, align 4
  %72 = load i32, i32* %len, align 4
  %73 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %74 = load i32, i32* %i, align 4
  %idxprom102 = sext i32 %74 to i64
  %arrayidx103 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %73, i64 %idxprom102
  %75 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx103, align 8
  %len104 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %75, i32 0, i32 4
  store i32 %72, i32* %len104, align 4
  %76 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %77 = load i32, i32* %i, align 4
  %idxprom105 = sext i32 %77 to i64
  %arrayidx106 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %76, i64 %idxprom105
  %78 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx106, align 8
  %call107 = call i32 @bpf_prog_calc_tag(%struct.bpf_prog* noundef %78) #11
  %tobool108 = icmp ne i32 %call107, 0
  br i1 %tobool108, label %if.then109, label %if.end110

if.then109:                                       ; preds = %if.end90
  br label %out_free

if.end110:                                        ; preds = %if.end90
  %79 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %80 = load i32, i32* %i, align 4
  %idxprom111 = sext i32 %80 to i64
  %arrayidx112 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %79, i64 %idxprom111
  %81 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx112, align 8
  %is_func = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %81, i32 0, i32 1
  %bf.load113 = load i16, i16* %is_func, align 2
  %bf.clear = and i16 %bf.load113, -65
  %bf.set = or i16 %bf.clear, 64
  store i16 %bf.set, i16* %is_func, align 2
  %82 = load i32, i32* %i, align 4
  %83 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %84 = load i32, i32* %i, align 4
  %idxprom114 = sext i32 %84 to i64
  %arrayidx115 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %83, i64 %idxprom114
  %85 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx115, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %85, i32 0, i32 7
  %86 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_idx = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %86, i32 0, i32 8
  store i32 %82, i32* %func_idx, align 4
  %87 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux116 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %87, i32 0, i32 7
  %88 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux116, align 8
  %btf = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %88, i32 0, i32 44
  %89 = load %struct.btf*, %struct.btf** %btf, align 8
  %90 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %91 = load i32, i32* %i, align 4
  %idxprom117 = sext i32 %91 to i64
  %arrayidx118 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %90, i64 %idxprom117
  %92 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx118, align 8
  %aux119 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %92, i32 0, i32 7
  %93 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux119, align 8
  %btf120 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %93, i32 0, i32 44
  store %struct.btf* %89, %struct.btf** %btf120, align 8
  %94 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux121 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %94, i32 0, i32 7
  %95 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux121, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %95, i32 0, i32 45
  %96 = load %struct.util_est*, %struct.util_est** %func_info, align 8
  %97 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %98 = load i32, i32* %i, align 4
  %idxprom122 = sext i32 %98 to i64
  %arrayidx123 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %97, i64 %idxprom122
  %99 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx123, align 8
  %aux124 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %99, i32 0, i32 7
  %100 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux124, align 8
  %func_info125 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %100, i32 0, i32 45
  store %struct.util_est* %96, %struct.util_est** %func_info125, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond126

for.cond126:                                      ; preds = %for.inc174, %if.end110
  %101 = load i32, i32* %j, align 4
  %102 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux127 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %102, i32 0, i32 7
  %103 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux127, align 8
  %size_poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %103, i32 0, i32 32
  %104 = load i32, i32* %size_poke_tab, align 8
  %cmp128 = icmp ult i32 %101, %104
  br i1 %cmp128, label %for.body130, label %for.end176

for.body130:                                      ; preds = %for.cond126
  %105 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux131 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %105, i32 0, i32 7
  %106 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux131, align 8
  %poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %106, i32 0, i32 31
  %107 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab, align 8
  %108 = load i32, i32* %j, align 4
  %idxprom132 = sext i32 %108 to i64
  %arrayidx133 = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %107, i64 %idxprom132
  %insn_idx134 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %arrayidx133, i32 0, i32 7
  %109 = load i32, i32* %insn_idx134, align 4
  store i32 %109, i32* %insn_idx, align 4
  %110 = load i32, i32* %insn_idx, align 4
  %111 = load i32, i32* %subprog_start, align 4
  %cmp135 = icmp uge i32 %110, %111
  br i1 %cmp135, label %land.lhs.true, label %if.then139

land.lhs.true:                                    ; preds = %for.body130
  %112 = load i32, i32* %insn_idx, align 4
  %113 = load i32, i32* %subprog_end, align 4
  %cmp137 = icmp ule i32 %112, %113
  br i1 %cmp137, label %if.end140, label %if.then139

if.then139:                                       ; preds = %land.lhs.true, %for.body130
  br label %for.inc174

if.end140:                                        ; preds = %land.lhs.true
  %114 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %115 = load i32, i32* %i, align 4
  %idxprom141 = sext i32 %115 to i64
  %arrayidx142 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %114, i64 %idxprom141
  %116 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx142, align 8
  %117 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux143 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %117, i32 0, i32 7
  %118 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux143, align 8
  %poke_tab144 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %118, i32 0, i32 31
  %119 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab144, align 8
  %120 = load i32, i32* %j, align 4
  %idxprom145 = sext i32 %120 to i64
  %arrayidx146 = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %119, i64 %idxprom145
  %call147 = call i32 @bpf_jit_add_poke_descriptor(%struct.bpf_prog* noundef %116, %struct.bpf_jit_poke_descriptor* noundef %arrayidx146) #11
  store i32 %call147, i32* %ret, align 4
  %121 = load i32, i32* %ret, align 4
  %cmp148 = icmp slt i32 %121, 0
  br i1 %cmp148, label %if.then150, label %if.end151

if.then150:                                       ; preds = %if.end140
  %122 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %123 = bitcast %struct.bpf_verifier_env* %122 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %123, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.380, i64 0, i64 0)) #11
  br label %out_free

if.end151:                                        ; preds = %if.end140
  %124 = load i32, i32* %ret, align 4
  %add152 = add i32 %124, 1
  %125 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %126 = load i32, i32* %i, align 4
  %idxprom153 = sext i32 %126 to i64
  %arrayidx154 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %125, i64 %idxprom153
  %127 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx154, align 8
  %insnsi155 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %127, i32 0, i32 11
  %128 = load i32, i32* %insn_idx, align 4
  %129 = load i32, i32* %subprog_start, align 4
  %sub156 = sub i32 %128, %129
  %idxprom157 = zext i32 %sub156 to i64
  %arrayidx158 = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi155, i64 0, i64 %idxprom157
  %imm159 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx158, i32 0, i32 3
  store i32 %add152, i32* %imm159, align 4
  %130 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %131 = load i32, i32* %i, align 4
  %idxprom160 = sext i32 %131 to i64
  %arrayidx161 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %130, i64 %idxprom160
  %132 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx161, align 8
  %aux162 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %132, i32 0, i32 7
  %133 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux162, align 8
  %poke_tab163 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %133, i32 0, i32 31
  %134 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab163, align 8
  %135 = load i32, i32* %ret, align 4
  %idxprom164 = sext i32 %135 to i64
  %arrayidx165 = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %134, i64 %idxprom164
  %136 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %arrayidx165, i32 0, i32 3
  %tail_call = bitcast %union.anon.4* %136 to %struct.anon.5*
  %map = getelementptr inbounds %struct.anon.5, %struct.anon.5* %tail_call, i32 0, i32 0
  %137 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  store %struct.bpf_map* %137, %struct.bpf_map** %map_ptr, align 8
  %138 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %138, i32 0, i32 0
  %139 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_poke_track = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %139, i32 0, i32 23
  %140 = load i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)*, i32 (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_track, align 8
  %141 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %142 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %143 = load i32, i32* %i, align 4
  %idxprom166 = sext i32 %143 to i64
  %arrayidx167 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %142, i64 %idxprom166
  %144 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx167, align 8
  %aux168 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %144, i32 0, i32 7
  %145 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux168, align 8
  %call169 = call i32 %140(%struct.bpf_map* noundef %141, %struct.bpf_prog_aux* noundef %145) #11
  store i32 %call169, i32* %ret, align 4
  %146 = load i32, i32* %ret, align 4
  %cmp170 = icmp slt i32 %146, 0
  br i1 %cmp170, label %if.then172, label %if.end173

if.then172:                                       ; preds = %if.end151
  %147 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %148 = bitcast %struct.bpf_verifier_env* %147 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %148, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.382, i64 0, i64 0)) #11
  br label %out_free

if.end173:                                        ; preds = %if.end151
  br label %for.inc174

for.inc174:                                       ; preds = %if.end173, %if.then139
  %149 = load i32, i32* %j, align 4
  %inc175 = add i32 %149, 1
  store i32 %inc175, i32* %j, align 4
  br label %for.cond126

for.end176:                                       ; preds = %for.cond126
  %150 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %151 = load i32, i32* %i, align 4
  %idxprom177 = sext i32 %151 to i64
  %arrayidx178 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %150, i64 %idxprom177
  %152 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx178, align 8
  %aux179 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %152, i32 0, i32 7
  %153 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux179, align 8
  %name = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %153, i32 0, i32 41
  %arrayidx180 = getelementptr [16 x i8], [16 x i8]* %name, i64 0, i64 0
  store i8 70, i8* %arrayidx180, align 8
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info181 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %154, i32 0, i32 23
  %155 = load i32, i32* %i, align 4
  %idxprom182 = sext i32 %155 to i64
  %arrayidx183 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info181, i64 0, i64 %idxprom182
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx183, i32 0, i32 2
  %156 = load i16, i16* %stack_depth, align 8
  %conv184 = zext i16 %156 to i32
  %157 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %158 = load i32, i32* %i, align 4
  %idxprom185 = sext i32 %158 to i64
  %arrayidx186 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %157, i64 %idxprom185
  %159 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx186, align 8
  %aux187 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %159, i32 0, i32 7
  %160 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux187, align 8
  %stack_depth188 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %160, i32 0, i32 5
  store i32 %conv184, i32* %stack_depth188, align 8
  %161 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %162 = load i32, i32* %i, align 4
  %idxprom189 = sext i32 %162 to i64
  %arrayidx190 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %161, i64 %idxprom189
  %163 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx190, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %163, i32 0, i32 1
  %bf.load191 = load i16, i16* %jit_requested, align 2
  %bf.clear192 = and i16 %bf.load191, -3
  %bf.set193 = or i16 %bf.clear192, 2
  store i16 %bf.set193, i16* %jit_requested, align 2
  %164 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux194 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %164, i32 0, i32 7
  %165 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux194, align 8
  %linfo = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %165, i32 0, i32 47
  %166 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %167 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %168 = load i32, i32* %i, align 4
  %idxprom195 = sext i32 %168 to i64
  %arrayidx196 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %167, i64 %idxprom195
  %169 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx196, align 8
  %aux197 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %169, i32 0, i32 7
  %170 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux197, align 8
  %linfo198 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %170, i32 0, i32 47
  store %struct.ethtool_pauseparam* %166, %struct.ethtool_pauseparam** %linfo198, align 8
  %171 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux199 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %171, i32 0, i32 7
  %172 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux199, align 8
  %nr_linfo = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %172, i32 0, i32 50
  %173 = load i32, i32* %nr_linfo, align 4
  %174 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %175 = load i32, i32* %i, align 4
  %idxprom200 = sext i32 %175 to i64
  %arrayidx201 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %174, i64 %idxprom200
  %176 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx201, align 8
  %aux202 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %176, i32 0, i32 7
  %177 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux202, align 8
  %nr_linfo203 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %177, i32 0, i32 50
  store i32 %173, i32* %nr_linfo203, align 4
  %178 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux204 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %178, i32 0, i32 7
  %179 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux204, align 8
  %jited_linfo = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %179, i32 0, i32 48
  %180 = load i8**, i8*** %jited_linfo, align 8
  %181 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %182 = load i32, i32* %i, align 4
  %idxprom205 = sext i32 %182 to i64
  %arrayidx206 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %181, i64 %idxprom205
  %183 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx206, align 8
  %aux207 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %183, i32 0, i32 7
  %184 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux207, align 8
  %jited_linfo208 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %184, i32 0, i32 48
  store i8** %180, i8*** %jited_linfo208, align 8
  %185 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info209 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %185, i32 0, i32 23
  %186 = load i32, i32* %i, align 4
  %idxprom210 = sext i32 %186 to i64
  %arrayidx211 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info209, i64 0, i64 %idxprom210
  %linfo_idx = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx211, i32 0, i32 1
  %187 = load i32, i32* %linfo_idx, align 4
  %188 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %189 = load i32, i32* %i, align 4
  %idxprom212 = sext i32 %189 to i64
  %arrayidx213 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %188, i64 %idxprom212
  %190 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx213, align 8
  %aux214 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %190, i32 0, i32 7
  %191 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux214, align 8
  %linfo_idx215 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %191, i32 0, i32 51
  store i32 %187, i32* %linfo_idx215, align 8
  store i32 0, i32* %num_exentries, align 4
  %192 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %193 = load i32, i32* %i, align 4
  %idxprom216 = sext i32 %193 to i64
  %arrayidx217 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %192, i64 %idxprom216
  %194 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx217, align 8
  %insnsi218 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %194, i32 0, i32 11
  %arraydecay219 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi218, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay219, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond220

for.cond220:                                      ; preds = %for.inc240, %for.end176
  %195 = load i32, i32* %j, align 4
  %196 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %197 = load i32, i32* %i, align 4
  %idxprom221 = sext i32 %197 to i64
  %arrayidx222 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %196, i64 %idxprom221
  %198 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx222, align 8
  %len223 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %198, i32 0, i32 4
  %199 = load i32, i32* %len223, align 4
  %cmp224 = icmp ult i32 %195, %199
  br i1 %cmp224, label %for.body226, label %for.end243

for.body226:                                      ; preds = %for.cond220
  %200 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code227 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %200, i32 0, i32 0
  %201 = load i8, i8* %code227, align 4
  %conv228 = zext i8 %201 to i32
  %and = and i32 %conv228, 7
  %cmp229 = icmp eq i32 %and, 1
  br i1 %cmp229, label %land.lhs.true231, label %if.end239

land.lhs.true231:                                 ; preds = %for.body226
  %202 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code232 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %202, i32 0, i32 0
  %203 = load i8, i8* %code232, align 4
  %conv233 = zext i8 %203 to i32
  %and234 = and i32 %conv233, 224
  %cmp235 = icmp eq i32 %and234, 32
  br i1 %cmp235, label %if.then237, label %if.end239

if.then237:                                       ; preds = %land.lhs.true231
  %204 = load i32, i32* %num_exentries, align 4
  %inc238 = add i32 %204, 1
  store i32 %inc238, i32* %num_exentries, align 4
  br label %if.end239

if.end239:                                        ; preds = %if.then237, %land.lhs.true231, %for.body226
  br label %for.inc240

for.inc240:                                       ; preds = %if.end239
  %205 = load i32, i32* %j, align 4
  %inc241 = add i32 %205, 1
  store i32 %inc241, i32* %j, align 4
  %206 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr242 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %206, i32 1
  store %struct.bpf_insn* %incdec.ptr242, %struct.bpf_insn** %insn, align 8
  br label %for.cond220

for.end243:                                       ; preds = %for.cond220
  %207 = load i32, i32* %num_exentries, align 4
  %208 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %209 = load i32, i32* %i, align 4
  %idxprom244 = sext i32 %209 to i64
  %arrayidx245 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %208, i64 %idxprom244
  %210 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx245, align 8
  %aux246 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %210, i32 0, i32 7
  %211 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux246, align 8
  %num_exentries247 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %211, i32 0, i32 52
  store i32 %207, i32* %num_exentries247, align 4
  %212 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info248 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %212, i32 0, i32 23
  %213 = load i32, i32* %i, align 4
  %idxprom249 = sext i32 %213 to i64
  %arrayidx250 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info248, i64 0, i64 %idxprom249
  %tail_call_reachable = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx250, i32 0, i32 4
  %214 = load i8, i8* %tail_call_reachable, align 1
  %tobool251 = trunc i8 %214 to i1
  %215 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %216 = load i32, i32* %i, align 4
  %idxprom252 = sext i32 %216 to i64
  %arrayidx253 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %215, i64 %idxprom252
  %217 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx253, align 8
  %aux254 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %217, i32 0, i32 7
  %218 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux254, align 8
  %tail_call_reachable255 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %218, i32 0, i32 24
  %frombool = zext i1 %tobool251 to i8
  store i8 %frombool, i8* %tail_call_reachable255, align 1
  %219 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %220 = load i32, i32* %i, align 4
  %idxprom256 = sext i32 %220 to i64
  %arrayidx257 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %219, i64 %idxprom256
  %221 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx257, align 8
  %call258 = call %struct.bpf_prog* @bpf_int_jit_compile(%struct.bpf_prog* noundef %221) #11
  %222 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %223 = load i32, i32* %i, align 4
  %idxprom259 = sext i32 %223 to i64
  %arrayidx260 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %222, i64 %idxprom259
  store %struct.bpf_prog* %call258, %struct.bpf_prog** %arrayidx260, align 8
  %224 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %225 = load i32, i32* %i, align 4
  %idxprom261 = sext i32 %225 to i64
  %arrayidx262 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %224, i64 %idxprom261
  %226 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx262, align 8
  %jited = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %226, i32 0, i32 1
  %bf.load263 = load i16, i16* %jited, align 2
  %bf.clear264 = and i16 %bf.load263, 1
  %tobool265 = icmp ne i16 %bf.clear264, 0
  br i1 %tobool265, label %if.end267, label %if.then266

if.then266:                                       ; preds = %for.end243
  store i32 -524, i32* %err, align 4
  br label %out_free

if.end267:                                        ; preds = %for.end243
  call void @___might_sleep(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 noundef 12635, i32 noundef 0) #11
  %call269 = call i32 @_cond_resched() #11
  store i32 %call269, i32* %tmp268, align 4
  %227 = load i32, i32* %tmp268, align 4
  br label %for.inc270

for.inc270:                                       ; preds = %if.end267
  %228 = load i32, i32* %i, align 4
  %inc271 = add i32 %228, 1
  store i32 %inc271, i32* %i, align 4
  br label %for.cond74

for.end272:                                       ; preds = %for.cond74
  store i32 0, i32* %i, align 4
  br label %for.cond273

for.cond273:                                      ; preds = %for.inc287, %for.end272
  %229 = load i32, i32* %i, align 4
  %230 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux274 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %230, i32 0, i32 7
  %231 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux274, align 8
  %size_poke_tab275 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %231, i32 0, i32 32
  %232 = load i32, i32* %size_poke_tab275, align 8
  %cmp276 = icmp ult i32 %229, %232
  br i1 %cmp276, label %for.body278, label %for.end289

for.body278:                                      ; preds = %for.cond273
  %233 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux279 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %233, i32 0, i32 7
  %234 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux279, align 8
  %poke_tab280 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %234, i32 0, i32 31
  %235 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab280, align 8
  %236 = load i32, i32* %i, align 4
  %idxprom281 = sext i32 %236 to i64
  %arrayidx282 = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %235, i64 %idxprom281
  %237 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %arrayidx282, i32 0, i32 3
  %tail_call283 = bitcast %union.anon.4* %237 to %struct.anon.5*
  %map284 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %tail_call283, i32 0, i32 0
  %238 = load %struct.bpf_map*, %struct.bpf_map** %map284, align 8
  store %struct.bpf_map* %238, %struct.bpf_map** %map_ptr, align 8
  %239 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops285 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %239, i32 0, i32 0
  %240 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops285, align 64
  %map_poke_untrack = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %240, i32 0, i32 24
  %241 = load void (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_untrack, align 8
  %242 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %243 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux286 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %243, i32 0, i32 7
  %244 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux286, align 8
  call void %241(%struct.bpf_map* noundef %242, %struct.bpf_prog_aux* noundef %244) #11
  br label %for.inc287

for.inc287:                                       ; preds = %for.body278
  %245 = load i32, i32* %i, align 4
  %inc288 = add i32 %245, 1
  store i32 %inc288, i32* %i, align 4
  br label %for.cond273

for.end289:                                       ; preds = %for.cond273
  store i32 0, i32* %i, align 4
  br label %for.cond290

for.cond290:                                      ; preds = %for.inc337, %for.end289
  %246 = load i32, i32* %i, align 4
  %247 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt291 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %247, i32 0, i32 26
  %248 = load i32, i32* %subprog_cnt291, align 4
  %cmp292 = icmp ult i32 %246, %248
  br i1 %cmp292, label %for.body294, label %for.end339

for.body294:                                      ; preds = %for.cond290
  %249 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %250 = load i32, i32* %i, align 4
  %idxprom295 = sext i32 %250 to i64
  %arrayidx296 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %249, i64 %idxprom295
  %251 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx296, align 8
  %insnsi297 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %251, i32 0, i32 11
  %arraydecay298 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi297, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay298, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond299

for.cond299:                                      ; preds = %for.inc325, %for.body294
  %252 = load i32, i32* %j, align 4
  %253 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %254 = load i32, i32* %i, align 4
  %idxprom300 = sext i32 %254 to i64
  %arrayidx301 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %253, i64 %idxprom300
  %255 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx301, align 8
  %len302 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %255, i32 0, i32 4
  %256 = load i32, i32* %len302, align 4
  %cmp303 = icmp ult i32 %252, %256
  br i1 %cmp303, label %for.body305, label %for.end328

for.body305:                                      ; preds = %for.cond299
  %257 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code306 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %257, i32 0, i32 0
  %258 = load i8, i8* %code306, align 4
  %conv307 = zext i8 %258 to i32
  %cmp308 = icmp ne i32 %conv307, 133
  br i1 %cmp308, label %if.then317, label %lor.lhs.false310

lor.lhs.false310:                                 ; preds = %for.body305
  %259 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg311 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %259, i32 0, i32 1
  %bf.load312 = load i8, i8* %src_reg311, align 1
  %bf.lshr313 = lshr i8 %bf.load312, 4
  %conv314 = zext i8 %bf.lshr313 to i32
  %cmp315 = icmp ne i32 %conv314, 1
  br i1 %cmp315, label %if.then317, label %if.end318

if.then317:                                       ; preds = %lor.lhs.false310, %for.body305
  br label %for.inc325

if.end318:                                        ; preds = %lor.lhs.false310
  %260 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off319 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %260, i32 0, i32 2
  %261 = load i16, i16* %off319, align 2
  %conv320 = sext i16 %261 to i32
  store i32 %conv320, i32* %subprog, align 4
  %262 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %263 = load i32, i32* %subprog, align 4
  %idxprom321 = sext i32 %263 to i64
  %arrayidx322 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %262, i64 %idxprom321
  %264 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx322, align 8
  %bpf_func = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %264, i32 0, i32 9
  %265 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func, align 8
  %266 = bitcast i32 (i8*, %struct.bpf_insn*)* %265 to i64 (i64, i64, i64, i64, i64)*
  %sub.ptr.lhs.cast = ptrtoint i64 (i64, i64, i64, i64, i64)* %266 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, ptrtoint (i64 (i64, i64, i64, i64, i64)* @__bpf_call_base to i64)
  %conv323 = trunc i64 %sub.ptr.sub to i32
  %267 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm324 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %267, i32 0, i32 3
  store i32 %conv323, i32* %imm324, align 4
  br label %for.inc325

for.inc325:                                       ; preds = %if.end318, %if.then317
  %268 = load i32, i32* %j, align 4
  %inc326 = add i32 %268, 1
  store i32 %inc326, i32* %j, align 4
  %269 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr327 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %269, i32 1
  store %struct.bpf_insn* %incdec.ptr327, %struct.bpf_insn** %insn, align 8
  br label %for.cond299

for.end328:                                       ; preds = %for.cond299
  %270 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %271 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %272 = load i32, i32* %i, align 4
  %idxprom329 = sext i32 %272 to i64
  %arrayidx330 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %271, i64 %idxprom329
  %273 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx330, align 8
  %aux331 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %273, i32 0, i32 7
  %274 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux331, align 8
  %func332 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %274, i32 0, i32 29
  store %struct.bpf_prog** %270, %struct.bpf_prog*** %func332, align 8
  %275 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt333 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %275, i32 0, i32 26
  %276 = load i32, i32* %subprog_cnt333, align 4
  %277 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %278 = load i32, i32* %i, align 4
  %idxprom334 = sext i32 %278 to i64
  %arrayidx335 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %277, i64 %idxprom334
  %279 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx335, align 8
  %aux336 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %279, i32 0, i32 7
  %280 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux336, align 8
  %func_cnt = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %280, i32 0, i32 7
  store i32 %276, i32* %func_cnt, align 8
  br label %for.inc337

for.inc337:                                       ; preds = %for.end328
  %281 = load i32, i32* %i, align 4
  %inc338 = add i32 %281, 1
  store i32 %inc338, i32* %i, align 4
  br label %for.cond290

for.end339:                                       ; preds = %for.cond290
  store i32 0, i32* %i, align 4
  br label %for.cond340

for.cond340:                                      ; preds = %for.inc365, %for.end339
  %282 = load i32, i32* %i, align 4
  %283 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt341 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %283, i32 0, i32 26
  %284 = load i32, i32* %subprog_cnt341, align 4
  %cmp342 = icmp ult i32 %282, %284
  br i1 %cmp342, label %for.body344, label %for.end367

for.body344:                                      ; preds = %for.cond340
  %285 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %286 = load i32, i32* %i, align 4
  %idxprom345 = sext i32 %286 to i64
  %arrayidx346 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %285, i64 %idxprom345
  %287 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx346, align 8
  %bpf_func347 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %287, i32 0, i32 9
  %288 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func347, align 8
  %289 = bitcast i32 (i8*, %struct.bpf_insn*)* %288 to i8*
  store i8* %289, i8** %old_bpf_func, align 8
  %290 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %291 = load i32, i32* %i, align 4
  %idxprom348 = sext i32 %291 to i64
  %arrayidx349 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %290, i64 %idxprom348
  %292 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx349, align 8
  %call350 = call %struct.bpf_prog* @bpf_int_jit_compile(%struct.bpf_prog* noundef %292) #11
  store %struct.bpf_prog* %call350, %struct.bpf_prog** %tmp, align 8
  %293 = load %struct.bpf_prog*, %struct.bpf_prog** %tmp, align 8
  %294 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %295 = load i32, i32* %i, align 4
  %idxprom351 = sext i32 %295 to i64
  %arrayidx352 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %294, i64 %idxprom351
  %296 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx352, align 8
  %cmp353 = icmp ne %struct.bpf_prog* %293, %296
  br i1 %cmp353, label %if.then361, label %lor.lhs.false355

lor.lhs.false355:                                 ; preds = %for.body344
  %297 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %298 = load i32, i32* %i, align 4
  %idxprom356 = sext i32 %298 to i64
  %arrayidx357 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %297, i64 %idxprom356
  %299 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx357, align 8
  %bpf_func358 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %299, i32 0, i32 9
  %300 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func358, align 8
  %301 = load i8*, i8** %old_bpf_func, align 8
  %302 = bitcast i8* %301 to i32 (i8*, %struct.bpf_insn*)*
  %cmp359 = icmp ne i32 (i8*, %struct.bpf_insn*)* %300, %302
  br i1 %cmp359, label %if.then361, label %if.end362

if.then361:                                       ; preds = %lor.lhs.false355, %for.body344
  %303 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %304 = bitcast %struct.bpf_verifier_env* %303 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %304, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.383, i64 0, i64 0)) #11
  store i32 -524, i32* %err, align 4
  br label %out_free

if.end362:                                        ; preds = %lor.lhs.false355
  call void @___might_sleep(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 noundef 12687, i32 noundef 0) #11
  %call364 = call i32 @_cond_resched() #11
  store i32 %call364, i32* %tmp363, align 4
  %305 = load i32, i32* %tmp363, align 4
  br label %for.inc365

for.inc365:                                       ; preds = %if.end362
  %306 = load i32, i32* %i, align 4
  %inc366 = add i32 %306, 1
  store i32 %inc366, i32* %i, align 4
  br label %for.cond340

for.end367:                                       ; preds = %for.cond340
  store i32 0, i32* %i, align 4
  br label %for.cond368

for.cond368:                                      ; preds = %for.inc377, %for.end367
  %307 = load i32, i32* %i, align 4
  %308 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt369 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %308, i32 0, i32 26
  %309 = load i32, i32* %subprog_cnt369, align 4
  %cmp370 = icmp ult i32 %307, %309
  br i1 %cmp370, label %for.body372, label %for.end379

for.body372:                                      ; preds = %for.cond368
  %310 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %311 = load i32, i32* %i, align 4
  %idxprom373 = sext i32 %311 to i64
  %arrayidx374 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %310, i64 %idxprom373
  %312 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx374, align 8
  call void @bpf_prog_lock_ro(%struct.bpf_prog* noundef %312) #11
  %313 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %314 = load i32, i32* %i, align 4
  %idxprom375 = sext i32 %314 to i64
  %arrayidx376 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %313, i64 %idxprom375
  %315 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx376, align 8
  call void @bpf_prog_kallsyms_add(%struct.bpf_prog* noundef %315) #11
  br label %for.inc377

for.inc377:                                       ; preds = %for.body372
  %316 = load i32, i32* %i, align 4
  %inc378 = add i32 %316, 1
  store i32 %inc378, i32* %i, align 4
  br label %for.cond368

for.end379:                                       ; preds = %for.cond368
  store i32 0, i32* %i, align 4
  %317 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi380 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %317, i32 0, i32 11
  %arraydecay381 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi380, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay381, %struct.bpf_insn** %insn, align 8
  br label %for.cond382

for.cond382:                                      ; preds = %for.inc412, %for.end379
  %318 = load i32, i32* %i, align 4
  %319 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len383 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %319, i32 0, i32 4
  %320 = load i32, i32* %len383, align 4
  %cmp384 = icmp ult i32 %318, %320
  br i1 %cmp384, label %for.body386, label %for.end415

for.body386:                                      ; preds = %for.cond382
  %321 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code387 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %321, i32 0, i32 0
  %322 = load i8, i8* %code387, align 4
  %conv388 = zext i8 %322 to i32
  %cmp389 = icmp ne i32 %conv388, 133
  br i1 %cmp389, label %if.then398, label %lor.lhs.false391

lor.lhs.false391:                                 ; preds = %for.body386
  %323 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg392 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %323, i32 0, i32 1
  %bf.load393 = load i8, i8* %src_reg392, align 1
  %bf.lshr394 = lshr i8 %bf.load393, 4
  %conv395 = zext i8 %bf.lshr394 to i32
  %cmp396 = icmp ne i32 %conv395, 1
  br i1 %cmp396, label %if.then398, label %if.end399

if.then398:                                       ; preds = %lor.lhs.false391, %for.body386
  br label %for.inc412

if.end399:                                        ; preds = %lor.lhs.false391
  %324 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data400 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %324, i32 0, i32 20
  %325 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data400, align 8
  %326 = load i32, i32* %i, align 4
  %idxprom401 = sext i32 %326 to i64
  %arrayidx402 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %325, i64 %idxprom401
  %327 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx402, i32 0, i32 0
  %call_imm403 = bitcast %struct.atomic64_t* %327 to i32*
  %328 = load i32, i32* %call_imm403, align 8
  %conv404 = trunc i32 %328 to i16
  %329 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off405 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %329, i32 0, i32 2
  store i16 %conv404, i16* %off405, align 2
  %330 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %331 = load i32, i32* %i, align 4
  %332 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off406 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %332, i32 0, i32 2
  %333 = load i16, i16* %off406, align 2
  %conv407 = sext i16 %333 to i32
  %add408 = add i32 %331, %conv407
  %add409 = add i32 %add408, 1
  %call410 = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %330, i32 noundef %add409) #11
  store i32 %call410, i32* %subprog, align 4
  %334 = load i32, i32* %subprog, align 4
  %335 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm411 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %335, i32 0, i32 3
  store i32 %334, i32* %imm411, align 4
  br label %for.inc412

for.inc412:                                       ; preds = %if.end399, %if.then398
  %336 = load i32, i32* %i, align 4
  %inc413 = add i32 %336, 1
  store i32 %inc413, i32* %i, align 4
  %337 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr414 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %337, i32 1
  store %struct.bpf_insn* %incdec.ptr414, %struct.bpf_insn** %insn, align 8
  br label %for.cond382

for.end415:                                       ; preds = %for.cond382
  %338 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jited416 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %338, i32 0, i32 1
  %bf.load417 = load i16, i16* %jited416, align 2
  %bf.clear418 = and i16 %bf.load417, -2
  %bf.set419 = or i16 %bf.clear418, 1
  store i16 %bf.set419, i16* %jited416, align 2
  %339 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %arrayidx420 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %339, i64 0
  %340 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx420, align 8
  %bpf_func421 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %340, i32 0, i32 9
  %341 = load i32 (i8*, %struct.bpf_insn*)*, i32 (i8*, %struct.bpf_insn*)** %bpf_func421, align 8
  %342 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %bpf_func422 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %342, i32 0, i32 9
  store i32 (i8*, %struct.bpf_insn*)* %341, i32 (i8*, %struct.bpf_insn*)** %bpf_func422, align 8
  %343 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %344 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux423 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %344, i32 0, i32 7
  %345 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux423, align 8
  %func424 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %345, i32 0, i32 29
  store %struct.bpf_prog** %343, %struct.bpf_prog*** %func424, align 8
  %346 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt425 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %346, i32 0, i32 26
  %347 = load i32, i32* %subprog_cnt425, align 4
  %348 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux426 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %348, i32 0, i32 7
  %349 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux426, align 8
  %func_cnt427 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %349, i32 0, i32 7
  store i32 %347, i32* %func_cnt427, align 8
  %350 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  call void @bpf_prog_free_unused_jited_linfo(%struct.bpf_prog* noundef %350) #11
  store i32 0, i32* %retval, align 4
  br label %return

out_free:                                         ; preds = %if.then361, %if.then266, %if.then172, %if.then150, %if.then109, %if.then89
  store i32 0, i32* %i, align 4
  br label %for.cond428

for.cond428:                                      ; preds = %for.inc464, %out_free
  %351 = load i32, i32* %i, align 4
  %352 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt429 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %352, i32 0, i32 26
  %353 = load i32, i32* %subprog_cnt429, align 4
  %cmp430 = icmp ult i32 %351, %353
  br i1 %cmp430, label %for.body432, label %for.end466

for.body432:                                      ; preds = %for.cond428
  %354 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %355 = load i32, i32* %i, align 4
  %idxprom433 = sext i32 %355 to i64
  %arrayidx434 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %354, i64 %idxprom433
  %356 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx434, align 8
  %tobool435 = icmp ne %struct.bpf_prog* %356, null
  br i1 %tobool435, label %if.end437, label %if.then436

if.then436:                                       ; preds = %for.body432
  br label %for.inc464

if.end437:                                        ; preds = %for.body432
  store i32 0, i32* %j, align 4
  br label %for.cond438

for.cond438:                                      ; preds = %for.inc459, %if.end437
  %357 = load i32, i32* %j, align 4
  %358 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %359 = load i32, i32* %i, align 4
  %idxprom439 = sext i32 %359 to i64
  %arrayidx440 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %358, i64 %idxprom439
  %360 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx440, align 8
  %aux441 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %360, i32 0, i32 7
  %361 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux441, align 8
  %size_poke_tab442 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %361, i32 0, i32 32
  %362 = load i32, i32* %size_poke_tab442, align 8
  %cmp443 = icmp ult i32 %357, %362
  br i1 %cmp443, label %for.body445, label %for.end461

for.body445:                                      ; preds = %for.cond438
  %363 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %364 = load i32, i32* %i, align 4
  %idxprom446 = sext i32 %364 to i64
  %arrayidx447 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %363, i64 %idxprom446
  %365 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx447, align 8
  %aux448 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %365, i32 0, i32 7
  %366 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux448, align 8
  %poke_tab449 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %366, i32 0, i32 31
  %367 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab449, align 8
  %368 = load i32, i32* %j, align 4
  %idxprom450 = sext i32 %368 to i64
  %arrayidx451 = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %367, i64 %idxprom450
  %369 = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %arrayidx451, i32 0, i32 3
  %tail_call452 = bitcast %union.anon.4* %369 to %struct.anon.5*
  %map453 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %tail_call452, i32 0, i32 0
  %370 = load %struct.bpf_map*, %struct.bpf_map** %map453, align 8
  store %struct.bpf_map* %370, %struct.bpf_map** %map_ptr, align 8
  %371 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %ops454 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %371, i32 0, i32 0
  %372 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops454, align 64
  %map_poke_untrack455 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %372, i32 0, i32 24
  %373 = load void (%struct.bpf_map*, %struct.bpf_prog_aux*)*, void (%struct.bpf_map*, %struct.bpf_prog_aux*)** %map_poke_untrack455, align 8
  %374 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %375 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %376 = load i32, i32* %i, align 4
  %idxprom456 = sext i32 %376 to i64
  %arrayidx457 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %375, i64 %idxprom456
  %377 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx457, align 8
  %aux458 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %377, i32 0, i32 7
  %378 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux458, align 8
  call void %373(%struct.bpf_map* noundef %374, %struct.bpf_prog_aux* noundef %378) #11
  br label %for.inc459

for.inc459:                                       ; preds = %for.body445
  %379 = load i32, i32* %j, align 4
  %inc460 = add i32 %379, 1
  store i32 %inc460, i32* %j, align 4
  br label %for.cond438

for.end461:                                       ; preds = %for.cond438
  %380 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %381 = load i32, i32* %i, align 4
  %idxprom462 = sext i32 %381 to i64
  %arrayidx463 = getelementptr %struct.bpf_prog*, %struct.bpf_prog** %380, i64 %idxprom462
  %382 = load %struct.bpf_prog*, %struct.bpf_prog** %arrayidx463, align 8
  call void @bpf_jit_free(%struct.bpf_prog* noundef %382) #11
  br label %for.inc464

for.inc464:                                       ; preds = %for.end461, %if.then436
  %383 = load i32, i32* %i, align 4
  %inc465 = add i32 %383, 1
  store i32 %inc465, i32* %i, align 4
  br label %for.cond428

for.end466:                                       ; preds = %for.cond428
  %384 = load %struct.bpf_prog**, %struct.bpf_prog*** %func, align 8
  %385 = bitcast %struct.bpf_prog** %384 to i8*
  call void @kfree(i8* noundef %385) #11
  br label %out_undo_insn

out_undo_insn:                                    ; preds = %for.end466, %if.then72, %if.then66
  %386 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested467 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %386, i32 0, i32 1
  %bf.load468 = load i16, i16* %jit_requested467, align 2
  %bf.clear469 = and i16 %bf.load468, -3
  %bf.set470 = or i16 %bf.clear469, 0
  store i16 %bf.set470, i16* %jit_requested467, align 2
  store i32 0, i32* %i, align 4
  %387 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi471 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %387, i32 0, i32 11
  %arraydecay472 = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi471, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay472, %struct.bpf_insn** %insn, align 8
  br label %for.cond473

for.cond473:                                      ; preds = %for.inc497, %out_undo_insn
  %388 = load i32, i32* %i, align 4
  %389 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len474 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %389, i32 0, i32 4
  %390 = load i32, i32* %len474, align 4
  %cmp475 = icmp ult i32 %388, %390
  br i1 %cmp475, label %for.body477, label %for.end500

for.body477:                                      ; preds = %for.cond473
  %391 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code478 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %391, i32 0, i32 0
  %392 = load i8, i8* %code478, align 4
  %conv479 = zext i8 %392 to i32
  %cmp480 = icmp ne i32 %conv479, 133
  br i1 %cmp480, label %if.then489, label %lor.lhs.false482

lor.lhs.false482:                                 ; preds = %for.body477
  %393 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg483 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %393, i32 0, i32 1
  %bf.load484 = load i8, i8* %src_reg483, align 1
  %bf.lshr485 = lshr i8 %bf.load484, 4
  %conv486 = zext i8 %bf.lshr485 to i32
  %cmp487 = icmp ne i32 %conv486, 1
  br i1 %cmp487, label %if.then489, label %if.end490

if.then489:                                       ; preds = %lor.lhs.false482, %for.body477
  br label %for.inc497

if.end490:                                        ; preds = %lor.lhs.false482
  %394 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off491 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %394, i32 0, i32 2
  store i16 0, i16* %off491, align 2
  %395 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data492 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %395, i32 0, i32 20
  %396 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data492, align 8
  %397 = load i32, i32* %i, align 4
  %idxprom493 = sext i32 %397 to i64
  %arrayidx494 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %396, i64 %idxprom493
  %398 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx494, i32 0, i32 0
  %call_imm495 = bitcast %struct.atomic64_t* %398 to i32*
  %399 = load i32, i32* %call_imm495, align 8
  %400 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm496 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %400, i32 0, i32 3
  store i32 %399, i32* %imm496, align 4
  br label %for.inc497

for.inc497:                                       ; preds = %if.end490, %if.then489
  %401 = load i32, i32* %i, align 4
  %inc498 = add i32 %401, 1
  store i32 %inc498, i32* %i, align 4
  %402 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %incdec.ptr499 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %402, i32 1
  store %struct.bpf_insn* %incdec.ptr499, %struct.bpf_insn** %insn, align 8
  br label %for.cond473

for.end500:                                       ; preds = %for.cond473
  %403 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  call void @bpf_prog_free_jited_linfo(%struct.bpf_prog* noundef %403) #11
  %404 = load i32, i32* %err, align 4
  store i32 %404, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end500, %for.end415, %if.end52, %if.then
  %405 = load i32, i32* %retval, align 4
  ret i32 %405
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @get_callee_stack_depth(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32 noundef %idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %idx.addr = alloca i32, align 4
  %start = alloca i32, align 4
  %subprog = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp34 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load i32, i32* %idx.addr, align 4
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 3
  %2 = load i32, i32* %imm, align 4
  %add = add i32 %0, %2
  %add1 = add i32 %add, 1
  store i32 %add1, i32* %start, align 4
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = load i32, i32* %start, align 4
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %3, i32 noundef %4) #11
  store i32 %call, i32* %subprog, align 4
  %5 = load i32, i32* %subprog, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end41

if.then:                                          ; preds = %entry
  store i32 1, i32* %__ret_warn_once, align 4
  %6 = load i32, i32* %__ret_warn_once, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then
  %7 = load i8, i8* @get_callee_stack_depth.__warned, align 1
  %tobool2 = trunc i8 %7 to i1
  %lnot = xor i1 %tobool2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then
  %8 = phi i1 [ false, %if.then ], [ %lnot, %land.rhs ]
  %lnot3 = xor i1 %8, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv, 0
  br i1 %tobool5, label %if.then6, label %if.end33

if.then6:                                         ; preds = %land.end
  store i8 1, i8* @get_callee_stack_depth.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool7 = icmp ne i32 %9, 0
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %tobool13 = icmp ne i64 %conv12, 0
  br i1 %tobool13, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.then6
  br label %do.body

do.body:                                          ; preds = %if.then14
  br label %do.body15

do.body15:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body15
  %10 = load i32, i32* %start, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.283, i64 0, i64 0), i32 noundef %10) #11
  br label %do.body16

do.body16:                                        ; preds = %do.end
  br label %do.body17

do.body17:                                        ; preds = %do.body16
  br label %do.end18

do.end18:                                         ; preds = %do.body17
  br label %do.body19

do.body19:                                        ; preds = %do.end18
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 3218, i32 2313, i64 12) #10, !srcloc !23
  br label %do.end20

do.end20:                                         ; preds = %do.body19
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 425) #10, !srcloc !24
  br label %do.body21

do.body21:                                        ; preds = %do.end20
  br label %do.end22

do.end22:                                         ; preds = %do.body21
  br label %do.end23

do.end23:                                         ; preds = %do.end22
  br label %do.body24

do.body24:                                        ; preds = %do.end23
  br label %do.end25

do.end25:                                         ; preds = %do.body24
  br label %do.end26

do.end26:                                         ; preds = %do.end25
  br label %if.end

if.end:                                           ; preds = %do.end26, %if.then6
  %11 = load i32, i32* %__ret_warn_on, align 4
  %tobool27 = icmp ne i32 %11, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  store i64 %conv32, i64* %tmp, align 8
  %12 = load i64, i64* %tmp, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.end, %land.end
  %13 = load i32, i32* %__ret_warn_once, align 4
  %tobool35 = icmp ne i32 %13, 0
  %lnot36 = xor i1 %tobool35, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %conv40 = sext i32 %lnot.ext39 to i64
  store i64 %conv40, i64* %tmp34, align 8
  %14 = load i64, i64* %tmp34, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %entry
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 23
  %16 = load i32, i32* %subprog, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %17 = load i16, i16* %stack_depth, align 8
  %conv42 = zext i16 %17 to i32
  store i32 %conv42, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end41, %if.end33
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_patch_call_args(%struct.bpf_insn* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @find_subprog(%struct.bpf_verifier_env* noundef %env, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %p = alloca %struct.bpf_subprog_info*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = bitcast i32* %off.addr to i8*
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 23
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  %2 = bitcast %struct.bpf_subprog_info* %arraydecay to i8*
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 26
  %4 = load i32, i32* %subprog_cnt, align 4
  %conv = zext i32 %4 to i64
  %call = call i8* @bsearch(i8* noundef %0, i8* noundef %2, i64 noundef %conv, i64 noundef 16, i32 (i8*, i8*)* noundef @cmp_subprogs) #11
  %5 = bitcast i8* %call to %struct.bpf_subprog_info*
  store %struct.bpf_subprog_info* %5, %struct.bpf_subprog_info** %p, align 8
  %6 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %p, align 8
  %tobool = icmp ne %struct.bpf_subprog_info* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -2, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %p, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 23
  %arraydecay2 = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info1, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint %struct.bpf_subprog_info* %7 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.bpf_subprog_info* %arraydecay2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 16
  %conv3 = trunc i64 %sub.ptr.div to i32
  store i32 %conv3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @cmp_subprogs(i8* noundef %a, i8* noundef %b) #0 {
entry:
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  store i8* %a, i8** %a.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  %0 = load i8*, i8** %a.addr, align 8
  %1 = bitcast i8* %0 to %struct.bpf_subprog_info*
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %1, i32 0, i32 0
  %2 = load i32, i32* %start, align 4
  %3 = load i8*, i8** %b.addr, align 8
  %4 = bitcast i8* %3 to %struct.bpf_subprog_info*
  %start1 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %4, i32 0, i32 0
  %5 = load i32, i32* %start1, align 4
  %sub = sub i32 %2, %5
  ret i32 %sub
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @bsearch(i8* noundef, i8* noundef, i64 noundef, i64 noundef, i32 (i8*, i8*)* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_alloc_jited_linfo(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kcalloc(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  %1 = load i64, i64* %size.addr, align 8
  %2 = load i32, i32* %flags.addr, align 4
  %or = or i32 %2, 256
  %call = call i8* @kmalloc_array(i64 noundef %0, i64 noundef %1, i32 noundef %or) #11
  ret i8* %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_prog_size(i32 noundef %proglen) #0 {
entry:
  %proglen.addr = alloca i32, align 4
  %__UNIQUE_ID___x359 = alloca i64, align 8
  %__UNIQUE_ID___y360 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store i32 %proglen, i32* %proglen.addr, align 4
  store i64 56, i64* %__UNIQUE_ID___x359, align 8
  %0 = load i32, i32* %proglen.addr, align 4
  %conv = zext i32 %0 to i64
  %1 = mul i64 %conv, 8
  %2 = add i64 56, %1
  store i64 %2, i64* %__UNIQUE_ID___y360, align 8
  %3 = load i64, i64* %__UNIQUE_ID___x359, align 8
  %4 = load i64, i64* %__UNIQUE_ID___y360, align 8
  %cmp = icmp ugt i64 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, i64* %__UNIQUE_ID___x359, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, i64* %__UNIQUE_ID___y360, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %6, %cond.false ]
  store i64 %cond, i64* %tmp, align 8
  %7 = load i64, i64* %tmp, align 8
  %conv2 = trunc i64 %7 to i32
  ret i32 %conv2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_prog* @bpf_prog_alloc_no_stats(i32 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_calc_tag(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_jit_add_poke_descriptor(%struct.bpf_prog* noundef %prog, %struct.bpf_jit_poke_descriptor* noundef %poke) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %poke.addr = alloca %struct.bpf_jit_poke_descriptor*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store %struct.bpf_jit_poke_descriptor* %poke, %struct.bpf_jit_poke_descriptor** %poke.addr, align 8
  ret i32 -524
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_prog* @bpf_int_jit_compile(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @___might_sleep(i8* noundef %file, i32 noundef %line, i32 noundef %preempt_offset) #0 {
entry:
  %file.addr = alloca i8*, align 8
  %line.addr = alloca i32, align 4
  %preempt_offset.addr = alloca i32, align 4
  store i8* %file, i8** %file.addr, align 8
  store i32 %line, i32* %line.addr, align 4
  store i32 %preempt_offset, i32* %preempt_offset.addr, align 4
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @_cond_resched() #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @__bpf_call_base(i64 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_prog_lock_ro(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %jited = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 1
  %bf.load = load i16, i16* %jited, align 2
  %bf.clear = and i16 %bf.load, 1
  %tobool = icmp ne i16 %bf.clear, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %2 = bitcast %struct.bpf_prog* %1 to i8*
  call void @set_vm_flush_reset_perms(i8* noundef %2) #11
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %4 = ptrtoint %struct.bpf_prog* %3 to i64
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  %pages = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 0
  %6 = load i16, i16* %pages, align 8
  %conv = zext i16 %6 to i32
  %call = call i32 @set_memory_ro(i64 noundef %4, i32 noundef %conv) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_prog_kallsyms_add(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_free_unused_jited_linfo(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_jit_free(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  call void @bpf_prog_unlock_free(%struct.bpf_prog* noundef %0) #11
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_free_jited_linfo(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_prog_unlock_free(%struct.bpf_prog* noundef %fp) #0 {
entry:
  %fp.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %fp, %struct.bpf_prog** %fp.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %fp.addr, align 8
  call void @__bpf_prog_free(%struct.bpf_prog* noundef %0) #11
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @__bpf_prog_free(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @set_vm_flush_reset_perms(i8* noundef %addr) #0 {
entry:
  %addr.addr = alloca i8*, align 8
  %vm = alloca %struct.vm_struct*, align 8
  store i8* %addr, i8** %addr.addr, align 8
  %0 = load i8*, i8** %addr.addr, align 8
  %call = call %struct.vm_struct* @find_vm_area(i8* noundef %0) #11
  store %struct.vm_struct* %call, %struct.vm_struct** %vm, align 8
  %1 = load %struct.vm_struct*, %struct.vm_struct** %vm, align 8
  %tobool = icmp ne %struct.vm_struct* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.vm_struct*, %struct.vm_struct** %vm, align 8
  %flags = getelementptr inbounds %struct.vm_struct, %struct.vm_struct* %2, i32 0, i32 3
  %3 = load i64, i64* %flags, align 8
  %or = or i64 %3, 256
  store i64 %or, i64* %flags, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @set_memory_ro(i64 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.vm_struct* @find_vm_area(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @insn_no_def(%struct.bpf_insn* noundef %insn) #0 {
entry:
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %class = alloca i8, align 1
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 7
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %class, align 1
  %2 = load i8, i8* %class, align 1
  %conv2 = zext i8 %2 to i32
  %cmp = icmp eq i32 %conv2, 5
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i8, i8* %class, align 1
  %conv4 = zext i8 %3 to i32
  %cmp5 = icmp eq i32 %conv4, 6
  br i1 %cmp5, label %lor.end, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %4 = load i8, i8* %class, align 1
  %conv8 = zext i8 %4 to i32
  %cmp9 = icmp eq i32 %conv8, 3
  br i1 %cmp9, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false7
  %5 = load i8, i8* %class, align 1
  %conv11 = zext i8 %5 to i32
  %cmp12 = icmp eq i32 %conv11, 2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false7, %lor.lhs.false, %entry
  %6 = phi i1 [ true, %lor.lhs.false7 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp12, %lor.rhs ]
  ret i1 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32 noundef %regno, %struct.bpf_reg_state* noundef %reg, i32 noundef %t) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %regno.addr = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %t.addr = alloca i32, align 4
  %code = alloca i8, align 1
  %class = alloca i8, align 1
  %op = alloca i8, align 1
  %mode = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code1, align 4
  store i8 %1, i8* %code, align 1
  %2 = load i8, i8* %code, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 7
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %class, align 1
  %3 = load i8, i8* %code, align 1
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 240
  %conv5 = trunc i32 %and4 to i8
  store i8 %conv5, i8* %op, align 1
  %4 = load i8, i8* %class, align 1
  %conv6 = zext i8 %4 to i32
  %cmp = icmp eq i32 %conv6, 5
  br i1 %cmp, label %if.then, label %if.end26

if.then:                                          ; preds = %entry
  %5 = load i8, i8* %op, align 1
  %conv8 = zext i8 %5 to i32
  %cmp9 = icmp eq i32 %conv8, 144
  br i1 %cmp9, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %if.then
  %6 = load i8, i8* %op, align 1
  %conv12 = zext i8 %6 to i32
  %cmp13 = icmp eq i32 %conv12, 128
  br i1 %cmp13, label %if.then15, label %if.end25

if.then15:                                        ; preds = %if.end
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv16 = zext i8 %bf.lshr to i32
  %cmp17 = icmp eq i32 %conv16, 1
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.then15
  store i1 false, i1* %retval, align 1
  br label %return

if.end20:                                         ; preds = %if.then15
  %8 = load i32, i32* %t.addr, align 4
  %cmp21 = icmp eq i32 %8, 0
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  store i1 true, i1* %retval, align 1
  br label %return

if.end24:                                         ; preds = %if.end20
  store i1 false, i1* %retval, align 1
  br label %return

if.end25:                                         ; preds = %if.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %entry
  %9 = load i8, i8* %class, align 1
  %conv27 = zext i8 %9 to i32
  %cmp28 = icmp eq i32 %conv27, 7
  br i1 %cmp28, label %if.then43, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end26
  %10 = load i8, i8* %class, align 1
  %conv30 = zext i8 %10 to i32
  %cmp31 = icmp eq i32 %conv30, 5
  br i1 %cmp31, label %if.then43, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %lor.lhs.false
  %11 = load i8, i8* %class, align 1
  %conv34 = zext i8 %11 to i32
  %cmp35 = icmp eq i32 %conv34, 4
  br i1 %cmp35, label %land.lhs.true, label %if.end44

land.lhs.true:                                    ; preds = %lor.lhs.false33
  %12 = load i8, i8* %op, align 1
  %conv37 = zext i8 %12 to i32
  %cmp38 = icmp eq i32 %conv37, 208
  br i1 %cmp38, label %land.lhs.true40, label %if.end44

land.lhs.true40:                                  ; preds = %land.lhs.true
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 3
  %14 = load i32, i32* %imm, align 4
  %cmp41 = icmp eq i32 %14, 64
  br i1 %cmp41, label %if.then43, label %if.end44

if.then43:                                        ; preds = %land.lhs.true40, %lor.lhs.false, %if.end26
  store i1 true, i1* %retval, align 1
  br label %return

if.end44:                                         ; preds = %land.lhs.true40, %land.lhs.true, %lor.lhs.false33
  %15 = load i8, i8* %class, align 1
  %conv45 = zext i8 %15 to i32
  %cmp46 = icmp eq i32 %conv45, 4
  br i1 %cmp46, label %if.then52, label %lor.lhs.false48

lor.lhs.false48:                                  ; preds = %if.end44
  %16 = load i8, i8* %class, align 1
  %conv49 = zext i8 %16 to i32
  %cmp50 = icmp eq i32 %conv49, 6
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %lor.lhs.false48, %if.end44
  store i1 false, i1* %retval, align 1
  br label %return

if.end53:                                         ; preds = %lor.lhs.false48
  %17 = load i8, i8* %class, align 1
  %conv54 = zext i8 %17 to i32
  %cmp55 = icmp eq i32 %conv54, 1
  br i1 %cmp55, label %if.then57, label %if.end66

if.then57:                                        ; preds = %if.end53
  %18 = load i32, i32* %t.addr, align 4
  %cmp58 = icmp ne i32 %18, 0
  br i1 %cmp58, label %if.then60, label %if.end65

if.then60:                                        ; preds = %if.then57
  %19 = load i8, i8* %code, align 1
  %conv61 = zext i8 %19 to i32
  %and62 = and i32 %conv61, 24
  %cmp63 = icmp eq i32 %and62, 24
  store i1 %cmp63, i1* %retval, align 1
  br label %return

if.end65:                                         ; preds = %if.then57
  store i1 true, i1* %retval, align 1
  br label %return

if.end66:                                         ; preds = %if.end53
  %20 = load i8, i8* %class, align 1
  %conv67 = zext i8 %20 to i32
  %cmp68 = icmp eq i32 %conv67, 3
  br i1 %cmp68, label %if.then70, label %if.end79

if.then70:                                        ; preds = %if.end66
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  %22 = load i32, i32* %type, align 8
  %cmp71 = icmp ne i32 %22, 1
  br i1 %cmp71, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.then70
  store i1 true, i1* %retval, align 1
  br label %return

if.end74:                                         ; preds = %if.then70
  %23 = load i8, i8* %code, align 1
  %conv75 = zext i8 %23 to i32
  %and76 = and i32 %conv75, 24
  %cmp77 = icmp eq i32 %and76, 24
  store i1 %cmp77, i1* %retval, align 1
  br label %return

if.end79:                                         ; preds = %if.end66
  %24 = load i8, i8* %class, align 1
  %conv80 = zext i8 %24 to i32
  %cmp81 = icmp eq i32 %conv80, 0
  br i1 %cmp81, label %if.then83, label %if.end100

if.then83:                                        ; preds = %if.end79
  %25 = load i8, i8* %code, align 1
  %conv84 = zext i8 %25 to i32
  %and85 = and i32 %conv84, 224
  %conv86 = trunc i32 %and85 to i8
  store i8 %conv86, i8* %mode, align 1
  %26 = load i8, i8* %mode, align 1
  %conv87 = zext i8 %26 to i32
  %cmp88 = icmp eq i32 %conv87, 0
  br i1 %cmp88, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.then83
  store i1 true, i1* %retval, align 1
  br label %return

if.end91:                                         ; preds = %if.then83
  %27 = load i32, i32* %t.addr, align 4
  %cmp92 = icmp ne i32 %27, 0
  br i1 %cmp92, label %if.then94, label %if.end95

if.then94:                                        ; preds = %if.end91
  store i1 false, i1* %retval, align 1
  br label %return

if.end95:                                         ; preds = %if.end91
  %28 = load i32, i32* %regno.addr, align 4
  %cmp96 = icmp eq i32 %28, 6
  br i1 %cmp96, label %if.then98, label %if.end99

if.then98:                                        ; preds = %if.end95
  store i1 true, i1* %retval, align 1
  br label %return

if.end99:                                         ; preds = %if.end95
  store i1 true, i1* %retval, align 1
  br label %return

if.end100:                                        ; preds = %if.end79
  %29 = load i8, i8* %class, align 1
  %conv101 = zext i8 %29 to i32
  %cmp102 = icmp eq i32 %conv101, 2
  br i1 %cmp102, label %if.then104, label %if.end105

if.then104:                                       ; preds = %if.end100
  store i1 true, i1* %retval, align 1
  br label %return

if.end105:                                        ; preds = %if.end100
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end105, %if.then104, %if.end99, %if.then98, %if.then94, %if.then90, %if.end74, %if.then73, %if.end65, %if.then60, %if.then52, %if.then43, %if.end24, %if.then23, %if.then19, %if.then11
  %30 = load i1, i1* %retval, align 1
  ret i1 %30
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @get_random_int() #0 {
entry:
  %call = call i32 @get_random_u32() #11
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_prog* @bpf_patch_insn_data(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, %struct.bpf_insn* noundef %patch, i32 noundef %len) #0 {
entry:
  %retval = alloca %struct.bpf_prog*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %patch.addr = alloca %struct.bpf_insn*, align 8
  %len.addr = alloca i32, align 4
  %new_prog = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store %struct.bpf_insn* %patch, %struct.bpf_insn** %patch.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %2 = load i32, i32* %off.addr, align 4
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %patch.addr, align 8
  %4 = load i32, i32* %len.addr, align 4
  %call = call %struct.bpf_prog* @bpf_patch_insn_single(%struct.bpf_prog* noundef %1, i32 noundef %2, %struct.bpf_insn* noundef %3, i32 noundef %4) #11
  store %struct.bpf_prog* %call, %struct.bpf_prog** %new_prog, align 8
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %6 = bitcast %struct.bpf_prog* %5 to i8*
  %call1 = call zeroext i1 @IS_ERR(i8* noundef %6) #11
  br i1 %call1, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %8 = bitcast %struct.bpf_prog* %7 to i8*
  %call2 = call i64 @PTR_ERR(i8* noundef %8) #11
  %cmp = icmp eq i64 %call2, -34
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 20
  %12 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %13 = load i32, i32* %off.addr, align 4
  %idxprom = zext i32 %13 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %12, i64 %idxprom
  %orig_idx = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 7
  %14 = load i32, i32* %orig_idx, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.379, i64 0, i64 0), i32 noundef %14) #11
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  store %struct.bpf_prog* null, %struct.bpf_prog** %retval, align 8
  br label %return

if.end4:                                          ; preds = %entry
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %17 = load i32, i32* %off.addr, align 4
  %18 = load i32, i32* %len.addr, align 4
  %call5 = call i32 @adjust_insn_aux_data(%struct.bpf_verifier_env* noundef %15, %struct.bpf_prog* noundef %16, i32 noundef %17, i32 noundef %18) #11
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  store %struct.bpf_prog* null, %struct.bpf_prog** %retval, align 8
  br label %return

if.end7:                                          ; preds = %if.end4
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load i32, i32* %off.addr, align 4
  %21 = load i32, i32* %len.addr, align 4
  call void @adjust_subprog_starts(%struct.bpf_verifier_env* noundef %19, i32 noundef %20, i32 noundef %21) #11
  %22 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  %23 = load i32, i32* %len.addr, align 4
  call void @adjust_poke_descs(%struct.bpf_prog* noundef %22, i32 noundef %23) #11
  %24 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog, align 8
  store %struct.bpf_prog* %24, %struct.bpf_prog** %retval, align 8
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.end
  %25 = load %struct.bpf_prog*, %struct.bpf_prog** %retval, align 8
  ret %struct.bpf_prog* %25
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_prog* @bpf_patch_insn_single(%struct.bpf_prog* noundef, i32 noundef, %struct.bpf_insn* noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_insn_aux_data(%struct.bpf_verifier_env* noundef %env, %struct.bpf_prog* noundef %new_prog, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %new_prog.addr = alloca %struct.bpf_prog*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %new_data = alloca %struct.bpf_insn_aux_data*, align 8
  %old_data = alloca %struct.bpf_insn_aux_data*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %prog_len = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_prog* %new_prog, %struct.bpf_prog** %new_prog.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 20
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %old_data, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog.addr, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %5 = load i32, i32* %off.addr, align 4
  %idx.ext = zext i32 %5 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %4, i64 %idx.ext
  %6 = load i32, i32* %cnt.addr, align 4
  %idx.ext1 = zext i32 %6 to i64
  %add.ptr2 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr, i64 %idx.ext1
  %add.ptr3 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %add.ptr2, i64 -1
  %call = call zeroext i1 @insn_has_def32(%struct.bpf_verifier_env* noundef %3, %struct.bpf_insn* noundef %add.ptr3) #11
  %7 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %8 = load i32, i32* %off.addr, align 4
  %idxprom = zext i32 %8 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %7, i64 %idxprom
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 5
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %zext_dst, align 4
  %9 = load i32, i32* %cnt.addr, align 4
  %cmp = icmp eq i32 %9, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %10 = load %struct.bpf_prog*, %struct.bpf_prog** %new_prog.addr, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %10, i32 0, i32 4
  %11 = load i32, i32* %len, align 4
  store i32 %11, i32* %prog_len, align 4
  %12 = load i32, i32* %prog_len, align 4
  %conv = zext i32 %12 to i64
  %call4 = call i64 @array_size(i64 noundef %conv, i64 noundef 40) #11
  %call5 = call i8* @vzalloc(i64 noundef %call4) #11
  %13 = bitcast i8* %call5 to %struct.bpf_insn_aux_data*
  store %struct.bpf_insn_aux_data* %13, %struct.bpf_insn_aux_data** %new_data, align 8
  %14 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %tobool = icmp ne %struct.bpf_insn_aux_data* %14, null
  br i1 %tobool, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %15 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %16 = bitcast %struct.bpf_insn_aux_data* %15 to i8*
  %17 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %18 = bitcast %struct.bpf_insn_aux_data* %17 to i8*
  %19 = load i32, i32* %off.addr, align 4
  %conv8 = zext i32 %19 to i64
  %mul = mul i64 40, %conv8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %16, i8* align 8 %18, i64 %mul, i1 false)
  %20 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %21 = load i32, i32* %off.addr, align 4
  %idx.ext9 = zext i32 %21 to i64
  %add.ptr10 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %20, i64 %idx.ext9
  %22 = load i32, i32* %cnt.addr, align 4
  %idx.ext11 = zext i32 %22 to i64
  %add.ptr12 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %add.ptr10, i64 %idx.ext11
  %add.ptr13 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %add.ptr12, i64 -1
  %23 = bitcast %struct.bpf_insn_aux_data* %add.ptr13 to i8*
  %24 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %25 = load i32, i32* %off.addr, align 4
  %idx.ext14 = zext i32 %25 to i64
  %add.ptr15 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %24, i64 %idx.ext14
  %26 = bitcast %struct.bpf_insn_aux_data* %add.ptr15 to i8*
  %27 = load i32, i32* %prog_len, align 4
  %28 = load i32, i32* %off.addr, align 4
  %sub = sub i32 %27, %28
  %29 = load i32, i32* %cnt.addr, align 4
  %sub16 = sub i32 %sub, %29
  %add = add i32 %sub16, 1
  %conv17 = zext i32 %add to i64
  %mul18 = mul i64 40, %conv17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %23, i8* align 8 %26, i64 %mul18, i1 false)
  %30 = load i32, i32* %off.addr, align 4
  store i32 %30, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %31 = load i32, i32* %i, align 4
  %32 = load i32, i32* %off.addr, align 4
  %33 = load i32, i32* %cnt.addr, align 4
  %add19 = add i32 %32, %33
  %sub20 = sub i32 %add19, 1
  %cmp21 = icmp ult i32 %31, %sub20
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %pass_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %34, i32 0, i32 25
  %35 = load i32, i32* %pass_cnt, align 8
  %36 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %37 = load i32, i32* %i, align 4
  %idxprom23 = sext i32 %37 to i64
  %arrayidx24 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %36, i64 %idxprom23
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx24, i32 0, i32 4
  store i32 %35, i32* %seen, align 8
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %40 = load i32, i32* %i, align 4
  %idx.ext25 = sext i32 %40 to i64
  %add.ptr26 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %39, i64 %idx.ext25
  %call27 = call zeroext i1 @insn_has_def32(%struct.bpf_verifier_env* noundef %38, %struct.bpf_insn* noundef %add.ptr26) #11
  %41 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %42 = load i32, i32* %i, align 4
  %idxprom28 = sext i32 %42 to i64
  %arrayidx29 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %41, i64 %idxprom28
  %zext_dst30 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx29, i32 0, i32 5
  %frombool31 = zext i1 %call27 to i8
  store i8 %frombool31, i8* %zext_dst30, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %43 = load i32, i32* %i, align 4
  %inc = add i32 %43, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %44 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %new_data, align 8
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data32 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %45, i32 0, i32 20
  store %struct.bpf_insn_aux_data* %44, %struct.bpf_insn_aux_data** %insn_aux_data32, align 8
  %46 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %old_data, align 8
  %47 = bitcast %struct.bpf_insn_aux_data* %46 to i8*
  call void @vfree(i8* noundef %47) #11
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then6, %if.then
  %48 = load i32, i32* %retval, align 4
  ret i32 %48
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_subprog_starts(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %len) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  %0 = load i32, i32* %len.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 26
  %3 = load i32, i32* %subprog_cnt, align 4
  %cmp1 = icmp ule i32 %1, %3
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 23
  %5 = load i32, i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %6 = load i32, i32* %start, align 8
  %7 = load i32, i32* %off.addr, align 4
  %cmp2 = icmp ule i32 %6, %7
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %for.body
  br label %for.inc

if.end4:                                          ; preds = %for.body
  %8 = load i32, i32* %len.addr, align 4
  %sub = sub i32 %8, 1
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info5 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 23
  %10 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %10 to i64
  %arrayidx7 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info5, i64 0, i64 %idxprom6
  %start8 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx7, i32 0, i32 0
  %11 = load i32, i32* %start8, align 8
  %add = add i32 %11, %sub
  store i32 %add, i32* %start8, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end4, %if.then3
  %12 = load i32, i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @adjust_poke_descs(%struct.bpf_prog* noundef %prog, i32 noundef %len) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %len.addr = alloca i32, align 4
  %tab = alloca %struct.bpf_jit_poke_descriptor*, align 8
  %i = alloca i32, align 4
  %sz = alloca i32, align 4
  %desc = alloca %struct.bpf_jit_poke_descriptor*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 7
  %1 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %1, i32 0, i32 31
  %2 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %poke_tab, align 8
  store %struct.bpf_jit_poke_descriptor* %2, %struct.bpf_jit_poke_descriptor** %tab, align 8
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 7
  %4 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1, align 8
  %size_poke_tab = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %4, i32 0, i32 32
  %5 = load i32, i32* %size_poke_tab, align 8
  store i32 %5, i32* %sz, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i32, i32* %i, align 4
  %7 = load i32, i32* %sz, align 4
  %cmp = icmp slt i32 %6, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %tab, align 8
  %9 = load i32, i32* %i, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %8, i64 %idxprom
  store %struct.bpf_jit_poke_descriptor* %arrayidx, %struct.bpf_jit_poke_descriptor** %desc, align 8
  %10 = load i32, i32* %len.addr, align 4
  %sub = sub i32 %10, 1
  %11 = load %struct.bpf_jit_poke_descriptor*, %struct.bpf_jit_poke_descriptor** %desc, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_jit_poke_descriptor, %struct.bpf_jit_poke_descriptor* %11, i32 0, i32 7
  %12 = load i32, i32* %insn_idx, align 4
  %add = add i32 %12, %sub
  store i32 %add, i32* %insn_idx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32, i32* %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @insn_has_def32(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call = call zeroext i1 @insn_no_def(%struct.bpf_insn* noundef %0) #11
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %3 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %3, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv = zext i8 %bf.clear to i32
  %call1 = call zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %1, %struct.bpf_insn* noundef %2, i32 noundef %conv, %struct.bpf_reg_state* noundef null, i32 noundef 1) #11
  %lnot = xor i1 %call1, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i1, i1* %retval, align 1
  ret i1 %4
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @get_random_u32() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_jit_blinding_enabled(%struct.bpf_prog* noundef %prog) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  ret i1 false
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_user_rnd_init_once() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @allow_tail_call_in_subprogs(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %jit_requested = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 1
  %bf.load = load i16, i16* %jit_requested, align 2
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 1
  %conv = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ true, %land.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_key_poisoned(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %map_key_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 1
  %1 = load i64, i64* %map_key_state, align 8
  %and = and i64 %1, -9223372036854775808
  %tobool = icmp ne i64 %and, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_ptr_poisoned(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 0
  %map_ptr_state = bitcast %struct.atomic64_t* %1 to i64*
  %2 = load i64, i64* %map_ptr_state, align 8
  %and = and i64 %2, -2
  %3 = inttoptr i64 %and to %struct.bpf_map*
  %cmp = icmp eq %struct.bpf_map* %3, inttoptr (i64 -2401263026318485698 to %struct.bpf_map*)
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 0
  %map_ptr_state = bitcast %struct.atomic64_t* %1 to i64*
  %2 = load i64, i64* %map_ptr_state, align 8
  %and = and i64 %2, 1
  %tobool = icmp ne i64 %and, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @bpf_map_key_immediate(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %map_key_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 1
  %1 = load i64, i64* %map_key_state, align 8
  %and = and i64 %1, 4611686018427387903
  ret i64 %and
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @func_id_name(i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_sock_convert_ctx_access(i32 noundef, %struct.bpf_insn* noundef, %struct.bpf_insn* noundef, %struct.bpf_prog* noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_tcp_sock_convert_ctx_access(i32 noundef, %struct.bpf_insn* noundef, %struct.bpf_insn* noundef, %struct.bpf_prog* noundef, i32* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_xdp_sock_convert_ctx_access(i32 noundef, %struct.bpf_insn* noundef, %struct.bpf_insn* noundef, %struct.bpf_prog* noundef, i32* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @resolve_prog_type(%struct.bpf_prog* noundef %prog) #0 {
entry:
  %prog.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %0, i32 0, i32 7
  %1 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %dst_prog = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %1, i32 0, i32 15
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %dst_prog, align 8
  %tobool = icmp ne %struct.bpf_prog* %2, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux1 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 7
  %4 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux1, align 8
  %dst_prog2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %4, i32 0, i32 15
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %dst_prog2, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 2
  %6 = load i32, i32* %type, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %type3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 2
  %8 = load i32, i32* %type3, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %6, %cond.true ], [ %8, %cond.false ]
  ret i32 %cond
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_ctx_off_adjust_machine(i32 noundef %size) #0 {
entry:
  %size.addr = alloca i32, align 4
  %size_machine = alloca i32, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 8, i32* %size_machine, align 4
  %0 = load i32, i32* %size.addr, align 4
  %cmp = icmp ugt i32 %0, 8
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %rem = urem i32 %1, 8
  %cmp1 = icmp eq i32 %rem, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 8, i32* %size.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %2 = load i32, i32* %size.addr, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i8 @bpf_ctx_narrow_access_offset(i32 noundef %off, i32 noundef %size, i32 noundef %size_default) #0 {
entry:
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %size_default.addr = alloca i32, align 4
  %access_off = alloca i8, align 1
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %size_default, i32* %size_default.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %1 = load i32, i32* %size_default.addr, align 4
  %sub = sub i32 %1, 1
  %and = and i32 %0, %sub
  %conv = trunc i32 %and to i8
  store i8 %conv, i8* %access_off, align 1
  %2 = load i8, i8* %access_off, align 1
  ret i8 %2
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @memcmp(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @verifier_remove_insns(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %aux_data = alloca %struct.bpf_insn_aux_data*, align 8
  %orig_prog_len = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 20
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  store %struct.bpf_insn_aux_data* %1, %struct.bpf_insn_aux_data** %aux_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 4
  %4 = load i32, i32* %len, align 4
  store i32 %4, i32* %orig_prog_len, align 4
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 2
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 7
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %7) #11
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load i32, i32* %off.addr, align 4
  %10 = load i32, i32* %cnt.addr, align 4
  call void @bpf_prog_offload_remove_insns(%struct.bpf_verifier_env* noundef %8, i32 noundef %9, i32 noundef %10) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 2
  %12 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %cnt.addr, align 4
  %call3 = call i32 @bpf_remove_insns(%struct.bpf_prog* noundef %12, i32 noundef %13, i32 noundef %14) #11
  store i32 %call3, i32* %err, align 4
  %15 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %15, 0
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %16 = load i32, i32* %err, align 4
  store i32 %16, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %off.addr, align 4
  %19 = load i32, i32* %cnt.addr, align 4
  %call6 = call i32 @adjust_subprog_starts_after_remove(%struct.bpf_verifier_env* noundef %17, i32 noundef %18, i32 noundef %19) #11
  store i32 %call6, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool7 = icmp ne i32 %20, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %21 = load i32, i32* %err, align 4
  store i32 %21, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end5
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load i32, i32* %off.addr, align 4
  %24 = load i32, i32* %cnt.addr, align 4
  %call10 = call i32 @bpf_adj_linfo_after_remove(%struct.bpf_verifier_env* noundef %22, i32 noundef %23, i32 noundef %24) #11
  store i32 %call10, i32* %err, align 4
  %25 = load i32, i32* %err, align 4
  %tobool11 = icmp ne i32 %25, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  %26 = load i32, i32* %err, align 4
  store i32 %26, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end9
  %27 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %28 = load i32, i32* %off.addr, align 4
  %idx.ext = zext i32 %28 to i64
  %add.ptr = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %27, i64 %idx.ext
  %29 = bitcast %struct.bpf_insn_aux_data* %add.ptr to i8*
  %30 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux_data, align 8
  %31 = load i32, i32* %off.addr, align 4
  %idx.ext14 = zext i32 %31 to i64
  %add.ptr15 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %30, i64 %idx.ext14
  %32 = load i32, i32* %cnt.addr, align 4
  %idx.ext16 = zext i32 %32 to i64
  %add.ptr17 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %add.ptr15, i64 %idx.ext16
  %33 = bitcast %struct.bpf_insn_aux_data* %add.ptr17 to i8*
  %34 = load i32, i32* %orig_prog_len, align 4
  %35 = load i32, i32* %off.addr, align 4
  %sub = sub i32 %34, %35
  %36 = load i32, i32* %cnt.addr, align 4
  %sub18 = sub i32 %sub, %36
  %conv = zext i32 %sub18 to i64
  %mul = mul i64 40, %conv
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 8 %29, i8* align 8 %33, i64 %mul, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then12, %if.then8, %if.then4
  %37 = load i32, i32* %retval, align 4
  ret i32 %37
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_offload_remove_insns(%struct.bpf_verifier_env* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_remove_insns(%struct.bpf_prog* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_subprog_starts_after_remove(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %aux = alloca %struct.bpf_prog_aux*, align 8
  %move = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 26
  %2 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 23
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  %5 = load i32, i32* %start, align 8
  %6 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp uge i32 %5, %6
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %8 = load i32, i32* %i, align 4
  store i32 %8, i32* %j, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc13, %for.end
  %9 = load i32, i32* %j, align 4
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 26
  %11 = load i32, i32* %subprog_cnt3, align 4
  %cmp4 = icmp ult i32 %9, %11
  br i1 %cmp4, label %for.body5, label %for.end15

for.body5:                                        ; preds = %for.cond2
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info6 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 23
  %13 = load i32, i32* %j, align 4
  %idxprom7 = sext i32 %13 to i64
  %arrayidx8 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info6, i64 0, i64 %idxprom7
  %start9 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx8, i32 0, i32 0
  %14 = load i32, i32* %start9, align 8
  %15 = load i32, i32* %off.addr, align 4
  %16 = load i32, i32* %cnt.addr, align 4
  %add = add i32 %15, %16
  %cmp10 = icmp uge i32 %14, %add
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body5
  br label %for.end15

if.end12:                                         ; preds = %for.body5
  br label %for.inc13

for.inc13:                                        ; preds = %if.end12
  %17 = load i32, i32* %j, align 4
  %inc14 = add i32 %17, 1
  store i32 %inc14, i32* %j, align 4
  br label %for.cond2

for.end15:                                        ; preds = %if.then11, %for.cond2
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 23
  %19 = load i32, i32* %j, align 4
  %idxprom17 = sext i32 %19 to i64
  %arrayidx18 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info16, i64 0, i64 %idxprom17
  %start19 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx18, i32 0, i32 0
  %20 = load i32, i32* %start19, align 8
  %21 = load i32, i32* %off.addr, align 4
  %22 = load i32, i32* %cnt.addr, align 4
  %add20 = add i32 %21, %22
  %cmp21 = icmp ne i32 %20, %add20
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %for.end15
  %23 = load i32, i32* %j, align 4
  %dec = add i32 %23, -1
  store i32 %dec, i32* %j, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %for.end15
  %24 = load i32, i32* %j, align 4
  %25 = load i32, i32* %i, align 4
  %cmp24 = icmp sgt i32 %24, %25
  br i1 %cmp24, label %if.then25, label %if.else

if.then25:                                        ; preds = %if.end23
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 2
  %27 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux26 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %27, i32 0, i32 7
  %28 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux26, align 8
  store %struct.bpf_prog_aux* %28, %struct.bpf_prog_aux** %aux, align 8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 26
  %30 = load i32, i32* %subprog_cnt27, align 4
  %add28 = add i32 %30, 1
  %31 = load i32, i32* %j, align 4
  %sub = sub i32 %add28, %31
  store i32 %sub, i32* %move, align 4
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %32, i32 0, i32 23
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info29, i64 0, i64 0
  %33 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %33 to i64
  %add.ptr = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arraydecay, i64 %idx.ext
  %34 = bitcast %struct.bpf_subprog_info* %add.ptr to i8*
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 23
  %arraydecay31 = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info30, i64 0, i64 0
  %36 = load i32, i32* %j, align 4
  %idx.ext32 = sext i32 %36 to i64
  %add.ptr33 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arraydecay31, i64 %idx.ext32
  %37 = bitcast %struct.bpf_subprog_info* %add.ptr33 to i8*
  %38 = load i32, i32* %move, align 4
  %conv = sext i32 %38 to i64
  %mul = mul i64 16, %conv
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %34, i8* align 4 %37, i64 %mul, i1 false)
  %39 = load i32, i32* %j, align 4
  %40 = load i32, i32* %i, align 4
  %sub34 = sub i32 %39, %40
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt35 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %41, i32 0, i32 26
  %42 = load i32, i32* %subprog_cnt35, align 4
  %sub36 = sub i32 %42, %sub34
  store i32 %sub36, i32* %subprog_cnt35, align 4
  %43 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %43, i32 0, i32 45
  %44 = load %struct.util_est*, %struct.util_est** %func_info, align 8
  %tobool = icmp ne %struct.util_est* %44, null
  br i1 %tobool, label %if.then37, label %if.end50

if.then37:                                        ; preds = %if.then25
  %45 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_cnt = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %45, i32 0, i32 49
  %46 = load i32, i32* %func_info_cnt, align 8
  %47 = load i32, i32* %j, align 4
  %sub38 = sub i32 %46, %47
  store i32 %sub38, i32* %move, align 4
  %48 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info39 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %48, i32 0, i32 45
  %49 = load %struct.util_est*, %struct.util_est** %func_info39, align 8
  %50 = load i32, i32* %i, align 4
  %idx.ext40 = sext i32 %50 to i64
  %add.ptr41 = getelementptr %struct.util_est, %struct.util_est* %49, i64 %idx.ext40
  %51 = bitcast %struct.util_est* %add.ptr41 to i8*
  %52 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info42 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %52, i32 0, i32 45
  %53 = load %struct.util_est*, %struct.util_est** %func_info42, align 8
  %54 = load i32, i32* %j, align 4
  %idx.ext43 = sext i32 %54 to i64
  %add.ptr44 = getelementptr %struct.util_est, %struct.util_est* %53, i64 %idx.ext43
  %55 = bitcast %struct.util_est* %add.ptr44 to i8*
  %56 = load i32, i32* %move, align 4
  %conv45 = sext i32 %56 to i64
  %mul46 = mul i64 8, %conv45
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %51, i8* align 4 %55, i64 %mul46, i1 false)
  %57 = load i32, i32* %j, align 4
  %58 = load i32, i32* %i, align 4
  %sub47 = sub i32 %57, %58
  %59 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_cnt48 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %59, i32 0, i32 49
  %60 = load i32, i32* %func_info_cnt48, align 8
  %sub49 = sub i32 %60, %sub47
  store i32 %sub49, i32* %func_info_cnt48, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then37, %if.then25
  br label %if.end60

if.else:                                          ; preds = %if.end23
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info51 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %61, i32 0, i32 23
  %62 = load i32, i32* %i, align 4
  %idxprom52 = sext i32 %62 to i64
  %arrayidx53 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info51, i64 0, i64 %idxprom52
  %start54 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx53, i32 0, i32 0
  %63 = load i32, i32* %start54, align 8
  %64 = load i32, i32* %off.addr, align 4
  %cmp55 = icmp eq i32 %63, %64
  br i1 %cmp55, label %if.then57, label %if.end59

if.then57:                                        ; preds = %if.else
  %65 = load i32, i32* %i, align 4
  %inc58 = add i32 %65, 1
  store i32 %inc58, i32* %i, align 4
  br label %if.end59

if.end59:                                         ; preds = %if.then57, %if.else
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.end50
  br label %for.cond61

for.cond61:                                       ; preds = %for.inc71, %if.end60
  %66 = load i32, i32* %i, align 4
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt62 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %67, i32 0, i32 26
  %68 = load i32, i32* %subprog_cnt62, align 4
  %cmp63 = icmp ule i32 %66, %68
  br i1 %cmp63, label %for.body65, label %for.end73

for.body65:                                       ; preds = %for.cond61
  %69 = load i32, i32* %cnt.addr, align 4
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info66 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %70, i32 0, i32 23
  %71 = load i32, i32* %i, align 4
  %idxprom67 = sext i32 %71 to i64
  %arrayidx68 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info66, i64 0, i64 %idxprom67
  %start69 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx68, i32 0, i32 0
  %72 = load i32, i32* %start69, align 8
  %sub70 = sub i32 %72, %69
  store i32 %sub70, i32* %start69, align 8
  br label %for.inc71

for.inc71:                                        ; preds = %for.body65
  %73 = load i32, i32* %i, align 4
  %inc72 = add i32 %73, 1
  store i32 %inc72, i32* %i, align 4
  br label %for.cond61

for.end73:                                        ; preds = %for.cond61
  ret i32 0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_adj_linfo_after_remove(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %cnt) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %cnt.addr = alloca i32, align 4
  %prog = alloca %struct.bpf_prog*, align 8
  %i = alloca i32, align 4
  %l_off = alloca i32, align 4
  %l_cnt = alloca i32, align 4
  %nr_linfo = alloca i32, align 4
  %linfo = alloca %struct.ethtool_pauseparam*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 7
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %nr_linfo2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 50
  %4 = load i32, i32* %nr_linfo2, align 4
  store i32 %4, i32* %nr_linfo, align 4
  %5 = load i32, i32* %nr_linfo, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %6, i32 0, i32 7
  %7 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %linfo4 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %7, i32 0, i32 47
  %8 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo4, align 8
  store %struct.ethtool_pauseparam* %8, %struct.ethtool_pauseparam** %linfo, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, i32* %i, align 4
  %10 = load i32, i32* %nr_linfo, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom = zext i32 %12 to i64
  %arrayidx = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %11, i64 %idxprom
  %insn_off = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx, i32 0, i32 0
  %13 = load i32, i32* %insn_off, align 4
  %14 = load i32, i32* %off.addr, align 4
  %cmp5 = icmp uge i32 %13, %14
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  br label %for.end

if.end7:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %15 = load i32, i32* %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then6, %for.cond
  %16 = load i32, i32* %i, align 4
  store i32 %16, i32* %l_off, align 4
  store i32 0, i32* %l_cnt, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc18, %for.end
  %17 = load i32, i32* %i, align 4
  %18 = load i32, i32* %nr_linfo, align 4
  %cmp9 = icmp ult i32 %17, %18
  br i1 %cmp9, label %for.body10, label %for.end20

for.body10:                                       ; preds = %for.cond8
  %19 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %20 = load i32, i32* %i, align 4
  %idxprom11 = zext i32 %20 to i64
  %arrayidx12 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %19, i64 %idxprom11
  %insn_off13 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx12, i32 0, i32 0
  %21 = load i32, i32* %insn_off13, align 4
  %22 = load i32, i32* %off.addr, align 4
  %23 = load i32, i32* %cnt.addr, align 4
  %add = add i32 %22, %23
  %cmp14 = icmp ult i32 %21, %add
  br i1 %cmp14, label %if.then15, label %if.else

if.then15:                                        ; preds = %for.body10
  %24 = load i32, i32* %l_cnt, align 4
  %inc16 = add i32 %24, 1
  store i32 %inc16, i32* %l_cnt, align 4
  br label %if.end17

if.else:                                          ; preds = %for.body10
  br label %for.end20

if.end17:                                         ; preds = %if.then15
  br label %for.inc18

for.inc18:                                        ; preds = %if.end17
  %25 = load i32, i32* %i, align 4
  %inc19 = add i32 %25, 1
  store i32 %inc19, i32* %i, align 4
  br label %for.cond8

for.end20:                                        ; preds = %if.else, %for.cond8
  %26 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %26, i32 0, i32 4
  %27 = load i32, i32* %len, align 4
  %28 = load i32, i32* %off.addr, align 4
  %cmp21 = icmp ne i32 %27, %28
  br i1 %cmp21, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %for.end20
  %29 = load i32, i32* %l_cnt, align 4
  %tobool22 = icmp ne i32 %29, 0
  br i1 %tobool22, label %land.lhs.true23, label %if.end36

land.lhs.true23:                                  ; preds = %land.lhs.true
  %30 = load i32, i32* %i, align 4
  %31 = load i32, i32* %nr_linfo, align 4
  %cmp24 = icmp eq i32 %30, %31
  br i1 %cmp24, label %if.then30, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true23
  %32 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %33 = load i32, i32* %i, align 4
  %idxprom25 = zext i32 %33 to i64
  %arrayidx26 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %32, i64 %idxprom25
  %insn_off27 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx26, i32 0, i32 0
  %34 = load i32, i32* %insn_off27, align 4
  %35 = load i32, i32* %off.addr, align 4
  %36 = load i32, i32* %cnt.addr, align 4
  %add28 = add i32 %35, %36
  %cmp29 = icmp ne i32 %34, %add28
  br i1 %cmp29, label %if.then30, label %if.end36

if.then30:                                        ; preds = %lor.lhs.false, %land.lhs.true23
  %37 = load i32, i32* %l_cnt, align 4
  %dec = add i32 %37, -1
  store i32 %dec, i32* %l_cnt, align 4
  %38 = load i32, i32* %off.addr, align 4
  %39 = load i32, i32* %cnt.addr, align 4
  %add31 = add i32 %38, %39
  %40 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %41 = load i32, i32* %i, align 4
  %dec32 = add i32 %41, -1
  store i32 %dec32, i32* %i, align 4
  %idxprom33 = zext i32 %dec32 to i64
  %arrayidx34 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %40, i64 %idxprom33
  %insn_off35 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx34, i32 0, i32 0
  store i32 %add31, i32* %insn_off35, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then30, %lor.lhs.false, %land.lhs.true, %for.end20
  %42 = load i32, i32* %l_cnt, align 4
  %tobool37 = icmp ne i32 %42, 0
  br i1 %tobool37, label %if.then38, label %if.end46

if.then38:                                        ; preds = %if.end36
  %43 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %44 = load i32, i32* %l_off, align 4
  %idx.ext = zext i32 %44 to i64
  %add.ptr = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %43, i64 %idx.ext
  %45 = bitcast %struct.ethtool_pauseparam* %add.ptr to i8*
  %46 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %47 = load i32, i32* %i, align 4
  %idx.ext39 = zext i32 %47 to i64
  %add.ptr40 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %46, i64 %idx.ext39
  %48 = bitcast %struct.ethtool_pauseparam* %add.ptr40 to i8*
  %49 = load i32, i32* %nr_linfo, align 4
  %50 = load i32, i32* %i, align 4
  %sub = sub i32 %49, %50
  %conv = zext i32 %sub to i64
  %mul = mul i64 16, %conv
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %45, i8* align 4 %48, i64 %mul, i1 false)
  %51 = load i32, i32* %l_cnt, align 4
  %52 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux41 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %52, i32 0, i32 7
  %53 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux41, align 8
  %nr_linfo42 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %53, i32 0, i32 50
  %54 = load i32, i32* %nr_linfo42, align 4
  %sub43 = sub i32 %54, %51
  store i32 %sub43, i32* %nr_linfo42, align 4
  %55 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux44 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %55, i32 0, i32 7
  %56 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux44, align 8
  %nr_linfo45 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %56, i32 0, i32 50
  %57 = load i32, i32* %nr_linfo45, align 4
  store i32 %57, i32* %nr_linfo, align 4
  br label %if.end46

if.end46:                                         ; preds = %if.then38, %if.end36
  %58 = load i32, i32* %l_off, align 4
  store i32 %58, i32* %i, align 4
  br label %for.cond47

for.cond47:                                       ; preds = %for.inc55, %if.end46
  %59 = load i32, i32* %i, align 4
  %60 = load i32, i32* %nr_linfo, align 4
  %cmp48 = icmp ult i32 %59, %60
  br i1 %cmp48, label %for.body50, label %for.end57

for.body50:                                       ; preds = %for.cond47
  %61 = load i32, i32* %cnt.addr, align 4
  %62 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %63 = load i32, i32* %i, align 4
  %idxprom51 = zext i32 %63 to i64
  %arrayidx52 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %62, i64 %idxprom51
  %insn_off53 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx52, i32 0, i32 0
  %64 = load i32, i32* %insn_off53, align 4
  %sub54 = sub i32 %64, %61
  store i32 %sub54, i32* %insn_off53, align 4
  br label %for.inc55

for.inc55:                                        ; preds = %for.body50
  %65 = load i32, i32* %i, align 4
  %inc56 = add i32 %65, 1
  store i32 %inc56, i32* %i, align 4
  br label %for.cond47

for.end57:                                        ; preds = %for.cond47
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc87, %for.end57
  %66 = load i32, i32* %i, align 4
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %67, i32 0, i32 26
  %68 = load i32, i32* %subprog_cnt, align 4
  %cmp59 = icmp ule i32 %66, %68
  br i1 %cmp59, label %for.body61, label %for.end89

for.body61:                                       ; preds = %for.cond58
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %69, i32 0, i32 23
  %70 = load i32, i32* %i, align 4
  %idxprom62 = zext i32 %70 to i64
  %arrayidx63 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom62
  %linfo_idx = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx63, i32 0, i32 1
  %71 = load i32, i32* %linfo_idx, align 4
  %72 = load i32, i32* %l_off, align 4
  %cmp64 = icmp ugt i32 %71, %72
  br i1 %cmp64, label %if.then66, label %if.end86

if.then66:                                        ; preds = %for.body61
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info67 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %73, i32 0, i32 23
  %74 = load i32, i32* %i, align 4
  %idxprom68 = zext i32 %74 to i64
  %arrayidx69 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info67, i64 0, i64 %idxprom68
  %linfo_idx70 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx69, i32 0, i32 1
  %75 = load i32, i32* %linfo_idx70, align 4
  %76 = load i32, i32* %l_off, align 4
  %77 = load i32, i32* %l_cnt, align 4
  %add71 = add i32 %76, %77
  %cmp72 = icmp uge i32 %75, %add71
  br i1 %cmp72, label %if.then74, label %if.else80

if.then74:                                        ; preds = %if.then66
  %78 = load i32, i32* %l_cnt, align 4
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info75 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %79, i32 0, i32 23
  %80 = load i32, i32* %i, align 4
  %idxprom76 = zext i32 %80 to i64
  %arrayidx77 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info75, i64 0, i64 %idxprom76
  %linfo_idx78 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx77, i32 0, i32 1
  %81 = load i32, i32* %linfo_idx78, align 4
  %sub79 = sub i32 %81, %78
  store i32 %sub79, i32* %linfo_idx78, align 4
  br label %if.end85

if.else80:                                        ; preds = %if.then66
  %82 = load i32, i32* %l_off, align 4
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info81 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %83, i32 0, i32 23
  %84 = load i32, i32* %i, align 4
  %idxprom82 = zext i32 %84 to i64
  %arrayidx83 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info81, i64 0, i64 %idxprom82
  %linfo_idx84 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx83, i32 0, i32 1
  store i32 %82, i32* %linfo_idx84, align 4
  br label %if.end85

if.end85:                                         ; preds = %if.else80, %if.then74
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %for.body61
  br label %for.inc87

for.inc87:                                        ; preds = %if.end86
  %85 = load i32, i32* %i, align 4
  %inc88 = add i32 %85, 1
  store i32 %inc88, i32* %i, align 4
  br label %for.cond58

for.end89:                                        ; preds = %for.cond58
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end89, %if.then
  %86 = load i32, i32* %retval, align 4
  ret i32 %86
}

; Function Attrs: argmemonly nofree nounwind willreturn
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1 immarg) #2

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @insn_is_cond_jump(i8 noundef zeroext %code) #0 {
entry:
  %retval = alloca i1, align 1
  %code.addr = alloca i8, align 1
  %op = alloca i8, align 1
  store i8 %code, i8* %code.addr, align 1
  %0 = load i8, i8* %code.addr, align 1
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 7
  %cmp = icmp eq i32 %and, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8, i8* %code.addr, align 1
  %conv2 = zext i8 %1 to i32
  %and3 = and i32 %conv2, 7
  %cmp4 = icmp ne i32 %and3, 5
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i1 false, i1* %retval, align 1
  br label %return

if.end7:                                          ; preds = %if.end
  %2 = load i8, i8* %code.addr, align 1
  %conv8 = zext i8 %2 to i32
  %and9 = and i32 %conv8, 240
  %conv10 = trunc i32 %and9 to i8
  store i8 %conv10, i8* %op, align 1
  %3 = load i8, i8* %op, align 1
  %conv11 = zext i8 %3 to i32
  %cmp12 = icmp ne i32 %conv11, 0
  br i1 %cmp12, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.end7
  %4 = load i8, i8* %op, align 1
  %conv14 = zext i8 %4 to i32
  %cmp15 = icmp ne i32 %conv14, 144
  br i1 %cmp15, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %5 = load i8, i8* %op, align 1
  %conv17 = zext i8 %5 to i32
  %cmp18 = icmp ne i32 %conv17, 128
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %if.end7
  %6 = phi i1 [ false, %land.lhs.true ], [ false, %if.end7 ], [ %cmp18, %land.rhs ]
  store i1 %6, i1* %retval, align 1
  br label %return

return:                                           ; preds = %land.end, %if.then6, %if.then
  %7 = load i1, i1* %retval, align 1
  ret i1 %7
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_prog_offload_replace_insn(%struct.bpf_verifier_env* noundef, i32 noundef, %struct.bpf_insn* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check_common(%struct.bpf_verifier_env* noundef %env, i32 noundef %subprog) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %subprog.addr = alloca i32, align 4
  %pop_log = alloca i8, align 1
  %state = alloca %struct.bpf_verifier_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %ret = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %subprog, i32* %subprog.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 22
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %1 = load i32, i32* %level, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %pop_log, align 1
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_linfo = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 21
  store %struct.ethtool_pauseparam* null, %struct.ethtool_pauseparam** %prev_linfo, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %pass_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 25
  %4 = load i32, i32* %pass_cnt, align 8
  %inc = add i32 %4, 1
  store i32 %inc, i32* %pass_cnt, align 8
  %call = call i8* @kzalloc(i64 noundef 120, i32 noundef 3264) #11
  %5 = bitcast i8* %call to %struct.bpf_verifier_state*
  store %struct.bpf_verifier_state* %5, %struct.bpf_verifier_state** %state, align 8
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %tobool1 = icmp ne %struct.bpf_verifier_state* %6, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 4
  store i32 0, i32* %curframe, align 8
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 6
  store i8 0, i8* %speculative, align 8
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %9, i32 0, i32 2
  store i32 1, i32* %branches, align 8
  %call2 = call i8* @kzalloc(i64 noundef 1360, i32 noundef 3264) #11
  %10 = bitcast i8* %call2 to %struct.bpf_func_state*
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 0
  store %struct.bpf_func_state* %10, %struct.bpf_func_state** %arrayidx, align 8
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 0
  %arrayidx4 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame3, i64 0, i64 0
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx4, align 8
  %tobool5 = icmp ne %struct.bpf_func_state* %13, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %15 = bitcast %struct.bpf_verifier_state* %14 to i8*
  call void @kfree(i8* noundef %15) #11
  store i32 -12, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %16 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 8
  store %struct.bpf_verifier_state* %16, %struct.bpf_verifier_state** %cur_state, align 8
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 0
  %arrayidx9 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame8, i64 0, i64 0
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx9, align 8
  %21 = load i32, i32* %subprog.addr, align 4
  call void @init_func_state(%struct.bpf_verifier_env* noundef %18, %struct.bpf_func_state* noundef %20, i32 noundef -1, i32 noundef 0, i32 noundef %21) #11
  %22 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %22, i32 0, i32 0
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe11 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 4
  %24 = load i32, i32* %curframe11, align 8
  %idxprom = zext i32 %24 to i64
  %arrayidx12 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame10, i64 0, i64 %idxprom
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx12, align 8
  %regs13 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs13, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %26 = load i32, i32* %subprog.addr, align 4
  %tobool14 = icmp ne i32 %26, 0
  br i1 %tobool14, label %if.then15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 2
  %28 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %28, i32 0, i32 2
  %29 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %29, 28
  br i1 %cmp, label %if.then15, label %if.else34

if.then15:                                        ; preds = %lor.lhs.false, %if.end7
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load i32, i32* %subprog.addr, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %call16 = call i32 @btf_prepare_func_args(%struct.bpf_verifier_env* noundef %30, i32 noundef %31, %struct.bpf_reg_state* noundef %32) #11
  store i32 %call16, i32* %ret, align 4
  %33 = load i32, i32* %ret, align 4
  %tobool17 = icmp ne i32 %33, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then15
  br label %out

if.end19:                                         ; preds = %if.then15
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %34 = load i32, i32* %i, align 4
  %cmp20 = icmp sle i32 %34, 5
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %36 = load i32, i32* %i, align 4
  %idxprom21 = sext i32 %36 to i64
  %arrayidx22 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i64 %idxprom21
  %type23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx22, i32 0, i32 0
  %37 = load i32, i32* %type23, align 8
  %cmp24 = icmp eq i32 %37, 2
  br i1 %cmp24, label %if.then25, label %if.else

if.then25:                                        ; preds = %for.body
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %40 = load i32, i32* %i, align 4
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %38, %struct.bpf_reg_state* noundef %39, i32 noundef %40) #11
  br label %if.end32

if.else:                                          ; preds = %for.body
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %42 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %42 to i64
  %arrayidx27 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i64 %idxprom26
  %type28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx27, i32 0, i32 0
  %43 = load i32, i32* %type28, align 8
  %cmp29 = icmp eq i32 %43, 1
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.else
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %46 = load i32, i32* %i, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %44, %struct.bpf_reg_state* noundef %45, i32 noundef %46) #11
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %if.else
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then25
  br label %for.inc

for.inc:                                          ; preds = %if.end32
  %47 = load i32, i32* %i, align 4
  %inc33 = add i32 %47, 1
  store i32 %inc33, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end41

if.else34:                                        ; preds = %lor.lhs.false
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx35 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i64 1
  %type36 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx35, i32 0, i32 0
  store i32 2, i32* %type36, align 8
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %49, %struct.bpf_reg_state* noundef %50, i32 noundef 1) #11
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = load i32, i32* %subprog.addr, align 4
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %call37 = call i32 @btf_check_func_arg_match(%struct.bpf_verifier_env* noundef %51, i32 noundef %52, %struct.bpf_reg_state* noundef %53) #11
  store i32 %call37, i32* %ret, align 4
  %54 = load i32, i32* %ret, align 4
  %cmp38 = icmp eq i32 %54, -14
  br i1 %cmp38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.else34
  br label %out

if.end40:                                         ; preds = %if.else34
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %for.end
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call42 = call i32 @do_check(%struct.bpf_verifier_env* noundef %55) #11
  store i32 %call42, i32* %ret, align 4
  br label %out

out:                                              ; preds = %if.end41, %if.then39, %if.then18
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state43 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %56, i32 0, i32 8
  %57 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state43, align 8
  %tobool44 = icmp ne %struct.bpf_verifier_state* %57, null
  br i1 %tobool44, label %if.then45, label %if.end48

if.then45:                                        ; preds = %out
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state46 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %58, i32 0, i32 8
  %59 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state46, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %59, i1 noundef zeroext true) #11
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state47 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %60, i32 0, i32 8
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %cur_state47, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.then45, %out
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end48
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call49 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %61, i32* noundef null, i32* noundef null, i1 noundef zeroext false) #11
  %tobool50 = icmp ne i32 %call49, 0
  %lnot51 = xor i1 %tobool50, true
  br i1 %lnot51, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %62 = load i32, i32* %ret, align 4
  %tobool52 = icmp ne i32 %62, 0
  br i1 %tobool52, label %if.end56, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.end
  %63 = load i8, i8* %pop_log, align 1
  %tobool53 = trunc i8 %63 to i1
  br i1 %tobool53, label %if.then54, label %if.end56

if.then54:                                        ; preds = %land.lhs.true
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log55 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %64, i32 0, i32 22
  call void @bpf_vlog_reset(%struct.bpf_verifier_log* noundef %log55, i32 noundef 0) #11
  br label %if.end56

if.end56:                                         ; preds = %if.then54, %land.lhs.true, %while.end
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @free_states(%struct.bpf_verifier_env* noundef %65) #11
  %66 = load i32, i32* %ret, align 4
  %tobool57 = icmp ne i32 %66, 0
  br i1 %tobool57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %if.end56
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @sanitize_insn_aux_data(%struct.bpf_verifier_env* noundef %67) #11
  br label %if.end59

if.end59:                                         ; preds = %if.then58, %if.end56
  %68 = load i32, i32* %ret, align 4
  store i32 %68, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end59, %if.then6, %if.then
  %69 = load i32, i32* %retval, align 4
  ret i32 %69
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @init_func_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %callsite, i32 noundef %frameno, i32 noundef %subprogno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %callsite.addr = alloca i32, align 4
  %frameno.addr = alloca i32, align 4
  %subprogno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %callsite, i32* %callsite.addr, align 4
  store i32 %frameno, i32* %frameno.addr, align 4
  store i32 %subprogno, i32* %subprogno.addr, align 4
  %0 = load i32, i32* %callsite.addr, align 4
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %callsite1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 1
  store i32 %0, i32* %callsite1, align 8
  %2 = load i32, i32* %frameno.addr, align 4
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 2
  store i32 %2, i32* %frameno2, align 4
  %4 = load i32, i32* %subprogno.addr, align 4
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %subprogno3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 3
  store i32 %4, i32* %subprogno3, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  call void @init_reg_state(%struct.bpf_verifier_env* noundef %6, %struct.bpf_func_state* noundef %7) #11
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_prepare_func_args(%struct.bpf_verifier_env* noundef, i32 noundef, %struct.bpf_reg_state* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %0, 11
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %1, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body7

do.body7:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body7
  br label %do.body8

do.body8:                                         ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1149, i32 2305, i64 12) #10, !srcloc !25
  br label %do.end9

do.end9:                                          ; preds = %do.body8
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 378) #10, !srcloc !26
  br label %do.body10

do.body10:                                        ; preds = %do.end9
  br label %do.end11

do.end11:                                         ; preds = %do.body10
  br label %do.end12

do.end12:                                         ; preds = %do.end11
  br label %if.end

if.end:                                           ; preds = %do.end12, %entry
  %2 = load i32, i32* %__ret_warn_on, align 4
  %tobool13 = icmp ne i32 %2, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  store i64 %conv18, i64* %tmp, align 8
  %3 = load i64, i64* %tmp, align 8
  %tobool19 = icmp ne i64 %3, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.92, i64 0, i64 0), i32 noundef %6) #11
  store i32 0, i32* %regno.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then20
  %7 = load i32, i32* %regno.addr, align 4
  %cmp21 = icmp ult i32 %7, 11
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %10 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %10 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i64 %idx.ext
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %add.ptr) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %regno.addr, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %regno.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %return

if.end23:                                         ; preds = %if.end
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %13 = load i32, i32* %regno.addr, align 4
  %idx.ext24 = zext i32 %13 to i64
  %add.ptr25 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i64 %idx.ext24
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %add.ptr25) #11
  br label %return

return:                                           ; preds = %if.end23, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %0, 11
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %1, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body7

do.body7:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body7
  br label %do.body8

do.body8:                                         ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1444, i32 2305, i64 12) #10, !srcloc !27
  br label %do.end9

do.end9:                                          ; preds = %do.body8
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 411) #10, !srcloc !28
  br label %do.body10

do.body10:                                        ; preds = %do.end9
  br label %do.end11

do.end11:                                         ; preds = %do.body10
  br label %do.end12

do.end12:                                         ; preds = %do.end11
  br label %if.end

if.end:                                           ; preds = %do.end12, %entry
  %2 = load i32, i32* %__ret_warn_on, align 4
  %tobool13 = icmp ne i32 %2, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  store i64 %conv18, i64* %tmp, align 8
  %3 = load i64, i64* %tmp, align 8
  %tobool19 = icmp ne i64 %3, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.93, i64 0, i64 0), i32 noundef %6) #11
  store i32 0, i32* %regno.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then20
  %7 = load i32, i32* %regno.addr, align 4
  %cmp21 = icmp ult i32 %7, 10
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %10 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %10 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i64 %idx.ext
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %add.ptr) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %regno.addr, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %regno.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %return

if.end23:                                         ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %14 = load i32, i32* %regno.addr, align 4
  %idx.ext24 = zext i32 %14 to i64
  %add.ptr25 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i64 %idx.ext24
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %12, %struct.bpf_reg_state* noundef %add.ptr25) #11
  br label %return

return:                                           ; preds = %if.end23, %for.end
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_check_func_arg_match(%struct.bpf_verifier_env* noundef, i32 noundef, %struct.bpf_reg_state* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @do_check(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %pscr_ret__.i.i = alloca %struct.task_struct*, align 8
  %__vpp_verify.i.i = alloca i8*, align 8
  %pfo_val__.i.i = alloca i64, align 8
  %tmp.i.i = alloca %struct.task_struct*, align 8
  %tmp1.i.i = alloca %struct.task_struct*, align 8
  %pscr_ret__.i = alloca %struct.task_struct*, align 8
  %__vpp_verify.i = alloca i8*, align 8
  %pfo_val__.i = alloca i64, align 8
  %tmp.i = alloca %struct.task_struct*, align 8
  %tmp1.i = alloca %struct.task_struct*, align 8
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %pop_log = alloca i8, align 1
  %state = alloca %struct.bpf_verifier_state*, align 8
  %insns = alloca %struct.bpf_insn*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %insn_cnt = alloca i32, align 4
  %do_print_state = alloca i8, align 1
  %prev_insn_idx = alloca i32, align 4
  %insn = alloca %struct.bpf_insn*, align 8
  %class = alloca i8, align 1
  %err = alloca i32, align 4
  %tmp = alloca i32, align 4
  %cbs = alloca %struct.bpf_insn_cbs, align 8
  %prev_src_type = alloca i32*, align 8
  %src_reg_type = alloca i32, align 4
  %prev_dst_type = alloca i32*, align 8
  %dst_reg_type = alloca i32, align 4
  %opcode = alloca i8, align 1
  %mode = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 22
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %1 = load i32, i32* %level, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %pop_log, align 1
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 8
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %3, %struct.bpf_verifier_state** %state, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 2
  %5 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %5, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insns, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 4
  %8 = load i32, i32* %len, align 4
  store i32 %8, i32* %insn_cnt, align 4
  store i8 0, i8* %do_print_state, align 1
  store i32 -1, i32* %prev_insn_idx, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end541, %if.else483, %if.end462, %if.end411, %if.end175, %entry
  %9 = load i32, i32* %prev_insn_idx, align 4
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 1
  store i32 %9, i32* %prev_insn_idx2, align 4
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 0
  %12 = load i32, i32* %insn_idx, align 8
  %13 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp uge i32 %12, %13
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 0
  %17 = load i32, i32* %insn_idx3, align 8
  %18 = load i32, i32* %insn_cnt, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.94, i64 0, i64 0), i32 noundef %17, i32 noundef %18) #11
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.cond
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insns, align 8
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 0
  %21 = load i32, i32* %insn_idx4, align 8
  %idxprom = zext i32 %21 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %19, i64 %idxprom
  store %struct.bpf_insn* %arrayidx, %struct.bpf_insn** %insn, align 8
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 0
  %23 = load i8, i8* %code, align 4
  %conv = zext i8 %23 to i32
  %and5 = and i32 %conv, 7
  %conv6 = trunc i32 %and5 to i8
  store i8 %conv6, i8* %class, align 1
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 28
  %25 = load i32, i32* %insn_processed, align 4
  %inc = add i32 %25, 1
  store i32 %inc, i32* %insn_processed, align 4
  %cmp7 = icmp ugt i32 %inc, 1000000
  br i1 %cmp7, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 28
  %29 = load i32, i32* %insn_processed10, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.95, i64 0, i64 0), i32 noundef %29) #11
  store i32 -7, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 0
  %32 = load i32, i32* %insn_idx12, align 8
  %call = call i32 @is_state_visited(%struct.bpf_verifier_env* noundef %30, i32 noundef %32) #11
  store i32 %call, i32* %err, align 4
  %33 = load i32, i32* %err, align 4
  %cmp13 = icmp slt i32 %33, 0
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end11
  %34 = load i32, i32* %err, align 4
  store i32 %34, i32* %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end11
  %35 = load i32, i32* %err, align 4
  %cmp17 = icmp eq i32 %35, 1
  br i1 %cmp17, label %if.then19, label %if.end35

if.then19:                                        ; preds = %if.end16
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log20 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %36, i32 0, i32 22
  %level21 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log20, i32 0, i32 0
  %37 = load i32, i32* %level21, align 8
  %and22 = and i32 %37, 3
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end34

if.then24:                                        ; preds = %if.then19
  %38 = load i8, i8* %do_print_state, align 1
  %tobool25 = trunc i8 %38 to i1
  br i1 %tobool25, label %if.then26, label %if.else

if.then26:                                        ; preds = %if.then24
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = bitcast %struct.bpf_verifier_env* %39 to i8*
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %41, i32 0, i32 1
  %42 = load i32, i32* %prev_insn_idx27, align 4
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx28 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %43, i32 0, i32 0
  %44 = load i32, i32* %insn_idx28, align 8
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %45, i32 0, i32 8
  %46 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state29, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %46, i32 0, i32 6
  %47 = load i8, i8* %speculative, align 8
  %tobool30 = trunc i8 %47 to i1
  %48 = zext i1 %tobool30 to i64
  %cond = select i1 %tobool30, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.97, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.98, i64 0, i64 0)
  call void (i8*, i8*, ...) @verbose(i8* noundef %40, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.96, i64 0, i64 0), i32 noundef %42, i32 noundef %44, i8* noundef %cond) #11
  br label %if.end33

if.else:                                          ; preds = %if.then24
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = bitcast %struct.bpf_verifier_env* %49 to i8*
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx32 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %51, i32 0, i32 0
  %52 = load i32, i32* %insn_idx32, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %50, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.99, i64 0, i64 0), i32 noundef %52) #11
  br label %if.end33

if.end33:                                         ; preds = %if.else, %if.then26
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.then19
  br label %process_bpf_exit

if.end35:                                         ; preds = %if.end16
  store i8* null, i8** %__vpp_verify.i, align 8
  %53 = load i8*, i8** %__vpp_verify.i, align 8
  %54 = call i64 asm "movq %gs:${1:P}, $0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #15, !srcloc !29
  store i64 %54, i64* %pfo_val__.i, align 8
  %55 = load i64, i64* %pfo_val__.i, align 8
  %56 = inttoptr i64 %55 to %struct.task_struct*
  store %struct.task_struct* %56, %struct.task_struct** %tmp.i, align 8
  %57 = load %struct.task_struct*, %struct.task_struct** %tmp.i, align 8
  store %struct.task_struct* %57, %struct.task_struct** %pscr_ret__.i, align 8
  %58 = load %struct.task_struct*, %struct.task_struct** %pscr_ret__.i, align 8
  store %struct.task_struct* %58, %struct.task_struct** %tmp1.i, align 8
  %59 = load %struct.task_struct*, %struct.task_struct** %tmp1.i, align 8
  %call37 = call i32 @signal_pending(%struct.task_struct* noundef %59) #11
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end35
  store i32 -11, i32* %retval, align 4
  br label %return

if.end40:                                         ; preds = %if.end35
  store i8* null, i8** %__vpp_verify.i.i, align 8
  %60 = load i8*, i8** %__vpp_verify.i.i, align 8
  %61 = call i64 asm "movq %gs:${1:P}, $0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #15, !srcloc !29
  store i64 %61, i64* %pfo_val__.i.i, align 8
  %62 = load i64, i64* %pfo_val__.i.i, align 8
  %63 = inttoptr i64 %62 to %struct.task_struct*
  store %struct.task_struct* %63, %struct.task_struct** %tmp.i.i, align 8
  %64 = load %struct.task_struct*, %struct.task_struct** %tmp.i.i, align 8
  store %struct.task_struct* %64, %struct.task_struct** %pscr_ret__.i.i, align 8
  %65 = load %struct.task_struct*, %struct.task_struct** %pscr_ret__.i.i, align 8
  store %struct.task_struct* %65, %struct.task_struct** %tmp1.i.i, align 8
  %66 = load %struct.task_struct*, %struct.task_struct** %tmp1.i.i, align 8
  %67 = bitcast %struct.task_struct* %66 to %struct.thread_info*
  %call1.i = call i32 @test_ti_thread_flag(%struct.thread_info* noundef %67, i32 noundef 3) #13
  %tobool.i = icmp ne i32 %call1.i, 0
  %lnot.i = xor i1 %tobool.i, true
  %lnot.ext.i = zext i1 %tobool.i to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %tobool.i, label %if.then42, label %if.end44

if.then42:                                        ; preds = %if.end40
  call void @___might_sleep(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 noundef 11255, i32 noundef 0) #11
  %call43 = call i32 @_cond_resched() #11
  store i32 %call43, i32* %tmp, align 4
  %68 = load i32, i32* %tmp, align 4
  br label %if.end44

if.end44:                                         ; preds = %if.then42, %if.end40
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log45 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %69, i32 0, i32 22
  %level46 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log45, i32 0, i32 0
  %70 = load i32, i32* %level46, align 8
  %and47 = and i32 %70, 2
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.then55, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end44
  %71 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log49 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %71, i32 0, i32 22
  %level50 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log49, i32 0, i32 0
  %72 = load i32, i32* %level50, align 8
  %and51 = and i32 %72, 3
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %land.lhs.true, label %if.end73

land.lhs.true:                                    ; preds = %lor.lhs.false
  %73 = load i8, i8* %do_print_state, align 1
  %tobool53 = trunc i8 %73 to i1
  br i1 %tobool53, label %if.then55, label %if.end73

if.then55:                                        ; preds = %land.lhs.true, %if.end44
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log56 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %74, i32 0, i32 22
  %level57 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log56, i32 0, i32 0
  %75 = load i32, i32* %level57, align 8
  %and58 = and i32 %75, 2
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %if.then60, label %if.else62

if.then60:                                        ; preds = %if.then55
  %76 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %77 = bitcast %struct.bpf_verifier_env* %76 to i8*
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx61 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %78, i32 0, i32 0
  %79 = load i32, i32* %insn_idx61, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %77, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.100, i64 0, i64 0), i32 noundef %79) #11
  br label %if.end70

if.else62:                                        ; preds = %if.then55
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %81 = bitcast %struct.bpf_verifier_env* %80 to i8*
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx63 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %82, i32 0, i32 1
  %83 = load i32, i32* %prev_insn_idx63, align 4
  %84 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx64 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %84, i32 0, i32 0
  %85 = load i32, i32* %insn_idx64, align 8
  %86 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state65 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %86, i32 0, i32 8
  %87 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state65, align 8
  %speculative66 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %87, i32 0, i32 6
  %88 = load i8, i8* %speculative66, align 8
  %tobool67 = trunc i8 %88 to i1
  %89 = zext i1 %tobool67 to i64
  %cond69 = select i1 %tobool67, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.97, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.98, i64 0, i64 0)
  call void (i8*, i8*, ...) @verbose(i8* noundef %81, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.101, i64 0, i64 0), i32 noundef %83, i32 noundef %85, i8* noundef %cond69) #11
  br label %if.end70

if.end70:                                         ; preds = %if.else62, %if.then60
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %91 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %91, i32 0, i32 0
  %92 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %92, i32 0, i32 4
  %93 = load i32, i32* %curframe, align 8
  %idxprom71 = zext i32 %93 to i64
  %arrayidx72 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom71
  %94 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx72, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %90, %struct.bpf_func_state* noundef %94) #11
  store i8 0, i8* %do_print_state, align 1
  br label %if.end73

if.end73:                                         ; preds = %if.end70, %land.lhs.true, %lor.lhs.false
  %95 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log74 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %95, i32 0, i32 22
  %level75 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log74, i32 0, i32 0
  %96 = load i32, i32* %level75, align 8
  %and76 = and i32 %96, 3
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %if.then78, label %if.end82

if.then78:                                        ; preds = %if.end73
  %cb_print = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 0
  store void (i8*, i8*, ...)* @verbose, void (i8*, i8*, ...)** %cb_print, align 8
  %cb_call = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 1
  store i8* (i8*, %struct.bpf_insn*)* null, i8* (i8*, %struct.bpf_insn*)** %cb_call, align 8
  %cb_imm = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 2
  store i8* (i8*, %struct.bpf_insn*, i64)* null, i8* (i8*, %struct.bpf_insn*, i64)** %cb_imm, align 8
  %private_data = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 3
  %97 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %98 = bitcast %struct.bpf_verifier_env* %97 to i8*
  store i8* %98, i8** %private_data, align 8
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx79 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %100, i32 0, i32 0
  %101 = load i32, i32* %insn_idx79, align 8
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %99, i32 noundef %101, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.102, i64 0, i64 0)) #11
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %103 = bitcast %struct.bpf_verifier_env* %102 to i8*
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx80 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %104, i32 0, i32 0
  %105 = load i32, i32* %insn_idx80, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %103, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.86, i64 0, i64 0), i32 noundef %105) #11
  %106 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %107, i32 0, i32 14
  %108 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool81 = trunc i8 %108 to i1
  call void @print_bpf_insn(%struct.bpf_insn_cbs* noundef %cbs, %struct.bpf_insn* noundef %106, i1 noundef zeroext %tobool81) #11
  br label %if.end82

if.end82:                                         ; preds = %if.then78, %if.end73
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog83 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %109, i32 0, i32 2
  %110 = load %struct.bpf_prog*, %struct.bpf_prog** %prog83, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %110, i32 0, i32 7
  %111 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call84 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %111) #11
  br i1 %call84, label %if.then85, label %if.end92

if.then85:                                        ; preds = %if.end82
  %112 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx86 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %113, i32 0, i32 0
  %114 = load i32, i32* %insn_idx86, align 8
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx87 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %115, i32 0, i32 1
  %116 = load i32, i32* %prev_insn_idx87, align 4
  %call88 = call i32 @bpf_prog_offload_verify_insn(%struct.bpf_verifier_env* noundef %112, i32 noundef %114, i32 noundef %116) #11
  store i32 %call88, i32* %err, align 4
  %117 = load i32, i32* %err, align 4
  %tobool89 = icmp ne i32 %117, 0
  br i1 %tobool89, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.then85
  %118 = load i32, i32* %err, align 4
  store i32 %118, i32* %retval, align 4
  br label %return

if.end91:                                         ; preds = %if.then85
  br label %if.end92

if.end92:                                         ; preds = %if.end91, %if.end82
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call93 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %119) #11
  store %struct.bpf_reg_state* %call93, %struct.bpf_reg_state** %regs, align 8
  %120 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %pass_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %120, i32 0, i32 25
  %121 = load i32, i32* %pass_cnt, align 8
  %122 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %122, i32 0, i32 20
  %123 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %124 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx94 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %124, i32 0, i32 0
  %125 = load i32, i32* %insn_idx94, align 8
  %idxprom95 = zext i32 %125 to i64
  %arrayidx96 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %123, i64 %idxprom95
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx96, i32 0, i32 4
  store i32 %121, i32* %seen, align 8
  %126 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx97 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %126, i32 0, i32 0
  %127 = load i32, i32* %insn_idx97, align 8
  store i32 %127, i32* %prev_insn_idx, align 4
  %128 = load i8, i8* %class, align 1
  %conv98 = zext i8 %128 to i32
  %cmp99 = icmp eq i32 %conv98, 4
  br i1 %cmp99, label %if.then105, label %lor.lhs.false101

lor.lhs.false101:                                 ; preds = %if.end92
  %129 = load i8, i8* %class, align 1
  %conv102 = zext i8 %129 to i32
  %cmp103 = icmp eq i32 %conv102, 7
  br i1 %cmp103, label %if.then105, label %if.else110

if.then105:                                       ; preds = %lor.lhs.false101, %if.end92
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %131 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call106 = call i32 @check_alu_op(%struct.bpf_verifier_env* noundef %130, %struct.bpf_insn* noundef %131) #11
  store i32 %call106, i32* %err, align 4
  %132 = load i32, i32* %err, align 4
  %tobool107 = icmp ne i32 %132, 0
  br i1 %tobool107, label %if.then108, label %if.end109

if.then108:                                       ; preds = %if.then105
  %133 = load i32, i32* %err, align 4
  store i32 %133, i32* %retval, align 4
  br label %return

if.end109:                                        ; preds = %if.then105
  br label %if.end541

if.else110:                                       ; preds = %lor.lhs.false101
  %134 = load i8, i8* %class, align 1
  %conv111 = zext i8 %134 to i32
  %cmp112 = icmp eq i32 %conv111, 1
  br i1 %cmp112, label %if.then114, label %if.else160

if.then114:                                       ; preds = %if.else110
  %135 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %136 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %136, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv115 = zext i8 %bf.lshr to i32
  %call116 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %135, i32 noundef %conv115, i32 noundef 0) #11
  store i32 %call116, i32* %err, align 4
  %137 = load i32, i32* %err, align 4
  %tobool117 = icmp ne i32 %137, 0
  br i1 %tobool117, label %if.then118, label %if.end119

if.then118:                                       ; preds = %if.then114
  %138 = load i32, i32* %err, align 4
  store i32 %138, i32* %retval, align 4
  br label %return

if.end119:                                        ; preds = %if.then114
  %139 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %140 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %140, i32 0, i32 1
  %bf.load120 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load120, 15
  %conv121 = zext i8 %bf.clear to i32
  %call122 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %139, i32 noundef %conv121, i32 noundef 2) #11
  store i32 %call122, i32* %err, align 4
  %141 = load i32, i32* %err, align 4
  %tobool123 = icmp ne i32 %141, 0
  br i1 %tobool123, label %if.then124, label %if.end125

if.then124:                                       ; preds = %if.end119
  %142 = load i32, i32* %err, align 4
  store i32 %142, i32* %retval, align 4
  br label %return

if.end125:                                        ; preds = %if.end119
  %143 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %144 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg126 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %144, i32 0, i32 1
  %bf.load127 = load i8, i8* %src_reg126, align 1
  %bf.lshr128 = lshr i8 %bf.load127, 4
  %idxprom129 = zext i8 %bf.lshr128 to i64
  %arrayidx130 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %143, i64 %idxprom129
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx130, i32 0, i32 0
  %145 = load i32, i32* %type, align 8
  store i32 %145, i32* %src_reg_type, align 4
  %146 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %147 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx131 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %147, i32 0, i32 0
  %148 = load i32, i32* %insn_idx131, align 8
  %149 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg132 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %149, i32 0, i32 1
  %bf.load133 = load i8, i8* %src_reg132, align 1
  %bf.lshr134 = lshr i8 %bf.load133, 4
  %conv135 = zext i8 %bf.lshr134 to i32
  %150 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %150, i32 0, i32 2
  %151 = load i16, i16* %off, align 2
  %conv136 = sext i16 %151 to i32
  %152 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code137 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %152, i32 0, i32 0
  %153 = load i8, i8* %code137, align 4
  %conv138 = zext i8 %153 to i32
  %and139 = and i32 %conv138, 24
  %154 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg140 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %154, i32 0, i32 1
  %bf.load141 = load i8, i8* %dst_reg140, align 1
  %bf.clear142 = and i8 %bf.load141, 15
  %conv143 = zext i8 %bf.clear142 to i32
  %call144 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %146, i32 noundef %148, i32 noundef %conv135, i32 noundef %conv136, i32 noundef %and139, i32 noundef 1, i32 noundef %conv143, i1 noundef zeroext false) #11
  store i32 %call144, i32* %err, align 4
  %155 = load i32, i32* %err, align 4
  %tobool145 = icmp ne i32 %155, 0
  br i1 %tobool145, label %if.then146, label %if.end147

if.then146:                                       ; preds = %if.end125
  %156 = load i32, i32* %err, align 4
  store i32 %156, i32* %retval, align 4
  br label %return

if.end147:                                        ; preds = %if.end125
  %157 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data148 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %157, i32 0, i32 20
  %158 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data148, align 8
  %159 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx149 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %159, i32 0, i32 0
  %160 = load i32, i32* %insn_idx149, align 8
  %idxprom150 = zext i32 %160 to i64
  %arrayidx151 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %158, i64 %idxprom150
  %161 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx151, i32 0, i32 0
  %ptr_type = bitcast %struct.atomic64_t* %161 to i32*
  store i32* %ptr_type, i32** %prev_src_type, align 8
  %162 = load i32*, i32** %prev_src_type, align 8
  %163 = load i32, i32* %162, align 4
  %cmp152 = icmp eq i32 %163, 0
  br i1 %cmp152, label %if.then154, label %if.else155

if.then154:                                       ; preds = %if.end147
  %164 = load i32, i32* %src_reg_type, align 4
  %165 = load i32*, i32** %prev_src_type, align 8
  store i32 %164, i32* %165, align 4
  br label %if.end159

if.else155:                                       ; preds = %if.end147
  %166 = load i32, i32* %src_reg_type, align 4
  %167 = load i32*, i32** %prev_src_type, align 8
  %168 = load i32, i32* %167, align 4
  %call156 = call zeroext i1 @reg_type_mismatch(i32 noundef %166, i32 noundef %168) #11
  br i1 %call156, label %if.then157, label %if.end158

if.then157:                                       ; preds = %if.else155
  %169 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %170 = bitcast %struct.bpf_verifier_env* %169 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %170, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.103, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end158:                                        ; preds = %if.else155
  br label %if.end159

if.end159:                                        ; preds = %if.end158, %if.then154
  br label %if.end540

if.else160:                                       ; preds = %if.else110
  %171 = load i8, i8* %class, align 1
  %conv161 = zext i8 %171 to i32
  %cmp162 = icmp eq i32 %conv161, 3
  br i1 %cmp162, label %if.then164, label %if.else232

if.then164:                                       ; preds = %if.else160
  %172 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code165 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %172, i32 0, i32 0
  %173 = load i8, i8* %code165, align 4
  %conv166 = zext i8 %173 to i32
  %and167 = and i32 %conv166, 224
  %cmp168 = icmp eq i32 %and167, 192
  br i1 %cmp168, label %if.then170, label %if.end178

if.then170:                                       ; preds = %if.then164
  %174 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %175 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx171 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %175, i32 0, i32 0
  %176 = load i32, i32* %insn_idx171, align 8
  %177 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call172 = call i32 @check_xadd(%struct.bpf_verifier_env* noundef %174, i32 noundef %176, %struct.bpf_insn* noundef %177) #11
  store i32 %call172, i32* %err, align 4
  %178 = load i32, i32* %err, align 4
  %tobool173 = icmp ne i32 %178, 0
  br i1 %tobool173, label %if.then174, label %if.end175

if.then174:                                       ; preds = %if.then170
  %179 = load i32, i32* %err, align 4
  store i32 %179, i32* %retval, align 4
  br label %return

if.end175:                                        ; preds = %if.then170
  %180 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx176 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %180, i32 0, i32 0
  %181 = load i32, i32* %insn_idx176, align 8
  %inc177 = add i32 %181, 1
  store i32 %inc177, i32* %insn_idx176, align 8
  br label %for.cond

if.end178:                                        ; preds = %if.then164
  %182 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %183 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg179 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %183, i32 0, i32 1
  %bf.load180 = load i8, i8* %src_reg179, align 1
  %bf.lshr181 = lshr i8 %bf.load180, 4
  %conv182 = zext i8 %bf.lshr181 to i32
  %call183 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %182, i32 noundef %conv182, i32 noundef 0) #11
  store i32 %call183, i32* %err, align 4
  %184 = load i32, i32* %err, align 4
  %tobool184 = icmp ne i32 %184, 0
  br i1 %tobool184, label %if.then185, label %if.end186

if.then185:                                       ; preds = %if.end178
  %185 = load i32, i32* %err, align 4
  store i32 %185, i32* %retval, align 4
  br label %return

if.end186:                                        ; preds = %if.end178
  %186 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %187 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg187 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %187, i32 0, i32 1
  %bf.load188 = load i8, i8* %dst_reg187, align 1
  %bf.clear189 = and i8 %bf.load188, 15
  %conv190 = zext i8 %bf.clear189 to i32
  %call191 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %186, i32 noundef %conv190, i32 noundef 0) #11
  store i32 %call191, i32* %err, align 4
  %188 = load i32, i32* %err, align 4
  %tobool192 = icmp ne i32 %188, 0
  br i1 %tobool192, label %if.then193, label %if.end194

if.then193:                                       ; preds = %if.end186
  %189 = load i32, i32* %err, align 4
  store i32 %189, i32* %retval, align 4
  br label %return

if.end194:                                        ; preds = %if.end186
  %190 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %191 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg195 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %191, i32 0, i32 1
  %bf.load196 = load i8, i8* %dst_reg195, align 1
  %bf.clear197 = and i8 %bf.load196, 15
  %idxprom198 = zext i8 %bf.clear197 to i64
  %arrayidx199 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %190, i64 %idxprom198
  %type200 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx199, i32 0, i32 0
  %192 = load i32, i32* %type200, align 8
  store i32 %192, i32* %dst_reg_type, align 4
  %193 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %194 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx201 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %194, i32 0, i32 0
  %195 = load i32, i32* %insn_idx201, align 8
  %196 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg202 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %196, i32 0, i32 1
  %bf.load203 = load i8, i8* %dst_reg202, align 1
  %bf.clear204 = and i8 %bf.load203, 15
  %conv205 = zext i8 %bf.clear204 to i32
  %197 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off206 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %197, i32 0, i32 2
  %198 = load i16, i16* %off206, align 2
  %conv207 = sext i16 %198 to i32
  %199 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code208 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %199, i32 0, i32 0
  %200 = load i8, i8* %code208, align 4
  %conv209 = zext i8 %200 to i32
  %and210 = and i32 %conv209, 24
  %201 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg211 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %201, i32 0, i32 1
  %bf.load212 = load i8, i8* %src_reg211, align 1
  %bf.lshr213 = lshr i8 %bf.load212, 4
  %conv214 = zext i8 %bf.lshr213 to i32
  %call215 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %193, i32 noundef %195, i32 noundef %conv205, i32 noundef %conv207, i32 noundef %and210, i32 noundef 2, i32 noundef %conv214, i1 noundef zeroext false) #11
  store i32 %call215, i32* %err, align 4
  %202 = load i32, i32* %err, align 4
  %tobool216 = icmp ne i32 %202, 0
  br i1 %tobool216, label %if.then217, label %if.end218

if.then217:                                       ; preds = %if.end194
  %203 = load i32, i32* %err, align 4
  store i32 %203, i32* %retval, align 4
  br label %return

if.end218:                                        ; preds = %if.end194
  %204 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data219 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %204, i32 0, i32 20
  %205 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data219, align 8
  %206 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx220 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %206, i32 0, i32 0
  %207 = load i32, i32* %insn_idx220, align 8
  %idxprom221 = zext i32 %207 to i64
  %arrayidx222 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %205, i64 %idxprom221
  %208 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx222, i32 0, i32 0
  %ptr_type223 = bitcast %struct.atomic64_t* %208 to i32*
  store i32* %ptr_type223, i32** %prev_dst_type, align 8
  %209 = load i32*, i32** %prev_dst_type, align 8
  %210 = load i32, i32* %209, align 4
  %cmp224 = icmp eq i32 %210, 0
  br i1 %cmp224, label %if.then226, label %if.else227

if.then226:                                       ; preds = %if.end218
  %211 = load i32, i32* %dst_reg_type, align 4
  %212 = load i32*, i32** %prev_dst_type, align 8
  store i32 %211, i32* %212, align 4
  br label %if.end231

if.else227:                                       ; preds = %if.end218
  %213 = load i32, i32* %dst_reg_type, align 4
  %214 = load i32*, i32** %prev_dst_type, align 8
  %215 = load i32, i32* %214, align 4
  %call228 = call zeroext i1 @reg_type_mismatch(i32 noundef %213, i32 noundef %215) #11
  br i1 %call228, label %if.then229, label %if.end230

if.then229:                                       ; preds = %if.else227
  %216 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %217 = bitcast %struct.bpf_verifier_env* %216 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %217, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.103, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end230:                                        ; preds = %if.else227
  br label %if.end231

if.end231:                                        ; preds = %if.end230, %if.then226
  br label %if.end539

if.else232:                                       ; preds = %if.else160
  %218 = load i8, i8* %class, align 1
  %conv233 = zext i8 %218 to i32
  %cmp234 = icmp eq i32 %conv233, 2
  br i1 %cmp234, label %if.then236, label %if.else292

if.then236:                                       ; preds = %if.else232
  %219 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code237 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %219, i32 0, i32 0
  %220 = load i8, i8* %code237, align 4
  %conv238 = zext i8 %220 to i32
  %and239 = and i32 %conv238, 224
  %cmp240 = icmp ne i32 %and239, 96
  br i1 %cmp240, label %if.then249, label %lor.lhs.false242

lor.lhs.false242:                                 ; preds = %if.then236
  %221 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg243 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %221, i32 0, i32 1
  %bf.load244 = load i8, i8* %src_reg243, align 1
  %bf.lshr245 = lshr i8 %bf.load244, 4
  %conv246 = zext i8 %bf.lshr245 to i32
  %cmp247 = icmp ne i32 %conv246, 0
  br i1 %cmp247, label %if.then249, label %if.end250

if.then249:                                       ; preds = %lor.lhs.false242, %if.then236
  %222 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %223 = bitcast %struct.bpf_verifier_env* %222 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %223, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.104, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end250:                                        ; preds = %lor.lhs.false242
  %224 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %225 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg251 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %225, i32 0, i32 1
  %bf.load252 = load i8, i8* %dst_reg251, align 1
  %bf.clear253 = and i8 %bf.load252, 15
  %conv254 = zext i8 %bf.clear253 to i32
  %call255 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %224, i32 noundef %conv254, i32 noundef 0) #11
  store i32 %call255, i32* %err, align 4
  %226 = load i32, i32* %err, align 4
  %tobool256 = icmp ne i32 %226, 0
  br i1 %tobool256, label %if.then257, label %if.end258

if.then257:                                       ; preds = %if.end250
  %227 = load i32, i32* %err, align 4
  store i32 %227, i32* %retval, align 4
  br label %return

if.end258:                                        ; preds = %if.end250
  %228 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %229 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg259 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %229, i32 0, i32 1
  %bf.load260 = load i8, i8* %dst_reg259, align 1
  %bf.clear261 = and i8 %bf.load260, 15
  %conv262 = zext i8 %bf.clear261 to i32
  %call263 = call zeroext i1 @is_ctx_reg(%struct.bpf_verifier_env* noundef %228, i32 noundef %conv262) #11
  br i1 %call263, label %if.then264, label %if.end277

if.then264:                                       ; preds = %if.end258
  %230 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %231 = bitcast %struct.bpf_verifier_env* %230 to i8*
  %232 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg265 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %232, i32 0, i32 1
  %bf.load266 = load i8, i8* %dst_reg265, align 1
  %bf.clear267 = and i8 %bf.load266, 15
  %conv268 = zext i8 %bf.clear267 to i32
  %233 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %234 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg269 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %234, i32 0, i32 1
  %bf.load270 = load i8, i8* %dst_reg269, align 1
  %bf.clear271 = and i8 %bf.load270, 15
  %conv272 = zext i8 %bf.clear271 to i32
  %call273 = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %233, i32 noundef %conv272) #11
  %type274 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %call273, i32 0, i32 0
  %235 = load i32, i32* %type274, align 8
  %idxprom275 = zext i32 %235 to i64
  %arrayidx276 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom275
  %236 = load i8*, i8** %arrayidx276, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %231, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.105, i64 0, i64 0), i32 noundef %conv268, i8* noundef %236) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end277:                                        ; preds = %if.end258
  %237 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %238 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx278 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %238, i32 0, i32 0
  %239 = load i32, i32* %insn_idx278, align 8
  %240 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg279 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %240, i32 0, i32 1
  %bf.load280 = load i8, i8* %dst_reg279, align 1
  %bf.clear281 = and i8 %bf.load280, 15
  %conv282 = zext i8 %bf.clear281 to i32
  %241 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off283 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %241, i32 0, i32 2
  %242 = load i16, i16* %off283, align 2
  %conv284 = sext i16 %242 to i32
  %243 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code285 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %243, i32 0, i32 0
  %244 = load i8, i8* %code285, align 4
  %conv286 = zext i8 %244 to i32
  %and287 = and i32 %conv286, 24
  %call288 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %237, i32 noundef %239, i32 noundef %conv282, i32 noundef %conv284, i32 noundef %and287, i32 noundef 2, i32 noundef -1, i1 noundef zeroext false) #11
  store i32 %call288, i32* %err, align 4
  %245 = load i32, i32* %err, align 4
  %tobool289 = icmp ne i32 %245, 0
  br i1 %tobool289, label %if.then290, label %if.end291

if.then290:                                       ; preds = %if.end277
  %246 = load i32, i32* %err, align 4
  store i32 %246, i32* %retval, align 4
  br label %return

if.end291:                                        ; preds = %if.end277
  br label %if.end538

if.else292:                                       ; preds = %if.else232
  %247 = load i8, i8* %class, align 1
  %conv293 = zext i8 %247 to i32
  %cmp294 = icmp eq i32 %conv293, 5
  br i1 %cmp294, label %if.then300, label %lor.lhs.false296

lor.lhs.false296:                                 ; preds = %if.else292
  %248 = load i8, i8* %class, align 1
  %conv297 = zext i8 %248 to i32
  %cmp298 = icmp eq i32 %conv297, 6
  br i1 %cmp298, label %if.then300, label %if.else493

if.then300:                                       ; preds = %lor.lhs.false296, %if.else292
  %249 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code301 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %249, i32 0, i32 0
  %250 = load i8, i8* %code301, align 4
  %conv302 = zext i8 %250 to i32
  %and303 = and i32 %conv302, 240
  %conv304 = trunc i32 %and303 to i8
  store i8 %conv304, i8* %opcode, align 1
  %251 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %251, i32 0, i32 30
  %252 = load i32, i32* %jmps_processed, align 4
  %inc305 = add i32 %252, 1
  store i32 %inc305, i32* %jmps_processed, align 4
  %253 = load i8, i8* %opcode, align 1
  %conv306 = zext i8 %253 to i32
  %cmp307 = icmp eq i32 %conv306, 128
  br i1 %cmp307, label %if.then309, label %if.else378

if.then309:                                       ; preds = %if.then300
  %254 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code310 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %254, i32 0, i32 0
  %255 = load i8, i8* %code310, align 4
  %conv311 = zext i8 %255 to i32
  %and312 = and i32 %conv311, 8
  %cmp313 = icmp ne i32 %and312, 0
  br i1 %cmp313, label %if.then345, label %lor.lhs.false315

lor.lhs.false315:                                 ; preds = %if.then309
  %256 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off316 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %256, i32 0, i32 2
  %257 = load i16, i16* %off316, align 2
  %conv317 = sext i16 %257 to i32
  %cmp318 = icmp ne i32 %conv317, 0
  br i1 %cmp318, label %if.then345, label %lor.lhs.false320

lor.lhs.false320:                                 ; preds = %lor.lhs.false315
  %258 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg321 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %258, i32 0, i32 1
  %bf.load322 = load i8, i8* %src_reg321, align 1
  %bf.lshr323 = lshr i8 %bf.load322, 4
  %conv324 = zext i8 %bf.lshr323 to i32
  %cmp325 = icmp ne i32 %conv324, 0
  br i1 %cmp325, label %land.lhs.true327, label %lor.lhs.false334

land.lhs.true327:                                 ; preds = %lor.lhs.false320
  %259 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg328 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %259, i32 0, i32 1
  %bf.load329 = load i8, i8* %src_reg328, align 1
  %bf.lshr330 = lshr i8 %bf.load329, 4
  %conv331 = zext i8 %bf.lshr330 to i32
  %cmp332 = icmp ne i32 %conv331, 1
  br i1 %cmp332, label %if.then345, label %lor.lhs.false334

lor.lhs.false334:                                 ; preds = %land.lhs.true327, %lor.lhs.false320
  %260 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg335 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %260, i32 0, i32 1
  %bf.load336 = load i8, i8* %dst_reg335, align 1
  %bf.clear337 = and i8 %bf.load336, 15
  %conv338 = zext i8 %bf.clear337 to i32
  %cmp339 = icmp ne i32 %conv338, 0
  br i1 %cmp339, label %if.then345, label %lor.lhs.false341

lor.lhs.false341:                                 ; preds = %lor.lhs.false334
  %261 = load i8, i8* %class, align 1
  %conv342 = zext i8 %261 to i32
  %cmp343 = icmp eq i32 %conv342, 6
  br i1 %cmp343, label %if.then345, label %if.end346

if.then345:                                       ; preds = %lor.lhs.false341, %lor.lhs.false334, %land.lhs.true327, %lor.lhs.false315, %if.then309
  %262 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %263 = bitcast %struct.bpf_verifier_env* %262 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %263, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.106, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end346:                                        ; preds = %lor.lhs.false341
  %264 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state347 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %264, i32 0, i32 8
  %265 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state347, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %265, i32 0, i32 5
  %266 = load i32, i32* %active_spin_lock, align 4
  %tobool348 = icmp ne i32 %266, 0
  br i1 %tobool348, label %land.lhs.true349, label %if.end360

land.lhs.true349:                                 ; preds = %if.end346
  %267 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg350 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %267, i32 0, i32 1
  %bf.load351 = load i8, i8* %src_reg350, align 1
  %bf.lshr352 = lshr i8 %bf.load351, 4
  %conv353 = zext i8 %bf.lshr352 to i32
  %cmp354 = icmp eq i32 %conv353, 1
  br i1 %cmp354, label %if.then359, label %lor.lhs.false356

lor.lhs.false356:                                 ; preds = %land.lhs.true349
  %268 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %268, i32 0, i32 3
  %269 = load i32, i32* %imm, align 4
  %cmp357 = icmp ne i32 %269, 94
  br i1 %cmp357, label %if.then359, label %if.end360

if.then359:                                       ; preds = %lor.lhs.false356, %land.lhs.true349
  %270 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %271 = bitcast %struct.bpf_verifier_env* %270 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %271, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.107, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end360:                                        ; preds = %lor.lhs.false356, %if.end346
  %272 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg361 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %272, i32 0, i32 1
  %bf.load362 = load i8, i8* %src_reg361, align 1
  %bf.lshr363 = lshr i8 %bf.load362, 4
  %conv364 = zext i8 %bf.lshr363 to i32
  %cmp365 = icmp eq i32 %conv364, 1
  br i1 %cmp365, label %if.then367, label %if.else370

if.then367:                                       ; preds = %if.end360
  %273 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %274 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %275 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx368 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %275, i32 0, i32 0
  %call369 = call i32 @check_func_call(%struct.bpf_verifier_env* noundef %273, %struct.bpf_insn* noundef %274, i32* noundef %insn_idx368) #11
  store i32 %call369, i32* %err, align 4
  br label %if.end374

if.else370:                                       ; preds = %if.end360
  %276 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %277 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm371 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %277, i32 0, i32 3
  %278 = load i32, i32* %imm371, align 4
  %279 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx372 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %279, i32 0, i32 0
  %280 = load i32, i32* %insn_idx372, align 8
  %call373 = call i32 @check_helper_call(%struct.bpf_verifier_env* noundef %276, i32 noundef %278, i32 noundef %280) #11
  store i32 %call373, i32* %err, align 4
  br label %if.end374

if.end374:                                        ; preds = %if.else370, %if.then367
  %281 = load i32, i32* %err, align 4
  %tobool375 = icmp ne i32 %281, 0
  br i1 %tobool375, label %if.then376, label %if.end377

if.then376:                                       ; preds = %if.end374
  %282 = load i32, i32* %err, align 4
  store i32 %282, i32* %retval, align 4
  br label %return

if.end377:                                        ; preds = %if.end374
  br label %if.end492

if.else378:                                       ; preds = %if.then300
  %283 = load i8, i8* %opcode, align 1
  %conv379 = zext i8 %283 to i32
  %cmp380 = icmp eq i32 %conv379, 0
  br i1 %cmp380, label %if.then382, label %if.else416

if.then382:                                       ; preds = %if.else378
  %284 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code383 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %284, i32 0, i32 0
  %285 = load i8, i8* %code383, align 4
  %conv384 = zext i8 %285 to i32
  %and385 = and i32 %conv384, 8
  %cmp386 = icmp ne i32 %and385, 0
  br i1 %cmp386, label %if.then410, label %lor.lhs.false388

lor.lhs.false388:                                 ; preds = %if.then382
  %286 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm389 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %286, i32 0, i32 3
  %287 = load i32, i32* %imm389, align 4
  %cmp390 = icmp ne i32 %287, 0
  br i1 %cmp390, label %if.then410, label %lor.lhs.false392

lor.lhs.false392:                                 ; preds = %lor.lhs.false388
  %288 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg393 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %288, i32 0, i32 1
  %bf.load394 = load i8, i8* %src_reg393, align 1
  %bf.lshr395 = lshr i8 %bf.load394, 4
  %conv396 = zext i8 %bf.lshr395 to i32
  %cmp397 = icmp ne i32 %conv396, 0
  br i1 %cmp397, label %if.then410, label %lor.lhs.false399

lor.lhs.false399:                                 ; preds = %lor.lhs.false392
  %289 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg400 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %289, i32 0, i32 1
  %bf.load401 = load i8, i8* %dst_reg400, align 1
  %bf.clear402 = and i8 %bf.load401, 15
  %conv403 = zext i8 %bf.clear402 to i32
  %cmp404 = icmp ne i32 %conv403, 0
  br i1 %cmp404, label %if.then410, label %lor.lhs.false406

lor.lhs.false406:                                 ; preds = %lor.lhs.false399
  %290 = load i8, i8* %class, align 1
  %conv407 = zext i8 %290 to i32
  %cmp408 = icmp eq i32 %conv407, 6
  br i1 %cmp408, label %if.then410, label %if.end411

if.then410:                                       ; preds = %lor.lhs.false406, %lor.lhs.false399, %lor.lhs.false392, %lor.lhs.false388, %if.then382
  %291 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %292 = bitcast %struct.bpf_verifier_env* %291 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %292, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.108, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end411:                                        ; preds = %lor.lhs.false406
  %293 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off412 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %293, i32 0, i32 2
  %294 = load i16, i16* %off412, align 2
  %conv413 = sext i16 %294 to i32
  %add = add i32 %conv413, 1
  %295 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx414 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %295, i32 0, i32 0
  %296 = load i32, i32* %insn_idx414, align 8
  %add415 = add i32 %296, %add
  store i32 %add415, i32* %insn_idx414, align 8
  br label %for.cond

if.else416:                                       ; preds = %if.else378
  %297 = load i8, i8* %opcode, align 1
  %conv417 = zext i8 %297 to i32
  %cmp418 = icmp eq i32 %conv417, 144
  br i1 %cmp418, label %if.then420, label %if.else484

if.then420:                                       ; preds = %if.else416
  %298 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code421 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %298, i32 0, i32 0
  %299 = load i8, i8* %code421, align 4
  %conv422 = zext i8 %299 to i32
  %and423 = and i32 %conv422, 8
  %cmp424 = icmp ne i32 %and423, 0
  br i1 %cmp424, label %if.then448, label %lor.lhs.false426

lor.lhs.false426:                                 ; preds = %if.then420
  %300 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %imm427 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %300, i32 0, i32 3
  %301 = load i32, i32* %imm427, align 4
  %cmp428 = icmp ne i32 %301, 0
  br i1 %cmp428, label %if.then448, label %lor.lhs.false430

lor.lhs.false430:                                 ; preds = %lor.lhs.false426
  %302 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg431 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %302, i32 0, i32 1
  %bf.load432 = load i8, i8* %src_reg431, align 1
  %bf.lshr433 = lshr i8 %bf.load432, 4
  %conv434 = zext i8 %bf.lshr433 to i32
  %cmp435 = icmp ne i32 %conv434, 0
  br i1 %cmp435, label %if.then448, label %lor.lhs.false437

lor.lhs.false437:                                 ; preds = %lor.lhs.false430
  %303 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg438 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %303, i32 0, i32 1
  %bf.load439 = load i8, i8* %dst_reg438, align 1
  %bf.clear440 = and i8 %bf.load439, 15
  %conv441 = zext i8 %bf.clear440 to i32
  %cmp442 = icmp ne i32 %conv441, 0
  br i1 %cmp442, label %if.then448, label %lor.lhs.false444

lor.lhs.false444:                                 ; preds = %lor.lhs.false437
  %304 = load i8, i8* %class, align 1
  %conv445 = zext i8 %304 to i32
  %cmp446 = icmp eq i32 %conv445, 6
  br i1 %cmp446, label %if.then448, label %if.end449

if.then448:                                       ; preds = %lor.lhs.false444, %lor.lhs.false437, %lor.lhs.false430, %lor.lhs.false426, %if.then420
  %305 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %306 = bitcast %struct.bpf_verifier_env* %305 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %306, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.109, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end449:                                        ; preds = %lor.lhs.false444
  %307 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state450 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %307, i32 0, i32 8
  %308 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state450, align 8
  %active_spin_lock451 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %308, i32 0, i32 5
  %309 = load i32, i32* %active_spin_lock451, align 4
  %tobool452 = icmp ne i32 %309, 0
  br i1 %tobool452, label %if.then453, label %if.end454

if.then453:                                       ; preds = %if.end449
  %310 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %311 = bitcast %struct.bpf_verifier_env* %310 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %311, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.110, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end454:                                        ; preds = %if.end449
  %312 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe455 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %312, i32 0, i32 4
  %313 = load i32, i32* %curframe455, align 8
  %tobool456 = icmp ne i32 %313, 0
  br i1 %tobool456, label %if.then457, label %if.end463

if.then457:                                       ; preds = %if.end454
  %314 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %315 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx458 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %315, i32 0, i32 0
  %call459 = call i32 @prepare_func_exit(%struct.bpf_verifier_env* noundef %314, i32* noundef %insn_idx458) #11
  store i32 %call459, i32* %err, align 4
  %316 = load i32, i32* %err, align 4
  %tobool460 = icmp ne i32 %316, 0
  br i1 %tobool460, label %if.then461, label %if.end462

if.then461:                                       ; preds = %if.then457
  %317 = load i32, i32* %err, align 4
  store i32 %317, i32* %retval, align 4
  br label %return

if.end462:                                        ; preds = %if.then457
  store i8 1, i8* %do_print_state, align 1
  br label %for.cond

if.end463:                                        ; preds = %if.end454
  %318 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call464 = call i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %318) #11
  store i32 %call464, i32* %err, align 4
  %319 = load i32, i32* %err, align 4
  %tobool465 = icmp ne i32 %319, 0
  br i1 %tobool465, label %if.then466, label %if.end467

if.then466:                                       ; preds = %if.end463
  %320 = load i32, i32* %err, align 4
  store i32 %320, i32* %retval, align 4
  br label %return

if.end467:                                        ; preds = %if.end463
  %321 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call468 = call i32 @check_return_code(%struct.bpf_verifier_env* noundef %321) #11
  store i32 %call468, i32* %err, align 4
  %322 = load i32, i32* %err, align 4
  %tobool469 = icmp ne i32 %322, 0
  br i1 %tobool469, label %if.then470, label %if.end471

if.then470:                                       ; preds = %if.end467
  %323 = load i32, i32* %err, align 4
  store i32 %323, i32* %retval, align 4
  br label %return

if.end471:                                        ; preds = %if.end467
  br label %process_bpf_exit

process_bpf_exit:                                 ; preds = %if.end471, %if.end34
  %324 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %325 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state472 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %325, i32 0, i32 8
  %326 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state472, align 8
  call void @update_branch_counts(%struct.bpf_verifier_env* noundef %324, %struct.bpf_verifier_state* noundef %326) #11
  %327 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %328 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx473 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %328, i32 0, i32 0
  %329 = load i8, i8* %pop_log, align 1
  %tobool474 = trunc i8 %329 to i1
  %call475 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %327, i32* noundef %prev_insn_idx, i32* noundef %insn_idx473, i1 noundef zeroext %tobool474) #11
  store i32 %call475, i32* %err, align 4
  %330 = load i32, i32* %err, align 4
  %cmp476 = icmp slt i32 %330, 0
  br i1 %cmp476, label %if.then478, label %if.else483

if.then478:                                       ; preds = %process_bpf_exit
  %331 = load i32, i32* %err, align 4
  %cmp479 = icmp ne i32 %331, -2
  br i1 %cmp479, label %if.then481, label %if.end482

if.then481:                                       ; preds = %if.then478
  %332 = load i32, i32* %err, align 4
  store i32 %332, i32* %retval, align 4
  br label %return

if.end482:                                        ; preds = %if.then478
  br label %for.end

if.else483:                                       ; preds = %process_bpf_exit
  store i8 1, i8* %do_print_state, align 1
  br label %for.cond

if.else484:                                       ; preds = %if.else416
  %333 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %334 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %335 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx485 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %335, i32 0, i32 0
  %call486 = call i32 @check_cond_jmp_op(%struct.bpf_verifier_env* noundef %333, %struct.bpf_insn* noundef %334, i32* noundef %insn_idx485) #11
  store i32 %call486, i32* %err, align 4
  %336 = load i32, i32* %err, align 4
  %tobool487 = icmp ne i32 %336, 0
  br i1 %tobool487, label %if.then488, label %if.end489

if.then488:                                       ; preds = %if.else484
  %337 = load i32, i32* %err, align 4
  store i32 %337, i32* %retval, align 4
  br label %return

if.end489:                                        ; preds = %if.else484
  br label %if.end490

if.end490:                                        ; preds = %if.end489
  br label %if.end491

if.end491:                                        ; preds = %if.end490
  br label %if.end492

if.end492:                                        ; preds = %if.end491, %if.end377
  br label %if.end537

if.else493:                                       ; preds = %lor.lhs.false296
  %338 = load i8, i8* %class, align 1
  %conv494 = zext i8 %338 to i32
  %cmp495 = icmp eq i32 %conv494, 0
  br i1 %cmp495, label %if.then497, label %if.else534

if.then497:                                       ; preds = %if.else493
  %339 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code498 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %339, i32 0, i32 0
  %340 = load i8, i8* %code498, align 4
  %conv499 = zext i8 %340 to i32
  %and500 = and i32 %conv499, 224
  %conv501 = trunc i32 %and500 to i8
  store i8 %conv501, i8* %mode, align 1
  %341 = load i8, i8* %mode, align 1
  %conv502 = zext i8 %341 to i32
  %cmp503 = icmp eq i32 %conv502, 32
  br i1 %cmp503, label %if.then509, label %lor.lhs.false505

lor.lhs.false505:                                 ; preds = %if.then497
  %342 = load i8, i8* %mode, align 1
  %conv506 = zext i8 %342 to i32
  %cmp507 = icmp eq i32 %conv506, 64
  br i1 %cmp507, label %if.then509, label %if.else514

if.then509:                                       ; preds = %lor.lhs.false505, %if.then497
  %343 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %344 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call510 = call i32 @check_ld_abs(%struct.bpf_verifier_env* noundef %343, %struct.bpf_insn* noundef %344) #11
  store i32 %call510, i32* %err, align 4
  %345 = load i32, i32* %err, align 4
  %tobool511 = icmp ne i32 %345, 0
  br i1 %tobool511, label %if.then512, label %if.end513

if.then512:                                       ; preds = %if.then509
  %346 = load i32, i32* %err, align 4
  store i32 %346, i32* %retval, align 4
  br label %return

if.end513:                                        ; preds = %if.then509
  br label %if.end533

if.else514:                                       ; preds = %lor.lhs.false505
  %347 = load i8, i8* %mode, align 1
  %conv515 = zext i8 %347 to i32
  %cmp516 = icmp eq i32 %conv515, 0
  br i1 %cmp516, label %if.then518, label %if.else531

if.then518:                                       ; preds = %if.else514
  %348 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %349 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %call519 = call i32 @check_ld_imm(%struct.bpf_verifier_env* noundef %348, %struct.bpf_insn* noundef %349) #11
  store i32 %call519, i32* %err, align 4
  %350 = load i32, i32* %err, align 4
  %tobool520 = icmp ne i32 %350, 0
  br i1 %tobool520, label %if.then521, label %if.end522

if.then521:                                       ; preds = %if.then518
  %351 = load i32, i32* %err, align 4
  store i32 %351, i32* %retval, align 4
  br label %return

if.end522:                                        ; preds = %if.then518
  %352 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx523 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %352, i32 0, i32 0
  %353 = load i32, i32* %insn_idx523, align 8
  %inc524 = add i32 %353, 1
  store i32 %inc524, i32* %insn_idx523, align 8
  %354 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %pass_cnt525 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %354, i32 0, i32 25
  %355 = load i32, i32* %pass_cnt525, align 8
  %356 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data526 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %356, i32 0, i32 20
  %357 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data526, align 8
  %358 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx527 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %358, i32 0, i32 0
  %359 = load i32, i32* %insn_idx527, align 8
  %idxprom528 = zext i32 %359 to i64
  %arrayidx529 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %357, i64 %idxprom528
  %seen530 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx529, i32 0, i32 4
  store i32 %355, i32* %seen530, align 8
  br label %if.end532

if.else531:                                       ; preds = %if.else514
  %360 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %361 = bitcast %struct.bpf_verifier_env* %360 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %361, i8* noundef getelementptr inbounds ([21 x i8], [21 x i8]* @.str.111, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end532:                                        ; preds = %if.end522
  br label %if.end533

if.end533:                                        ; preds = %if.end532, %if.end513
  br label %if.end536

if.else534:                                       ; preds = %if.else493
  %362 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %363 = bitcast %struct.bpf_verifier_env* %362 to i8*
  %364 = load i8, i8* %class, align 1
  %conv535 = zext i8 %364 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %363, i8* noundef getelementptr inbounds ([23 x i8], [23 x i8]* @.str.112, i64 0, i64 0), i32 noundef %conv535) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end536:                                        ; preds = %if.end533
  br label %if.end537

if.end537:                                        ; preds = %if.end536, %if.end492
  br label %if.end538

if.end538:                                        ; preds = %if.end537, %if.end291
  br label %if.end539

if.end539:                                        ; preds = %if.end538, %if.end231
  br label %if.end540

if.end540:                                        ; preds = %if.end539, %if.end159
  br label %if.end541

if.end541:                                        ; preds = %if.end540, %if.end109
  %365 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx542 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %365, i32 0, i32 0
  %366 = load i32, i32* %insn_idx542, align 8
  %inc543 = add i32 %366, 1
  store i32 %inc543, i32* %insn_idx542, align 8
  br label %for.cond

for.end:                                          ; preds = %if.end482
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.else534, %if.else531, %if.then521, %if.then512, %if.then488, %if.then481, %if.then470, %if.then466, %if.then461, %if.then453, %if.then448, %if.then410, %if.then376, %if.then359, %if.then345, %if.then290, %if.then264, %if.then257, %if.then249, %if.then229, %if.then217, %if.then193, %if.then185, %if.then174, %if.then157, %if.then146, %if.then124, %if.then118, %if.then108, %if.then90, %if.then39, %if.then15, %if.then9, %if.then
  %367 = load i32, i32* %retval, align 4
  ret i32 %367
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @free_verifier_state(%struct.bpf_verifier_state* noundef %state, i1 noundef zeroext %free_self) #0 {
entry:
  %state.addr = alloca %struct.bpf_verifier_state*, align 8
  %free_self.addr = alloca i8, align 1
  %i = alloca i32, align 4
  store %struct.bpf_verifier_state* %state, %struct.bpf_verifier_state** %state.addr, align 8
  %frombool = zext i1 %free_self to i8
  store i8 %frombool, i8* %free_self.addr, align 1
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 0
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %5) #11
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %frame1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 0
  %7 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame1, i64 0, i64 %idxprom2
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  call void @clear_jmp_history(%struct.bpf_verifier_state* noundef %9) #11
  %10 = load i8, i8* %free_self.addr, align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %12 = bitcast %struct.bpf_verifier_state* %11 to i8*
  call void @kfree(i8* noundef %12) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @pop_stack(%struct.bpf_verifier_env* noundef %env, i32* noundef %prev_insn_idx, i32* noundef %insn_idx, i1 noundef zeroext %pop_log) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %prev_insn_idx.addr = alloca i32*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %pop_log.addr = alloca i8, align 1
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %elem = alloca %struct.bpf_verifier_stack_elem*, align 8
  %head = alloca %struct.bpf_verifier_stack_elem*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32* %prev_insn_idx, i32** %prev_insn_idx.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %frombool = zext i1 %pop_log to i8
  store i8 %frombool, i8* %pop_log.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 4
  %3 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head1, align 8
  store %struct.bpf_verifier_stack_elem* %3, %struct.bpf_verifier_stack_elem** %head, align 8
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 4
  %5 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head2, align 8
  %cmp = icmp eq %struct.bpf_verifier_stack_elem* %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -2, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %6, null
  br i1 %tobool, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %8 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %st = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %8, i32 0, i32 0
  %call = call i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %7, %struct.bpf_verifier_state* noundef %st) #11
  store i32 %call, i32* %err, align 4
  %9 = load i32, i32* %err, align 4
  %tobool4 = icmp ne i32 %9, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then3
  %10 = load i32, i32* %err, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.then3
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %if.end
  %11 = load i8, i8* %pop_log.addr, align 1
  %tobool8 = trunc i8 %11 to i1
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 22
  %13 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %log_pos = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %13, i32 0, i32 4
  %14 = load i32, i32* %log_pos, align 8
  call void @bpf_vlog_reset(%struct.bpf_verifier_log* noundef %log, i32 noundef %14) #11
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  %15 = load i32*, i32** %insn_idx.addr, align 8
  %tobool11 = icmp ne i32* %15, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %16 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %insn_idx13 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %16, i32 0, i32 1
  %17 = load i32, i32* %insn_idx13, align 8
  %18 = load i32*, i32** %insn_idx.addr, align 8
  store i32 %17, i32* %18, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  %19 = load i32*, i32** %prev_insn_idx.addr, align 8
  %tobool15 = icmp ne i32* %19, null
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end14
  %20 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %prev_insn_idx17 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %20, i32 0, i32 2
  %21 = load i32, i32* %prev_insn_idx17, align 4
  %22 = load i32*, i32** %prev_insn_idx.addr, align 8
  store i32 %21, i32* %22, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end14
  %23 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %23, i32 0, i32 3
  %24 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %next, align 8
  store %struct.bpf_verifier_stack_elem* %24, %struct.bpf_verifier_stack_elem** %elem, align 8
  %25 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %st19 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %25, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %st19, i1 noundef zeroext false) #11
  %26 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %27 = bitcast %struct.bpf_verifier_stack_elem* %26 to i8*
  call void @kfree(i8* noundef %27) #11
  %28 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head20 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 4
  store %struct.bpf_verifier_stack_elem* %28, %struct.bpf_verifier_stack_elem** %head20, align 8
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 5
  %31 = load i32, i32* %stack_size, align 8
  %dec = add i32 %31, -1
  store i32 %dec, i32* %stack_size, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then5, %if.then
  %32 = load i32, i32* %retval, align 4
  ret i32 %32
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_vlog_reset(%struct.bpf_verifier_log* noundef %log, i32 noundef %new_pos) #0 {
entry:
  %log.addr = alloca %struct.bpf_verifier_log*, align 8
  %new_pos.addr = alloca i32, align 4
  %zero = alloca i8, align 1
  %tmp = alloca i64, align 8
  %__ret_pu = alloca i32, align 4
  %__ptr_pu = alloca i8*, align 8
  %__val_pu = alloca i8, align 1
  %tmp2 = alloca i64, align 8
  store %struct.bpf_verifier_log* %log, %struct.bpf_verifier_log** %log.addr, align 8
  store i32 %new_pos, i32* %new_pos.addr, align 4
  store i8 0, i8* %zero, align 1
  %0 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %0) #11
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end5

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %new_pos.addr, align 4
  %2 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %2, i32 0, i32 3
  store i32 %1, i32* %len_used, align 8
  call void @might_fault() #11
  %3 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %3, i32 0, i32 2
  %4 = load i8*, i8** %ubuf, align 8
  %5 = load i32, i32* %new_pos.addr, align 4
  %idx.ext = zext i32 %5 to i64
  %add.ptr = getelementptr i8, i8* %4, i64 %idx.ext
  store i8* %add.ptr, i8** %__ptr_pu, align 8
  %6 = load i8, i8* %zero, align 1
  store i8 %6, i8* %__val_pu, align 1
  %7 = call i64 @llvm.read_register.i64(metadata !5)
  %8 = load i8*, i8** %__ptr_pu, align 8
  %9 = load i8, i8* %__val_pu, align 1
  %10 = call { i8*, i64 } asm sideeffect "call __put_user_${4:P}", "={cx},={rsp},0,{rax},i,{rsp},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %8, i8 %9, i64 1, i64 %7) #10, !srcloc !30
  %asmresult = extractvalue { i8*, i64 } %10, 0
  %asmresult1 = extractvalue { i8*, i64 } %10, 1
  %11 = ptrtoint i8* %asmresult to i64
  %12 = trunc i64 %11 to i32
  store i32 %12, i32* %__ret_pu, align 4
  call void @llvm.write_register.i64(metadata !5, i64 %asmresult1)
  %13 = load i32, i32* %__ret_pu, align 4
  %conv = sext i32 %13 to i64
  store i64 %conv, i64* %tmp2, align 8
  %14 = load i64, i64* %tmp2, align 8
  store i64 %14, i64* %tmp, align 8
  %15 = load i64, i64* %tmp, align 8
  %tobool = icmp ne i64 %15, 0
  br i1 %tobool, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %16 = load %struct.bpf_verifier_log*, %struct.bpf_verifier_log** %log.addr, align 8
  %ubuf4 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %16, i32 0, i32 2
  store i8* null, i8** %ubuf4, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @free_states(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %sl = alloca %struct.bpf_verifier_state_list*, align 8
  %sln = alloca %struct.bpf_verifier_state_list*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 10
  %1 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %free_list, align 8
  store %struct.bpf_verifier_state_list* %1, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool = icmp ne %struct.bpf_verifier_state_list* %2, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %3, i32 0, i32 1
  %4 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next, align 8
  store %struct.bpf_verifier_state_list* %4, %struct.bpf_verifier_state_list** %sln, align 8
  %5 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %5, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %state, i1 noundef zeroext false) #11
  %6 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %7 = bitcast %struct.bpf_verifier_state_list* %6 to i8*
  call void @kfree(i8* noundef %7) #11
  %8 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sln, align 8
  store %struct.bpf_verifier_state_list* %8, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 10
  store %struct.bpf_verifier_state_list* null, %struct.bpf_verifier_state_list** %free_list1, align 8
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 9
  %11 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states, align 8
  %tobool2 = icmp ne %struct.bpf_verifier_state_list** %11, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %while.end
  br label %for.end

if.end:                                           ; preds = %while.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @state_htab_size(%struct.bpf_verifier_env* noundef %13) #11
  %cmp = icmp ult i32 %12, %call
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 9
  %15 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states3, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %15, i64 %idxprom
  %17 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %arrayidx, align 8
  store %struct.bpf_verifier_state_list* %17, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond4

while.cond4:                                      ; preds = %while.body6, %for.body
  %18 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool5 = icmp ne %struct.bpf_verifier_state_list* %18, null
  br i1 %tobool5, label %while.body6, label %while.end9

while.body6:                                      ; preds = %while.cond4
  %19 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next7 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %19, i32 0, i32 1
  %20 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next7, align 8
  store %struct.bpf_verifier_state_list* %20, %struct.bpf_verifier_state_list** %sln, align 8
  %21 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state8 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %21, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %state8, i1 noundef zeroext false) #11
  %22 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %23 = bitcast %struct.bpf_verifier_state_list* %22 to i8*
  call void @kfree(i8* noundef %23) #11
  %24 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sln, align 8
  store %struct.bpf_verifier_state_list* %24, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond4

while.end9:                                       ; preds = %while.cond4
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 9
  %26 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states10, align 8
  %27 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %27 to i64
  %arrayidx12 = getelementptr %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %26, i64 %idxprom11
  store %struct.bpf_verifier_state_list* null, %struct.bpf_verifier_state_list** %arrayidx12, align 8
  br label %for.inc

for.inc:                                          ; preds = %while.end9
  %28 = load i32, i32* %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @sanitize_insn_aux_data(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %i = alloca i32, align 4
  %class = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  store %struct.bpf_insn* %arraydecay, %struct.bpf_insn** %insn, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %4, i32 0, i32 4
  %5 = load i32, i32* %len, align 4
  %cmp = icmp ult i32 %2, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %7 = load i32, i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %6, i64 %idxprom
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 0
  %8 = load i8, i8* %code, align 4
  %conv = zext i8 %8 to i32
  %and = and i32 %conv, 7
  store i32 %and, i32* %class, align 4
  %9 = load i32, i32* %class, align 4
  %cmp2 = icmp ne i32 %9, 1
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %10 = load i32, i32* %class, align 4
  %cmp4 = icmp ne i32 %10, 3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 20
  %12 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %13 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %12, i64 %idxprom6
  store %struct.bpf_insn_aux_data* %arrayidx7, %struct.bpf_insn_aux_data** %aux, align 8
  %14 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %seen = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %14, i32 0, i32 4
  %15 = load i32, i32* %seen, align 8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %pass_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 25
  %17 = load i32, i32* %pass_cnt, align 8
  %cmp8 = icmp ne i32 %15, %17
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  br label %for.inc

if.end11:                                         ; preds = %if.end
  %18 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %19 = bitcast %struct.bpf_insn_aux_data* %18 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %19, i8 0, i64 32, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end11, %if.then10, %if.then
  %20 = load i32, i32* %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: argmemonly nofree nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #8

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @might_fault() #0 {
entry:
  ret void
}

; Function Attrs: nounwind readonly
declare i64 @llvm.read_register.i64(metadata) #9

; Function Attrs: nounwind
declare void @llvm.write_register.i64(metadata, i64) #10

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %dst_state, %struct.bpf_verifier_state* noundef %src) #0 {
entry:
  %retval.i68 = alloca i32, align 4
  %flags.addr.i69 = alloca i32, align 4
  %retval.i61 = alloca i32, align 4
  %size.addr.i62 = alloca i64, align 8
  %size.addr.i58 = alloca i64, align 8
  %flags.addr.i59 = alloca i32, align 4
  %order.i = alloca i32, align 4
  %retval.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %index.i = alloca i32, align 4
  %retval = alloca i32, align 4
  %dst_state.addr = alloca %struct.bpf_verifier_state*, align 8
  %src.addr = alloca %struct.bpf_verifier_state*, align 8
  %dst = alloca %struct.bpf_func_state*, align 8
  %jmp_sz = alloca i32, align 4
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_state* %dst_state, %struct.bpf_verifier_state** %dst_state.addr, align 8
  store %struct.bpf_verifier_state* %src, %struct.bpf_verifier_state** %src.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 10
  %1 = load i32, i32* %jmp_history_cnt, align 8
  %conv = zext i32 %1 to i64
  %mul = mul i64 8, %conv
  %conv1 = trunc i64 %mul to i32
  store i32 %conv1, i32* %jmp_sz, align 4
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history_cnt2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 10
  %3 = load i32, i32* %jmp_history_cnt2, align 8
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history_cnt3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 10
  %5 = load i32, i32* %jmp_history_cnt3, align 8
  %cmp = icmp ult i32 %3, %5
  br i1 %cmp, label %if.then, label %if.end9

if.then:                                          ; preds = %entry
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 9
  %7 = load %struct.util_est*, %struct.util_est** %jmp_history, align 8
  %8 = bitcast %struct.util_est* %7 to i8*
  call void @kfree(i8* noundef %8) #11
  %9 = load i32, i32* %jmp_sz, align 4
  %conv5 = zext i32 %9 to i64
  store i64 %conv5, i64* %size.addr.i, align 8
  store i32 1051840, i32* %flags.addr.i, align 4
  %10 = load i64, i64* %size.addr.i, align 8
  %11 = call i1 @llvm.is.constant.i64(i64 %10) #10
  br i1 %11, label %if.then.i, label %if.end9.i

if.then.i:                                        ; preds = %if.then
  %12 = load i64, i64* %size.addr.i, align 8
  %cmp.i = icmp ugt i64 %12, 8192
  br i1 %cmp.i, label %if.then1.i, label %if.end.i

if.then1.i:                                       ; preds = %if.then.i
  %13 = load i64, i64* %size.addr.i, align 8
  %14 = load i32, i32* %flags.addr.i, align 4
  store i64 %13, i64* %size.addr.i58, align 8
  store i32 %14, i32* %flags.addr.i59, align 4
  %15 = load i64, i64* %size.addr.i58, align 8
  %call.i60 = call i32 @get_order(i64 noundef %15) #14
  store i32 %call.i60, i32* %order.i, align 4
  %16 = load i64, i64* %size.addr.i58, align 8
  %17 = load i32, i32* %flags.addr.i59, align 4
  %18 = load i32, i32* %order.i, align 4
  %call1.i = call noalias align 4096 i8* @kmalloc_order_trace(i64 noundef %16, i32 noundef %17, i32 noundef %18) #13
  store i8* %call1.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end.i:                                         ; preds = %if.then.i
  %19 = load i64, i64* %size.addr.i, align 8
  store i64 %19, i64* %size.addr.i62, align 8
  %20 = load i64, i64* %size.addr.i62, align 8
  %tobool.i63 = icmp ne i64 %20, 0
  br i1 %tobool.i63, label %if.end.i66, label %if.then.i64

if.then.i64:                                      ; preds = %if.end.i
  store i32 0, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end.i66:                                       ; preds = %if.end.i
  %21 = load i64, i64* %size.addr.i62, align 8
  %cmp.i65 = icmp ule i64 %21, 8
  br i1 %cmp.i65, label %if.then1.i67, label %if.end2.i

if.then1.i67:                                     ; preds = %if.end.i66
  store i32 3, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end2.i:                                        ; preds = %if.end.i66
  %22 = load i64, i64* %size.addr.i62, align 8
  %cmp3.i = icmp ugt i64 %22, 64
  br i1 %cmp3.i, label %land.lhs.true.i, label %if.end6.i

land.lhs.true.i:                                  ; preds = %if.end2.i
  %23 = load i64, i64* %size.addr.i62, align 8
  %cmp4.i = icmp ule i64 %23, 96
  br i1 %cmp4.i, label %if.then5.i, label %if.end6.i

if.then5.i:                                       ; preds = %land.lhs.true.i
  store i32 1, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end6.i:                                        ; preds = %land.lhs.true.i, %if.end2.i
  %24 = load i64, i64* %size.addr.i62, align 8
  %cmp7.i = icmp ugt i64 %24, 128
  br i1 %cmp7.i, label %land.lhs.true8.i, label %if.end11.i

land.lhs.true8.i:                                 ; preds = %if.end6.i
  %25 = load i64, i64* %size.addr.i62, align 8
  %cmp9.i = icmp ule i64 %25, 192
  br i1 %cmp9.i, label %if.then10.i, label %if.end11.i

if.then10.i:                                      ; preds = %land.lhs.true8.i
  store i32 2, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end11.i:                                       ; preds = %land.lhs.true8.i, %if.end6.i
  %26 = load i64, i64* %size.addr.i62, align 8
  %cmp12.i = icmp ule i64 %26, 8
  br i1 %cmp12.i, label %if.then13.i, label %if.end14.i

if.then13.i:                                      ; preds = %if.end11.i
  store i32 3, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end14.i:                                       ; preds = %if.end11.i
  %27 = load i64, i64* %size.addr.i62, align 8
  %cmp15.i = icmp ule i64 %27, 16
  br i1 %cmp15.i, label %if.then16.i, label %if.end17.i

if.then16.i:                                      ; preds = %if.end14.i
  store i32 4, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end17.i:                                       ; preds = %if.end14.i
  %28 = load i64, i64* %size.addr.i62, align 8
  %cmp18.i = icmp ule i64 %28, 32
  br i1 %cmp18.i, label %if.then19.i, label %if.end20.i

if.then19.i:                                      ; preds = %if.end17.i
  store i32 5, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end20.i:                                       ; preds = %if.end17.i
  %29 = load i64, i64* %size.addr.i62, align 8
  %cmp21.i = icmp ule i64 %29, 64
  br i1 %cmp21.i, label %if.then22.i, label %if.end23.i

if.then22.i:                                      ; preds = %if.end20.i
  store i32 6, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end23.i:                                       ; preds = %if.end20.i
  %30 = load i64, i64* %size.addr.i62, align 8
  %cmp24.i = icmp ule i64 %30, 128
  br i1 %cmp24.i, label %if.then25.i, label %if.end26.i

if.then25.i:                                      ; preds = %if.end23.i
  store i32 7, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end26.i:                                       ; preds = %if.end23.i
  %31 = load i64, i64* %size.addr.i62, align 8
  %cmp27.i = icmp ule i64 %31, 256
  br i1 %cmp27.i, label %if.then28.i, label %if.end29.i

if.then28.i:                                      ; preds = %if.end26.i
  store i32 8, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end29.i:                                       ; preds = %if.end26.i
  %32 = load i64, i64* %size.addr.i62, align 8
  %cmp30.i = icmp ule i64 %32, 512
  br i1 %cmp30.i, label %if.then31.i, label %if.end32.i

if.then31.i:                                      ; preds = %if.end29.i
  store i32 9, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end32.i:                                       ; preds = %if.end29.i
  %33 = load i64, i64* %size.addr.i62, align 8
  %cmp33.i = icmp ule i64 %33, 1024
  br i1 %cmp33.i, label %if.then34.i, label %if.end35.i

if.then34.i:                                      ; preds = %if.end32.i
  store i32 10, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end35.i:                                       ; preds = %if.end32.i
  %34 = load i64, i64* %size.addr.i62, align 8
  %cmp36.i = icmp ule i64 %34, 2048
  br i1 %cmp36.i, label %if.then37.i, label %if.end38.i

if.then37.i:                                      ; preds = %if.end35.i
  store i32 11, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end38.i:                                       ; preds = %if.end35.i
  %35 = load i64, i64* %size.addr.i62, align 8
  %cmp39.i = icmp ule i64 %35, 4096
  br i1 %cmp39.i, label %if.then40.i, label %if.end41.i

if.then40.i:                                      ; preds = %if.end38.i
  store i32 12, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end41.i:                                       ; preds = %if.end38.i
  %36 = load i64, i64* %size.addr.i62, align 8
  %cmp42.i = icmp ule i64 %36, 8192
  br i1 %cmp42.i, label %if.then43.i, label %if.end44.i

if.then43.i:                                      ; preds = %if.end41.i
  store i32 13, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end44.i:                                       ; preds = %if.end41.i
  %37 = load i64, i64* %size.addr.i62, align 8
  %cmp45.i = icmp ule i64 %37, 16384
  br i1 %cmp45.i, label %if.then46.i, label %if.end47.i

if.then46.i:                                      ; preds = %if.end44.i
  store i32 14, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end47.i:                                       ; preds = %if.end44.i
  %38 = load i64, i64* %size.addr.i62, align 8
  %cmp48.i = icmp ule i64 %38, 32768
  br i1 %cmp48.i, label %if.then49.i, label %if.end50.i

if.then49.i:                                      ; preds = %if.end47.i
  store i32 15, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end50.i:                                       ; preds = %if.end47.i
  %39 = load i64, i64* %size.addr.i62, align 8
  %cmp51.i = icmp ule i64 %39, 65536
  br i1 %cmp51.i, label %if.then52.i, label %if.end53.i

if.then52.i:                                      ; preds = %if.end50.i
  store i32 16, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end53.i:                                       ; preds = %if.end50.i
  %40 = load i64, i64* %size.addr.i62, align 8
  %cmp54.i = icmp ule i64 %40, 131072
  br i1 %cmp54.i, label %if.then55.i, label %if.end56.i

if.then55.i:                                      ; preds = %if.end53.i
  store i32 17, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end56.i:                                       ; preds = %if.end53.i
  %41 = load i64, i64* %size.addr.i62, align 8
  %cmp57.i = icmp ule i64 %41, 262144
  br i1 %cmp57.i, label %if.then58.i, label %if.end59.i

if.then58.i:                                      ; preds = %if.end56.i
  store i32 18, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end59.i:                                       ; preds = %if.end56.i
  %42 = load i64, i64* %size.addr.i62, align 8
  %cmp60.i = icmp ule i64 %42, 524288
  br i1 %cmp60.i, label %if.then61.i, label %if.end62.i

if.then61.i:                                      ; preds = %if.end59.i
  store i32 19, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end62.i:                                       ; preds = %if.end59.i
  %43 = load i64, i64* %size.addr.i62, align 8
  %cmp63.i = icmp ule i64 %43, 1048576
  br i1 %cmp63.i, label %if.then64.i, label %if.end65.i

if.then64.i:                                      ; preds = %if.end62.i
  store i32 20, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end65.i:                                       ; preds = %if.end62.i
  %44 = load i64, i64* %size.addr.i62, align 8
  %cmp66.i = icmp ule i64 %44, 2097152
  br i1 %cmp66.i, label %if.then67.i, label %if.end68.i

if.then67.i:                                      ; preds = %if.end65.i
  store i32 21, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end68.i:                                       ; preds = %if.end65.i
  %45 = load i64, i64* %size.addr.i62, align 8
  %cmp69.i = icmp ule i64 %45, 4194304
  br i1 %cmp69.i, label %if.then70.i, label %if.end71.i

if.then70.i:                                      ; preds = %if.end68.i
  store i32 22, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end71.i:                                       ; preds = %if.end68.i
  %46 = load i64, i64* %size.addr.i62, align 8
  %cmp72.i = icmp ule i64 %46, 8388608
  br i1 %cmp72.i, label %if.then73.i, label %if.end74.i

if.then73.i:                                      ; preds = %if.end71.i
  store i32 23, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end74.i:                                       ; preds = %if.end71.i
  %47 = load i64, i64* %size.addr.i62, align 8
  %cmp75.i = icmp ule i64 %47, 16777216
  br i1 %cmp75.i, label %if.then76.i, label %if.end77.i

if.then76.i:                                      ; preds = %if.end74.i
  store i32 24, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end77.i:                                       ; preds = %if.end74.i
  %48 = load i64, i64* %size.addr.i62, align 8
  %cmp78.i = icmp ule i64 %48, 33554432
  br i1 %cmp78.i, label %if.then79.i, label %if.end80.i

if.then79.i:                                      ; preds = %if.end77.i
  store i32 25, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end80.i:                                       ; preds = %if.end77.i
  %49 = load i64, i64* %size.addr.i62, align 8
  %cmp81.i = icmp ule i64 %49, 67108864
  br i1 %cmp81.i, label %if.then82.i, label %if.end83.i

if.then82.i:                                      ; preds = %if.end80.i
  store i32 26, i32* %retval.i61, align 4
  br label %kmalloc_index.exit

if.end83.i:                                       ; preds = %if.end80.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.30, i64 0, i64 0), i32 382, i32 0, i64 12) #10, !srcloc !12
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.unreachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 81) #10, !srcloc !13
  unreachable

kmalloc_index.exit:                               ; preds = %if.then82.i, %if.then79.i, %if.then76.i, %if.then73.i, %if.then70.i, %if.then67.i, %if.then64.i, %if.then61.i, %if.then58.i, %if.then55.i, %if.then52.i, %if.then49.i, %if.then46.i, %if.then43.i, %if.then40.i, %if.then37.i, %if.then34.i, %if.then31.i, %if.then28.i, %if.then25.i, %if.then22.i, %if.then19.i, %if.then16.i, %if.then13.i, %if.then10.i, %if.then5.i, %if.then1.i67, %if.then.i64
  %50 = load i32, i32* %retval.i61, align 4
  store i32 %50, i32* %index.i, align 4
  %51 = load i32, i32* %index.i, align 4
  %tobool.i = icmp ne i32 %51, 0
  br i1 %tobool.i, label %if.end4.i, label %if.then3.i

if.then3.i:                                       ; preds = %kmalloc_index.exit
  store i8* inttoptr (i64 16 to i8*), i8** %retval.i, align 8
  br label %kmalloc.exit

if.end4.i:                                        ; preds = %kmalloc_index.exit
  %52 = load i32, i32* %flags.addr.i, align 4
  store i32 %52, i32* %flags.addr.i69, align 4
  %53 = load i32, i32* %flags.addr.i69, align 4
  %and.i = and i32 %53, 17
  %cmp.i70 = icmp eq i32 %and.i, 0
  %lnot.i = xor i1 %cmp.i70, true
  %lnot.ext.i = zext i1 %cmp.i70 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %cmp.i70, label %if.then.i71, label %if.end.i72

if.then.i71:                                      ; preds = %if.end4.i
  store i32 0, i32* %retval.i68, align 4
  br label %kmalloc_type.exit

if.end.i72:                                       ; preds = %if.end4.i
  %54 = load i32, i32* %flags.addr.i69, align 4
  %and2.i = and i32 %54, 1
  %tobool3.i = icmp ne i32 %and2.i, 0
  %55 = zext i1 %tobool3.i to i64
  %cond.i = select i1 %tobool3.i, i32 2, i32 1
  store i32 %cond.i, i32* %retval.i68, align 4
  br label %kmalloc_type.exit

kmalloc_type.exit:                                ; preds = %if.end.i72, %if.then.i71
  %56 = load i32, i32* %retval.i68, align 4
  %idxprom.i = zext i32 %56 to i64
  %arrayidx.i = getelementptr [3 x [14 x %struct.kmem_cache*]], [3 x [14 x %struct.kmem_cache*]]* @kmalloc_caches, i64 0, i64 %idxprom.i
  %57 = load i32, i32* %index.i, align 4
  %idxprom6.i = zext i32 %57 to i64
  %arrayidx7.i = getelementptr [14 x %struct.kmem_cache*], [14 x %struct.kmem_cache*]* %arrayidx.i, i64 0, i64 %idxprom6.i
  %58 = load %struct.kmem_cache*, %struct.kmem_cache** %arrayidx7.i, align 8
  %59 = load i32, i32* %flags.addr.i, align 4
  %60 = load i64, i64* %size.addr.i, align 8
  %call8.i = call noalias align 8 i8* @kmem_cache_alloc_trace(%struct.kmem_cache* noundef %58, i32 noundef %59, i64 noundef %60) #13
  store i8* %call8.i, i8** %retval.i, align 8
  br label %kmalloc.exit

if.end9.i:                                        ; preds = %if.then
  %61 = load i64, i64* %size.addr.i, align 8
  %62 = load i32, i32* %flags.addr.i, align 4
  %call10.i = call noalias align 8 i8* @__kmalloc(i64 noundef %61, i32 noundef %62) #13
  store i8* %call10.i, i8** %retval.i, align 8
  br label %kmalloc.exit

kmalloc.exit:                                     ; preds = %if.end9.i, %kmalloc_type.exit, %if.then3.i, %if.then1.i
  %63 = load i8*, i8** %retval.i, align 8
  %64 = bitcast i8* %63 to %struct.util_est*
  %65 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history6 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %65, i32 0, i32 9
  store %struct.util_est* %64, %struct.util_est** %jmp_history6, align 8
  %66 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history7 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %66, i32 0, i32 9
  %67 = load %struct.util_est*, %struct.util_est** %jmp_history7, align 8
  %tobool = icmp ne %struct.util_est* %67, null
  br i1 %tobool, label %if.end, label %if.then8

if.then8:                                         ; preds = %kmalloc.exit
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %kmalloc.exit
  br label %if.end9

if.end9:                                          ; preds = %if.end, %entry
  %68 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %68, i32 0, i32 9
  %69 = load %struct.util_est*, %struct.util_est** %jmp_history10, align 8
  %70 = bitcast %struct.util_est* %69 to i8*
  %71 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history11 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %71, i32 0, i32 9
  %72 = load %struct.util_est*, %struct.util_est** %jmp_history11, align 8
  %73 = bitcast %struct.util_est* %72 to i8*
  %74 = load i32, i32* %jmp_sz, align 4
  %conv12 = zext i32 %74 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %70, i8* align 4 %73, i64 %conv12, i1 false)
  %75 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %jmp_history_cnt13 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %75, i32 0, i32 10
  %76 = load i32, i32* %jmp_history_cnt13, align 8
  %77 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %jmp_history_cnt14 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %77, i32 0, i32 10
  store i32 %76, i32* %jmp_history_cnt14, align 8
  %78 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %78, i32 0, i32 4
  %79 = load i32, i32* %curframe, align 8
  %add = add i32 %79, 1
  store i32 %add, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %80 = load i32, i32* %i, align 4
  %81 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %curframe15 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %81, i32 0, i32 4
  %82 = load i32, i32* %curframe15, align 8
  %cmp16 = icmp ule i32 %80, %82
  br i1 %cmp16, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %83 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %83, i32 0, i32 0
  %84 = load i32, i32* %i, align 4
  %idxprom = sext i32 %84 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %85 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %85) #11
  %86 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame18 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %86, i32 0, i32 0
  %87 = load i32, i32* %i, align 4
  %idxprom19 = sext i32 %87 to i64
  %arrayidx20 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame18, i64 0, i64 %idxprom19
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx20, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %88 = load i32, i32* %i, align 4
  %inc = add i32 %88, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %89 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %89, i32 0, i32 6
  %90 = load i8, i8* %speculative, align 8
  %tobool21 = trunc i8 %90 to i1
  %91 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %speculative22 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %91, i32 0, i32 6
  %frombool = zext i1 %tobool21 to i8
  store i8 %frombool, i8* %speculative22, align 8
  %92 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %curframe23 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %92, i32 0, i32 4
  %93 = load i32, i32* %curframe23, align 8
  %94 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %curframe24 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %94, i32 0, i32 4
  store i32 %93, i32* %curframe24, align 8
  %95 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %95, i32 0, i32 5
  %96 = load i32, i32* %active_spin_lock, align 4
  %97 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %active_spin_lock25 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %97, i32 0, i32 5
  store i32 %96, i32* %active_spin_lock25, align 4
  %98 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %98, i32 0, i32 2
  %99 = load i32, i32* %branches, align 8
  %100 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %branches26 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %100, i32 0, i32 2
  store i32 %99, i32* %branches26, align 8
  %101 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %101, i32 0, i32 1
  %102 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  %103 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %parent27 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %103, i32 0, i32 1
  store %struct.bpf_verifier_state* %102, %struct.bpf_verifier_state** %parent27, align 8
  %104 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %first_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %104, i32 0, i32 7
  %105 = load i32, i32* %first_insn_idx, align 4
  %106 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %first_insn_idx28 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %106, i32 0, i32 7
  store i32 %105, i32* %first_insn_idx28, align 4
  %107 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %last_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %107, i32 0, i32 8
  %108 = load i32, i32* %last_insn_idx, align 8
  %109 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %last_insn_idx29 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %109, i32 0, i32 8
  store i32 %108, i32* %last_insn_idx29, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond30

for.cond30:                                       ; preds = %for.inc55, %for.end
  %110 = load i32, i32* %i, align 4
  %111 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %curframe31 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %111, i32 0, i32 4
  %112 = load i32, i32* %curframe31, align 8
  %cmp32 = icmp ule i32 %110, %112
  br i1 %cmp32, label %for.body34, label %for.end57

for.body34:                                       ; preds = %for.cond30
  %113 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame35 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %113, i32 0, i32 0
  %114 = load i32, i32* %i, align 4
  %idxprom36 = sext i32 %114 to i64
  %arrayidx37 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame35, i64 0, i64 %idxprom36
  %115 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx37, align 8
  store %struct.bpf_func_state* %115, %struct.bpf_func_state** %dst, align 8
  %116 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %tobool38 = icmp ne %struct.bpf_func_state* %116, null
  br i1 %tobool38, label %if.end47, label %if.then39

if.then39:                                        ; preds = %for.body34
  %call40 = call i8* @kzalloc(i64 noundef 1360, i32 noundef 3264) #11
  %117 = bitcast i8* %call40 to %struct.bpf_func_state*
  store %struct.bpf_func_state* %117, %struct.bpf_func_state** %dst, align 8
  %118 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %tobool41 = icmp ne %struct.bpf_func_state* %118, null
  br i1 %tobool41, label %if.end43, label %if.then42

if.then42:                                        ; preds = %if.then39
  store i32 -12, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.then39
  %119 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %120 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %dst_state.addr, align 8
  %frame44 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %120, i32 0, i32 0
  %121 = load i32, i32* %i, align 4
  %idxprom45 = sext i32 %121 to i64
  %arrayidx46 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame44, i64 0, i64 %idxprom45
  store %struct.bpf_func_state* %119, %struct.bpf_func_state** %arrayidx46, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.end43, %for.body34
  %122 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst, align 8
  %123 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %src.addr, align 8
  %frame48 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %123, i32 0, i32 0
  %124 = load i32, i32* %i, align 4
  %idxprom49 = sext i32 %124 to i64
  %arrayidx50 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame48, i64 0, i64 %idxprom49
  %125 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx50, align 8
  %call51 = call i32 @copy_func_state(%struct.bpf_func_state* noundef %122, %struct.bpf_func_state* noundef %125) #11
  store i32 %call51, i32* %err, align 4
  %126 = load i32, i32* %err, align 4
  %tobool52 = icmp ne i32 %126, 0
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end47
  %127 = load i32, i32* %err, align 4
  store i32 %127, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.end47
  br label %for.inc55

for.inc55:                                        ; preds = %if.end54
  %128 = load i32, i32* %i, align 4
  %inc56 = add i32 %128, 1
  store i32 %inc56, i32* %i, align 4
  br label %for.cond30

for.end57:                                        ; preds = %for.cond30
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end57, %if.then53, %if.then42, %if.then8
  %129 = load i32, i32* %retval, align 4
  ret i32 %129
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @free_func_state(%struct.bpf_func_state* noundef %state) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %tobool = icmp ne %struct.bpf_func_state* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 5
  %2 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %3 = bitcast %struct.util_est* %2 to i8*
  call void @kfree(i8* noundef %3) #11
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 7
  %5 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %6 = bitcast %struct.bpf_stack_state* %5 to i8*
  call void @kfree(i8* noundef %6) #11
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %8 = bitcast %struct.bpf_func_state* %7 to i8*
  call void @kfree(i8* noundef %8) #11
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_func_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 6
  %2 = load i32, i32* %allocated_stack, align 8
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 4
  %4 = load i32, i32* %acquired_refs, align 4
  %call = call i32 @realloc_func_state(%struct.bpf_func_state* noundef %0, i32 noundef %2, i32 noundef %4, i1 noundef zeroext false) #11
  store i32 %call, i32* %err, align 4
  %5 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, i32* %err, align 4
  store i32 %6, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %8 = bitcast %struct.bpf_func_state* %7 to i8*
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %10 = bitcast %struct.bpf_func_state* %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %8, i8* align 8 %10, i64 1332, i1 false)
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %call1 = call i32 @copy_reference_state(%struct.bpf_func_state* noundef %11, %struct.bpf_func_state* noundef %12) #11
  store i32 %call1, i32* %err, align 4
  %13 = load i32, i32* %err, align 4
  %tobool2 = icmp ne i32 %13, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %14 = load i32, i32* %err, align 4
  store i32 %14, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %call5 = call i32 @copy_stack_state(%struct.bpf_func_state* noundef %15, %struct.bpf_func_state* noundef %16) #11
  store i32 %call5, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %17 = load i32, i32* %retval, align 4
  ret i32 %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @realloc_func_state(%struct.bpf_func_state* noundef %state, i32 noundef %stack_size, i32 noundef %refs_size, i1 noundef zeroext %copy_old) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %stack_size.addr = alloca i32, align 4
  %refs_size.addr = alloca i32, align 4
  %copy_old.addr = alloca i8, align 1
  %err = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %stack_size, i32* %stack_size.addr, align 4
  store i32 %refs_size, i32* %refs_size.addr, align 4
  %frombool = zext i1 %copy_old to i8
  store i8 %frombool, i8* %copy_old.addr, align 1
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %1 = load i32, i32* %refs_size.addr, align 4
  %2 = load i8, i8* %copy_old.addr, align 1
  %tobool = trunc i8 %2 to i1
  %call = call i32 @realloc_reference_state(%struct.bpf_func_state* noundef %0, i32 noundef %1, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %err, align 4
  %3 = load i32, i32* %err, align 4
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %err, align 4
  store i32 %4, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %6 = load i32, i32* %stack_size.addr, align 4
  %7 = load i8, i8* %copy_old.addr, align 1
  %tobool2 = trunc i8 %7 to i1
  %call3 = call i32 @realloc_stack_state(%struct.bpf_func_state* noundef %5, i32 noundef %6, i1 noundef zeroext %tobool2) #11
  store i32 %call3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_reference_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 5
  %1 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %tobool = icmp ne %struct.util_est* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 4
  %3 = load i32, i32* %acquired_refs, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 4
  %5 = load i32, i32* %acquired_refs1, align 4
  %cmp = icmp slt i32 %3, %5
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %6 = load i32, i32* %__ret_warn_on, align 4
  %tobool3 = icmp ne i32 %6, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %tobool8 = icmp ne i64 %conv, 0
  br i1 %tobool8, label %if.then9, label %if.end16

if.then9:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then9
  br label %do.body10

do.body10:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body10
  br label %do.body11

do.body11:                                        ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 792, i32 2307, i64 12) #10, !srcloc !31
  br label %do.end12

do.end12:                                         ; preds = %do.body11
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 375) #10, !srcloc !32
  br label %do.body13

do.body13:                                        ; preds = %do.end12
  br label %do.end14

do.end14:                                         ; preds = %do.body13
  br label %do.end15

do.end15:                                         ; preds = %do.end14
  br label %if.end16

if.end16:                                         ; preds = %do.end15, %if.end
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool17 = icmp ne i32 %7, 0
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  store i64 %conv22, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %tobool23 = icmp ne i64 %8, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end16
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %10 = bitcast %struct.bpf_func_state* %9 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %10, i8 0, i64 1360, i1 false)
  store i32 -14, i32* %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.end16
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %refs26 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 5
  %12 = load %struct.util_est*, %struct.util_est** %refs26, align 8
  %13 = bitcast %struct.util_est* %12 to i8*
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %refs27 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 5
  %15 = load %struct.util_est*, %struct.util_est** %refs27, align 8
  %16 = bitcast %struct.util_est* %15 to i8*
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %acquired_refs28 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 4
  %18 = load i32, i32* %acquired_refs28, align 4
  %div = sdiv i32 %18, 1
  %conv29 = sext i32 %div to i64
  %mul = mul i64 8, %conv29
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %13, i8* align 4 %16, i64 %mul, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end25, %if.then24, %if.then
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @copy_stack_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 7
  %1 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %tobool = icmp ne %struct.bpf_stack_state* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 6
  %3 = load i32, i32* %allocated_stack, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %allocated_stack1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 6
  %5 = load i32, i32* %allocated_stack1, align 8
  %cmp = icmp slt i32 %3, %5
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %6 = load i32, i32* %__ret_warn_on, align 4
  %tobool3 = icmp ne i32 %6, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %tobool8 = icmp ne i64 %conv, 0
  br i1 %tobool8, label %if.then9, label %if.end16

if.then9:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then9
  br label %do.body10

do.body10:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body10
  br label %do.body11

do.body11:                                        ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 794, i32 2307, i64 12) #10, !srcloc !33
  br label %do.end12

do.end12:                                         ; preds = %do.body11
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 376) #10, !srcloc !34
  br label %do.body13

do.body13:                                        ; preds = %do.end12
  br label %do.end14

do.end14:                                         ; preds = %do.body13
  br label %do.end15

do.end15:                                         ; preds = %do.end14
  br label %if.end16

if.end16:                                         ; preds = %do.end15, %if.end
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool17 = icmp ne i32 %7, 0
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  store i64 %conv22, i64* %tmp, align 8
  %8 = load i64, i64* %tmp, align 8
  %tobool23 = icmp ne i64 %8, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end16
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %10 = bitcast %struct.bpf_func_state* %9 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %10, i8 0, i64 1360, i1 false)
  store i32 -14, i32* %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.end16
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %stack26 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 7
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack26, align 8
  %13 = bitcast %struct.bpf_stack_state* %12 to i8*
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %stack27 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 7
  %15 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack27, align 8
  %16 = bitcast %struct.bpf_stack_state* %15 to i8*
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %allocated_stack28 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 6
  %18 = load i32, i32* %allocated_stack28, align 8
  %div = sdiv i32 %18, 8
  %conv29 = sext i32 %div to i64
  %mul = mul i64 128, %conv29
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 %16, i64 %mul, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end25, %if.then24, %if.then
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @realloc_reference_state(%struct.bpf_func_state* noundef %state, i32 noundef %size, i1 noundef zeroext %copy_old) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %size.addr = alloca i32, align 4
  %copy_old.addr = alloca i8, align 1
  %old_size = alloca i32, align 4
  %new_refs = alloca %struct.util_est*, align 8
  %slot = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %copy_old to i8
  store i8 %frombool, i8* %copy_old.addr, align 1
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 4
  %1 = load i32, i32* %acquired_refs, align 4
  store i32 %1, i32* %old_size, align 4
  %2 = load i32, i32* %size.addr, align 4
  %div = sdiv i32 %2, 1
  store i32 %div, i32* %slot, align 4
  %3 = load i32, i32* %size.addr, align 4
  %4 = load i32, i32* %old_size, align 4
  %cmp = icmp ule i32 %3, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i32, i32* %size.addr, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end9, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load i8, i8* %copy_old.addr, align 1
  %tobool1 = trunc i8 %6 to i1
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %7 = load i32, i32* %slot, align 4
  %mul = mul i32 %7, 1
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 4
  store i32 %mul, i32* %acquired_refs3, align 4
  %9 = load i32, i32* %size.addr, align 4
  %tobool4 = icmp ne i32 %9, 0
  br i1 %tobool4, label %if.end8, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %10 = load i32, i32* %old_size, align 4
  %tobool5 = icmp ne i32 %10, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %land.lhs.true
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 5
  %12 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %13 = bitcast %struct.util_est* %12 to i8*
  call void @kfree(i8* noundef %13) #11
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 5
  store %struct.util_est* null, %struct.util_est** %refs7, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %land.lhs.true, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %lor.lhs.false
  %15 = load i32, i32* %slot, align 4
  %conv = sext i32 %15 to i64
  %call = call i8* @kmalloc_array(i64 noundef %conv, i64 noundef 8, i32 noundef 3264) #11
  %16 = bitcast i8* %call to %struct.util_est*
  store %struct.util_est* %16, %struct.util_est** %new_refs, align 8
  %17 = load %struct.util_est*, %struct.util_est** %new_refs, align 8
  %tobool10 = icmp ne %struct.util_est* %17, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end9
  store i32 -12, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end9
  %18 = load i8, i8* %copy_old.addr, align 1
  %tobool13 = trunc i8 %18 to i1
  br i1 %tobool13, label %if.then14, label %if.end27

if.then14:                                        ; preds = %if.end12
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 5
  %20 = load %struct.util_est*, %struct.util_est** %refs15, align 8
  %tobool16 = icmp ne %struct.util_est* %20, null
  br i1 %tobool16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.then14
  %21 = load %struct.util_est*, %struct.util_est** %new_refs, align 8
  %22 = bitcast %struct.util_est* %21 to i8*
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs18 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 5
  %24 = load %struct.util_est*, %struct.util_est** %refs18, align 8
  %25 = bitcast %struct.util_est* %24 to i8*
  %26 = load i32, i32* %old_size, align 4
  %div19 = udiv i32 %26, 1
  %conv20 = zext i32 %div19 to i64
  %mul21 = mul i64 8, %conv20
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %22, i8* align 4 %25, i64 %mul21, i1 false)
  br label %if.end22

if.end22:                                         ; preds = %if.then17, %if.then14
  %27 = load %struct.util_est*, %struct.util_est** %new_refs, align 8
  %28 = load i32, i32* %old_size, align 4
  %div23 = udiv i32 %28, 1
  %idx.ext = zext i32 %div23 to i64
  %add.ptr = getelementptr %struct.util_est, %struct.util_est* %27, i64 %idx.ext
  %29 = bitcast %struct.util_est* %add.ptr to i8*
  %30 = load i32, i32* %size.addr, align 4
  %31 = load i32, i32* %old_size, align 4
  %sub = sub i32 %30, %31
  %conv24 = zext i32 %sub to i64
  %mul25 = mul i64 8, %conv24
  %div26 = udiv i64 %mul25, 1
  call void @llvm.memset.p0i8.i64(i8* align 4 %29, i8 0, i64 %div26, i1 false)
  br label %if.end27

if.end27:                                         ; preds = %if.end22, %if.end12
  %32 = load i32, i32* %slot, align 4
  %mul28 = mul i32 %32, 1
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs29 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 4
  store i32 %mul28, i32* %acquired_refs29, align 4
  %34 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs30 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %34, i32 0, i32 5
  %35 = load %struct.util_est*, %struct.util_est** %refs30, align 8
  %36 = bitcast %struct.util_est* %35 to i8*
  call void @kfree(i8* noundef %36) #11
  %37 = load %struct.util_est*, %struct.util_est** %new_refs, align 8
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs31 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %38, i32 0, i32 5
  store %struct.util_est* %37, %struct.util_est** %refs31, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then11, %if.end8, %if.then2
  %39 = load i32, i32* %retval, align 4
  ret i32 %39
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @realloc_stack_state(%struct.bpf_func_state* noundef %state, i32 noundef %size, i1 noundef zeroext %copy_old) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %size.addr = alloca i32, align 4
  %copy_old.addr = alloca i8, align 1
  %old_size = alloca i32, align 4
  %new_stack = alloca %struct.bpf_stack_state*, align 8
  %slot = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %copy_old to i8
  store i8 %frombool, i8* %copy_old.addr, align 1
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 6
  %1 = load i32, i32* %allocated_stack, align 8
  store i32 %1, i32* %old_size, align 4
  %2 = load i32, i32* %size.addr, align 4
  %div = sdiv i32 %2, 8
  store i32 %div, i32* %slot, align 4
  %3 = load i32, i32* %size.addr, align 4
  %4 = load i32, i32* %old_size, align 4
  %cmp = icmp ule i32 %3, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i32, i32* %size.addr, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end9, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load i8, i8* %copy_old.addr, align 1
  %tobool1 = trunc i8 %6 to i1
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %7 = load i32, i32* %slot, align 4
  %mul = mul i32 %7, 8
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 6
  store i32 %mul, i32* %allocated_stack3, align 8
  %9 = load i32, i32* %size.addr, align 4
  %tobool4 = icmp ne i32 %9, 0
  br i1 %tobool4, label %if.end8, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %10 = load i32, i32* %old_size, align 4
  %tobool5 = icmp ne i32 %10, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %land.lhs.true
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 7
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %13 = bitcast %struct.bpf_stack_state* %12 to i8*
  call void @kfree(i8* noundef %13) #11
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 7
  store %struct.bpf_stack_state* null, %struct.bpf_stack_state** %stack7, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %land.lhs.true, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %lor.lhs.false
  %15 = load i32, i32* %slot, align 4
  %conv = sext i32 %15 to i64
  %call = call i8* @kmalloc_array(i64 noundef %conv, i64 noundef 128, i32 noundef 3264) #11
  %16 = bitcast i8* %call to %struct.bpf_stack_state*
  store %struct.bpf_stack_state* %16, %struct.bpf_stack_state** %new_stack, align 8
  %17 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %new_stack, align 8
  %tobool10 = icmp ne %struct.bpf_stack_state* %17, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end9
  store i32 -12, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end9
  %18 = load i8, i8* %copy_old.addr, align 1
  %tobool13 = trunc i8 %18 to i1
  br i1 %tobool13, label %if.then14, label %if.end27

if.then14:                                        ; preds = %if.end12
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 7
  %20 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack15, align 8
  %tobool16 = icmp ne %struct.bpf_stack_state* %20, null
  br i1 %tobool16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.then14
  %21 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %new_stack, align 8
  %22 = bitcast %struct.bpf_stack_state* %21 to i8*
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack18 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 7
  %24 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack18, align 8
  %25 = bitcast %struct.bpf_stack_state* %24 to i8*
  %26 = load i32, i32* %old_size, align 4
  %div19 = udiv i32 %26, 8
  %conv20 = zext i32 %div19 to i64
  %mul21 = mul i64 128, %conv20
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* align 8 %25, i64 %mul21, i1 false)
  br label %if.end22

if.end22:                                         ; preds = %if.then17, %if.then14
  %27 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %new_stack, align 8
  %28 = load i32, i32* %old_size, align 4
  %div23 = udiv i32 %28, 8
  %idx.ext = zext i32 %div23 to i64
  %add.ptr = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %27, i64 %idx.ext
  %29 = bitcast %struct.bpf_stack_state* %add.ptr to i8*
  %30 = load i32, i32* %size.addr, align 4
  %31 = load i32, i32* %old_size, align 4
  %sub = sub i32 %30, %31
  %conv24 = zext i32 %sub to i64
  %mul25 = mul i64 128, %conv24
  %div26 = udiv i64 %mul25, 8
  call void @llvm.memset.p0i8.i64(i8* align 8 %29, i8 0, i64 %div26, i1 false)
  br label %if.end27

if.end27:                                         ; preds = %if.end22, %if.end12
  %32 = load i32, i32* %slot, align 4
  %mul28 = mul i32 %32, 8
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack29 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 6
  store i32 %mul28, i32* %allocated_stack29, align 8
  %34 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack30 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %34, i32 0, i32 7
  %35 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack30, align 8
  %36 = bitcast %struct.bpf_stack_state* %35 to i8*
  call void @kfree(i8* noundef %36) #11
  %37 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %new_stack, align 8
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack31 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %38, i32 0, i32 7
  store %struct.bpf_stack_state* %37, %struct.bpf_stack_state** %stack31, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then11, %if.end8, %if.then2
  %39 = load i32, i32* %retval, align 4
  ret i32 %39
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clear_jmp_history(%struct.bpf_verifier_state* noundef %state) #0 {
entry:
  %state.addr = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_state* %state, %struct.bpf_verifier_state** %state.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 9
  %1 = load %struct.util_est*, %struct.util_est** %jmp_history, align 8
  %2 = bitcast %struct.util_est* %1 to i8*
  call void @kfree(i8* noundef %2) #11
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %jmp_history1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  store %struct.util_est* null, %struct.util_est** %jmp_history1, align 8
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state.addr, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 10
  store i32 0, i32* %jmp_history_cnt, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @is_state_visited(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %new_sl = alloca %struct.bpf_verifier_state_list*, align 8
  %sl = alloca %struct.bpf_verifier_state_list*, align 8
  %pprev = alloca %struct.bpf_verifier_state_list**, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %new = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %err = alloca i32, align 4
  %states_cnt = alloca i32, align 4
  %add_new_state = alloca i8, align 1
  %br = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp109 = alloca i64, align 8
  %__ret_warn_once156 = alloca i32, align 4
  %__ret_warn_on177 = alloca i32, align 4
  %tmp202 = alloca i64, align 8
  %tmp210 = alloca i64, align 8
  %frame266 = alloca %struct.bpf_func_state*, align 8
  %newframe = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  store i32 0, i32* %states_cnt, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %test_state_freq = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 7
  %3 = load i8, i8* %test_state_freq, align 1
  %tobool = trunc i8 %3 to i1
  %4 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %tobool1 = icmp ne i32 %cond, 0
  %frombool = zext i1 %tobool1 to i8
  store i8 %frombool, i8* %add_new_state, align 1
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 1
  %6 = load i32, i32* %prev_insn_idx, align 4
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %last_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 8
  store i32 %6, i32* %last_insn_idx, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 20
  %9 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %10 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %9, i64 %idxprom
  %prune_point = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 8
  %11 = load i8, i8* %prune_point, align 4
  %tobool2 = trunc i8 %11 to i1
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 30
  %13 = load i32, i32* %jmps_processed, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_jmps_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 29
  %15 = load i32, i32* %prev_jmps_processed, align 8
  %sub = sub i32 %13, %15
  %cmp = icmp uge i32 %sub, 2
  br i1 %cmp, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 28
  %17 = load i32, i32* %insn_processed, align 4
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_processed = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 27
  %19 = load i32, i32* %prev_insn_processed, align 8
  %sub3 = sub i32 %17, %19
  %cmp4 = icmp uge i32 %sub3, 8
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true
  store i8 1, i8* %add_new_state, align 1
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %land.lhs.true, %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = load i32, i32* %insn_idx.addr, align 4
  %call = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %20, i32 noundef %21) #11
  store %struct.bpf_verifier_state_list** %call, %struct.bpf_verifier_state_list*** %pprev, align 8
  %22 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  %23 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %22, align 8
  store %struct.bpf_verifier_state_list* %23, %struct.bpf_verifier_state_list** %sl, align 8
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load i32, i32* %insn_idx.addr, align 4
  %26 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  call void @clean_live_states(%struct.bpf_verifier_env* noundef %24, i32 noundef %25, %struct.bpf_verifier_state* noundef %26) #11
  br label %while.cond

while.cond:                                       ; preds = %next121, %if.end119, %if.end6
  %27 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool7 = icmp ne %struct.bpf_verifier_state_list* %27, null
  br i1 %tobool7, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %28 = load i32, i32* %states_cnt, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %states_cnt, align 4
  %29 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %29, i32 0, i32 0
  %insn_idx8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state, i32 0, i32 3
  %30 = load i32, i32* %insn_idx8, align 4
  %31 = load i32, i32* %insn_idx.addr, align 4
  %cmp9 = icmp ne i32 %30, %31
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body
  br label %next121

if.end11:                                         ; preds = %while.body
  %32 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state12 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %32, i32 0, i32 0
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state12, i32 0, i32 2
  %33 = load i32, i32* %branches, align 8
  %tobool13 = icmp ne i32 %33, 0
  br i1 %tobool13, label %if.then14, label %if.end33

if.then14:                                        ; preds = %if.end11
  %34 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state15 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %34, i32 0, i32 0
  %35 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call16 = call zeroext i1 @states_maybe_looping(%struct.bpf_verifier_state* noundef %state15, %struct.bpf_verifier_state* noundef %35) #11
  br i1 %call16, label %land.lhs.true17, label %if.end21

land.lhs.true17:                                  ; preds = %if.then14
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state18 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %37, i32 0, i32 0
  %38 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call19 = call zeroext i1 @states_equal(%struct.bpf_verifier_env* noundef %36, %struct.bpf_verifier_state* noundef %state18, %struct.bpf_verifier_state* noundef %38) #11
  br i1 %call19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true17
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load i32, i32* %insn_idx.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %39, i32 noundef %40, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.102, i64 0, i64 0)) #11
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load i32, i32* %insn_idx.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.113, i64 0, i64 0), i32 noundef %43) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %land.lhs.true17, %if.then14
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed22 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %44, i32 0, i32 30
  %45 = load i32, i32* %jmps_processed22, align 4
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_jmps_processed23 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %46, i32 0, i32 29
  %47 = load i32, i32* %prev_jmps_processed23, align 8
  %sub24 = sub i32 %45, %47
  %cmp25 = icmp ult i32 %sub24, 20
  br i1 %cmp25, label %land.lhs.true26, label %if.end32

land.lhs.true26:                                  ; preds = %if.end21
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %48, i32 0, i32 28
  %49 = load i32, i32* %insn_processed27, align 4
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_processed28 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %50, i32 0, i32 27
  %51 = load i32, i32* %prev_insn_processed28, align 8
  %sub29 = sub i32 %49, %51
  %cmp30 = icmp ult i32 %sub29, 100
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %land.lhs.true26
  store i8 0, i8* %add_new_state, align 1
  br label %if.end32

if.end32:                                         ; preds = %if.then31, %land.lhs.true26, %if.end21
  br label %miss

if.end33:                                         ; preds = %if.end11
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state34 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %53, i32 0, i32 0
  %54 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call35 = call zeroext i1 @states_equal(%struct.bpf_verifier_env* noundef %52, %struct.bpf_verifier_state* noundef %state34, %struct.bpf_verifier_state* noundef %54) #11
  br i1 %call35, label %if.then36, label %if.end53

if.then36:                                        ; preds = %if.end33
  %55 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %hit_cnt = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %55, i32 0, i32 3
  %56 = load i32, i32* %hit_cnt, align 4
  %inc37 = add i32 %56, 1
  store i32 %inc37, i32* %hit_cnt, align 4
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state38 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %58, i32 0, i32 0
  %59 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call39 = call i32 @propagate_liveness(%struct.bpf_verifier_env* noundef %57, %struct.bpf_verifier_state* noundef %state38, %struct.bpf_verifier_state* noundef %59) #11
  store i32 %call39, i32* %err, align 4
  %60 = load i32, i32* %err, align 4
  %tobool40 = icmp ne i32 %60, 0
  br i1 %tobool40, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then36
  br label %cond.end

cond.false:                                       ; preds = %if.then36
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %62 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call41 = call i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %61, %struct.bpf_verifier_state* noundef %62) #11
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond42 = phi i32 [ %60, %cond.true ], [ %call41, %cond.false ]
  store i32 %cond42, i32* %err, align 4
  %63 = load i32, i32* %err, align 4
  %tobool43 = icmp ne i32 %63, 0
  br i1 %tobool43, label %cond.true44, label %cond.false45

cond.true44:                                      ; preds = %cond.end
  br label %cond.end48

cond.false45:                                     ; preds = %cond.end
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state46 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %65, i32 0, i32 0
  %call47 = call i32 @propagate_precision(%struct.bpf_verifier_env* noundef %64, %struct.bpf_verifier_state* noundef %state46) #11
  br label %cond.end48

cond.end48:                                       ; preds = %cond.false45, %cond.true44
  %cond49 = phi i32 [ %63, %cond.true44 ], [ %call47, %cond.false45 ]
  store i32 %cond49, i32* %err, align 4
  %66 = load i32, i32* %err, align 4
  %tobool50 = icmp ne i32 %66, 0
  br i1 %tobool50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %cond.end48
  %67 = load i32, i32* %err, align 4
  store i32 %67, i32* %retval, align 4
  br label %return

if.end52:                                         ; preds = %cond.end48
  store i32 1, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.end33
  br label %miss

miss:                                             ; preds = %if.end53, %if.end32
  %68 = load i8, i8* %add_new_state, align 1
  %tobool54 = trunc i8 %68 to i1
  br i1 %tobool54, label %if.then55, label %if.end57

if.then55:                                        ; preds = %miss
  %69 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %miss_cnt = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %69, i32 0, i32 2
  %70 = load i32, i32* %miss_cnt, align 8
  %inc56 = add i32 %70, 1
  store i32 %inc56, i32* %miss_cnt, align 8
  br label %if.end57

if.end57:                                         ; preds = %if.then55, %miss
  %71 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %miss_cnt58 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %71, i32 0, i32 2
  %72 = load i32, i32* %miss_cnt58, align 8
  %73 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %hit_cnt59 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %73, i32 0, i32 3
  %74 = load i32, i32* %hit_cnt59, align 4
  %mul = mul i32 %74, 3
  %add = add i32 %mul, 3
  %cmp60 = icmp sgt i32 %72, %add
  br i1 %cmp60, label %if.then61, label %if.end120

if.then61:                                        ; preds = %if.end57
  %75 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %75, i32 0, i32 1
  %76 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next, align 8
  %77 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  store %struct.bpf_verifier_state_list* %76, %struct.bpf_verifier_state_list** %77, align 8
  %78 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state62 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %78, i32 0, i32 0
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state62, i32 0, i32 0
  %arrayidx63 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 0
  %79 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx63, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %79, i32 0, i32 0
  %arrayidx64 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx64, i32 0, i32 17
  %80 = load i32, i32* %live, align 8
  %and = and i32 %80, 8
  %tobool65 = icmp ne i32 %and, 0
  br i1 %tobool65, label %if.then66, label %if.else

if.then66:                                        ; preds = %if.then61
  %81 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state67 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %81, i32 0, i32 0
  %branches68 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state67, i32 0, i32 2
  %82 = load i32, i32* %branches68, align 8
  store i32 %82, i32* %br, align 4
  %83 = load i32, i32* %br, align 4
  %tobool69 = icmp ne i32 %83, 0
  %lnot = xor i1 %tobool69, true
  %lnot70 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot70 to i32
  store i32 %lnot.ext, i32* %__ret_warn_once, align 4
  %84 = load i32, i32* %__ret_warn_once, align 4
  %tobool71 = icmp ne i32 %84, 0
  br i1 %tobool71, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then66
  %85 = load i8, i8* @is_state_visited.__warned, align 1
  %tobool72 = trunc i8 %85 to i1
  %lnot73 = xor i1 %tobool72, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then66
  %86 = phi i1 [ false, %if.then66 ], [ %lnot73, %land.rhs ]
  %lnot75 = xor i1 %86, true
  %lnot77 = xor i1 %lnot75, true
  %lnot.ext78 = zext i1 %lnot77 to i32
  %conv = sext i32 %lnot.ext78 to i64
  %tobool79 = icmp ne i64 %conv, 0
  br i1 %tobool79, label %if.then80, label %if.end108

if.then80:                                        ; preds = %land.end
  store i8 1, i8* @is_state_visited.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %87 = load i32, i32* %__ret_warn_on, align 4
  %tobool81 = icmp ne i32 %87, 0
  %lnot82 = xor i1 %tobool81, true
  %lnot84 = xor i1 %lnot82, true
  %lnot.ext85 = zext i1 %lnot84 to i32
  %conv86 = sext i32 %lnot.ext85 to i64
  %tobool87 = icmp ne i64 %conv86, 0
  br i1 %tobool87, label %if.then88, label %if.end101

if.then88:                                        ; preds = %if.then80
  br label %do.body

do.body:                                          ; preds = %if.then88
  br label %do.body89

do.body89:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body89
  %88 = load i32, i32* %br, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.114, i64 0, i64 0), i32 noundef %88) #11
  br label %do.body90

do.body90:                                        ; preds = %do.end
  br label %do.body91

do.body91:                                        ; preds = %do.body90
  br label %do.end92

do.end92:                                         ; preds = %do.body91
  br label %do.body93

do.body93:                                        ; preds = %do.end92
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 11067, i32 2313, i64 12) #10, !srcloc !35
  br label %do.end94

do.end94:                                         ; preds = %do.body93
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 493) #10, !srcloc !36
  br label %do.body95

do.body95:                                        ; preds = %do.end94
  br label %do.end96

do.end96:                                         ; preds = %do.body95
  br label %do.end97

do.end97:                                         ; preds = %do.end96
  br label %do.body98

do.body98:                                        ; preds = %do.end97
  br label %do.end99

do.end99:                                         ; preds = %do.body98
  br label %do.end100

do.end100:                                        ; preds = %do.end99
  br label %if.end101

if.end101:                                        ; preds = %do.end100, %if.then80
  %89 = load i32, i32* %__ret_warn_on, align 4
  %tobool102 = icmp ne i32 %89, 0
  %lnot103 = xor i1 %tobool102, true
  %lnot105 = xor i1 %lnot103, true
  %lnot.ext106 = zext i1 %lnot105 to i32
  %conv107 = sext i32 %lnot.ext106 to i64
  store i64 %conv107, i64* %tmp, align 8
  %90 = load i64, i64* %tmp, align 8
  br label %if.end108

if.end108:                                        ; preds = %if.end101, %land.end
  %91 = load i32, i32* %__ret_warn_once, align 4
  %tobool110 = icmp ne i32 %91, 0
  %lnot111 = xor i1 %tobool110, true
  %lnot113 = xor i1 %lnot111, true
  %lnot.ext114 = zext i1 %lnot113 to i32
  %conv115 = sext i32 %lnot.ext114 to i64
  store i64 %conv115, i64* %tmp109, align 8
  %92 = load i64, i64* %tmp109, align 8
  %93 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state116 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %93, i32 0, i32 0
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %state116, i1 noundef zeroext false) #11
  %94 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %95 = bitcast %struct.bpf_verifier_state_list* %94 to i8*
  call void @kfree(i8* noundef %95) #11
  %96 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %peak_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %96, i32 0, i32 34
  %97 = load i32, i32* %peak_states, align 8
  %dec = add i32 %97, -1
  store i32 %dec, i32* %peak_states, align 8
  br label %if.end119

if.else:                                          ; preds = %if.then61
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %98, i32 0, i32 10
  %99 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %free_list, align 8
  %100 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next117 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %100, i32 0, i32 1
  store %struct.bpf_verifier_state_list* %99, %struct.bpf_verifier_state_list** %next117, align 8
  %101 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %free_list118 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %102, i32 0, i32 10
  store %struct.bpf_verifier_state_list* %101, %struct.bpf_verifier_state_list** %free_list118, align 8
  br label %if.end119

if.end119:                                        ; preds = %if.else, %if.end108
  %103 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  %104 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %103, align 8
  store %struct.bpf_verifier_state_list* %104, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

if.end120:                                        ; preds = %if.end57
  br label %next121

next121:                                          ; preds = %if.end120, %if.then10
  %105 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next122 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %105, i32 0, i32 1
  store %struct.bpf_verifier_state_list** %next122, %struct.bpf_verifier_state_list*** %pprev, align 8
  %106 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %pprev, align 8
  %107 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %106, align 8
  store %struct.bpf_verifier_state_list* %107, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %max_states_per_insn = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %108, i32 0, i32 32
  %109 = load i32, i32* %max_states_per_insn, align 8
  %110 = load i32, i32* %states_cnt, align 4
  %cmp123 = icmp ult i32 %109, %110
  br i1 %cmp123, label %if.then125, label %if.end127

if.then125:                                       ; preds = %while.end
  %111 = load i32, i32* %states_cnt, align 4
  %112 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %max_states_per_insn126 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %112, i32 0, i32 32
  store i32 %111, i32* %max_states_per_insn126, align 8
  br label %if.end127

if.end127:                                        ; preds = %if.then125, %while.end
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %113, i32 0, i32 16
  %114 = load i8, i8* %bpf_capable, align 2
  %tobool128 = trunc i8 %114 to i1
  br i1 %tobool128, label %if.end134, label %land.lhs.true129

land.lhs.true129:                                 ; preds = %if.end127
  %115 = load i32, i32* %states_cnt, align 4
  %cmp130 = icmp sgt i32 %115, 64
  br i1 %cmp130, label %if.then132, label %if.end134

if.then132:                                       ; preds = %land.lhs.true129
  %116 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %117 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call133 = call i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %116, %struct.bpf_verifier_state* noundef %117) #11
  store i32 %call133, i32* %retval, align 4
  br label %return

if.end134:                                        ; preds = %land.lhs.true129, %if.end127
  %118 = load i8, i8* %add_new_state, align 1
  %tobool135 = trunc i8 %118 to i1
  br i1 %tobool135, label %if.end138, label %if.then136

if.then136:                                       ; preds = %if.end134
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %120 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call137 = call i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %119, %struct.bpf_verifier_state* noundef %120) #11
  store i32 %call137, i32* %retval, align 4
  br label %return

if.end138:                                        ; preds = %if.end134
  %call139 = call i8* @kzalloc(i64 noundef 136, i32 noundef 3264) #11
  %121 = bitcast i8* %call139 to %struct.bpf_verifier_state_list*
  store %struct.bpf_verifier_state_list* %121, %struct.bpf_verifier_state_list** %new_sl, align 8
  %122 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %tobool140 = icmp ne %struct.bpf_verifier_state_list* %122, null
  br i1 %tobool140, label %if.end142, label %if.then141

if.then141:                                       ; preds = %if.end138
  store i32 -12, i32* %retval, align 4
  br label %return

if.end142:                                        ; preds = %if.end138
  %123 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %total_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %123, i32 0, i32 33
  %124 = load i32, i32* %total_states, align 4
  %inc143 = add i32 %124, 1
  store i32 %inc143, i32* %total_states, align 4
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %peak_states144 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %125, i32 0, i32 34
  %126 = load i32, i32* %peak_states144, align 8
  %inc145 = add i32 %126, 1
  store i32 %inc145, i32* %peak_states144, align 8
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %jmps_processed146 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %127, i32 0, i32 30
  %128 = load i32, i32* %jmps_processed146, align 4
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_jmps_processed147 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %129, i32 0, i32 29
  store i32 %128, i32* %prev_jmps_processed147, align 8
  %130 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_processed148 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %130, i32 0, i32 28
  %131 = load i32, i32* %insn_processed148, align 4
  %132 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_processed149 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %132, i32 0, i32 27
  store i32 %131, i32* %prev_insn_processed149, align 8
  %133 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %state150 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %133, i32 0, i32 0
  store %struct.bpf_verifier_state* %state150, %struct.bpf_verifier_state** %new, align 8
  %134 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %135 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call151 = call i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %134, %struct.bpf_verifier_state* noundef %135) #11
  store i32 %call151, i32* %err, align 4
  %136 = load i32, i32* %err, align 4
  %tobool152 = icmp ne i32 %136, 0
  br i1 %tobool152, label %if.then153, label %if.end154

if.then153:                                       ; preds = %if.end142
  %137 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %137, i1 noundef zeroext false) #11
  %138 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %139 = bitcast %struct.bpf_verifier_state_list* %138 to i8*
  call void @kfree(i8* noundef %139) #11
  %140 = load i32, i32* %err, align 4
  store i32 %140, i32* %retval, align 4
  br label %return

if.end154:                                        ; preds = %if.end142
  %141 = load i32, i32* %insn_idx.addr, align 4
  %142 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %insn_idx155 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %142, i32 0, i32 3
  store i32 %141, i32* %insn_idx155, align 4
  %143 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %branches157 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %143, i32 0, i32 2
  %144 = load i32, i32* %branches157, align 8
  %cmp158 = icmp ne i32 %144, 1
  %lnot160 = xor i1 %cmp158, true
  %lnot162 = xor i1 %lnot160, true
  %lnot.ext163 = zext i1 %lnot162 to i32
  store i32 %lnot.ext163, i32* %__ret_warn_once156, align 4
  %145 = load i32, i32* %__ret_warn_once156, align 4
  %tobool164 = icmp ne i32 %145, 0
  br i1 %tobool164, label %land.rhs165, label %land.end169

land.rhs165:                                      ; preds = %if.end154
  %146 = load i8, i8* @is_state_visited.__warned.115, align 1
  %tobool166 = trunc i8 %146 to i1
  %lnot167 = xor i1 %tobool166, true
  br label %land.end169

land.end169:                                      ; preds = %land.rhs165, %if.end154
  %147 = phi i1 [ false, %if.end154 ], [ %lnot167, %land.rhs165 ]
  %lnot170 = xor i1 %147, true
  %lnot172 = xor i1 %lnot170, true
  %lnot.ext173 = zext i1 %lnot172 to i32
  %conv174 = sext i32 %lnot.ext173 to i64
  %tobool175 = icmp ne i64 %conv174, 0
  br i1 %tobool175, label %if.then176, label %if.end209

if.then176:                                       ; preds = %land.end169
  store i8 1, i8* @is_state_visited.__warned.115, align 1
  store i32 1, i32* %__ret_warn_on177, align 4
  %148 = load i32, i32* %__ret_warn_on177, align 4
  %tobool178 = icmp ne i32 %148, 0
  %lnot179 = xor i1 %tobool178, true
  %lnot181 = xor i1 %lnot179, true
  %lnot.ext182 = zext i1 %lnot181 to i32
  %conv183 = sext i32 %lnot.ext182 to i64
  %tobool184 = icmp ne i64 %conv183, 0
  br i1 %tobool184, label %if.then185, label %if.end201

if.then185:                                       ; preds = %if.then176
  br label %do.body186

do.body186:                                       ; preds = %if.then185
  br label %do.body187

do.body187:                                       ; preds = %do.body186
  br label %do.end188

do.end188:                                        ; preds = %do.body187
  %149 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %branches189 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %149, i32 0, i32 2
  %150 = load i32, i32* %branches189, align 8
  %151 = load i32, i32* %insn_idx.addr, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.116, i64 0, i64 0), i32 noundef %150, i32 noundef %151) #11
  br label %do.body190

do.body190:                                       ; preds = %do.end188
  br label %do.body191

do.body191:                                       ; preds = %do.body190
  br label %do.end192

do.end192:                                        ; preds = %do.body191
  br label %do.body193

do.body193:                                       ; preds = %do.end192
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 11123, i32 2313, i64 12) #10, !srcloc !37
  br label %do.end194

do.end194:                                        ; preds = %do.body193
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 494) #10, !srcloc !38
  br label %do.body195

do.body195:                                       ; preds = %do.end194
  br label %do.end196

do.end196:                                        ; preds = %do.body195
  br label %do.end197

do.end197:                                        ; preds = %do.end196
  br label %do.body198

do.body198:                                       ; preds = %do.end197
  br label %do.end199

do.end199:                                        ; preds = %do.body198
  br label %do.end200

do.end200:                                        ; preds = %do.end199
  br label %if.end201

if.end201:                                        ; preds = %do.end200, %if.then176
  %152 = load i32, i32* %__ret_warn_on177, align 4
  %tobool203 = icmp ne i32 %152, 0
  %lnot204 = xor i1 %tobool203, true
  %lnot206 = xor i1 %lnot204, true
  %lnot.ext207 = zext i1 %lnot206 to i32
  %conv208 = sext i32 %lnot.ext207 to i64
  store i64 %conv208, i64* %tmp202, align 8
  %153 = load i64, i64* %tmp202, align 8
  br label %if.end209

if.end209:                                        ; preds = %if.end201, %land.end169
  %154 = load i32, i32* %__ret_warn_once156, align 4
  %tobool211 = icmp ne i32 %154, 0
  %lnot212 = xor i1 %tobool211, true
  %lnot214 = xor i1 %lnot212, true
  %lnot.ext215 = zext i1 %lnot214 to i32
  %conv216 = sext i32 %lnot.ext215 to i64
  store i64 %conv216, i64* %tmp210, align 8
  %155 = load i64, i64* %tmp210, align 8
  %156 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %157 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %157, i32 0, i32 1
  store %struct.bpf_verifier_state* %156, %struct.bpf_verifier_state** %parent, align 8
  %158 = load i32, i32* %insn_idx.addr, align 4
  %159 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %first_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %159, i32 0, i32 7
  store i32 %158, i32* %first_insn_idx, align 4
  %160 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  call void @clear_jmp_history(%struct.bpf_verifier_state* noundef %160) #11
  %161 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %162 = load i32, i32* %insn_idx.addr, align 4
  %call217 = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %161, i32 noundef %162) #11
  %163 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %call217, align 8
  %164 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %next218 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %164, i32 0, i32 1
  store %struct.bpf_verifier_state_list* %163, %struct.bpf_verifier_state_list** %next218, align 8
  %165 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %new_sl, align 8
  %166 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %167 = load i32, i32* %insn_idx.addr, align 4
  %call219 = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %166, i32 noundef %167) #11
  store %struct.bpf_verifier_state_list* %165, %struct.bpf_verifier_state_list** %call219, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc258, %if.end209
  %168 = load i32, i32* %j, align 4
  %169 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %169, i32 0, i32 4
  %170 = load i32, i32* %curframe, align 8
  %cmp220 = icmp ule i32 %168, %170
  br i1 %cmp220, label %for.body, label %for.end260

for.body:                                         ; preds = %for.cond
  %171 = load i32, i32* %j, align 4
  %172 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe222 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %172, i32 0, i32 4
  %173 = load i32, i32* %curframe222, align 8
  %cmp223 = icmp ult i32 %171, %173
  %174 = zext i1 %cmp223 to i64
  %cond225 = select i1 %cmp223, i32 6, i32 0
  store i32 %cond225, i32* %i, align 4
  br label %for.cond226

for.cond226:                                      ; preds = %for.inc, %for.body
  %175 = load i32, i32* %i, align 4
  %cmp227 = icmp slt i32 %175, 10
  br i1 %cmp227, label %for.body229, label %for.end

for.body229:                                      ; preds = %for.cond226
  %176 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %frame230 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %176, i32 0, i32 0
  %177 = load i32, i32* %j, align 4
  %idxprom231 = sext i32 %177 to i64
  %arrayidx232 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame230, i64 0, i64 %idxprom231
  %178 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx232, align 8
  %regs233 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %178, i32 0, i32 0
  %179 = load i32, i32* %i, align 4
  %idxprom234 = sext i32 %179 to i64
  %arrayidx235 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs233, i64 0, i64 %idxprom234
  %180 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame236 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %180, i32 0, i32 0
  %181 = load i32, i32* %j, align 4
  %idxprom237 = sext i32 %181 to i64
  %arrayidx238 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame236, i64 0, i64 %idxprom237
  %182 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx238, align 8
  %regs239 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %182, i32 0, i32 0
  %183 = load i32, i32* %i, align 4
  %idxprom240 = sext i32 %183 to i64
  %arrayidx241 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs239, i64 0, i64 %idxprom240
  %parent242 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx241, i32 0, i32 14
  store %struct.bpf_reg_state* %arrayidx235, %struct.bpf_reg_state** %parent242, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body229
  %184 = load i32, i32* %i, align 4
  %inc243 = add i32 %184, 1
  store i32 %inc243, i32* %i, align 4
  br label %for.cond226

for.end:                                          ; preds = %for.cond226
  store i32 0, i32* %i, align 4
  br label %for.cond244

for.cond244:                                      ; preds = %for.inc255, %for.end
  %185 = load i32, i32* %i, align 4
  %cmp245 = icmp slt i32 %185, 10
  br i1 %cmp245, label %for.body247, label %for.end257

for.body247:                                      ; preds = %for.cond244
  %186 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame248 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %186, i32 0, i32 0
  %187 = load i32, i32* %j, align 4
  %idxprom249 = sext i32 %187 to i64
  %arrayidx250 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame248, i64 0, i64 %idxprom249
  %188 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx250, align 8
  %regs251 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %188, i32 0, i32 0
  %189 = load i32, i32* %i, align 4
  %idxprom252 = sext i32 %189 to i64
  %arrayidx253 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs251, i64 0, i64 %idxprom252
  %live254 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx253, i32 0, i32 17
  store i32 0, i32* %live254, align 8
  br label %for.inc255

for.inc255:                                       ; preds = %for.body247
  %190 = load i32, i32* %i, align 4
  %inc256 = add i32 %190, 1
  store i32 %inc256, i32* %i, align 4
  br label %for.cond244

for.end257:                                       ; preds = %for.cond244
  br label %for.inc258

for.inc258:                                       ; preds = %for.end257
  %191 = load i32, i32* %j, align 4
  %inc259 = add i32 %191, 1
  store i32 %inc259, i32* %j, align 4
  br label %for.cond

for.end260:                                       ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond261

for.cond261:                                      ; preds = %for.inc292, %for.end260
  %192 = load i32, i32* %j, align 4
  %193 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe262 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %193, i32 0, i32 4
  %194 = load i32, i32* %curframe262, align 8
  %cmp263 = icmp ule i32 %192, %194
  br i1 %cmp263, label %for.body265, label %for.end294

for.body265:                                      ; preds = %for.cond261
  %195 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame267 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %195, i32 0, i32 0
  %196 = load i32, i32* %j, align 4
  %idxprom268 = sext i32 %196 to i64
  %arrayidx269 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame267, i64 0, i64 %idxprom268
  %197 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx269, align 8
  store %struct.bpf_func_state* %197, %struct.bpf_func_state** %frame266, align 8
  %198 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %new, align 8
  %frame270 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %198, i32 0, i32 0
  %199 = load i32, i32* %j, align 4
  %idxprom271 = sext i32 %199 to i64
  %arrayidx272 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame270, i64 0, i64 %idxprom271
  %200 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx272, align 8
  store %struct.bpf_func_state* %200, %struct.bpf_func_state** %newframe, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond273

for.cond273:                                      ; preds = %for.inc289, %for.body265
  %201 = load i32, i32* %i, align 4
  %202 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame266, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %202, i32 0, i32 6
  %203 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %203, 8
  %cmp274 = icmp slt i32 %201, %div
  br i1 %cmp274, label %for.body276, label %for.end291

for.body276:                                      ; preds = %for.cond273
  %204 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame266, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %204, i32 0, i32 7
  %205 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %206 = load i32, i32* %i, align 4
  %idxprom277 = sext i32 %206 to i64
  %arrayidx278 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %205, i64 %idxprom277
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx278, i32 0, i32 0
  %live279 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 17
  store i32 0, i32* %live279, align 8
  %207 = load %struct.bpf_func_state*, %struct.bpf_func_state** %newframe, align 8
  %stack280 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %207, i32 0, i32 7
  %208 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack280, align 8
  %209 = load i32, i32* %i, align 4
  %idxprom281 = sext i32 %209 to i64
  %arrayidx282 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %208, i64 %idxprom281
  %spilled_ptr283 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx282, i32 0, i32 0
  %210 = load %struct.bpf_func_state*, %struct.bpf_func_state** %frame266, align 8
  %stack284 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %210, i32 0, i32 7
  %211 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack284, align 8
  %212 = load i32, i32* %i, align 4
  %idxprom285 = sext i32 %212 to i64
  %arrayidx286 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %211, i64 %idxprom285
  %spilled_ptr287 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx286, i32 0, i32 0
  %parent288 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr287, i32 0, i32 14
  store %struct.bpf_reg_state* %spilled_ptr283, %struct.bpf_reg_state** %parent288, align 8
  br label %for.inc289

for.inc289:                                       ; preds = %for.body276
  %213 = load i32, i32* %i, align 4
  %inc290 = add i32 %213, 1
  store i32 %inc290, i32* %i, align 4
  br label %for.cond273

for.end291:                                       ; preds = %for.cond273
  br label %for.inc292

for.inc292:                                       ; preds = %for.end291
  %214 = load i32, i32* %j, align 4
  %inc293 = add i32 %214, 1
  store i32 %inc293, i32* %j, align 4
  br label %for.cond261

for.end294:                                       ; preds = %for.cond261
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end294, %if.then153, %if.then141, %if.then136, %if.then132, %if.end52, %if.then51, %if.then20, %if.then
  %215 = load i32, i32* %retval, align 4
  ret i32 %215
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @signal_pending(%struct.task_struct* noundef %p) #0 {
entry:
  %p.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %p, %struct.task_struct** %p.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %p.addr, align 8
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* noundef %0, i32 noundef 2) #11
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %conv2 = trunc i64 %conv to i32
  ret i32 %conv2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @test_ti_thread_flag(%struct.thread_info* noundef %ti, i32 noundef %flag) #0 {
entry:
  %ti.addr = alloca %struct.thread_info*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.thread_info* %ti, %struct.thread_info** %ti.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load i32, i32* %flag.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load %struct.thread_info*, %struct.thread_info** %ti.addr, align 8
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %1, i32 0, i32 0
  %call = call zeroext i1 @test_bit(i64 noundef %conv, i64* noundef %flags) #11
  %conv1 = zext i1 %call to i32
  ret i32 %conv1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_verifier_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %t = alloca i32, align 4
  %i = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  %types_buf = alloca [9 x i8], align 1
  %valid = alloca i8, align 1
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 2
  %1 = load i32, i32* %frameno, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 2
  %5 = load i32, i32* %frameno1, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.134, i64 0, i64 0), i32 noundef %5) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %6, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 0
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 0
  %10 = load i32, i32* %type, align 8
  store i32 %10, i32* %t, align 4
  %11 = load i32, i32* %t, align 4
  %cmp2 = icmp eq i32 %11, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %for.body
  br label %for.inc

if.end4:                                          ; preds = %for.body
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.135, i64 0, i64 0), i32 noundef %14) #11
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 17
  %17 = load i32, i32* %live, align 8
  call void @print_liveness(%struct.bpf_verifier_env* noundef %15, i32 noundef %17) #11
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %t, align 4
  %idxprom5 = zext i32 %20 to i64
  %arrayidx6 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom5
  %21 = load i8*, i8** %arrayidx6, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.136, i64 0, i64 0), i8* noundef %21) #11
  %22 = load i32, i32* %t, align 4
  %cmp7 = icmp eq i32 %22, 1
  br i1 %cmp7, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %if.end4
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 18
  %24 = load i8, i8* %precise, align 4
  %tobool8 = trunc i8 %24 to i1
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %land.lhs.true
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.137, i64 0, i64 0)) #11
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %land.lhs.true, %if.end4
  %27 = load i32, i32* %t, align 4
  %cmp11 = icmp eq i32 %27, 1
  br i1 %cmp11, label %land.lhs.true13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end10
  %28 = load i32, i32* %t, align 4
  %cmp12 = icmp eq i32 %28, 6
  br i1 %cmp12, label %land.lhs.true13, label %if.else

land.lhs.true13:                                  ; preds = %lor.lhs.false, %if.end10
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 5
  %30 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %32, i64 %34) #11
  br i1 %call, label %if.then14, label %if.else

if.then14:                                        ; preds = %land.lhs.true13
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off15, i32 0, i32 0
  %38 = load i64, i64* %value, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 2
  %40 = load i32, i32* %off, align 8
  %conv = sext i32 %40 to i64
  %add = add i64 %38, %conv
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.138, i64 0, i64 0), i64 noundef %add) #11
  br label %if.end139

if.else:                                          ; preds = %land.lhs.true13, %lor.lhs.false
  %41 = load i32, i32* %t, align 4
  %cmp16 = icmp eq i32 %41, 19
  br i1 %cmp16, label %if.then24, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %if.else
  %42 = load i32, i32* %t, align 4
  %cmp19 = icmp eq i32 %42, 20
  br i1 %cmp19, label %if.then24, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %lor.lhs.false18
  %43 = load i32, i32* %t, align 4
  %cmp22 = icmp eq i32 %43, 27
  br i1 %cmp22, label %if.then24, label %if.end26

if.then24:                                        ; preds = %lor.lhs.false21, %lor.lhs.false18, %if.else
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = bitcast %struct.bpf_verifier_env* %44 to i8*
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %47 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 1
  %btf_id = bitcast %struct.bpf_iter_aux_info* %47 to i32*
  %48 = load i32, i32* %btf_id, align 8
  %call25 = call i8* @kernel_type_name(i32 noundef %48) #11
  call void (i8*, i8*, ...) @verbose(i8* noundef %45, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.139, i64 0, i64 0), i8* noundef %call25) #11
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %lor.lhs.false21
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = bitcast %struct.bpf_verifier_env* %49 to i8*
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %51, i32 0, i32 3
  %52 = load i32, i32* %id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %50, i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str.140, i64 0, i64 0), i32 noundef %52) #11
  %53 = load i32, i32* %t, align 4
  %call27 = call zeroext i1 @reg_type_may_be_refcounted_or_null(i32 noundef %53) #11
  br i1 %call27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end26
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 4
  %57 = load i32, i32* %ref_obj_id, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([15 x i8], [15 x i8]* @.str.141, i64 0, i64 0), i32 noundef %57) #11
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end26
  %58 = load i32, i32* %t, align 4
  %cmp30 = icmp ne i32 %58, 1
  br i1 %cmp30, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end29
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = bitcast %struct.bpf_verifier_env* %59 to i8*
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 2
  %62 = load i32, i32* %off33, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %60, i8* noundef getelementptr inbounds ([8 x i8], [8 x i8]* @.str.142, i64 0, i64 0), i32 noundef %62) #11
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end29
  %63 = load i32, i32* %t, align 4
  %call35 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %63) #11
  br i1 %call35, label %if.then36, label %if.else38

if.then36:                                        ; preds = %if.end34
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = bitcast %struct.bpf_verifier_env* %64 to i8*
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 1
  %range = bitcast %struct.bpf_iter_aux_info* %67 to i16*
  %68 = load i16, i16* %range, align 8
  %conv37 = zext i16 %68 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %65, i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str.143, i64 0, i64 0), i32 noundef %conv37) #11
  br label %if.end50

if.else38:                                        ; preds = %if.end34
  %69 = load i32, i32* %t, align 4
  %cmp39 = icmp eq i32 %69, 3
  br i1 %cmp39, label %if.then47, label %lor.lhs.false41

lor.lhs.false41:                                  ; preds = %if.else38
  %70 = load i32, i32* %t, align 4
  %cmp42 = icmp eq i32 %70, 4
  br i1 %cmp42, label %if.then47, label %lor.lhs.false44

lor.lhs.false44:                                  ; preds = %lor.lhs.false41
  %71 = load i32, i32* %t, align 4
  %cmp45 = icmp eq i32 %71, 5
  br i1 %cmp45, label %if.then47, label %if.end49

if.then47:                                        ; preds = %lor.lhs.false44, %lor.lhs.false41, %if.else38
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %73 = bitcast %struct.bpf_verifier_env* %72 to i8*
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 1
  %map_ptr = bitcast %struct.bpf_iter_aux_info* %75 to %struct.bpf_map**
  %76 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %key_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %76, i32 0, i32 4
  %77 = load i32, i32* %key_size, align 4
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %79 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %78, i32 0, i32 1
  %map_ptr48 = bitcast %struct.bpf_iter_aux_info* %79 to %struct.bpf_map**
  %80 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr48, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %80, i32 0, i32 5
  %81 = load i32, i32* %value_size, align 32
  call void (i8*, i8*, ...) @verbose(i8* noundef %73, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.144, i64 0, i64 0), i32 noundef %77, i32 noundef %81) #11
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %lor.lhs.false44
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then36
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off51 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 5
  %83 = bitcast %struct.tnum* %var_off51 to { i64, i64 }*
  %84 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = load i64, i64* %84, align 8
  %86 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = load i64, i64* %86, align 8
  %call52 = call zeroext i1 @tnum_is_const(i64 %85, i64 %87) #11
  br i1 %call52, label %if.then53, label %if.else56

if.then53:                                        ; preds = %if.end50
  %88 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %89 = bitcast %struct.bpf_verifier_env* %88 to i8*
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off54 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %90, i32 0, i32 5
  %value55 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off54, i32 0, i32 0
  %91 = load i64, i64* %value55, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %89, i8* noundef getelementptr inbounds ([10 x i8], [10 x i8]* @.str.145, i64 0, i64 0), i64 noundef %91) #11
  br label %if.end138

if.else56:                                        ; preds = %if.end50
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 6
  %93 = load i64, i64* %smin_value, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %94, i32 0, i32 8
  %95 = load i64, i64* %umin_value, align 8
  %cmp57 = icmp ne i64 %93, %95
  br i1 %cmp57, label %land.lhs.true59, label %if.end65

land.lhs.true59:                                  ; preds = %if.else56
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value60 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %96, i32 0, i32 6
  %97 = load i64, i64* %smin_value60, align 8
  %cmp61 = icmp ne i64 %97, -9223372036854775808
  br i1 %cmp61, label %if.then63, label %if.end65

if.then63:                                        ; preds = %land.lhs.true59
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %99 = bitcast %struct.bpf_verifier_env* %98 to i8*
  %100 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value64 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %100, i32 0, i32 6
  %101 = load i64, i64* %smin_value64, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %99, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.146, i64 0, i64 0), i64 noundef %101) #11
  br label %if.end65

if.end65:                                         ; preds = %if.then63, %land.lhs.true59, %if.else56
  %102 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %102, i32 0, i32 7
  %103 = load i64, i64* %smax_value, align 8
  %104 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %104, i32 0, i32 9
  %105 = load i64, i64* %umax_value, align 8
  %cmp66 = icmp ne i64 %103, %105
  br i1 %cmp66, label %land.lhs.true68, label %if.end74

land.lhs.true68:                                  ; preds = %if.end65
  %106 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value69 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %106, i32 0, i32 7
  %107 = load i64, i64* %smax_value69, align 8
  %cmp70 = icmp ne i64 %107, 9223372036854775807
  br i1 %cmp70, label %if.then72, label %if.end74

if.then72:                                        ; preds = %land.lhs.true68
  %108 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %109 = bitcast %struct.bpf_verifier_env* %108 to i8*
  %110 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %110, i32 0, i32 7
  %111 = load i64, i64* %smax_value73, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %109, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.147, i64 0, i64 0), i64 noundef %111) #11
  br label %if.end74

if.end74:                                         ; preds = %if.then72, %land.lhs.true68, %if.end65
  %112 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %112, i32 0, i32 8
  %113 = load i64, i64* %umin_value75, align 8
  %cmp76 = icmp ne i64 %113, 0
  br i1 %cmp76, label %if.then78, label %if.end80

if.then78:                                        ; preds = %if.end74
  %114 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %115 = bitcast %struct.bpf_verifier_env* %114 to i8*
  %116 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value79 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %116, i32 0, i32 8
  %117 = load i64, i64* %umin_value79, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %115, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.148, i64 0, i64 0), i64 noundef %117) #11
  br label %if.end80

if.end80:                                         ; preds = %if.then78, %if.end74
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 9
  %119 = load i64, i64* %umax_value81, align 8
  %cmp82 = icmp ne i64 %119, -1
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %if.end80
  %120 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %121 = bitcast %struct.bpf_verifier_env* %120 to i8*
  %122 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %122, i32 0, i32 9
  %123 = load i64, i64* %umax_value85, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %121, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.149, i64 0, i64 0), i64 noundef %123) #11
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %if.end80
  %124 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off87 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %124, i32 0, i32 5
  %125 = bitcast %struct.tnum* %var_off87 to { i64, i64 }*
  %126 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %125, i32 0, i32 0
  %127 = load i64, i64* %126, align 8
  %128 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %125, i32 0, i32 1
  %129 = load i64, i64* %128, align 8
  %call88 = call zeroext i1 @tnum_is_unknown(i64 %127, i64 %129) #11
  br i1 %call88, label %if.end93, label %if.then89

if.then89:                                        ; preds = %if.end86
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %130 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off90 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %130, i32 0, i32 5
  %131 = bitcast %struct.tnum* %var_off90 to { i64, i64 }*
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %131, i32 0, i32 0
  %133 = load i64, i64* %132, align 8
  %134 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %131, i32 0, i32 1
  %135 = load i64, i64* %134, align 8
  %call91 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %133, i64 %135) #11
  %136 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %137 = bitcast %struct.bpf_verifier_env* %136 to i8*
  %arraydecay92 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %137, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.150, i64 0, i64 0), i8* noundef %arraydecay92) #11
  br label %if.end93

if.end93:                                         ; preds = %if.then89, %if.end86
  %138 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %138, i32 0, i32 10
  %139 = load i32, i32* %s32_min_value, align 8
  %conv94 = sext i32 %139 to i64
  %140 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %140, i32 0, i32 6
  %141 = load i64, i64* %smin_value95, align 8
  %cmp96 = icmp ne i64 %conv94, %141
  br i1 %cmp96, label %land.lhs.true98, label %if.end104

land.lhs.true98:                                  ; preds = %if.end93
  %142 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_min_value99 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %142, i32 0, i32 10
  %143 = load i32, i32* %s32_min_value99, align 8
  %cmp100 = icmp ne i32 %143, -2147483648
  br i1 %cmp100, label %if.then102, label %if.end104

if.then102:                                       ; preds = %land.lhs.true98
  %144 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %145 = bitcast %struct.bpf_verifier_env* %144 to i8*
  %146 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_min_value103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %146, i32 0, i32 10
  %147 = load i32, i32* %s32_min_value103, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %145, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.151, i64 0, i64 0), i32 noundef %147) #11
  br label %if.end104

if.end104:                                        ; preds = %if.then102, %land.lhs.true98, %if.end93
  %148 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %148, i32 0, i32 11
  %149 = load i32, i32* %s32_max_value, align 4
  %conv105 = sext i32 %149 to i64
  %150 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value106 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %150, i32 0, i32 7
  %151 = load i64, i64* %smax_value106, align 8
  %cmp107 = icmp ne i64 %conv105, %151
  br i1 %cmp107, label %land.lhs.true109, label %if.end115

land.lhs.true109:                                 ; preds = %if.end104
  %152 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_max_value110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %152, i32 0, i32 11
  %153 = load i32, i32* %s32_max_value110, align 4
  %cmp111 = icmp ne i32 %153, 2147483647
  br i1 %cmp111, label %if.then113, label %if.end115

if.then113:                                       ; preds = %land.lhs.true109
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %155 = bitcast %struct.bpf_verifier_env* %154 to i8*
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %s32_max_value114 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i32 0, i32 11
  %157 = load i32, i32* %s32_max_value114, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %155, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.152, i64 0, i64 0), i32 noundef %157) #11
  br label %if.end115

if.end115:                                        ; preds = %if.then113, %land.lhs.true109, %if.end104
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %158, i32 0, i32 12
  %159 = load i32, i32* %u32_min_value, align 8
  %conv116 = zext i32 %159 to i64
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value117 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 8
  %161 = load i64, i64* %umin_value117, align 8
  %cmp118 = icmp ne i64 %conv116, %161
  br i1 %cmp118, label %land.lhs.true120, label %if.end126

land.lhs.true120:                                 ; preds = %if.end115
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_min_value121 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %162, i32 0, i32 12
  %163 = load i32, i32* %u32_min_value121, align 8
  %cmp122 = icmp ne i32 %163, 0
  br i1 %cmp122, label %if.then124, label %if.end126

if.then124:                                       ; preds = %land.lhs.true120
  %164 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %165 = bitcast %struct.bpf_verifier_env* %164 to i8*
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_min_value125 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %166, i32 0, i32 12
  %167 = load i32, i32* %u32_min_value125, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %165, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.153, i64 0, i64 0), i32 noundef %167) #11
  br label %if.end126

if.end126:                                        ; preds = %if.then124, %land.lhs.true120, %if.end115
  %168 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %168, i32 0, i32 13
  %169 = load i32, i32* %u32_max_value, align 4
  %conv127 = zext i32 %169 to i64
  %170 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value128 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %170, i32 0, i32 9
  %171 = load i64, i64* %umax_value128, align 8
  %cmp129 = icmp ne i64 %conv127, %171
  br i1 %cmp129, label %land.lhs.true131, label %if.end137

land.lhs.true131:                                 ; preds = %if.end126
  %172 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_max_value132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %172, i32 0, i32 13
  %173 = load i32, i32* %u32_max_value132, align 4
  %cmp133 = icmp ne i32 %173, -1
  br i1 %cmp133, label %if.then135, label %if.end137

if.then135:                                       ; preds = %land.lhs.true131
  %174 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %175 = bitcast %struct.bpf_verifier_env* %174 to i8*
  %176 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %u32_max_value136 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %176, i32 0, i32 13
  %177 = load i32, i32* %u32_max_value136, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %175, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.154, i64 0, i64 0), i32 noundef %177) #11
  br label %if.end137

if.end137:                                        ; preds = %if.then135, %land.lhs.true131, %if.end126
  br label %if.end138

if.end138:                                        ; preds = %if.end137, %if.then53
  %178 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %179 = bitcast %struct.bpf_verifier_env* %178 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %179, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.155, i64 0, i64 0)) #11
  br label %if.end139

if.end139:                                        ; preds = %if.end138, %if.then14
  br label %for.inc

for.inc:                                          ; preds = %if.end139, %if.then3
  %180 = load i32, i32* %i, align 4
  %inc = add i32 %180, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond140

for.cond140:                                      ; preds = %for.inc219, %for.end
  %181 = load i32, i32* %i, align 4
  %182 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %182, i32 0, i32 6
  %183 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %183, 8
  %cmp141 = icmp slt i32 %181, %div
  br i1 %cmp141, label %for.body143, label %for.end221

for.body143:                                      ; preds = %for.cond140
  store i8 0, i8* %valid, align 1
  store i32 0, i32* %j, align 4
  br label %for.cond144

for.cond144:                                      ; preds = %for.inc167, %for.body143
  %184 = load i32, i32* %j, align 4
  %cmp145 = icmp slt i32 %184, 8
  br i1 %cmp145, label %for.body147, label %for.end169

for.body147:                                      ; preds = %for.cond144
  %185 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %185, i32 0, i32 7
  %186 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %187 = load i32, i32* %i, align 4
  %idxprom148 = sext i32 %187 to i64
  %arrayidx149 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %186, i64 %idxprom148
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx149, i32 0, i32 1
  %188 = load i32, i32* %j, align 4
  %idxprom150 = sext i32 %188 to i64
  %arrayidx151 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom150
  %189 = load i8, i8* %arrayidx151, align 1
  %conv152 = zext i8 %189 to i32
  %cmp153 = icmp ne i32 %conv152, 0
  br i1 %cmp153, label %if.then155, label %if.end156

if.then155:                                       ; preds = %for.body147
  store i8 1, i8* %valid, align 1
  br label %if.end156

if.end156:                                        ; preds = %if.then155, %for.body147
  %190 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack157 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %190, i32 0, i32 7
  %191 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack157, align 8
  %192 = load i32, i32* %i, align 4
  %idxprom158 = sext i32 %192 to i64
  %arrayidx159 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %191, i64 %idxprom158
  %slot_type160 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx159, i32 0, i32 1
  %193 = load i32, i32* %j, align 4
  %idxprom161 = sext i32 %193 to i64
  %arrayidx162 = getelementptr [8 x i8], [8 x i8]* %slot_type160, i64 0, i64 %idxprom161
  %194 = load i8, i8* %arrayidx162, align 1
  %idxprom163 = zext i8 %194 to i64
  %arrayidx164 = getelementptr [4 x i8], [4 x i8]* @slot_type_char, i64 0, i64 %idxprom163
  %195 = load i8, i8* %arrayidx164, align 1
  %196 = load i32, i32* %j, align 4
  %idxprom165 = sext i32 %196 to i64
  %arrayidx166 = getelementptr [9 x i8], [9 x i8]* %types_buf, i64 0, i64 %idxprom165
  store i8 %195, i8* %arrayidx166, align 1
  br label %for.inc167

for.inc167:                                       ; preds = %if.end156
  %197 = load i32, i32* %j, align 4
  %inc168 = add i32 %197, 1
  store i32 %inc168, i32* %j, align 4
  br label %for.cond144

for.end169:                                       ; preds = %for.cond144
  %arrayidx170 = getelementptr [9 x i8], [9 x i8]* %types_buf, i64 0, i64 8
  store i8 0, i8* %arrayidx170, align 1
  %198 = load i8, i8* %valid, align 1
  %tobool171 = trunc i8 %198 to i1
  br i1 %tobool171, label %if.end173, label %if.then172

if.then172:                                       ; preds = %for.end169
  br label %for.inc219

if.end173:                                        ; preds = %for.end169
  %199 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %200 = bitcast %struct.bpf_verifier_env* %199 to i8*
  %201 = load i32, i32* %i, align 4
  %sub = sub i32 0, %201
  %sub174 = sub i32 %sub, 1
  %mul = mul i32 %sub174, 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %200, i8* noundef getelementptr inbounds ([6 x i8], [6 x i8]* @.str.156, i64 0, i64 0), i32 noundef %mul) #11
  %202 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %203 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack175 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %203, i32 0, i32 7
  %204 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack175, align 8
  %205 = load i32, i32* %i, align 4
  %idxprom176 = sext i32 %205 to i64
  %arrayidx177 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %204, i64 %idxprom176
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx177, i32 0, i32 0
  %live178 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 17
  %206 = load i32, i32* %live178, align 8
  call void @print_liveness(%struct.bpf_verifier_env* noundef %202, i32 noundef %206) #11
  %207 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack179 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %207, i32 0, i32 7
  %208 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack179, align 8
  %209 = load i32, i32* %i, align 4
  %idxprom180 = sext i32 %209 to i64
  %arrayidx181 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %208, i64 %idxprom180
  %slot_type182 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx181, i32 0, i32 1
  %arrayidx183 = getelementptr [8 x i8], [8 x i8]* %slot_type182, i64 0, i64 0
  %210 = load i8, i8* %arrayidx183, align 8
  %conv184 = zext i8 %210 to i32
  %cmp185 = icmp eq i32 %conv184, 1
  br i1 %cmp185, label %if.then187, label %if.else216

if.then187:                                       ; preds = %if.end173
  %211 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack188 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %211, i32 0, i32 7
  %212 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack188, align 8
  %213 = load i32, i32* %i, align 4
  %idxprom189 = sext i32 %213 to i64
  %arrayidx190 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %212, i64 %idxprom189
  %spilled_ptr191 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx190, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr191, %struct.bpf_reg_state** %reg, align 8
  %214 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type192 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %214, i32 0, i32 0
  %215 = load i32, i32* %type192, align 8
  store i32 %215, i32* %t, align 4
  %216 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %217 = bitcast %struct.bpf_verifier_env* %216 to i8*
  %218 = load i32, i32* %t, align 4
  %idxprom193 = zext i32 %218 to i64
  %arrayidx194 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom193
  %219 = load i8*, i8** %arrayidx194, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %217, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.136, i64 0, i64 0), i8* noundef %219) #11
  %220 = load i32, i32* %t, align 4
  %cmp195 = icmp eq i32 %220, 1
  br i1 %cmp195, label %land.lhs.true197, label %if.end202

land.lhs.true197:                                 ; preds = %if.then187
  %221 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise198 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %221, i32 0, i32 18
  %222 = load i8, i8* %precise198, align 4
  %tobool199 = trunc i8 %222 to i1
  br i1 %tobool199, label %if.then201, label %if.end202

if.then201:                                       ; preds = %land.lhs.true197
  %223 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %224 = bitcast %struct.bpf_verifier_env* %223 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %224, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.137, i64 0, i64 0)) #11
  br label %if.end202

if.end202:                                        ; preds = %if.then201, %land.lhs.true197, %if.then187
  %225 = load i32, i32* %t, align 4
  %cmp203 = icmp eq i32 %225, 1
  br i1 %cmp203, label %land.lhs.true205, label %if.end215

land.lhs.true205:                                 ; preds = %if.end202
  %226 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off206 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %226, i32 0, i32 5
  %227 = bitcast %struct.tnum* %var_off206 to { i64, i64 }*
  %228 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %227, i32 0, i32 0
  %229 = load i64, i64* %228, align 8
  %230 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %227, i32 0, i32 1
  %231 = load i64, i64* %230, align 8
  %call207 = call zeroext i1 @tnum_is_const(i64 %229, i64 %231) #11
  br i1 %call207, label %if.then209, label %if.end215

if.then209:                                       ; preds = %land.lhs.true205
  %232 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %233 = bitcast %struct.bpf_verifier_env* %232 to i8*
  %234 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off210 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %234, i32 0, i32 5
  %value211 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off210, i32 0, i32 0
  %235 = load i64, i64* %value211, align 8
  %236 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off212 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %236, i32 0, i32 2
  %237 = load i32, i32* %off212, align 8
  %conv213 = sext i32 %237 to i64
  %add214 = add i64 %235, %conv213
  call void (i8*, i8*, ...) @verbose(i8* noundef %233, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.138, i64 0, i64 0), i64 noundef %add214) #11
  br label %if.end215

if.end215:                                        ; preds = %if.then209, %land.lhs.true205, %if.end202
  br label %if.end218

if.else216:                                       ; preds = %if.end173
  %238 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %239 = bitcast %struct.bpf_verifier_env* %238 to i8*
  %arraydecay217 = getelementptr inbounds [9 x i8], [9 x i8]* %types_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %239, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.136, i64 0, i64 0), i8* noundef %arraydecay217) #11
  br label %if.end218

if.end218:                                        ; preds = %if.else216, %if.end215
  br label %for.inc219

for.inc219:                                       ; preds = %if.end218, %if.then172
  %240 = load i32, i32* %i, align 4
  %inc220 = add i32 %240, 1
  store i32 %inc220, i32* %i, align 4
  br label %for.cond140

for.end221:                                       ; preds = %for.cond140
  %241 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %241, i32 0, i32 4
  %242 = load i32, i32* %acquired_refs, align 4
  %tobool222 = icmp ne i32 %242, 0
  br i1 %tobool222, label %land.lhs.true223, label %if.end250

land.lhs.true223:                                 ; preds = %for.end221
  %243 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %243, i32 0, i32 5
  %244 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %arrayidx224 = getelementptr %struct.util_est, %struct.util_est* %244, i64 0
  %id225 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx224, i32 0, i32 0
  %245 = load i32, i32* %id225, align 4
  %tobool226 = icmp ne i32 %245, 0
  br i1 %tobool226, label %if.then227, label %if.end250

if.then227:                                       ; preds = %land.lhs.true223
  %246 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %247 = bitcast %struct.bpf_verifier_env* %246 to i8*
  %248 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs228 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %248, i32 0, i32 5
  %249 = load %struct.util_est*, %struct.util_est** %refs228, align 8
  %arrayidx229 = getelementptr %struct.util_est, %struct.util_est* %249, i64 0
  %id230 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx229, i32 0, i32 0
  %250 = load i32, i32* %id230, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %247, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.157, i64 0, i64 0), i32 noundef %250) #11
  store i32 1, i32* %i, align 4
  br label %for.cond231

for.cond231:                                      ; preds = %for.inc247, %if.then227
  %251 = load i32, i32* %i, align 4
  %252 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs232 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %252, i32 0, i32 4
  %253 = load i32, i32* %acquired_refs232, align 4
  %cmp233 = icmp slt i32 %251, %253
  br i1 %cmp233, label %for.body235, label %for.end249

for.body235:                                      ; preds = %for.cond231
  %254 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs236 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %254, i32 0, i32 5
  %255 = load %struct.util_est*, %struct.util_est** %refs236, align 8
  %256 = load i32, i32* %i, align 4
  %idxprom237 = sext i32 %256 to i64
  %arrayidx238 = getelementptr %struct.util_est, %struct.util_est* %255, i64 %idxprom237
  %id239 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx238, i32 0, i32 0
  %257 = load i32, i32* %id239, align 4
  %tobool240 = icmp ne i32 %257, 0
  br i1 %tobool240, label %if.then241, label %if.end246

if.then241:                                       ; preds = %for.body235
  %258 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %259 = bitcast %struct.bpf_verifier_env* %258 to i8*
  %260 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs242 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %260, i32 0, i32 5
  %261 = load %struct.util_est*, %struct.util_est** %refs242, align 8
  %262 = load i32, i32* %i, align 4
  %idxprom243 = sext i32 %262 to i64
  %arrayidx244 = getelementptr %struct.util_est, %struct.util_est* %261, i64 %idxprom243
  %id245 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx244, i32 0, i32 0
  %263 = load i32, i32* %id245, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %259, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.158, i64 0, i64 0), i32 noundef %263) #11
  br label %if.end246

if.end246:                                        ; preds = %if.then241, %for.body235
  br label %for.inc247

for.inc247:                                       ; preds = %if.end246
  %264 = load i32, i32* %i, align 4
  %inc248 = add i32 %264, 1
  store i32 %inc248, i32* %i, align 4
  br label %for.cond231

for.end249:                                       ; preds = %for.cond231
  br label %if.end250

if.end250:                                        ; preds = %for.end249, %land.lhs.true223, %for.end221
  %265 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %266 = bitcast %struct.bpf_verifier_env* %265 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %266, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.159, i64 0, i64 0)) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @verbose_linfo(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_off, i8* noundef %prefix_fmt, ...) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_off.addr = alloca i32, align 4
  %prefix_fmt.addr = alloca i8*, align 8
  %linfo = alloca %struct.ethtool_pauseparam*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_off, i32* %insn_off.addr, align 4
  store i8* %prefix_fmt, i8** %prefix_fmt.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 22
  %call = call zeroext i1 @bpf_verifier_log_needed(%struct.bpf_verifier_log* noundef %log) #11
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load i32, i32* %insn_off.addr, align 4
  %call1 = call %struct.ethtool_pauseparam* @find_linfo(%struct.bpf_verifier_env* noundef %1, i32 noundef %2) #11
  store %struct.ethtool_pauseparam* %call1, %struct.ethtool_pauseparam** %linfo, align 8
  %3 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %tobool = icmp ne %struct.ethtool_pauseparam* %3, null
  br i1 %tobool, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %4 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_linfo = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 21
  %6 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %prev_linfo, align 8
  %cmp = icmp eq %struct.ethtool_pauseparam* %4, %6
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %7 = load i8*, i8** %prefix_fmt.addr, align 8
  %tobool4 = icmp ne i8* %7, null
  br i1 %tobool4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %if.end3
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay6 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay6)
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log7 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 22
  %9 = load i8*, i8** %prefix_fmt.addr, align 8
  %arraydecay8 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  call void @bpf_verifier_vlog(%struct.bpf_verifier_log* noundef %log7, i8* noundef %9, %struct.__va_list_tag* noundef %arraydecay8) #11
  %arraydecay9 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i64 0, i64 0
  %arraydecay910 = bitcast %struct.__va_list_tag* %arraydecay9 to i8*
  call void @llvm.va_end(i8* %arraydecay910)
  br label %if.end11

if.end11:                                         ; preds = %if.then5, %if.end3
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %12, i32 0, i32 2
  %13 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %13, i32 0, i32 7
  %14 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %14, i32 0, i32 44
  %15 = load %struct.btf*, %struct.btf** %btf, align 8
  %16 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %line_off = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %16, i32 0, i32 2
  %17 = load i32, i32* %line_off, align 4
  %call12 = call i8* @btf_name_by_offset(%struct.btf* noundef %15, i32 noundef %17) #11
  %call13 = call i8* @ltrim(i8* noundef %call12) #11
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.89, i64 0, i64 0), i8* noundef %call13) #11
  %18 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_linfo14 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 21
  store %struct.ethtool_pauseparam* %18, %struct.ethtool_pauseparam** %prev_linfo14, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then2, %if.then
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @print_bpf_insn(%struct.bpf_insn_cbs* noundef, %struct.bpf_insn* noundef, i1 noundef zeroext) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_prog_offload_verify_insn(%struct.bpf_verifier_env* noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_alu_op(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %opcode = alloca i8, align 1
  %err = alloca i32, align 4
  %src_reg141 = alloca %struct.bpf_reg_state*, align 8
  %dst_reg146 = alloca %struct.bpf_reg_state*, align 8
  %size = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 0
  %2 = load i8, i8* %code, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 240
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %opcode, align 1
  %3 = load i8, i8* %opcode, align 1
  %conv2 = zext i8 %3 to i32
  %cmp = icmp eq i32 %conv2, 208
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load i8, i8* %opcode, align 1
  %conv4 = zext i8 %4 to i32
  %cmp5 = icmp eq i32 %conv4, 128
  br i1 %cmp5, label %if.then, label %if.else83

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load i8, i8* %opcode, align 1
  %conv7 = zext i8 %5 to i32
  %cmp8 = icmp eq i32 %conv7, 128
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code11 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code11, align 4
  %conv12 = zext i8 %7 to i32
  %and13 = and i32 %conv12, 8
  %cmp14 = icmp ne i32 %and13, 0
  br i1 %cmp14, label %if.then27, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %if.then10
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv17 = zext i8 %bf.lshr to i32
  %cmp18 = icmp ne i32 %conv17, 0
  br i1 %cmp18, label %if.then27, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false16
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 2
  %10 = load i16, i16* %off, align 2
  %conv21 = sext i16 %10 to i32
  %cmp22 = icmp ne i32 %conv21, 0
  br i1 %cmp22, label %if.then27, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %lor.lhs.false20
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 3
  %12 = load i32, i32* %imm, align 4
  %cmp25 = icmp ne i32 %12, 0
  br i1 %cmp25, label %if.then27, label %if.end

if.then27:                                        ; preds = %lor.lhs.false24, %lor.lhs.false20, %lor.lhs.false16, %if.then10
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.164, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false24
  br label %if.end58

if.else:                                          ; preds = %if.then
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg28 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 1
  %bf.load29 = load i8, i8* %src_reg28, align 1
  %bf.lshr30 = lshr i8 %bf.load29, 4
  %conv31 = zext i8 %bf.lshr30 to i32
  %cmp32 = icmp ne i32 %conv31, 0
  br i1 %cmp32, label %if.then56, label %lor.lhs.false34

lor.lhs.false34:                                  ; preds = %if.else
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 2
  %17 = load i16, i16* %off35, align 2
  %conv36 = sext i16 %17 to i32
  %cmp37 = icmp ne i32 %conv36, 0
  br i1 %cmp37, label %if.then56, label %lor.lhs.false39

lor.lhs.false39:                                  ; preds = %lor.lhs.false34
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm40 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 3
  %19 = load i32, i32* %imm40, align 4
  %cmp41 = icmp ne i32 %19, 16
  br i1 %cmp41, label %land.lhs.true, label %lor.lhs.false50

land.lhs.true:                                    ; preds = %lor.lhs.false39
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 3
  %21 = load i32, i32* %imm43, align 4
  %cmp44 = icmp ne i32 %21, 32
  br i1 %cmp44, label %land.lhs.true46, label %lor.lhs.false50

land.lhs.true46:                                  ; preds = %land.lhs.true
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm47 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 3
  %23 = load i32, i32* %imm47, align 4
  %cmp48 = icmp ne i32 %23, 64
  br i1 %cmp48, label %if.then56, label %lor.lhs.false50

lor.lhs.false50:                                  ; preds = %land.lhs.true46, %land.lhs.true, %lor.lhs.false39
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code51 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 0
  %25 = load i8, i8* %code51, align 4
  %conv52 = zext i8 %25 to i32
  %and53 = and i32 %conv52, 7
  %cmp54 = icmp eq i32 %and53, 7
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %lor.lhs.false50, %land.lhs.true46, %lor.lhs.false34, %if.else
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.165, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end57:                                         ; preds = %lor.lhs.false50
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.end
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load59 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load59, 15
  %conv60 = zext i8 %bf.clear to i32
  %call61 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %28, i32 noundef %conv60, i32 noundef 0) #11
  store i32 %call61, i32* %err, align 4
  %30 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %30, 0
  br i1 %tobool, label %if.then62, label %if.end63

if.then62:                                        ; preds = %if.end58
  %31 = load i32, i32* %err, align 4
  store i32 %31, i32* %retval, align 4
  br label %return

if.end63:                                         ; preds = %if.end58
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg64 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %33, i32 0, i32 1
  %bf.load65 = load i8, i8* %dst_reg64, align 1
  %bf.clear66 = and i8 %bf.load65, 15
  %conv67 = zext i8 %bf.clear66 to i32
  %call68 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %32, i32 noundef %conv67) #11
  br i1 %call68, label %if.then69, label %if.end74

if.then69:                                        ; preds = %if.end63
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg70 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %36, i32 0, i32 1
  %bf.load71 = load i8, i8* %dst_reg70, align 1
  %bf.clear72 = and i8 %bf.load71, 15
  %conv73 = zext i8 %bf.clear72 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.166, i64 0, i64 0), i32 noundef %conv73) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %if.end63
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg75 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 1
  %bf.load76 = load i8, i8* %dst_reg75, align 1
  %bf.clear77 = and i8 %bf.load76, 15
  %conv78 = zext i8 %bf.clear77 to i32
  %call79 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %37, i32 noundef %conv78, i32 noundef 1) #11
  store i32 %call79, i32* %err, align 4
  %39 = load i32, i32* %err, align 4
  %tobool80 = icmp ne i32 %39, 0
  br i1 %tobool80, label %if.then81, label %if.end82

if.then81:                                        ; preds = %if.end74
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %if.end74
  br label %if.end345

if.else83:                                        ; preds = %lor.lhs.false
  %41 = load i8, i8* %opcode, align 1
  %conv84 = zext i8 %41 to i32
  %cmp85 = icmp eq i32 %conv84, 176
  br i1 %cmp85, label %if.then87, label %if.else228

if.then87:                                        ; preds = %if.else83
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code88 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %42, i32 0, i32 0
  %43 = load i8, i8* %code88, align 4
  %conv89 = zext i8 %43 to i32
  %and90 = and i32 %conv89, 8
  %cmp91 = icmp eq i32 %and90, 8
  br i1 %cmp91, label %if.then93, label %if.else112

if.then93:                                        ; preds = %if.then87
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm94 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 3
  %45 = load i32, i32* %imm94, align 4
  %cmp95 = icmp ne i32 %45, 0
  br i1 %cmp95, label %if.then102, label %lor.lhs.false97

lor.lhs.false97:                                  ; preds = %if.then93
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off98 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 2
  %47 = load i16, i16* %off98, align 2
  %conv99 = sext i16 %47 to i32
  %cmp100 = icmp ne i32 %conv99, 0
  br i1 %cmp100, label %if.then102, label %if.end103

if.then102:                                       ; preds = %lor.lhs.false97, %if.then93
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = bitcast %struct.bpf_verifier_env* %48 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %49, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.167, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end103:                                        ; preds = %lor.lhs.false97
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg104 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %51, i32 0, i32 1
  %bf.load105 = load i8, i8* %src_reg104, align 1
  %bf.lshr106 = lshr i8 %bf.load105, 4
  %conv107 = zext i8 %bf.lshr106 to i32
  %call108 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %50, i32 noundef %conv107, i32 noundef 0) #11
  store i32 %call108, i32* %err, align 4
  %52 = load i32, i32* %err, align 4
  %tobool109 = icmp ne i32 %52, 0
  br i1 %tobool109, label %if.then110, label %if.end111

if.then110:                                       ; preds = %if.end103
  %53 = load i32, i32* %err, align 4
  store i32 %53, i32* %retval, align 4
  br label %return

if.end111:                                        ; preds = %if.end103
  br label %if.end126

if.else112:                                       ; preds = %if.then87
  %54 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg113 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %54, i32 0, i32 1
  %bf.load114 = load i8, i8* %src_reg113, align 1
  %bf.lshr115 = lshr i8 %bf.load114, 4
  %conv116 = zext i8 %bf.lshr115 to i32
  %cmp117 = icmp ne i32 %conv116, 0
  br i1 %cmp117, label %if.then124, label %lor.lhs.false119

lor.lhs.false119:                                 ; preds = %if.else112
  %55 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off120 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %55, i32 0, i32 2
  %56 = load i16, i16* %off120, align 2
  %conv121 = sext i16 %56 to i32
  %cmp122 = icmp ne i32 %conv121, 0
  br i1 %cmp122, label %if.then124, label %if.end125

if.then124:                                       ; preds = %lor.lhs.false119, %if.else112
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = bitcast %struct.bpf_verifier_env* %57 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %58, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.167, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end125:                                        ; preds = %lor.lhs.false119
  br label %if.end126

if.end126:                                        ; preds = %if.end125, %if.end111
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg127 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %60, i32 0, i32 1
  %bf.load128 = load i8, i8* %dst_reg127, align 1
  %bf.clear129 = and i8 %bf.load128, 15
  %conv130 = zext i8 %bf.clear129 to i32
  %call131 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %59, i32 noundef %conv130, i32 noundef 2) #11
  store i32 %call131, i32* %err, align 4
  %61 = load i32, i32* %err, align 4
  %tobool132 = icmp ne i32 %61, 0
  br i1 %tobool132, label %if.then133, label %if.end134

if.then133:                                       ; preds = %if.end126
  %62 = load i32, i32* %err, align 4
  store i32 %62, i32* %retval, align 4
  br label %return

if.end134:                                        ; preds = %if.end126
  %63 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code135 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %63, i32 0, i32 0
  %64 = load i8, i8* %code135, align 4
  %conv136 = zext i8 %64 to i32
  %and137 = and i32 %conv136, 8
  %cmp138 = icmp eq i32 %and137, 8
  br i1 %cmp138, label %if.then140, label %if.else194

if.then140:                                       ; preds = %if.end134
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %66 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg142 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %66, i32 0, i32 1
  %bf.load143 = load i8, i8* %src_reg142, align 1
  %bf.lshr144 = lshr i8 %bf.load143, 4
  %conv145 = zext i8 %bf.lshr144 to i32
  %idx.ext = sext i32 %conv145 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %src_reg141, align 8
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %68 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg147 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %68, i32 0, i32 1
  %bf.load148 = load i8, i8* %dst_reg147, align 1
  %bf.clear149 = and i8 %bf.load148, 15
  %conv150 = zext i8 %bf.clear149 to i32
  %idx.ext151 = sext i32 %conv150 to i64
  %add.ptr152 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i64 %idx.ext151
  store %struct.bpf_reg_state* %add.ptr152, %struct.bpf_reg_state** %dst_reg146, align 8
  %69 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code153 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %69, i32 0, i32 0
  %70 = load i8, i8* %code153, align 4
  %conv154 = zext i8 %70 to i32
  %and155 = and i32 %conv154, 7
  %cmp156 = icmp eq i32 %and155, 7
  br i1 %cmp156, label %if.then158, label %if.else166

if.then158:                                       ; preds = %if.then140
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 0
  %72 = load i32, i32* %type, align 8
  %cmp159 = icmp eq i32 %72, 1
  br i1 %cmp159, label %land.lhs.true161, label %if.end165

land.lhs.true161:                                 ; preds = %if.then158
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %73, i32 0, i32 3
  %74 = load i32, i32* %id, align 4
  %tobool162 = icmp ne i32 %74, 0
  br i1 %tobool162, label %if.end165, label %if.then163

if.then163:                                       ; preds = %land.lhs.true161
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %75, i32 0, i32 13
  %76 = load i32, i32* %id_gen, align 4
  %inc = add i32 %76, 1
  store i32 %inc, i32* %id_gen, align 4
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %id164 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %77, i32 0, i32 3
  store i32 %inc, i32* %id164, align 4
  br label %if.end165

if.end165:                                        ; preds = %if.then163, %land.lhs.true161, %if.then158
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %80 = bitcast %struct.bpf_reg_state* %78 to i8*
  %81 = bitcast %struct.bpf_reg_state* %79 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %80, i8* align 8 %81, i64 120, i1 false)
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 17
  %83 = load i32, i32* %live, align 8
  %or = or i32 %83, 4
  store i32 %or, i32* %live, align 8
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %84, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  br label %if.end193

if.else166:                                       ; preds = %if.then140
  %85 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %86 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg167 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %86, i32 0, i32 1
  %bf.load168 = load i8, i8* %src_reg167, align 1
  %bf.lshr169 = lshr i8 %bf.load168, 4
  %conv170 = zext i8 %bf.lshr169 to i32
  %call171 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %85, i32 noundef %conv170) #11
  br i1 %call171, label %if.then172, label %if.else177

if.then172:                                       ; preds = %if.else166
  %87 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %88 = bitcast %struct.bpf_verifier_env* %87 to i8*
  %89 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg173 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %89, i32 0, i32 1
  %bf.load174 = load i8, i8* %src_reg173, align 1
  %bf.lshr175 = lshr i8 %bf.load174, 4
  %conv176 = zext i8 %bf.lshr175 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %88, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.168, i64 0, i64 0), i32 noundef %conv176) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.else177:                                       ; preds = %if.else166
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %type178 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %90, i32 0, i32 0
  %91 = load i32, i32* %type178, align 8
  %cmp179 = icmp eq i32 %91, 1
  br i1 %cmp179, label %if.then181, label %if.else186

if.then181:                                       ; preds = %if.else177
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg141, align 8
  %94 = bitcast %struct.bpf_reg_state* %92 to i8*
  %95 = bitcast %struct.bpf_reg_state* %93 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %94, i8* align 8 %95, i64 120, i1 false)
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %id182 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %96, i32 0, i32 3
  store i32 0, i32* %id182, align 4
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %live183 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 17
  %98 = load i32, i32* %live183, align 8
  %or184 = or i32 %98, 4
  store i32 %or184, i32* %live183, align 8
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %99, i32 0, i32 0
  %100 = load i32, i32* %insn_idx, align 8
  %add = add i32 %100, 1
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  %subreg_def185 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %101, i32 0, i32 16
  store i32 %add, i32* %subreg_def185, align 4
  br label %if.end191

if.else186:                                       ; preds = %if.else177
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %104 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg187 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %104, i32 0, i32 1
  %bf.load188 = load i8, i8* %dst_reg187, align 1
  %bf.clear189 = and i8 %bf.load188, 15
  %conv190 = zext i8 %bf.clear189 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %102, %struct.bpf_reg_state* noundef %103, i32 noundef %conv190) #11
  br label %if.end191

if.end191:                                        ; preds = %if.else186, %if.then181
  br label %if.end192

if.end192:                                        ; preds = %if.end191
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg146, align 8
  call void @zext_32_to_64(%struct.bpf_reg_state* noundef %105) #11
  br label %if.end193

if.end193:                                        ; preds = %if.end192, %if.end165
  br label %if.end227

if.else194:                                       ; preds = %if.end134
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %107 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %108 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg195 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %108, i32 0, i32 1
  %bf.load196 = load i8, i8* %dst_reg195, align 1
  %bf.clear197 = and i8 %bf.load196, 15
  %conv198 = zext i8 %bf.clear197 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %106, %struct.bpf_reg_state* noundef %107, i32 noundef %conv198) #11
  %109 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %110 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg199 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %110, i32 0, i32 1
  %bf.load200 = load i8, i8* %dst_reg199, align 1
  %bf.clear201 = and i8 %bf.load200, 15
  %idxprom = zext i8 %bf.clear201 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %109, i64 %idxprom
  %type202 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  store i32 1, i32* %type202, align 8
  %111 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code203 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %111, i32 0, i32 0
  %112 = load i8, i8* %code203, align 4
  %conv204 = zext i8 %112 to i32
  %and205 = and i32 %conv204, 7
  %cmp206 = icmp eq i32 %and205, 7
  br i1 %cmp206, label %if.then208, label %if.else217

if.then208:                                       ; preds = %if.else194
  %113 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %114 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg209 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %114, i32 0, i32 1
  %bf.load210 = load i8, i8* %dst_reg209, align 1
  %bf.clear211 = and i8 %bf.load210, 15
  %conv212 = zext i8 %bf.clear211 to i32
  %idx.ext213 = sext i32 %conv212 to i64
  %add.ptr214 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %113, i64 %idx.ext213
  %115 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm215 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %115, i32 0, i32 3
  %116 = load i32, i32* %imm215, align 4
  %conv216 = sext i32 %116 to i64
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %add.ptr214, i64 noundef %conv216) #11
  br label %if.end226

if.else217:                                       ; preds = %if.else194
  %117 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %118 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg218 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %118, i32 0, i32 1
  %bf.load219 = load i8, i8* %dst_reg218, align 1
  %bf.clear220 = and i8 %bf.load219, 15
  %conv221 = zext i8 %bf.clear220 to i32
  %idx.ext222 = sext i32 %conv221 to i64
  %add.ptr223 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %117, i64 %idx.ext222
  %119 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm224 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %119, i32 0, i32 3
  %120 = load i32, i32* %imm224, align 4
  %conv225 = zext i32 %120 to i64
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %add.ptr223, i64 noundef %conv225) #11
  br label %if.end226

if.end226:                                        ; preds = %if.else217, %if.then208
  br label %if.end227

if.end227:                                        ; preds = %if.end226, %if.end193
  br label %if.end344

if.else228:                                       ; preds = %if.else83
  %121 = load i8, i8* %opcode, align 1
  %conv229 = zext i8 %121 to i32
  %cmp230 = icmp sgt i32 %conv229, 208
  br i1 %cmp230, label %if.then232, label %if.else234

if.then232:                                       ; preds = %if.else228
  %122 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %123 = bitcast %struct.bpf_verifier_env* %122 to i8*
  %124 = load i8, i8* %opcode, align 1
  %conv233 = zext i8 %124 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %123, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.169, i64 0, i64 0), i32 noundef %conv233) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.else234:                                       ; preds = %if.else228
  %125 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code235 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %125, i32 0, i32 0
  %126 = load i8, i8* %code235, align 4
  %conv236 = zext i8 %126 to i32
  %and237 = and i32 %conv236, 8
  %cmp238 = icmp eq i32 %and237, 8
  br i1 %cmp238, label %if.then240, label %if.else259

if.then240:                                       ; preds = %if.else234
  %127 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm241 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %127, i32 0, i32 3
  %128 = load i32, i32* %imm241, align 4
  %cmp242 = icmp ne i32 %128, 0
  br i1 %cmp242, label %if.then249, label %lor.lhs.false244

lor.lhs.false244:                                 ; preds = %if.then240
  %129 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off245 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %129, i32 0, i32 2
  %130 = load i16, i16* %off245, align 2
  %conv246 = sext i16 %130 to i32
  %cmp247 = icmp ne i32 %conv246, 0
  br i1 %cmp247, label %if.then249, label %if.end250

if.then249:                                       ; preds = %lor.lhs.false244, %if.then240
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %132 = bitcast %struct.bpf_verifier_env* %131 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %132, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.170, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end250:                                        ; preds = %lor.lhs.false244
  %133 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %134 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg251 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %134, i32 0, i32 1
  %bf.load252 = load i8, i8* %src_reg251, align 1
  %bf.lshr253 = lshr i8 %bf.load252, 4
  %conv254 = zext i8 %bf.lshr253 to i32
  %call255 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %133, i32 noundef %conv254, i32 noundef 0) #11
  store i32 %call255, i32* %err, align 4
  %135 = load i32, i32* %err, align 4
  %tobool256 = icmp ne i32 %135, 0
  br i1 %tobool256, label %if.then257, label %if.end258

if.then257:                                       ; preds = %if.end250
  %136 = load i32, i32* %err, align 4
  store i32 %136, i32* %retval, align 4
  br label %return

if.end258:                                        ; preds = %if.end250
  br label %if.end273

if.else259:                                       ; preds = %if.else234
  %137 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg260 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %137, i32 0, i32 1
  %bf.load261 = load i8, i8* %src_reg260, align 1
  %bf.lshr262 = lshr i8 %bf.load261, 4
  %conv263 = zext i8 %bf.lshr262 to i32
  %cmp264 = icmp ne i32 %conv263, 0
  br i1 %cmp264, label %if.then271, label %lor.lhs.false266

lor.lhs.false266:                                 ; preds = %if.else259
  %138 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off267 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %138, i32 0, i32 2
  %139 = load i16, i16* %off267, align 2
  %conv268 = sext i16 %139 to i32
  %cmp269 = icmp ne i32 %conv268, 0
  br i1 %cmp269, label %if.then271, label %if.end272

if.then271:                                       ; preds = %lor.lhs.false266, %if.else259
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %141 = bitcast %struct.bpf_verifier_env* %140 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %141, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.170, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end272:                                        ; preds = %lor.lhs.false266
  br label %if.end273

if.end273:                                        ; preds = %if.end272, %if.end258
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %143 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg274 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %143, i32 0, i32 1
  %bf.load275 = load i8, i8* %dst_reg274, align 1
  %bf.clear276 = and i8 %bf.load275, 15
  %conv277 = zext i8 %bf.clear276 to i32
  %call278 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %142, i32 noundef %conv277, i32 noundef 0) #11
  store i32 %call278, i32* %err, align 4
  %144 = load i32, i32* %err, align 4
  %tobool279 = icmp ne i32 %144, 0
  br i1 %tobool279, label %if.then280, label %if.end281

if.then280:                                       ; preds = %if.end273
  %145 = load i32, i32* %err, align 4
  store i32 %145, i32* %retval, align 4
  br label %return

if.end281:                                        ; preds = %if.end273
  %146 = load i8, i8* %opcode, align 1
  %conv282 = zext i8 %146 to i32
  %cmp283 = icmp eq i32 %conv282, 144
  br i1 %cmp283, label %land.lhs.true289, label %lor.lhs.false285

lor.lhs.false285:                                 ; preds = %if.end281
  %147 = load i8, i8* %opcode, align 1
  %conv286 = zext i8 %147 to i32
  %cmp287 = icmp eq i32 %conv286, 48
  br i1 %cmp287, label %land.lhs.true289, label %if.end300

land.lhs.true289:                                 ; preds = %lor.lhs.false285, %if.end281
  %148 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code290 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %148, i32 0, i32 0
  %149 = load i8, i8* %code290, align 4
  %conv291 = zext i8 %149 to i32
  %and292 = and i32 %conv291, 8
  %cmp293 = icmp eq i32 %and292, 0
  br i1 %cmp293, label %land.lhs.true295, label %if.end300

land.lhs.true295:                                 ; preds = %land.lhs.true289
  %150 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm296 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %150, i32 0, i32 3
  %151 = load i32, i32* %imm296, align 4
  %cmp297 = icmp eq i32 %151, 0
  br i1 %cmp297, label %if.then299, label %if.end300

if.then299:                                       ; preds = %land.lhs.true295
  %152 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %153 = bitcast %struct.bpf_verifier_env* %152 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %153, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.171, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end300:                                        ; preds = %land.lhs.true295, %land.lhs.true289, %lor.lhs.false285
  %154 = load i8, i8* %opcode, align 1
  %conv301 = zext i8 %154 to i32
  %cmp302 = icmp eq i32 %conv301, 96
  br i1 %cmp302, label %land.lhs.true312, label %lor.lhs.false304

lor.lhs.false304:                                 ; preds = %if.end300
  %155 = load i8, i8* %opcode, align 1
  %conv305 = zext i8 %155 to i32
  %cmp306 = icmp eq i32 %conv305, 112
  br i1 %cmp306, label %land.lhs.true312, label %lor.lhs.false308

lor.lhs.false308:                                 ; preds = %lor.lhs.false304
  %156 = load i8, i8* %opcode, align 1
  %conv309 = zext i8 %156 to i32
  %cmp310 = icmp eq i32 %conv309, 192
  br i1 %cmp310, label %land.lhs.true312, label %if.end334

land.lhs.true312:                                 ; preds = %lor.lhs.false308, %lor.lhs.false304, %if.end300
  %157 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code313 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %157, i32 0, i32 0
  %158 = load i8, i8* %code313, align 4
  %conv314 = zext i8 %158 to i32
  %and315 = and i32 %conv314, 8
  %cmp316 = icmp eq i32 %and315, 0
  br i1 %cmp316, label %if.then318, label %if.end334

if.then318:                                       ; preds = %land.lhs.true312
  %159 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code319 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %159, i32 0, i32 0
  %160 = load i8, i8* %code319, align 4
  %conv320 = zext i8 %160 to i32
  %and321 = and i32 %conv320, 7
  %cmp322 = icmp eq i32 %and321, 7
  %161 = zext i1 %cmp322 to i64
  %cond = select i1 %cmp322, i32 64, i32 32
  store i32 %cond, i32* %size, align 4
  %162 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm324 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %162, i32 0, i32 3
  %163 = load i32, i32* %imm324, align 4
  %cmp325 = icmp slt i32 %163, 0
  br i1 %cmp325, label %if.then331, label %lor.lhs.false327

lor.lhs.false327:                                 ; preds = %if.then318
  %164 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm328 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %164, i32 0, i32 3
  %165 = load i32, i32* %imm328, align 4
  %166 = load i32, i32* %size, align 4
  %cmp329 = icmp sge i32 %165, %166
  br i1 %cmp329, label %if.then331, label %if.end333

if.then331:                                       ; preds = %lor.lhs.false327, %if.then318
  %167 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %168 = bitcast %struct.bpf_verifier_env* %167 to i8*
  %169 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm332 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %169, i32 0, i32 3
  %170 = load i32, i32* %imm332, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %168, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.172, i64 0, i64 0), i32 noundef %170) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end333:                                        ; preds = %lor.lhs.false327
  br label %if.end334

if.end334:                                        ; preds = %if.end333, %land.lhs.true312, %lor.lhs.false308
  %171 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %172 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg335 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %172, i32 0, i32 1
  %bf.load336 = load i8, i8* %dst_reg335, align 1
  %bf.clear337 = and i8 %bf.load336, 15
  %conv338 = zext i8 %bf.clear337 to i32
  %call339 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %171, i32 noundef %conv338, i32 noundef 2) #11
  store i32 %call339, i32* %err, align 4
  %173 = load i32, i32* %err, align 4
  %tobool340 = icmp ne i32 %173, 0
  br i1 %tobool340, label %if.then341, label %if.end342

if.then341:                                       ; preds = %if.end334
  %174 = load i32, i32* %err, align 4
  store i32 %174, i32* %retval, align 4
  br label %return

if.end342:                                        ; preds = %if.end334
  %175 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %176 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call343 = call i32 @adjust_reg_min_max_vals(%struct.bpf_verifier_env* noundef %175, %struct.bpf_insn* noundef %176) #11
  store i32 %call343, i32* %retval, align 4
  br label %return

if.end344:                                        ; preds = %if.end227
  br label %if.end345

if.end345:                                        ; preds = %if.end344, %if.end82
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end345, %if.end342, %if.then341, %if.then331, %if.then299, %if.then280, %if.then271, %if.then257, %if.then249, %if.then232, %if.then172, %if.then133, %if.then124, %if.then110, %if.then102, %if.then81, %if.then69, %if.then62, %if.then56, %if.then27
  %177 = load i32, i32* %retval, align 4
  ret i32 %177
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %t) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %rw64 = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 2
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 0
  %9 = load i32, i32* %insn_idx, align 8
  %idx.ext = zext i32 %9 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %insn, align 8
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay2, %struct.bpf_reg_state** %regs, align 8
  %11 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %11, 11
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([16 x i8], [16 x i8]* @.str.203, i64 0, i64 0), i32 noundef %14) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %16 = load i32, i32* %regno.addr, align 4
  %idxprom3 = zext i32 %16 to i64
  %arrayidx4 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i64 %idxprom3
  store %struct.bpf_reg_state* %arrayidx4, %struct.bpf_reg_state** %reg, align 8
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %19 = load i32, i32* %regno.addr, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %21 = load i32, i32* %t.addr, align 4
  %call = call zeroext i1 @is_reg64(%struct.bpf_verifier_env* noundef %17, %struct.bpf_insn* noundef %18, i32 noundef %19, %struct.bpf_reg_state* noundef %20, i32 noundef %21) #11
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %rw64, align 1
  %22 = load i32, i32* %t.addr, align 4
  %cmp5 = icmp eq i32 %22, 0
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 0
  %24 = load i32, i32* %type, align 8
  %cmp7 = icmp eq i32 %24, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.then6
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.204, i64 0, i64 0), i32 noundef %27) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.then6
  %28 = load i32, i32* %regno.addr, align 4
  %cmp10 = icmp eq i32 %28, 10
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  store i32 0, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end9
  %29 = load i8, i8* %rw64, align 1
  %tobool = trunc i8 %29 to i1
  br i1 %tobool, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end12
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @mark_insn_zext(%struct.bpf_verifier_env* noundef %30, %struct.bpf_reg_state* noundef %31) #11
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end12
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 14
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %36 = load i8, i8* %rw64, align 1
  %tobool15 = trunc i8 %36 to i1
  %37 = zext i1 %tobool15 to i64
  %cond = select i1 %tobool15, i32 2, i32 1
  %conv = trunc i32 %cond to i8
  %call16 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %32, %struct.bpf_reg_state* noundef %33, %struct.bpf_reg_state* noundef %35, i8 noundef zeroext %conv) #11
  store i32 %call16, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end
  %38 = load i32, i32* %regno.addr, align 4
  %cmp17 = icmp eq i32 %38, 10
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.else
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = bitcast %struct.bpf_verifier_env* %39 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %40, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.205, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.else
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 17
  %42 = load i32, i32* %live, align 8
  %or = or i32 %42, 4
  store i32 %or, i32* %live, align 8
  %43 = load i8, i8* %rw64, align 1
  %tobool21 = trunc i8 %43 to i1
  br i1 %tobool21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end20
  br label %cond.end

cond.false:                                       ; preds = %if.end20
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx23 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %44, i32 0, i32 0
  %45 = load i32, i32* %insn_idx23, align 8
  %add = add i32 %45, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond24 = phi i32 [ 0, %cond.true ], [ %add, %cond.false ]
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 16
  store i32 %cond24, i32* %subreg_def, align 4
  %47 = load i32, i32* %t.addr, align 4
  %cmp25 = icmp eq i32 %47, 1
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %cond.end
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %50 = load i32, i32* %regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %48, %struct.bpf_reg_state* noundef %49, i32 noundef %50) #11
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %cond.end
  br label %if.end29

if.end29:                                         ; preds = %if.end28
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end29, %if.then19, %if.end14, %if.then11, %if.then8, %if.then
  %51 = load i32, i32* %retval, align 4
  ret i32 %51
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_mem_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %regno, i32 noundef %off, i32 noundef %bpf_size, i32 noundef %t, i32 noundef %value_regno, i1 noundef zeroext %strict_alignment_once) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %bpf_size.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %strict_alignment_once.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %size = alloca i32, align 4
  %err = alloca i32, align 4
  %bytes = alloca i32, align 4
  %tmp = alloca i32, align 4
  %map = alloca %struct.bpf_map*, align 8
  %map_off = alloca i32, align 4
  %val = alloca i64, align 8
  %reg_type = alloca i32, align 4
  %btf_id = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %bpf_size, i32* %bpf_size.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  %frombool = zext i1 %strict_alignment_once to i8
  store i8 %frombool, i8* %strict_alignment_once.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %2 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  store i32 0, i32* %err, align 4
  store i32 -22, i32* %bytes, align 4
  %3 = load i32, i32* %bpf_size.addr, align 4
  %cmp = icmp eq i32 %3, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %bytes, align 4
  br label %if.end11

if.else:                                          ; preds = %entry
  %4 = load i32, i32* %bpf_size.addr, align 4
  %cmp1 = icmp eq i32 %4, 8
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  store i32 2, i32* %bytes, align 4
  br label %if.end10

if.else3:                                         ; preds = %if.else
  %5 = load i32, i32* %bpf_size.addr, align 4
  %cmp4 = icmp eq i32 %5, 0
  br i1 %cmp4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else3
  store i32 4, i32* %bytes, align 4
  br label %if.end9

if.else6:                                         ; preds = %if.else3
  %6 = load i32, i32* %bpf_size.addr, align 4
  %cmp7 = icmp eq i32 %6, 24
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else6
  store i32 8, i32* %bytes, align 4
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.else6
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then5
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.then2
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then
  %7 = load i32, i32* %bytes, align 4
  store i32 %7, i32* %tmp, align 4
  %8 = load i32, i32* %tmp, align 4
  store i32 %8, i32* %size, align 4
  %9 = load i32, i32* %size, align 4
  %cmp12 = icmp slt i32 %9, 0
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  %10 = load i32, i32* %size, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end11
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size, align 4
  %15 = load i8, i8* %strict_alignment_once.addr, align 1
  %tobool = trunc i8 %15 to i1
  %call15 = call i32 @check_ptr_alignment(%struct.bpf_verifier_env* noundef %11, %struct.bpf_reg_state* noundef %12, i32 noundef %13, i32 noundef %14, i1 noundef zeroext %tobool) #11
  store i32 %call15, i32* %err, align 4
  %16 = load i32, i32* %err, align 4
  %tobool16 = icmp ne i32 %16, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  %17 = load i32, i32* %err, align 4
  store i32 %17, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end14
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 2
  %19 = load i32, i32* %off19, align 8
  %20 = load i32, i32* %off.addr, align 4
  %add = add i32 %20, %19
  store i32 %add, i32* %off.addr, align 4
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  %22 = load i32, i32* %type, align 8
  %cmp20 = icmp eq i32 %22, 4
  br i1 %cmp20, label %if.then21, label %if.else58

if.then21:                                        ; preds = %if.end18
  %23 = load i32, i32* %t.addr, align 4
  %cmp22 = icmp eq i32 %23, 2
  br i1 %cmp22, label %land.lhs.true, label %if.end27

land.lhs.true:                                    ; preds = %if.then21
  %24 = load i32, i32* %value_regno.addr, align 4
  %cmp23 = icmp sge i32 %24, 0
  br i1 %cmp23, label %land.lhs.true24, label %if.end27

land.lhs.true24:                                  ; preds = %land.lhs.true
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load i32, i32* %value_regno.addr, align 4
  %call25 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %25, i32 noundef %26) #11
  br i1 %call25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %land.lhs.true24
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = bitcast %struct.bpf_verifier_env* %27 to i8*
  %29 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %28, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.206, i64 0, i64 0), i32 noundef %29) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end27:                                         ; preds = %land.lhs.true24, %land.lhs.true, %if.then21
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load i32, i32* %regno.addr, align 4
  %32 = load i32, i32* %off.addr, align 4
  %33 = load i32, i32* %size, align 4
  %34 = load i32, i32* %t.addr, align 4
  %call28 = call i32 @check_map_access_type(%struct.bpf_verifier_env* noundef %30, i32 noundef %31, i32 noundef %32, i32 noundef %33, i32 noundef %34) #11
  store i32 %call28, i32* %err, align 4
  %35 = load i32, i32* %err, align 4
  %tobool29 = icmp ne i32 %35, 0
  br i1 %tobool29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end27
  %36 = load i32, i32* %err, align 4
  store i32 %36, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end27
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = load i32, i32* %regno.addr, align 4
  %39 = load i32, i32* %off.addr, align 4
  %40 = load i32, i32* %size, align 4
  %call32 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %37, i32 noundef %38, i32 noundef %39, i32 noundef %40, i1 noundef zeroext false) #11
  store i32 %call32, i32* %err, align 4
  %41 = load i32, i32* %err, align 4
  %tobool33 = icmp ne i32 %41, 0
  br i1 %tobool33, label %if.end57, label %land.lhs.true34

land.lhs.true34:                                  ; preds = %if.end31
  %42 = load i32, i32* %t.addr, align 4
  %cmp35 = icmp eq i32 %42, 1
  br i1 %cmp35, label %land.lhs.true36, label %if.end57

land.lhs.true36:                                  ; preds = %land.lhs.true34
  %43 = load i32, i32* %value_regno.addr, align 4
  %cmp37 = icmp sge i32 %43, 0
  br i1 %cmp37, label %if.then38, label %if.end57

if.then38:                                        ; preds = %land.lhs.true36
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 1
  %map_ptr = bitcast %struct.bpf_iter_aux_info* %45 to %struct.bpf_map**
  %46 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %46, %struct.bpf_map** %map, align 8
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 5
  %48 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %49 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %48, i32 0, i32 0
  %50 = load i64, i64* %49, align 8
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %48, i32 0, i32 1
  %52 = load i64, i64* %51, align 8
  %call39 = call zeroext i1 @tnum_is_const(i64 %50, i64 %52) #11
  br i1 %call39, label %land.lhs.true40, label %if.else55

land.lhs.true40:                                  ; preds = %if.then38
  %53 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call41 = call zeroext i1 @bpf_map_is_rdonly(%struct.bpf_map* noundef %53) #11
  br i1 %call41, label %land.lhs.true42, label %if.else55

land.lhs.true42:                                  ; preds = %land.lhs.true40
  %54 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %54, i32 0, i32 0
  %55 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %55, i32 0, i32 26
  %56 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %tobool43 = icmp ne i32 (%struct.bpf_map*, i64*, i32)* %56, null
  br i1 %tobool43, label %if.then44, label %if.else55

if.then44:                                        ; preds = %land.lhs.true42
  %57 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %57 to i64
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off45 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %58, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off45, i32 0, i32 0
  %59 = load i64, i64* %value, align 8
  %add46 = add i64 %conv, %59
  %conv47 = trunc i64 %add46 to i32
  store i32 %conv47, i32* %map_off, align 4
  store i64 0, i64* %val, align 8
  %60 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %61 = load i32, i32* %map_off, align 4
  %62 = load i32, i32* %size, align 4
  %call48 = call i32 @bpf_map_direct_read(%struct.bpf_map* noundef %60, i32 noundef %61, i32 noundef %62, i64* noundef %val) #11
  store i32 %call48, i32* %err, align 4
  %63 = load i32, i32* %err, align 4
  %tobool49 = icmp ne i32 %63, 0
  br i1 %tobool49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.then44
  %64 = load i32, i32* %err, align 4
  store i32 %64, i32* %retval, align 4
  br label %return

if.end51:                                         ; preds = %if.then44
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %66 = load i32, i32* %value_regno.addr, align 4
  %idxprom = sext i32 %66 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i64 %idxprom
  %type52 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  store i32 1, i32* %type52, align 8
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %68 = load i32, i32* %value_regno.addr, align 4
  %idxprom53 = sext i32 %68 to i64
  %arrayidx54 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i64 %idxprom53
  %69 = load i64, i64* %val, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %arrayidx54, i64 noundef %69) #11
  br label %if.end56

if.else55:                                        ; preds = %land.lhs.true42, %land.lhs.true40, %if.then38
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %72 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %70, %struct.bpf_reg_state* noundef %71, i32 noundef %72) #11
  br label %if.end56

if.end56:                                         ; preds = %if.else55, %if.end51
  br label %if.end57

if.end57:                                         ; preds = %if.end56, %land.lhs.true36, %land.lhs.true34, %if.end31
  br label %if.end316

if.else58:                                        ; preds = %if.end18
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %73, i32 0, i32 0
  %74 = load i32, i32* %type59, align 8
  %cmp60 = icmp eq i32 %74, 21
  br i1 %cmp60, label %if.then62, label %if.else83

if.then62:                                        ; preds = %if.else58
  %75 = load i32, i32* %t.addr, align 4
  %cmp63 = icmp eq i32 %75, 2
  br i1 %cmp63, label %land.lhs.true65, label %if.end72

land.lhs.true65:                                  ; preds = %if.then62
  %76 = load i32, i32* %value_regno.addr, align 4
  %cmp66 = icmp sge i32 %76, 0
  br i1 %cmp66, label %land.lhs.true68, label %if.end72

land.lhs.true68:                                  ; preds = %land.lhs.true65
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %78 = load i32, i32* %value_regno.addr, align 4
  %call69 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %77, i32 noundef %78) #11
  br i1 %call69, label %if.then71, label %if.end72

if.then71:                                        ; preds = %land.lhs.true68
  %79 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %80 = bitcast %struct.bpf_verifier_env* %79 to i8*
  %81 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %80, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.207, i64 0, i64 0), i32 noundef %81) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end72:                                         ; preds = %land.lhs.true68, %land.lhs.true65, %if.then62
  %82 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %83 = load i32, i32* %regno.addr, align 4
  %84 = load i32, i32* %off.addr, align 4
  %85 = load i32, i32* %size, align 4
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %87 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 1
  %mem_size = bitcast %struct.bpf_iter_aux_info* %87 to i32*
  %88 = load i32, i32* %mem_size, align 8
  %call73 = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %82, i32 noundef %83, i32 noundef %84, i32 noundef %85, i32 noundef %88, i1 noundef zeroext false) #11
  store i32 %call73, i32* %err, align 4
  %89 = load i32, i32* %err, align 4
  %tobool74 = icmp ne i32 %89, 0
  br i1 %tobool74, label %if.end82, label %land.lhs.true75

land.lhs.true75:                                  ; preds = %if.end72
  %90 = load i32, i32* %t.addr, align 4
  %cmp76 = icmp eq i32 %90, 1
  br i1 %cmp76, label %land.lhs.true78, label %if.end82

land.lhs.true78:                                  ; preds = %land.lhs.true75
  %91 = load i32, i32* %value_regno.addr, align 4
  %cmp79 = icmp sge i32 %91, 0
  br i1 %cmp79, label %if.then81, label %if.end82

if.then81:                                        ; preds = %land.lhs.true78
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %94 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %92, %struct.bpf_reg_state* noundef %93, i32 noundef %94) #11
  br label %if.end82

if.end82:                                         ; preds = %if.then81, %land.lhs.true78, %land.lhs.true75, %if.end72
  br label %if.end315

if.else83:                                        ; preds = %if.else58
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type84 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 0
  %96 = load i32, i32* %type84, align 8
  %cmp85 = icmp eq i32 %96, 2
  br i1 %cmp85, label %if.then87, label %if.else140

if.then87:                                        ; preds = %if.else83
  store i32 1, i32* %reg_type, align 4
  store i32 0, i32* %btf_id, align 4
  %97 = load i32, i32* %t.addr, align 4
  %cmp88 = icmp eq i32 %97, 2
  br i1 %cmp88, label %land.lhs.true90, label %if.end97

land.lhs.true90:                                  ; preds = %if.then87
  %98 = load i32, i32* %value_regno.addr, align 4
  %cmp91 = icmp sge i32 %98, 0
  br i1 %cmp91, label %land.lhs.true93, label %if.end97

land.lhs.true93:                                  ; preds = %land.lhs.true90
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %100 = load i32, i32* %value_regno.addr, align 4
  %call94 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %99, i32 noundef %100) #11
  br i1 %call94, label %if.then96, label %if.end97

if.then96:                                        ; preds = %land.lhs.true93
  %101 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %102 = bitcast %struct.bpf_verifier_env* %101 to i8*
  %103 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %102, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.208, i64 0, i64 0), i32 noundef %103) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end97:                                         ; preds = %land.lhs.true93, %land.lhs.true90, %if.then87
  %104 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %105 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %106 = load i32, i32* %regno.addr, align 4
  %call98 = call i32 @check_ctx_reg(%struct.bpf_verifier_env* noundef %104, %struct.bpf_reg_state* noundef %105, i32 noundef %106) #11
  store i32 %call98, i32* %err, align 4
  %107 = load i32, i32* %err, align 4
  %cmp99 = icmp slt i32 %107, 0
  br i1 %cmp99, label %if.then101, label %if.end102

if.then101:                                       ; preds = %if.end97
  %108 = load i32, i32* %err, align 4
  store i32 %108, i32* %retval, align 4
  br label %return

if.end102:                                        ; preds = %if.end97
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %110 = load i32, i32* %insn_idx.addr, align 4
  %111 = load i32, i32* %off.addr, align 4
  %112 = load i32, i32* %size, align 4
  %113 = load i32, i32* %t.addr, align 4
  %call103 = call i32 @check_ctx_access(%struct.bpf_verifier_env* noundef %109, i32 noundef %110, i32 noundef %111, i32 noundef %112, i32 noundef %113, i32* noundef %reg_type, i32* noundef %btf_id) #11
  store i32 %call103, i32* %err, align 4
  %114 = load i32, i32* %err, align 4
  %tobool104 = icmp ne i32 %114, 0
  br i1 %tobool104, label %if.then105, label %if.end106

if.then105:                                       ; preds = %if.end102
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %116 = load i32, i32* %insn_idx.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %115, i32 noundef %116, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.102, i64 0, i64 0)) #11
  br label %if.end106

if.end106:                                        ; preds = %if.then105, %if.end102
  %117 = load i32, i32* %err, align 4
  %tobool107 = icmp ne i32 %117, 0
  br i1 %tobool107, label %if.end139, label %land.lhs.true108

land.lhs.true108:                                 ; preds = %if.end106
  %118 = load i32, i32* %t.addr, align 4
  %cmp109 = icmp eq i32 %118, 1
  br i1 %cmp109, label %land.lhs.true111, label %if.end139

land.lhs.true111:                                 ; preds = %land.lhs.true108
  %119 = load i32, i32* %value_regno.addr, align 4
  %cmp112 = icmp sge i32 %119, 0
  br i1 %cmp112, label %if.then114, label %if.end139

if.then114:                                       ; preds = %land.lhs.true111
  %120 = load i32, i32* %reg_type, align 4
  %cmp115 = icmp eq i32 %120, 1
  br i1 %cmp115, label %if.then117, label %if.else118

if.then117:                                       ; preds = %if.then114
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %122 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %123 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %121, %struct.bpf_reg_state* noundef %122, i32 noundef %123) #11
  br label %if.end135

if.else118:                                       ; preds = %if.then114
  %124 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %125 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %126 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %124, %struct.bpf_reg_state* noundef %125, i32 noundef %126) #11
  %127 = load i32, i32* %reg_type, align 4
  %call119 = call zeroext i1 @reg_type_may_be_null(i32 noundef %127) #11
  br i1 %call119, label %if.then120, label %if.end123

if.then120:                                       ; preds = %if.else118
  %128 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %128, i32 0, i32 13
  %129 = load i32, i32* %id_gen, align 4
  %inc = add i32 %129, 1
  store i32 %inc, i32* %id_gen, align 4
  %130 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %131 = load i32, i32* %value_regno.addr, align 4
  %idxprom121 = sext i32 %131 to i64
  %arrayidx122 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %130, i64 %idxprom121
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx122, i32 0, i32 3
  store i32 %inc, i32* %id, align 4
  br label %if.end123

if.end123:                                        ; preds = %if.then120, %if.else118
  %132 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %133 = load i32, i32* %value_regno.addr, align 4
  %idxprom124 = sext i32 %133 to i64
  %arrayidx125 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %132, i64 %idxprom124
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx125, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  %134 = load i32, i32* %reg_type, align 4
  %cmp126 = icmp eq i32 %134, 19
  br i1 %cmp126, label %if.then130, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end123
  %135 = load i32, i32* %reg_type, align 4
  %cmp128 = icmp eq i32 %135, 20
  br i1 %cmp128, label %if.then130, label %if.end134

if.then130:                                       ; preds = %lor.lhs.false, %if.end123
  %136 = load i32, i32* %btf_id, align 4
  %137 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %138 = load i32, i32* %value_regno.addr, align 4
  %idxprom131 = sext i32 %138 to i64
  %arrayidx132 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %137, i64 %idxprom131
  %139 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx132, i32 0, i32 1
  %btf_id133 = bitcast %struct.bpf_iter_aux_info* %139 to i32*
  store i32 %136, i32* %btf_id133, align 8
  br label %if.end134

if.end134:                                        ; preds = %if.then130, %lor.lhs.false
  br label %if.end135

if.end135:                                        ; preds = %if.end134, %if.then117
  %140 = load i32, i32* %reg_type, align 4
  %141 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %142 = load i32, i32* %value_regno.addr, align 4
  %idxprom136 = sext i32 %142 to i64
  %arrayidx137 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %141, i64 %idxprom136
  %type138 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx137, i32 0, i32 0
  store i32 %140, i32* %type138, align 8
  br label %if.end139

if.end139:                                        ; preds = %if.end135, %land.lhs.true111, %land.lhs.true108, %if.end106
  br label %if.end314

if.else140:                                       ; preds = %if.else83
  %143 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type141 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %143, i32 0, i32 0
  %144 = load i32, i32* %type141, align 8
  %cmp142 = icmp eq i32 %144, 6
  br i1 %cmp142, label %if.then144, label %if.else166

if.then144:                                       ; preds = %if.else140
  %145 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off145 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %145, i32 0, i32 5
  %value146 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off145, i32 0, i32 0
  %146 = load i64, i64* %value146, align 8
  %147 = load i32, i32* %off.addr, align 4
  %conv147 = sext i32 %147 to i64
  %add148 = add i64 %conv147, %146
  %conv149 = trunc i64 %add148 to i32
  store i32 %conv149, i32* %off.addr, align 4
  %148 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %149 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %150 = load i32, i32* %off.addr, align 4
  %151 = load i32, i32* %size, align 4
  %call150 = call i32 @check_stack_access(%struct.bpf_verifier_env* noundef %148, %struct.bpf_reg_state* noundef %149, i32 noundef %150, i32 noundef %151) #11
  store i32 %call150, i32* %err, align 4
  %152 = load i32, i32* %err, align 4
  %tobool151 = icmp ne i32 %152, 0
  br i1 %tobool151, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.then144
  %153 = load i32, i32* %err, align 4
  store i32 %153, i32* %retval, align 4
  br label %return

if.end153:                                        ; preds = %if.then144
  %154 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call154 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %154, %struct.bpf_reg_state* noundef %155) #11
  store %struct.bpf_func_state* %call154, %struct.bpf_func_state** %state, align 8
  %156 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %157 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %158 = load i32, i32* %off.addr, align 4
  %call155 = call i32 @update_stack_depth(%struct.bpf_verifier_env* noundef %156, %struct.bpf_func_state* noundef %157, i32 noundef %158) #11
  store i32 %call155, i32* %err, align 4
  %159 = load i32, i32* %err, align 4
  %tobool156 = icmp ne i32 %159, 0
  br i1 %tobool156, label %if.then157, label %if.end158

if.then157:                                       ; preds = %if.end153
  %160 = load i32, i32* %err, align 4
  store i32 %160, i32* %retval, align 4
  br label %return

if.end158:                                        ; preds = %if.end153
  %161 = load i32, i32* %t.addr, align 4
  %cmp159 = icmp eq i32 %161, 2
  br i1 %cmp159, label %if.then161, label %if.else163

if.then161:                                       ; preds = %if.end158
  %162 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %163 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %164 = load i32, i32* %off.addr, align 4
  %165 = load i32, i32* %size, align 4
  %166 = load i32, i32* %value_regno.addr, align 4
  %167 = load i32, i32* %insn_idx.addr, align 4
  %call162 = call i32 @check_stack_write(%struct.bpf_verifier_env* noundef %162, %struct.bpf_func_state* noundef %163, i32 noundef %164, i32 noundef %165, i32 noundef %166, i32 noundef %167) #11
  store i32 %call162, i32* %err, align 4
  br label %if.end165

if.else163:                                       ; preds = %if.end158
  %168 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %169 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %170 = load i32, i32* %off.addr, align 4
  %171 = load i32, i32* %size, align 4
  %172 = load i32, i32* %value_regno.addr, align 4
  %call164 = call i32 @check_stack_read(%struct.bpf_verifier_env* noundef %168, %struct.bpf_func_state* noundef %169, i32 noundef %170, i32 noundef %171, i32 noundef %172) #11
  store i32 %call164, i32* %err, align 4
  br label %if.end165

if.end165:                                        ; preds = %if.else163, %if.then161
  br label %if.end313

if.else166:                                       ; preds = %if.else140
  %173 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call167 = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %173) #11
  br i1 %call167, label %if.then168, label %if.else195

if.then168:                                       ; preds = %if.else166
  %174 = load i32, i32* %t.addr, align 4
  %cmp169 = icmp eq i32 %174, 2
  br i1 %cmp169, label %land.lhs.true171, label %if.end174

land.lhs.true171:                                 ; preds = %if.then168
  %175 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %176 = load i32, i32* %t.addr, align 4
  %call172 = call zeroext i1 @may_access_direct_pkt_data(%struct.bpf_verifier_env* noundef %175, %struct.bpf_call_arg_meta* noundef null, i32 noundef %176) #11
  br i1 %call172, label %if.end174, label %if.then173

if.then173:                                       ; preds = %land.lhs.true171
  %177 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %178 = bitcast %struct.bpf_verifier_env* %177 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %178, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.209, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end174:                                        ; preds = %land.lhs.true171, %if.then168
  %179 = load i32, i32* %t.addr, align 4
  %cmp175 = icmp eq i32 %179, 2
  br i1 %cmp175, label %land.lhs.true177, label %if.end184

land.lhs.true177:                                 ; preds = %if.end174
  %180 = load i32, i32* %value_regno.addr, align 4
  %cmp178 = icmp sge i32 %180, 0
  br i1 %cmp178, label %land.lhs.true180, label %if.end184

land.lhs.true180:                                 ; preds = %land.lhs.true177
  %181 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %182 = load i32, i32* %value_regno.addr, align 4
  %call181 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %181, i32 noundef %182) #11
  br i1 %call181, label %if.then183, label %if.end184

if.then183:                                       ; preds = %land.lhs.true180
  %183 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %184 = bitcast %struct.bpf_verifier_env* %183 to i8*
  %185 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %184, i8* noundef getelementptr inbounds ([28 x i8], [28 x i8]* @.str.210, i64 0, i64 0), i32 noundef %185) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end184:                                        ; preds = %land.lhs.true180, %land.lhs.true177, %if.end174
  %186 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %187 = load i32, i32* %regno.addr, align 4
  %188 = load i32, i32* %off.addr, align 4
  %189 = load i32, i32* %size, align 4
  %call185 = call i32 @check_packet_access(%struct.bpf_verifier_env* noundef %186, i32 noundef %187, i32 noundef %188, i32 noundef %189, i1 noundef zeroext false) #11
  store i32 %call185, i32* %err, align 4
  %190 = load i32, i32* %err, align 4
  %tobool186 = icmp ne i32 %190, 0
  br i1 %tobool186, label %if.end194, label %land.lhs.true187

land.lhs.true187:                                 ; preds = %if.end184
  %191 = load i32, i32* %t.addr, align 4
  %cmp188 = icmp eq i32 %191, 1
  br i1 %cmp188, label %land.lhs.true190, label %if.end194

land.lhs.true190:                                 ; preds = %land.lhs.true187
  %192 = load i32, i32* %value_regno.addr, align 4
  %cmp191 = icmp sge i32 %192, 0
  br i1 %cmp191, label %if.then193, label %if.end194

if.then193:                                       ; preds = %land.lhs.true190
  %193 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %194 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %195 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %193, %struct.bpf_reg_state* noundef %194, i32 noundef %195) #11
  br label %if.end194

if.end194:                                        ; preds = %if.then193, %land.lhs.true190, %land.lhs.true187, %if.end184
  br label %if.end312

if.else195:                                       ; preds = %if.else166
  %196 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type196 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %196, i32 0, i32 0
  %197 = load i32, i32* %type196, align 8
  %cmp197 = icmp eq i32 %197, 10
  br i1 %cmp197, label %if.then199, label %if.else220

if.then199:                                       ; preds = %if.else195
  %198 = load i32, i32* %t.addr, align 4
  %cmp200 = icmp eq i32 %198, 2
  br i1 %cmp200, label %land.lhs.true202, label %if.end209

land.lhs.true202:                                 ; preds = %if.then199
  %199 = load i32, i32* %value_regno.addr, align 4
  %cmp203 = icmp sge i32 %199, 0
  br i1 %cmp203, label %land.lhs.true205, label %if.end209

land.lhs.true205:                                 ; preds = %land.lhs.true202
  %200 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %201 = load i32, i32* %value_regno.addr, align 4
  %call206 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %200, i32 noundef %201) #11
  br i1 %call206, label %if.then208, label %if.end209

if.then208:                                       ; preds = %land.lhs.true205
  %202 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %203 = bitcast %struct.bpf_verifier_env* %202 to i8*
  %204 = load i32, i32* %value_regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %203, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.211, i64 0, i64 0), i32 noundef %204) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end209:                                        ; preds = %land.lhs.true205, %land.lhs.true202, %if.then199
  %205 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %206 = load i32, i32* %off.addr, align 4
  %207 = load i32, i32* %size, align 4
  %call210 = call i32 @check_flow_keys_access(%struct.bpf_verifier_env* noundef %205, i32 noundef %206, i32 noundef %207) #11
  store i32 %call210, i32* %err, align 4
  %208 = load i32, i32* %err, align 4
  %tobool211 = icmp ne i32 %208, 0
  br i1 %tobool211, label %if.end219, label %land.lhs.true212

land.lhs.true212:                                 ; preds = %if.end209
  %209 = load i32, i32* %t.addr, align 4
  %cmp213 = icmp eq i32 %209, 1
  br i1 %cmp213, label %land.lhs.true215, label %if.end219

land.lhs.true215:                                 ; preds = %land.lhs.true212
  %210 = load i32, i32* %value_regno.addr, align 4
  %cmp216 = icmp sge i32 %210, 0
  br i1 %cmp216, label %if.then218, label %if.end219

if.then218:                                       ; preds = %land.lhs.true215
  %211 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %212 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %213 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %211, %struct.bpf_reg_state* noundef %212, i32 noundef %213) #11
  br label %if.end219

if.end219:                                        ; preds = %if.then218, %land.lhs.true215, %land.lhs.true212, %if.end209
  br label %if.end311

if.else220:                                       ; preds = %if.else195
  %214 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type221 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %214, i32 0, i32 0
  %215 = load i32, i32* %type221, align 8
  %call222 = call zeroext i1 @type_is_sk_pointer(i32 noundef %215) #11
  br i1 %call222, label %if.then223, label %if.else238

if.then223:                                       ; preds = %if.else220
  %216 = load i32, i32* %t.addr, align 4
  %cmp224 = icmp eq i32 %216, 2
  br i1 %cmp224, label %if.then226, label %if.end230

if.then226:                                       ; preds = %if.then223
  %217 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %218 = bitcast %struct.bpf_verifier_env* %217 to i8*
  %219 = load i32, i32* %regno.addr, align 4
  %220 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type227 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %220, i32 0, i32 0
  %221 = load i32, i32* %type227, align 8
  %idxprom228 = zext i32 %221 to i64
  %arrayidx229 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom228
  %222 = load i8*, i8** %arrayidx229, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %218, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.212, i64 0, i64 0), i32 noundef %219, i8* noundef %222) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end230:                                        ; preds = %if.then223
  %223 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %224 = load i32, i32* %insn_idx.addr, align 4
  %225 = load i32, i32* %regno.addr, align 4
  %226 = load i32, i32* %off.addr, align 4
  %227 = load i32, i32* %size, align 4
  %228 = load i32, i32* %t.addr, align 4
  %call231 = call i32 @check_sock_access(%struct.bpf_verifier_env* noundef %223, i32 noundef %224, i32 noundef %225, i32 noundef %226, i32 noundef %227, i32 noundef %228) #11
  store i32 %call231, i32* %err, align 4
  %229 = load i32, i32* %err, align 4
  %tobool232 = icmp ne i32 %229, 0
  br i1 %tobool232, label %if.end237, label %land.lhs.true233

land.lhs.true233:                                 ; preds = %if.end230
  %230 = load i32, i32* %value_regno.addr, align 4
  %cmp234 = icmp sge i32 %230, 0
  br i1 %cmp234, label %if.then236, label %if.end237

if.then236:                                       ; preds = %land.lhs.true233
  %231 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %232 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %233 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %231, %struct.bpf_reg_state* noundef %232, i32 noundef %233) #11
  br label %if.end237

if.end237:                                        ; preds = %if.then236, %land.lhs.true233, %if.end230
  br label %if.end310

if.else238:                                       ; preds = %if.else220
  %234 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type239 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %234, i32 0, i32 0
  %235 = load i32, i32* %type239, align 8
  %cmp240 = icmp eq i32 %235, 17
  br i1 %cmp240, label %if.then242, label %if.else253

if.then242:                                       ; preds = %if.else238
  %236 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %237 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %238 = load i32, i32* %regno.addr, align 4
  %239 = load i32, i32* %off.addr, align 4
  %240 = load i32, i32* %size, align 4
  %call243 = call i32 @check_tp_buffer_access(%struct.bpf_verifier_env* noundef %236, %struct.bpf_reg_state* noundef %237, i32 noundef %238, i32 noundef %239, i32 noundef %240) #11
  store i32 %call243, i32* %err, align 4
  %241 = load i32, i32* %err, align 4
  %tobool244 = icmp ne i32 %241, 0
  br i1 %tobool244, label %if.end252, label %land.lhs.true245

land.lhs.true245:                                 ; preds = %if.then242
  %242 = load i32, i32* %t.addr, align 4
  %cmp246 = icmp eq i32 %242, 1
  br i1 %cmp246, label %land.lhs.true248, label %if.end252

land.lhs.true248:                                 ; preds = %land.lhs.true245
  %243 = load i32, i32* %value_regno.addr, align 4
  %cmp249 = icmp sge i32 %243, 0
  br i1 %cmp249, label %if.then251, label %if.end252

if.then251:                                       ; preds = %land.lhs.true248
  %244 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %245 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %246 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %244, %struct.bpf_reg_state* noundef %245, i32 noundef %246) #11
  br label %if.end252

if.end252:                                        ; preds = %if.then251, %land.lhs.true248, %land.lhs.true245, %if.then242
  br label %if.end309

if.else253:                                       ; preds = %if.else238
  %247 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type254 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %247, i32 0, i32 0
  %248 = load i32, i32* %type254, align 8
  %cmp255 = icmp eq i32 %248, 19
  br i1 %cmp255, label %if.then257, label %if.else259

if.then257:                                       ; preds = %if.else253
  %249 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %250 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %251 = load i32, i32* %regno.addr, align 4
  %252 = load i32, i32* %off.addr, align 4
  %253 = load i32, i32* %size, align 4
  %254 = load i32, i32* %t.addr, align 4
  %255 = load i32, i32* %value_regno.addr, align 4
  %call258 = call i32 @check_ptr_to_btf_access(%struct.bpf_verifier_env* noundef %249, %struct.bpf_reg_state* noundef %250, i32 noundef %251, i32 noundef %252, i32 noundef %253, i32 noundef %254, i32 noundef %255) #11
  store i32 %call258, i32* %err, align 4
  br label %if.end308

if.else259:                                       ; preds = %if.else253
  %256 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type260 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %256, i32 0, i32 0
  %257 = load i32, i32* %type260, align 8
  %cmp261 = icmp eq i32 %257, 3
  br i1 %cmp261, label %if.then263, label %if.else265

if.then263:                                       ; preds = %if.else259
  %258 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %259 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %260 = load i32, i32* %regno.addr, align 4
  %261 = load i32, i32* %off.addr, align 4
  %262 = load i32, i32* %size, align 4
  %263 = load i32, i32* %t.addr, align 4
  %264 = load i32, i32* %value_regno.addr, align 4
  %call264 = call i32 @check_ptr_to_map_access(%struct.bpf_verifier_env* noundef %258, %struct.bpf_reg_state* noundef %259, i32 noundef %260, i32 noundef %261, i32 noundef %262, i32 noundef %263, i32 noundef %264) #11
  store i32 %call264, i32* %err, align 4
  br label %if.end307

if.else265:                                       ; preds = %if.else259
  %265 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type266 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %265, i32 0, i32 0
  %266 = load i32, i32* %type266, align 8
  %cmp267 = icmp eq i32 %266, 23
  br i1 %cmp267, label %if.then269, label %if.else284

if.then269:                                       ; preds = %if.else265
  %267 = load i32, i32* %t.addr, align 4
  %cmp270 = icmp eq i32 %267, 2
  br i1 %cmp270, label %if.then272, label %if.end276

if.then272:                                       ; preds = %if.then269
  %268 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %269 = bitcast %struct.bpf_verifier_env* %268 to i8*
  %270 = load i32, i32* %regno.addr, align 4
  %271 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type273 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %271, i32 0, i32 0
  %272 = load i32, i32* %type273, align 8
  %idxprom274 = zext i32 %272 to i64
  %arrayidx275 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom274
  %273 = load i8*, i8** %arrayidx275, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %269, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.212, i64 0, i64 0), i32 noundef %270, i8* noundef %273) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end276:                                        ; preds = %if.then269
  %274 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %275 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %276 = load i32, i32* %regno.addr, align 4
  %277 = load i32, i32* %off.addr, align 4
  %278 = load i32, i32* %size, align 4
  %279 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %279, i32 0, i32 2
  %280 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %280, i32 0, i32 7
  %281 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_rdonly_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %281, i32 0, i32 11
  %call277 = call i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %274, %struct.bpf_reg_state* noundef %275, i32 noundef %276, i32 noundef %277, i32 noundef %278, i1 noundef zeroext false, i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str.213, i64 0, i64 0), i32* noundef %max_rdonly_access) #11
  store i32 %call277, i32* %err, align 4
  %282 = load i32, i32* %err, align 4
  %tobool278 = icmp ne i32 %282, 0
  br i1 %tobool278, label %if.end283, label %land.lhs.true279

land.lhs.true279:                                 ; preds = %if.end276
  %283 = load i32, i32* %value_regno.addr, align 4
  %cmp280 = icmp sge i32 %283, 0
  br i1 %cmp280, label %if.then282, label %if.end283

if.then282:                                       ; preds = %land.lhs.true279
  %284 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %285 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %286 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %284, %struct.bpf_reg_state* noundef %285, i32 noundef %286) #11
  br label %if.end283

if.end283:                                        ; preds = %if.then282, %land.lhs.true279, %if.end276
  br label %if.end306

if.else284:                                       ; preds = %if.else265
  %287 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type285 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %287, i32 0, i32 0
  %288 = load i32, i32* %type285, align 8
  %cmp286 = icmp eq i32 %288, 25
  br i1 %cmp286, label %if.then288, label %if.else301

if.then288:                                       ; preds = %if.else284
  %289 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %290 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %291 = load i32, i32* %regno.addr, align 4
  %292 = load i32, i32* %off.addr, align 4
  %293 = load i32, i32* %size, align 4
  %294 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog289 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %294, i32 0, i32 2
  %295 = load %struct.bpf_prog*, %struct.bpf_prog** %prog289, align 8
  %aux290 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %295, i32 0, i32 7
  %296 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux290, align 8
  %max_rdwr_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %296, i32 0, i32 12
  %call291 = call i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %289, %struct.bpf_reg_state* noundef %290, i32 noundef %291, i32 noundef %292, i32 noundef %293, i1 noundef zeroext false, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.214, i64 0, i64 0), i32* noundef %max_rdwr_access) #11
  store i32 %call291, i32* %err, align 4
  %297 = load i32, i32* %err, align 4
  %tobool292 = icmp ne i32 %297, 0
  br i1 %tobool292, label %if.end300, label %land.lhs.true293

land.lhs.true293:                                 ; preds = %if.then288
  %298 = load i32, i32* %t.addr, align 4
  %cmp294 = icmp eq i32 %298, 1
  br i1 %cmp294, label %land.lhs.true296, label %if.end300

land.lhs.true296:                                 ; preds = %land.lhs.true293
  %299 = load i32, i32* %value_regno.addr, align 4
  %cmp297 = icmp sge i32 %299, 0
  br i1 %cmp297, label %if.then299, label %if.end300

if.then299:                                       ; preds = %land.lhs.true296
  %300 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %301 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %302 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %300, %struct.bpf_reg_state* noundef %301, i32 noundef %302) #11
  br label %if.end300

if.end300:                                        ; preds = %if.then299, %land.lhs.true296, %land.lhs.true293, %if.then288
  br label %if.end305

if.else301:                                       ; preds = %if.else284
  %303 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %304 = bitcast %struct.bpf_verifier_env* %303 to i8*
  %305 = load i32, i32* %regno.addr, align 4
  %306 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type302 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %306, i32 0, i32 0
  %307 = load i32, i32* %type302, align 8
  %idxprom303 = zext i32 %307 to i64
  %arrayidx304 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom303
  %308 = load i8*, i8** %arrayidx304, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %304, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.215, i64 0, i64 0), i32 noundef %305, i8* noundef %308) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end305:                                        ; preds = %if.end300
  br label %if.end306

if.end306:                                        ; preds = %if.end305, %if.end283
  br label %if.end307

if.end307:                                        ; preds = %if.end306, %if.then263
  br label %if.end308

if.end308:                                        ; preds = %if.end307, %if.then257
  br label %if.end309

if.end309:                                        ; preds = %if.end308, %if.end252
  br label %if.end310

if.end310:                                        ; preds = %if.end309, %if.end237
  br label %if.end311

if.end311:                                        ; preds = %if.end310, %if.end219
  br label %if.end312

if.end312:                                        ; preds = %if.end311, %if.end194
  br label %if.end313

if.end313:                                        ; preds = %if.end312, %if.end165
  br label %if.end314

if.end314:                                        ; preds = %if.end313, %if.end139
  br label %if.end315

if.end315:                                        ; preds = %if.end314, %if.end82
  br label %if.end316

if.end316:                                        ; preds = %if.end315, %if.end57
  %309 = load i32, i32* %err, align 4
  %tobool317 = icmp ne i32 %309, 0
  br i1 %tobool317, label %if.end336, label %land.lhs.true318

land.lhs.true318:                                 ; preds = %if.end316
  %310 = load i32, i32* %size, align 4
  %cmp319 = icmp slt i32 %310, 8
  br i1 %cmp319, label %land.lhs.true321, label %if.end336

land.lhs.true321:                                 ; preds = %land.lhs.true318
  %311 = load i32, i32* %value_regno.addr, align 4
  %cmp322 = icmp sge i32 %311, 0
  br i1 %cmp322, label %land.lhs.true324, label %if.end336

land.lhs.true324:                                 ; preds = %land.lhs.true321
  %312 = load i32, i32* %t.addr, align 4
  %cmp325 = icmp eq i32 %312, 1
  br i1 %cmp325, label %land.lhs.true327, label %if.end336

land.lhs.true327:                                 ; preds = %land.lhs.true324
  %313 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %314 = load i32, i32* %value_regno.addr, align 4
  %idxprom328 = sext i32 %314 to i64
  %arrayidx329 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %313, i64 %idxprom328
  %type330 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx329, i32 0, i32 0
  %315 = load i32, i32* %type330, align 8
  %cmp331 = icmp eq i32 %315, 1
  br i1 %cmp331, label %if.then333, label %if.end336

if.then333:                                       ; preds = %land.lhs.true327
  %316 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %317 = load i32, i32* %value_regno.addr, align 4
  %idxprom334 = sext i32 %317 to i64
  %arrayidx335 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %316, i64 %idxprom334
  %318 = load i32, i32* %size, align 4
  call void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %arrayidx335, i32 noundef %318) #11
  br label %if.end336

if.end336:                                        ; preds = %if.then333, %land.lhs.true327, %land.lhs.true324, %land.lhs.true321, %land.lhs.true318, %if.end316
  %319 = load i32, i32* %err, align 4
  store i32 %319, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end336, %if.else301, %if.then272, %if.then226, %if.then208, %if.then183, %if.then173, %if.then157, %if.then152, %if.then101, %if.then96, %if.then71, %if.then50, %if.then30, %if.then26, %if.then17, %if.then13
  %320 = load i32, i32* %retval, align 4
  ret i32 %320
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_mismatch(i32 noundef %src, i32 noundef %prev) #0 {
entry:
  %src.addr = alloca i32, align 4
  %prev.addr = alloca i32, align 4
  store i32 %src, i32* %src.addr, align 4
  store i32 %prev, i32* %prev.addr, align 4
  %0 = load i32, i32* %src.addr, align 4
  %1 = load i32, i32* %prev.addr, align 4
  %cmp = icmp ne i32 %0, %1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load i32, i32* %src.addr, align 4
  %call = call zeroext i1 @reg_type_mismatch_ok(i32 noundef %2) #11
  br i1 %call, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.rhs
  %3 = load i32, i32* %prev.addr, align 4
  %call1 = call zeroext i1 @reg_type_mismatch_ok(i32 noundef %3) #11
  %lnot = xor i1 %call1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %4 = phi i1 [ true, %land.rhs ], [ %lnot, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %entry
  %5 = phi i1 [ false, %entry ], [ %4, %lor.end ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_xadd(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 24
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 24
  %cmp5 = icmp ne i32 %and4, 24
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 3
  %5 = load i32, i32* %imm, align 4
  %cmp7 = icmp ne i32 %5, 0
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.252, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv9 = zext i8 %bf.lshr to i32
  %call = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %8, i32 noundef %conv9, i32 noundef 0) #11
  store i32 %call, i32* %err, align 4
  %10 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  %11 = load i32, i32* %err, align 4
  store i32 %11, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 1
  %bf.load12 = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load12, 15
  %conv13 = zext i8 %bf.clear to i32
  %call14 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %12, i32 noundef %conv13, i32 noundef 0) #11
  store i32 %call14, i32* %err, align 4
  %14 = load i32, i32* %err, align 4
  %tobool15 = icmp ne i32 %14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end11
  %15 = load i32, i32* %err, align 4
  store i32 %15, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end11
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg18 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %17, i32 0, i32 1
  %bf.load19 = load i8, i8* %src_reg18, align 1
  %bf.lshr20 = lshr i8 %bf.load19, 4
  %conv21 = zext i8 %bf.lshr20 to i32
  %call22 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %16, i32 noundef %conv21) #11
  br i1 %call22, label %if.then23, label %if.end28

if.then23:                                        ; preds = %if.end17
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg24 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 1
  %bf.load25 = load i8, i8* %src_reg24, align 1
  %bf.lshr26 = lshr i8 %bf.load25, 4
  %conv27 = zext i8 %bf.lshr26 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.207, i64 0, i64 0), i32 noundef %conv27) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end17
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg29 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %22, i32 0, i32 1
  %bf.load30 = load i8, i8* %dst_reg29, align 1
  %bf.clear31 = and i8 %bf.load30, 15
  %conv32 = zext i8 %bf.clear31 to i32
  %call33 = call zeroext i1 @is_ctx_reg(%struct.bpf_verifier_env* noundef %21, i32 noundef %conv32) #11
  br i1 %call33, label %if.then56, label %lor.lhs.false35

lor.lhs.false35:                                  ; preds = %if.end28
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg36 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 1
  %bf.load37 = load i8, i8* %dst_reg36, align 1
  %bf.clear38 = and i8 %bf.load37, 15
  %conv39 = zext i8 %bf.clear38 to i32
  %call40 = call zeroext i1 @is_pkt_reg(%struct.bpf_verifier_env* noundef %23, i32 noundef %conv39) #11
  br i1 %call40, label %if.then56, label %lor.lhs.false42

lor.lhs.false42:                                  ; preds = %lor.lhs.false35
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %26, i32 0, i32 1
  %bf.load44 = load i8, i8* %dst_reg43, align 1
  %bf.clear45 = and i8 %bf.load44, 15
  %conv46 = zext i8 %bf.clear45 to i32
  %call47 = call zeroext i1 @is_flow_key_reg(%struct.bpf_verifier_env* noundef %25, i32 noundef %conv46) #11
  br i1 %call47, label %if.then56, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %lor.lhs.false42
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg50 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %28, i32 0, i32 1
  %bf.load51 = load i8, i8* %dst_reg50, align 1
  %bf.clear52 = and i8 %bf.load51, 15
  %conv53 = zext i8 %bf.clear52 to i32
  %call54 = call zeroext i1 @is_sk_reg(%struct.bpf_verifier_env* noundef %27, i32 noundef %conv53) #11
  br i1 %call54, label %if.then56, label %if.end66

if.then56:                                        ; preds = %lor.lhs.false49, %lor.lhs.false42, %lor.lhs.false35, %if.end28
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg57 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %31, i32 0, i32 1
  %bf.load58 = load i8, i8* %dst_reg57, align 1
  %bf.clear59 = and i8 %bf.load58, 15
  %conv60 = zext i8 %bf.clear59 to i32
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg61 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %33, i32 0, i32 1
  %bf.load62 = load i8, i8* %dst_reg61, align 1
  %bf.clear63 = and i8 %bf.load62, 15
  %conv64 = zext i8 %bf.clear63 to i32
  %call65 = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %32, i32 noundef %conv64) #11
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %call65, i32 0, i32 0
  %34 = load i32, i32* %type, align 8
  %idxprom = zext i32 %34 to i64
  %arrayidx = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %35 = load i8*, i8** %arrayidx, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.253, i64 0, i64 0), i32 noundef %conv60, i8* noundef %35) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end66:                                         ; preds = %lor.lhs.false49
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = load i32, i32* %insn_idx.addr, align 4
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg67 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 1
  %bf.load68 = load i8, i8* %dst_reg67, align 1
  %bf.clear69 = and i8 %bf.load68, 15
  %conv70 = zext i8 %bf.clear69 to i32
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %39, i32 0, i32 2
  %40 = load i16, i16* %off, align 2
  %conv71 = sext i16 %40 to i32
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code72 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %41, i32 0, i32 0
  %42 = load i8, i8* %code72, align 4
  %conv73 = zext i8 %42 to i32
  %and74 = and i32 %conv73, 24
  %call75 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %36, i32 noundef %37, i32 noundef %conv70, i32 noundef %conv71, i32 noundef %and74, i32 noundef 1, i32 noundef -1, i1 noundef zeroext true) #11
  store i32 %call75, i32* %err, align 4
  %43 = load i32, i32* %err, align 4
  %tobool76 = icmp ne i32 %43, 0
  br i1 %tobool76, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.end66
  %44 = load i32, i32* %err, align 4
  store i32 %44, i32* %retval, align 4
  br label %return

if.end78:                                         ; preds = %if.end66
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = load i32, i32* %insn_idx.addr, align 4
  %47 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg79 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %47, i32 0, i32 1
  %bf.load80 = load i8, i8* %dst_reg79, align 1
  %bf.clear81 = and i8 %bf.load80, 15
  %conv82 = zext i8 %bf.clear81 to i32
  %48 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off83 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %48, i32 0, i32 2
  %49 = load i16, i16* %off83, align 2
  %conv84 = sext i16 %49 to i32
  %50 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code85 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %50, i32 0, i32 0
  %51 = load i8, i8* %code85, align 4
  %conv86 = zext i8 %51 to i32
  %and87 = and i32 %conv86, 24
  %call88 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %45, i32 noundef %46, i32 noundef %conv82, i32 noundef %conv84, i32 noundef %and87, i32 noundef 2, i32 noundef -1, i1 noundef zeroext true) #11
  store i32 %call88, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end78, %if.then77, %if.then56, %if.then23, %if.then16, %if.then10, %if.then
  %52 = load i32, i32* %retval, align 4
  ret i32 %52
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_ctx_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %3, 2
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #11
  %1 = load i32, i32* %regno.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call, i64 %idx.ext
  ret %struct.bpf_reg_state* %add.ptr
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_func_call(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %state = alloca %struct.bpf_verifier_state*, align 8
  %func_info_aux = alloca %struct.bpf_func_info_aux*, align 8
  %caller = alloca %struct.bpf_func_state*, align 8
  %callee = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %subprog = alloca i32, align 4
  %target_insn = alloca i32, align 4
  %is_global = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %state, align 8
  store i8 0, i8* %is_global, align 1
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe, align 8
  %add = add i32 %3, 1
  %cmp = icmp uge i32 %add, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 4
  %7 = load i32, i32* %curframe1, align 8
  %add2 = add i32 %7, 2
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.282, i64 0, i64 0), i32 noundef %add2) #11
  store i32 -7, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load i32*, i32** %insn_idx.addr, align 8
  %9 = load i32, i32* %8, align 4
  %10 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %10, i32 0, i32 3
  %11 = load i32, i32* %imm, align 4
  %add3 = add i32 %9, %11
  store i32 %add3, i32* %target_insn, align 4
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load i32, i32* %target_insn, align 4
  %add4 = add i32 %13, 1
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %12, i32 noundef %add4) #11
  store i32 %call, i32* %subprog, align 4
  %14 = load i32, i32* %subprog, align 4
  %cmp5 = icmp slt i32 %14, 0
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = bitcast %struct.bpf_verifier_env* %15 to i8*
  %17 = load i32, i32* %target_insn, align 4
  %add7 = add i32 %17, 1
  call void (i8*, i8*, ...) @verbose(i8* noundef %16, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.283, i64 0, i64 0), i32 noundef %add7) #11
  store i32 -14, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 0
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe9 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 4
  %20 = load i32, i32* %curframe9, align 8
  %idxprom = zext i32 %20 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %21, %struct.bpf_func_state** %caller, align 8
  %22 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %22, i32 0, i32 0
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe11 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 4
  %24 = load i32, i32* %curframe11, align 8
  %add12 = add i32 %24, 1
  %idxprom13 = zext i32 %add12 to i64
  %arrayidx14 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame10, i64 0, i64 %idxprom13
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx14, align 8
  %tobool = icmp ne %struct.bpf_func_state* %25, null
  br i1 %tobool, label %if.then15, label %if.end18

if.then15:                                        ; preds = %if.end8
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe16 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %28, i32 0, i32 4
  %29 = load i32, i32* %curframe16, align 8
  %add17 = add i32 %29, 1
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.284, i64 0, i64 0), i32 noundef %add17) #11
  store i32 -14, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end8
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 2
  %31 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %31, i32 0, i32 7
  %32 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %func_info_aux19 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %32, i32 0, i32 46
  %33 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux19, align 8
  store %struct.bpf_func_info_aux* %33, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %34 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %tobool20 = icmp ne %struct.bpf_func_info_aux* %34, null
  br i1 %tobool20, label %if.then21, label %if.end26

if.then21:                                        ; preds = %if.end18
  %35 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %func_info_aux, align 8
  %36 = load i32, i32* %subprog, align 4
  %idxprom22 = sext i32 %36 to i64
  %arrayidx23 = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %35, i64 %idxprom22
  %linkage = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx23, i32 0, i32 0
  %37 = load i16, i16* %linkage, align 2
  %conv = zext i16 %37 to i32
  %cmp24 = icmp eq i32 %conv, 1
  %frombool = zext i1 %cmp24 to i8
  store i8 %frombool, i8* %is_global, align 1
  br label %if.end26

if.end26:                                         ; preds = %if.then21, %if.end18
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load i32, i32* %subprog, align 4
  %40 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %40, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %call27 = call i32 @btf_check_func_arg_match(%struct.bpf_verifier_env* noundef %38, i32 noundef %39, %struct.bpf_reg_state* noundef %arraydecay) #11
  store i32 %call27, i32* %err, align 4
  %41 = load i32, i32* %err, align 4
  %cmp28 = icmp eq i32 %41, -14
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end26
  %42 = load i32, i32* %err, align 4
  store i32 %42, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end26
  %43 = load i8, i8* %is_global, align 1
  %tobool32 = trunc i8 %43 to i1
  br i1 %tobool32, label %if.then33, label %if.end43

if.then33:                                        ; preds = %if.end31
  %44 = load i32, i32* %err, align 4
  %tobool34 = icmp ne i32 %44, 0
  br i1 %tobool34, label %if.then35, label %if.else

if.then35:                                        ; preds = %if.then33
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = bitcast %struct.bpf_verifier_env* %45 to i8*
  %47 = load i32, i32* %subprog, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %46, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.285, i64 0, i64 0), i32 noundef %47) #11
  %48 = load i32, i32* %err, align 4
  store i32 %48, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.then33
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %49, i32 0, i32 22
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %50 = load i32, i32* %level, align 8
  %and = and i32 %50, 3
  %tobool36 = icmp ne i32 %and, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.else
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  %53 = load i32, i32* %subprog, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.286, i64 0, i64 0), i32 noundef %53) #11
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.else
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs39 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %55, i32 0, i32 0
  %arraydecay40 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs39, i64 0, i64 0
  call void @clear_caller_saved_regs(%struct.bpf_verifier_env* noundef %54, %struct.bpf_reg_state* noundef %arraydecay40) #11
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs41 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %57, i32 0, i32 0
  %arraydecay42 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs41, i64 0, i64 0
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %56, %struct.bpf_reg_state* noundef %arraydecay42, i32 noundef 0) #11
  store i32 0, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.end31
  %call44 = call i8* @kzalloc(i64 noundef 1360, i32 noundef 3264) #11
  %58 = bitcast i8* %call44 to %struct.bpf_func_state*
  store %struct.bpf_func_state* %58, %struct.bpf_func_state** %callee, align 8
  %59 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %tobool45 = icmp ne %struct.bpf_func_state* %59, null
  br i1 %tobool45, label %if.end47, label %if.then46

if.then46:                                        ; preds = %if.end43
  store i32 -12, i32* %retval, align 4
  br label %return

if.end47:                                         ; preds = %if.end43
  %60 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %61 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame48 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %61, i32 0, i32 0
  %62 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe49 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %62, i32 0, i32 4
  %63 = load i32, i32* %curframe49, align 8
  %add50 = add i32 %63, 1
  %idxprom51 = zext i32 %add50 to i64
  %arrayidx52 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame48, i64 0, i64 %idxprom51
  store %struct.bpf_func_state* %60, %struct.bpf_func_state** %arrayidx52, align 8
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %66 = load i32*, i32** %insn_idx.addr, align 8
  %67 = load i32, i32* %66, align 4
  %68 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe53 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %68, i32 0, i32 4
  %69 = load i32, i32* %curframe53, align 8
  %add54 = add i32 %69, 1
  %70 = load i32, i32* %subprog, align 4
  call void @init_func_state(%struct.bpf_verifier_env* noundef %64, %struct.bpf_func_state* noundef %65, i32 noundef %67, i32 noundef %add54, i32 noundef %70) #11
  %71 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %72 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %call55 = call i32 @transfer_reference_state(%struct.bpf_func_state* noundef %71, %struct.bpf_func_state* noundef %72) #11
  store i32 %call55, i32* %err, align 4
  %73 = load i32, i32* %err, align 4
  %tobool56 = icmp ne i32 %73, 0
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.end47
  %74 = load i32, i32* %err, align 4
  store i32 %74, i32* %retval, align 4
  br label %return

if.end58:                                         ; preds = %if.end47
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end58
  %75 = load i32, i32* %i, align 4
  %cmp59 = icmp sle i32 %75, 5
  br i1 %cmp59, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %76 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %regs61 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %76, i32 0, i32 0
  %77 = load i32, i32* %i, align 4
  %idxprom62 = sext i32 %77 to i64
  %arrayidx63 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs61, i64 0, i64 %idxprom62
  %78 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs64 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %78, i32 0, i32 0
  %79 = load i32, i32* %i, align 4
  %idxprom65 = sext i32 %79 to i64
  %arrayidx66 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs64, i64 0, i64 %idxprom65
  %80 = bitcast %struct.bpf_reg_state* %arrayidx63 to i8*
  %81 = bitcast %struct.bpf_reg_state* %arrayidx66 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %80, i8* align 8 %81, i64 120, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %82 = load i32, i32* %i, align 4
  %inc = add i32 %82, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %84 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs67 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %84, i32 0, i32 0
  %arraydecay68 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs67, i64 0, i64 0
  call void @clear_caller_saved_regs(%struct.bpf_verifier_env* noundef %83, %struct.bpf_reg_state* noundef %arraydecay68) #11
  %85 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe69 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %85, i32 0, i32 4
  %86 = load i32, i32* %curframe69, align 8
  %inc70 = add i32 %86, 1
  store i32 %inc70, i32* %curframe69, align 8
  %87 = load i32, i32* %target_insn, align 4
  %88 = load i32*, i32** %insn_idx.addr, align 8
  store i32 %87, i32* %88, align 4
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log71 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %89, i32 0, i32 22
  %level72 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log71, i32 0, i32 0
  %90 = load i32, i32* %level72, align 8
  %and73 = and i32 %90, 3
  %tobool74 = icmp ne i32 %and73, 0
  br i1 %tobool74, label %if.then75, label %if.end76

if.then75:                                        ; preds = %for.end
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %92 = bitcast %struct.bpf_verifier_env* %91 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %92, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.287, i64 0, i64 0)) #11
  %93 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %94 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %93, %struct.bpf_func_state* noundef %94) #11
  %95 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %96 = bitcast %struct.bpf_verifier_env* %95 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %96, i8* noundef getelementptr inbounds ([9 x i8], [9 x i8]* @.str.288, i64 0, i64 0)) #11
  %97 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %98 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %97, %struct.bpf_func_state* noundef %98) #11
  br label %if.end76

if.end76:                                         ; preds = %if.then75, %for.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end76, %if.then57, %if.then46, %if.end38, %if.then35, %if.then30, %if.then15, %if.then6, %if.then
  %99 = load i32, i32* %retval, align 4
  ret i32 %99
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_helper_call(%struct.bpf_verifier_env* noundef %env, i32 noundef %func_id, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %func_id.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %fn = alloca %struct.bpf_func_proto*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %meta = alloca %struct.bpf_call_arg_meta, align 8
  %changes_data = alloca i8, align 1
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %t = alloca %struct.btf_type*, align 8
  %tsize = alloca i32, align 4
  %ret = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %ret_btf_id190 = alloca i32, align 4
  %id231 = alloca i32, align 4
  %err_str = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store %struct.bpf_func_proto* null, %struct.bpf_func_proto** %fn, align 8
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp sge i32 %1, 156
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  %4 = load i32, i32* %func_id.addr, align 4
  %call = call i8* @func_id_name(i32 noundef %4) #11
  %5 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([20 x i8], [20 x i8]* @.str.289, i64 0, i64 0), i8* noundef %call, i32 noundef %5) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 3
  %7 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %get_func_proto = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %7, i32 0, i32 0
  %8 = load %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, %struct.bpf_func_proto* (i32, %struct.bpf_prog*)** %get_func_proto, align 8
  %tobool = icmp ne %struct.bpf_func_proto* (i32, %struct.bpf_prog*)* %8, null
  br i1 %tobool, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 3
  %10 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops3, align 8
  %get_func_proto4 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %10, i32 0, i32 0
  %11 = load %struct.bpf_func_proto* (i32, %struct.bpf_prog*)*, %struct.bpf_func_proto* (i32, %struct.bpf_prog*)** %get_func_proto4, align 8
  %12 = load i32, i32* %func_id.addr, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 2
  %14 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call5 = call %struct.bpf_func_proto* %11(i32 noundef %12, %struct.bpf_prog* noundef %14) #11
  store %struct.bpf_func_proto* %call5, %struct.bpf_func_proto** %fn, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then2, %if.end
  %15 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %tobool7 = icmp ne %struct.bpf_func_proto* %15, null
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %if.end6
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load i32, i32* %func_id.addr, align 4
  %call9 = call i8* @func_id_name(i32 noundef %18) #11
  %19 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([20 x i8], [20 x i8]* @.str.290, i64 0, i64 0), i8* noundef %call9, i32 noundef %19) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 2
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog11, align 8
  %gpl_compatible = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 1
  %bf.load = load i16, i16* %gpl_compatible, align 2
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %tobool12 = icmp ne i16 %bf.clear, 0
  br i1 %tobool12, label %if.end15, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end10
  %22 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %gpl_only = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %22, i32 0, i32 1
  %23 = load i8, i8* %gpl_only, align 8
  %tobool13 = trunc i8 %23 to i1
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.291, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %land.lhs.true, %if.end10
  %26 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %allowed = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %26, i32 0, i32 7
  %27 = load i1 (%struct.bpf_prog*)*, i1 (%struct.bpf_prog*)** %allowed, align 8
  %tobool16 = icmp ne i1 (%struct.bpf_prog*)* %27, null
  br i1 %tobool16, label %land.lhs.true17, label %if.end22

land.lhs.true17:                                  ; preds = %if.end15
  %28 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %allowed18 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %28, i32 0, i32 7
  %29 = load i1 (%struct.bpf_prog*)*, i1 (%struct.bpf_prog*)** %allowed18, align 8
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog19 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 2
  %31 = load %struct.bpf_prog*, %struct.bpf_prog** %prog19, align 8
  %call20 = call zeroext i1 %29(%struct.bpf_prog* noundef %31) #11
  br i1 %call20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %land.lhs.true17
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = bitcast %struct.bpf_verifier_env* %32 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %33, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.292, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %land.lhs.true17, %if.end15
  %34 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %func = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %34, i32 0, i32 0
  %35 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %func, align 8
  %36 = bitcast i64 (i64, i64, i64, i64, i64)* %35 to i8*
  %call23 = call zeroext i1 @bpf_helper_changes_pkt_data(i8* noundef %36) #11
  %frombool = zext i1 %call23 to i8
  store i8 %frombool, i8* %changes_data, align 1
  %37 = load i8, i8* %changes_data, align 1
  %tobool24 = trunc i8 %37 to i1
  br i1 %tobool24, label %land.lhs.true25, label %if.end29

land.lhs.true25:                                  ; preds = %if.end22
  %38 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %39 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %38, i32 0, i32 4
  %40 = bitcast %union.anon.168* %39 to %struct.gnet_stats_queue*
  %arg1_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %40, i32 0, i32 0
  %41 = load i32, i32* %arg1_type, align 8
  %cmp26 = icmp ne i32 %41, 11
  br i1 %cmp26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %land.lhs.true25
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %43 = bitcast %struct.bpf_verifier_env* %42 to i8*
  %44 = load i32, i32* %func_id.addr, align 4
  %call28 = call i8* @func_id_name(i32 noundef %44) #11
  %45 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %43, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.293, i64 0, i64 0), i8* noundef %call28, i32 noundef %45) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %land.lhs.true25, %if.end22
  %46 = bitcast %struct.bpf_call_arg_meta* %meta to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %46, i8 0, i64 48, i1 false)
  %47 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %pkt_access = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %47, i32 0, i32 2
  %48 = load i8, i8* %pkt_access, align 1
  %tobool30 = trunc i8 %48 to i1
  %pkt_access31 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 2
  %frombool32 = zext i1 %tobool30 to i8
  store i8 %frombool32, i8* %pkt_access31, align 1
  %49 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %50 = load i32, i32* %func_id.addr, align 4
  %call33 = call i32 @check_func_proto(%struct.bpf_func_proto* noundef %49, i32 noundef %50) #11
  store i32 %call33, i32* %err, align 4
  %51 = load i32, i32* %err, align 4
  %tobool34 = icmp ne i32 %51, 0
  br i1 %tobool34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end29
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  %54 = load i32, i32* %func_id.addr, align 4
  %call36 = call i8* @func_id_name(i32 noundef %54) #11
  %55 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.294, i64 0, i64 0), i8* noundef %call36, i32 noundef %55) #11
  %56 = load i32, i32* %err, align 4
  store i32 %56, i32* %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end29
  %57 = load i32, i32* %func_id.addr, align 4
  %func_id38 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 8
  store i32 %57, i32* %func_id38, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end37
  %58 = load i32, i32* %i, align 4
  %cmp39 = icmp slt i32 %58, 5
  br i1 %cmp39, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = load i32, i32* %i, align 4
  %61 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %call40 = call i32 @check_func_arg(%struct.bpf_verifier_env* noundef %59, i32 noundef %60, %struct.bpf_call_arg_meta* noundef %meta, %struct.bpf_func_proto* noundef %61) #11
  store i32 %call40, i32* %err, align 4
  %62 = load i32, i32* %err, align 4
  %tobool41 = icmp ne i32 %62, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %for.body
  %63 = load i32, i32* %err, align 4
  store i32 %63, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end43
  %64 = load i32, i32* %i, align 4
  %inc = add i32 %64, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %66 = load i32, i32* %func_id.addr, align 4
  %67 = load i32, i32* %insn_idx.addr, align 4
  %call44 = call i32 @record_func_map(%struct.bpf_verifier_env* noundef %65, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %66, i32 noundef %67) #11
  store i32 %call44, i32* %err, align 4
  %68 = load i32, i32* %err, align 4
  %tobool45 = icmp ne i32 %68, 0
  br i1 %tobool45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %for.end
  %69 = load i32, i32* %err, align 4
  store i32 %69, i32* %retval, align 4
  br label %return

if.end47:                                         ; preds = %for.end
  %70 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %71 = load i32, i32* %func_id.addr, align 4
  %72 = load i32, i32* %insn_idx.addr, align 4
  %call48 = call i32 @record_func_key(%struct.bpf_verifier_env* noundef %70, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %71, i32 noundef %72) #11
  store i32 %call48, i32* %err, align 4
  %73 = load i32, i32* %err, align 4
  %tobool49 = icmp ne i32 %73, 0
  br i1 %tobool49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.end47
  %74 = load i32, i32* %err, align 4
  store i32 %74, i32* %retval, align 4
  br label %return

if.end51:                                         ; preds = %if.end47
  store i32 0, i32* %i, align 4
  br label %for.cond52

for.cond52:                                       ; preds = %for.inc59, %if.end51
  %75 = load i32, i32* %i, align 4
  %access_size = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 4
  %76 = load i32, i32* %access_size, align 8
  %cmp53 = icmp slt i32 %75, %76
  br i1 %cmp53, label %for.body54, label %for.end61

for.body54:                                       ; preds = %for.cond52
  %77 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %78 = load i32, i32* %insn_idx.addr, align 4
  %regno = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 3
  %79 = load i32, i32* %regno, align 4
  %80 = load i32, i32* %i, align 4
  %call55 = call i32 @check_mem_access(%struct.bpf_verifier_env* noundef %77, i32 noundef %78, i32 noundef %79, i32 noundef %80, i32 noundef 16, i32 noundef 2, i32 noundef -1, i1 noundef zeroext false) #11
  store i32 %call55, i32* %err, align 4
  %81 = load i32, i32* %err, align 4
  %tobool56 = icmp ne i32 %81, 0
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %for.body54
  %82 = load i32, i32* %err, align 4
  store i32 %82, i32* %retval, align 4
  br label %return

if.end58:                                         ; preds = %for.body54
  br label %for.inc59

for.inc59:                                        ; preds = %if.end58
  %83 = load i32, i32* %i, align 4
  %inc60 = add i32 %83, 1
  store i32 %inc60, i32* %i, align 4
  br label %for.cond52

for.end61:                                        ; preds = %for.cond52
  %84 = load i32, i32* %func_id.addr, align 4
  %cmp62 = icmp eq i32 %84, 12
  br i1 %cmp62, label %if.then63, label %if.else

if.then63:                                        ; preds = %for.end61
  %85 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call64 = call i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %85) #11
  store i32 %call64, i32* %err, align 4
  %86 = load i32, i32* %err, align 4
  %tobool65 = icmp ne i32 %86, 0
  br i1 %tobool65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.then63
  %87 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %88 = bitcast %struct.bpf_verifier_env* %87 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %88, i8* noundef getelementptr inbounds ([40 x i8], [40 x i8]* @.str.295, i64 0, i64 0)) #11
  %89 = load i32, i32* %err, align 4
  store i32 %89, i32* %retval, align 4
  br label %return

if.end67:                                         ; preds = %if.then63
  br label %if.end76

if.else:                                          ; preds = %for.end61
  %90 = load i32, i32* %func_id.addr, align 4
  %call68 = call zeroext i1 @is_release_function(i32 noundef %90) #11
  br i1 %call68, label %if.then69, label %if.end75

if.then69:                                        ; preds = %if.else
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 7
  %92 = load i32, i32* %ref_obj_id, align 8
  %call70 = call i32 @release_reference(%struct.bpf_verifier_env* noundef %91, i32 noundef %92) #11
  store i32 %call70, i32* %err, align 4
  %93 = load i32, i32* %err, align 4
  %tobool71 = icmp ne i32 %93, 0
  br i1 %tobool71, label %if.then72, label %if.end74

if.then72:                                        ; preds = %if.then69
  %94 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %95 = bitcast %struct.bpf_verifier_env* %94 to i8*
  %96 = load i32, i32* %func_id.addr, align 4
  %call73 = call i8* @func_id_name(i32 noundef %96) #11
  %97 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %95, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.296, i64 0, i64 0), i8* noundef %call73, i32 noundef %97) #11
  %98 = load i32, i32* %err, align 4
  store i32 %98, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %if.then69
  br label %if.end75

if.end75:                                         ; preds = %if.end74, %if.else
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end67
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call77 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %99) #11
  store %struct.bpf_reg_state* %call77, %struct.bpf_reg_state** %regs, align 8
  %100 = load i32, i32* %func_id.addr, align 4
  %cmp78 = icmp eq i32 %100, 81
  br i1 %cmp78, label %land.lhs.true79, label %if.end82

land.lhs.true79:                                  ; preds = %if.end76
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %101, i64 2
  %call80 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %arrayidx) #11
  br i1 %call80, label %if.end82, label %if.then81

if.then81:                                        ; preds = %land.lhs.true79
  %102 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %103 = bitcast %struct.bpf_verifier_env* %102 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %103, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.297, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %land.lhs.true79, %if.end76
  store i32 0, i32* %i, align 4
  br label %for.cond83

for.cond83:                                       ; preds = %for.inc90, %if.end82
  %104 = load i32, i32* %i, align 4
  %cmp84 = icmp slt i32 %104, 6
  br i1 %cmp84, label %for.body85, label %for.end92

for.body85:                                       ; preds = %for.cond83
  %105 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %106 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %107 = load i32, i32* %i, align 4
  %idxprom = sext i32 %107 to i64
  %arrayidx86 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom
  %108 = load i32, i32* %arrayidx86, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %105, %struct.bpf_reg_state* noundef %106, i32 noundef %108) #11
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %110 = load i32, i32* %i, align 4
  %idxprom87 = sext i32 %110 to i64
  %arrayidx88 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom87
  %111 = load i32, i32* %arrayidx88, align 4
  %call89 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %109, i32 noundef %111, i32 noundef 2) #11
  br label %for.inc90

for.inc90:                                        ; preds = %for.body85
  %112 = load i32, i32* %i, align 4
  %inc91 = add i32 %112, 1
  store i32 %inc91, i32* %i, align 4
  br label %for.cond83

for.end92:                                        ; preds = %for.cond83
  %113 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx93 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %113, i64 0
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx93, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  %114 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %114, i32 0, i32 3
  %115 = load i32, i32* %ret_type, align 4
  %cmp94 = icmp eq i32 %115, 0
  br i1 %cmp94, label %if.then95, label %if.else96

if.then95:                                        ; preds = %for.end92
  %116 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %117 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %116, %struct.bpf_reg_state* noundef %117, i32 noundef 0) #11
  br label %if.end212

if.else96:                                        ; preds = %for.end92
  %118 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type97 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %118, i32 0, i32 3
  %119 = load i32, i32* %ret_type97, align 4
  %cmp98 = icmp eq i32 %119, 1
  br i1 %cmp98, label %if.then99, label %if.else101

if.then99:                                        ; preds = %if.else96
  %120 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx100 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %120, i64 0
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx100, i32 0, i32 0
  store i32 0, i32* %type, align 8
  br label %if.end211

if.else101:                                       ; preds = %if.else96
  %121 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type102 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %121, i32 0, i32 3
  %122 = load i32, i32* %ret_type102, align 4
  %cmp103 = icmp eq i32 %122, 3
  br i1 %cmp103, label %if.then107, label %lor.lhs.false104

lor.lhs.false104:                                 ; preds = %if.else101
  %123 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type105 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %123, i32 0, i32 3
  %124 = load i32, i32* %ret_type105, align 4
  %cmp106 = icmp eq i32 %124, 2
  br i1 %cmp106, label %if.then107, label %if.else129

if.then107:                                       ; preds = %lor.lhs.false104, %if.else101
  %125 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %126 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %125, %struct.bpf_reg_state* noundef %126, i32 noundef 0) #11
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %127 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %cmp108 = icmp eq %struct.bpf_map* %127, null
  br i1 %cmp108, label %if.then109, label %if.end110

if.then109:                                       ; preds = %if.then107
  %128 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %129 = bitcast %struct.bpf_verifier_env* %128 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %129, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.298, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end110:                                        ; preds = %if.then107
  %map_ptr111 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %130 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr111, align 8
  %131 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx112 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %131, i64 0
  %132 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx112, i32 0, i32 1
  %map_ptr113 = bitcast %struct.bpf_iter_aux_info* %132 to %struct.bpf_map**
  store %struct.bpf_map* %130, %struct.bpf_map** %map_ptr113, align 8
  %133 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type114 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %133, i32 0, i32 3
  %134 = load i32, i32* %ret_type114, align 4
  %cmp115 = icmp eq i32 %134, 2
  br i1 %cmp115, label %if.then116, label %if.else125

if.then116:                                       ; preds = %if.end110
  %135 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx117 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %135, i64 0
  %type118 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx117, i32 0, i32 0
  store i32 4, i32* %type118, align 8
  %map_ptr119 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %136 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr119, align 8
  %call120 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %136) #11
  br i1 %call120, label %if.then121, label %if.end124

if.then121:                                       ; preds = %if.then116
  %137 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %137, i32 0, i32 13
  %138 = load i32, i32* %id_gen, align 4
  %inc122 = add i32 %138, 1
  store i32 %inc122, i32* %id_gen, align 4
  %139 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx123 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %139, i64 0
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx123, i32 0, i32 3
  store i32 %inc122, i32* %id, align 4
  br label %if.end124

if.end124:                                        ; preds = %if.then121, %if.then116
  br label %if.end128

if.else125:                                       ; preds = %if.end110
  %140 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx126 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %140, i64 0
  %type127 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx126, i32 0, i32 0
  store i32 5, i32* %type127, align 8
  br label %if.end128

if.end128:                                        ; preds = %if.else125, %if.end124
  br label %if.end210

if.else129:                                       ; preds = %lor.lhs.false104
  %141 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type130 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %141, i32 0, i32 3
  %142 = load i32, i32* %ret_type130, align 4
  %cmp131 = icmp eq i32 %142, 4
  br i1 %cmp131, label %if.then132, label %if.else135

if.then132:                                       ; preds = %if.else129
  %143 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %144 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %143, %struct.bpf_reg_state* noundef %144, i32 noundef 0) #11
  %145 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx133 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %145, i64 0
  %type134 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx133, i32 0, i32 0
  store i32 12, i32* %type134, align 8
  br label %if.end209

if.else135:                                       ; preds = %if.else129
  %146 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type136 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %146, i32 0, i32 3
  %147 = load i32, i32* %ret_type136, align 4
  %cmp137 = icmp eq i32 %147, 6
  br i1 %cmp137, label %if.then138, label %if.else141

if.then138:                                       ; preds = %if.else135
  %148 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %149 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %148, %struct.bpf_reg_state* noundef %149, i32 noundef 0) #11
  %150 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx139 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %150, i64 0
  %type140 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx139, i32 0, i32 0
  store i32 14, i32* %type140, align 8
  br label %if.end208

if.else141:                                       ; preds = %if.else135
  %151 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type142 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %151, i32 0, i32 3
  %152 = load i32, i32* %ret_type142, align 4
  %cmp143 = icmp eq i32 %152, 5
  br i1 %cmp143, label %if.then144, label %if.else147

if.then144:                                       ; preds = %if.else141
  %153 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %154 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %153, %struct.bpf_reg_state* noundef %154, i32 noundef 0) #11
  %155 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx145 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %155, i64 0
  %type146 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx145, i32 0, i32 0
  store i32 16, i32* %type146, align 8
  br label %if.end207

if.else147:                                       ; preds = %if.else141
  %156 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type148 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %156, i32 0, i32 3
  %157 = load i32, i32* %ret_type148, align 4
  %cmp149 = icmp eq i32 %157, 7
  br i1 %cmp149, label %if.then150, label %if.else155

if.then150:                                       ; preds = %if.else147
  %158 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %159 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %158, %struct.bpf_reg_state* noundef %159, i32 noundef 0) #11
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx151 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i64 0
  %type152 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx151, i32 0, i32 0
  store i32 22, i32* %type152, align 8
  %mem_size = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 5
  %161 = load i32, i32* %mem_size, align 4
  %162 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx153 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %162, i64 0
  %163 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx153, i32 0, i32 1
  %mem_size154 = bitcast %struct.bpf_iter_aux_info* %163 to i32*
  store i32 %161, i32* %mem_size154, align 8
  br label %if.end206

if.else155:                                       ; preds = %if.else147
  %164 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type156 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %164, i32 0, i32 3
  %165 = load i32, i32* %ret_type156, align 4
  %cmp157 = icmp eq i32 %165, 9
  br i1 %cmp157, label %if.then161, label %lor.lhs.false158

lor.lhs.false158:                                 ; preds = %if.else155
  %166 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type159 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %166, i32 0, i32 3
  %167 = load i32, i32* %ret_type159, align 4
  %cmp160 = icmp eq i32 %167, 10
  br i1 %cmp160, label %if.then161, label %if.else186

if.then161:                                       ; preds = %lor.lhs.false158, %if.else155
  %168 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %169 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %168, %struct.bpf_reg_state* noundef %169, i32 noundef 0) #11
  %170 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %ret_btf_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 10
  %171 = load i32, i32* %ret_btf_id, align 4
  %call162 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %170, i32 noundef %171, i32* noundef null) #11
  store %struct.btf_type* %call162, %struct.btf_type** %t, align 8
  %172 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call163 = call zeroext i1 @btf_type_is_struct(%struct.btf_type* noundef %172) #11
  br i1 %call163, label %if.else177, label %if.then164

if.then164:                                       ; preds = %if.then161
  %173 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %174 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call165 = call %struct.btf_type* @btf_resolve_size(%struct.btf* noundef %173, %struct.btf_type* noundef %174, i32* noundef %tsize) #11
  store %struct.btf_type* %call165, %struct.btf_type** %ret, align 8
  %175 = load %struct.btf_type*, %struct.btf_type** %ret, align 8
  %176 = bitcast %struct.btf_type* %175 to i8*
  %call166 = call zeroext i1 @IS_ERR(i8* noundef %176) #11
  br i1 %call166, label %if.then167, label %if.end170

if.then167:                                       ; preds = %if.then164
  %177 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %178 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %178, i32 0, i32 0
  %179 = load i32, i32* %name_off, align 4
  %call168 = call i8* @btf_name_by_offset(%struct.btf* noundef %177, i32 noundef %179) #11
  store i8* %call168, i8** %tname, align 8
  %180 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %181 = bitcast %struct.bpf_verifier_env* %180 to i8*
  %182 = load i8*, i8** %tname, align 8
  %183 = load %struct.btf_type*, %struct.btf_type** %ret, align 8
  %184 = bitcast %struct.btf_type* %183 to i8*
  %call169 = call i64 @PTR_ERR(i8* noundef %184) #11
  call void (i8*, i8*, ...) @verbose(i8* noundef %181, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.299, i64 0, i64 0), i8* noundef %182, i64 noundef %call169) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end170:                                        ; preds = %if.then164
  %185 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type171 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %185, i32 0, i32 3
  %186 = load i32, i32* %ret_type171, align 4
  %cmp172 = icmp eq i32 %186, 10
  %187 = zext i1 %cmp172 to i64
  %cond = select i1 %cmp172, i32 21, i32 22
  %188 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx173 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %188, i64 0
  %type174 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx173, i32 0, i32 0
  store i32 %cond, i32* %type174, align 8
  %189 = load i32, i32* %tsize, align 4
  %190 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx175 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %190, i64 0
  %191 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx175, i32 0, i32 1
  %mem_size176 = bitcast %struct.bpf_iter_aux_info* %191 to i32*
  store i32 %189, i32* %mem_size176, align 8
  br label %if.end185

if.else177:                                       ; preds = %if.then161
  %192 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type178 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %192, i32 0, i32 3
  %193 = load i32, i32* %ret_type178, align 4
  %cmp179 = icmp eq i32 %193, 10
  %194 = zext i1 %cmp179 to i64
  %cond180 = select i1 %cmp179, i32 19, i32 20
  %195 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx181 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %195, i64 0
  %type182 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx181, i32 0, i32 0
  store i32 %cond180, i32* %type182, align 8
  %ret_btf_id183 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 10
  %196 = load i32, i32* %ret_btf_id183, align 4
  %197 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx184 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %197, i64 0
  %198 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx184, i32 0, i32 1
  %btf_id = bitcast %struct.bpf_iter_aux_info* %198 to i32*
  store i32 %196, i32* %btf_id, align 8
  br label %if.end185

if.end185:                                        ; preds = %if.else177, %if.end170
  br label %if.end205

if.else186:                                       ; preds = %lor.lhs.false158
  %199 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type187 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %199, i32 0, i32 3
  %200 = load i32, i32* %ret_type187, align 4
  %cmp188 = icmp eq i32 %200, 8
  br i1 %cmp188, label %if.then189, label %if.else201

if.then189:                                       ; preds = %if.else186
  %201 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %202 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %201, %struct.bpf_reg_state* noundef %202, i32 noundef 0) #11
  %203 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx191 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %203, i64 0
  %type192 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx191, i32 0, i32 0
  store i32 20, i32* %type192, align 8
  %204 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_btf_id193 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %204, i32 0, i32 6
  %205 = load i32*, i32** %ret_btf_id193, align 8
  %206 = load i32, i32* %205, align 4
  store i32 %206, i32* %ret_btf_id190, align 4
  %207 = load i32, i32* %ret_btf_id190, align 4
  %cmp194 = icmp eq i32 %207, 0
  br i1 %cmp194, label %if.then195, label %if.end198

if.then195:                                       ; preds = %if.then189
  %208 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %209 = bitcast %struct.bpf_verifier_env* %208 to i8*
  %210 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type196 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %210, i32 0, i32 3
  %211 = load i32, i32* %ret_type196, align 4
  %212 = load i32, i32* %func_id.addr, align 4
  %call197 = call i8* @func_id_name(i32 noundef %212) #11
  %213 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %209, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.300, i64 0, i64 0), i32 noundef %211, i8* noundef %call197, i32 noundef %213) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end198:                                        ; preds = %if.then189
  %214 = load i32, i32* %ret_btf_id190, align 4
  %215 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx199 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %215, i64 0
  %216 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx199, i32 0, i32 1
  %btf_id200 = bitcast %struct.bpf_iter_aux_info* %216 to i32*
  store i32 %214, i32* %btf_id200, align 8
  br label %if.end204

if.else201:                                       ; preds = %if.else186
  %217 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %218 = bitcast %struct.bpf_verifier_env* %217 to i8*
  %219 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type202 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %219, i32 0, i32 3
  %220 = load i32, i32* %ret_type202, align 4
  %221 = load i32, i32* %func_id.addr, align 4
  %call203 = call i8* @func_id_name(i32 noundef %221) #11
  %222 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %218, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.301, i64 0, i64 0), i32 noundef %220, i8* noundef %call203, i32 noundef %222) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end204:                                        ; preds = %if.end198
  br label %if.end205

if.end205:                                        ; preds = %if.end204, %if.end185
  br label %if.end206

if.end206:                                        ; preds = %if.end205, %if.then150
  br label %if.end207

if.end207:                                        ; preds = %if.end206, %if.then144
  br label %if.end208

if.end208:                                        ; preds = %if.end207, %if.then138
  br label %if.end209

if.end209:                                        ; preds = %if.end208, %if.then132
  br label %if.end210

if.end210:                                        ; preds = %if.end209, %if.end128
  br label %if.end211

if.end211:                                        ; preds = %if.end210, %if.then99
  br label %if.end212

if.end212:                                        ; preds = %if.end211, %if.then95
  %223 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx213 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %223, i64 0
  %type214 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx213, i32 0, i32 0
  %224 = load i32, i32* %type214, align 8
  %call215 = call zeroext i1 @reg_type_may_be_null(i32 noundef %224) #11
  br i1 %call215, label %if.then216, label %if.end221

if.then216:                                       ; preds = %if.end212
  %225 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen217 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %225, i32 0, i32 13
  %226 = load i32, i32* %id_gen217, align 4
  %inc218 = add i32 %226, 1
  store i32 %inc218, i32* %id_gen217, align 4
  %227 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx219 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %227, i64 0
  %id220 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx219, i32 0, i32 3
  store i32 %inc218, i32* %id220, align 4
  br label %if.end221

if.end221:                                        ; preds = %if.then216, %if.end212
  %228 = load i32, i32* %func_id.addr, align 4
  %call222 = call zeroext i1 @is_ptr_cast_function(i32 noundef %228) #11
  br i1 %call222, label %if.then223, label %if.else227

if.then223:                                       ; preds = %if.end221
  %ref_obj_id224 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 7
  %229 = load i32, i32* %ref_obj_id224, align 8
  %230 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx225 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %230, i64 0
  %ref_obj_id226 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx225, i32 0, i32 4
  store i32 %229, i32* %ref_obj_id226, align 8
  br label %if.end241

if.else227:                                       ; preds = %if.end221
  %231 = load i32, i32* %func_id.addr, align 4
  %map_ptr228 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %232 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr228, align 8
  %call229 = call zeroext i1 @is_acquire_function(i32 noundef %231, %struct.bpf_map* noundef %232) #11
  br i1 %call229, label %if.then230, label %if.end240

if.then230:                                       ; preds = %if.else227
  %233 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %234 = load i32, i32* %insn_idx.addr, align 4
  %call232 = call i32 @acquire_reference_state(%struct.bpf_verifier_env* noundef %233, i32 noundef %234) #11
  store i32 %call232, i32* %id231, align 4
  %235 = load i32, i32* %id231, align 4
  %cmp233 = icmp slt i32 %235, 0
  br i1 %cmp233, label %if.then234, label %if.end235

if.then234:                                       ; preds = %if.then230
  %236 = load i32, i32* %id231, align 4
  store i32 %236, i32* %retval, align 4
  br label %return

if.end235:                                        ; preds = %if.then230
  %237 = load i32, i32* %id231, align 4
  %238 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx236 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %238, i64 0
  %id237 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx236, i32 0, i32 3
  store i32 %237, i32* %id237, align 4
  %239 = load i32, i32* %id231, align 4
  %240 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx238 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %240, i64 0
  %ref_obj_id239 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx238, i32 0, i32 4
  store i32 %239, i32* %ref_obj_id239, align 8
  br label %if.end240

if.end240:                                        ; preds = %if.end235, %if.else227
  br label %if.end241

if.end241:                                        ; preds = %if.end240, %if.then223
  %241 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %242 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn, align 8
  %ret_type242 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %242, i32 0, i32 3
  %243 = load i32, i32* %ret_type242, align 4
  %244 = load i32, i32* %func_id.addr, align 4
  call void @do_refine_retval_range(%struct.bpf_reg_state* noundef %241, i32 noundef %243, i32 noundef %244, %struct.bpf_call_arg_meta* noundef %meta) #11
  %245 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %map_ptr243 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %meta, i32 0, i32 0
  %246 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr243, align 8
  %247 = load i32, i32* %func_id.addr, align 4
  %call244 = call i32 @check_map_func_compatibility(%struct.bpf_verifier_env* noundef %245, %struct.bpf_map* noundef %246, i32 noundef %247) #11
  store i32 %call244, i32* %err, align 4
  %248 = load i32, i32* %err, align 4
  %tobool245 = icmp ne i32 %248, 0
  br i1 %tobool245, label %if.then246, label %if.end247

if.then246:                                       ; preds = %if.end241
  %249 = load i32, i32* %err, align 4
  store i32 %249, i32* %retval, align 4
  br label %return

if.end247:                                        ; preds = %if.end241
  %250 = load i32, i32* %func_id.addr, align 4
  %cmp248 = icmp eq i32 %250, 67
  br i1 %cmp248, label %land.lhs.true251, label %lor.lhs.false249

lor.lhs.false249:                                 ; preds = %if.end247
  %251 = load i32, i32* %func_id.addr, align 4
  %cmp250 = icmp eq i32 %251, 141
  br i1 %cmp250, label %land.lhs.true251, label %if.end267

land.lhs.true251:                                 ; preds = %lor.lhs.false249, %if.end247
  %252 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog252 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %252, i32 0, i32 2
  %253 = load %struct.bpf_prog*, %struct.bpf_prog** %prog252, align 8
  %has_callchain_buf = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %253, i32 0, i32 1
  %bf.load253 = load i16, i16* %has_callchain_buf, align 2
  %bf.lshr254 = lshr i16 %bf.load253, 8
  %bf.clear255 = and i16 %bf.lshr254, 1
  %tobool256 = icmp ne i16 %bf.clear255, 0
  br i1 %tobool256, label %if.end267, label %if.then257

if.then257:                                       ; preds = %land.lhs.true251
  %254 = load i32, i32* @sysctl_perf_event_max_stack, align 4
  %call258 = call i32 @get_callchain_buffers(i32 noundef %254) #11
  store i32 %call258, i32* %err, align 4
  store i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.302, i64 0, i64 0), i8** %err_str, align 8
  %255 = load i32, i32* %err, align 4
  %tobool259 = icmp ne i32 %255, 0
  br i1 %tobool259, label %if.then260, label %if.end262

if.then260:                                       ; preds = %if.then257
  %256 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %257 = bitcast %struct.bpf_verifier_env* %256 to i8*
  %258 = load i8*, i8** %err_str, align 8
  %259 = load i32, i32* %func_id.addr, align 4
  %call261 = call i8* @func_id_name(i32 noundef %259) #11
  %260 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %257, i8* noundef %258, i8* noundef %call261, i32 noundef %260) #11
  %261 = load i32, i32* %err, align 4
  store i32 %261, i32* %retval, align 4
  br label %return

if.end262:                                        ; preds = %if.then257
  %262 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog263 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %262, i32 0, i32 2
  %263 = load %struct.bpf_prog*, %struct.bpf_prog** %prog263, align 8
  %has_callchain_buf264 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %263, i32 0, i32 1
  %bf.load265 = load i16, i16* %has_callchain_buf264, align 2
  %bf.clear266 = and i16 %bf.load265, -257
  %bf.set = or i16 %bf.clear266, 256
  store i16 %bf.set, i16* %has_callchain_buf264, align 2
  br label %if.end267

if.end267:                                        ; preds = %if.end262, %land.lhs.true251, %lor.lhs.false249
  %264 = load i32, i32* %func_id.addr, align 4
  %cmp268 = icmp eq i32 %264, 27
  br i1 %cmp268, label %if.then271, label %lor.lhs.false269

lor.lhs.false269:                                 ; preds = %if.end267
  %265 = load i32, i32* %func_id.addr, align 4
  %cmp270 = icmp eq i32 %265, 67
  br i1 %cmp270, label %if.then271, label %if.end276

if.then271:                                       ; preds = %lor.lhs.false269, %if.end267
  %266 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog272 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %266, i32 0, i32 2
  %267 = load %struct.bpf_prog*, %struct.bpf_prog** %prog272, align 8
  %call_get_stack = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %267, i32 0, i32 1
  %bf.load273 = load i16, i16* %call_get_stack, align 2
  %bf.clear274 = and i16 %bf.load273, -1025
  %bf.set275 = or i16 %bf.clear274, 1024
  store i16 %bf.set275, i16* %call_get_stack, align 2
  br label %if.end276

if.end276:                                        ; preds = %if.then271, %lor.lhs.false269
  %268 = load i8, i8* %changes_data, align 1
  %tobool277 = trunc i8 %268 to i1
  br i1 %tobool277, label %if.then278, label %if.end279

if.then278:                                       ; preds = %if.end276
  %269 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  call void @clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %269) #11
  br label %if.end279

if.end279:                                        ; preds = %if.then278, %if.end276
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end279, %if.then260, %if.then246, %if.then234, %if.else201, %if.then195, %if.then167, %if.then109, %if.then81, %if.then72, %if.then66, %if.then57, %if.then50, %if.then46, %if.then42, %if.then35, %if.then27, %if.then21, %if.then14, %if.then8, %if.then
  %270 = load i32, i32* %retval, align 4
  ret i32 %270
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @prepare_func_exit(%struct.bpf_verifier_env* noundef %env, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %state = alloca %struct.bpf_verifier_state*, align 8
  %caller = alloca %struct.bpf_func_state*, align 8
  %callee = alloca %struct.bpf_func_state*, align 8
  %r0 = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %state, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %callee, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arrayidx1 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arrayidx1, %struct.bpf_reg_state** %r0, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 0
  %8 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %8, 6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.351, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 4
  %12 = load i32, i32* %curframe2, align 8
  %dec = add i32 %12, -1
  store i32 %dec, i32* %curframe2, align 8
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame3 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 0
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 4
  %15 = load i32, i32* %curframe4, align 8
  %idxprom5 = zext i32 %15 to i64
  %arrayidx6 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame3, i64 0, i64 %idxprom5
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx6, align 8
  store %struct.bpf_func_state* %16, %struct.bpf_func_state** %caller, align 8
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %regs7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 0
  %arrayidx8 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs7, i64 0, i64 0
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %r0, align 8
  %19 = bitcast %struct.bpf_reg_state* %arrayidx8 to i8*
  %20 = bitcast %struct.bpf_reg_state* %18 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 %20, i64 120, i1 false)
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %call = call i32 @transfer_reference_state(%struct.bpf_func_state* noundef %21, %struct.bpf_func_state* noundef %22) #11
  store i32 %call, i32* %err, align 4
  %23 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %23, 0
  br i1 %tobool, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %24 = load i32, i32* %err, align 4
  store i32 %24, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 1
  %26 = load i32, i32* %callsite, align 8
  %add = add i32 %26, 1
  %27 = load i32*, i32** %insn_idx.addr, align 8
  store i32 %add, i32* %27, align 4
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 22
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %29 = load i32, i32* %level, align 8
  %and = and i32 %29, 3
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.352, i64 0, i64 0)) #11
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %32, %struct.bpf_func_state* noundef %33) #11
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %35 = bitcast %struct.bpf_verifier_env* %34 to i8*
  %36 = load i32*, i32** %insn_idx.addr, align 8
  %37 = load i32, i32* %36, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %35, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.353, i64 0, i64 0), i32 noundef %37) #11
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load %struct.bpf_func_state*, %struct.bpf_func_state** %caller, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %38, %struct.bpf_func_state* noundef %39) #11
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end10
  %40 = load %struct.bpf_func_state*, %struct.bpf_func_state** %callee, align 8
  call void @free_func_state(%struct.bpf_func_state* noundef %40) #11
  %41 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %frame14 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %41, i32 0, i32 0
  %42 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %state, align 8
  %curframe15 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %42, i32 0, i32 4
  %43 = load i32, i32* %curframe15, align 8
  %add16 = add i32 %43, 1
  %idxprom17 = zext i32 %add16 to i64
  %arrayidx18 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame14, i64 0, i64 %idxprom17
  store %struct.bpf_func_state* null, %struct.bpf_func_state** %arrayidx18, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then9, %if.then
  %44 = load i32, i32* %retval, align 4
  ret i32 %44
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 4
  %3 = load i32, i32* %acquired_refs, align 4
  %cmp = icmp slt i32 %1, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 5
  %7 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %7, i64 %idxprom
  %id = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 0
  %9 = load i32, i32* %id, align 4
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 5
  %11 = load %struct.util_est*, %struct.util_est** %refs1, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %12 to i64
  %arrayidx3 = getelementptr %struct.util_est, %struct.util_est* %11, i64 %idxprom2
  %insn_idx = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx3, i32 0, i32 1
  %13 = load i32, i32* %insn_idx, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.354, i64 0, i64 0), i32 noundef %9, i32 noundef %13) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 4
  %16 = load i32, i32* %acquired_refs4, align 4
  %tobool = icmp ne i32 %16, 0
  %17 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 -22, i32 0
  ret i32 %cond
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_return_code(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %enforce_attach_type_range = alloca %struct.tnum, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %range = alloca %struct.tnum, align 8
  %prog_type = alloca i32, align 4
  %err = alloca i32, align 4
  %is_subprog = alloca i8, align 1
  %tmp = alloca %struct.tnum, align 8
  %tmp55 = alloca %struct.tnum, align 8
  %tmp57 = alloca %struct.tnum, align 8
  %tmp67 = alloca %struct.tnum, align 8
  %tmp73 = alloca %struct.tnum, align 8
  %tmp78 = alloca %struct.tnum, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = bitcast %struct.tnum* %enforce_attach_type_range to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %0, i8* align 8 bitcast (%struct.tnum* @tnum_unknown to i8*), i64 16, i1 false)
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 2
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %2, %struct.bpf_prog** %prog, align 8
  %call = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #11
  %3 = bitcast %struct.tnum* %range to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 2
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog2, align 8
  %call3 = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %9) #11
  store i32 %call3, i32* %prog_type, align 4
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 8
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 0
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %subprogno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 3
  %13 = load i32, i32* %subprogno, align 8
  %tobool = icmp ne i32 %13, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* %is_subprog, align 1
  %14 = load i8, i8* %is_subprog, align 1
  %tobool4 = trunc i8 %14 to i1
  br i1 %tobool4, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %15 = load i32, i32* %prog_type, align 4
  %cmp = icmp eq i32 %15, 27
  br i1 %cmp, label %land.lhs.true6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %16 = load i32, i32* %prog_type, align 4
  %cmp5 = icmp eq i32 %16, 29
  br i1 %cmp5, label %land.lhs.true6, label %if.end

land.lhs.true6:                                   ; preds = %lor.lhs.false, %land.lhs.true
  %17 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %17, i32 0, i32 7
  %18 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %attach_func_proto = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %18, i32 0, i32 27
  %19 = load %struct.btf_type*, %struct.btf_type** %attach_func_proto, align 8
  %20 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %19, i32 0, i32 2
  %type = bitcast %struct.atomic_t* %20 to i32*
  %21 = load i32, i32* %type, align 4
  %tobool7 = icmp ne i32 %21, 0
  br i1 %tobool7, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true6
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true6, %lor.lhs.false, %entry
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call8 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %22, i32 noundef 0, i32 noundef 0) #11
  store i32 %call8, i32* %err, align 4
  %23 = load i32, i32* %err, align 4
  %tobool9 = icmp ne i32 %23, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  %24 = load i32, i32* %err, align 4
  store i32 %24, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call12 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %25, i32 noundef 0) #11
  br i1 %call12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.355, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end11
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call15 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %28) #11
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call15, i64 0
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  %29 = load i8, i8* %is_subprog, align 1
  %tobool16 = trunc i8 %29 to i1
  br i1 %tobool16, label %if.then17, label %if.end24

if.then17:                                        ; preds = %if.end14
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 0
  %31 = load i32, i32* %type18, align 8
  %cmp19 = icmp ne i32 %31, 1
  br i1 %cmp19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.then17
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = bitcast %struct.bpf_verifier_env* %32 to i8*
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 0
  %35 = load i32, i32* %type21, align 8
  %idxprom = zext i32 %35 to i64
  %arrayidx22 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %36 = load i8*, i8** %arrayidx22, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %33, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.356, i64 0, i64 0), i8* noundef %36) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %if.then17
  store i32 0, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end14
  %37 = load i32, i32* %prog_type, align 4
  switch i32 %37, label %sw.default81 [
    i32 18, label %sw.bb
    i32 8, label %sw.bb50
    i32 9, label %sw.bb60
    i32 13, label %sw.bb60
    i32 15, label %sw.bb60
    i32 23, label %sw.bb60
    i32 25, label %sw.bb60
    i32 17, label %sw.bb61
    i32 26, label %sw.bb69
    i32 30, label %sw.bb77
    i32 28, label %sw.bb80
  ]

sw.bb:                                            ; preds = %if.end24
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog25 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %38, i32 0, i32 2
  %39 = load %struct.bpf_prog*, %struct.bpf_prog** %prog25, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %39, i32 0, i32 3
  %40 = load i32, i32* %expected_attach_type, align 8
  %cmp26 = icmp eq i32 %40, 19
  br i1 %cmp26, label %if.then47, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %sw.bb
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog28 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %41, i32 0, i32 2
  %42 = load %struct.bpf_prog*, %struct.bpf_prog** %prog28, align 8
  %expected_attach_type29 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %42, i32 0, i32 3
  %43 = load i32, i32* %expected_attach_type29, align 8
  %cmp30 = icmp eq i32 %43, 20
  br i1 %cmp30, label %if.then47, label %lor.lhs.false31

lor.lhs.false31:                                  ; preds = %lor.lhs.false27
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog32 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %44, i32 0, i32 2
  %45 = load %struct.bpf_prog*, %struct.bpf_prog** %prog32, align 8
  %expected_attach_type33 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %45, i32 0, i32 3
  %46 = load i32, i32* %expected_attach_type33, align 8
  %cmp34 = icmp eq i32 %46, 29
  br i1 %cmp34, label %if.then47, label %lor.lhs.false35

lor.lhs.false35:                                  ; preds = %lor.lhs.false31
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog36 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %47, i32 0, i32 2
  %48 = load %struct.bpf_prog*, %struct.bpf_prog** %prog36, align 8
  %expected_attach_type37 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %48, i32 0, i32 3
  %49 = load i32, i32* %expected_attach_type37, align 8
  %cmp38 = icmp eq i32 %49, 30
  br i1 %cmp38, label %if.then47, label %lor.lhs.false39

lor.lhs.false39:                                  ; preds = %lor.lhs.false35
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog40 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %50, i32 0, i32 2
  %51 = load %struct.bpf_prog*, %struct.bpf_prog** %prog40, align 8
  %expected_attach_type41 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %51, i32 0, i32 3
  %52 = load i32, i32* %expected_attach_type41, align 8
  %cmp42 = icmp eq i32 %52, 31
  br i1 %cmp42, label %if.then47, label %lor.lhs.false43

lor.lhs.false43:                                  ; preds = %lor.lhs.false39
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog44 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %53, i32 0, i32 2
  %54 = load %struct.bpf_prog*, %struct.bpf_prog** %prog44, align 8
  %expected_attach_type45 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %54, i32 0, i32 3
  %55 = load i32, i32* %expected_attach_type45, align 8
  %cmp46 = icmp eq i32 %55, 32
  br i1 %cmp46, label %if.then47, label %if.end49

if.then47:                                        ; preds = %lor.lhs.false43, %lor.lhs.false39, %lor.lhs.false35, %lor.lhs.false31, %lor.lhs.false27, %sw.bb
  %call48 = call { i64, i64 } @tnum_range(i64 noundef 1, i64 noundef 1) #11
  %56 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %57 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %56, i32 0, i32 0
  %58 = extractvalue { i64, i64 } %call48, 0
  store i64 %58, i64* %57, align 8
  %59 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %56, i32 0, i32 1
  %60 = extractvalue { i64, i64 } %call48, 1
  store i64 %60, i64* %59, align 8
  %61 = bitcast %struct.tnum* %range to i8*
  %62 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %61, i8* align 8 %62, i64 16, i1 false)
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %lor.lhs.false43
  br label %sw.epilog82

sw.bb50:                                          ; preds = %if.end24
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog51 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %63, i32 0, i32 2
  %64 = load %struct.bpf_prog*, %struct.bpf_prog** %prog51, align 8
  %expected_attach_type52 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %64, i32 0, i32 3
  %65 = load i32, i32* %expected_attach_type52, align 8
  %cmp53 = icmp eq i32 %65, 1
  br i1 %cmp53, label %if.then54, label %if.end59

if.then54:                                        ; preds = %sw.bb50
  %call56 = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 3) #11
  %66 = bitcast %struct.tnum* %tmp55 to { i64, i64 }*
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 0
  %68 = extractvalue { i64, i64 } %call56, 0
  store i64 %68, i64* %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %66, i32 0, i32 1
  %70 = extractvalue { i64, i64 } %call56, 1
  store i64 %70, i64* %69, align 8
  %71 = bitcast %struct.tnum* %range to i8*
  %72 = bitcast %struct.tnum* %tmp55 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %71, i8* align 8 %72, i64 16, i1 false)
  %call58 = call { i64, i64 } @tnum_range(i64 noundef 2, i64 noundef 3) #11
  %73 = bitcast %struct.tnum* %tmp57 to { i64, i64 }*
  %74 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 0
  %75 = extractvalue { i64, i64 } %call58, 0
  store i64 %75, i64* %74, align 8
  %76 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %73, i32 0, i32 1
  %77 = extractvalue { i64, i64 } %call58, 1
  store i64 %77, i64* %76, align 8
  %78 = bitcast %struct.tnum* %enforce_attach_type_range to i8*
  %79 = bitcast %struct.tnum* %tmp57 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %78, i8* align 8 %79, i64 16, i1 false)
  br label %if.end59

if.end59:                                         ; preds = %if.then54, %sw.bb50
  br label %sw.epilog82

sw.bb60:                                          ; preds = %if.end24, %if.end24, %if.end24, %if.end24, %if.end24
  br label %sw.epilog82

sw.bb61:                                          ; preds = %if.end24
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog62 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %80, i32 0, i32 2
  %81 = load %struct.bpf_prog*, %struct.bpf_prog** %prog62, align 8
  %aux63 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %81, i32 0, i32 7
  %82 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux63, align 8
  %attach_btf_id = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %82, i32 0, i32 9
  %83 = load i32, i32* %attach_btf_id, align 8
  %tobool64 = icmp ne i32 %83, 0
  br i1 %tobool64, label %if.end66, label %if.then65

if.then65:                                        ; preds = %sw.bb61
  store i32 0, i32* %retval, align 4
  br label %return

if.end66:                                         ; preds = %sw.bb61
  %call68 = call { i64, i64 } @tnum_const(i64 noundef 0) #11
  %84 = bitcast %struct.tnum* %tmp67 to { i64, i64 }*
  %85 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %84, i32 0, i32 0
  %86 = extractvalue { i64, i64 } %call68, 0
  store i64 %86, i64* %85, align 8
  %87 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %84, i32 0, i32 1
  %88 = extractvalue { i64, i64 } %call68, 1
  store i64 %88, i64* %87, align 8
  %89 = bitcast %struct.tnum* %range to i8*
  %90 = bitcast %struct.tnum* %tmp67 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %89, i8* align 8 %90, i64 16, i1 false)
  br label %sw.epilog82

sw.bb69:                                          ; preds = %if.end24
  %91 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog70 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %91, i32 0, i32 2
  %92 = load %struct.bpf_prog*, %struct.bpf_prog** %prog70, align 8
  %expected_attach_type71 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %92, i32 0, i32 3
  %93 = load i32, i32* %expected_attach_type71, align 8
  switch i32 %93, label %sw.default [
    i32 24, label %sw.bb72
    i32 25, label %sw.bb72
    i32 23, label %sw.bb75
    i32 26, label %sw.bb75
    i32 28, label %sw.bb76
  ]

sw.bb72:                                          ; preds = %sw.bb69, %sw.bb69
  %call74 = call { i64, i64 } @tnum_const(i64 noundef 0) #11
  %94 = bitcast %struct.tnum* %tmp73 to { i64, i64 }*
  %95 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %94, i32 0, i32 0
  %96 = extractvalue { i64, i64 } %call74, 0
  store i64 %96, i64* %95, align 8
  %97 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %94, i32 0, i32 1
  %98 = extractvalue { i64, i64 } %call74, 1
  store i64 %98, i64* %97, align 8
  %99 = bitcast %struct.tnum* %range to i8*
  %100 = bitcast %struct.tnum* %tmp73 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %99, i8* align 8 %100, i64 16, i1 false)
  br label %sw.epilog

sw.bb75:                                          ; preds = %sw.bb69, %sw.bb69
  store i32 0, i32* %retval, align 4
  br label %return

sw.bb76:                                          ; preds = %sw.bb69
  br label %sw.epilog

sw.default:                                       ; preds = %sw.bb69
  store i32 -524, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb76, %sw.bb72
  br label %sw.epilog82

sw.bb77:                                          ; preds = %if.end24
  %call79 = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef 1) #11
  %101 = bitcast %struct.tnum* %tmp78 to { i64, i64 }*
  %102 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %101, i32 0, i32 0
  %103 = extractvalue { i64, i64 } %call79, 0
  store i64 %103, i64* %102, align 8
  %104 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %101, i32 0, i32 1
  %105 = extractvalue { i64, i64 } %call79, 1
  store i64 %105, i64* %104, align 8
  %106 = bitcast %struct.tnum* %range to i8*
  %107 = bitcast %struct.tnum* %tmp78 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %106, i8* align 8 %107, i64 16, i1 false)
  br label %sw.epilog82

sw.bb80:                                          ; preds = %if.end24
  br label %sw.default81

sw.default81:                                     ; preds = %sw.bb80, %if.end24
  store i32 0, i32* %retval, align 4
  br label %return

sw.epilog82:                                      ; preds = %sw.bb77, %sw.epilog, %if.end66, %sw.bb60, %if.end59, %if.end49
  %108 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type83 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %108, i32 0, i32 0
  %109 = load i32, i32* %type83, align 8
  %cmp84 = icmp ne i32 %109, 1
  br i1 %cmp84, label %if.then85, label %if.end89

if.then85:                                        ; preds = %sw.epilog82
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %111 = bitcast %struct.bpf_verifier_env* %110 to i8*
  %112 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type86 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %112, i32 0, i32 0
  %113 = load i32, i32* %type86, align 8
  %idxprom87 = zext i32 %113 to i64
  %arrayidx88 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom87
  %114 = load i8*, i8** %arrayidx88, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %111, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.357, i64 0, i64 0), i8* noundef %114) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end89:                                         ; preds = %sw.epilog82
  %115 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %115, i32 0, i32 5
  %116 = bitcast %struct.tnum* %range to { i64, i64 }*
  %117 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %116, i32 0, i32 0
  %118 = load i64, i64* %117, align 8
  %119 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %116, i32 0, i32 1
  %120 = load i64, i64* %119, align 8
  %121 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %122 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %121, i32 0, i32 0
  %123 = load i64, i64* %122, align 8
  %124 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %121, i32 0, i32 1
  %125 = load i64, i64* %124, align 8
  %call90 = call zeroext i1 @tnum_in(i64 %118, i64 %120, i64 %123, i64 %125) #11
  br i1 %call90, label %if.end102, label %if.then91

if.then91:                                        ; preds = %if.end89
  %126 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %127 = bitcast %struct.bpf_verifier_env* %126 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %127, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.358, i64 0, i64 0)) #11
  %128 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %128, i32 0, i32 5
  %129 = bitcast %struct.tnum* %var_off92 to { i64, i64 }*
  %130 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 0
  %131 = load i64, i64* %130, align 8
  %132 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %129, i32 0, i32 1
  %133 = load i64, i64* %132, align 8
  %call93 = call zeroext i1 @tnum_is_unknown(i64 %131, i64 %133) #11
  br i1 %call93, label %if.else, label %if.then94

if.then94:                                        ; preds = %if.then91
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %134 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off95 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %134, i32 0, i32 5
  %135 = bitcast %struct.tnum* %var_off95 to { i64, i64 }*
  %136 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %135, i32 0, i32 0
  %137 = load i64, i64* %136, align 8
  %138 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %135, i32 0, i32 1
  %139 = load i64, i64* %138, align 8
  %call96 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %137, i64 %139) #11
  %140 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %141 = bitcast %struct.bpf_verifier_env* %140 to i8*
  %arraydecay97 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %141, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.359, i64 0, i64 0), i8* noundef %arraydecay97) #11
  br label %if.end98

if.else:                                          ; preds = %if.then91
  %142 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %143 = bitcast %struct.bpf_verifier_env* %142 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %143, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.360, i64 0, i64 0)) #11
  br label %if.end98

if.end98:                                         ; preds = %if.else, %if.then94
  %arraydecay99 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %144 = bitcast %struct.tnum* %range to { i64, i64 }*
  %145 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 0
  %146 = load i64, i64* %145, align 8
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %144, i32 0, i32 1
  %148 = load i64, i64* %147, align 8
  %call100 = call i32 @tnum_strn(i8* noundef %arraydecay99, i64 noundef 48, i64 %146, i64 %148) #11
  %149 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %150 = bitcast %struct.bpf_verifier_env* %149 to i8*
  %arraydecay101 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %150, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.361, i64 0, i64 0), i8* noundef %arraydecay101) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end102:                                        ; preds = %if.end89
  %151 = bitcast %struct.tnum* %enforce_attach_type_range to { i64, i64 }*
  %152 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %151, i32 0, i32 0
  %153 = load i64, i64* %152, align 8
  %154 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %151, i32 0, i32 1
  %155 = load i64, i64* %154, align 8
  %call103 = call zeroext i1 @tnum_is_unknown(i64 %153, i64 %155) #11
  br i1 %call103, label %if.end109, label %land.lhs.true104

land.lhs.true104:                                 ; preds = %if.end102
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off105 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i32 0, i32 5
  %157 = bitcast %struct.tnum* %enforce_attach_type_range to { i64, i64 }*
  %158 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %157, i32 0, i32 0
  %159 = load i64, i64* %158, align 8
  %160 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %157, i32 0, i32 1
  %161 = load i64, i64* %160, align 8
  %162 = bitcast %struct.tnum* %var_off105 to { i64, i64 }*
  %163 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %162, i32 0, i32 0
  %164 = load i64, i64* %163, align 8
  %165 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %162, i32 0, i32 1
  %166 = load i64, i64* %165, align 8
  %call106 = call zeroext i1 @tnum_in(i64 %159, i64 %161, i64 %164, i64 %166) #11
  br i1 %call106, label %if.then107, label %if.end109

if.then107:                                       ; preds = %land.lhs.true104
  %167 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog108 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %167, i32 0, i32 2
  %168 = load %struct.bpf_prog*, %struct.bpf_prog** %prog108, align 8
  %enforce_expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %168, i32 0, i32 1
  %bf.load = load i16, i16* %enforce_expected_attach_type, align 2
  %bf.clear = and i16 %bf.load, -513
  %bf.set = or i16 %bf.clear, 512
  store i16 %bf.set, i16* %enforce_expected_attach_type, align 2
  br label %if.end109

if.end109:                                        ; preds = %if.then107, %land.lhs.true104, %if.end102
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end109, %if.end98, %if.then85, %sw.default81, %sw.default, %sw.bb75, %if.then65, %if.end23, %if.then20, %if.then13, %if.then10, %if.then
  %169 = load i32, i32* %retval, align 4
  ret i32 %169
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @update_branch_counts(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %br = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp38 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end47, %entry
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %0, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 2
  %2 = load i32, i32* %branches, align 8
  %dec = add i32 %2, -1
  store i32 %dec, i32* %branches, align 8
  store i32 %dec, i32* %br, align 4
  %3 = load i32, i32* %br, align 4
  %cmp = icmp slt i32 %3, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_once, align 4
  %4 = load i32, i32* %__ret_warn_once, align 4
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.body
  %5 = load i8, i8* @update_branch_counts.__warned, align 1
  %tobool3 = trunc i8 %5 to i1
  %lnot4 = xor i1 %tobool3, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.body
  %6 = phi i1 [ false, %while.body ], [ %lnot4, %land.rhs ]
  %lnot6 = xor i1 %6, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext9 to i64
  %tobool10 = icmp ne i64 %conv, 0
  br i1 %tobool10, label %if.then, label %if.end37

if.then:                                          ; preds = %land.end
  store i8 1, i8* @update_branch_counts.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool11 = icmp ne i32 %7, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %tobool17 = icmp ne i64 %conv16, 0
  br i1 %tobool17, label %if.then18, label %if.end

if.then18:                                        ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then18
  br label %do.body19

do.body19:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body19
  %8 = load i32, i32* %br, align 4
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.362, i64 0, i64 0), i32 noundef %8) #11
  br label %do.body20

do.body20:                                        ; preds = %do.end
  br label %do.body21

do.body21:                                        ; preds = %do.body20
  br label %do.end22

do.end22:                                         ; preds = %do.body21
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1007, i32 2313, i64 12) #10, !srcloc !39
  br label %do.end24

do.end24:                                         ; preds = %do.body23
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 377) #10, !srcloc !40
  br label %do.body25

do.body25:                                        ; preds = %do.end24
  br label %do.end26

do.end26:                                         ; preds = %do.body25
  br label %do.end27

do.end27:                                         ; preds = %do.end26
  br label %do.body28

do.body28:                                        ; preds = %do.end27
  br label %do.end29

do.end29:                                         ; preds = %do.body28
  br label %do.end30

do.end30:                                         ; preds = %do.end29
  br label %if.end

if.end:                                           ; preds = %do.end30, %if.then
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool31 = icmp ne i32 %9, 0
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %conv36 = sext i32 %lnot.ext35 to i64
  store i64 %conv36, i64* %tmp, align 8
  %10 = load i64, i64* %tmp, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.end, %land.end
  %11 = load i32, i32* %__ret_warn_once, align 4
  %tobool39 = icmp ne i32 %11, 0
  %lnot40 = xor i1 %tobool39, true
  %lnot42 = xor i1 %lnot40, true
  %lnot.ext43 = zext i1 %lnot42 to i32
  %conv44 = sext i32 %lnot.ext43 to i64
  store i64 %conv44, i64* %tmp38, align 8
  %12 = load i64, i64* %tmp38, align 8
  %13 = load i32, i32* %br, align 4
  %tobool45 = icmp ne i32 %13, 0
  br i1 %tobool45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.end37
  br label %while.end

if.end47:                                         ; preds = %if.end37
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 1
  %15 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  store %struct.bpf_verifier_state* %15, %struct.bpf_verifier_state** %st.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %if.then46, %while.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_cond_jmp_op(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, i32* noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %insn_idx.addr = alloca i32*, align 8
  %this_branch = alloca %struct.bpf_verifier_state*, align 8
  %other_branch = alloca %struct.bpf_verifier_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %other_branch_regs = alloca %struct.bpf_reg_state*, align 8
  %src_reg = alloca %struct.bpf_reg_state*, align 8
  %opcode = alloca i8, align 1
  %is_jmp32 = alloca i8, align 1
  %pred = alloca i32, align 4
  %err = alloca i32, align 4
  %agg.tmp = alloca %struct.tnum, align 8
  %coerce = alloca %struct.tnum, align 8
  %src_reg166 = alloca %struct.bpf_reg_state*, align 8
  %agg.tmp187 = alloca %struct.tnum, align 8
  %coerce202 = alloca %struct.tnum, align 8
  %agg.tmp214 = alloca %struct.tnum, align 8
  %coerce229 = alloca %struct.tnum, align 8
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_warn_on322 = alloca i32, align 4
  %tmp353 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store i32* %insn_idx, i32** %insn_idx.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %this_branch, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %src_reg, align 8
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 0
  %7 = load i8, i8* %code, align 4
  %conv = zext i8 %7 to i32
  %and = and i32 %conv, 240
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %opcode, align 1
  store i32 -1, i32* %pred, align 4
  %8 = load i8, i8* %opcode, align 1
  %conv3 = zext i8 %8 to i32
  %cmp = icmp eq i32 %conv3, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %9 = load i8, i8* %opcode, align 1
  %conv5 = zext i8 %9 to i32
  %cmp6 = icmp sgt i32 %conv5, 208
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load i8, i8* %opcode, align 1
  %conv8 = zext i8 %12 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([33 x i8], [33 x i8]* @.str.363, i64 0, i64 0), i32 noundef %conv8) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 0
  %14 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %14 to i32
  %and11 = and i32 %conv10, 8
  %cmp12 = icmp eq i32 %and11, 8
  br i1 %cmp12, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 3
  %16 = load i32, i32* %imm, align 4
  %cmp15 = icmp ne i32 %16, 0
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then14
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.364, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.then14
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg19 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %20, i32 0, i32 1
  %bf.load = load i8, i8* %src_reg19, align 1
  %bf.lshr = lshr i8 %bf.load, 4
  %conv20 = zext i8 %bf.lshr to i32
  %call = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %19, i32 noundef %conv20, i32 noundef 0) #11
  store i32 %call, i32* %err, align 4
  %21 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %21, 0
  br i1 %tobool, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  %22 = load i32, i32* %err, align 4
  store i32 %22, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end18
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %24, i32 0, i32 1
  %bf.load24 = load i8, i8* %src_reg23, align 1
  %bf.lshr25 = lshr i8 %bf.load24, 4
  %conv26 = zext i8 %bf.lshr25 to i32
  %call27 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %23, i32 noundef %conv26) #11
  br i1 %call27, label %if.then28, label %if.end33

if.then28:                                        ; preds = %if.end22
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg29 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %27, i32 0, i32 1
  %bf.load30 = load i8, i8* %src_reg29, align 1
  %bf.lshr31 = lshr i8 %bf.load30, 4
  %conv32 = zext i8 %bf.lshr31 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.365, i64 0, i64 0), i32 noundef %conv32) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end22
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load35 = load i8, i8* %src_reg34, align 1
  %bf.lshr36 = lshr i8 %bf.load35, 4
  %idxprom37 = zext i8 %bf.lshr36 to i64
  %arrayidx38 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i64 %idxprom37
  store %struct.bpf_reg_state* %arrayidx38, %struct.bpf_reg_state** %src_reg, align 8
  br label %if.end47

if.else:                                          ; preds = %if.end
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg39 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %30, i32 0, i32 1
  %bf.load40 = load i8, i8* %src_reg39, align 1
  %bf.lshr41 = lshr i8 %bf.load40, 4
  %conv42 = zext i8 %bf.lshr41 to i32
  %cmp43 = icmp ne i32 %conv42, 0
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.else
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %32 = bitcast %struct.bpf_verifier_env* %31 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %32, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.364, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end46:                                         ; preds = %if.else
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.end33
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg48 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %34, i32 0, i32 1
  %bf.load49 = load i8, i8* %dst_reg48, align 1
  %bf.clear = and i8 %bf.load49, 15
  %conv50 = zext i8 %bf.clear to i32
  %call51 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %33, i32 noundef %conv50, i32 noundef 0) #11
  store i32 %call51, i32* %err, align 4
  %35 = load i32, i32* %err, align 4
  %tobool52 = icmp ne i32 %35, 0
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.end47
  %36 = load i32, i32* %err, align 4
  store i32 %36, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.end47
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %38 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg55 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %38, i32 0, i32 1
  %bf.load56 = load i8, i8* %dst_reg55, align 1
  %bf.clear57 = and i8 %bf.load56, 15
  %idxprom58 = zext i8 %bf.clear57 to i64
  %arrayidx59 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i64 %idxprom58
  store %struct.bpf_reg_state* %arrayidx59, %struct.bpf_reg_state** %dst_reg, align 8
  %39 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code60 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %39, i32 0, i32 0
  %40 = load i8, i8* %code60, align 4
  %conv61 = zext i8 %40 to i32
  %and62 = and i32 %conv61, 7
  %cmp63 = icmp eq i32 %and62, 6
  %frombool = zext i1 %cmp63 to i8
  store i8 %frombool, i8* %is_jmp32, align 1
  %41 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code65 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %41, i32 0, i32 0
  %42 = load i8, i8* %code65, align 4
  %conv66 = zext i8 %42 to i32
  %and67 = and i32 %conv66, 8
  %cmp68 = icmp eq i32 %and67, 0
  br i1 %cmp68, label %if.then70, label %if.else75

if.then70:                                        ; preds = %if.end54
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %44 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm71 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %44, i32 0, i32 3
  %45 = load i32, i32* %imm71, align 4
  %conv72 = sext i32 %45 to i64
  %46 = load i8, i8* %opcode, align 1
  %47 = load i8, i8* %is_jmp32, align 1
  %tobool73 = trunc i8 %47 to i1
  %call74 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %43, i64 noundef %conv72, i8 noundef zeroext %46, i1 noundef zeroext %tobool73) #11
  store i32 %call74, i32* %pred, align 4
  br label %if.end106

if.else75:                                        ; preds = %if.end54
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 0
  %49 = load i32, i32* %type, align 8
  %cmp76 = icmp eq i32 %49, 1
  br i1 %cmp76, label %land.lhs.true, label %if.else89

land.lhs.true:                                    ; preds = %if.else75
  %50 = load i8, i8* %is_jmp32, align 1
  %tobool78 = trunc i8 %50 to i1
  br i1 %tobool78, label %land.lhs.true80, label %if.else89

land.lhs.true80:                                  ; preds = %land.lhs.true
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %51, i32 0, i32 5
  %52 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 0
  %54 = load i64, i64* %53, align 8
  %55 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %52, i32 0, i32 1
  %56 = load i64, i64* %55, align 8
  %call81 = call { i64, i64 } @tnum_subreg(i64 %54, i64 %56) #11
  %57 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 0
  %59 = extractvalue { i64, i64 } %call81, 0
  store i64 %59, i64* %58, align 8
  %60 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %57, i32 0, i32 1
  %61 = extractvalue { i64, i64 } %call81, 1
  store i64 %61, i64* %60, align 8
  %62 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 0
  %64 = load i64, i64* %63, align 8
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %62, i32 0, i32 1
  %66 = load i64, i64* %65, align 8
  %call82 = call zeroext i1 @tnum_is_const(i64 %64, i64 %66) #11
  br i1 %call82, label %if.then84, label %if.else89

if.then84:                                        ; preds = %land.lhs.true80
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 5
  %69 = bitcast %struct.tnum* %var_off85 to { i64, i64 }*
  %70 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %69, i32 0, i32 0
  %71 = load i64, i64* %70, align 8
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %69, i32 0, i32 1
  %73 = load i64, i64* %72, align 8
  %call86 = call { i64, i64 } @tnum_subreg(i64 %71, i64 %73) #11
  %74 = bitcast %struct.tnum* %coerce to { i64, i64 }*
  %75 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %74, i32 0, i32 0
  %76 = extractvalue { i64, i64 } %call86, 0
  store i64 %76, i64* %75, align 8
  %77 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %74, i32 0, i32 1
  %78 = extractvalue { i64, i64 } %call86, 1
  store i64 %78, i64* %77, align 8
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce, i32 0, i32 0
  %79 = load i64, i64* %value, align 8
  %80 = load i8, i8* %opcode, align 1
  %81 = load i8, i8* %is_jmp32, align 1
  %tobool87 = trunc i8 %81 to i1
  %call88 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %67, i64 noundef %79, i8 noundef zeroext %80, i1 noundef zeroext %tobool87) #11
  store i32 %call88, i32* %pred, align 4
  br label %if.end105

if.else89:                                        ; preds = %land.lhs.true80, %land.lhs.true, %if.else75
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %type90 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 0
  %83 = load i32, i32* %type90, align 8
  %cmp91 = icmp eq i32 %83, 1
  br i1 %cmp91, label %land.lhs.true93, label %if.end104

land.lhs.true93:                                  ; preds = %if.else89
  %84 = load i8, i8* %is_jmp32, align 1
  %tobool94 = trunc i8 %84 to i1
  br i1 %tobool94, label %if.end104, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %land.lhs.true93
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off96 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %85, i32 0, i32 5
  %86 = bitcast %struct.tnum* %var_off96 to { i64, i64 }*
  %87 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %86, i32 0, i32 0
  %88 = load i64, i64* %87, align 8
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %86, i32 0, i32 1
  %90 = load i64, i64* %89, align 8
  %call97 = call zeroext i1 @tnum_is_const(i64 %88, i64 %90) #11
  br i1 %call97, label %if.then99, label %if.end104

if.then99:                                        ; preds = %land.lhs.true95
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %var_off100 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 5
  %value101 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off100, i32 0, i32 0
  %93 = load i64, i64* %value101, align 8
  %94 = load i8, i8* %opcode, align 1
  %95 = load i8, i8* %is_jmp32, align 1
  %tobool102 = trunc i8 %95 to i1
  %call103 = call i32 @is_branch_taken(%struct.bpf_reg_state* noundef %91, i64 noundef %93, i8 noundef zeroext %94, i1 noundef zeroext %tobool102) #11
  store i32 %call103, i32* %pred, align 4
  br label %if.end104

if.end104:                                        ; preds = %if.then99, %land.lhs.true95, %land.lhs.true93, %if.else89
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %if.then84
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %if.then70
  %96 = load i32, i32* %pred, align 4
  %cmp107 = icmp sge i32 %96, 0
  br i1 %cmp107, label %if.then109, label %if.end135

if.then109:                                       ; preds = %if.end106
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call110 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext false, %struct.bpf_reg_state* noundef %97) #11
  br i1 %call110, label %if.end117, label %if.then111

if.then111:                                       ; preds = %if.then109
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %99 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg112 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %99, i32 0, i32 1
  %bf.load113 = load i8, i8* %dst_reg112, align 1
  %bf.clear114 = and i8 %bf.load113, 15
  %conv115 = zext i8 %bf.clear114 to i32
  %call116 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %98, i32 noundef %conv115) #11
  store i32 %call116, i32* %err, align 4
  br label %if.end117

if.end117:                                        ; preds = %if.then111, %if.then109
  %100 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code118 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %100, i32 0, i32 0
  %101 = load i8, i8* %code118, align 4
  %conv119 = zext i8 %101 to i32
  %and120 = and i32 %conv119, 8
  %cmp121 = icmp eq i32 %and120, 8
  br i1 %cmp121, label %land.lhs.true123, label %if.end131

land.lhs.true123:                                 ; preds = %if.end117
  %102 = load i32, i32* %err, align 4
  %tobool124 = icmp ne i32 %102, 0
  br i1 %tobool124, label %if.end131, label %if.then125

if.then125:                                       ; preds = %land.lhs.true123
  %103 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %104 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg126 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %104, i32 0, i32 1
  %bf.load127 = load i8, i8* %src_reg126, align 1
  %bf.lshr128 = lshr i8 %bf.load127, 4
  %conv129 = zext i8 %bf.lshr128 to i32
  %call130 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %103, i32 noundef %conv129) #11
  store i32 %call130, i32* %err, align 4
  br label %if.end131

if.end131:                                        ; preds = %if.then125, %land.lhs.true123, %if.end117
  %105 = load i32, i32* %err, align 4
  %tobool132 = icmp ne i32 %105, 0
  br i1 %tobool132, label %if.then133, label %if.end134

if.then133:                                       ; preds = %if.end131
  %106 = load i32, i32* %err, align 4
  store i32 %106, i32* %retval, align 4
  br label %return

if.end134:                                        ; preds = %if.end131
  br label %if.end135

if.end135:                                        ; preds = %if.end134, %if.end106
  %107 = load i32, i32* %pred, align 4
  %cmp136 = icmp eq i32 %107, 1
  br i1 %cmp136, label %if.then138, label %if.else140

if.then138:                                       ; preds = %if.end135
  %108 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %108, i32 0, i32 2
  %109 = load i16, i16* %off, align 2
  %conv139 = sext i16 %109 to i32
  %110 = load i32*, i32** %insn_idx.addr, align 8
  %111 = load i32, i32* %110, align 4
  %add = add i32 %111, %conv139
  store i32 %add, i32* %110, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.else140:                                       ; preds = %if.end135
  %112 = load i32, i32* %pred, align 4
  %cmp141 = icmp eq i32 %112, 0
  br i1 %cmp141, label %if.then143, label %if.end144

if.then143:                                       ; preds = %if.else140
  store i32 0, i32* %retval, align 4
  br label %return

if.end144:                                        ; preds = %if.else140
  br label %if.end145

if.end145:                                        ; preds = %if.end144
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %114 = load i32*, i32** %insn_idx.addr, align 8
  %115 = load i32, i32* %114, align 4
  %116 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off146 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %116, i32 0, i32 2
  %117 = load i16, i16* %off146, align 2
  %conv147 = sext i16 %117 to i32
  %add148 = add i32 %115, %conv147
  %add149 = add i32 %add148, 1
  %118 = load i32*, i32** %insn_idx.addr, align 8
  %119 = load i32, i32* %118, align 4
  %call150 = call %struct.bpf_verifier_state* @push_stack(%struct.bpf_verifier_env* noundef %113, i32 noundef %add149, i32 noundef %119, i1 noundef zeroext false) #11
  store %struct.bpf_verifier_state* %call150, %struct.bpf_verifier_state** %other_branch, align 8
  %120 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %tobool151 = icmp ne %struct.bpf_verifier_state* %120, null
  br i1 %tobool151, label %if.end153, label %if.then152

if.then152:                                       ; preds = %if.end145
  store i32 -14, i32* %retval, align 4
  br label %return

if.end153:                                        ; preds = %if.end145
  %121 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %frame154 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %121, i32 0, i32 0
  %122 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %curframe155 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %122, i32 0, i32 4
  %123 = load i32, i32* %curframe155, align 8
  %idxprom156 = zext i32 %123 to i64
  %arrayidx157 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame154, i64 0, i64 %idxprom156
  %124 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx157, align 8
  %regs158 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %124, i32 0, i32 0
  %arraydecay159 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs158, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay159, %struct.bpf_reg_state** %other_branch_regs, align 8
  %125 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code160 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %125, i32 0, i32 0
  %126 = load i8, i8* %code160, align 4
  %conv161 = zext i8 %126 to i32
  %and162 = and i32 %conv161, 8
  %cmp163 = icmp eq i32 %and162, 8
  br i1 %cmp163, label %if.then165, label %if.else299

if.then165:                                       ; preds = %if.end153
  %127 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %128 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg167 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %128, i32 0, i32 1
  %bf.load168 = load i8, i8* %src_reg167, align 1
  %bf.lshr169 = lshr i8 %bf.load168, 4
  %idxprom170 = zext i8 %bf.lshr169 to i64
  %arrayidx171 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %127, i64 %idxprom170
  store %struct.bpf_reg_state* %arrayidx171, %struct.bpf_reg_state** %src_reg166, align 8
  %129 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type172 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %129, i32 0, i32 0
  %130 = load i32, i32* %type172, align 8
  %cmp173 = icmp eq i32 %130, 1
  br i1 %cmp173, label %land.lhs.true175, label %if.end298

land.lhs.true175:                                 ; preds = %if.then165
  %131 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg166, align 8
  %type176 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %131, i32 0, i32 0
  %132 = load i32, i32* %type176, align 8
  %cmp177 = icmp eq i32 %132, 1
  br i1 %cmp177, label %if.then179, label %if.end298

if.then179:                                       ; preds = %land.lhs.true175
  %133 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg166, align 8
  %var_off180 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %133, i32 0, i32 5
  %134 = bitcast %struct.tnum* %var_off180 to { i64, i64 }*
  %135 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %134, i32 0, i32 0
  %136 = load i64, i64* %135, align 8
  %137 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %134, i32 0, i32 1
  %138 = load i64, i64* %137, align 8
  %call181 = call zeroext i1 @tnum_is_const(i64 %136, i64 %138) #11
  br i1 %call181, label %if.then192, label %lor.lhs.false183

lor.lhs.false183:                                 ; preds = %if.then179
  %139 = load i8, i8* %is_jmp32, align 1
  %tobool184 = trunc i8 %139 to i1
  br i1 %tobool184, label %land.lhs.true186, label %if.else206

land.lhs.true186:                                 ; preds = %lor.lhs.false183
  %140 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg166, align 8
  %var_off188 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %140, i32 0, i32 5
  %141 = bitcast %struct.tnum* %var_off188 to { i64, i64 }*
  %142 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %141, i32 0, i32 0
  %143 = load i64, i64* %142, align 8
  %144 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %141, i32 0, i32 1
  %145 = load i64, i64* %144, align 8
  %call189 = call { i64, i64 } @tnum_subreg(i64 %143, i64 %145) #11
  %146 = bitcast %struct.tnum* %agg.tmp187 to { i64, i64 }*
  %147 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %146, i32 0, i32 0
  %148 = extractvalue { i64, i64 } %call189, 0
  store i64 %148, i64* %147, align 8
  %149 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %146, i32 0, i32 1
  %150 = extractvalue { i64, i64 } %call189, 1
  store i64 %150, i64* %149, align 8
  %151 = bitcast %struct.tnum* %agg.tmp187 to { i64, i64 }*
  %152 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %151, i32 0, i32 0
  %153 = load i64, i64* %152, align 8
  %154 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %151, i32 0, i32 1
  %155 = load i64, i64* %154, align 8
  %call190 = call zeroext i1 @tnum_is_const(i64 %153, i64 %155) #11
  br i1 %call190, label %if.then192, label %if.else206

if.then192:                                       ; preds = %land.lhs.true186, %if.then179
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %157 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg193 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %157, i32 0, i32 1
  %bf.load194 = load i8, i8* %dst_reg193, align 1
  %bf.clear195 = and i8 %bf.load194, 15
  %idxprom196 = zext i8 %bf.clear195 to i64
  %arrayidx197 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i64 %idxprom196
  %158 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %159 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg166, align 8
  %var_off198 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %159, i32 0, i32 5
  %value199 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off198, i32 0, i32 0
  %160 = load i64, i64* %value199, align 8
  %161 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg166, align 8
  %var_off200 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %161, i32 0, i32 5
  %162 = bitcast %struct.tnum* %var_off200 to { i64, i64 }*
  %163 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %162, i32 0, i32 0
  %164 = load i64, i64* %163, align 8
  %165 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %162, i32 0, i32 1
  %166 = load i64, i64* %165, align 8
  %call201 = call { i64, i64 } @tnum_subreg(i64 %164, i64 %166) #11
  %167 = bitcast %struct.tnum* %coerce202 to { i64, i64 }*
  %168 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %167, i32 0, i32 0
  %169 = extractvalue { i64, i64 } %call201, 0
  store i64 %169, i64* %168, align 8
  %170 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %167, i32 0, i32 1
  %171 = extractvalue { i64, i64 } %call201, 1
  store i64 %171, i64* %170, align 8
  %value203 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce202, i32 0, i32 0
  %172 = load i64, i64* %value203, align 8
  %conv204 = trunc i64 %172 to i32
  %173 = load i8, i8* %opcode, align 1
  %174 = load i8, i8* %is_jmp32, align 1
  %tobool205 = trunc i8 %174 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %arrayidx197, %struct.bpf_reg_state* noundef %158, i64 noundef %160, i32 noundef %conv204, i8 noundef zeroext %173, i1 noundef zeroext %tobool205) #11
  br label %if.end256

if.else206:                                       ; preds = %land.lhs.true186, %lor.lhs.false183
  %175 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off207 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %175, i32 0, i32 5
  %176 = bitcast %struct.tnum* %var_off207 to { i64, i64 }*
  %177 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %176, i32 0, i32 0
  %178 = load i64, i64* %177, align 8
  %179 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %176, i32 0, i32 1
  %180 = load i64, i64* %179, align 8
  %call208 = call zeroext i1 @tnum_is_const(i64 %178, i64 %180) #11
  br i1 %call208, label %if.then219, label %lor.lhs.false210

lor.lhs.false210:                                 ; preds = %if.else206
  %181 = load i8, i8* %is_jmp32, align 1
  %tobool211 = trunc i8 %181 to i1
  br i1 %tobool211, label %land.lhs.true213, label %if.else233

land.lhs.true213:                                 ; preds = %lor.lhs.false210
  %182 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off215 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %182, i32 0, i32 5
  %183 = bitcast %struct.tnum* %var_off215 to { i64, i64 }*
  %184 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %183, i32 0, i32 0
  %185 = load i64, i64* %184, align 8
  %186 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %183, i32 0, i32 1
  %187 = load i64, i64* %186, align 8
  %call216 = call { i64, i64 } @tnum_subreg(i64 %185, i64 %187) #11
  %188 = bitcast %struct.tnum* %agg.tmp214 to { i64, i64 }*
  %189 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %188, i32 0, i32 0
  %190 = extractvalue { i64, i64 } %call216, 0
  store i64 %190, i64* %189, align 8
  %191 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %188, i32 0, i32 1
  %192 = extractvalue { i64, i64 } %call216, 1
  store i64 %192, i64* %191, align 8
  %193 = bitcast %struct.tnum* %agg.tmp214 to { i64, i64 }*
  %194 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %193, i32 0, i32 0
  %195 = load i64, i64* %194, align 8
  %196 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %193, i32 0, i32 1
  %197 = load i64, i64* %196, align 8
  %call217 = call zeroext i1 @tnum_is_const(i64 %195, i64 %197) #11
  br i1 %call217, label %if.then219, label %if.else233

if.then219:                                       ; preds = %land.lhs.true213, %if.else206
  %198 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %199 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg220 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %199, i32 0, i32 1
  %bf.load221 = load i8, i8* %src_reg220, align 1
  %bf.lshr222 = lshr i8 %bf.load221, 4
  %idxprom223 = zext i8 %bf.lshr222 to i64
  %arrayidx224 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %198, i64 %idxprom223
  %200 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg166, align 8
  %201 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off225 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %201, i32 0, i32 5
  %value226 = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off225, i32 0, i32 0
  %202 = load i64, i64* %value226, align 8
  %203 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off227 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %203, i32 0, i32 5
  %204 = bitcast %struct.tnum* %var_off227 to { i64, i64 }*
  %205 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %204, i32 0, i32 0
  %206 = load i64, i64* %205, align 8
  %207 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %204, i32 0, i32 1
  %208 = load i64, i64* %207, align 8
  %call228 = call { i64, i64 } @tnum_subreg(i64 %206, i64 %208) #11
  %209 = bitcast %struct.tnum* %coerce229 to { i64, i64 }*
  %210 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %209, i32 0, i32 0
  %211 = extractvalue { i64, i64 } %call228, 0
  store i64 %211, i64* %210, align 8
  %212 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %209, i32 0, i32 1
  %213 = extractvalue { i64, i64 } %call228, 1
  store i64 %213, i64* %212, align 8
  %value230 = getelementptr inbounds %struct.tnum, %struct.tnum* %coerce229, i32 0, i32 0
  %214 = load i64, i64* %value230, align 8
  %conv231 = trunc i64 %214 to i32
  %215 = load i8, i8* %opcode, align 1
  %216 = load i8, i8* %is_jmp32, align 1
  %tobool232 = trunc i8 %216 to i1
  call void @reg_set_min_max_inv(%struct.bpf_reg_state* noundef %arrayidx224, %struct.bpf_reg_state* noundef %200, i64 noundef %202, i32 noundef %conv231, i8 noundef zeroext %215, i1 noundef zeroext %tobool232) #11
  br label %if.end255

if.else233:                                       ; preds = %land.lhs.true213, %lor.lhs.false210
  %217 = load i8, i8* %is_jmp32, align 1
  %tobool234 = trunc i8 %217 to i1
  br i1 %tobool234, label %if.end254, label %land.lhs.true235

land.lhs.true235:                                 ; preds = %if.else233
  %218 = load i8, i8* %opcode, align 1
  %conv236 = zext i8 %218 to i32
  %cmp237 = icmp eq i32 %conv236, 16
  br i1 %cmp237, label %if.then243, label %lor.lhs.false239

lor.lhs.false239:                                 ; preds = %land.lhs.true235
  %219 = load i8, i8* %opcode, align 1
  %conv240 = zext i8 %219 to i32
  %cmp241 = icmp eq i32 %conv240, 80
  br i1 %cmp241, label %if.then243, label %if.end254

if.then243:                                       ; preds = %lor.lhs.false239, %land.lhs.true235
  %220 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %221 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg244 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %221, i32 0, i32 1
  %bf.load245 = load i8, i8* %src_reg244, align 1
  %bf.lshr246 = lshr i8 %bf.load245, 4
  %idxprom247 = zext i8 %bf.lshr246 to i64
  %arrayidx248 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %220, i64 %idxprom247
  %222 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %223 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg249 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %223, i32 0, i32 1
  %bf.load250 = load i8, i8* %dst_reg249, align 1
  %bf.clear251 = and i8 %bf.load250, 15
  %idxprom252 = zext i8 %bf.clear251 to i64
  %arrayidx253 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %222, i64 %idxprom252
  %224 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg166, align 8
  %225 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %226 = load i8, i8* %opcode, align 1
  call void @reg_combine_min_max(%struct.bpf_reg_state* noundef %arrayidx248, %struct.bpf_reg_state* noundef %arrayidx253, %struct.bpf_reg_state* noundef %224, %struct.bpf_reg_state* noundef %225, i8 noundef zeroext %226) #11
  br label %if.end254

if.end254:                                        ; preds = %if.then243, %lor.lhs.false239, %if.else233
  br label %if.end255

if.end255:                                        ; preds = %if.end254, %if.then219
  br label %if.end256

if.end256:                                        ; preds = %if.end255, %if.then192
  %227 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg166, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %227, i32 0, i32 3
  %228 = load i32, i32* %id, align 4
  %tobool257 = icmp ne i32 %228, 0
  br i1 %tobool257, label %land.lhs.true258, label %if.end297

land.lhs.true258:                                 ; preds = %if.end256
  %229 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg166, align 8
  %id259 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %229, i32 0, i32 3
  %230 = load i32, i32* %id259, align 4
  %231 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %232 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg260 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %232, i32 0, i32 1
  %bf.load261 = load i8, i8* %src_reg260, align 1
  %bf.lshr262 = lshr i8 %bf.load261, 4
  %idxprom263 = zext i8 %bf.lshr262 to i64
  %arrayidx264 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %231, i64 %idxprom263
  %id265 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx264, i32 0, i32 3
  %233 = load i32, i32* %id265, align 4
  %cmp266 = icmp ne i32 %230, %233
  %lnot = xor i1 %cmp266, true
  %lnot268 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot268 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %234 = load i32, i32* %__ret_warn_on, align 4
  %tobool269 = icmp ne i32 %234, 0
  %lnot270 = xor i1 %tobool269, true
  %lnot272 = xor i1 %lnot270, true
  %lnot.ext273 = zext i1 %lnot272 to i32
  %conv274 = sext i32 %lnot.ext273 to i64
  %tobool275 = icmp ne i64 %conv274, 0
  br i1 %tobool275, label %if.then276, label %if.end283

if.then276:                                       ; preds = %land.lhs.true258
  br label %do.body

do.body:                                          ; preds = %if.then276
  br label %do.body277

do.body277:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body277
  br label %do.body278

do.body278:                                       ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 7872, i32 2307, i64 12) #10, !srcloc !41
  br label %do.end279

do.end279:                                        ; preds = %do.body278
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 483) #10, !srcloc !42
  br label %do.body280

do.body280:                                       ; preds = %do.end279
  br label %do.end281

do.end281:                                        ; preds = %do.body280
  br label %do.end282

do.end282:                                        ; preds = %do.end281
  br label %if.end283

if.end283:                                        ; preds = %do.end282, %land.lhs.true258
  %235 = load i32, i32* %__ret_warn_on, align 4
  %tobool284 = icmp ne i32 %235, 0
  %lnot285 = xor i1 %tobool284, true
  %lnot287 = xor i1 %lnot285, true
  %lnot.ext288 = zext i1 %lnot287 to i32
  %conv289 = sext i32 %lnot.ext288 to i64
  store i64 %conv289, i64* %tmp, align 8
  %236 = load i64, i64* %tmp, align 8
  %tobool290 = icmp ne i64 %236, 0
  br i1 %tobool290, label %if.end297, label %if.then291

if.then291:                                       ; preds = %if.end283
  %237 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %238 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg166, align 8
  call void @find_equal_scalars(%struct.bpf_verifier_state* noundef %237, %struct.bpf_reg_state* noundef %238) #11
  %239 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %240 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %241 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg292 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %241, i32 0, i32 1
  %bf.load293 = load i8, i8* %src_reg292, align 1
  %bf.lshr294 = lshr i8 %bf.load293, 4
  %idxprom295 = zext i8 %bf.lshr294 to i64
  %arrayidx296 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %240, i64 %idxprom295
  call void @find_equal_scalars(%struct.bpf_verifier_state* noundef %239, %struct.bpf_reg_state* noundef %arrayidx296) #11
  br label %if.end297

if.end297:                                        ; preds = %if.then291, %if.end283, %if.end256
  br label %if.end298

if.end298:                                        ; preds = %if.end297, %land.lhs.true175, %if.then165
  br label %if.end314

if.else299:                                       ; preds = %if.end153
  %242 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type300 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %242, i32 0, i32 0
  %243 = load i32, i32* %type300, align 8
  %cmp301 = icmp eq i32 %243, 1
  br i1 %cmp301, label %if.then303, label %if.end313

if.then303:                                       ; preds = %if.else299
  %244 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %245 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg304 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %245, i32 0, i32 1
  %bf.load305 = load i8, i8* %dst_reg304, align 1
  %bf.clear306 = and i8 %bf.load305, 15
  %idxprom307 = zext i8 %bf.clear306 to i64
  %arrayidx308 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %244, i64 %idxprom307
  %246 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %247 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm309 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %247, i32 0, i32 3
  %248 = load i32, i32* %imm309, align 4
  %conv310 = sext i32 %248 to i64
  %249 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm311 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %249, i32 0, i32 3
  %250 = load i32, i32* %imm311, align 4
  %251 = load i8, i8* %opcode, align 1
  %252 = load i8, i8* %is_jmp32, align 1
  %tobool312 = trunc i8 %252 to i1
  call void @reg_set_min_max(%struct.bpf_reg_state* noundef %arrayidx308, %struct.bpf_reg_state* noundef %246, i64 noundef %conv310, i32 noundef %250, i8 noundef zeroext %251, i1 noundef zeroext %tobool312) #11
  br label %if.end313

if.end313:                                        ; preds = %if.then303, %if.else299
  br label %if.end314

if.end314:                                        ; preds = %if.end313, %if.end298
  %253 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type315 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %253, i32 0, i32 0
  %254 = load i32, i32* %type315, align 8
  %cmp316 = icmp eq i32 %254, 1
  br i1 %cmp316, label %land.lhs.true318, label %if.end367

land.lhs.true318:                                 ; preds = %if.end314
  %255 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id319 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %255, i32 0, i32 3
  %256 = load i32, i32* %id319, align 4
  %tobool320 = icmp ne i32 %256, 0
  br i1 %tobool320, label %land.lhs.true321, label %if.end367

land.lhs.true321:                                 ; preds = %land.lhs.true318
  %257 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id323 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %257, i32 0, i32 3
  %258 = load i32, i32* %id323, align 4
  %259 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %260 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg324 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %260, i32 0, i32 1
  %bf.load325 = load i8, i8* %dst_reg324, align 1
  %bf.clear326 = and i8 %bf.load325, 15
  %idxprom327 = zext i8 %bf.clear326 to i64
  %arrayidx328 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %259, i64 %idxprom327
  %id329 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx328, i32 0, i32 3
  %261 = load i32, i32* %id329, align 4
  %cmp330 = icmp ne i32 %258, %261
  %lnot332 = xor i1 %cmp330, true
  %lnot334 = xor i1 %lnot332, true
  %lnot.ext335 = zext i1 %lnot334 to i32
  store i32 %lnot.ext335, i32* %__ret_warn_on322, align 4
  %262 = load i32, i32* %__ret_warn_on322, align 4
  %tobool336 = icmp ne i32 %262, 0
  %lnot337 = xor i1 %tobool336, true
  %lnot339 = xor i1 %lnot337, true
  %lnot.ext340 = zext i1 %lnot339 to i32
  %conv341 = sext i32 %lnot.ext340 to i64
  %tobool342 = icmp ne i64 %conv341, 0
  br i1 %tobool342, label %if.then343, label %if.end352

if.then343:                                       ; preds = %land.lhs.true321
  br label %do.body344

do.body344:                                       ; preds = %if.then343
  br label %do.body345

do.body345:                                       ; preds = %do.body344
  br label %do.end346

do.end346:                                        ; preds = %do.body345
  br label %do.body347

do.body347:                                       ; preds = %do.end346
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 7885, i32 2307, i64 12) #10, !srcloc !43
  br label %do.end348

do.end348:                                        ; preds = %do.body347
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 484) #10, !srcloc !44
  br label %do.body349

do.body349:                                       ; preds = %do.end348
  br label %do.end350

do.end350:                                        ; preds = %do.body349
  br label %do.end351

do.end351:                                        ; preds = %do.end350
  br label %if.end352

if.end352:                                        ; preds = %do.end351, %land.lhs.true321
  %263 = load i32, i32* %__ret_warn_on322, align 4
  %tobool354 = icmp ne i32 %263, 0
  %lnot355 = xor i1 %tobool354, true
  %lnot357 = xor i1 %lnot355, true
  %lnot.ext358 = zext i1 %lnot357 to i32
  %conv359 = sext i32 %lnot.ext358 to i64
  store i64 %conv359, i64* %tmp353, align 8
  %264 = load i64, i64* %tmp353, align 8
  %tobool360 = icmp ne i64 %264, 0
  br i1 %tobool360, label %if.end367, label %if.then361

if.then361:                                       ; preds = %if.end352
  %265 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %266 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @find_equal_scalars(%struct.bpf_verifier_state* noundef %265, %struct.bpf_reg_state* noundef %266) #11
  %267 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %268 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %other_branch_regs, align 8
  %269 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg362 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %269, i32 0, i32 1
  %bf.load363 = load i8, i8* %dst_reg362, align 1
  %bf.clear364 = and i8 %bf.load363, 15
  %idxprom365 = zext i8 %bf.clear364 to i64
  %arrayidx366 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %268, i64 %idxprom365
  call void @find_equal_scalars(%struct.bpf_verifier_state* noundef %267, %struct.bpf_reg_state* noundef %arrayidx366) #11
  br label %if.end367

if.end367:                                        ; preds = %if.then361, %if.end352, %land.lhs.true318, %if.end314
  %270 = load i8, i8* %is_jmp32, align 1
  %tobool368 = trunc i8 %270 to i1
  br i1 %tobool368, label %if.else406, label %land.lhs.true369

land.lhs.true369:                                 ; preds = %if.end367
  %271 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code370 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %271, i32 0, i32 0
  %272 = load i8, i8* %code370, align 4
  %conv371 = zext i8 %272 to i32
  %and372 = and i32 %conv371, 8
  %cmp373 = icmp eq i32 %and372, 0
  br i1 %cmp373, label %land.lhs.true375, label %if.else406

land.lhs.true375:                                 ; preds = %land.lhs.true369
  %273 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm376 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %273, i32 0, i32 3
  %274 = load i32, i32* %imm376, align 4
  %cmp377 = icmp eq i32 %274, 0
  br i1 %cmp377, label %land.lhs.true379, label %if.else406

land.lhs.true379:                                 ; preds = %land.lhs.true375
  %275 = load i8, i8* %opcode, align 1
  %conv380 = zext i8 %275 to i32
  %cmp381 = icmp eq i32 %conv380, 16
  br i1 %cmp381, label %land.lhs.true387, label %lor.lhs.false383

lor.lhs.false383:                                 ; preds = %land.lhs.true379
  %276 = load i8, i8* %opcode, align 1
  %conv384 = zext i8 %276 to i32
  %cmp385 = icmp eq i32 %conv384, 80
  br i1 %cmp385, label %land.lhs.true387, label %if.else406

land.lhs.true387:                                 ; preds = %lor.lhs.false383, %land.lhs.true379
  %277 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type388 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %277, i32 0, i32 0
  %278 = load i32, i32* %type388, align 8
  %call389 = call zeroext i1 @reg_type_may_be_null(i32 noundef %278) #11
  br i1 %call389, label %if.then391, label %if.else406

if.then391:                                       ; preds = %land.lhs.true387
  %279 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %280 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg392 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %280, i32 0, i32 1
  %bf.load393 = load i8, i8* %dst_reg392, align 1
  %bf.clear394 = and i8 %bf.load393, 15
  %conv395 = zext i8 %bf.clear394 to i32
  %281 = load i8, i8* %opcode, align 1
  %conv396 = zext i8 %281 to i32
  %cmp397 = icmp eq i32 %conv396, 80
  call void @mark_ptr_or_null_regs(%struct.bpf_verifier_state* noundef %279, i32 noundef %conv395, i1 noundef zeroext %cmp397) #11
  %282 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %283 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg399 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %283, i32 0, i32 1
  %bf.load400 = load i8, i8* %dst_reg399, align 1
  %bf.clear401 = and i8 %bf.load400, 15
  %conv402 = zext i8 %bf.clear401 to i32
  %284 = load i8, i8* %opcode, align 1
  %conv403 = zext i8 %284 to i32
  %cmp404 = icmp eq i32 %conv403, 16
  call void @mark_ptr_or_null_regs(%struct.bpf_verifier_state* noundef %282, i32 noundef %conv402, i1 noundef zeroext %cmp404) #11
  br label %if.end426

if.else406:                                       ; preds = %land.lhs.true387, %lor.lhs.false383, %land.lhs.true375, %land.lhs.true369, %if.end367
  %285 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %286 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %287 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %288 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg407 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %288, i32 0, i32 1
  %bf.load408 = load i8, i8* %src_reg407, align 1
  %bf.lshr409 = lshr i8 %bf.load408, 4
  %idxprom410 = zext i8 %bf.lshr409 to i64
  %arrayidx411 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %287, i64 %idxprom410
  %289 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %290 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch, align 8
  %call412 = call zeroext i1 @try_match_pkt_pointers(%struct.bpf_insn* noundef %285, %struct.bpf_reg_state* noundef %286, %struct.bpf_reg_state* noundef %arrayidx411, %struct.bpf_verifier_state* noundef %289, %struct.bpf_verifier_state* noundef %290) #11
  br i1 %call412, label %if.end425, label %land.lhs.true413

land.lhs.true413:                                 ; preds = %if.else406
  %291 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %292 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg414 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %292, i32 0, i32 1
  %bf.load415 = load i8, i8* %dst_reg414, align 1
  %bf.clear416 = and i8 %bf.load415, 15
  %conv417 = zext i8 %bf.clear416 to i32
  %call418 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %291, i32 noundef %conv417) #11
  br i1 %call418, label %if.then420, label %if.end425

if.then420:                                       ; preds = %land.lhs.true413
  %293 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %294 = bitcast %struct.bpf_verifier_env* %293 to i8*
  %295 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg421 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %295, i32 0, i32 1
  %bf.load422 = load i8, i8* %dst_reg421, align 1
  %bf.clear423 = and i8 %bf.load422, 15
  %conv424 = zext i8 %bf.clear423 to i32
  call void (i8*, i8*, ...) @verbose(i8* noundef %294, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.365, i64 0, i64 0), i32 noundef %conv424) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end425:                                        ; preds = %land.lhs.true413, %if.else406
  br label %if.end426

if.end426:                                        ; preds = %if.end425, %if.then391
  %296 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %296, i32 0, i32 22
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %297 = load i32, i32* %level, align 8
  %and427 = and i32 %297, 3
  %tobool428 = icmp ne i32 %and427, 0
  br i1 %tobool428, label %if.then429, label %if.end434

if.then429:                                       ; preds = %if.end426
  %298 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %299 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %frame430 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %299, i32 0, i32 0
  %300 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch, align 8
  %curframe431 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %300, i32 0, i32 4
  %301 = load i32, i32* %curframe431, align 8
  %idxprom432 = zext i32 %301 to i64
  %arrayidx433 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame430, i64 0, i64 %idxprom432
  %302 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx433, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %298, %struct.bpf_func_state* noundef %302) #11
  br label %if.end434

if.end434:                                        ; preds = %if.then429, %if.end426
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end434, %if.then420, %if.then152, %if.then143, %if.then138, %if.then133, %if.then53, %if.then45, %if.then28, %if.then21, %if.then17, %if.then
  %303 = load i32, i32* %retval, align 4
  ret i32 %303
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ld_abs(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %mode = alloca i8, align 1
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %1, i32 0, i32 0
  %2 = load i8, i8* %code, align 4
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 224
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %mode, align 1
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call2 = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %4) #11
  %call3 = call zeroext i1 @may_access_skb(i32 noundef %call2) #11
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = bitcast %struct.bpf_verifier_env* %5 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %6, i8* noundef getelementptr inbounds ([65 x i8], [65 x i8]* @.str.366, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 3
  %8 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %gen_ld_abs = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %8, i32 0, i32 3
  %9 = load i32 (%struct.bpf_insn*, %struct.bpf_insn*)*, i32 (%struct.bpf_insn*, %struct.bpf_insn*)** %gen_ld_abs, align 8
  %tobool = icmp ne i32 (%struct.bpf_insn*, %struct.bpf_insn*)* %9, null
  br i1 %tobool, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.367, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %12, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv6 = zext i8 %bf.clear to i32
  %cmp = icmp ne i32 %conv6, 0
  br i1 %cmp, label %if.then25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 2
  %14 = load i16, i16* %off, align 2
  %conv8 = sext i16 %14 to i32
  %cmp9 = icmp ne i32 %conv8, 0
  br i1 %cmp9, label %if.then25, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code12 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 0
  %16 = load i8, i8* %code12, align 4
  %conv13 = zext i8 %16 to i32
  %and14 = and i32 %conv13, 24
  %cmp15 = icmp eq i32 %and14, 24
  br i1 %cmp15, label %if.then25, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %lor.lhs.false11
  %17 = load i8, i8* %mode, align 1
  %conv18 = zext i8 %17 to i32
  %cmp19 = icmp eq i32 %conv18, 32
  br i1 %cmp19, label %land.lhs.true, label %if.end26

land.lhs.true:                                    ; preds = %lor.lhs.false17
  %18 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %18, i32 0, i32 1
  %bf.load21 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load21, 4
  %conv22 = zext i8 %bf.lshr to i32
  %cmp23 = icmp ne i32 %conv22, 0
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %land.lhs.true, %lor.lhs.false11, %lor.lhs.false, %if.end5
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.368, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %land.lhs.true, %lor.lhs.false17
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call27 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %21, i32 noundef 6, i32 noundef 0) #11
  store i32 %call27, i32* %err, align 4
  %22 = load i32, i32* %err, align 4
  %tobool28 = icmp ne i32 %22, 0
  br i1 %tobool28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.end26
  %23 = load i32, i32* %err, align 4
  store i32 %23, i32* %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.end26
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call31 = call i32 @check_reference_leak(%struct.bpf_verifier_env* noundef %24) #11
  store i32 %call31, i32* %err, align 4
  %25 = load i32, i32* %err, align 4
  %tobool32 = icmp ne i32 %25, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end30
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([57 x i8], [57 x i8]* @.str.369, i64 0, i64 0)) #11
  %28 = load i32, i32* %err, align 4
  store i32 %28, i32* %retval, align 4
  br label %return

if.end34:                                         ; preds = %if.end30
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %29, i32 0, i32 8
  %30 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %30, i32 0, i32 5
  %31 = load i32, i32* %active_spin_lock, align 4
  %tobool35 = icmp ne i32 %31, 0
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end34
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = bitcast %struct.bpf_verifier_env* %32 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %33, i8* noundef getelementptr inbounds ([64 x i8], [64 x i8]* @.str.370, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end34
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i64 6
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  %35 = load i32, i32* %type, align 8
  %cmp38 = icmp ne i32 %35, 2
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end37
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.371, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end37
  %38 = load i8, i8* %mode, align 1
  %conv42 = zext i8 %38 to i32
  %cmp43 = icmp eq i32 %conv42, 64
  br i1 %cmp43, label %if.then45, label %if.end54

if.then45:                                        ; preds = %if.end41
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg46 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %40, i32 0, i32 1
  %bf.load47 = load i8, i8* %src_reg46, align 1
  %bf.lshr48 = lshr i8 %bf.load47, 4
  %conv49 = zext i8 %bf.lshr48 to i32
  %call50 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %39, i32 noundef %conv49, i32 noundef 0) #11
  store i32 %call50, i32* %err, align 4
  %41 = load i32, i32* %err, align 4
  %tobool51 = icmp ne i32 %41, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.then45
  %42 = load i32, i32* %err, align 4
  store i32 %42, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.then45
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.end41
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx55 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i64 6
  %call56 = call i32 @check_ctx_reg(%struct.bpf_verifier_env* noundef %43, %struct.bpf_reg_state* noundef %arrayidx55, i32 noundef 6) #11
  store i32 %call56, i32* %err, align 4
  %45 = load i32, i32* %err, align 4
  %cmp57 = icmp slt i32 %45, 0
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end54
  %46 = load i32, i32* %err, align 4
  store i32 %46, i32* %retval, align 4
  br label %return

if.end60:                                         ; preds = %if.end54
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end60
  %47 = load i32, i32* %i, align 4
  %cmp61 = icmp slt i32 %47, 6
  br i1 %cmp61, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %50 = load i32, i32* %i, align 4
  %idxprom = sext i32 %50 to i64
  %arrayidx63 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom
  %51 = load i32, i32* %arrayidx63, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %48, %struct.bpf_reg_state* noundef %49, i32 noundef %51) #11
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load i32, i32* %i, align 4
  %idxprom64 = sext i32 %53 to i64
  %arrayidx65 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom64
  %54 = load i32, i32* %arrayidx65, align 4
  %call66 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %52, i32 noundef %54, i32 noundef 2) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %55 = load i32, i32* %i, align 4
  %inc = add i32 %55, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %56, %struct.bpf_reg_state* noundef %57, i32 noundef 0) #11
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %58, i32 0, i32 0
  %59 = load i32, i32* %insn_idx, align 8
  %add = add i32 %59, 1
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx67 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i64 0
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx67, i32 0, i32 16
  store i32 %add, i32* %subreg_def, align 4
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then59, %if.then52, %if.then40, %if.then36, %if.then33, %if.then29, %if.then25, %if.then4, %if.then
  %61 = load i32, i32* %retval, align 4
  ret i32 %61
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ld_imm(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %err = alloca i32, align 4
  %imm = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_insn_aux_data* %call, %struct.bpf_insn_aux_data** %aux, align 8
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call1 = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %1) #11
  store %struct.bpf_reg_state* %call1, %struct.bpf_reg_state** %regs, align 8
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code, align 4
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 24
  %cmp = icmp ne i32 %and, 24
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.372, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %6, i32 0, i32 2
  %7 = load i16, i16* %off, align 2
  %conv3 = sext i16 %7 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.373, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg8 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg8, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv9 = zext i8 %bf.clear to i32
  %call10 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %10, i32 noundef %conv9, i32 noundef 1) #11
  store i32 %call10, i32* %err, align 4
  %12 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end7
  %13 = load i32, i32* %err, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end7
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %15 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %15, i32 0, i32 1
  %bf.load14 = load i8, i8* %dst_reg13, align 1
  %bf.clear15 = and i8 %bf.load14, 15
  %idxprom = zext i8 %bf.clear15 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %dst_reg, align 8
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 1
  %bf.load16 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load16, 4
  %conv17 = zext i8 %bf.lshr to i32
  %cmp18 = icmp eq i32 %conv17, 0
  br i1 %cmp18, label %if.then20, label %if.end30

if.then20:                                        ; preds = %if.end12
  %17 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %17, i64 1
  %imm21 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %add.ptr, i32 0, i32 3
  %18 = load i32, i32* %imm21, align 4
  %conv22 = sext i32 %18 to i64
  %shl = shl i64 %conv22, 32
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %19, i32 0, i32 3
  %20 = load i32, i32* %imm23, align 4
  %conv24 = zext i32 %20 to i64
  %or = or i64 %shl, %conv24
  store i64 %or, i64* %imm, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  store i32 1, i32* %type, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %23 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg25 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %23, i32 0, i32 1
  %bf.load26 = load i8, i8* %dst_reg25, align 1
  %bf.clear27 = and i8 %bf.load26, 15
  %idxprom28 = zext i8 %bf.clear27 to i64
  %arrayidx29 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i64 %idxprom28
  %24 = load i64, i64* %imm, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %arrayidx29, i64 noundef %24) #11
  store i32 0, i32* %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.end12
  %25 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg31 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %25, i32 0, i32 1
  %bf.load32 = load i8, i8* %src_reg31, align 1
  %bf.lshr33 = lshr i8 %bf.load32, 4
  %conv34 = zext i8 %bf.lshr33 to i32
  %cmp35 = icmp eq i32 %conv34, 3
  br i1 %cmp35, label %if.then37, label %if.end49

if.then37:                                        ; preds = %if.end30
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %28 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg38 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %28, i32 0, i32 1
  %bf.load39 = load i8, i8* %dst_reg38, align 1
  %bf.clear40 = and i8 %bf.load39, 15
  %conv41 = zext i8 %bf.clear40 to i32
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %26, %struct.bpf_reg_state* noundef %27, i32 noundef %conv41) #11
  %29 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %30 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %29, i32 0, i32 0
  %btf_var = bitcast %struct.atomic64_t* %30 to %struct.ethtool_link_ext_state_info*
  %reg_type = getelementptr inbounds %struct.ethtool_link_ext_state_info, %struct.ethtool_link_ext_state_info* %btf_var, i32 0, i32 0
  %31 = load i32, i32* %reg_type, align 8
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type42 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 0
  store i32 %31, i32* %type42, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 0
  %34 = load i32, i32* %type43, align 8
  switch i32 %34, label %sw.default [
    i32 21, label %sw.bb
    i32 19, label %sw.bb46
    i32 27, label %sw.bb46
  ]

sw.bb:                                            ; preds = %if.then37
  %35 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %36 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %35, i32 0, i32 0
  %btf_var44 = bitcast %struct.atomic64_t* %36 to %struct.ethtool_link_ext_state_info*
  %37 = getelementptr inbounds %struct.ethtool_link_ext_state_info, %struct.ethtool_link_ext_state_info* %btf_var44, i32 0, i32 1
  %mem_size = bitcast %struct.atomic_t* %37 to i32*
  %38 = load i32, i32* %mem_size, align 4
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %40 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 1
  %mem_size45 = bitcast %struct.bpf_iter_aux_info* %40 to i32*
  store i32 %38, i32* %mem_size45, align 8
  br label %sw.epilog

sw.bb46:                                          ; preds = %if.then37, %if.then37
  %41 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %42 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %41, i32 0, i32 0
  %btf_var47 = bitcast %struct.atomic64_t* %42 to %struct.ethtool_link_ext_state_info*
  %43 = getelementptr inbounds %struct.ethtool_link_ext_state_info, %struct.ethtool_link_ext_state_info* %btf_var47, i32 0, i32 1
  %btf_id = bitcast %struct.atomic_t* %43 to i32*
  %44 = load i32, i32* %btf_id, align 4
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %46 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %45, i32 0, i32 1
  %btf_id48 = bitcast %struct.bpf_iter_aux_info* %46 to i32*
  store i32 %44, i32* %btf_id48, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.then37
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = bitcast %struct.bpf_verifier_env* %47 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %48, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.367, i64 0, i64 0)) #11
  store i32 -14, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb46, %sw.bb
  store i32 0, i32* %retval, align 4
  br label %return

if.end49:                                         ; preds = %if.end30
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %used_maps = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %49, i32 0, i32 11
  %50 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %51 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %50, i32 0, i32 0
  %52 = bitcast %struct.atomic64_t* %51 to %struct.util_est*
  %map_index = getelementptr inbounds %struct.util_est, %struct.util_est* %52, i32 0, i32 0
  %53 = load i32, i32* %map_index, align 8
  %idxprom50 = zext i32 %53 to i64
  %arrayidx51 = getelementptr [64 x %struct.bpf_map*], [64 x %struct.bpf_map*]* %used_maps, i64 0, i64 %idxprom50
  %54 = load %struct.bpf_map*, %struct.bpf_map** %arrayidx51, align 8
  store %struct.bpf_map* %54, %struct.bpf_map** %map, align 8
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %57 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg52 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %57, i32 0, i32 1
  %bf.load53 = load i8, i8* %dst_reg52, align 1
  %bf.clear54 = and i8 %bf.load53, 15
  %conv55 = zext i8 %bf.clear54 to i32
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %55, %struct.bpf_reg_state* noundef %56, i32 noundef %conv55) #11
  %58 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %60 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 1
  %map_ptr = bitcast %struct.bpf_iter_aux_info* %60 to %struct.bpf_map**
  store %struct.bpf_map* %58, %struct.bpf_map** %map_ptr, align 8
  %61 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg56 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %61, i32 0, i32 1
  %bf.load57 = load i8, i8* %src_reg56, align 1
  %bf.lshr58 = lshr i8 %bf.load57, 4
  %conv59 = zext i8 %bf.lshr58 to i32
  %cmp60 = icmp eq i32 %conv59, 2
  br i1 %cmp60, label %if.then62, label %if.else

if.then62:                                        ; preds = %if.end49
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type63 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 0
  store i32 4, i32* %type63, align 8
  %63 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %64 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %63, i32 0, i32 0
  %65 = bitcast %struct.atomic64_t* %64 to %struct.util_est*
  %map_off = getelementptr inbounds %struct.util_est, %struct.util_est* %65, i32 0, i32 1
  %66 = load i32, i32* %map_off, align 4
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off64 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i32 0, i32 2
  store i32 %66, i32* %off64, align 8
  %68 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call65 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %68) #11
  br i1 %call65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.then62
  %69 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %69, i32 0, i32 13
  %70 = load i32, i32* %id_gen, align 4
  %inc = add i32 %70, 1
  store i32 %inc, i32* %id_gen, align 4
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 3
  store i32 %inc, i32* %id, align 4
  br label %if.end67

if.end67:                                         ; preds = %if.then66, %if.then62
  br label %if.end78

if.else:                                          ; preds = %if.end49
  %72 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg68 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %72, i32 0, i32 1
  %bf.load69 = load i8, i8* %src_reg68, align 1
  %bf.lshr70 = lshr i8 %bf.load69, 4
  %conv71 = zext i8 %bf.lshr70 to i32
  %cmp72 = icmp eq i32 %conv71, 1
  br i1 %cmp72, label %if.then74, label %if.else76

if.then74:                                        ; preds = %if.else
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %73, i32 0, i32 0
  store i32 3, i32* %type75, align 8
  br label %if.end77

if.else76:                                        ; preds = %if.else
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = bitcast %struct.bpf_verifier_env* %74 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %75, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.367, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end77:                                         ; preds = %if.then74
  br label %if.end78

if.end78:                                         ; preds = %if.end77, %if.end67
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end78, %if.else76, %sw.epilog, %sw.default, %if.then20, %if.then11, %if.then6, %if.then
  %76 = load i32, i32* %retval, align 4
  ret i32 %76
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %spin_lock_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 8
  %1 = load i32, i32* %spin_lock_off, align 4
  %cmp = icmp sge i32 %1, 0
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_access_skb(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 1, label %sw.bb
    i32 3, label %sw.bb
    i32 4, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load i32, i32* %regno.addr, align 4
  %cmp = icmp uge i32 %0, 11
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %1, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body7

do.body7:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body7
  br label %do.body8

do.body8:                                         ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1464, i32 2305, i64 12) #10, !srcloc !45
  br label %do.end9

do.end9:                                          ; preds = %do.body8
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 412) #10, !srcloc !46
  br label %do.body10

do.body10:                                        ; preds = %do.end9
  br label %do.end11

do.end11:                                         ; preds = %do.body10
  br label %do.end12

do.end12:                                         ; preds = %do.end11
  br label %if.end

if.end:                                           ; preds = %do.end12, %entry
  %2 = load i32, i32* %__ret_warn_on, align 4
  %tobool13 = icmp ne i32 %2, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  store i64 %conv18, i64* %tmp, align 8
  %3 = load i64, i64* %tmp, align 8
  %tobool19 = icmp ne i64 %3, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.91, i64 0, i64 0), i32 noundef %6) #11
  store i32 0, i32* %regno.addr, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then20
  %7 = load i32, i32* %regno.addr, align 4
  %cmp21 = icmp ult i32 %7, 10
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %10 = load i32, i32* %regno.addr, align 4
  %idx.ext = zext i32 %10 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i64 %idx.ext
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %add.ptr) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %regno.addr, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %regno.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %return

if.end23:                                         ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %14 = load i32, i32* %regno.addr, align 4
  %idx.ext24 = zext i32 %14 to i64
  %add.ptr25 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i64 %idx.ext24
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %12, %struct.bpf_reg_state* noundef %add.ptr25) #11
  br label %return

return:                                           ; preds = %if.end23, %for.end
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %0, %struct.bpf_reg_state* noundef %1) #11
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  store i32 0, i32* %type, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 14
  %1 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool = trunc i8 %1 to i1
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %2, i32 noundef %3) #11
  %call1 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext %tobool, %struct.bpf_reg_state* noundef %call) #11
  ret i1 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call i32 @__mark_chain_precision(%struct.bpf_verifier_env* noundef %0, i32 noundef %1, i32 noundef -1) #11
  ret i32 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_verifier_state* @push_stack(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %prev_insn_idx, i1 noundef zeroext %speculative) #0 {
entry:
  %retval = alloca %struct.bpf_verifier_state*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %prev_insn_idx.addr = alloca i32, align 4
  %speculative.addr = alloca i8, align 1
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %elem = alloca %struct.bpf_verifier_stack_elem*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %prev_insn_idx, i32* %prev_insn_idx.addr, align 4
  %frombool = zext i1 %speculative to i8
  store i8 %frombool, i8* %speculative.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %call = call i8* @kzalloc(i64 noundef 144, i32 noundef 3264) #11
  %2 = bitcast i8* %call to %struct.bpf_verifier_stack_elem*
  store %struct.bpf_verifier_stack_elem* %2, %struct.bpf_verifier_stack_elem** %elem, align 8
  %3 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %tobool = icmp ne %struct.bpf_verifier_stack_elem* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %err28

if.end:                                           ; preds = %entry
  %4 = load i32, i32* %insn_idx.addr, align 4
  %5 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %insn_idx1 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %5, i32 0, i32 1
  store i32 %4, i32* %insn_idx1, align 8
  %6 = load i32, i32* %prev_insn_idx.addr, align 4
  %7 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %prev_insn_idx2 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %7, i32 0, i32 2
  store i32 %6, i32* %prev_insn_idx2, align 4
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 4
  %9 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %head, align 8
  %10 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %next = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %10, i32 0, i32 3
  store %struct.bpf_verifier_stack_elem* %9, %struct.bpf_verifier_stack_elem** %next, align 8
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 22
  %len_used = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 3
  %12 = load i32, i32* %len_used, align 8
  %13 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %log_pos = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %13, i32 0, i32 4
  store i32 %12, i32* %log_pos, align 8
  %14 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %head3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 4
  store %struct.bpf_verifier_stack_elem* %14, %struct.bpf_verifier_stack_elem** %head3, align 8
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 5
  %17 = load i32, i32* %stack_size, align 8
  %inc = add i32 %17, 1
  store i32 %inc, i32* %stack_size, align 8
  %18 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %18, i32 0, i32 0
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %call4 = call i32 @copy_verifier_state(%struct.bpf_verifier_state* noundef %st, %struct.bpf_verifier_state* noundef %19) #11
  store i32 %call4, i32* %err, align 4
  %20 = load i32, i32* %err, align 4
  %tobool5 = icmp ne i32 %20, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  br label %err28

if.end7:                                          ; preds = %if.end
  %21 = load i8, i8* %speculative.addr, align 1
  %tobool8 = trunc i8 %21 to i1
  %conv = zext i1 %tobool8 to i32
  %22 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st9 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %22, i32 0, i32 0
  %speculative10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st9, i32 0, i32 6
  %23 = load i8, i8* %speculative10, align 8
  %tobool11 = trunc i8 %23 to i1
  %conv12 = zext i1 %tobool11 to i32
  %or = or i32 %conv12, %conv
  %tobool13 = icmp ne i32 %or, 0
  %frombool14 = zext i1 %tobool13 to i8
  store i8 %frombool14, i8* %speculative10, align 8
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size15 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %24, i32 0, i32 5
  %25 = load i32, i32* %stack_size15, align 8
  %cmp = icmp sgt i32 %25, 8192
  br i1 %cmp, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end7
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %stack_size18 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %28, i32 0, i32 5
  %29 = load i32, i32* %stack_size18, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.192, i64 0, i64 0), i32 noundef %29) #11
  br label %err28

if.end19:                                         ; preds = %if.end7
  %30 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st20 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %30, i32 0, i32 0
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st20, i32 0, i32 1
  %31 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  %tobool21 = icmp ne %struct.bpf_verifier_state* %31, null
  br i1 %tobool21, label %if.then22, label %if.end26

if.then22:                                        ; preds = %if.end19
  %32 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st23 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %32, i32 0, i32 0
  %parent24 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %st23, i32 0, i32 1
  %33 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent24, align 8
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %33, i32 0, i32 2
  %34 = load i32, i32* %branches, align 8
  %inc25 = add i32 %34, 1
  store i32 %inc25, i32* %branches, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then22, %if.end19
  %35 = load %struct.bpf_verifier_stack_elem*, %struct.bpf_verifier_stack_elem** %elem, align 8
  %st27 = getelementptr inbounds %struct.bpf_verifier_stack_elem, %struct.bpf_verifier_stack_elem* %35, i32 0, i32 0
  store %struct.bpf_verifier_state* %st27, %struct.bpf_verifier_state** %retval, align 8
  br label %return

err28:                                            ; preds = %if.then17, %if.then6, %if.then
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %36, i32 0, i32 8
  %37 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state29, align 8
  call void @free_verifier_state(%struct.bpf_verifier_state* noundef %37, i1 noundef zeroext true) #11
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state30 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %38, i32 0, i32 8
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %cur_state30, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %err28
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call31 = call i32 @pop_stack(%struct.bpf_verifier_env* noundef %39, i32* noundef null, i32* noundef null, i1 noundef zeroext false) #11
  %tobool32 = icmp ne i32 %call31, 0
  %lnot = xor i1 %tobool32, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store %struct.bpf_verifier_state* null, %struct.bpf_verifier_state** %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.end26
  %40 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %retval, align 8
  ret %struct.bpf_verifier_state* %40
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @find_equal_scalars(%struct.bpf_verifier_state* noundef %vstate, %struct.bpf_reg_state* noundef %known_reg) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %known_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_reg_state* %known_reg, %struct.bpf_reg_state** %known_reg.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc61, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end63

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 0
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %6 = load i32, i32* %j, align 4
  %cmp2 = icmp slt i32 %6, 11
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 0
  %8 = load i32, i32* %j, align 4
  %idxprom4 = sext i32 %8 to i64
  %arrayidx5 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom4
  store %struct.bpf_reg_state* %arrayidx5, %struct.bpf_reg_state** %reg, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 0
  %10 = load i32, i32* %type, align 8
  %cmp6 = icmp eq i32 %10, 1
  br i1 %cmp6, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body3
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 3
  %12 = load i32, i32* %id, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %known_reg.addr, align 8
  %id7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 3
  %14 = load i32, i32* %id7, align 4
  %cmp8 = icmp eq i32 %12, %14
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %known_reg.addr, align 8
  %17 = bitcast %struct.bpf_reg_state* %15 to i8*
  %18 = bitcast %struct.bpf_reg_state* %16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %17, i8* align 8 %18, i64 120, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body3
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %19 = load i32, i32* %j, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  store i32 0, i32* %j, align 4
  %20 = load i32, i32* %j, align 4
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 6
  %22 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %22, 8
  %cmp9 = icmp slt i32 %20, %div
  br i1 %cmp9, label %land.lhs.true10, label %cond.false

land.lhs.true10:                                  ; preds = %for.end
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 7
  %24 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %25 = load i32, i32* %j, align 4
  %idxprom11 = sext i32 %25 to i64
  %arrayidx12 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %24, i64 %idxprom11
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx12, i32 0, i32 1
  %arrayidx13 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %26 = load i8, i8* %arrayidx13, align 8
  %conv = zext i8 %26 to i32
  %cmp14 = icmp eq i32 %conv, 1
  br i1 %cmp14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true10
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack16 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 7
  %28 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack16, align 8
  %29 = load i32, i32* %j, align 4
  %idxprom17 = sext i32 %29 to i64
  %arrayidx18 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %28, i64 %idxprom17
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx18, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true10, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond19

for.cond19:                                       ; preds = %cond.end58, %cond.end
  %30 = load i32, i32* %j, align 4
  %31 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack20 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %31, i32 0, i32 6
  %32 = load i32, i32* %allocated_stack20, align 8
  %div21 = sdiv i32 %32, 8
  %cmp22 = icmp slt i32 %30, %div21
  br i1 %cmp22, label %for.body24, label %for.end60

for.body24:                                       ; preds = %for.cond19
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %33, null
  br i1 %tobool, label %if.end26, label %if.then25

if.then25:                                        ; preds = %for.body24
  br label %for.inc37

if.end26:                                         ; preds = %for.body24
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 0
  %35 = load i32, i32* %type27, align 8
  %cmp28 = icmp eq i32 %35, 1
  br i1 %cmp28, label %land.lhs.true30, label %if.end36

land.lhs.true30:                                  ; preds = %if.end26
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id31 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 3
  %37 = load i32, i32* %id31, align 4
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %known_reg.addr, align 8
  %id32 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 3
  %39 = load i32, i32* %id32, align 4
  %cmp33 = icmp eq i32 %37, %39
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %land.lhs.true30
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %known_reg.addr, align 8
  %42 = bitcast %struct.bpf_reg_state* %40 to i8*
  %43 = bitcast %struct.bpf_reg_state* %41 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %42, i8* align 8 %43, i64 120, i1 false)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %land.lhs.true30, %if.end26
  br label %for.inc37

for.inc37:                                        ; preds = %if.end36, %if.then25
  %44 = load i32, i32* %j, align 4
  %inc38 = add i32 %44, 1
  store i32 %inc38, i32* %j, align 4
  %45 = load i32, i32* %j, align 4
  %46 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack39 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %46, i32 0, i32 6
  %47 = load i32, i32* %allocated_stack39, align 8
  %div40 = sdiv i32 %47, 8
  %cmp41 = icmp slt i32 %45, %div40
  br i1 %cmp41, label %land.lhs.true43, label %cond.false57

land.lhs.true43:                                  ; preds = %for.inc37
  %48 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack44 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %48, i32 0, i32 7
  %49 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack44, align 8
  %50 = load i32, i32* %j, align 4
  %idxprom45 = sext i32 %50 to i64
  %arrayidx46 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %49, i64 %idxprom45
  %slot_type47 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx46, i32 0, i32 1
  %arrayidx48 = getelementptr [8 x i8], [8 x i8]* %slot_type47, i64 0, i64 0
  %51 = load i8, i8* %arrayidx48, align 8
  %conv49 = zext i8 %51 to i32
  %cmp50 = icmp eq i32 %conv49, 1
  br i1 %cmp50, label %cond.true52, label %cond.false57

cond.true52:                                      ; preds = %land.lhs.true43
  %52 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack53 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %52, i32 0, i32 7
  %53 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack53, align 8
  %54 = load i32, i32* %j, align 4
  %idxprom54 = sext i32 %54 to i64
  %arrayidx55 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %53, i64 %idxprom54
  %spilled_ptr56 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx55, i32 0, i32 0
  br label %cond.end58

cond.false57:                                     ; preds = %land.lhs.true43, %for.inc37
  br label %cond.end58

cond.end58:                                       ; preds = %cond.false57, %cond.true52
  %cond59 = phi %struct.bpf_reg_state* [ %spilled_ptr56, %cond.true52 ], [ null, %cond.false57 ]
  store %struct.bpf_reg_state* %cond59, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond19

for.end60:                                        ; preds = %for.cond19
  br label %for.inc61

for.inc61:                                        ; preds = %for.end60
  %55 = load i32, i32* %i, align 4
  %inc62 = add i32 %55, 1
  store i32 %inc62, i32* %i, align 4
  br label %for.cond

for.end63:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_may_be_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 5
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 12
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 14
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp5 = icmp eq i32 %3, 16
  br i1 %cmp5, label %lor.end, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %4 = load i32, i32* %type.addr, align 4
  %cmp7 = icmp eq i32 %4, 20
  br i1 %cmp7, label %lor.end, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %5 = load i32, i32* %type.addr, align 4
  %cmp9 = icmp eq i32 %5, 22
  br i1 %cmp9, label %lor.end, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %lor.lhs.false8
  %6 = load i32, i32* %type.addr, align 4
  %cmp11 = icmp eq i32 %6, 24
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false10
  %7 = load i32, i32* %type.addr, align 4
  %cmp12 = icmp eq i32 %7, 26
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false10, %lor.lhs.false8, %lor.lhs.false6, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %8 = phi i1 [ true, %lor.lhs.false10 ], [ true, %lor.lhs.false8 ], [ true, %lor.lhs.false6 ], [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp12, %lor.rhs ]
  ret i1 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_ptr_or_null_regs(%struct.bpf_verifier_state* noundef %vstate, i32 noundef %regno, i1 noundef zeroext %is_null) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %regno.addr = alloca i32, align 4
  %is_null.addr = alloca i8, align 1
  %state = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %ref_obj_id = alloca i32, align 4
  %id = alloca i32, align 4
  %i = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %frombool = zext i1 %is_null to i8
  store i8 %frombool, i8* %is_null.addr, align 1
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %3, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %6 = load i32, i32* %regno.addr, align 4
  %idxprom2 = zext i32 %6 to i64
  %arrayidx3 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i64 %idxprom2
  %ref_obj_id4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx3, i32 0, i32 4
  %7 = load i32, i32* %ref_obj_id4, align 8
  store i32 %7, i32* %ref_obj_id, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %9 = load i32, i32* %regno.addr, align 4
  %idxprom5 = zext i32 %9 to i64
  %arrayidx6 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i64 %idxprom5
  %id7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx6, i32 0, i32 3
  %10 = load i32, i32* %id7, align 4
  store i32 %10, i32* %id, align 4
  %11 = load i32, i32* %ref_obj_id, align 4
  %tobool = icmp ne i32 %11, 0
  br i1 %tobool, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %entry
  %12 = load i32, i32* %ref_obj_id, align 4
  %13 = load i32, i32* %id, align 4
  %cmp = icmp eq i32 %12, %13
  br i1 %cmp, label %land.lhs.true8, label %if.end31

land.lhs.true8:                                   ; preds = %land.lhs.true
  %14 = load i8, i8* %is_null.addr, align 1
  %tobool9 = trunc i8 %14 to i1
  br i1 %tobool9, label %if.then, label %if.end31

if.then:                                          ; preds = %land.lhs.true8
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %16 = load i32, i32* %id, align 4
  %call = call i32 @release_reference_state(%struct.bpf_func_state* noundef %15, i32 noundef %16) #11
  %tobool10 = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %17 = load i32, i32* %__ret_warn_on, align 4
  %tobool12 = icmp ne i32 %17, 0
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv = sext i32 %lnot.ext16 to i64
  %tobool17 = icmp ne i64 %conv, 0
  br i1 %tobool17, label %if.then18, label %if.end

if.then18:                                        ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then18
  br label %do.body19

do.body19:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body19
  br label %do.body20

do.body20:                                        ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 7616, i32 2307, i64 12) #10, !srcloc !47
  br label %do.end21

do.end21:                                         ; preds = %do.body20
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 482) #10, !srcloc !48
  br label %do.body22

do.body22:                                        ; preds = %do.end21
  br label %do.end23

do.end23:                                         ; preds = %do.body22
  br label %do.end24

do.end24:                                         ; preds = %do.end23
  br label %if.end

if.end:                                           ; preds = %do.end24, %if.then
  %18 = load i32, i32* %__ret_warn_on, align 4
  %tobool25 = icmp ne i32 %18, 0
  %lnot26 = xor i1 %tobool25, true
  %lnot28 = xor i1 %lnot26, true
  %lnot.ext29 = zext i1 %lnot28 to i32
  %conv30 = sext i32 %lnot.ext29 to i64
  store i64 %conv30, i64* %tmp, align 8
  %19 = load i64, i64* %tmp, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.end, %land.lhs.true8, %land.lhs.true, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end31
  %20 = load i32, i32* %i, align 4
  %21 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe32 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %21, i32 0, i32 4
  %22 = load i32, i32* %curframe32, align 8
  %cmp33 = icmp ule i32 %20, %22
  br i1 %cmp33, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame35 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 0
  %24 = load i32, i32* %i, align 4
  %idxprom36 = sext i32 %24 to i64
  %arrayidx37 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame35, i64 0, i64 %idxprom36
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx37, align 8
  %26 = load i32, i32* %id, align 4
  %27 = load i8, i8* %is_null.addr, align 1
  %tobool38 = trunc i8 %27 to i1
  call void @__mark_ptr_or_null_regs(%struct.bpf_func_state* noundef %25, i32 noundef %26, i1 noundef zeroext %tobool38) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %28 = load i32, i32* %i, align 4
  %inc = add i32 %28, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @try_match_pkt_pointers(%struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %dst_reg, %struct.bpf_reg_state* noundef %src_reg, %struct.bpf_verifier_state* noundef %this_branch, %struct.bpf_verifier_state* noundef %other_branch) #0 {
entry:
  %retval = alloca i1, align 1
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %src_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %this_branch.addr = alloca %struct.bpf_verifier_state*, align 8
  %other_branch.addr = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store %struct.bpf_reg_state* %src_reg, %struct.bpf_reg_state** %src_reg.addr, align 8
  store %struct.bpf_verifier_state* %this_branch, %struct.bpf_verifier_state** %this_branch.addr, align 8
  store %struct.bpf_verifier_state* %other_branch, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 0
  %1 = load i8, i8* %code, align 4
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 8
  %cmp = icmp ne i32 %and, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %2, i32 0, i32 0
  %3 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %3 to i32
  %and4 = and i32 %conv3, 7
  %cmp5 = icmp eq i32 %and4, 6
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  store i1 false, i1* %retval, align 1
  br label %return

if.end8:                                          ; preds = %if.end
  %4 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code9 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %4, i32 0, i32 0
  %5 = load i8, i8* %code9, align 4
  %conv10 = zext i8 %5 to i32
  %and11 = and i32 %conv10, 240
  switch i32 %and11, label %sw.default [
    i32 32, label %sw.bb
    i32 160, label %sw.bb43
    i32 48, label %sw.bb80
    i32 176, label %sw.bb117
  ]

sw.bb:                                            ; preds = %if.end8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp12 = icmp eq i32 %7, 8
  br i1 %cmp12, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %sw.bb
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 0
  %9 = load i32, i32* %type14, align 8
  %cmp15 = icmp eq i32 %9, 9
  br i1 %cmp15, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %sw.bb
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 0
  %11 = load i32, i32* %type17, align 8
  %cmp18 = icmp eq i32 %11, 7
  br i1 %cmp18, label %land.lhs.true20, label %if.else

land.lhs.true20:                                  ; preds = %lor.lhs.false
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %12, i32 noundef 8) #11
  br i1 %call, label %if.then22, label %if.else

if.then22:                                        ; preds = %land.lhs.true20, %land.lhs.true
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type23, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %13, %struct.bpf_reg_state* noundef %14, i32 noundef %16, i1 noundef zeroext false) #11
  br label %if.end42

if.else:                                          ; preds = %land.lhs.true20, %lor.lhs.false
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 0
  %18 = load i32, i32* %type24, align 8
  %cmp25 = icmp eq i32 %18, 9
  br i1 %cmp25, label %land.lhs.true27, label %lor.lhs.false31

land.lhs.true27:                                  ; preds = %if.else
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type28, align 8
  %cmp29 = icmp eq i32 %20, 8
  br i1 %cmp29, label %if.then38, label %lor.lhs.false31

lor.lhs.false31:                                  ; preds = %land.lhs.true27, %if.else
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call32 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %21, i32 noundef 8) #11
  br i1 %call32, label %land.lhs.true34, label %if.else40

land.lhs.true34:                                  ; preds = %lor.lhs.false31
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type35 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 0
  %23 = load i32, i32* %type35, align 8
  %cmp36 = icmp eq i32 %23, 7
  br i1 %cmp36, label %if.then38, label %if.else40

if.then38:                                        ; preds = %land.lhs.true34, %land.lhs.true27
  %24 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type39 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 0
  %27 = load i32, i32* %type39, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %24, %struct.bpf_reg_state* noundef %25, i32 noundef %27, i1 noundef zeroext true) #11
  br label %if.end41

if.else40:                                        ; preds = %land.lhs.true34, %lor.lhs.false31
  store i1 false, i1* %retval, align 1
  br label %return

if.end41:                                         ; preds = %if.then38
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.then22
  br label %sw.epilog

sw.bb43:                                          ; preds = %if.end8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 0
  %29 = load i32, i32* %type44, align 8
  %cmp45 = icmp eq i32 %29, 8
  br i1 %cmp45, label %land.lhs.true47, label %lor.lhs.false51

land.lhs.true47:                                  ; preds = %sw.bb43
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type48 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 0
  %31 = load i32, i32* %type48, align 8
  %cmp49 = icmp eq i32 %31, 9
  br i1 %cmp49, label %if.then58, label %lor.lhs.false51

lor.lhs.false51:                                  ; preds = %land.lhs.true47, %sw.bb43
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type52 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 0
  %33 = load i32, i32* %type52, align 8
  %cmp53 = icmp eq i32 %33, 7
  br i1 %cmp53, label %land.lhs.true55, label %if.else60

land.lhs.true55:                                  ; preds = %lor.lhs.false51
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call56 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %34, i32 noundef 8) #11
  br i1 %call56, label %if.then58, label %if.else60

if.then58:                                        ; preds = %land.lhs.true55, %land.lhs.true47
  %35 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 0
  %38 = load i32, i32* %type59, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %35, %struct.bpf_reg_state* noundef %36, i32 noundef %38, i1 noundef zeroext true) #11
  br label %if.end79

if.else60:                                        ; preds = %land.lhs.true55, %lor.lhs.false51
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type61 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 0
  %40 = load i32, i32* %type61, align 8
  %cmp62 = icmp eq i32 %40, 9
  br i1 %cmp62, label %land.lhs.true64, label %lor.lhs.false68

land.lhs.true64:                                  ; preds = %if.else60
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 0
  %42 = load i32, i32* %type65, align 8
  %cmp66 = icmp eq i32 %42, 8
  br i1 %cmp66, label %if.then75, label %lor.lhs.false68

lor.lhs.false68:                                  ; preds = %land.lhs.true64, %if.else60
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call69 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %43, i32 noundef 8) #11
  br i1 %call69, label %land.lhs.true71, label %if.else77

land.lhs.true71:                                  ; preds = %lor.lhs.false68
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type72 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 0
  %45 = load i32, i32* %type72, align 8
  %cmp73 = icmp eq i32 %45, 7
  br i1 %cmp73, label %if.then75, label %if.else77

if.then75:                                        ; preds = %land.lhs.true71, %land.lhs.true64
  %46 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type76 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 0
  %49 = load i32, i32* %type76, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %46, %struct.bpf_reg_state* noundef %47, i32 noundef %49, i1 noundef zeroext false) #11
  br label %if.end78

if.else77:                                        ; preds = %land.lhs.true71, %lor.lhs.false68
  store i1 false, i1* %retval, align 1
  br label %return

if.end78:                                         ; preds = %if.then75
  br label %if.end79

if.end79:                                         ; preds = %if.end78, %if.then58
  br label %sw.epilog

sw.bb80:                                          ; preds = %if.end8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 0
  %51 = load i32, i32* %type81, align 8
  %cmp82 = icmp eq i32 %51, 8
  br i1 %cmp82, label %land.lhs.true84, label %lor.lhs.false88

land.lhs.true84:                                  ; preds = %sw.bb80
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type85 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 0
  %53 = load i32, i32* %type85, align 8
  %cmp86 = icmp eq i32 %53, 9
  br i1 %cmp86, label %if.then95, label %lor.lhs.false88

lor.lhs.false88:                                  ; preds = %land.lhs.true84, %sw.bb80
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type89 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 0
  %55 = load i32, i32* %type89, align 8
  %cmp90 = icmp eq i32 %55, 7
  br i1 %cmp90, label %land.lhs.true92, label %if.else97

land.lhs.true92:                                  ; preds = %lor.lhs.false88
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call93 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %56, i32 noundef 8) #11
  br i1 %call93, label %if.then95, label %if.else97

if.then95:                                        ; preds = %land.lhs.true92, %land.lhs.true84
  %57 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type96 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 0
  %60 = load i32, i32* %type96, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %57, %struct.bpf_reg_state* noundef %58, i32 noundef %60, i1 noundef zeroext true) #11
  br label %if.end116

if.else97:                                        ; preds = %land.lhs.true92, %lor.lhs.false88
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type98 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 0
  %62 = load i32, i32* %type98, align 8
  %cmp99 = icmp eq i32 %62, 9
  br i1 %cmp99, label %land.lhs.true101, label %lor.lhs.false105

land.lhs.true101:                                 ; preds = %if.else97
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type102 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %63, i32 0, i32 0
  %64 = load i32, i32* %type102, align 8
  %cmp103 = icmp eq i32 %64, 8
  br i1 %cmp103, label %if.then112, label %lor.lhs.false105

lor.lhs.false105:                                 ; preds = %land.lhs.true101, %if.else97
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call106 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %65, i32 noundef 8) #11
  br i1 %call106, label %land.lhs.true108, label %if.else114

land.lhs.true108:                                 ; preds = %lor.lhs.false105
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %67, 7
  br i1 %cmp110, label %if.then112, label %if.else114

if.then112:                                       ; preds = %land.lhs.true108, %land.lhs.true101
  %68 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type113 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 0
  %71 = load i32, i32* %type113, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %68, %struct.bpf_reg_state* noundef %69, i32 noundef %71, i1 noundef zeroext false) #11
  br label %if.end115

if.else114:                                       ; preds = %land.lhs.true108, %lor.lhs.false105
  store i1 false, i1* %retval, align 1
  br label %return

if.end115:                                        ; preds = %if.then112
  br label %if.end116

if.end116:                                        ; preds = %if.end115, %if.then95
  br label %sw.epilog

sw.bb117:                                         ; preds = %if.end8
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type118 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 0
  %73 = load i32, i32* %type118, align 8
  %cmp119 = icmp eq i32 %73, 8
  br i1 %cmp119, label %land.lhs.true121, label %lor.lhs.false125

land.lhs.true121:                                 ; preds = %sw.bb117
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type122 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 0
  %75 = load i32, i32* %type122, align 8
  %cmp123 = icmp eq i32 %75, 9
  br i1 %cmp123, label %if.then132, label %lor.lhs.false125

lor.lhs.false125:                                 ; preds = %land.lhs.true121, %sw.bb117
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type126 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %76, i32 0, i32 0
  %77 = load i32, i32* %type126, align 8
  %cmp127 = icmp eq i32 %77, 7
  br i1 %cmp127, label %land.lhs.true129, label %if.else134

land.lhs.true129:                                 ; preds = %lor.lhs.false125
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %call130 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %78, i32 noundef 8) #11
  br i1 %call130, label %if.then132, label %if.else134

if.then132:                                       ; preds = %land.lhs.true129, %land.lhs.true121
  %79 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %other_branch.addr, align 8
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type133 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %81, i32 0, i32 0
  %82 = load i32, i32* %type133, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %79, %struct.bpf_reg_state* noundef %80, i32 noundef %82, i1 noundef zeroext false) #11
  br label %if.end153

if.else134:                                       ; preds = %land.lhs.true129, %lor.lhs.false125
  %83 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %type135 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %83, i32 0, i32 0
  %84 = load i32, i32* %type135, align 8
  %cmp136 = icmp eq i32 %84, 9
  br i1 %cmp136, label %land.lhs.true138, label %lor.lhs.false142

land.lhs.true138:                                 ; preds = %if.else134
  %85 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type139 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %85, i32 0, i32 0
  %86 = load i32, i32* %type139, align 8
  %cmp140 = icmp eq i32 %86, 8
  br i1 %cmp140, label %if.then149, label %lor.lhs.false142

lor.lhs.false142:                                 ; preds = %land.lhs.true138, %if.else134
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %call143 = call zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %87, i32 noundef 8) #11
  br i1 %call143, label %land.lhs.true145, label %if.else151

land.lhs.true145:                                 ; preds = %lor.lhs.false142
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type146 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 0
  %89 = load i32, i32* %type146, align 8
  %cmp147 = icmp eq i32 %89, 7
  br i1 %cmp147, label %if.then149, label %if.else151

if.then149:                                       ; preds = %land.lhs.true145, %land.lhs.true138
  %90 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %this_branch.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg.addr, align 8
  %type150 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 0
  %93 = load i32, i32* %type150, align 8
  call void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %90, %struct.bpf_reg_state* noundef %91, i32 noundef %93, i1 noundef zeroext true) #11
  br label %if.end152

if.else151:                                       ; preds = %land.lhs.true145, %lor.lhs.false142
  store i1 false, i1* %retval, align 1
  br label %return

if.end152:                                        ; preds = %if.then149
  br label %if.end153

if.end153:                                        ; preds = %if.end152, %if.then132
  br label %sw.epilog

sw.default:                                       ; preds = %if.end8
  store i1 false, i1* %retval, align 1
  br label %return

sw.epilog:                                        ; preds = %if.end153, %if.end116, %if.end79, %if.end42
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %if.else151, %if.else114, %if.else77, %if.else40, %if.then7, %if.then
  %94 = load i1, i1* %retval, align 1
  ret i1 %94
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_is_init_pkt_pointer(%struct.bpf_reg_state* noundef %reg, i32 noundef %which) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %which.addr = alloca i32, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %which, i32* %which.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %2 = load i32, i32* %which.addr, align 4
  %cmp = icmp eq i32 %1, %2
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 3
  %4 = load i32, i32* %id, align 4
  %cmp1 = icmp eq i32 %4, 0
  br i1 %cmp1, label %land.lhs.true2, label %land.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 2
  %6 = load i32, i32* %off, align 8
  %cmp3 = icmp eq i32 %6, 0
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true2
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_equals_const(i64 %10, i64 %12, i64 noundef 0) #11
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true2, %land.lhs.true, %entry
  %13 = phi i1 [ false, %land.lhs.true2 ], [ false, %land.lhs.true ], [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %13
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @find_good_pkt_pointers(%struct.bpf_verifier_state* noundef %vstate, %struct.bpf_reg_state* noundef %dst_reg, i32 noundef %type, i1 noundef zeroext %range_right_open) #0 {
entry:
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %type.addr = alloca i32, align 4
  %range_right_open.addr = alloca i8, align 1
  %new_range = alloca i16, align 2
  %i = alloca i32, align 4
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %frombool = zext i1 %range_right_open to i8
  store i8 %frombool, i8* %range_right_open.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 2
  %1 = load i32, i32* %off, align 8
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 2
  %3 = load i32, i32* %off1, align 8
  %cmp2 = icmp eq i32 %3, 0
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %4 = load i8, i8* %range_right_open.addr, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %entry
  br label %for.end

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 9
  %6 = load i64, i64* %umax_value, align 8
  %cmp3 = icmp ugt i64 %6, 65535
  br i1 %cmp3, label %if.then9, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %umax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 9
  %8 = load i64, i64* %umax_value5, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 2
  %10 = load i32, i32* %off6, align 8
  %conv = sext i32 %10 to i64
  %add = add i64 %8, %conv
  %cmp7 = icmp ugt i64 %add, 65535
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %lor.lhs.false4, %if.end
  br label %for.end

if.end10:                                         ; preds = %lor.lhs.false4
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %off11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 2
  %12 = load i32, i32* %off11, align 8
  %conv12 = trunc i32 %12 to i16
  store i16 %conv12, i16* %new_range, align 2
  %13 = load i8, i8* %range_right_open.addr, align 1
  %tobool13 = trunc i8 %13 to i1
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end10
  %14 = load i16, i16* %new_range, align 2
  %dec = add i16 %14, -1
  store i16 %dec, i16* %new_range, align 2
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end10
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end15
  %15 = load i32, i32* %i, align 4
  %16 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %16, i32 0, i32 4
  %17 = load i32, i32* %curframe, align 8
  %cmp16 = icmp ule i32 %15, %17
  br i1 %cmp16, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 0
  %19 = load i32, i32* %i, align 4
  %idxprom = sext i32 %19 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %22 = load i32, i32* %type.addr, align 4
  %23 = load i16, i16* %new_range, align 2
  call void @__find_good_pkt_pointers(%struct.bpf_func_state* noundef %20, %struct.bpf_reg_state* noundef %21, i32 noundef %22, i16 noundef zeroext %23) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %24 = load i32, i32* %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then9, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__find_good_pkt_pointers(%struct.bpf_func_state* noundef %state, %struct.bpf_reg_state* noundef %dst_reg, i32 noundef %type, i16 noundef zeroext %new_range) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %type.addr = alloca i32, align 4
  %new_range.addr = alloca i16, align 2
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  %__UNIQUE_ID___x436 = alloca i16, align 2
  %__UNIQUE_ID___y437 = alloca i16, align 2
  %tmp = alloca i32, align 4
  %__UNIQUE_ID___x438 = alloca i16, align 2
  %__UNIQUE_ID___y439 = alloca i16, align 2
  %tmp46 = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  store i16 %new_range, i16* %new_range.addr, align 2
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %2 = load i32, i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type1, align 8
  %5 = load i32, i32* %type.addr, align 4
  %cmp2 = icmp eq i32 %4, %5
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 3
  %7 = load i32, i32* %id, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %id3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 3
  %9 = load i32, i32* %id3, align 4
  %cmp4 = icmp eq i32 %7, %9
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 1
  %range = bitcast %struct.bpf_iter_aux_info* %11 to i16*
  %12 = load i16, i16* %range, align 8
  store i16 %12, i16* %__UNIQUE_ID___x436, align 2
  %13 = load i16, i16* %new_range.addr, align 2
  store i16 %13, i16* %__UNIQUE_ID___y437, align 2
  %14 = load i16, i16* %__UNIQUE_ID___x436, align 2
  %conv = zext i16 %14 to i32
  %15 = load i16, i16* %__UNIQUE_ID___y437, align 2
  %conv5 = zext i16 %15 to i32
  %cmp6 = icmp sgt i32 %conv, %conv5
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %16 = load i16, i16* %__UNIQUE_ID___x436, align 2
  %conv8 = zext i16 %16 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %17 = load i16, i16* %__UNIQUE_ID___y437, align 2
  %conv9 = zext i16 %17 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv8, %cond.true ], [ %conv9, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %18 = load i32, i32* %tmp, align 4
  %conv10 = trunc i32 %18 to i16
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 1
  %range11 = bitcast %struct.bpf_iter_aux_info* %20 to i16*
  store i16 %conv10, i16* %range11, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %21 = load i32, i32* %i, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %22 = load i32, i32* %i, align 4
  %23 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %23, i32 0, i32 6
  %24 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %24, 8
  %cmp12 = icmp slt i32 %22, %div
  br i1 %cmp12, label %land.lhs.true14, label %cond.false25

land.lhs.true14:                                  ; preds = %for.end
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 7
  %26 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %27 = load i32, i32* %i, align 4
  %idxprom15 = sext i32 %27 to i64
  %arrayidx16 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %26, i64 %idxprom15
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx16, i32 0, i32 1
  %arrayidx17 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %28 = load i8, i8* %arrayidx17, align 8
  %conv18 = zext i8 %28 to i32
  %cmp19 = icmp eq i32 %conv18, 1
  br i1 %cmp19, label %cond.true21, label %cond.false25

cond.true21:                                      ; preds = %land.lhs.true14
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack22 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 7
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack22, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom23 = sext i32 %31 to i64
  %arrayidx24 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom23
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx24, i32 0, i32 0
  br label %cond.end26

cond.false25:                                     ; preds = %land.lhs.true14, %for.end
  br label %cond.end26

cond.end26:                                       ; preds = %cond.false25, %cond.true21
  %cond27 = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true21 ], [ null, %cond.false25 ]
  store %struct.bpf_reg_state* %cond27, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond28

for.cond28:                                       ; preds = %cond.end81, %cond.end26
  %32 = load i32, i32* %i, align 4
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack29 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 6
  %34 = load i32, i32* %allocated_stack29, align 8
  %div30 = sdiv i32 %34, 8
  %cmp31 = icmp slt i32 %32, %div30
  br i1 %cmp31, label %for.body33, label %for.end83

for.body33:                                       ; preds = %for.cond28
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %35, null
  br i1 %tobool, label %if.end35, label %if.then34

if.then34:                                        ; preds = %for.body33
  br label %for.inc60

if.end35:                                         ; preds = %for.body33
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type36 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 0
  %37 = load i32, i32* %type36, align 8
  %38 = load i32, i32* %type.addr, align 4
  %cmp37 = icmp eq i32 %37, %38
  br i1 %cmp37, label %land.lhs.true39, label %if.end59

land.lhs.true39:                                  ; preds = %if.end35
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id40 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %39, i32 0, i32 3
  %40 = load i32, i32* %id40, align 4
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %id41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 3
  %42 = load i32, i32* %id41, align 4
  %cmp42 = icmp eq i32 %40, %42
  br i1 %cmp42, label %if.then44, label %if.end59

if.then44:                                        ; preds = %land.lhs.true39
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 1
  %range45 = bitcast %struct.bpf_iter_aux_info* %44 to i16*
  %45 = load i16, i16* %range45, align 8
  store i16 %45, i16* %__UNIQUE_ID___x438, align 2
  %46 = load i16, i16* %new_range.addr, align 2
  store i16 %46, i16* %__UNIQUE_ID___y439, align 2
  %47 = load i16, i16* %__UNIQUE_ID___x438, align 2
  %conv47 = zext i16 %47 to i32
  %48 = load i16, i16* %__UNIQUE_ID___y439, align 2
  %conv48 = zext i16 %48 to i32
  %cmp49 = icmp sgt i32 %conv47, %conv48
  br i1 %cmp49, label %cond.true51, label %cond.false53

cond.true51:                                      ; preds = %if.then44
  %49 = load i16, i16* %__UNIQUE_ID___x438, align 2
  %conv52 = zext i16 %49 to i32
  br label %cond.end55

cond.false53:                                     ; preds = %if.then44
  %50 = load i16, i16* %__UNIQUE_ID___y439, align 2
  %conv54 = zext i16 %50 to i32
  br label %cond.end55

cond.end55:                                       ; preds = %cond.false53, %cond.true51
  %cond56 = phi i32 [ %conv52, %cond.true51 ], [ %conv54, %cond.false53 ]
  store i32 %cond56, i32* %tmp46, align 4
  %51 = load i32, i32* %tmp46, align 4
  %conv57 = trunc i32 %51 to i16
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %53 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 1
  %range58 = bitcast %struct.bpf_iter_aux_info* %53 to i16*
  store i16 %conv57, i16* %range58, align 8
  br label %if.end59

if.end59:                                         ; preds = %cond.end55, %land.lhs.true39, %if.end35
  br label %for.inc60

for.inc60:                                        ; preds = %if.end59, %if.then34
  %54 = load i32, i32* %i, align 4
  %inc61 = add i32 %54, 1
  store i32 %inc61, i32* %i, align 4
  %55 = load i32, i32* %i, align 4
  %56 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack62 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %56, i32 0, i32 6
  %57 = load i32, i32* %allocated_stack62, align 8
  %div63 = sdiv i32 %57, 8
  %cmp64 = icmp slt i32 %55, %div63
  br i1 %cmp64, label %land.lhs.true66, label %cond.false80

land.lhs.true66:                                  ; preds = %for.inc60
  %58 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack67 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %58, i32 0, i32 7
  %59 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack67, align 8
  %60 = load i32, i32* %i, align 4
  %idxprom68 = sext i32 %60 to i64
  %arrayidx69 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %59, i64 %idxprom68
  %slot_type70 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx69, i32 0, i32 1
  %arrayidx71 = getelementptr [8 x i8], [8 x i8]* %slot_type70, i64 0, i64 0
  %61 = load i8, i8* %arrayidx71, align 8
  %conv72 = zext i8 %61 to i32
  %cmp73 = icmp eq i32 %conv72, 1
  br i1 %cmp73, label %cond.true75, label %cond.false80

cond.true75:                                      ; preds = %land.lhs.true66
  %62 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack76 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %62, i32 0, i32 7
  %63 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack76, align 8
  %64 = load i32, i32* %i, align 4
  %idxprom77 = sext i32 %64 to i64
  %arrayidx78 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %63, i64 %idxprom77
  %spilled_ptr79 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx78, i32 0, i32 0
  br label %cond.end81

cond.false80:                                     ; preds = %land.lhs.true66, %for.inc60
  br label %cond.end81

cond.end81:                                       ; preds = %cond.false80, %cond.true75
  %cond82 = phi %struct.bpf_reg_state* [ %spilled_ptr79, %cond.true75 ], [ null, %cond.false80 ]
  store %struct.bpf_reg_state* %cond82, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond28

for.end83:                                        ; preds = %for.cond28
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @release_reference_state(%struct.bpf_func_state* noundef %state, i32 noundef %ptr_id) #0 {
entry:
  %retval = alloca i32, align 4
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %ptr_id.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %last_idx = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %ptr_id, i32* %ptr_id.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 4
  %1 = load i32, i32* %acquired_refs, align 4
  %sub = sub i32 %1, 1
  store i32 %sub, i32* %last_idx, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 4
  %4 = load i32, i32* %acquired_refs1, align 4
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 5
  %6 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %7 = load i32, i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %6, i64 %idxprom
  %id = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 0
  %8 = load i32, i32* %id, align 4
  %9 = load i32, i32* %ptr_id.addr, align 4
  %cmp2 = icmp eq i32 %8, %9
  br i1 %cmp2, label %if.then, label %if.end15

if.then:                                          ; preds = %for.body
  %10 = load i32, i32* %last_idx, align 4
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %11 = load i32, i32* %i, align 4
  %12 = load i32, i32* %last_idx, align 4
  %cmp3 = icmp ne i32 %11, %12
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %land.lhs.true
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 5
  %14 = load %struct.util_est*, %struct.util_est** %refs5, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %15 to i64
  %arrayidx7 = getelementptr %struct.util_est, %struct.util_est* %14, i64 %idxprom6
  %16 = bitcast %struct.util_est* %arrayidx7 to i8*
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs8 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 5
  %18 = load %struct.util_est*, %struct.util_est** %refs8, align 8
  %19 = load i32, i32* %last_idx, align 4
  %idxprom9 = sext i32 %19 to i64
  %arrayidx10 = getelementptr %struct.util_est, %struct.util_est* %18, i64 %idxprom9
  %20 = bitcast %struct.util_est* %arrayidx10 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %16, i8* align 4 %20, i64 8, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then4, %land.lhs.true, %if.then
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %refs11 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 5
  %22 = load %struct.util_est*, %struct.util_est** %refs11, align 8
  %23 = load i32, i32* %last_idx, align 4
  %idxprom12 = sext i32 %23 to i64
  %arrayidx13 = getelementptr %struct.util_est, %struct.util_est* %22, i64 %idxprom12
  %24 = bitcast %struct.util_est* %arrayidx13 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %24, i8 0, i64 8, i1 false)
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 4
  %26 = load i32, i32* %acquired_refs14, align 4
  %dec = add i32 %26, -1
  store i32 %dec, i32* %acquired_refs14, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end15
  %27 = load i32, i32* %i, align 4
  %inc = add i32 %27, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end
  %28 = load i32, i32* %retval, align 4
  ret i32 %28
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_ptr_or_null_regs(%struct.bpf_func_state* noundef %state, i32 noundef %id, i1 noundef zeroext %is_null) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %id.addr = alloca i32, align 4
  %is_null.addr = alloca i8, align 1
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %id, i32* %id.addr, align 4
  %frombool = zext i1 %is_null to i8
  store i8 %frombool, i8* %is_null.addr, align 1
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 0
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %4 = load i32, i32* %id.addr, align 4
  %5 = load i8, i8* %is_null.addr, align 1
  %tobool = trunc i8 %5 to i1
  call void @mark_ptr_or_null_reg(%struct.bpf_func_state* noundef %1, %struct.bpf_reg_state* noundef %arrayidx, i32 noundef %4, i1 noundef zeroext %tobool) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %7 = load i32, i32* %i, align 4
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 6
  %9 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %9, 8
  %cmp1 = icmp slt i32 %7, %div
  br i1 %cmp1, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.end
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 7
  %11 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %12 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %12 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %11, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %arrayidx4 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %13 = load i8, i8* %arrayidx4, align 8
  %conv = zext i8 %13 to i32
  %cmp5 = icmp eq i32 %conv, 1
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %14 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack7 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %14, i32 0, i32 7
  %15 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack7, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom8 = sext i32 %16 to i64
  %arrayidx9 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %15, i64 %idxprom8
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx9, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond10

for.cond10:                                       ; preds = %cond.end39, %cond.end
  %17 = load i32, i32* %i, align 4
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack11 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 6
  %19 = load i32, i32* %allocated_stack11, align 8
  %div12 = sdiv i32 %19, 8
  %cmp13 = icmp slt i32 %17, %div12
  br i1 %cmp13, label %for.body15, label %for.end41

for.body15:                                       ; preds = %for.cond10
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool16 = icmp ne %struct.bpf_reg_state* %20, null
  br i1 %tobool16, label %if.end, label %if.then

if.then:                                          ; preds = %for.body15
  br label %for.inc18

if.end:                                           ; preds = %for.body15
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %23 = load i32, i32* %id.addr, align 4
  %24 = load i8, i8* %is_null.addr, align 1
  %tobool17 = trunc i8 %24 to i1
  call void @mark_ptr_or_null_reg(%struct.bpf_func_state* noundef %21, %struct.bpf_reg_state* noundef %22, i32 noundef %23, i1 noundef zeroext %tobool17) #11
  br label %for.inc18

for.inc18:                                        ; preds = %if.end, %if.then
  %25 = load i32, i32* %i, align 4
  %inc19 = add i32 %25, 1
  store i32 %inc19, i32* %i, align 4
  %26 = load i32, i32* %i, align 4
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack20 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 6
  %28 = load i32, i32* %allocated_stack20, align 8
  %div21 = sdiv i32 %28, 8
  %cmp22 = icmp slt i32 %26, %div21
  br i1 %cmp22, label %land.lhs.true24, label %cond.false38

land.lhs.true24:                                  ; preds = %for.inc18
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack25 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 7
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack25, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %31 to i64
  %arrayidx27 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom26
  %slot_type28 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx27, i32 0, i32 1
  %arrayidx29 = getelementptr [8 x i8], [8 x i8]* %slot_type28, i64 0, i64 0
  %32 = load i8, i8* %arrayidx29, align 8
  %conv30 = zext i8 %32 to i32
  %cmp31 = icmp eq i32 %conv30, 1
  br i1 %cmp31, label %cond.true33, label %cond.false38

cond.true33:                                      ; preds = %land.lhs.true24
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack34 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 7
  %34 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack34, align 8
  %35 = load i32, i32* %i, align 4
  %idxprom35 = sext i32 %35 to i64
  %arrayidx36 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %34, i64 %idxprom35
  %spilled_ptr37 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx36, i32 0, i32 0
  br label %cond.end39

cond.false38:                                     ; preds = %land.lhs.true24, %for.inc18
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true33
  %cond40 = phi %struct.bpf_reg_state* [ %spilled_ptr37, %cond.true33 ], [ null, %cond.false38 ]
  store %struct.bpf_reg_state* %cond40, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond10

for.end41:                                        ; preds = %for.cond10
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_ptr_or_null_reg(%struct.bpf_func_state* noundef %state, %struct.bpf_reg_state* noundef %reg, i32 noundef %id, i1 noundef zeroext %is_null) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %id.addr = alloca i32, align 4
  %is_null.addr = alloca i8, align 1
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_warn_on26 = alloca i32, align 4
  %tmp53 = alloca i64, align 8
  %map = alloca %struct.bpf_map*, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %id, i32* %id.addr, align 4
  %frombool = zext i1 %is_null to i8
  store i8 %frombool, i8* %is_null.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %call = call zeroext i1 @reg_type_may_be_null(i32 noundef %1) #11
  br i1 %call, label %land.lhs.true, label %if.end156

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 3
  %3 = load i32, i32* %id1, align 4
  %4 = load i32, i32* %id.addr, align 4
  %cmp = icmp eq i32 %3, %4
  br i1 %cmp, label %land.lhs.true2, label %if.end156

land.lhs.true2:                                   ; preds = %land.lhs.true
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 3
  %6 = load i32, i32* %id3, align 4
  %tobool = icmp ne i32 %6, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %7 = load i32, i32* %__ret_warn_on, align 4
  %tobool6 = icmp ne i32 %7, 0
  %lnot7 = xor i1 %tobool6, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext10 to i64
  %tobool11 = icmp ne i64 %conv, 0
  br i1 %tobool11, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true2
  br label %do.body

do.body:                                          ; preds = %if.then
  br label %do.body12

do.body12:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body12
  br label %do.body13

do.body13:                                        ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 7522, i32 2307, i64 12) #10, !srcloc !49
  br label %do.end14

do.end14:                                         ; preds = %do.body13
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 480) #10, !srcloc !50
  br label %do.body15

do.body15:                                        ; preds = %do.end14
  br label %do.end16

do.end16:                                         ; preds = %do.body15
  br label %do.end17

do.end17:                                         ; preds = %do.end16
  br label %if.end

if.end:                                           ; preds = %do.end17, %land.lhs.true2
  %8 = load i32, i32* %__ret_warn_on, align 4
  %tobool18 = icmp ne i32 %8, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  store i64 %conv23, i64* %tmp, align 8
  %9 = load i64, i64* %tmp, align 8
  %tobool24 = icmp ne i64 %9, 0
  br i1 %tobool24, label %if.end156, label %if.then25

if.then25:                                        ; preds = %if.end
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  %11 = load i64, i64* %smin_value, align 8
  %tobool27 = icmp ne i64 %11, 0
  br i1 %tobool27, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then25
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  %tobool28 = icmp ne i64 %13, 0
  br i1 %tobool28, label %lor.end, label %lor.lhs.false29

lor.lhs.false29:                                  ; preds = %lor.lhs.false
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %15 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = load i64, i64* %16, align 8
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = load i64, i64* %18, align 8
  %call30 = call zeroext i1 @tnum_equals_const(i64 %17, i64 %19, i64 noundef 0) #11
  br i1 %call30, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %lor.lhs.false29
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 2
  %21 = load i32, i32* %off, align 8
  %tobool31 = icmp ne i32 %21, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false29, %lor.lhs.false, %if.then25
  %22 = phi i1 [ true, %lor.lhs.false29 ], [ true, %lor.lhs.false ], [ true, %if.then25 ], [ %tobool31, %lor.rhs ]
  %lnot32 = xor i1 %22, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  store i32 %lnot.ext35, i32* %__ret_warn_on26, align 4
  %23 = load i32, i32* %__ret_warn_on26, align 4
  %tobool36 = icmp ne i32 %23, 0
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  %tobool42 = icmp ne i64 %conv41, 0
  br i1 %tobool42, label %if.then43, label %if.end52

if.then43:                                        ; preds = %lor.end
  br label %do.body44

do.body44:                                        ; preds = %if.then43
  br label %do.body45

do.body45:                                        ; preds = %do.body44
  br label %do.end46

do.end46:                                         ; preds = %do.body45
  br label %do.body47

do.body47:                                        ; preds = %do.end46
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 7529, i32 2307, i64 12) #10, !srcloc !51
  br label %do.end48

do.end48:                                         ; preds = %do.body47
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 481) #10, !srcloc !52
  br label %do.body49

do.body49:                                        ; preds = %do.end48
  br label %do.end50

do.end50:                                         ; preds = %do.body49
  br label %do.end51

do.end51:                                         ; preds = %do.end50
  br label %if.end52

if.end52:                                         ; preds = %do.end51, %lor.end
  %24 = load i32, i32* %__ret_warn_on26, align 4
  %tobool54 = icmp ne i32 %24, 0
  %lnot55 = xor i1 %tobool54, true
  %lnot57 = xor i1 %lnot55, true
  %lnot.ext58 = zext i1 %lnot57 to i32
  %conv59 = sext i32 %lnot.ext58 to i64
  store i64 %conv59, i64* %tmp53, align 8
  %25 = load i64, i64* %tmp53, align 8
  %tobool60 = icmp ne i64 %25, 0
  br i1 %tobool60, label %if.then61, label %if.end63

if.then61:                                        ; preds = %if.end52
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %26) #11
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off62 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 2
  store i32 0, i32* %off62, align 8
  br label %if.end63

if.end63:                                         ; preds = %if.then61, %if.end52
  %28 = load i8, i8* %is_null.addr, align 1
  %tobool64 = trunc i8 %28 to i1
  br i1 %tobool64, label %if.then65, label %if.else

if.then65:                                        ; preds = %if.end63
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 0
  store i32 1, i32* %type66, align 8
  br label %if.end146

if.else:                                          ; preds = %if.end63
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type67 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 0
  %31 = load i32, i32* %type67, align 8
  %cmp68 = icmp eq i32 %31, 5
  br i1 %cmp68, label %if.then70, label %if.else96

if.then70:                                        ; preds = %if.else
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 1
  %map_ptr = bitcast %struct.bpf_iter_aux_info* %33 to %struct.bpf_map**
  %34 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %34, %struct.bpf_map** %map, align 8
  %35 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %inner_map_meta = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %35, i32 0, i32 1
  %36 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta, align 8
  %tobool71 = icmp ne %struct.bpf_map* %36, null
  br i1 %tobool71, label %if.then72, label %if.else76

if.then72:                                        ; preds = %if.then70
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 0
  store i32 3, i32* %type73, align 8
  %38 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %inner_map_meta74 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %38, i32 0, i32 1
  %39 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta74, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %41 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 1
  %map_ptr75 = bitcast %struct.bpf_iter_aux_info* %41 to %struct.bpf_map**
  store %struct.bpf_map* %39, %struct.bpf_map** %map_ptr75, align 8
  br label %if.end95

if.else76:                                        ; preds = %if.then70
  %42 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %42, i32 0, i32 3
  %43 = load i32, i32* %map_type, align 8
  %cmp77 = icmp eq i32 %43, 17
  br i1 %cmp77, label %if.then79, label %if.else81

if.then79:                                        ; preds = %if.else76
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 0
  store i32 18, i32* %type80, align 8
  br label %if.end94

if.else81:                                        ; preds = %if.else76
  %45 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type82 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %45, i32 0, i32 3
  %46 = load i32, i32* %map_type82, align 8
  %cmp83 = icmp eq i32 %46, 15
  br i1 %cmp83, label %if.then89, label %lor.lhs.false85

lor.lhs.false85:                                  ; preds = %if.else81
  %47 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type86 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %47, i32 0, i32 3
  %48 = load i32, i32* %map_type86, align 8
  %cmp87 = icmp eq i32 %48, 18
  br i1 %cmp87, label %if.then89, label %if.else91

if.then89:                                        ; preds = %lor.lhs.false85, %if.else81
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type90 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 0
  store i32 11, i32* %type90, align 8
  br label %if.end93

if.else91:                                        ; preds = %lor.lhs.false85
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type92 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 0
  store i32 4, i32* %type92, align 8
  br label %if.end93

if.end93:                                         ; preds = %if.else91, %if.then89
  br label %if.end94

if.end94:                                         ; preds = %if.end93, %if.then79
  br label %if.end95

if.end95:                                         ; preds = %if.end94, %if.then72
  br label %if.end145

if.else96:                                        ; preds = %if.else
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type97 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %51, i32 0, i32 0
  %52 = load i32, i32* %type97, align 8
  %cmp98 = icmp eq i32 %52, 12
  br i1 %cmp98, label %if.then100, label %if.else102

if.then100:                                       ; preds = %if.else96
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type101 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 0
  store i32 11, i32* %type101, align 8
  br label %if.end144

if.else102:                                       ; preds = %if.else96
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 0
  %55 = load i32, i32* %type103, align 8
  %cmp104 = icmp eq i32 %55, 14
  br i1 %cmp104, label %if.then106, label %if.else108

if.then106:                                       ; preds = %if.else102
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type107 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 0
  store i32 13, i32* %type107, align 8
  br label %if.end143

if.else108:                                       ; preds = %if.else102
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 0
  %58 = load i32, i32* %type109, align 8
  %cmp110 = icmp eq i32 %58, 16
  br i1 %cmp110, label %if.then112, label %if.else114

if.then112:                                       ; preds = %if.else108
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type113 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %59, i32 0, i32 0
  store i32 15, i32* %type113, align 8
  br label %if.end142

if.else114:                                       ; preds = %if.else108
  %60 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type115 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %60, i32 0, i32 0
  %61 = load i32, i32* %type115, align 8
  %cmp116 = icmp eq i32 %61, 20
  br i1 %cmp116, label %if.then118, label %if.else120

if.then118:                                       ; preds = %if.else114
  %62 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type119 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %62, i32 0, i32 0
  store i32 19, i32* %type119, align 8
  br label %if.end141

if.else120:                                       ; preds = %if.else114
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type121 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %63, i32 0, i32 0
  %64 = load i32, i32* %type121, align 8
  %cmp122 = icmp eq i32 %64, 22
  br i1 %cmp122, label %if.then124, label %if.else126

if.then124:                                       ; preds = %if.else120
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type125 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 0
  store i32 21, i32* %type125, align 8
  br label %if.end140

if.else126:                                       ; preds = %if.else120
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type127 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %66, i32 0, i32 0
  %67 = load i32, i32* %type127, align 8
  %cmp128 = icmp eq i32 %67, 24
  br i1 %cmp128, label %if.then130, label %if.else132

if.then130:                                       ; preds = %if.else126
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type131 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %68, i32 0, i32 0
  store i32 23, i32* %type131, align 8
  br label %if.end139

if.else132:                                       ; preds = %if.else126
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type133 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %69, i32 0, i32 0
  %70 = load i32, i32* %type133, align 8
  %cmp134 = icmp eq i32 %70, 26
  br i1 %cmp134, label %if.then136, label %if.end138

if.then136:                                       ; preds = %if.else132
  %71 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type137 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %71, i32 0, i32 0
  store i32 25, i32* %type137, align 8
  br label %if.end138

if.end138:                                        ; preds = %if.then136, %if.else132
  br label %if.end139

if.end139:                                        ; preds = %if.end138, %if.then130
  br label %if.end140

if.end140:                                        ; preds = %if.end139, %if.then124
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.then118
  br label %if.end142

if.end142:                                        ; preds = %if.end141, %if.then112
  br label %if.end143

if.end143:                                        ; preds = %if.end142, %if.then106
  br label %if.end144

if.end144:                                        ; preds = %if.end143, %if.then100
  br label %if.end145

if.end145:                                        ; preds = %if.end144, %if.end95
  br label %if.end146

if.end146:                                        ; preds = %if.end145, %if.then65
  %72 = load i8, i8* %is_null.addr, align 1
  %tobool147 = trunc i8 %72 to i1
  br i1 %tobool147, label %if.then148, label %if.else150

if.then148:                                       ; preds = %if.end146
  %73 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id149 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %73, i32 0, i32 3
  store i32 0, i32* %id149, align 4
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 4
  store i32 0, i32* %ref_obj_id, align 8
  br label %if.end155

if.else150:                                       ; preds = %if.end146
  %75 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call151 = call zeroext i1 @reg_may_point_to_spin_lock(%struct.bpf_reg_state* noundef %75) #11
  br i1 %call151, label %if.end154, label %if.then152

if.then152:                                       ; preds = %if.else150
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %id153 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %76, i32 0, i32 3
  store i32 0, i32* %id153, align 4
  br label %if.end154

if.end154:                                        ; preds = %if.then152, %if.else150
  br label %if.end155

if.end155:                                        ; preds = %if.end154, %if.then148
  br label %if.end156

if.end156:                                        ; preds = %if.end155, %if.end, %land.lhs.true, %entry
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_known_zero(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %0, i64 noundef 0) #11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_may_point_to_spin_lock(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 4
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 1
  %map_ptr = bitcast %struct.bpf_iter_aux_info* %3 to %struct.bpf_map**
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %call = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %4) #11
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %5 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__mark_chain_precision(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %spi) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %spi.addr = alloca i32, align 4
  %st = alloca %struct.bpf_verifier_state*, align 8
  %first_idx = alloca i32, align 4
  %last_idx = alloca i32, align 4
  %func = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %reg_mask = alloca i32, align 4
  %stack_mask = alloca i64, align 8
  %skip_first = alloca i8, align 1
  %new_marks = alloca i8, align 1
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp47 = alloca i64, align 8
  %mask = alloca [1 x i64], align 8
  %history = alloca i32, align 4
  %__ret_warn_once120 = alloca i32, align 4
  %__ret_warn_on134 = alloca i32, align 4
  %tmp158 = alloca i64, align 8
  %tmp166 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %spi, i32* %spi.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %st, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %first_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 7
  %3 = load i32, i32* %first_insn_idx, align 4
  store i32 %3, i32* %first_idx, align 4
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 0
  %5 = load i32, i32* %insn_idx, align 8
  store i32 %5, i32* %last_idx, align 4
  %6 = load i32, i32* %regno.addr, align 4
  %cmp = icmp sge i32 %6, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i32, i32* %regno.addr, align 4
  %shl = shl i32 1, %7
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %shl, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %reg_mask, align 4
  %8 = load i32, i32* %spi.addr, align 4
  %cmp1 = icmp sge i32 %8, 0
  br i1 %cmp1, label %cond.true2, label %cond.false4

cond.true2:                                       ; preds = %cond.end
  %9 = load i32, i32* %spi.addr, align 4
  %sh_prom = zext i32 %9 to i64
  %shl3 = shl i64 1, %sh_prom
  br label %cond.end5

cond.false4:                                      ; preds = %cond.end
  br label %cond.end5

cond.end5:                                        ; preds = %cond.false4, %cond.true2
  %cond6 = phi i64 [ %shl3, %cond.true2 ], [ 0, %cond.false4 ]
  store i64 %cond6, i64* %stack_mask, align 8
  store i8 1, i8* %skip_first, align 1
  store i8 0, i8* %new_marks, align 1
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 16
  %11 = load i8, i8* %bpf_capable, align 2
  %tobool = trunc i8 %11 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end5
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end5
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 0
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 4
  %14 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %14 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %15, %struct.bpf_func_state** %func, align 8
  %16 = load i32, i32* %regno.addr, align 4
  %cmp7 = icmp sge i32 %16, 0
  br i1 %cmp7, label %if.then8, label %if.end59

if.then8:                                         ; preds = %if.end
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 0
  %18 = load i32, i32* %regno.addr, align 4
  %idxprom9 = sext i32 %18 to i64
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom9
  store %struct.bpf_reg_state* %arrayidx10, %struct.bpf_reg_state** %reg, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type, align 8
  %cmp11 = icmp ne i32 %20, 1
  br i1 %cmp11, label %if.then12, label %if.end54

if.then12:                                        ; preds = %if.then8
  store i32 1, i32* %__ret_warn_once, align 4
  %21 = load i32, i32* %__ret_warn_once, align 4
  %tobool13 = icmp ne i32 %21, 0
  br i1 %tobool13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then12
  %22 = load i8, i8* @__mark_chain_precision.__warned, align 1
  %tobool14 = trunc i8 %22 to i1
  %lnot = xor i1 %tobool14, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then12
  %23 = phi i1 [ false, %if.then12 ], [ %lnot, %land.rhs ]
  %lnot15 = xor i1 %23, true
  %lnot16 = xor i1 %lnot15, true
  %lnot.ext = zext i1 %lnot16 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool17 = icmp ne i64 %conv, 0
  br i1 %tobool17, label %if.then18, label %if.end46

if.then18:                                        ; preds = %land.end
  store i8 1, i8* @__mark_chain_precision.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %24 = load i32, i32* %__ret_warn_on, align 4
  %tobool19 = icmp ne i32 %24, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %tobool25 = icmp ne i64 %conv24, 0
  br i1 %tobool25, label %if.then26, label %if.end39

if.then26:                                        ; preds = %if.then18
  br label %do.body

do.body:                                          ; preds = %if.then26
  br label %do.body27

do.body27:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body27
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([19 x i8], [19 x i8]* @.str.121, i64 0, i64 0)) #11
  br label %do.body28

do.body28:                                        ; preds = %do.end
  br label %do.body29

do.body29:                                        ; preds = %do.body28
  br label %do.end30

do.end30:                                         ; preds = %do.body29
  br label %do.body31

do.body31:                                        ; preds = %do.end30
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2132, i32 2313, i64 12) #10, !srcloc !53
  br label %do.end32

do.end32:                                         ; preds = %do.body31
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 416) #10, !srcloc !54
  br label %do.body33

do.body33:                                        ; preds = %do.end32
  br label %do.end34

do.end34:                                         ; preds = %do.body33
  br label %do.end35

do.end35:                                         ; preds = %do.end34
  br label %do.body36

do.body36:                                        ; preds = %do.end35
  br label %do.end37

do.end37:                                         ; preds = %do.body36
  br label %do.end38

do.end38:                                         ; preds = %do.end37
  br label %if.end39

if.end39:                                         ; preds = %do.end38, %if.then18
  %25 = load i32, i32* %__ret_warn_on, align 4
  %tobool40 = icmp ne i32 %25, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  store i64 %conv45, i64* %tmp, align 8
  %26 = load i64, i64* %tmp, align 8
  br label %if.end46

if.end46:                                         ; preds = %if.end39, %land.end
  %27 = load i32, i32* %__ret_warn_once, align 4
  %tobool48 = icmp ne i32 %27, 0
  %lnot49 = xor i1 %tobool48, true
  %lnot51 = xor i1 %lnot49, true
  %lnot.ext52 = zext i1 %lnot51 to i32
  %conv53 = sext i32 %lnot.ext52 to i64
  store i64 %conv53, i64* %tmp47, align 8
  %28 = load i64, i64* %tmp47, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.then8
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 18
  %30 = load i8, i8* %precise, align 4
  %tobool55 = trunc i8 %30 to i1
  br i1 %tobool55, label %if.else, label %if.then56

if.then56:                                        ; preds = %if.end54
  store i8 1, i8* %new_marks, align 1
  br label %if.end57

if.else:                                          ; preds = %if.end54
  store i32 0, i32* %reg_mask, align 4
  br label %if.end57

if.end57:                                         ; preds = %if.else, %if.then56
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 18
  store i8 1, i8* %precise58, align 4
  br label %if.end59

if.end59:                                         ; preds = %if.end57, %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end59
  %32 = load i32, i32* %spi.addr, align 4
  %cmp60 = icmp sge i32 %32, 0
  br i1 %cmp60, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 7
  %34 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %35 = load i32, i32* %spi.addr, align 4
  %idxprom62 = sext i32 %35 to i64
  %arrayidx63 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %34, i64 %idxprom62
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx63, i32 0, i32 1
  %arrayidx64 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %36 = load i8, i8* %arrayidx64, align 8
  %conv65 = zext i8 %36 to i32
  %cmp66 = icmp ne i32 %conv65, 1
  br i1 %cmp66, label %if.then68, label %if.end69

if.then68:                                        ; preds = %while.body
  store i64 0, i64* %stack_mask, align 8
  br label %while.end

if.end69:                                         ; preds = %while.body
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack70 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %37, i32 0, i32 7
  %38 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack70, align 8
  %39 = load i32, i32* %spi.addr, align 4
  %idxprom71 = sext i32 %39 to i64
  %arrayidx72 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %38, i64 %idxprom71
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx72, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %reg, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 0
  %41 = load i32, i32* %type73, align 8
  %cmp74 = icmp ne i32 %41, 1
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %if.end69
  store i64 0, i64* %stack_mask, align 8
  br label %while.end

if.end77:                                         ; preds = %if.end69
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise78 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 18
  %43 = load i8, i8* %precise78, align 4
  %tobool79 = trunc i8 %43 to i1
  br i1 %tobool79, label %if.else81, label %if.then80

if.then80:                                        ; preds = %if.end77
  store i8 1, i8* %new_marks, align 1
  br label %if.end82

if.else81:                                        ; preds = %if.end77
  store i64 0, i64* %stack_mask, align 8
  br label %if.end82

if.end82:                                         ; preds = %if.else81, %if.then80
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise83 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 18
  store i8 1, i8* %precise83, align 4
  br label %while.end

while.end:                                        ; preds = %if.end82, %if.then76, %if.then68, %while.cond
  %45 = load i8, i8* %new_marks, align 1
  %tobool84 = trunc i8 %45 to i1
  br i1 %tobool84, label %if.end86, label %if.then85

if.then85:                                        ; preds = %while.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end86:                                         ; preds = %while.end
  %46 = load i32, i32* %reg_mask, align 4
  %tobool87 = icmp ne i32 %46, 0
  br i1 %tobool87, label %if.end90, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end86
  %47 = load i64, i64* %stack_mask, align 8
  %tobool88 = icmp ne i64 %47, 0
  br i1 %tobool88, label %if.end90, label %if.then89

if.then89:                                        ; preds = %land.lhs.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end90:                                         ; preds = %land.lhs.true, %if.end86
  br label %for.cond

for.cond:                                         ; preds = %if.end275, %if.end90
  %48 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %48, i32 0, i32 10
  %49 = load i32, i32* %jmp_history_cnt, align 8
  store i32 %49, i32* %history, align 4
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %50, i32 0, i32 22
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %51 = load i32, i32* %level, align 8
  %and = and i32 %51, 3
  %tobool91 = icmp ne i32 %and, 0
  br i1 %tobool91, label %if.then92, label %if.end93

if.then92:                                        ; preds = %for.cond
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  %54 = load i32, i32* %last_idx, align 4
  %55 = load i32, i32* %first_idx, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.122, i64 0, i64 0), i32 noundef %54, i32 noundef %55) #11
  br label %if.end93

if.end93:                                         ; preds = %if.then92, %for.cond
  %56 = load i32, i32* %last_idx, align 4
  store i32 %56, i32* %i, align 4
  br label %for.cond94

for.cond94:                                       ; preds = %if.end173, %if.end93
  %57 = load i8, i8* %skip_first, align 1
  %tobool95 = trunc i8 %57 to i1
  br i1 %tobool95, label %if.then96, label %if.else97

if.then96:                                        ; preds = %for.cond94
  store i32 0, i32* %err, align 4
  store i8 0, i8* %skip_first, align 1
  br label %if.end98

if.else97:                                        ; preds = %for.cond94
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = load i32, i32* %i, align 4
  %call = call i32 @backtrack_insn(%struct.bpf_verifier_env* noundef %58, i32 noundef %59, i32* noundef %reg_mask, i64* noundef %stack_mask) #11
  store i32 %call, i32* %err, align 4
  br label %if.end98

if.end98:                                         ; preds = %if.else97, %if.then96
  %60 = load i32, i32* %err, align 4
  %cmp99 = icmp eq i32 %60, -524
  br i1 %cmp99, label %if.then101, label %if.else102

if.then101:                                       ; preds = %if.end98
  %61 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %62 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  call void @mark_all_scalars_precise(%struct.bpf_verifier_env* noundef %61, %struct.bpf_verifier_state* noundef %62) #11
  store i32 0, i32* %retval, align 4
  br label %return

if.else102:                                       ; preds = %if.end98
  %63 = load i32, i32* %err, align 4
  %tobool103 = icmp ne i32 %63, 0
  br i1 %tobool103, label %if.then104, label %if.end105

if.then104:                                       ; preds = %if.else102
  %64 = load i32, i32* %err, align 4
  store i32 %64, i32* %retval, align 4
  br label %return

if.end105:                                        ; preds = %if.else102
  br label %if.end106

if.end106:                                        ; preds = %if.end105
  %65 = load i32, i32* %reg_mask, align 4
  %tobool107 = icmp ne i32 %65, 0
  br i1 %tobool107, label %if.end111, label %land.lhs.true108

land.lhs.true108:                                 ; preds = %if.end106
  %66 = load i64, i64* %stack_mask, align 8
  %tobool109 = icmp ne i64 %66, 0
  br i1 %tobool109, label %if.end111, label %if.then110

if.then110:                                       ; preds = %land.lhs.true108
  store i32 0, i32* %retval, align 4
  br label %return

if.end111:                                        ; preds = %land.lhs.true108, %if.end106
  %67 = load i32, i32* %i, align 4
  %68 = load i32, i32* %first_idx, align 4
  %cmp112 = icmp eq i32 %67, %68
  br i1 %cmp112, label %if.then114, label %if.end115

if.then114:                                       ; preds = %if.end111
  br label %for.end

if.end115:                                        ; preds = %if.end111
  %69 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %70 = load i32, i32* %i, align 4
  %call116 = call i32 @get_prev_insn_idx(%struct.bpf_verifier_state* noundef %69, i32 noundef %70, i32* noundef %history) #11
  store i32 %call116, i32* %i, align 4
  %71 = load i32, i32* %i, align 4
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %72, i32 0, i32 2
  %73 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %73, i32 0, i32 4
  %74 = load i32, i32* %len, align 4
  %cmp117 = icmp uge i32 %71, %74
  br i1 %cmp117, label %if.then119, label %if.end173

if.then119:                                       ; preds = %if.end115
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = bitcast %struct.bpf_verifier_env* %75 to i8*
  %77 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %76, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.123, i64 0, i64 0), i32 noundef %77) #11
  store i32 1, i32* %__ret_warn_once120, align 4
  %78 = load i32, i32* %__ret_warn_once120, align 4
  %tobool121 = icmp ne i32 %78, 0
  br i1 %tobool121, label %land.rhs122, label %land.end126

land.rhs122:                                      ; preds = %if.then119
  %79 = load i8, i8* @__mark_chain_precision.__warned.124, align 1
  %tobool123 = trunc i8 %79 to i1
  %lnot124 = xor i1 %tobool123, true
  br label %land.end126

land.end126:                                      ; preds = %land.rhs122, %if.then119
  %80 = phi i1 [ false, %if.then119 ], [ %lnot124, %land.rhs122 ]
  %lnot127 = xor i1 %80, true
  %lnot129 = xor i1 %lnot127, true
  %lnot.ext130 = zext i1 %lnot129 to i32
  %conv131 = sext i32 %lnot.ext130 to i64
  %tobool132 = icmp ne i64 %conv131, 0
  br i1 %tobool132, label %if.then133, label %if.end165

if.then133:                                       ; preds = %land.end126
  store i8 1, i8* @__mark_chain_precision.__warned.124, align 1
  store i32 1, i32* %__ret_warn_on134, align 4
  %81 = load i32, i32* %__ret_warn_on134, align 4
  %tobool135 = icmp ne i32 %81, 0
  %lnot136 = xor i1 %tobool135, true
  %lnot138 = xor i1 %lnot136, true
  %lnot.ext139 = zext i1 %lnot138 to i32
  %conv140 = sext i32 %lnot.ext139 to i64
  %tobool141 = icmp ne i64 %conv140, 0
  br i1 %tobool141, label %if.then142, label %if.end157

if.then142:                                       ; preds = %if.then133
  br label %do.body143

do.body143:                                       ; preds = %if.then142
  br label %do.body144

do.body144:                                       ; preds = %do.body143
  br label %do.end145

do.end145:                                        ; preds = %do.body144
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.125, i64 0, i64 0)) #11
  br label %do.body146

do.body146:                                       ; preds = %do.end145
  br label %do.body147

do.body147:                                       ; preds = %do.body146
  br label %do.end148

do.end148:                                        ; preds = %do.body147
  br label %do.body149

do.body149:                                       ; preds = %do.end148
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2200, i32 2313, i64 12) #10, !srcloc !55
  br label %do.end150

do.end150:                                        ; preds = %do.body149
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 417) #10, !srcloc !56
  br label %do.body151

do.body151:                                       ; preds = %do.end150
  br label %do.end152

do.end152:                                        ; preds = %do.body151
  br label %do.end153

do.end153:                                        ; preds = %do.end152
  br label %do.body154

do.body154:                                       ; preds = %do.end153
  br label %do.end155

do.end155:                                        ; preds = %do.body154
  br label %do.end156

do.end156:                                        ; preds = %do.end155
  br label %if.end157

if.end157:                                        ; preds = %do.end156, %if.then133
  %82 = load i32, i32* %__ret_warn_on134, align 4
  %tobool159 = icmp ne i32 %82, 0
  %lnot160 = xor i1 %tobool159, true
  %lnot162 = xor i1 %lnot160, true
  %lnot.ext163 = zext i1 %lnot162 to i32
  %conv164 = sext i32 %lnot.ext163 to i64
  store i64 %conv164, i64* %tmp158, align 8
  %83 = load i64, i64* %tmp158, align 8
  br label %if.end165

if.end165:                                        ; preds = %if.end157, %land.end126
  %84 = load i32, i32* %__ret_warn_once120, align 4
  %tobool167 = icmp ne i32 %84, 0
  %lnot168 = xor i1 %tobool167, true
  %lnot170 = xor i1 %lnot168, true
  %lnot.ext171 = zext i1 %lnot170 to i32
  %conv172 = sext i32 %lnot.ext171 to i64
  store i64 %conv172, i64* %tmp166, align 8
  %85 = load i64, i64* %tmp166, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end173:                                        ; preds = %if.end115
  br label %for.cond94

for.end:                                          ; preds = %if.then114
  %86 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %86, i32 0, i32 1
  %87 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  store %struct.bpf_verifier_state* %87, %struct.bpf_verifier_state** %st, align 8
  %88 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %tobool174 = icmp ne %struct.bpf_verifier_state* %88, null
  br i1 %tobool174, label %if.end176, label %if.then175

if.then175:                                       ; preds = %for.end
  br label %for.end277

if.end176:                                        ; preds = %for.end
  store i8 0, i8* %new_marks, align 1
  %89 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %frame177 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %89, i32 0, i32 0
  %90 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %curframe178 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %90, i32 0, i32 4
  %91 = load i32, i32* %curframe178, align 8
  %idxprom179 = zext i32 %91 to i64
  %arrayidx180 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame177, i64 0, i64 %idxprom179
  %92 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx180, align 8
  store %struct.bpf_func_state* %92, %struct.bpf_func_state** %func, align 8
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %93 = load i32, i32* %reg_mask, align 4
  %conv181 = zext i32 %93 to i64
  call void @bitmap_from_u64(i64* noundef %arraydecay, i64 noundef %conv181) #11
  %arraydecay182 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %call183 = call i64 @find_first_bit(i64* noundef %arraydecay182, i64 noundef 32) #11
  %conv184 = trunc i64 %call183 to i32
  store i32 %conv184, i32* %i, align 4
  br label %for.cond185

for.cond185:                                      ; preds = %for.inc, %if.end176
  %94 = load i32, i32* %i, align 4
  %cmp186 = icmp slt i32 %94, 32
  br i1 %cmp186, label %for.body, label %for.end207

for.body:                                         ; preds = %for.cond185
  %95 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %regs188 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %95, i32 0, i32 0
  %96 = load i32, i32* %i, align 4
  %idxprom189 = sext i32 %96 to i64
  %arrayidx190 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs188, i64 0, i64 %idxprom189
  store %struct.bpf_reg_state* %arrayidx190, %struct.bpf_reg_state** %reg, align 8
  %97 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type191 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %97, i32 0, i32 0
  %98 = load i32, i32* %type191, align 8
  %cmp192 = icmp ne i32 %98, 1
  br i1 %cmp192, label %if.then194, label %if.end197

if.then194:                                       ; preds = %for.body
  %99 = load i32, i32* %i, align 4
  %shl195 = shl i32 1, %99
  %neg = xor i32 %shl195, -1
  %100 = load i32, i32* %reg_mask, align 4
  %and196 = and i32 %100, %neg
  store i32 %and196, i32* %reg_mask, align 4
  br label %for.inc

if.end197:                                        ; preds = %for.body
  %101 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise198 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %101, i32 0, i32 18
  %102 = load i8, i8* %precise198, align 4
  %tobool199 = trunc i8 %102 to i1
  br i1 %tobool199, label %if.end201, label %if.then200

if.then200:                                       ; preds = %if.end197
  store i8 1, i8* %new_marks, align 1
  br label %if.end201

if.end201:                                        ; preds = %if.then200, %if.end197
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise202 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %103, i32 0, i32 18
  store i8 1, i8* %precise202, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end201, %if.then194
  %arraydecay203 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %104 = load i32, i32* %i, align 4
  %add = add i32 %104, 1
  %conv204 = sext i32 %add to i64
  %call205 = call i64 @find_next_bit(i64* noundef %arraydecay203, i64 noundef 32, i64 noundef %conv204) #11
  %conv206 = trunc i64 %call205 to i32
  store i32 %conv206, i32* %i, align 4
  br label %for.cond185

for.end207:                                       ; preds = %for.cond185
  %arraydecay208 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %105 = load i64, i64* %stack_mask, align 8
  call void @bitmap_from_u64(i64* noundef %arraydecay208, i64 noundef %105) #11
  %arraydecay209 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %call210 = call i64 @find_first_bit(i64* noundef %arraydecay209, i64 noundef 64) #11
  %conv211 = trunc i64 %call210 to i32
  store i32 %conv211, i32* %i, align 4
  br label %for.cond212

for.cond212:                                      ; preds = %for.inc252, %for.end207
  %106 = load i32, i32* %i, align 4
  %cmp213 = icmp slt i32 %106, 64
  br i1 %cmp213, label %for.body215, label %for.end258

for.body215:                                      ; preds = %for.cond212
  %107 = load i32, i32* %i, align 4
  %108 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %108, i32 0, i32 6
  %109 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %109, 8
  %cmp216 = icmp sge i32 %107, %div
  br i1 %cmp216, label %if.then218, label %if.end219

if.then218:                                       ; preds = %for.body215
  %110 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %111 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  call void @mark_all_scalars_precise(%struct.bpf_verifier_env* noundef %110, %struct.bpf_verifier_state* noundef %111) #11
  store i32 0, i32* %retval, align 4
  br label %return

if.end219:                                        ; preds = %for.body215
  %112 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack220 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %112, i32 0, i32 7
  %113 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack220, align 8
  %114 = load i32, i32* %i, align 4
  %idxprom221 = sext i32 %114 to i64
  %arrayidx222 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %113, i64 %idxprom221
  %slot_type223 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx222, i32 0, i32 1
  %arrayidx224 = getelementptr [8 x i8], [8 x i8]* %slot_type223, i64 0, i64 0
  %115 = load i8, i8* %arrayidx224, align 8
  %conv225 = zext i8 %115 to i32
  %cmp226 = icmp ne i32 %conv225, 1
  br i1 %cmp226, label %if.then228, label %if.end233

if.then228:                                       ; preds = %if.end219
  %116 = load i32, i32* %i, align 4
  %sh_prom229 = zext i32 %116 to i64
  %shl230 = shl i64 1, %sh_prom229
  %neg231 = xor i64 %shl230, -1
  %117 = load i64, i64* %stack_mask, align 8
  %and232 = and i64 %117, %neg231
  store i64 %and232, i64* %stack_mask, align 8
  br label %for.inc252

if.end233:                                        ; preds = %if.end219
  %118 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack234 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %118, i32 0, i32 7
  %119 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack234, align 8
  %120 = load i32, i32* %i, align 4
  %idxprom235 = sext i32 %120 to i64
  %arrayidx236 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %119, i64 %idxprom235
  %spilled_ptr237 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx236, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr237, %struct.bpf_reg_state** %reg, align 8
  %121 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type238 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %121, i32 0, i32 0
  %122 = load i32, i32* %type238, align 8
  %cmp239 = icmp ne i32 %122, 1
  br i1 %cmp239, label %if.then241, label %if.end246

if.then241:                                       ; preds = %if.end233
  %123 = load i32, i32* %i, align 4
  %sh_prom242 = zext i32 %123 to i64
  %shl243 = shl i64 1, %sh_prom242
  %neg244 = xor i64 %shl243, -1
  %124 = load i64, i64* %stack_mask, align 8
  %and245 = and i64 %124, %neg244
  store i64 %and245, i64* %stack_mask, align 8
  br label %for.inc252

if.end246:                                        ; preds = %if.end233
  %125 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise247 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %125, i32 0, i32 18
  %126 = load i8, i8* %precise247, align 4
  %tobool248 = trunc i8 %126 to i1
  br i1 %tobool248, label %if.end250, label %if.then249

if.then249:                                       ; preds = %if.end246
  store i8 1, i8* %new_marks, align 1
  br label %if.end250

if.end250:                                        ; preds = %if.then249, %if.end246
  %127 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise251 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %127, i32 0, i32 18
  store i8 1, i8* %precise251, align 4
  br label %for.inc252

for.inc252:                                       ; preds = %if.end250, %if.then241, %if.then228
  %arraydecay253 = getelementptr inbounds [1 x i64], [1 x i64]* %mask, i64 0, i64 0
  %128 = load i32, i32* %i, align 4
  %add254 = add i32 %128, 1
  %conv255 = sext i32 %add254 to i64
  %call256 = call i64 @find_next_bit(i64* noundef %arraydecay253, i64 noundef 64, i64 noundef %conv255) #11
  %conv257 = trunc i64 %call256 to i32
  store i32 %conv257, i32* %i, align 4
  br label %for.cond212

for.end258:                                       ; preds = %for.cond212
  %129 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log259 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %129, i32 0, i32 22
  %level260 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log259, i32 0, i32 0
  %130 = load i32, i32* %level260, align 8
  %and261 = and i32 %130, 3
  %tobool262 = icmp ne i32 %and261, 0
  br i1 %tobool262, label %if.then263, label %if.end267

if.then263:                                       ; preds = %for.end258
  %131 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %132 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %131, %struct.bpf_func_state* noundef %132) #11
  %133 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %134 = bitcast %struct.bpf_verifier_env* %133 to i8*
  %135 = load i8, i8* %new_marks, align 1
  %tobool264 = trunc i8 %135 to i1
  %136 = zext i1 %tobool264 to i64
  %cond266 = select i1 %tobool264, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.127, i64 0, i64 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.128, i64 0, i64 0)
  %137 = load i32, i32* %reg_mask, align 4
  %138 = load i64, i64* %stack_mask, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %134, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.126, i64 0, i64 0), i8* noundef %cond266, i32 noundef %137, i64 noundef %138) #11
  br label %if.end267

if.end267:                                        ; preds = %if.then263, %for.end258
  %139 = load i32, i32* %reg_mask, align 4
  %tobool268 = icmp ne i32 %139, 0
  br i1 %tobool268, label %if.end272, label %land.lhs.true269

land.lhs.true269:                                 ; preds = %if.end267
  %140 = load i64, i64* %stack_mask, align 8
  %tobool270 = icmp ne i64 %140, 0
  br i1 %tobool270, label %if.end272, label %if.then271

if.then271:                                       ; preds = %land.lhs.true269
  br label %for.end277

if.end272:                                        ; preds = %land.lhs.true269, %if.end267
  %141 = load i8, i8* %new_marks, align 1
  %tobool273 = trunc i8 %141 to i1
  br i1 %tobool273, label %if.end275, label %if.then274

if.then274:                                       ; preds = %if.end272
  br label %for.end277

if.end275:                                        ; preds = %if.end272
  %142 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %last_insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %142, i32 0, i32 8
  %143 = load i32, i32* %last_insn_idx, align 8
  store i32 %143, i32* %last_idx, align 4
  %144 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st, align 8
  %first_insn_idx276 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %144, i32 0, i32 7
  %145 = load i32, i32* %first_insn_idx276, align 4
  store i32 %145, i32* %first_idx, align 4
  br label %for.cond

for.end277:                                       ; preds = %if.then274, %if.then271, %if.then175
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end277, %if.then218, %if.end165, %if.then110, %if.then104, %if.then101, %if.then89, %if.then85, %if.end46, %if.then
  %146 = load i32, i32* %retval, align 4
  ret i32 %146
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @backtrack_insn(%struct.bpf_verifier_env* noundef %env, i32 noundef %idx, i32* noundef %reg_mask, i64* noundef %stack_mask) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %idx.addr = alloca i32, align 4
  %reg_mask.addr = alloca i32*, align 8
  %stack_mask.addr = alloca i64*, align 8
  %cbs = alloca %struct.bpf_insn_cbs, align 8
  %insn = alloca %struct.bpf_insn*, align 8
  %class = alloca i8, align 1
  %opcode = alloca i8, align 1
  %mode = alloca i8, align 1
  %dreg = alloca i32, align 4
  %sreg = alloca i32, align 4
  %spi = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp122 = alloca i64, align 8
  %__ret_warn_once168 = alloca i32, align 4
  %__ret_warn_on182 = alloca i32, align 4
  %tmp206 = alloca i64, align 8
  %tmp214 = alloca i64, align 8
  %__ret_warn_once263 = alloca i32, align 4
  %__ret_warn_on277 = alloca i32, align 4
  %tmp301 = alloca i64, align 8
  %tmp309 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  store i32* %reg_mask, i32** %reg_mask.addr, align 8
  store i64* %stack_mask, i64** %stack_mask.addr, align 8
  %cb_print = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 0
  store void (i8*, i8*, ...)* @verbose, void (i8*, i8*, ...)** %cb_print, align 8
  %cb_call = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 1
  store i8* (i8*, %struct.bpf_insn*)* null, i8* (i8*, %struct.bpf_insn*)** %cb_call, align 8
  %cb_imm = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 2
  store i8* (i8*, %struct.bpf_insn*, i64)* null, i8* (i8*, %struct.bpf_insn*, i64)** %cb_imm, align 8
  %private_data = getelementptr inbounds %struct.bpf_insn_cbs, %struct.bpf_insn_cbs* %cbs, i32 0, i32 3
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = bitcast %struct.bpf_verifier_env* %0 to i8*
  store i8* %1, i8** %private_data, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 11
  %arraydecay = getelementptr inbounds [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 0
  %4 = load i32, i32* %idx.addr, align 4
  %idx.ext = sext i32 %4 to i64
  %add.ptr = getelementptr %struct.bpf_insn, %struct.bpf_insn* %arraydecay, i64 %idx.ext
  store %struct.bpf_insn* %add.ptr, %struct.bpf_insn** %insn, align 8
  %5 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %5, i32 0, i32 0
  %6 = load i8, i8* %code, align 4
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 7
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %class, align 1
  %7 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %7, i32 0, i32 0
  %8 = load i8, i8* %code2, align 4
  %conv3 = zext i8 %8 to i32
  %and4 = and i32 %conv3, 240
  %conv5 = trunc i32 %and4 to i8
  store i8 %conv5, i8* %opcode, align 1
  %9 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %9, i32 0, i32 0
  %10 = load i8, i8* %code6, align 4
  %conv7 = zext i8 %10 to i32
  %and8 = and i32 %conv7, 224
  %conv9 = trunc i32 %and8 to i8
  store i8 %conv9, i8* %mode, align 1
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv10 = zext i8 %bf.clear to i32
  %shl = shl i32 1, %conv10
  store i32 %shl, i32* %dreg, align 4
  %12 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %12, i32 0, i32 1
  %bf.load11 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load11, 4
  %conv12 = zext i8 %bf.lshr to i32
  %shl13 = shl i32 1, %conv12
  store i32 %shl13, i32* %sreg, align 4
  %13 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code14 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %13, i32 0, i32 0
  %14 = load i8, i8* %code14, align 4
  %conv15 = zext i8 %14 to i32
  %cmp = icmp eq i32 %conv15, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 22
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %16 = load i32, i32* %level, align 8
  %and17 = and i32 %16, 3
  %tobool = icmp ne i32 %and17, 0
  br i1 %tobool, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  %19 = load i32*, i32** %reg_mask.addr, align 8
  %20 = load i32, i32* %19, align 4
  %21 = load i64*, i64** %stack_mask.addr, align 8
  %22 = load i64, i64* %21, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([27 x i8], [27 x i8]* @.str.129, i64 0, i64 0), i32 noundef %20, i64 noundef %22) #11
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = bitcast %struct.bpf_verifier_env* %23 to i8*
  %25 = load i32, i32* %idx.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %24, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.86, i64 0, i64 0), i32 noundef %25) #11
  %26 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 14
  %28 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool19 = trunc i8 %28 to i1
  call void @print_bpf_insn(%struct.bpf_insn_cbs* noundef %cbs, %struct.bpf_insn* noundef %26, i1 noundef zeroext %tobool19) #11
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end
  %29 = load i8, i8* %class, align 1
  %conv21 = zext i8 %29 to i32
  %cmp22 = icmp eq i32 %conv21, 4
  br i1 %cmp22, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end20
  %30 = load i8, i8* %class, align 1
  %conv24 = zext i8 %30 to i32
  %cmp25 = icmp eq i32 %conv24, 7
  br i1 %cmp25, label %if.then27, label %if.else56

if.then27:                                        ; preds = %lor.lhs.false, %if.end20
  %31 = load i32*, i32** %reg_mask.addr, align 8
  %32 = load i32, i32* %31, align 4
  %33 = load i32, i32* %dreg, align 4
  %and28 = and i32 %32, %33
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.then27
  store i32 0, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.then27
  %34 = load i8, i8* %opcode, align 1
  %conv32 = zext i8 %34 to i32
  %cmp33 = icmp eq i32 %conv32, 176
  br i1 %cmp33, label %if.then35, label %if.else46

if.then35:                                        ; preds = %if.end31
  %35 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code36 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %35, i32 0, i32 0
  %36 = load i8, i8* %code36, align 4
  %conv37 = zext i8 %36 to i32
  %and38 = and i32 %conv37, 8
  %cmp39 = icmp eq i32 %and38, 8
  br i1 %cmp39, label %if.then41, label %if.else

if.then41:                                        ; preds = %if.then35
  %37 = load i32, i32* %dreg, align 4
  %neg = xor i32 %37, -1
  %38 = load i32*, i32** %reg_mask.addr, align 8
  %39 = load i32, i32* %38, align 4
  %and42 = and i32 %39, %neg
  store i32 %and42, i32* %38, align 4
  %40 = load i32, i32* %sreg, align 4
  %41 = load i32*, i32** %reg_mask.addr, align 8
  %42 = load i32, i32* %41, align 4
  %or = or i32 %42, %40
  store i32 %or, i32* %41, align 4
  br label %if.end45

if.else:                                          ; preds = %if.then35
  %43 = load i32, i32* %dreg, align 4
  %neg43 = xor i32 %43, -1
  %44 = load i32*, i32** %reg_mask.addr, align 8
  %45 = load i32, i32* %44, align 4
  %and44 = and i32 %45, %neg43
  store i32 %and44, i32* %44, align 4
  br label %if.end45

if.end45:                                         ; preds = %if.else, %if.then41
  br label %if.end55

if.else46:                                        ; preds = %if.end31
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code47 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 0
  %47 = load i8, i8* %code47, align 4
  %conv48 = zext i8 %47 to i32
  %and49 = and i32 %conv48, 8
  %cmp50 = icmp eq i32 %and49, 8
  br i1 %cmp50, label %if.then52, label %if.end54

if.then52:                                        ; preds = %if.else46
  %48 = load i32, i32* %sreg, align 4
  %49 = load i32*, i32** %reg_mask.addr, align 8
  %50 = load i32, i32* %49, align 4
  %or53 = or i32 %50, %48
  store i32 %or53, i32* %49, align 4
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %if.else46
  br label %if.end55

if.end55:                                         ; preds = %if.end54, %if.end45
  br label %if.end348

if.else56:                                        ; preds = %lor.lhs.false
  %51 = load i8, i8* %class, align 1
  %conv57 = zext i8 %51 to i32
  %cmp58 = icmp eq i32 %conv57, 1
  br i1 %cmp58, label %if.then60, label %if.else132

if.then60:                                        ; preds = %if.else56
  %52 = load i32*, i32** %reg_mask.addr, align 8
  %53 = load i32, i32* %52, align 4
  %54 = load i32, i32* %dreg, align 4
  %and61 = and i32 %53, %54
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.end64, label %if.then63

if.then63:                                        ; preds = %if.then60
  store i32 0, i32* %retval, align 4
  br label %return

if.end64:                                         ; preds = %if.then60
  %55 = load i32, i32* %dreg, align 4
  %neg65 = xor i32 %55, -1
  %56 = load i32*, i32** %reg_mask.addr, align 8
  %57 = load i32, i32* %56, align 4
  %and66 = and i32 %57, %neg65
  store i32 %and66, i32* %56, align 4
  %58 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg67 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %58, i32 0, i32 1
  %bf.load68 = load i8, i8* %src_reg67, align 1
  %bf.lshr69 = lshr i8 %bf.load68, 4
  %conv70 = zext i8 %bf.lshr69 to i32
  %cmp71 = icmp ne i32 %conv70, 10
  br i1 %cmp71, label %if.then73, label %if.end74

if.then73:                                        ; preds = %if.end64
  store i32 0, i32* %retval, align 4
  br label %return

if.end74:                                         ; preds = %if.end64
  %59 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code75 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %59, i32 0, i32 0
  %60 = load i8, i8* %code75, align 4
  %conv76 = zext i8 %60 to i32
  %and77 = and i32 %conv76, 24
  %cmp78 = icmp ne i32 %and77, 24
  br i1 %cmp78, label %if.then80, label %if.end81

if.then80:                                        ; preds = %if.end74
  store i32 0, i32* %retval, align 4
  br label %return

if.end81:                                         ; preds = %if.end74
  %61 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %61, i32 0, i32 2
  %62 = load i16, i16* %off, align 2
  %conv82 = sext i16 %62 to i32
  %sub = sub i32 0, %conv82
  %sub83 = sub i32 %sub, 1
  %div = sdiv i32 %sub83, 8
  store i32 %div, i32* %spi, align 4
  %63 = load i32, i32* %spi, align 4
  %cmp84 = icmp uge i32 %63, 64
  br i1 %cmp84, label %if.then86, label %if.end129

if.then86:                                        ; preds = %if.end81
  %64 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %65 = bitcast %struct.bpf_verifier_env* %64 to i8*
  %66 = load i32, i32* %spi, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %65, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.130, i64 0, i64 0), i32 noundef %66) #11
  store i32 1, i32* %__ret_warn_once, align 4
  %67 = load i32, i32* %__ret_warn_once, align 4
  %tobool87 = icmp ne i32 %67, 0
  br i1 %tobool87, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then86
  %68 = load i8, i8* @backtrack_insn.__warned, align 1
  %tobool88 = trunc i8 %68 to i1
  %lnot = xor i1 %tobool88, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then86
  %69 = phi i1 [ false, %if.then86 ], [ %lnot, %land.rhs ]
  %lnot89 = xor i1 %69, true
  %lnot90 = xor i1 %lnot89, true
  %lnot.ext = zext i1 %lnot90 to i32
  %conv91 = sext i32 %lnot.ext to i64
  %tobool92 = icmp ne i64 %conv91, 0
  br i1 %tobool92, label %if.then93, label %if.end121

if.then93:                                        ; preds = %land.end
  store i8 1, i8* @backtrack_insn.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %70 = load i32, i32* %__ret_warn_on, align 4
  %tobool94 = icmp ne i32 %70, 0
  %lnot95 = xor i1 %tobool94, true
  %lnot97 = xor i1 %lnot95, true
  %lnot.ext98 = zext i1 %lnot97 to i32
  %conv99 = sext i32 %lnot.ext98 to i64
  %tobool100 = icmp ne i64 %conv99, 0
  br i1 %tobool100, label %if.then101, label %if.end114

if.then101:                                       ; preds = %if.then93
  br label %do.body

do.body:                                          ; preds = %if.then101
  br label %do.body102

do.body102:                                       ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body102
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.125, i64 0, i64 0)) #11
  br label %do.body103

do.body103:                                       ; preds = %do.end
  br label %do.body104

do.body104:                                       ; preds = %do.body103
  br label %do.end105

do.end105:                                        ; preds = %do.body104
  br label %do.body106

do.body106:                                       ; preds = %do.end105
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1970, i32 2313, i64 12) #10, !srcloc !57
  br label %do.end107

do.end107:                                        ; preds = %do.body106
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 413) #10, !srcloc !58
  br label %do.body108

do.body108:                                       ; preds = %do.end107
  br label %do.end109

do.end109:                                        ; preds = %do.body108
  br label %do.end110

do.end110:                                        ; preds = %do.end109
  br label %do.body111

do.body111:                                       ; preds = %do.end110
  br label %do.end112

do.end112:                                        ; preds = %do.body111
  br label %do.end113

do.end113:                                        ; preds = %do.end112
  br label %if.end114

if.end114:                                        ; preds = %do.end113, %if.then93
  %71 = load i32, i32* %__ret_warn_on, align 4
  %tobool115 = icmp ne i32 %71, 0
  %lnot116 = xor i1 %tobool115, true
  %lnot118 = xor i1 %lnot116, true
  %lnot.ext119 = zext i1 %lnot118 to i32
  %conv120 = sext i32 %lnot.ext119 to i64
  store i64 %conv120, i64* %tmp, align 8
  %72 = load i64, i64* %tmp, align 8
  br label %if.end121

if.end121:                                        ; preds = %if.end114, %land.end
  %73 = load i32, i32* %__ret_warn_once, align 4
  %tobool123 = icmp ne i32 %73, 0
  %lnot124 = xor i1 %tobool123, true
  %lnot126 = xor i1 %lnot124, true
  %lnot.ext127 = zext i1 %lnot126 to i32
  %conv128 = sext i32 %lnot.ext127 to i64
  store i64 %conv128, i64* %tmp122, align 8
  %74 = load i64, i64* %tmp122, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end129:                                        ; preds = %if.end81
  %75 = load i32, i32* %spi, align 4
  %sh_prom = zext i32 %75 to i64
  %shl130 = shl i64 1, %sh_prom
  %76 = load i64*, i64** %stack_mask.addr, align 8
  %77 = load i64, i64* %76, align 8
  %or131 = or i64 %77, %shl130
  store i64 %or131, i64* %76, align 8
  br label %if.end347

if.else132:                                       ; preds = %if.else56
  %78 = load i8, i8* %class, align 1
  %conv133 = zext i8 %78 to i32
  %cmp134 = icmp eq i32 %conv133, 3
  br i1 %cmp134, label %if.then140, label %lor.lhs.false136

lor.lhs.false136:                                 ; preds = %if.else132
  %79 = load i8, i8* %class, align 1
  %conv137 = zext i8 %79 to i32
  %cmp138 = icmp eq i32 %conv137, 2
  br i1 %cmp138, label %if.then140, label %if.else238

if.then140:                                       ; preds = %lor.lhs.false136, %if.else132
  %80 = load i32*, i32** %reg_mask.addr, align 8
  %81 = load i32, i32* %80, align 4
  %82 = load i32, i32* %dreg, align 4
  %and141 = and i32 %81, %82
  %tobool142 = icmp ne i32 %and141, 0
  br i1 %tobool142, label %if.then143, label %if.end144

if.then143:                                       ; preds = %if.then140
  store i32 -524, i32* %retval, align 4
  br label %return

if.end144:                                        ; preds = %if.then140
  %83 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %dst_reg145 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %83, i32 0, i32 1
  %bf.load146 = load i8, i8* %dst_reg145, align 1
  %bf.clear147 = and i8 %bf.load146, 15
  %conv148 = zext i8 %bf.clear147 to i32
  %cmp149 = icmp ne i32 %conv148, 10
  br i1 %cmp149, label %if.then151, label %if.end152

if.then151:                                       ; preds = %if.end144
  store i32 0, i32* %retval, align 4
  br label %return

if.end152:                                        ; preds = %if.end144
  %84 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %code153 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %84, i32 0, i32 0
  %85 = load i8, i8* %code153, align 4
  %conv154 = zext i8 %85 to i32
  %and155 = and i32 %conv154, 24
  %cmp156 = icmp ne i32 %and155, 24
  br i1 %cmp156, label %if.then158, label %if.end159

if.then158:                                       ; preds = %if.end152
  store i32 0, i32* %retval, align 4
  br label %return

if.end159:                                        ; preds = %if.end152
  %86 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %off160 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %86, i32 0, i32 2
  %87 = load i16, i16* %off160, align 2
  %conv161 = sext i16 %87 to i32
  %sub162 = sub i32 0, %conv161
  %sub163 = sub i32 %sub162, 1
  %div164 = sdiv i32 %sub163, 8
  store i32 %div164, i32* %spi, align 4
  %88 = load i32, i32* %spi, align 4
  %cmp165 = icmp uge i32 %88, 64
  br i1 %cmp165, label %if.then167, label %if.end221

if.then167:                                       ; preds = %if.end159
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %90 = bitcast %struct.bpf_verifier_env* %89 to i8*
  %91 = load i32, i32* %spi, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %90, i8* noundef getelementptr inbounds ([12 x i8], [12 x i8]* @.str.130, i64 0, i64 0), i32 noundef %91) #11
  store i32 1, i32* %__ret_warn_once168, align 4
  %92 = load i32, i32* %__ret_warn_once168, align 4
  %tobool169 = icmp ne i32 %92, 0
  br i1 %tobool169, label %land.rhs170, label %land.end174

land.rhs170:                                      ; preds = %if.then167
  %93 = load i8, i8* @backtrack_insn.__warned.131, align 1
  %tobool171 = trunc i8 %93 to i1
  %lnot172 = xor i1 %tobool171, true
  br label %land.end174

land.end174:                                      ; preds = %land.rhs170, %if.then167
  %94 = phi i1 [ false, %if.then167 ], [ %lnot172, %land.rhs170 ]
  %lnot175 = xor i1 %94, true
  %lnot177 = xor i1 %lnot175, true
  %lnot.ext178 = zext i1 %lnot177 to i32
  %conv179 = sext i32 %lnot.ext178 to i64
  %tobool180 = icmp ne i64 %conv179, 0
  br i1 %tobool180, label %if.then181, label %if.end213

if.then181:                                       ; preds = %land.end174
  store i8 1, i8* @backtrack_insn.__warned.131, align 1
  store i32 1, i32* %__ret_warn_on182, align 4
  %95 = load i32, i32* %__ret_warn_on182, align 4
  %tobool183 = icmp ne i32 %95, 0
  %lnot184 = xor i1 %tobool183, true
  %lnot186 = xor i1 %lnot184, true
  %lnot.ext187 = zext i1 %lnot186 to i32
  %conv188 = sext i32 %lnot.ext187 to i64
  %tobool189 = icmp ne i64 %conv188, 0
  br i1 %tobool189, label %if.then190, label %if.end205

if.then190:                                       ; preds = %if.then181
  br label %do.body191

do.body191:                                       ; preds = %if.then190
  br label %do.body192

do.body192:                                       ; preds = %do.body191
  br label %do.end193

do.end193:                                        ; preds = %do.body192
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.125, i64 0, i64 0)) #11
  br label %do.body194

do.body194:                                       ; preds = %do.end193
  br label %do.body195

do.body195:                                       ; preds = %do.body194
  br label %do.end196

do.end196:                                        ; preds = %do.body195
  br label %do.body197

do.body197:                                       ; preds = %do.end196
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 1989, i32 2313, i64 12) #10, !srcloc !59
  br label %do.end198

do.end198:                                        ; preds = %do.body197
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 414) #10, !srcloc !60
  br label %do.body199

do.body199:                                       ; preds = %do.end198
  br label %do.end200

do.end200:                                        ; preds = %do.body199
  br label %do.end201

do.end201:                                        ; preds = %do.end200
  br label %do.body202

do.body202:                                       ; preds = %do.end201
  br label %do.end203

do.end203:                                        ; preds = %do.body202
  br label %do.end204

do.end204:                                        ; preds = %do.end203
  br label %if.end205

if.end205:                                        ; preds = %do.end204, %if.then181
  %96 = load i32, i32* %__ret_warn_on182, align 4
  %tobool207 = icmp ne i32 %96, 0
  %lnot208 = xor i1 %tobool207, true
  %lnot210 = xor i1 %lnot208, true
  %lnot.ext211 = zext i1 %lnot210 to i32
  %conv212 = sext i32 %lnot.ext211 to i64
  store i64 %conv212, i64* %tmp206, align 8
  %97 = load i64, i64* %tmp206, align 8
  br label %if.end213

if.end213:                                        ; preds = %if.end205, %land.end174
  %98 = load i32, i32* %__ret_warn_once168, align 4
  %tobool215 = icmp ne i32 %98, 0
  %lnot216 = xor i1 %tobool215, true
  %lnot218 = xor i1 %lnot216, true
  %lnot.ext219 = zext i1 %lnot218 to i32
  %conv220 = sext i32 %lnot.ext219 to i64
  store i64 %conv220, i64* %tmp214, align 8
  %99 = load i64, i64* %tmp214, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end221:                                        ; preds = %if.end159
  %100 = load i64*, i64** %stack_mask.addr, align 8
  %101 = load i64, i64* %100, align 8
  %102 = load i32, i32* %spi, align 4
  %sh_prom222 = zext i32 %102 to i64
  %shl223 = shl i64 1, %sh_prom222
  %and224 = and i64 %101, %shl223
  %tobool225 = icmp ne i64 %and224, 0
  br i1 %tobool225, label %if.end227, label %if.then226

if.then226:                                       ; preds = %if.end221
  store i32 0, i32* %retval, align 4
  br label %return

if.end227:                                        ; preds = %if.end221
  %103 = load i32, i32* %spi, align 4
  %sh_prom228 = zext i32 %103 to i64
  %shl229 = shl i64 1, %sh_prom228
  %neg230 = xor i64 %shl229, -1
  %104 = load i64*, i64** %stack_mask.addr, align 8
  %105 = load i64, i64* %104, align 8
  %and231 = and i64 %105, %neg230
  store i64 %and231, i64* %104, align 8
  %106 = load i8, i8* %class, align 1
  %conv232 = zext i8 %106 to i32
  %cmp233 = icmp eq i32 %conv232, 3
  br i1 %cmp233, label %if.then235, label %if.end237

if.then235:                                       ; preds = %if.end227
  %107 = load i32, i32* %sreg, align 4
  %108 = load i32*, i32** %reg_mask.addr, align 8
  %109 = load i32, i32* %108, align 4
  %or236 = or i32 %109, %107
  store i32 %or236, i32* %108, align 4
  br label %if.end237

if.end237:                                        ; preds = %if.then235, %if.end227
  br label %if.end346

if.else238:                                       ; preds = %lor.lhs.false136
  %110 = load i8, i8* %class, align 1
  %conv239 = zext i8 %110 to i32
  %cmp240 = icmp eq i32 %conv239, 5
  br i1 %cmp240, label %if.then246, label %lor.lhs.false242

lor.lhs.false242:                                 ; preds = %if.else238
  %111 = load i8, i8* %class, align 1
  %conv243 = zext i8 %111 to i32
  %cmp244 = icmp eq i32 %conv243, 6
  br i1 %cmp244, label %if.then246, label %if.else324

if.then246:                                       ; preds = %lor.lhs.false242, %if.else238
  %112 = load i8, i8* %opcode, align 1
  %conv247 = zext i8 %112 to i32
  %cmp248 = icmp eq i32 %conv247, 128
  br i1 %cmp248, label %if.then250, label %if.else317

if.then250:                                       ; preds = %if.then246
  %113 = load %struct.bpf_insn*, %struct.bpf_insn** %insn, align 8
  %src_reg251 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %113, i32 0, i32 1
  %bf.load252 = load i8, i8* %src_reg251, align 1
  %bf.lshr253 = lshr i8 %bf.load252, 4
  %conv254 = zext i8 %bf.lshr253 to i32
  %cmp255 = icmp eq i32 %conv254, 1
  br i1 %cmp255, label %if.then257, label %if.end258

if.then257:                                       ; preds = %if.then250
  store i32 -524, i32* %retval, align 4
  br label %return

if.end258:                                        ; preds = %if.then250
  %114 = load i32*, i32** %reg_mask.addr, align 8
  %115 = load i32, i32* %114, align 4
  %and259 = and i32 %115, -2
  store i32 %and259, i32* %114, align 4
  %116 = load i32*, i32** %reg_mask.addr, align 8
  %117 = load i32, i32* %116, align 4
  %and260 = and i32 %117, 63
  %tobool261 = icmp ne i32 %and260, 0
  br i1 %tobool261, label %if.then262, label %if.end316

if.then262:                                       ; preds = %if.end258
  %118 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %119 = bitcast %struct.bpf_verifier_env* %118 to i8*
  %120 = load i32*, i32** %reg_mask.addr, align 8
  %121 = load i32, i32* %120, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %119, i8* noundef getelementptr inbounds ([13 x i8], [13 x i8]* @.str.132, i64 0, i64 0), i32 noundef %121) #11
  store i32 1, i32* %__ret_warn_once263, align 4
  %122 = load i32, i32* %__ret_warn_once263, align 4
  %tobool264 = icmp ne i32 %122, 0
  br i1 %tobool264, label %land.rhs265, label %land.end269

land.rhs265:                                      ; preds = %if.then262
  %123 = load i8, i8* @backtrack_insn.__warned.133, align 1
  %tobool266 = trunc i8 %123 to i1
  %lnot267 = xor i1 %tobool266, true
  br label %land.end269

land.end269:                                      ; preds = %land.rhs265, %if.then262
  %124 = phi i1 [ false, %if.then262 ], [ %lnot267, %land.rhs265 ]
  %lnot270 = xor i1 %124, true
  %lnot272 = xor i1 %lnot270, true
  %lnot.ext273 = zext i1 %lnot272 to i32
  %conv274 = sext i32 %lnot.ext273 to i64
  %tobool275 = icmp ne i64 %conv274, 0
  br i1 %tobool275, label %if.then276, label %if.end308

if.then276:                                       ; preds = %land.end269
  store i8 1, i8* @backtrack_insn.__warned.133, align 1
  store i32 1, i32* %__ret_warn_on277, align 4
  %125 = load i32, i32* %__ret_warn_on277, align 4
  %tobool278 = icmp ne i32 %125, 0
  %lnot279 = xor i1 %tobool278, true
  %lnot281 = xor i1 %lnot279, true
  %lnot.ext282 = zext i1 %lnot281 to i32
  %conv283 = sext i32 %lnot.ext282 to i64
  %tobool284 = icmp ne i64 %conv283, 0
  br i1 %tobool284, label %if.then285, label %if.end300

if.then285:                                       ; preds = %if.then276
  br label %do.body286

do.body286:                                       ; preds = %if.then285
  br label %do.body287

do.body287:                                       ; preds = %do.body286
  br label %do.end288

do.end288:                                        ; preds = %do.body287
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.125, i64 0, i64 0)) #11
  br label %do.body289

do.body289:                                       ; preds = %do.end288
  br label %do.body290

do.body290:                                       ; preds = %do.body289
  br label %do.end291

do.end291:                                        ; preds = %do.body290
  br label %do.body292

do.body292:                                       ; preds = %do.end291
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 2008, i32 2313, i64 12) #10, !srcloc !61
  br label %do.end293

do.end293:                                        ; preds = %do.body292
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 415) #10, !srcloc !62
  br label %do.body294

do.body294:                                       ; preds = %do.end293
  br label %do.end295

do.end295:                                        ; preds = %do.body294
  br label %do.end296

do.end296:                                        ; preds = %do.end295
  br label %do.body297

do.body297:                                       ; preds = %do.end296
  br label %do.end298

do.end298:                                        ; preds = %do.body297
  br label %do.end299

do.end299:                                        ; preds = %do.end298
  br label %if.end300

if.end300:                                        ; preds = %do.end299, %if.then276
  %126 = load i32, i32* %__ret_warn_on277, align 4
  %tobool302 = icmp ne i32 %126, 0
  %lnot303 = xor i1 %tobool302, true
  %lnot305 = xor i1 %lnot303, true
  %lnot.ext306 = zext i1 %lnot305 to i32
  %conv307 = sext i32 %lnot.ext306 to i64
  store i64 %conv307, i64* %tmp301, align 8
  %127 = load i64, i64* %tmp301, align 8
  br label %if.end308

if.end308:                                        ; preds = %if.end300, %land.end269
  %128 = load i32, i32* %__ret_warn_once263, align 4
  %tobool310 = icmp ne i32 %128, 0
  %lnot311 = xor i1 %tobool310, true
  %lnot313 = xor i1 %lnot311, true
  %lnot.ext314 = zext i1 %lnot313 to i32
  %conv315 = sext i32 %lnot.ext314 to i64
  store i64 %conv315, i64* %tmp309, align 8
  %129 = load i64, i64* %tmp309, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end316:                                        ; preds = %if.end258
  br label %if.end323

if.else317:                                       ; preds = %if.then246
  %130 = load i8, i8* %opcode, align 1
  %conv318 = zext i8 %130 to i32
  %cmp319 = icmp eq i32 %conv318, 144
  br i1 %cmp319, label %if.then321, label %if.end322

if.then321:                                       ; preds = %if.else317
  store i32 -524, i32* %retval, align 4
  br label %return

if.end322:                                        ; preds = %if.else317
  br label %if.end323

if.end323:                                        ; preds = %if.end322, %if.end316
  br label %if.end345

if.else324:                                       ; preds = %lor.lhs.false242
  %131 = load i8, i8* %class, align 1
  %conv325 = zext i8 %131 to i32
  %cmp326 = icmp eq i32 %conv325, 0
  br i1 %cmp326, label %if.then328, label %if.end344

if.then328:                                       ; preds = %if.else324
  %132 = load i32*, i32** %reg_mask.addr, align 8
  %133 = load i32, i32* %132, align 4
  %134 = load i32, i32* %dreg, align 4
  %and329 = and i32 %133, %134
  %tobool330 = icmp ne i32 %and329, 0
  br i1 %tobool330, label %if.end332, label %if.then331

if.then331:                                       ; preds = %if.then328
  store i32 0, i32* %retval, align 4
  br label %return

if.end332:                                        ; preds = %if.then328
  %135 = load i32, i32* %dreg, align 4
  %neg333 = xor i32 %135, -1
  %136 = load i32*, i32** %reg_mask.addr, align 8
  %137 = load i32, i32* %136, align 4
  %and334 = and i32 %137, %neg333
  store i32 %and334, i32* %136, align 4
  %138 = load i8, i8* %mode, align 1
  %conv335 = zext i8 %138 to i32
  %cmp336 = icmp eq i32 %conv335, 64
  br i1 %cmp336, label %if.then342, label %lor.lhs.false338

lor.lhs.false338:                                 ; preds = %if.end332
  %139 = load i8, i8* %mode, align 1
  %conv339 = zext i8 %139 to i32
  %cmp340 = icmp eq i32 %conv339, 32
  br i1 %cmp340, label %if.then342, label %if.end343

if.then342:                                       ; preds = %lor.lhs.false338, %if.end332
  store i32 -524, i32* %retval, align 4
  br label %return

if.end343:                                        ; preds = %lor.lhs.false338
  br label %if.end344

if.end344:                                        ; preds = %if.end343, %if.else324
  br label %if.end345

if.end345:                                        ; preds = %if.end344, %if.end323
  br label %if.end346

if.end346:                                        ; preds = %if.end345, %if.end237
  br label %if.end347

if.end347:                                        ; preds = %if.end346, %if.end129
  br label %if.end348

if.end348:                                        ; preds = %if.end347, %if.end55
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end348, %if.then342, %if.then331, %if.then321, %if.end308, %if.then257, %if.then226, %if.end213, %if.then158, %if.then151, %if.then143, %if.end121, %if.then80, %if.then73, %if.then63, %if.then30, %if.then
  %140 = load i32, i32* %retval, align 4
  ret i32 %140
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_all_scalars_precise(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %func = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc34, %entry
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %tobool = icmp ne %struct.bpf_verifier_state* %0, null
  br i1 %tobool, label %for.body, label %for.end35

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc31, %for.body
  %1 = load i32, i32* %i, align 4
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %1, %3
  br i1 %cmp, label %for.body2, label %for.end33

for.body2:                                        ; preds = %for.cond1
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 0
  %5 = load i32, i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %6, %struct.bpf_func_state** %func, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %for.body2
  %7 = load i32, i32* %j, align 4
  %cmp4 = icmp slt i32 %7, 10
  br i1 %cmp4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond3
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 0
  %9 = load i32, i32* %j, align 4
  %idxprom6 = sext i32 %9 to i64
  %arrayidx7 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom6
  store %struct.bpf_reg_state* %arrayidx7, %struct.bpf_reg_state** %reg, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 0
  %11 = load i32, i32* %type, align 8
  %cmp8 = icmp ne i32 %11, 1
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body5
  br label %for.inc

if.end:                                           ; preds = %for.body5
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 18
  store i8 1, i8* %precise, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %13 = load i32, i32* %j, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond3

for.end:                                          ; preds = %for.cond3
  store i32 0, i32* %j, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc28, %for.end
  %14 = load i32, i32* %j, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 6
  %16 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %16, 8
  %cmp10 = icmp slt i32 %14, %div
  br i1 %cmp10, label %for.body11, label %for.end30

for.body11:                                       ; preds = %for.cond9
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 7
  %18 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %19 = load i32, i32* %j, align 4
  %idxprom12 = sext i32 %19 to i64
  %arrayidx13 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %18, i64 %idxprom12
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx13, i32 0, i32 1
  %arrayidx14 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %20 = load i8, i8* %arrayidx14, align 8
  %conv = zext i8 %20 to i32
  %cmp15 = icmp ne i32 %conv, 1
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.body11
  br label %for.inc28

if.end18:                                         ; preds = %for.body11
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func, align 8
  %stack19 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 7
  %22 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack19, align 8
  %23 = load i32, i32* %j, align 4
  %idxprom20 = sext i32 %23 to i64
  %arrayidx21 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %22, i64 %idxprom20
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx21, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %reg, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type22 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 0
  %25 = load i32, i32* %type22, align 8
  %cmp23 = icmp ne i32 %25, 1
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end18
  br label %for.inc28

if.end26:                                         ; preds = %if.end18
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %precise27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 18
  store i8 1, i8* %precise27, align 4
  br label %for.inc28

for.inc28:                                        ; preds = %if.end26, %if.then25, %if.then17
  %27 = load i32, i32* %j, align 4
  %inc29 = add i32 %27, 1
  store i32 %inc29, i32* %j, align 4
  br label %for.cond9

for.end30:                                        ; preds = %for.cond9
  br label %for.inc31

for.inc31:                                        ; preds = %for.end30
  %28 = load i32, i32* %i, align 4
  %inc32 = add i32 %28, 1
  store i32 %inc32, i32* %i, align 4
  br label %for.cond1

for.end33:                                        ; preds = %for.cond1
  br label %for.inc34

for.inc34:                                        ; preds = %for.end33
  %29 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %parent = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %29, i32 0, i32 1
  %30 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %parent, align 8
  store %struct.bpf_verifier_state* %30, %struct.bpf_verifier_state** %st.addr, align 8
  br label %for.cond

for.end35:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @get_prev_insn_idx(%struct.bpf_verifier_state* noundef %st, i32 noundef %i, i32* noundef %history) #0 {
entry:
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %i.addr = alloca i32, align 4
  %history.addr = alloca i32*, align 8
  %cnt = alloca i32, align 4
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  store i32* %history, i32** %history.addr, align 8
  %0 = load i32*, i32** %history.addr, align 8
  %1 = load i32, i32* %0, align 4
  store i32 %1, i32* %cnt, align 4
  %2 = load i32, i32* %cnt, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  %4 = load %struct.util_est*, %struct.util_est** %jmp_history, align 8
  %5 = load i32, i32* %cnt, align 4
  %sub = sub i32 %5, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %4, i64 %idxprom
  %idx = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 1
  %6 = load i32, i32* %idx, align 4
  %7 = load i32, i32* %i.addr, align 4
  %cmp = icmp eq i32 %6, %7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %jmp_history1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 9
  %9 = load %struct.util_est*, %struct.util_est** %jmp_history1, align 8
  %10 = load i32, i32* %cnt, align 4
  %sub2 = sub i32 %10, 1
  %idxprom3 = zext i32 %sub2 to i64
  %arrayidx4 = getelementptr %struct.util_est, %struct.util_est* %9, i64 %idxprom3
  %prev_idx = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx4, i32 0, i32 0
  %11 = load i32, i32* %prev_idx, align 4
  store i32 %11, i32* %i.addr, align 4
  %12 = load i32*, i32** %history.addr, align 8
  %13 = load i32, i32* %12, align 4
  %dec = add i32 %13, -1
  store i32 %dec, i32* %12, align 4
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %14 = load i32, i32* %i.addr, align 4
  %dec5 = add i32 %14, -1
  store i32 %dec5, i32* %i.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %15 = load i32, i32* %i.addr, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bitmap_from_u64(i64* noundef %dst, i64 noundef %mask) #0 {
entry:
  %dst.addr = alloca i64*, align 8
  %mask.addr = alloca i64, align 8
  store i64* %dst, i64** %dst.addr, align 8
  store i64 %mask, i64* %mask.addr, align 8
  %0 = load i64, i64* %mask.addr, align 8
  %and = and i64 %0, -1
  %1 = load i64*, i64** %dst.addr, align 8
  %arrayidx = getelementptr i64, i64* %1, i64 0
  store i64 %and, i64* %arrayidx, align 8
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @find_first_bit(i64* noundef, i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @find_next_bit(i64* noundef, i64 noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @tnum_is_unknown(i64 %a.coerce0, i64 %a.coerce1) #0 {
entry:
  %a = alloca %struct.tnum, align 8
  %0 = bitcast %struct.tnum* %a to { i64, i64 }*
  %1 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %a.coerce0, i64* %1, align 8
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2, align 8
  %mask = getelementptr inbounds %struct.tnum, %struct.tnum* %a, i32 0, i32 1
  %3 = load i64, i64* %mask, align 8
  %neg = xor i64 %3, -1
  %tobool = icmp ne i64 %neg, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @transfer_reference_state(%struct.bpf_func_state* noundef %dst, %struct.bpf_func_state* noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca %struct.bpf_func_state*, align 8
  %src.addr = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_func_state* %dst, %struct.bpf_func_state** %dst.addr, align 8
  store %struct.bpf_func_state* %src, %struct.bpf_func_state** %src.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 4
  %2 = load i32, i32* %acquired_refs, align 4
  %call = call i32 @realloc_reference_state(%struct.bpf_func_state* noundef %0, i32 noundef %2, i1 noundef zeroext false) #11
  store i32 %call, i32* %err, align 4
  %3 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %err, align 4
  store i32 %4, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %dst.addr, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %src.addr, align 8
  %call1 = call i32 @copy_reference_state(%struct.bpf_func_state* noundef %5, %struct.bpf_func_state* noundef %6) #11
  store i32 %call1, i32* %err, align 4
  %7 = load i32, i32* %err, align 4
  %tobool2 = icmp ne i32 %7, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %8 = load i32, i32* %err, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %9 = load i32, i32* %retval, align 4
  ret i32 %9
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_helper_changes_pkt_data(i8* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_func_proto(%struct.bpf_func_proto* noundef %fn, i32 noundef %func_id) #0 {
entry:
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %func_id.addr = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call = call zeroext i1 @check_raw_mode_ok(%struct.bpf_func_proto* noundef %0) #11
  br i1 %call, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call1 = call zeroext i1 @check_arg_pair_ok(%struct.bpf_func_proto* noundef %1) #11
  br i1 %call1, label %land.lhs.true2, label %land.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %call3 = call zeroext i1 @check_btf_id_ok(%struct.bpf_func_proto* noundef %2) #11
  br i1 %call3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true2
  %3 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %4 = load i32, i32* %func_id.addr, align 4
  %call4 = call zeroext i1 @check_refcount_ok(%struct.bpf_func_proto* noundef %3, i32 noundef %4) #11
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true2, %land.lhs.true, %entry
  %5 = phi i1 [ false, %land.lhs.true2 ], [ false, %land.lhs.true ], [ false, %entry ], [ %call4, %land.rhs ]
  %6 = zext i1 %5 to i64
  %cond = select i1 %5, i32 0, i32 -22
  ret i32 %cond
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_func_arg(%struct.bpf_verifier_env* noundef %env, i32 noundef %arg, %struct.bpf_call_arg_meta* noundef %meta, %struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %arg.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %regno = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %arg_type = alloca i32, align 4
  %type = alloca i32, align 4
  %err = alloca i32, align 4
  %zero_size_allowed = alloca i8, align 1
  %size = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %arg, i32* %arg.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  %0 = load i32, i32* %arg.addr, align 4
  %add = add i32 1, %0
  store i32 %add, i32* %regno, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %1) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %3 = load i32, i32* %regno, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %4 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %5 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %4, i32 0, i32 4
  %arg_type1 = bitcast %union.anon.168* %5 to [5 x i32]*
  %6 = load i32, i32* %arg.addr, align 4
  %idxprom2 = zext i32 %6 to i64
  %arrayidx3 = getelementptr [5 x i32], [5 x i32]* %arg_type1, i64 0, i64 %idxprom2
  %7 = load i32, i32* %arrayidx3, align 4
  store i32 %7, i32* %arg_type, align 4
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 0
  %9 = load i32, i32* %type4, align 8
  store i32 %9, i32* %type, align 4
  store i32 0, i32* %err, align 4
  %10 = load i32, i32* %arg_type, align 4
  %cmp = icmp eq i32 %10, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %regno, align 4
  %call5 = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %11, i32 noundef %12, i32 noundef 0) #11
  store i32 %call5, i32* %err, align 4
  %13 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %14 = load i32, i32* %err, align 4
  store i32 %14, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %15 = load i32, i32* %arg_type, align 4
  %cmp8 = icmp eq i32 %15, 13
  br i1 %cmp8, label %if.then9, label %if.end13

if.then9:                                         ; preds = %if.end7
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = load i32, i32* %regno, align 4
  %call10 = call zeroext i1 @is_pointer_value(%struct.bpf_verifier_env* noundef %16, i32 noundef %17) #11
  br i1 %call10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.then9
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.303, i64 0, i64 0), i32 noundef %20) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.then9
  store i32 0, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end7
  %21 = load i32, i32* %type, align 4
  %call14 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %21) #11
  br i1 %call14, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.end13
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call15 = call zeroext i1 @may_access_direct_pkt_data(%struct.bpf_verifier_env* noundef %22, %struct.bpf_call_arg_meta* noundef %23, i32 noundef 1) #11
  br i1 %call15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %land.lhs.true
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.304, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %land.lhs.true, %if.end13
  %26 = load i32, i32* %arg_type, align 4
  %cmp18 = icmp eq i32 %26, 3
  br i1 %cmp18, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end17
  %27 = load i32, i32* %arg_type, align 4
  %cmp19 = icmp eq i32 %27, 4
  br i1 %cmp19, label %if.then22, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false
  %28 = load i32, i32* %arg_type, align 4
  %cmp21 = icmp eq i32 %28, 5
  br i1 %cmp21, label %if.then22, label %if.end27

if.then22:                                        ; preds = %lor.lhs.false20, %lor.lhs.false, %if.end17
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call23 = call i32 @resolve_map_arg_type(%struct.bpf_verifier_env* noundef %29, %struct.bpf_call_arg_meta* noundef %30, i32* noundef %arg_type) #11
  store i32 %call23, i32* %err, align 4
  %31 = load i32, i32* %err, align 4
  %tobool24 = icmp ne i32 %31, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.then22
  %32 = load i32, i32* %err, align 4
  store i32 %32, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.then22
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %lor.lhs.false20
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call28 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %33) #11
  br i1 %call28, label %land.lhs.true29, label %if.end32

land.lhs.true29:                                  ; preds = %if.end27
  %34 = load i32, i32* %arg_type, align 4
  %call30 = call zeroext i1 @arg_type_may_be_null(i32 noundef %34) #11
  br i1 %call30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %land.lhs.true29
  br label %skip_type_check

if.end32:                                         ; preds = %land.lhs.true29, %if.end27
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = load i32, i32* %regno, align 4
  %37 = load i32, i32* %arg_type, align 4
  %38 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %39 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %38, i32 0, i32 5
  %arg_btf_id = bitcast %union.anon.170* %39 to [5 x i32*]*
  %40 = load i32, i32* %arg.addr, align 4
  %idxprom33 = zext i32 %40 to i64
  %arrayidx34 = getelementptr [5 x i32*], [5 x i32*]* %arg_btf_id, i64 0, i64 %idxprom33
  %41 = load i32*, i32** %arrayidx34, align 8
  %call35 = call i32 @check_reg_type(%struct.bpf_verifier_env* noundef %35, i32 noundef %36, i32 noundef %37, i32* noundef %41) #11
  store i32 %call35, i32* %err, align 4
  %42 = load i32, i32* %err, align 4
  %tobool36 = icmp ne i32 %42, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end32
  %43 = load i32, i32* %err, align 4
  store i32 %43, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.end32
  %44 = load i32, i32* %type, align 4
  %cmp39 = icmp eq i32 %44, 2
  br i1 %cmp39, label %if.then40, label %if.end45

if.then40:                                        ; preds = %if.end38
  %45 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %47 = load i32, i32* %regno, align 4
  %call41 = call i32 @check_ctx_reg(%struct.bpf_verifier_env* noundef %45, %struct.bpf_reg_state* noundef %46, i32 noundef %47) #11
  store i32 %call41, i32* %err, align 4
  %48 = load i32, i32* %err, align 4
  %cmp42 = icmp slt i32 %48, 0
  br i1 %cmp42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.then40
  %49 = load i32, i32* %err, align 4
  store i32 %49, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %if.then40
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %if.end38
  br label %skip_type_check

skip_type_check:                                  ; preds = %if.end45, %if.then31
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 4
  %51 = load i32, i32* %ref_obj_id, align 8
  %tobool46 = icmp ne i32 %51, 0
  br i1 %tobool46, label %if.then47, label %if.end56

if.then47:                                        ; preds = %skip_type_check
  %52 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ref_obj_id48 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %52, i32 0, i32 7
  %53 = load i32, i32* %ref_obj_id48, align 8
  %tobool49 = icmp ne i32 %53, 0
  br i1 %tobool49, label %if.then50, label %if.end53

if.then50:                                        ; preds = %if.then47
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  %56 = load i32, i32* %regno, align 4
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id51 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %57, i32 0, i32 4
  %58 = load i32, i32* %ref_obj_id51, align 8
  %59 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ref_obj_id52 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %59, i32 0, i32 7
  %60 = load i32, i32* %ref_obj_id52, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([70 x i8], [70 x i8]* @.str.305, i64 0, i64 0), i32 noundef %56, i32 noundef %58, i32 noundef %60) #11
  store i32 -14, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %if.then47
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id54 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 4
  %62 = load i32, i32* %ref_obj_id54, align 8
  %63 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ref_obj_id55 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %63, i32 0, i32 7
  store i32 %62, i32* %ref_obj_id55, align 8
  br label %if.end56

if.end56:                                         ; preds = %if.end53, %skip_type_check
  %64 = load i32, i32* %arg_type, align 4
  %cmp57 = icmp eq i32 %64, 1
  br i1 %cmp57, label %if.then58, label %if.else

if.then58:                                        ; preds = %if.end56
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %65, i32 0, i32 1
  %map_ptr = bitcast %struct.bpf_iter_aux_info* %66 to %struct.bpf_map**
  %67 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %68 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr59 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %68, i32 0, i32 0
  store %struct.bpf_map* %67, %struct.bpf_map** %map_ptr59, align 8
  br label %if.end174

if.else:                                          ; preds = %if.end56
  %69 = load i32, i32* %arg_type, align 4
  %cmp60 = icmp eq i32 %69, 2
  br i1 %cmp60, label %if.then61, label %if.else68

if.then61:                                        ; preds = %if.else
  %70 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr62 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %70, i32 0, i32 0
  %71 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr62, align 8
  %tobool63 = icmp ne %struct.bpf_map* %71, null
  br i1 %tobool63, label %if.end65, label %if.then64

if.then64:                                        ; preds = %if.then61
  %72 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %73 = bitcast %struct.bpf_verifier_env* %72 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %73, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.306, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end65:                                         ; preds = %if.then61
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %75 = load i32, i32* %regno, align 4
  %76 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr66 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %76, i32 0, i32 0
  %77 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr66, align 8
  %key_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %77, i32 0, i32 4
  %78 = load i32, i32* %key_size, align 4
  %call67 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %74, i32 noundef %75, i32 noundef %78, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef null) #11
  store i32 %call67, i32* %err, align 4
  br label %if.end173

if.else68:                                        ; preds = %if.else
  %79 = load i32, i32* %arg_type, align 4
  %cmp69 = icmp eq i32 %79, 3
  br i1 %cmp69, label %if.then76, label %lor.lhs.false70

lor.lhs.false70:                                  ; preds = %if.else68
  %80 = load i32, i32* %arg_type, align 4
  %cmp71 = icmp eq i32 %80, 5
  br i1 %cmp71, label %land.lhs.true72, label %lor.lhs.false74

land.lhs.true72:                                  ; preds = %lor.lhs.false70
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call73 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %81) #11
  br i1 %call73, label %lor.lhs.false74, label %if.then76

lor.lhs.false74:                                  ; preds = %land.lhs.true72, %lor.lhs.false70
  %82 = load i32, i32* %arg_type, align 4
  %cmp75 = icmp eq i32 %82, 4
  br i1 %cmp75, label %if.then76, label %if.else84

if.then76:                                        ; preds = %lor.lhs.false74, %land.lhs.true72, %if.else68
  %83 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr77 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %83, i32 0, i32 0
  %84 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr77, align 8
  %tobool78 = icmp ne %struct.bpf_map* %84, null
  br i1 %tobool78, label %if.end80, label %if.then79

if.then79:                                        ; preds = %if.then76
  %85 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %86 = bitcast %struct.bpf_verifier_env* %85 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %86, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.307, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end80:                                         ; preds = %if.then76
  %87 = load i32, i32* %arg_type, align 4
  %cmp81 = icmp eq i32 %87, 4
  %88 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %88, i32 0, i32 1
  %frombool = zext i1 %cmp81 to i8
  store i8 %frombool, i8* %raw_mode, align 8
  %89 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %90 = load i32, i32* %regno, align 4
  %91 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr82 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %91, i32 0, i32 0
  %92 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr82, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %92, i32 0, i32 5
  %93 = load i32, i32* %value_size, align 32
  %94 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call83 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %89, i32 noundef %90, i32 noundef %93, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef %94) #11
  store i32 %call83, i32* %err, align 4
  br label %if.end172

if.else84:                                        ; preds = %lor.lhs.false74
  %95 = load i32, i32* %arg_type, align 4
  %cmp85 = icmp eq i32 %95, 25
  br i1 %cmp85, label %if.then86, label %if.else91

if.then86:                                        ; preds = %if.else84
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %97 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %96, i32 0, i32 1
  %btf_id = bitcast %struct.bpf_iter_aux_info* %97 to i32*
  %98 = load i32, i32* %btf_id, align 8
  %tobool87 = icmp ne i32 %98, 0
  br i1 %tobool87, label %if.end89, label %if.then88

if.then88:                                        ; preds = %if.then86
  %99 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %100 = bitcast %struct.bpf_verifier_env* %99 to i8*
  %101 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %100, i8* noundef getelementptr inbounds ([34 x i8], [34 x i8]* @.str.308, i64 0, i64 0), i32 noundef %101) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end89:                                         ; preds = %if.then86
  %102 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %102, i32 0, i32 1
  %btf_id90 = bitcast %struct.bpf_iter_aux_info* %103 to i32*
  %104 = load i32, i32* %btf_id90, align 8
  %105 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %ret_btf_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %105, i32 0, i32 10
  store i32 %104, i32* %ret_btf_id, align 4
  br label %if.end171

if.else91:                                        ; preds = %if.else84
  %106 = load i32, i32* %arg_type, align 4
  %cmp92 = icmp eq i32 %106, 14
  br i1 %cmp92, label %if.then93, label %if.else111

if.then93:                                        ; preds = %if.else91
  %107 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %func_id = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %107, i32 0, i32 8
  %108 = load i32, i32* %func_id, align 4
  %cmp94 = icmp eq i32 %108, 93
  br i1 %cmp94, label %if.then95, label %if.else100

if.then95:                                        ; preds = %if.then93
  %109 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %110 = load i32, i32* %regno, align 4
  %call96 = call i32 @process_spin_lock(%struct.bpf_verifier_env* noundef %109, i32 noundef %110, i1 noundef zeroext true) #11
  %tobool97 = icmp ne i32 %call96, 0
  br i1 %tobool97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %if.then95
  store i32 -13, i32* %retval, align 4
  br label %return

if.end99:                                         ; preds = %if.then95
  br label %if.end110

if.else100:                                       ; preds = %if.then93
  %111 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %func_id101 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %111, i32 0, i32 8
  %112 = load i32, i32* %func_id101, align 4
  %cmp102 = icmp eq i32 %112, 94
  br i1 %cmp102, label %if.then103, label %if.else108

if.then103:                                       ; preds = %if.else100
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %114 = load i32, i32* %regno, align 4
  %call104 = call i32 @process_spin_lock(%struct.bpf_verifier_env* noundef %113, i32 noundef %114, i1 noundef zeroext false) #11
  %tobool105 = icmp ne i32 %call104, 0
  br i1 %tobool105, label %if.then106, label %if.end107

if.then106:                                       ; preds = %if.then103
  store i32 -13, i32* %retval, align 4
  br label %return

if.end107:                                        ; preds = %if.then103
  br label %if.end109

if.else108:                                       ; preds = %if.else100
  %115 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %116 = bitcast %struct.bpf_verifier_env* %115 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %116, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.309, i64 0, i64 0)) #11
  store i32 -14, i32* %retval, align 4
  br label %return

if.end109:                                        ; preds = %if.end107
  br label %if.end110

if.end110:                                        ; preds = %if.end109, %if.end99
  br label %if.end170

if.else111:                                       ; preds = %if.else91
  %117 = load i32, i32* %arg_type, align 4
  %call112 = call zeroext i1 @arg_type_is_mem_ptr(i32 noundef %117) #11
  br i1 %call112, label %if.then113, label %if.else117

if.then113:                                       ; preds = %if.else111
  %118 = load i32, i32* %arg_type, align 4
  %cmp114 = icmp eq i32 %118, 8
  %119 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode115 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %119, i32 0, i32 1
  %frombool116 = zext i1 %cmp114 to i8
  store i8 %frombool116, i8* %raw_mode115, align 8
  br label %if.end169

if.else117:                                       ; preds = %if.else111
  %120 = load i32, i32* %arg_type, align 4
  %call118 = call zeroext i1 @arg_type_is_mem_size(i32 noundef %120) #11
  br i1 %call118, label %if.then119, label %if.else148

if.then119:                                       ; preds = %if.else117
  %121 = load i32, i32* %arg_type, align 4
  %cmp120 = icmp eq i32 %121, 10
  %frombool121 = zext i1 %cmp120 to i8
  store i8 %frombool121, i8* %zero_size_allowed, align 1
  %122 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %122, i32 0, i32 9
  %123 = load i64, i64* %umax_value, align 8
  %124 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_max_value = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %124, i32 0, i32 6
  store i64 %123, i64* %msize_max_value, align 8
  %125 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %125, i32 0, i32 5
  %126 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %127 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %126, i32 0, i32 0
  %128 = load i64, i64* %127, align 8
  %129 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %126, i32 0, i32 1
  %130 = load i64, i64* %129, align 8
  %call122 = call zeroext i1 @tnum_is_const(i64 %128, i64 %130) #11
  br i1 %call122, label %if.end124, label %if.then123

if.then123:                                       ; preds = %if.then119
  store %struct.bpf_call_arg_meta* null, %struct.bpf_call_arg_meta** %meta.addr, align 8
  br label %if.end124

if.end124:                                        ; preds = %if.then123, %if.then119
  %131 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %131, i32 0, i32 6
  %132 = load i64, i64* %smin_value, align 8
  %cmp125 = icmp slt i64 %132, 0
  br i1 %cmp125, label %if.then126, label %if.end127

if.then126:                                       ; preds = %if.end124
  %133 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %134 = bitcast %struct.bpf_verifier_env* %133 to i8*
  %135 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %134, i8* noundef getelementptr inbounds ([66 x i8], [66 x i8]* @.str.310, i64 0, i64 0), i32 noundef %135) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end127:                                        ; preds = %if.end124
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 8
  %137 = load i64, i64* %umin_value, align 8
  %cmp128 = icmp eq i64 %137, 0
  br i1 %cmp128, label %if.then129, label %if.end135

if.then129:                                       ; preds = %if.end127
  %138 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %139 = load i32, i32* %regno, align 4
  %sub = sub i32 %139, 1
  %140 = load i8, i8* %zero_size_allowed, align 1
  %tobool130 = trunc i8 %140 to i1
  %141 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call131 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %138, i32 noundef %sub, i32 noundef 0, i1 noundef zeroext %tobool130, %struct.bpf_call_arg_meta* noundef %141) #11
  store i32 %call131, i32* %err, align 4
  %142 = load i32, i32* %err, align 4
  %tobool132 = icmp ne i32 %142, 0
  br i1 %tobool132, label %if.then133, label %if.end134

if.then133:                                       ; preds = %if.then129
  %143 = load i32, i32* %err, align 4
  store i32 %143, i32* %retval, align 4
  br label %return

if.end134:                                        ; preds = %if.then129
  br label %if.end135

if.end135:                                        ; preds = %if.end134, %if.end127
  %144 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value136 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %144, i32 0, i32 9
  %145 = load i64, i64* %umax_value136, align 8
  %cmp137 = icmp uge i64 %145, 536870912
  br i1 %cmp137, label %if.then138, label %if.end139

if.then138:                                       ; preds = %if.end135
  %146 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %147 = bitcast %struct.bpf_verifier_env* %146 to i8*
  %148 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %147, i8* noundef getelementptr inbounds ([71 x i8], [71 x i8]* @.str.311, i64 0, i64 0), i32 noundef %148) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end139:                                        ; preds = %if.end135
  %149 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %150 = load i32, i32* %regno, align 4
  %sub140 = sub i32 %150, 1
  %151 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value141 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %151, i32 0, i32 9
  %152 = load i64, i64* %umax_value141, align 8
  %conv = trunc i64 %152 to i32
  %153 = load i8, i8* %zero_size_allowed, align 1
  %tobool142 = trunc i8 %153 to i1
  %154 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call143 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %149, i32 noundef %sub140, i32 noundef %conv, i1 noundef zeroext %tobool142, %struct.bpf_call_arg_meta* noundef %154) #11
  store i32 %call143, i32* %err, align 4
  %155 = load i32, i32* %err, align 4
  %tobool144 = icmp ne i32 %155, 0
  br i1 %tobool144, label %if.end147, label %if.then145

if.then145:                                       ; preds = %if.end139
  %156 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %157 = load i32, i32* %regno, align 4
  %call146 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %156, i32 noundef %157) #11
  store i32 %call146, i32* %err, align 4
  br label %if.end147

if.end147:                                        ; preds = %if.then145, %if.end139
  br label %if.end168

if.else148:                                       ; preds = %if.else117
  %158 = load i32, i32* %arg_type, align 4
  %call149 = call zeroext i1 @arg_type_is_alloc_size(i32 noundef %158) #11
  br i1 %call149, label %if.then150, label %if.else157

if.then150:                                       ; preds = %if.else148
  %159 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off151 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %159, i32 0, i32 5
  %160 = bitcast %struct.tnum* %var_off151 to { i64, i64 }*
  %161 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %160, i32 0, i32 0
  %162 = load i64, i64* %161, align 8
  %163 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %160, i32 0, i32 1
  %164 = load i64, i64* %163, align 8
  %call152 = call zeroext i1 @tnum_is_const(i64 %162, i64 %164) #11
  br i1 %call152, label %if.end154, label %if.then153

if.then153:                                       ; preds = %if.then150
  %165 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %166 = bitcast %struct.bpf_verifier_env* %165 to i8*
  %167 = load i32, i32* %regno, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %166, i8* noundef getelementptr inbounds ([62 x i8], [62 x i8]* @.str.312, i64 0, i64 0), i32 noundef %167) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end154:                                        ; preds = %if.then150
  %168 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off155 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %168, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off155, i32 0, i32 0
  %169 = load i64, i64* %value, align 8
  %conv156 = trunc i64 %169 to i32
  %170 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %mem_size = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %170, i32 0, i32 5
  store i32 %conv156, i32* %mem_size, align 4
  br label %if.end167

if.else157:                                       ; preds = %if.else148
  %171 = load i32, i32* %arg_type, align 4
  %call158 = call zeroext i1 @arg_type_is_int_ptr(i32 noundef %171) #11
  br i1 %call158, label %if.then159, label %if.end166

if.then159:                                       ; preds = %if.else157
  %172 = load i32, i32* %arg_type, align 4
  %call160 = call i32 @int_ptr_type_to_size(i32 noundef %172) #11
  store i32 %call160, i32* %size, align 4
  %173 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %174 = load i32, i32* %regno, align 4
  %175 = load i32, i32* %size, align 4
  %176 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call161 = call i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %173, i32 noundef %174, i32 noundef %175, i1 noundef zeroext false, %struct.bpf_call_arg_meta* noundef %176) #11
  store i32 %call161, i32* %err, align 4
  %177 = load i32, i32* %err, align 4
  %tobool162 = icmp ne i32 %177, 0
  br i1 %tobool162, label %if.then163, label %if.end164

if.then163:                                       ; preds = %if.then159
  %178 = load i32, i32* %err, align 4
  store i32 %178, i32* %retval, align 4
  br label %return

if.end164:                                        ; preds = %if.then159
  %179 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %180 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %181 = load i32, i32* %size, align 4
  %call165 = call i32 @check_ptr_alignment(%struct.bpf_verifier_env* noundef %179, %struct.bpf_reg_state* noundef %180, i32 noundef 0, i32 noundef %181, i1 noundef zeroext true) #11
  store i32 %call165, i32* %err, align 4
  br label %if.end166

if.end166:                                        ; preds = %if.end164, %if.else157
  br label %if.end167

if.end167:                                        ; preds = %if.end166, %if.end154
  br label %if.end168

if.end168:                                        ; preds = %if.end167, %if.end147
  br label %if.end169

if.end169:                                        ; preds = %if.end168, %if.then113
  br label %if.end170

if.end170:                                        ; preds = %if.end169, %if.end110
  br label %if.end171

if.end171:                                        ; preds = %if.end170, %if.end89
  br label %if.end172

if.end172:                                        ; preds = %if.end171, %if.end80
  br label %if.end173

if.end173:                                        ; preds = %if.end172, %if.end65
  br label %if.end174

if.end174:                                        ; preds = %if.end173, %if.then58
  %182 = load i32, i32* %err, align 4
  store i32 %182, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end174, %if.then163, %if.then153, %if.then138, %if.then133, %if.then126, %if.else108, %if.then106, %if.then98, %if.then88, %if.then79, %if.then64, %if.then50, %if.then43, %if.then37, %if.then25, %if.then16, %if.end12, %if.then11, %if.then6, %if.then
  %183 = load i32, i32* %retval, align 4
  ret i32 %183
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @record_func_map(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %func_id, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %func_id.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %map = alloca %struct.bpf_map*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 20
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx, %struct.bpf_insn_aux_data** %aux, align 8
  %3 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %3, i32 0, i32 0
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %4, %struct.bpf_map** %map, align 8
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %5, 12
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp ne i32 %6, 1
  br i1 %cmp1, label %land.lhs.true2, label %if.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %7 = load i32, i32* %func_id.addr, align 4
  %cmp3 = icmp ne i32 %7, 2
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true2
  %8 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp ne i32 %8, 3
  br i1 %cmp5, label %land.lhs.true6, label %if.end

land.lhs.true6:                                   ; preds = %land.lhs.true4
  %9 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp ne i32 %9, 87
  br i1 %cmp7, label %land.lhs.true8, label %if.end

land.lhs.true8:                                   ; preds = %land.lhs.true6
  %10 = load i32, i32* %func_id.addr, align 4
  %cmp9 = icmp ne i32 %10, 88
  br i1 %cmp9, label %land.lhs.true10, label %if.end

land.lhs.true10:                                  ; preds = %land.lhs.true8
  %11 = load i32, i32* %func_id.addr, align 4
  %cmp11 = icmp ne i32 %11, 89
  br i1 %cmp11, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true10
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true10, %land.lhs.true8, %land.lhs.true6, %land.lhs.true4, %land.lhs.true2, %land.lhs.true, %entry
  %12 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %cmp12 = icmp eq %struct.bpf_map* %12, null
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.298, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end
  %15 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %15, i32 0, i32 7
  %16 = load i32, i32* %map_flags, align 8
  %and = and i32 %16, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true15, label %if.end23

land.lhs.true15:                                  ; preds = %if.end14
  %17 = load i32, i32* %func_id.addr, align 4
  %cmp16 = icmp eq i32 %17, 3
  br i1 %cmp16, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true15
  %18 = load i32, i32* %func_id.addr, align 4
  %cmp17 = icmp eq i32 %18, 2
  br i1 %cmp17, label %if.then22, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %lor.lhs.false
  %19 = load i32, i32* %func_id.addr, align 4
  %cmp19 = icmp eq i32 %19, 87
  br i1 %cmp19, label %if.then22, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false18
  %20 = load i32, i32* %func_id.addr, align 4
  %cmp21 = icmp eq i32 %20, 88
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %lor.lhs.false20, %lor.lhs.false18, %lor.lhs.false, %land.lhs.true15
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([26 x i8], [26 x i8]* @.str.347, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %lor.lhs.false20, %if.end14
  %23 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %24 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %23, i32 0, i32 0
  %map_ptr_state = bitcast %struct.atomic64_t* %24 to i64*
  %25 = load i64, i64* %map_ptr_state, align 8
  %and24 = and i64 %25, -2
  %26 = inttoptr i64 %and24 to %struct.bpf_map*
  %tobool25 = icmp ne %struct.bpf_map* %26, null
  br i1 %tobool25, label %if.else, label %if.then26

if.then26:                                        ; preds = %if.end23
  %27 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %28 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr27 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %28, i32 0, i32 0
  %29 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr27, align 8
  %30 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr28 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %30, i32 0, i32 0
  %31 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr28, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %31, i32 0, i32 17
  %32 = load i8, i8* %bypass_spec_v1, align 4
  %tobool29 = trunc i8 %32 to i1
  %lnot = xor i1 %tobool29, true
  call void @bpf_map_ptr_store(%struct.bpf_insn_aux_data* noundef %27, %struct.bpf_map* noundef %29, i1 noundef zeroext %lnot) #11
  br label %if.end40

if.else:                                          ; preds = %if.end23
  %33 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %34 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %33, i32 0, i32 0
  %map_ptr_state30 = bitcast %struct.atomic64_t* %34 to i64*
  %35 = load i64, i64* %map_ptr_state30, align 8
  %and31 = and i64 %35, -2
  %36 = inttoptr i64 %and31 to %struct.bpf_map*
  %37 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr32 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %37, i32 0, i32 0
  %38 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr32, align 8
  %cmp33 = icmp ne %struct.bpf_map* %36, %38
  br i1 %cmp33, label %if.then34, label %if.end39

if.then34:                                        ; preds = %if.else
  %39 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %40 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr35 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %40, i32 0, i32 0
  %41 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr35, align 8
  %bypass_spec_v136 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %41, i32 0, i32 17
  %42 = load i8, i8* %bypass_spec_v136, align 4
  %tobool37 = trunc i8 %42 to i1
  %lnot38 = xor i1 %tobool37, true
  call void @bpf_map_ptr_store(%struct.bpf_insn_aux_data* noundef %39, %struct.bpf_map* noundef inttoptr (i64 -2401263026318485698 to %struct.bpf_map*), i1 noundef zeroext %lnot38) #11
  br label %if.end39

if.end39:                                         ; preds = %if.then34, %if.else
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then26
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end40, %if.then22, %if.then13, %if.then
  %43 = load i32, i32* %retval, align 4
  ret i32 %43
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @record_func_key(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %func_id, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %func_id.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %range = alloca %struct.tnum, align 8
  %val = alloca i64, align 8
  %err = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 20
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  store %struct.bpf_insn_aux_data* %arrayidx, %struct.bpf_insn_aux_data** %aux, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %3) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %4 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %5, %struct.bpf_map** %map, align 8
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %6, 12
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %tobool = icmp ne %struct.bpf_map* %7, null
  br i1 %tobool, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %8 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %8, i32 0, i32 3
  %9 = load i32, i32* %map_type, align 8
  %cmp1 = icmp ne i32 %9, 3
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.298, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %12 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %max_entries = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %12, i32 0, i32 6
  %13 = load i32, i32* %max_entries, align 4
  %sub = sub i32 %13, 1
  %conv = zext i32 %sub to i64
  %call4 = call { i64, i64 } @tnum_range(i64 noundef 0, i64 noundef %conv) #11
  %14 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 0
  %16 = extractvalue { i64, i64 } %call4, 0
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %14, i32 0, i32 1
  %18 = extractvalue { i64, i64 } %call4, 1
  store i64 %18, i64* %17, align 8
  %19 = bitcast %struct.tnum* %range to i8*
  %20 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %19, i8* align 8 %20, i64 16, i1 false)
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i64 3
  store %struct.bpf_reg_state* %arrayidx5, %struct.bpf_reg_state** %reg, align 8
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call6 = call zeroext i1 @register_is_const(%struct.bpf_reg_state* noundef %22) #11
  br i1 %call6, label %lor.lhs.false7, label %if.then9

lor.lhs.false7:                                   ; preds = %if.end3
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 5
  %24 = bitcast %struct.tnum* %range to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = load i64, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = load i64, i64* %27, align 8
  %29 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call8 = call zeroext i1 @tnum_in(i64 %26, i64 %28, i64 %31, i64 %33) #11
  br i1 %call8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %lor.lhs.false7, %if.end3
  %34 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  call void @bpf_map_key_store(%struct.bpf_insn_aux_data* noundef %34, i64 noundef -9223372036854775808) #11
  store i32 0, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %lor.lhs.false7
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call11 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %35, i32 noundef 3) #11
  store i32 %call11, i32* %err, align 4
  %36 = load i32, i32* %err, align 4
  %tobool12 = icmp ne i32 %36, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %37 = load i32, i32* %err, align 4
  store i32 %37, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end10
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off15 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %38, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off15, i32 0, i32 0
  %39 = load i64, i64* %value, align 8
  store i64 %39, i64* %val, align 8
  %40 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call16 = call zeroext i1 @bpf_map_key_unseen(%struct.bpf_insn_aux_data* noundef %40) #11
  br i1 %call16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end14
  %41 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %42 = load i64, i64* %val, align 8
  call void @bpf_map_key_store(%struct.bpf_insn_aux_data* noundef %41, i64 noundef %42) #11
  br label %if.end24

if.else:                                          ; preds = %if.end14
  %43 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call18 = call zeroext i1 @bpf_map_key_poisoned(%struct.bpf_insn_aux_data* noundef %43) #11
  br i1 %call18, label %if.end23, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %44 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %call19 = call i64 @bpf_map_key_immediate(%struct.bpf_insn_aux_data* noundef %44) #11
  %45 = load i64, i64* %val, align 8
  %cmp20 = icmp ne i64 %call19, %45
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true
  %46 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  call void @bpf_map_key_store(%struct.bpf_insn_aux_data* noundef %46, i64 noundef -9223372036854775808) #11
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %land.lhs.true, %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then17
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end24, %if.then13, %if.then9, %if.then2, %if.then
  %47 = load i32, i32* %retval, align 4
  ret i32 %47
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_release_function(i32 noundef %func_id) #0 {
entry:
  %func_id.addr = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %0, 86
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp eq i32 %1, 132
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %2 = load i32, i32* %func_id.addr, align 4
  %cmp2 = icmp eq i32 %2, 133
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %3 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @release_reference(%struct.bpf_verifier_env* noundef %env, i32 noundef %ref_obj_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %ref_obj_id.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %err = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %ref_obj_id, i32* %ref_obj_id.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %2) #11
  %3 = load i32, i32* %ref_obj_id.addr, align 4
  %call1 = call i32 @release_reference_state(%struct.bpf_func_state* noundef %call, i32 noundef %3) #11
  store i32 %call1, i32* %err, align 4
  %4 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i32, i32* %err, align 4
  store i32 %5, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 4
  %8 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %6, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %10, i32 0, i32 0
  %11 = load i32, i32* %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %13 = load i32, i32* %ref_obj_id.addr, align 4
  call void @release_reg_references(%struct.bpf_verifier_env* noundef %9, %struct.bpf_func_state* noundef %12, i32 noundef %13) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, i32* %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_equals_const(i64 %5, i64 %7, i64 noundef 0) #11
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %8
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef, i32 noundef, i32* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_struct(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  %kind = alloca i8, align 1
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 15
  %conv = trunc i32 %and to i8
  store i8 %conv, i8* %kind, align 1
  %2 = load i8, i8* %kind, align 1
  %conv1 = zext i8 %2 to i32
  %cmp = icmp eq i32 %conv1, 4
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %3 = load i8, i8* %kind, align 1
  %conv3 = zext i8 %3 to i32
  %cmp4 = icmp eq i32 %conv3, 5
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp4, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_resolve_size(%struct.btf* noundef, %struct.btf_type* noundef, i32* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_ptr_cast_function(i32 noundef %func_id) #0 {
entry:
  %func_id.addr = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %0, 96
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp eq i32 %1, 95
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %func_id.addr, align 4
  %cmp3 = icmp eq i32 %2, 137
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp eq i32 %3, 136
  br i1 %cmp5, label %lor.end, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp eq i32 %4, 140
  br i1 %cmp7, label %lor.end, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp9 = icmp eq i32 %5, 138
  br i1 %cmp9, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false8
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp10 = icmp eq i32 %6, 139
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false8, %lor.lhs.false6, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %7 = phi i1 [ true, %lor.lhs.false8 ], [ true, %lor.lhs.false6 ], [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp10, %lor.rhs ]
  ret i1 %7
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_acquire_function(i32 noundef %func_id, %struct.bpf_map* noundef %map) #0 {
entry:
  %retval = alloca i1, align 1
  %func_id.addr = alloca i32, align 4
  %map.addr = alloca %struct.bpf_map*, align 8
  %map_type = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %tobool = icmp ne %struct.bpf_map* %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %1, i32 0, i32 3
  %2 = load i32, i32* %map_type1, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %map_type, align 4
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %3, 84
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp2 = icmp eq i32 %4, 85
  br i1 %cmp2, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp4 = icmp eq i32 %5, 99
  br i1 %cmp4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false3
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp6 = icmp eq i32 %6, 131
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false5, %lor.lhs.false3, %lor.lhs.false, %cond.end
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false5
  %7 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp eq i32 %7, 1
  br i1 %cmp7, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %if.end
  %8 = load i32, i32* %map_type, align 4
  %cmp8 = icmp eq i32 %8, 15
  br i1 %cmp8, label %if.then11, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %land.lhs.true
  %9 = load i32, i32* %map_type, align 4
  %cmp10 = icmp eq i32 %9, 18
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %lor.lhs.false9, %land.lhs.true
  store i1 true, i1* %retval, align 1
  br label %return

if.end12:                                         ; preds = %lor.lhs.false9, %if.end
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end12, %if.then11, %if.then
  %10 = load i1, i1* %retval, align 1
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @acquire_reference_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %state = alloca %struct.bpf_func_state*, align 8
  %new_ofs = alloca i32, align 4
  %id = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_func_state* @cur_func(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_func_state* %call, %struct.bpf_func_state** %state, align 8
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 4
  %2 = load i32, i32* %acquired_refs, align 4
  store i32 %2, i32* %new_ofs, align 4
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 4
  %5 = load i32, i32* %acquired_refs1, align 4
  %add = add i32 %5, 1
  %call2 = call i32 @realloc_reference_state(%struct.bpf_func_state* noundef %3, i32 noundef %add, i1 noundef zeroext true) #11
  store i32 %call2, i32* %err, align 4
  %6 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load i32, i32* %err, align 4
  store i32 %7, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 13
  %9 = load i32, i32* %id_gen, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %id_gen, align 4
  store i32 %inc, i32* %id, align 4
  %10 = load i32, i32* %id, align 4
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 5
  %12 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %13 = load i32, i32* %new_ofs, align 4
  %idxprom = sext i32 %13 to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %12, i64 %idxprom
  %id3 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 0
  store i32 %10, i32* %id3, align 4
  %14 = load i32, i32* %insn_idx.addr, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %refs4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 5
  %16 = load %struct.util_est*, %struct.util_est** %refs4, align 8
  %17 = load i32, i32* %new_ofs, align 4
  %idxprom5 = sext i32 %17 to i64
  %arrayidx6 = getelementptr %struct.util_est, %struct.util_est* %16, i64 %idxprom5
  %insn_idx7 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx6, i32 0, i32 1
  store i32 %14, i32* %insn_idx7, align 4
  %18 = load i32, i32* %id, align 4
  store i32 %18, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %19 = load i32, i32* %retval, align 4
  ret i32 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @do_refine_retval_range(%struct.bpf_reg_state* noundef %regs, i32 noundef %ret_type, i32 noundef %func_id, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %ret_type.addr = alloca i32, align 4
  %func_id.addr = alloca i32, align 4
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %ret_reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %ret_type, i32* %ret_type.addr, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i64 0
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %ret_reg, align 8
  %1 = load i32, i32* %ret_type.addr, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp ne i32 %2, 67
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp2 = icmp ne i32 %3, 45
  br i1 %cmp2, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp4 = icmp ne i32 %4, 115
  br i1 %cmp4, label %land.lhs.true5, label %if.end

land.lhs.true5:                                   ; preds = %land.lhs.true3
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp6 = icmp ne i32 %5, 114
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true5, %entry
  br label %return

if.end:                                           ; preds = %land.lhs.true5, %land.lhs.true3, %land.lhs.true, %lor.lhs.false
  %6 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_max_value = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %6, i32 0, i32 6
  %7 = load i64, i64* %msize_max_value, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 7
  store i64 %7, i64* %smax_value, align 8
  %9 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %msize_max_value7 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %9, i32 0, i32 6
  %10 = load i64, i64* %msize_max_value7, align 8
  %conv = trunc i64 %10 to i32
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 11
  store i32 %conv, i32* %s32_max_value, align 4
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  store i64 -4095, i64* %smin_value, align 8
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 10
  store i32 -4095, i32* %s32_min_value, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %14) #11
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %15) #11
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ret_reg, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %16) #11
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_func_compatibility(%struct.bpf_verifier_env* noundef %env, %struct.bpf_map* noundef %map, i32 noundef %func_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  %func_id.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %tobool = icmp ne %struct.bpf_map* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %1, i32 0, i32 3
  %2 = load i32, i32* %map_type, align 8
  switch i32 %2, label %sw.default [
    i32 3, label %sw.bb
    i32 4, label %sw.bb3
    i32 27, label %sw.bb14
    i32 7, label %sw.bb26
    i32 8, label %sw.bb30
    i32 19, label %sw.bb36
    i32 21, label %sw.bb36
    i32 14, label %sw.bb40
    i32 25, label %sw.bb40
    i32 16, label %sw.bb46
    i32 17, label %sw.bb50
    i32 12, label %sw.bb56
    i32 13, label %sw.bb56
    i32 15, label %sw.bb60
    i32 18, label %sw.bb75
    i32 20, label %sw.bb91
    i32 22, label %sw.bb95
    i32 23, label %sw.bb95
    i32 24, label %sw.bb103
    i32 28, label %sw.bb109
  ]

sw.bb:                                            ; preds = %if.end
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %3, 12
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %sw.bb
  br label %error

if.end2:                                          ; preds = %sw.bb
  br label %sw.epilog

sw.bb3:                                           ; preds = %if.end
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp4 = icmp ne i32 %4, 22
  br i1 %cmp4, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %sw.bb3
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp ne i32 %5, 25
  br i1 %cmp5, label %land.lhs.true6, label %if.end13

land.lhs.true6:                                   ; preds = %land.lhs.true
  %6 = load i32, i32* %func_id.addr, align 4
  %cmp7 = icmp ne i32 %6, 111
  br i1 %cmp7, label %land.lhs.true8, label %if.end13

land.lhs.true8:                                   ; preds = %land.lhs.true6
  %7 = load i32, i32* %func_id.addr, align 4
  %cmp9 = icmp ne i32 %7, 55
  br i1 %cmp9, label %land.lhs.true10, label %if.end13

land.lhs.true10:                                  ; preds = %land.lhs.true8
  %8 = load i32, i32* %func_id.addr, align 4
  %cmp11 = icmp ne i32 %8, 121
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %land.lhs.true10
  br label %error

if.end13:                                         ; preds = %land.lhs.true10, %land.lhs.true8, %land.lhs.true6, %land.lhs.true, %sw.bb3
  br label %sw.epilog

sw.bb14:                                          ; preds = %if.end
  %9 = load i32, i32* %func_id.addr, align 4
  %cmp15 = icmp ne i32 %9, 130
  br i1 %cmp15, label %land.lhs.true16, label %if.end25

land.lhs.true16:                                  ; preds = %sw.bb14
  %10 = load i32, i32* %func_id.addr, align 4
  %cmp17 = icmp ne i32 %10, 131
  br i1 %cmp17, label %land.lhs.true18, label %if.end25

land.lhs.true18:                                  ; preds = %land.lhs.true16
  %11 = load i32, i32* %func_id.addr, align 4
  %cmp19 = icmp ne i32 %11, 132
  br i1 %cmp19, label %land.lhs.true20, label %if.end25

land.lhs.true20:                                  ; preds = %land.lhs.true18
  %12 = load i32, i32* %func_id.addr, align 4
  %cmp21 = icmp ne i32 %12, 133
  br i1 %cmp21, label %land.lhs.true22, label %if.end25

land.lhs.true22:                                  ; preds = %land.lhs.true20
  %13 = load i32, i32* %func_id.addr, align 4
  %cmp23 = icmp ne i32 %13, 134
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true22
  br label %error

if.end25:                                         ; preds = %land.lhs.true22, %land.lhs.true20, %land.lhs.true18, %land.lhs.true16, %sw.bb14
  br label %sw.epilog

sw.bb26:                                          ; preds = %if.end
  %14 = load i32, i32* %func_id.addr, align 4
  %cmp27 = icmp ne i32 %14, 27
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %sw.bb26
  br label %error

if.end29:                                         ; preds = %sw.bb26
  br label %sw.epilog

sw.bb30:                                          ; preds = %if.end
  %15 = load i32, i32* %func_id.addr, align 4
  %cmp31 = icmp ne i32 %15, 33
  br i1 %cmp31, label %land.lhs.true32, label %if.end35

land.lhs.true32:                                  ; preds = %sw.bb30
  %16 = load i32, i32* %func_id.addr, align 4
  %cmp33 = icmp ne i32 %16, 37
  br i1 %cmp33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %land.lhs.true32
  br label %error

if.end35:                                         ; preds = %land.lhs.true32, %sw.bb30
  br label %sw.epilog

sw.bb36:                                          ; preds = %if.end, %if.end
  %17 = load i32, i32* %func_id.addr, align 4
  %cmp37 = icmp ne i32 %17, 81
  br i1 %cmp37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %sw.bb36
  br label %error

if.end39:                                         ; preds = %sw.bb36
  br label %sw.epilog

sw.bb40:                                          ; preds = %if.end, %if.end
  %18 = load i32, i32* %func_id.addr, align 4
  %cmp41 = icmp ne i32 %18, 51
  br i1 %cmp41, label %land.lhs.true42, label %if.end45

land.lhs.true42:                                  ; preds = %sw.bb40
  %19 = load i32, i32* %func_id.addr, align 4
  %cmp43 = icmp ne i32 %19, 1
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %land.lhs.true42
  br label %error

if.end45:                                         ; preds = %land.lhs.true42, %sw.bb40
  br label %sw.epilog

sw.bb46:                                          ; preds = %if.end
  %20 = load i32, i32* %func_id.addr, align 4
  %cmp47 = icmp ne i32 %20, 51
  br i1 %cmp47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %sw.bb46
  br label %error

if.end49:                                         ; preds = %sw.bb46
  br label %sw.epilog

sw.bb50:                                          ; preds = %if.end
  %21 = load i32, i32* %func_id.addr, align 4
  %cmp51 = icmp ne i32 %21, 51
  br i1 %cmp51, label %land.lhs.true52, label %if.end55

land.lhs.true52:                                  ; preds = %sw.bb50
  %22 = load i32, i32* %func_id.addr, align 4
  %cmp53 = icmp ne i32 %22, 1
  br i1 %cmp53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %land.lhs.true52
  br label %error

if.end55:                                         ; preds = %land.lhs.true52, %sw.bb50
  br label %sw.epilog

sw.bb56:                                          ; preds = %if.end, %if.end
  %23 = load i32, i32* %func_id.addr, align 4
  %cmp57 = icmp ne i32 %23, 1
  br i1 %cmp57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %sw.bb56
  br label %error

if.end59:                                         ; preds = %sw.bb56
  br label %sw.epilog

sw.bb60:                                          ; preds = %if.end
  %24 = load i32, i32* %func_id.addr, align 4
  %cmp61 = icmp ne i32 %24, 52
  br i1 %cmp61, label %land.lhs.true62, label %if.end74

land.lhs.true62:                                  ; preds = %sw.bb60
  %25 = load i32, i32* %func_id.addr, align 4
  %cmp63 = icmp ne i32 %25, 53
  br i1 %cmp63, label %land.lhs.true64, label %if.end74

land.lhs.true64:                                  ; preds = %land.lhs.true62
  %26 = load i32, i32* %func_id.addr, align 4
  %cmp65 = icmp ne i32 %26, 3
  br i1 %cmp65, label %land.lhs.true66, label %if.end74

land.lhs.true66:                                  ; preds = %land.lhs.true64
  %27 = load i32, i32* %func_id.addr, align 4
  %cmp67 = icmp ne i32 %27, 60
  br i1 %cmp67, label %land.lhs.true68, label %if.end74

land.lhs.true68:                                  ; preds = %land.lhs.true66
  %28 = load i32, i32* %func_id.addr, align 4
  %cmp69 = icmp ne i32 %28, 82
  br i1 %cmp69, label %land.lhs.true70, label %if.end74

land.lhs.true70:                                  ; preds = %land.lhs.true68
  %29 = load i32, i32* %func_id.addr, align 4
  %cmp71 = icmp ne i32 %29, 1
  br i1 %cmp71, label %land.lhs.true72, label %if.end74

land.lhs.true72:                                  ; preds = %land.lhs.true70
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load i32, i32* %func_id.addr, align 4
  %call = call zeroext i1 @may_update_sockmap(%struct.bpf_verifier_env* noundef %30, i32 noundef %31) #11
  br i1 %call, label %if.end74, label %if.then73

if.then73:                                        ; preds = %land.lhs.true72
  br label %error

if.end74:                                         ; preds = %land.lhs.true72, %land.lhs.true70, %land.lhs.true68, %land.lhs.true66, %land.lhs.true64, %land.lhs.true62, %sw.bb60
  br label %sw.epilog

sw.bb75:                                          ; preds = %if.end
  %32 = load i32, i32* %func_id.addr, align 4
  %cmp76 = icmp ne i32 %32, 72
  br i1 %cmp76, label %land.lhs.true77, label %if.end90

land.lhs.true77:                                  ; preds = %sw.bb75
  %33 = load i32, i32* %func_id.addr, align 4
  %cmp78 = icmp ne i32 %33, 70
  br i1 %cmp78, label %land.lhs.true79, label %if.end90

land.lhs.true79:                                  ; preds = %land.lhs.true77
  %34 = load i32, i32* %func_id.addr, align 4
  %cmp80 = icmp ne i32 %34, 3
  br i1 %cmp80, label %land.lhs.true81, label %if.end90

land.lhs.true81:                                  ; preds = %land.lhs.true79
  %35 = load i32, i32* %func_id.addr, align 4
  %cmp82 = icmp ne i32 %35, 71
  br i1 %cmp82, label %land.lhs.true83, label %if.end90

land.lhs.true83:                                  ; preds = %land.lhs.true81
  %36 = load i32, i32* %func_id.addr, align 4
  %cmp84 = icmp ne i32 %36, 82
  br i1 %cmp84, label %land.lhs.true85, label %if.end90

land.lhs.true85:                                  ; preds = %land.lhs.true83
  %37 = load i32, i32* %func_id.addr, align 4
  %cmp86 = icmp ne i32 %37, 1
  br i1 %cmp86, label %land.lhs.true87, label %if.end90

land.lhs.true87:                                  ; preds = %land.lhs.true85
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load i32, i32* %func_id.addr, align 4
  %call88 = call zeroext i1 @may_update_sockmap(%struct.bpf_verifier_env* noundef %38, i32 noundef %39) #11
  br i1 %call88, label %if.end90, label %if.then89

if.then89:                                        ; preds = %land.lhs.true87
  br label %error

if.end90:                                         ; preds = %land.lhs.true87, %land.lhs.true85, %land.lhs.true83, %land.lhs.true81, %land.lhs.true79, %land.lhs.true77, %sw.bb75
  br label %sw.epilog

sw.bb91:                                          ; preds = %if.end
  %40 = load i32, i32* %func_id.addr, align 4
  %cmp92 = icmp ne i32 %40, 82
  br i1 %cmp92, label %if.then93, label %if.end94

if.then93:                                        ; preds = %sw.bb91
  br label %error

if.end94:                                         ; preds = %sw.bb91
  br label %sw.epilog

sw.bb95:                                          ; preds = %if.end, %if.end
  %41 = load i32, i32* %func_id.addr, align 4
  %cmp96 = icmp ne i32 %41, 89
  br i1 %cmp96, label %land.lhs.true97, label %if.end102

land.lhs.true97:                                  ; preds = %sw.bb95
  %42 = load i32, i32* %func_id.addr, align 4
  %cmp98 = icmp ne i32 %42, 88
  br i1 %cmp98, label %land.lhs.true99, label %if.end102

land.lhs.true99:                                  ; preds = %land.lhs.true97
  %43 = load i32, i32* %func_id.addr, align 4
  %cmp100 = icmp ne i32 %43, 87
  br i1 %cmp100, label %if.then101, label %if.end102

if.then101:                                       ; preds = %land.lhs.true99
  br label %error

if.end102:                                        ; preds = %land.lhs.true99, %land.lhs.true97, %sw.bb95
  br label %sw.epilog

sw.bb103:                                         ; preds = %if.end
  %44 = load i32, i32* %func_id.addr, align 4
  %cmp104 = icmp ne i32 %44, 107
  br i1 %cmp104, label %land.lhs.true105, label %if.end108

land.lhs.true105:                                 ; preds = %sw.bb103
  %45 = load i32, i32* %func_id.addr, align 4
  %cmp106 = icmp ne i32 %45, 108
  br i1 %cmp106, label %if.then107, label %if.end108

if.then107:                                       ; preds = %land.lhs.true105
  br label %error

if.end108:                                        ; preds = %land.lhs.true105, %sw.bb103
  br label %sw.epilog

sw.bb109:                                         ; preds = %if.end
  %46 = load i32, i32* %func_id.addr, align 4
  %cmp110 = icmp ne i32 %46, 145
  br i1 %cmp110, label %land.lhs.true111, label %if.end114

land.lhs.true111:                                 ; preds = %sw.bb109
  %47 = load i32, i32* %func_id.addr, align 4
  %cmp112 = icmp ne i32 %47, 146
  br i1 %cmp112, label %if.then113, label %if.end114

if.then113:                                       ; preds = %land.lhs.true111
  br label %error

if.end114:                                        ; preds = %land.lhs.true111, %sw.bb109
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end114, %if.end108, %if.end102, %if.end94, %if.end90, %if.end74, %if.end59, %if.end55, %if.end49, %if.end45, %if.end39, %if.end35, %if.end29, %if.end25, %if.end13, %if.end2
  %48 = load i32, i32* %func_id.addr, align 4
  switch i32 %48, label %sw.default201 [
    i32 12, label %sw.bb115
    i32 22, label %sw.bb125
    i32 25, label %sw.bb125
    i32 55, label %sw.bb125
    i32 111, label %sw.bb125
    i32 121, label %sw.bb125
    i32 27, label %sw.bb130
    i32 37, label %sw.bb135
    i32 33, label %sw.bb135
    i32 51, label %sw.bb140
    i32 52, label %sw.bb154
    i32 60, label %sw.bb154
    i32 53, label %sw.bb154
    i32 72, label %sw.bb159
    i32 71, label %sw.bb159
    i32 70, label %sw.bb159
    i32 81, label %sw.bb164
    i32 82, label %sw.bb172
    i32 89, label %sw.bb183
    i32 88, label %sw.bb183
    i32 87, label %sw.bb183
    i32 107, label %sw.bb191
    i32 108, label %sw.bb191
    i32 145, label %sw.bb196
    i32 146, label %sw.bb196
  ]

sw.bb115:                                         ; preds = %sw.epilog
  %49 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type116 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %49, i32 0, i32 3
  %50 = load i32, i32* %map_type116, align 8
  %cmp117 = icmp ne i32 %50, 3
  br i1 %cmp117, label %if.then118, label %if.end119

if.then118:                                       ; preds = %sw.bb115
  br label %error

if.end119:                                        ; preds = %sw.bb115
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %51, i32 0, i32 26
  %52 = load i32, i32* %subprog_cnt, align 4
  %cmp120 = icmp ugt i32 %52, 1
  br i1 %cmp120, label %land.lhs.true121, label %if.end124

land.lhs.true121:                                 ; preds = %if.end119
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call122 = call zeroext i1 @allow_tail_call_in_subprogs(%struct.bpf_verifier_env* noundef %53) #11
  br i1 %call122, label %if.end124, label %if.then123

if.then123:                                       ; preds = %land.lhs.true121
  %54 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %55 = bitcast %struct.bpf_verifier_env* %54 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %55, i8* noundef getelementptr inbounds ([72 x i8], [72 x i8]* @.str.348, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end124:                                        ; preds = %land.lhs.true121, %if.end119
  br label %sw.epilog202

sw.bb125:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog, %sw.epilog, %sw.epilog
  %56 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type126 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %56, i32 0, i32 3
  %57 = load i32, i32* %map_type126, align 8
  %cmp127 = icmp ne i32 %57, 4
  br i1 %cmp127, label %if.then128, label %if.end129

if.then128:                                       ; preds = %sw.bb125
  br label %error

if.end129:                                        ; preds = %sw.bb125
  br label %sw.epilog202

sw.bb130:                                         ; preds = %sw.epilog
  %58 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type131 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %58, i32 0, i32 3
  %59 = load i32, i32* %map_type131, align 8
  %cmp132 = icmp ne i32 %59, 7
  br i1 %cmp132, label %if.then133, label %if.end134

if.then133:                                       ; preds = %sw.bb130
  br label %error

if.end134:                                        ; preds = %sw.bb130
  br label %sw.epilog202

sw.bb135:                                         ; preds = %sw.epilog, %sw.epilog
  %60 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type136 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %60, i32 0, i32 3
  %61 = load i32, i32* %map_type136, align 8
  %cmp137 = icmp ne i32 %61, 8
  br i1 %cmp137, label %if.then138, label %if.end139

if.then138:                                       ; preds = %sw.bb135
  br label %error

if.end139:                                        ; preds = %sw.bb135
  br label %sw.epilog202

sw.bb140:                                         ; preds = %sw.epilog
  %62 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type141 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %62, i32 0, i32 3
  %63 = load i32, i32* %map_type141, align 8
  %cmp142 = icmp ne i32 %63, 14
  br i1 %cmp142, label %land.lhs.true143, label %if.end153

land.lhs.true143:                                 ; preds = %sw.bb140
  %64 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type144 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %64, i32 0, i32 3
  %65 = load i32, i32* %map_type144, align 8
  %cmp145 = icmp ne i32 %65, 25
  br i1 %cmp145, label %land.lhs.true146, label %if.end153

land.lhs.true146:                                 ; preds = %land.lhs.true143
  %66 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type147 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %66, i32 0, i32 3
  %67 = load i32, i32* %map_type147, align 8
  %cmp148 = icmp ne i32 %67, 16
  br i1 %cmp148, label %land.lhs.true149, label %if.end153

land.lhs.true149:                                 ; preds = %land.lhs.true146
  %68 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type150 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %68, i32 0, i32 3
  %69 = load i32, i32* %map_type150, align 8
  %cmp151 = icmp ne i32 %69, 17
  br i1 %cmp151, label %if.then152, label %if.end153

if.then152:                                       ; preds = %land.lhs.true149
  br label %error

if.end153:                                        ; preds = %land.lhs.true149, %land.lhs.true146, %land.lhs.true143, %sw.bb140
  br label %sw.epilog202

sw.bb154:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %70 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type155 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %70, i32 0, i32 3
  %71 = load i32, i32* %map_type155, align 8
  %cmp156 = icmp ne i32 %71, 15
  br i1 %cmp156, label %if.then157, label %if.end158

if.then157:                                       ; preds = %sw.bb154
  br label %error

if.end158:                                        ; preds = %sw.bb154
  br label %sw.epilog202

sw.bb159:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %72 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type160 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %72, i32 0, i32 3
  %73 = load i32, i32* %map_type160, align 8
  %cmp161 = icmp ne i32 %73, 18
  br i1 %cmp161, label %if.then162, label %if.end163

if.then162:                                       ; preds = %sw.bb159
  br label %error

if.end163:                                        ; preds = %sw.bb159
  br label %sw.epilog202

sw.bb164:                                         ; preds = %sw.epilog
  %74 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type165 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %74, i32 0, i32 3
  %75 = load i32, i32* %map_type165, align 8
  %cmp166 = icmp ne i32 %75, 19
  br i1 %cmp166, label %land.lhs.true167, label %if.end171

land.lhs.true167:                                 ; preds = %sw.bb164
  %76 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type168 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %76, i32 0, i32 3
  %77 = load i32, i32* %map_type168, align 8
  %cmp169 = icmp ne i32 %77, 21
  br i1 %cmp169, label %if.then170, label %if.end171

if.then170:                                       ; preds = %land.lhs.true167
  br label %error

if.end171:                                        ; preds = %land.lhs.true167, %sw.bb164
  br label %sw.epilog202

sw.bb172:                                         ; preds = %sw.epilog
  %78 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type173 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %78, i32 0, i32 3
  %79 = load i32, i32* %map_type173, align 8
  %cmp174 = icmp ne i32 %79, 20
  br i1 %cmp174, label %land.lhs.true175, label %if.end182

land.lhs.true175:                                 ; preds = %sw.bb172
  %80 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type176 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %80, i32 0, i32 3
  %81 = load i32, i32* %map_type176, align 8
  %cmp177 = icmp ne i32 %81, 15
  br i1 %cmp177, label %land.lhs.true178, label %if.end182

land.lhs.true178:                                 ; preds = %land.lhs.true175
  %82 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type179 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %82, i32 0, i32 3
  %83 = load i32, i32* %map_type179, align 8
  %cmp180 = icmp ne i32 %83, 18
  br i1 %cmp180, label %if.then181, label %if.end182

if.then181:                                       ; preds = %land.lhs.true178
  br label %error

if.end182:                                        ; preds = %land.lhs.true178, %land.lhs.true175, %sw.bb172
  br label %sw.epilog202

sw.bb183:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %84 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type184 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %84, i32 0, i32 3
  %85 = load i32, i32* %map_type184, align 8
  %cmp185 = icmp ne i32 %85, 22
  br i1 %cmp185, label %land.lhs.true186, label %if.end190

land.lhs.true186:                                 ; preds = %sw.bb183
  %86 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type187 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %86, i32 0, i32 3
  %87 = load i32, i32* %map_type187, align 8
  %cmp188 = icmp ne i32 %87, 23
  br i1 %cmp188, label %if.then189, label %if.end190

if.then189:                                       ; preds = %land.lhs.true186
  br label %error

if.end190:                                        ; preds = %land.lhs.true186, %sw.bb183
  br label %sw.epilog202

sw.bb191:                                         ; preds = %sw.epilog, %sw.epilog
  %88 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type192 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %88, i32 0, i32 3
  %89 = load i32, i32* %map_type192, align 8
  %cmp193 = icmp ne i32 %89, 24
  br i1 %cmp193, label %if.then194, label %if.end195

if.then194:                                       ; preds = %sw.bb191
  br label %error

if.end195:                                        ; preds = %sw.bb191
  br label %sw.epilog202

sw.bb196:                                         ; preds = %sw.epilog, %sw.epilog
  %90 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type197 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %90, i32 0, i32 3
  %91 = load i32, i32* %map_type197, align 8
  %cmp198 = icmp ne i32 %91, 28
  br i1 %cmp198, label %if.then199, label %if.end200

if.then199:                                       ; preds = %sw.bb196
  br label %error

if.end200:                                        ; preds = %sw.bb196
  br label %sw.epilog202

sw.default201:                                    ; preds = %sw.epilog
  br label %sw.epilog202

sw.epilog202:                                     ; preds = %sw.default201, %if.end200, %if.end195, %if.end190, %if.end182, %if.end171, %if.end163, %if.end158, %if.end153, %if.end139, %if.end134, %if.end129, %if.end124
  store i32 0, i32* %retval, align 4
  br label %return

error:                                            ; preds = %if.then199, %if.then194, %if.then189, %if.then181, %if.then170, %if.then162, %if.then157, %if.then152, %if.then138, %if.then133, %if.then128, %if.then118, %if.then113, %if.then107, %if.then101, %if.then93, %if.then89, %if.then73, %if.then58, %if.then54, %if.then48, %if.then44, %if.then38, %if.then34, %if.then28, %if.then24, %if.then12, %if.then1
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %93 = bitcast %struct.bpf_verifier_env* %92 to i8*
  %94 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type203 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %94, i32 0, i32 3
  %95 = load i32, i32* %map_type203, align 8
  %96 = load i32, i32* %func_id.addr, align 4
  %call204 = call i8* @func_id_name(i32 noundef %96) #11
  %97 = load i32, i32* %func_id.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %93, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.349, i64 0, i64 0), i32 noundef %95, i8* noundef %call204, i32 noundef %97) #11
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %error, %sw.epilog202, %if.then123, %if.then
  %98 = load i32, i32* %retval, align 4
  ret i32 %98
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @get_callchain_buffers(i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 0
  %7 = load i32, i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  call void @__clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %5, %struct.bpf_func_state* noundef %8) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__clear_all_pkt_pointers(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i64 %idxprom
  %call = call zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %arrayidx) #11
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %6 = load i32, i32* %i, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %4, %struct.bpf_reg_state* noundef %5, i32 noundef %6) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %8 = load i32, i32* %i, align 4
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 6
  %10 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %10, 8
  %cmp2 = icmp slt i32 %8, %div
  br i1 %cmp2, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.end
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 7
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %13 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %13 to i64
  %arrayidx4 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom3
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx4, i32 0, i32 1
  %arrayidx5 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %14 = load i8, i8* %arrayidx5, align 8
  %conv = zext i8 %14 to i32
  %cmp6 = icmp eq i32 %conv, 1
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack8 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 7
  %16 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack8, align 8
  %17 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %17 to i64
  %arrayidx10 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %16, i64 %idxprom9
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx10, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond11

for.cond11:                                       ; preds = %cond.end43, %cond.end
  %18 = load i32, i32* %i, align 4
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack12 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 6
  %20 = load i32, i32* %allocated_stack12, align 8
  %div13 = sdiv i32 %20, 8
  %cmp14 = icmp slt i32 %18, %div13
  br i1 %cmp14, label %for.body16, label %for.end45

for.body16:                                       ; preds = %for.cond11
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %21, null
  br i1 %tobool, label %if.end18, label %if.then17

if.then17:                                        ; preds = %for.body16
  br label %for.inc22

if.end18:                                         ; preds = %for.body16
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call19 = call zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %22) #11
  br i1 %call19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end18
  %23 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %23, %struct.bpf_reg_state* noundef %24) #11
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.end18
  br label %for.inc22

for.inc22:                                        ; preds = %if.end21, %if.then17
  %25 = load i32, i32* %i, align 4
  %inc23 = add i32 %25, 1
  store i32 %inc23, i32* %i, align 4
  %26 = load i32, i32* %i, align 4
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack24 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 6
  %28 = load i32, i32* %allocated_stack24, align 8
  %div25 = sdiv i32 %28, 8
  %cmp26 = icmp slt i32 %26, %div25
  br i1 %cmp26, label %land.lhs.true28, label %cond.false42

land.lhs.true28:                                  ; preds = %for.inc22
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack29 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 7
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack29, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom30 = sext i32 %31 to i64
  %arrayidx31 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom30
  %slot_type32 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx31, i32 0, i32 1
  %arrayidx33 = getelementptr [8 x i8], [8 x i8]* %slot_type32, i64 0, i64 0
  %32 = load i8, i8* %arrayidx33, align 8
  %conv34 = zext i8 %32 to i32
  %cmp35 = icmp eq i32 %conv34, 1
  br i1 %cmp35, label %cond.true37, label %cond.false42

cond.true37:                                      ; preds = %land.lhs.true28
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack38 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 7
  %34 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack38, align 8
  %35 = load i32, i32* %i, align 4
  %idxprom39 = sext i32 %35 to i64
  %arrayidx40 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %34, i64 %idxprom39
  %spilled_ptr41 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx40, i32 0, i32 0
  br label %cond.end43

cond.false42:                                     ; preds = %land.lhs.true28, %for.inc22
  br label %cond.end43

cond.end43:                                       ; preds = %cond.false42, %cond.true37
  %cond44 = phi %struct.bpf_reg_state* [ %spilled_ptr41, %cond.true37 ], [ null, %cond.false42 ]
  store %struct.bpf_reg_state* %cond44, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond11

for.end45:                                        ; preds = %for.cond11
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_is_pkt_pointer_any(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %0) #11
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  %2 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %2, 9
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %cmp, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %call = call zeroext i1 @type_is_pkt_pointer(i32 noundef %1) #11
  ret i1 %call
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @type_is_pkt_pointer(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 8
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 7
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_update_sockmap(%struct.bpf_verifier_env* noundef %env, i32 noundef %func_id) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %func_id.addr = alloca i32, align 4
  %eatype = alloca i32, align 4
  %type = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 3
  %2 = load i32, i32* %expected_attach_type, align 8
  store i32 %2, i32* %eatype, align 4
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 2
  %4 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %4) #11
  store i32 %call, i32* %type, align 4
  %5 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp ne i32 %5, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, i32* %type, align 4
  switch i32 %6, label %sw.default [
    i32 26, label %sw.bb
    i32 1, label %sw.bb5
    i32 3, label %sw.bb5
    i32 4, label %sw.bb5
    i32 6, label %sw.bb5
    i32 21, label %sw.bb5
    i32 22, label %sw.bb5
    i32 30, label %sw.bb5
  ]

sw.bb:                                            ; preds = %if.end
  %7 = load i32, i32* %eatype, align 4
  %cmp2 = icmp eq i32 %7, 28
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %sw.bb
  store i1 true, i1* %retval, align 1
  br label %return

if.end4:                                          ; preds = %sw.bb
  br label %sw.epilog

sw.bb5:                                           ; preds = %if.end, %if.end, %if.end, %if.end, %if.end, %if.end, %if.end
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end4
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.350, i64 0, i64 0)) #11
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb5, %if.then3, %if.then
  %10 = load i1, i1* %retval, align 1
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @release_reg_references(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %ref_obj_id) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %ref_obj_id.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %ref_obj_id, i32* %ref_obj_id.addr, align 4
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i64 %idxprom
  %ref_obj_id2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 4
  %4 = load i32, i32* %ref_obj_id2, align 8
  %5 = load i32, i32* %ref_obj_id.addr, align 4
  %cmp3 = icmp eq i32 %4, %5
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %8 = load i32, i32* %i, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %6, %struct.bpf_reg_state* noundef %7, i32 noundef %8) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  %10 = load i32, i32* %i, align 4
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 6
  %12 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %12, 8
  %cmp4 = icmp slt i32 %10, %div
  br i1 %cmp4, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.end
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 7
  %14 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom5 = sext i32 %15 to i64
  %arrayidx6 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %14, i64 %idxprom5
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx6, i32 0, i32 1
  %arrayidx7 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %16 = load i8, i8* %arrayidx7, align 8
  %conv = zext i8 %16 to i32
  %cmp8 = icmp eq i32 %conv, 1
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack10 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 7
  %18 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack10, align 8
  %19 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %19 to i64
  %arrayidx12 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %18, i64 %idxprom11
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx12, i32 0, i32 0
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.bpf_reg_state* [ %spilled_ptr, %cond.true ], [ null, %cond.false ]
  store %struct.bpf_reg_state* %cond, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond13

for.cond13:                                       ; preds = %cond.end47, %cond.end
  %20 = load i32, i32* %i, align 4
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 6
  %22 = load i32, i32* %allocated_stack14, align 8
  %div15 = sdiv i32 %22, 8
  %cmp16 = icmp slt i32 %20, %div15
  br i1 %cmp16, label %for.body18, label %for.end49

for.body18:                                       ; preds = %for.cond13
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %23, null
  br i1 %tobool, label %if.end20, label %if.then19

if.then19:                                        ; preds = %for.body18
  br label %for.inc26

if.end20:                                         ; preds = %for.body18
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %ref_obj_id21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 4
  %25 = load i32, i32* %ref_obj_id21, align 8
  %26 = load i32, i32* %ref_obj_id.addr, align 4
  %cmp22 = icmp eq i32 %25, %26
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end20
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %27, %struct.bpf_reg_state* noundef %28) #11
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.end20
  br label %for.inc26

for.inc26:                                        ; preds = %if.end25, %if.then19
  %29 = load i32, i32* %i, align 4
  %inc27 = add i32 %29, 1
  store i32 %inc27, i32* %i, align 4
  %30 = load i32, i32* %i, align 4
  %31 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %allocated_stack28 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %31, i32 0, i32 6
  %32 = load i32, i32* %allocated_stack28, align 8
  %div29 = sdiv i32 %32, 8
  %cmp30 = icmp slt i32 %30, %div29
  br i1 %cmp30, label %land.lhs.true32, label %cond.false46

land.lhs.true32:                                  ; preds = %for.inc26
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack33 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 7
  %34 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack33, align 8
  %35 = load i32, i32* %i, align 4
  %idxprom34 = sext i32 %35 to i64
  %arrayidx35 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %34, i64 %idxprom34
  %slot_type36 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx35, i32 0, i32 1
  %arrayidx37 = getelementptr [8 x i8], [8 x i8]* %slot_type36, i64 0, i64 0
  %36 = load i8, i8* %arrayidx37, align 8
  %conv38 = zext i8 %36 to i32
  %cmp39 = icmp eq i32 %conv38, 1
  br i1 %cmp39, label %cond.true41, label %cond.false46

cond.true41:                                      ; preds = %land.lhs.true32
  %37 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack42 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %37, i32 0, i32 7
  %38 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack42, align 8
  %39 = load i32, i32* %i, align 4
  %idxprom43 = sext i32 %39 to i64
  %arrayidx44 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %38, i64 %idxprom43
  %spilled_ptr45 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx44, i32 0, i32 0
  br label %cond.end47

cond.false46:                                     ; preds = %land.lhs.true32, %for.inc26
  br label %cond.end47

cond.end47:                                       ; preds = %cond.false46, %cond.true41
  %cond48 = phi %struct.bpf_reg_state* [ %spilled_ptr45, %cond.true41 ], [ null, %cond.false46 ]
  store %struct.bpf_reg_state* %cond48, %struct.bpf_reg_state** %reg, align 8
  br label %for.cond13

for.end49:                                        ; preds = %for.cond13
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @register_is_const(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %5, i64 %7) #11
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %call, %land.rhs ]
  ret i1 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_map_key_store(%struct.bpf_insn_aux_data* noundef %aux, i64 noundef %state) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %state.addr = alloca i64, align 8
  %poisoned = alloca i8, align 1
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store i64 %state, i64* %state.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %call = call zeroext i1 @bpf_map_key_poisoned(%struct.bpf_insn_aux_data* noundef %0) #11
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %poisoned, align 1
  %1 = load i64, i64* %state.addr, align 8
  %or = or i64 %1, 4611686018427387904
  %2 = load i8, i8* %poisoned, align 1
  %tobool = trunc i8 %2 to i1
  %3 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i64 -9223372036854775808, i64 0
  %or1 = or i64 %or, %cond
  %4 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %map_key_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %4, i32 0, i32 1
  store i64 %or1, i64* %map_key_state, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_key_unseen(%struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %map_key_state = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %0, i32 0, i32 1
  %1 = load i64, i64* %map_key_state, align 8
  %and = and i64 %1, 4611686018427387904
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @bpf_map_ptr_store(%struct.bpf_insn_aux_data* noundef %aux, %struct.bpf_map* noundef %map, i1 noundef zeroext %unpriv) #0 {
entry:
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  %unpriv.addr = alloca i8, align 1
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %frombool = zext i1 %unpriv to i8
  store i8 %frombool, i8* %unpriv.addr, align 1
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %call = call zeroext i1 @bpf_map_ptr_unpriv(%struct.bpf_insn_aux_data* noundef %0) #11
  %conv = zext i1 %call to i32
  %1 = load i8, i8* %unpriv.addr, align 1
  %tobool = trunc i8 %1 to i1
  %conv1 = zext i1 %tobool to i32
  %or = or i32 %conv1, %conv
  %tobool2 = icmp ne i32 %or, 0
  %frombool3 = zext i1 %tobool2 to i8
  store i8 %frombool3, i8* %unpriv.addr, align 1
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %3 = ptrtoint %struct.bpf_map* %2 to i64
  %4 = load i8, i8* %unpriv.addr, align 1
  %tobool4 = trunc i8 %4 to i1
  %5 = zext i1 %tobool4 to i64
  %cond = select i1 %tobool4, i64 1, i64 0
  %or6 = or i64 %3, %cond
  %6 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %7 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %6, i32 0, i32 0
  %map_ptr_state = bitcast %struct.atomic64_t* %7 to i64*
  store i64 %or6, i64* %map_ptr_state, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_access_direct_pkt_data(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32 noundef %t) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %t.addr = alloca i32, align 4
  %prog_type = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %1) #11
  store i32 %call, i32* %prog_type, align 4
  %2 = load i32, i32* %prog_type, align 4
  switch i32 %2, label %sw.default [
    i32 10, label %sw.bb
    i32 11, label %sw.bb
    i32 19, label %sw.bb
    i32 21, label %sw.bb
    i32 22, label %sw.bb
    i32 8, label %sw.bb
    i32 3, label %sw.bb1
    i32 4, label %sw.bb1
    i32 6, label %sw.bb1
    i32 12, label %sw.bb1
    i32 14, label %sw.bb1
    i32 16, label %sw.bb1
    i32 25, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry
  %3 = load i32, i32* %t.addr, align 4
  %cmp = icmp eq i32 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.bb1

sw.bb1:                                           ; preds = %if.end, %entry, %entry, %entry, %entry, %entry, %entry
  %4 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool = icmp ne %struct.bpf_call_arg_meta* %4, null
  br i1 %tobool, label %if.then2, label %if.end4

if.then2:                                         ; preds = %sw.bb1
  %5 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %pkt_access = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %5, i32 0, i32 2
  %6 = load i8, i8* %pkt_access, align 1
  %tobool3 = trunc i8 %6 to i1
  store i1 %tobool3, i1* %retval, align 1
  br label %return

if.end4:                                          ; preds = %sw.bb1
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 19
  store i8 1, i8* %seen_direct_write, align 1
  store i1 true, i1* %retval, align 1
  br label %return

sw.bb5:                                           ; preds = %entry
  %8 = load i32, i32* %t.addr, align 4
  %cmp6 = icmp eq i32 %8, 2
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %sw.bb5
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %seen_direct_write8 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 19
  store i8 1, i8* %seen_direct_write8, align 1
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %sw.bb5
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %if.end9, %if.end4, %if.then2, %if.then
  %10 = load i1, i1* %retval, align 1
  ret i1 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @resolve_map_arg_type(%struct.bpf_verifier_env* noundef %env, %struct.bpf_call_arg_meta* noundef %meta, i32* noundef %arg_type) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %arg_type.addr = alloca i32*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  store i32* %arg_type, i32** %arg_type.addr, align 8
  %0 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %0, i32 0, i32 0
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %tobool = icmp ne %struct.bpf_map* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = bitcast %struct.bpf_verifier_env* %2 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %3, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.313, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %map_ptr1 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %4, i32 0, i32 0
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr1, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %5, i32 0, i32 3
  %6 = load i32, i32* %map_type, align 8
  switch i32 %6, label %sw.default [
    i32 15, label %sw.bb
    i32 18, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.end, %if.end
  %7 = load i32*, i32** %arg_type.addr, align 8
  %8 = load i32, i32* %7, align 4
  %cmp = icmp eq i32 %8, 3
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %sw.bb
  %9 = load i32*, i32** %arg_type.addr, align 8
  store i32 24, i32* %9, align 4
  br label %if.end3

if.else:                                          ; preds = %sw.bb
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.314, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.then2
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end3
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.else, %if.then
  %12 = load i32, i32* %retval, align 4
  ret i32 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_may_be_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 5
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 7
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 12
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp5 = icmp eq i32 %3, 19
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false4
  %4 = load i32, i32* %type.addr, align 4
  %cmp6 = icmp eq i32 %4, 22
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp6, %lor.rhs ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_reg_type(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %arg_type, i32* noundef %arg_btf_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %arg_type.addr = alloca i32, align 4
  %arg_btf_id.addr = alloca i32*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %expected = alloca i32, align 4
  %type = alloca i32, align 4
  %compatible = alloca %struct.bpf_reg_types*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %arg_type, i32* %arg_type.addr, align 4
  store i32* %arg_btf_id, i32** %arg_btf_id.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type1, align 8
  store i32 %4, i32* %type, align 4
  %5 = load i32, i32* %arg_type.addr, align 4
  %idxprom2 = zext i32 %5 to i64
  %arrayidx3 = getelementptr [26 x %struct.bpf_reg_types*], [26 x %struct.bpf_reg_types*]* @compatible_reg_types, i64 0, i64 %idxprom2
  %6 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %arrayidx3, align 8
  store %struct.bpf_reg_types* %6, %struct.bpf_reg_types** %compatible, align 8
  %7 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %tobool = icmp ne %struct.bpf_reg_types* %7, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  %10 = load i32, i32* %arg_type.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.315, i64 0, i64 0), i32 noundef %10) #11
  store i32 -14, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %11 = load i32, i32* %i, align 4
  %conv = sext i32 %11 to i64
  %cmp = icmp ult i64 %conv, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %types = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %12, i32 0, i32 0
  %13 = load i32, i32* %i, align 4
  %idxprom5 = sext i32 %13 to i64
  %arrayidx6 = getelementptr [10 x i32], [10 x i32]* %types, i64 0, i64 %idxprom5
  %14 = load i32, i32* %arrayidx6, align 4
  store i32 %14, i32* %expected, align 4
  %15 = load i32, i32* %expected, align 4
  %cmp7 = icmp eq i32 %15, 0
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %for.body
  br label %for.end

if.end10:                                         ; preds = %for.body
  %16 = load i32, i32* %type, align 4
  %17 = load i32, i32* %expected, align 4
  %cmp11 = icmp eq i32 %16, %17
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  br label %found

if.end14:                                         ; preds = %if.end10
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then9, %for.cond
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  %21 = load i32, i32* %regno.addr, align 4
  %22 = load i32, i32* %type, align 4
  %idxprom15 = zext i32 %22 to i64
  %arrayidx16 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom15
  %23 = load i8*, i8** %arrayidx16, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.316, i64 0, i64 0), i32 noundef %21, i8* noundef %23) #11
  store i32 0, i32* %j, align 4
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc26, %for.end
  %24 = load i32, i32* %j, align 4
  %add = add i32 %24, 1
  %25 = load i32, i32* %i, align 4
  %cmp18 = icmp slt i32 %add, %25
  br i1 %cmp18, label %for.body20, label %for.end28

for.body20:                                       ; preds = %for.cond17
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %types21 = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %28, i32 0, i32 0
  %29 = load i32, i32* %j, align 4
  %idxprom22 = sext i32 %29 to i64
  %arrayidx23 = getelementptr [10 x i32], [10 x i32]* %types21, i64 0, i64 %idxprom22
  %30 = load i32, i32* %arrayidx23, align 4
  %idxprom24 = zext i32 %30 to i64
  %arrayidx25 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom24
  %31 = load i8*, i8** %arrayidx25, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.317, i64 0, i64 0), i8* noundef %31) #11
  br label %for.inc26

for.inc26:                                        ; preds = %for.body20
  %32 = load i32, i32* %j, align 4
  %inc27 = add i32 %32, 1
  store i32 %inc27, i32* %j, align 4
  br label %for.cond17

for.end28:                                        ; preds = %for.cond17
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  %35 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %types29 = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %35, i32 0, i32 0
  %36 = load i32, i32* %j, align 4
  %idxprom30 = sext i32 %36 to i64
  %arrayidx31 = getelementptr [10 x i32], [10 x i32]* %types29, i64 0, i64 %idxprom30
  %37 = load i32, i32* %arrayidx31, align 4
  %idxprom32 = zext i32 %37 to i64
  %arrayidx33 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom32
  %38 = load i8*, i8** %arrayidx33, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.89, i64 0, i64 0), i8* noundef %38) #11
  store i32 -13, i32* %retval, align 4
  br label %return

found:                                            ; preds = %if.then13
  %39 = load i32, i32* %type, align 4
  %cmp34 = icmp eq i32 %39, 19
  br i1 %cmp34, label %if.then36, label %if.end56

if.then36:                                        ; preds = %found
  %40 = load i32*, i32** %arg_btf_id.addr, align 8
  %tobool37 = icmp ne i32* %40, null
  br i1 %tobool37, label %if.end43, label %if.then38

if.then38:                                        ; preds = %if.then36
  %41 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %btf_id = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %41, i32 0, i32 1
  %42 = load i32*, i32** %btf_id, align 8
  %tobool39 = icmp ne i32* %42, null
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.then38
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = bitcast %struct.bpf_verifier_env* %43 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %44, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.318, i64 0, i64 0)) #11
  store i32 -14, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.then38
  %45 = load %struct.bpf_reg_types*, %struct.bpf_reg_types** %compatible, align 8
  %btf_id42 = getelementptr inbounds %struct.bpf_reg_types, %struct.bpf_reg_types* %45, i32 0, i32 1
  %46 = load i32*, i32** %btf_id42, align 8
  store i32* %46, i32** %arg_btf_id.addr, align 8
  br label %if.end43

if.end43:                                         ; preds = %if.end41, %if.then36
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %47, i32 0, i32 22
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 2
  %49 = load i32, i32* %off, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %51 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %50, i32 0, i32 1
  %btf_id44 = bitcast %struct.bpf_iter_aux_info* %51 to i32*
  %52 = load i32, i32* %btf_id44, align 8
  %53 = load i32*, i32** %arg_btf_id.addr, align 8
  %54 = load i32, i32* %53, align 4
  %call45 = call zeroext i1 @btf_struct_ids_match(%struct.bpf_verifier_log* noundef %log, i32 noundef %49, i32 noundef %52, i32 noundef %54) #11
  br i1 %call45, label %if.end50, label %if.then46

if.then46:                                        ; preds = %if.end43
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = bitcast %struct.bpf_verifier_env* %55 to i8*
  %57 = load i32, i32* %regno.addr, align 4
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %59 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %58, i32 0, i32 1
  %btf_id47 = bitcast %struct.bpf_iter_aux_info* %59 to i32*
  %60 = load i32, i32* %btf_id47, align 8
  %call48 = call i8* @kernel_type_name(i32 noundef %60) #11
  %61 = load i32*, i32** %arg_btf_id.addr, align 8
  %62 = load i32, i32* %61, align 4
  %call49 = call i8* @kernel_type_name(i32 noundef %62) #11
  call void (i8*, i8*, ...) @verbose(i8* noundef %56, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.319, i64 0, i64 0), i32 noundef %57, i8* noundef %call48, i8* noundef %call49) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end50:                                         ; preds = %if.end43
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %63, i32 0, i32 5
  %64 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %65 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %64, i32 0, i32 0
  %66 = load i64, i64* %65, align 8
  %67 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %64, i32 0, i32 1
  %68 = load i64, i64* %67, align 8
  %call51 = call zeroext i1 @tnum_is_const(i64 %66, i64 %68) #11
  br i1 %call51, label %lor.lhs.false, label %if.then54

lor.lhs.false:                                    ; preds = %if.end50
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off52 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %69, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off52, i32 0, i32 0
  %70 = load i64, i64* %value, align 8
  %tobool53 = icmp ne i64 %70, 0
  br i1 %tobool53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %lor.lhs.false, %if.end50
  %71 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %72 = bitcast %struct.bpf_verifier_env* %71 to i8*
  %73 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %72, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.320, i64 0, i64 0), i32 noundef %73) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end55:                                         ; preds = %lor.lhs.false
  br label %if.end56

if.end56:                                         ; preds = %if.end55, %found
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end56, %if.then54, %if.then46, %if.then40, %for.end28, %if.then
  %74 = load i32, i32* %retval, align 4
  ret i32 %74
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_helper_mem_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %access_size, i1 noundef zeroext %zero_size_allowed, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %access_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %access_size, i32* %access_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 0
  %4 = load i32, i32* %type, align 8
  switch i32 %4, label %sw.default [
    i32 8, label %sw.bb
    i32 7, label %sw.bb
    i32 4, label %sw.bb2
    i32 21, label %sw.bb11
    i32 23, label %sw.bb15
    i32 25, label %sw.bb24
    i32 6, label %sw.bb30
  ]

sw.bb:                                            ; preds = %entry, %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load i32, i32* %regno.addr, align 4
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 2
  %8 = load i32, i32* %off, align 8
  %9 = load i32, i32* %access_size.addr, align 4
  %10 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %10 to i1
  %call1 = call i32 @check_packet_access(%struct.bpf_verifier_env* noundef %5, i32 noundef %6, i32 noundef %8, i32 noundef %9, i1 noundef zeroext %tobool) #11
  store i32 %call1, i32* %retval, align 4
  br label %return

sw.bb2:                                           ; preds = %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 2
  %14 = load i32, i32* %off3, align 8
  %15 = load i32, i32* %access_size.addr, align 4
  %16 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool4 = icmp ne %struct.bpf_call_arg_meta* %16, null
  br i1 %tobool4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %sw.bb2
  %17 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %17, i32 0, i32 1
  %18 = load i8, i8* %raw_mode, align 8
  %tobool5 = trunc i8 %18 to i1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %sw.bb2
  %19 = phi i1 [ false, %sw.bb2 ], [ %tobool5, %land.rhs ]
  %20 = zext i1 %19 to i64
  %cond = select i1 %19, i32 2, i32 1
  %call6 = call i32 @check_map_access_type(%struct.bpf_verifier_env* noundef %11, i32 noundef %12, i32 noundef %14, i32 noundef %15, i32 noundef %cond) #11
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.end
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = load i32, i32* %regno.addr, align 4
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 2
  %24 = load i32, i32* %off8, align 8
  %25 = load i32, i32* %access_size.addr, align 4
  %26 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool9 = trunc i8 %26 to i1
  %call10 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %21, i32 noundef %22, i32 noundef %24, i32 noundef %25, i1 noundef zeroext %tobool9) #11
  store i32 %call10, i32* %retval, align 4
  br label %return

sw.bb11:                                          ; preds = %entry
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load i32, i32* %regno.addr, align 4
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 2
  %30 = load i32, i32* %off12, align 8
  %31 = load i32, i32* %access_size.addr, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 1
  %mem_size = bitcast %struct.bpf_iter_aux_info* %33 to i32*
  %34 = load i32, i32* %mem_size, align 8
  %35 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool13 = trunc i8 %35 to i1
  %call14 = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %27, i32 noundef %28, i32 noundef %30, i32 noundef %31, i32 noundef %34, i1 noundef zeroext %tobool13) #11
  store i32 %call14, i32* %retval, align 4
  br label %return

sw.bb15:                                          ; preds = %entry
  %36 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool16 = icmp ne %struct.bpf_call_arg_meta* %36, null
  br i1 %tobool16, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %sw.bb15
  %37 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode17 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %37, i32 0, i32 1
  %38 = load i8, i8* %raw_mode17, align 8
  %tobool18 = trunc i8 %38 to i1
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true
  store i32 -13, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %land.lhs.true, %sw.bb15
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %41 = load i32, i32* %regno.addr, align 4
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 2
  %43 = load i32, i32* %off21, align 8
  %44 = load i32, i32* %access_size.addr, align 4
  %45 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool22 = trunc i8 %45 to i1
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %46, i32 0, i32 2
  %47 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %47, i32 0, i32 7
  %48 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_rdonly_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %48, i32 0, i32 11
  %call23 = call i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %39, %struct.bpf_reg_state* noundef %40, i32 noundef %41, i32 noundef %43, i32 noundef %44, i1 noundef zeroext %tobool22, i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str.213, i64 0, i64 0), i32* noundef %max_rdonly_access) #11
  store i32 %call23, i32* %retval, align 4
  br label %return

sw.bb24:                                          ; preds = %entry
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %51 = load i32, i32* %regno.addr, align 4
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %52, i32 0, i32 2
  %53 = load i32, i32* %off25, align 8
  %54 = load i32, i32* %access_size.addr, align 4
  %55 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool26 = trunc i8 %55 to i1
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %56, i32 0, i32 2
  %57 = load %struct.bpf_prog*, %struct.bpf_prog** %prog27, align 8
  %aux28 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %57, i32 0, i32 7
  %58 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux28, align 8
  %max_rdwr_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %58, i32 0, i32 12
  %call29 = call i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %49, %struct.bpf_reg_state* noundef %50, i32 noundef %51, i32 noundef %53, i32 noundef %54, i1 noundef zeroext %tobool26, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.214, i64 0, i64 0), i32* noundef %max_rdwr_access) #11
  store i32 %call29, i32* %retval, align 4
  br label %return

sw.bb30:                                          ; preds = %entry
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = load i32, i32* %regno.addr, align 4
  %61 = load i32, i32* %access_size.addr, align 4
  %62 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool31 = trunc i8 %62 to i1
  %63 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %call32 = call i32 @check_stack_boundary(%struct.bpf_verifier_env* noundef %59, i32 noundef %60, i32 noundef %61, i1 noundef zeroext %tobool31, %struct.bpf_call_arg_meta* noundef %63) #11
  store i32 %call32, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  %64 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool33 = trunc i8 %64 to i1
  br i1 %tobool33, label %land.lhs.true34, label %if.end38

land.lhs.true34:                                  ; preds = %sw.default
  %65 = load i32, i32* %access_size.addr, align 4
  %cmp = icmp eq i32 %65, 0
  br i1 %cmp, label %land.lhs.true35, label %if.end38

land.lhs.true35:                                  ; preds = %land.lhs.true34
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call36 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %66) #11
  br i1 %call36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %land.lhs.true35
  store i32 0, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %land.lhs.true35, %land.lhs.true34, %sw.default
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %68 = bitcast %struct.bpf_verifier_env* %67 to i8*
  %69 = load i32, i32* %regno.addr, align 4
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type39 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 0
  %71 = load i32, i32* %type39, align 8
  %idxprom40 = zext i32 %71 to i64
  %arrayidx41 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom40
  %72 = load i8*, i8** %arrayidx41, align 8
  %73 = load i8*, i8** getelementptr inbounds ([28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 6), align 16
  call void (i8*, i8*, ...) @verbose(i8* noundef %68, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.329, i64 0, i64 0), i32 noundef %69, i8* noundef %72, i8* noundef %73) #11
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end38, %if.then37, %sw.bb30, %sw.bb24, %if.end20, %if.then19, %sw.bb11, %if.end, %if.then, %sw.bb
  %74 = load i32, i32* %retval, align 4
  ret i32 %74
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @process_spin_lock(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i1 noundef zeroext %is_lock) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %is_lock.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %is_const = alloca i8, align 1
  %map = alloca %struct.bpf_map*, align 8
  %val = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %frombool = zext i1 %is_lock to i8
  store i8 %frombool, i8* %is_lock.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 8
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %4, %struct.bpf_verifier_state** %cur, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 5
  %6 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = load i64, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = load i64, i64* %9, align 8
  %call1 = call zeroext i1 @tnum_is_const(i64 %8, i64 %10) #11
  %frombool2 = zext i1 %call1 to i8
  store i8 %frombool2, i8* %is_const, align 1
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 1
  %map_ptr = bitcast %struct.bpf_iter_aux_info* %12 to %struct.bpf_map**
  %13 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %13, %struct.bpf_map** %map, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off3, i32 0, i32 0
  %15 = load i64, i64* %value, align 8
  store i64 %15, i64* %val, align 8
  %16 = load i8, i8* %is_const, align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  %19 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([82 x i8], [82 x i8]* @.str.338, i64 0, i64 0), i32 noundef %19) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %20 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %btf = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %20, i32 0, i32 13
  %21 = load %struct.btf*, %struct.btf** %btf, align 64
  %tobool4 = icmp ne %struct.btf* %21, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  %24 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %24, i32 0, i32 15
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %name, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.339, i64 0, i64 0), i8* noundef %arraydecay) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %25 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call7 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %25) #11
  br i1 %call7, label %if.end22, label %if.then8

if.then8:                                         ; preds = %if.end6
  %26 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %26, i32 0, i32 8
  %27 = load i32, i32* %spin_lock_off, align 4
  %cmp = icmp eq i32 %27, -7
  br i1 %cmp, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then8
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  %30 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name10 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %30, i32 0, i32 15
  %arraydecay11 = getelementptr inbounds [16 x i8], [16 x i8]* %name10, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.340, i64 0, i64 0), i8* noundef %arraydecay11) #11
  br label %if.end21

if.else:                                          ; preds = %if.then8
  %31 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off12 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %31, i32 0, i32 8
  %32 = load i32, i32* %spin_lock_off12, align 4
  %cmp13 = icmp eq i32 %32, -2
  br i1 %cmp13, label %if.then14, label %if.else17

if.then14:                                        ; preds = %if.else
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  %35 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name15 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %35, i32 0, i32 15
  %arraydecay16 = getelementptr inbounds [16 x i8], [16 x i8]* %name15, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.341, i64 0, i64 0), i8* noundef %arraydecay16) #11
  br label %if.end20

if.else17:                                        ; preds = %if.else
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = bitcast %struct.bpf_verifier_env* %36 to i8*
  %38 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %name18 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %38, i32 0, i32 15
  %arraydecay19 = getelementptr inbounds [16 x i8], [16 x i8]* %name18, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %37, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.342, i64 0, i64 0), i8* noundef %arraydecay19) #11
  br label %if.end20

if.end20:                                         ; preds = %if.else17, %if.then14
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then9
  store i32 -22, i32* %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end6
  %39 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off23 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %39, i32 0, i32 8
  %40 = load i32, i32* %spin_lock_off23, align 4
  %conv = sext i32 %40 to i64
  %41 = load i64, i64* %val, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 2
  %43 = load i32, i32* %off, align 8
  %conv24 = sext i32 %43 to i64
  %add = add i64 %41, %conv24
  %cmp25 = icmp ne i64 %conv, %add
  br i1 %cmp25, label %if.then27, label %if.end31

if.then27:                                        ; preds = %if.end22
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = bitcast %struct.bpf_verifier_env* %44 to i8*
  %46 = load i64, i64* %val, align 8
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %47, i32 0, i32 2
  %48 = load i32, i32* %off28, align 8
  %conv29 = sext i32 %48 to i64
  %add30 = add i64 %46, %conv29
  call void (i8*, i8*, ...) @verbose(i8* noundef %45, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.343, i64 0, i64 0), i64 noundef %add30) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end22
  %49 = load i8, i8* %is_lock.addr, align 1
  %tobool32 = trunc i8 %49 to i1
  br i1 %tobool32, label %if.then33, label %if.else38

if.then33:                                        ; preds = %if.end31
  %50 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %50, i32 0, i32 5
  %51 = load i32, i32* %active_spin_lock, align 4
  %tobool34 = icmp ne i32 %51, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then33
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = bitcast %struct.bpf_verifier_env* %52 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %53, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.344, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.then33
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %54, i32 0, i32 3
  %55 = load i32, i32* %id, align 4
  %56 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock37 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %56, i32 0, i32 5
  store i32 %55, i32* %active_spin_lock37, align 4
  br label %if.end50

if.else38:                                        ; preds = %if.end31
  %57 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock39 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %57, i32 0, i32 5
  %58 = load i32, i32* %active_spin_lock39, align 4
  %tobool40 = icmp ne i32 %58, 0
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.else38
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %60 = bitcast %struct.bpf_verifier_env* %59 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %60, i8* noundef getelementptr inbounds ([39 x i8], [39 x i8]* @.str.345, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end42:                                         ; preds = %if.else38
  %61 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock43 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %61, i32 0, i32 5
  %62 = load i32, i32* %active_spin_lock43, align 4
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id44 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %63, i32 0, i32 3
  %64 = load i32, i32* %id44, align 4
  %cmp45 = icmp ne i32 %62, %64
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end42
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %66 = bitcast %struct.bpf_verifier_env* %65 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %66, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.346, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.end42
  %67 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %active_spin_lock49 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %67, i32 0, i32 5
  store i32 0, i32* %active_spin_lock49, align 4
  br label %if.end50

if.end50:                                         ; preds = %if.end48, %if.end36
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end50, %if.then47, %if.then41, %if.then35, %if.then27, %if.end21, %if.then5, %if.then
  %68 = load i32, i32* %retval, align 4
  ret i32 %68
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_mem_ptr(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 6
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 7
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp2 = icmp eq i32 %2, 8
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %3 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_mem_size(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 9
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 10
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_alloc_size(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 23
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_is_int_ptr(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 16
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 17
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %cmp1, %lor.rhs ]
  ret i1 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @int_ptr_type_to_size(i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 4, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 17
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  store i32 8, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %2 = load i32, i32* %retval, align 4
  ret i32 %2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ptr_alignment(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %strict_alignment_once) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %strict_alignment_once.addr = alloca i8, align 1
  %strict = alloca i8, align 1
  %pointer_desc = alloca i8*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %strict_alignment_once to i8
  store i8 %frombool, i8* %strict_alignment_once.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %strict_alignment = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 6
  %1 = load i8, i8* %strict_alignment, align 4
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load i8, i8* %strict_alignment_once.addr, align 1
  %tobool1 = trunc i8 %2 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %3 = phi i1 [ true, %entry ], [ %tobool1, %lor.rhs ]
  %frombool2 = zext i1 %3 to i8
  store i8 %frombool2, i8* %strict, align 1
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.98, i64 0, i64 0), i8** %pointer_desc, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 0
  %5 = load i32, i32* %type, align 8
  switch i32 %5, label %sw.default [
    i32 8, label %sw.bb
    i32 7, label %sw.bb
    i32 10, label %sw.bb4
    i32 4, label %sw.bb5
    i32 2, label %sw.bb6
    i32 6, label %sw.bb7
    i32 11, label %sw.bb8
    i32 13, label %sw.bb9
    i32 15, label %sw.bb10
    i32 18, label %sw.bb11
  ]

sw.bb:                                            ; preds = %lor.end, %lor.end
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %8 = load i32, i32* %off.addr, align 4
  %9 = load i32, i32* %size.addr, align 4
  %10 = load i8, i8* %strict, align 1
  %tobool3 = trunc i8 %10 to i1
  %call = call i32 @check_pkt_ptr_alignment(%struct.bpf_verifier_env* noundef %6, %struct.bpf_reg_state* noundef %7, i32 noundef %8, i32 noundef %9, i1 noundef zeroext %tobool3) #11
  store i32 %call, i32* %retval, align 4
  br label %return

sw.bb4:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.216, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb5:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.217, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.218, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb7:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.219, i64 0, i64 0), i8** %pointer_desc, align 8
  store i8 1, i8* %strict, align 1
  br label %sw.epilog

sw.bb8:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.220, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb9:                                           ; preds = %lor.end
  store i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.221, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb10:                                          ; preds = %lor.end
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.222, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %lor.end
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.223, i64 0, i64 0), i8** %pointer_desc, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %lor.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %13 = load i8*, i8** %pointer_desc, align 8
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  %16 = load i8, i8* %strict, align 1
  %tobool12 = trunc i8 %16 to i1
  %call13 = call i32 @check_generic_ptr_alignment(%struct.bpf_verifier_env* noundef %11, %struct.bpf_reg_state* noundef %12, i8* noundef %13, i32 noundef %14, i32 noundef %15, i1 noundef zeroext %tobool12) #11
  store i32 %call13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb
  %17 = load i32, i32* %retval, align 4
  ret i32 %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_pkt_ptr_alignment(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %strict) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %strict.addr = alloca i8, align 1
  %reg_off = alloca %struct.tnum, align 8
  %ip_align = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %strict to i8
  store i8 %frombool, i8* %strict.addr, align 1
  %0 = load i8, i8* %strict.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i32 2, i32* %ip_align, align 4
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = load i32, i32* %ip_align, align 4
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 2
  %5 = load i32, i32* %off1, align 8
  %add = add i32 %3, %5
  %6 = load i32, i32* %off.addr, align 4
  %add2 = add i32 %add, %6
  %conv = sext i32 %add2 to i64
  %call = call { i64, i64 } @tnum_const(i64 noundef %conv) #11
  %7 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = extractvalue { i64, i64 } %call, 0
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = extractvalue { i64, i64 } %call, 1
  store i64 %11, i64* %10, align 8
  %12 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = load i64, i64* %13, align 8
  %15 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = load i64, i64* %15, align 8
  %17 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %18 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = load i64, i64* %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = load i64, i64* %20, align 8
  %call3 = call { i64, i64 } @tnum_add(i64 %14, i64 %16, i64 %19, i64 %21) #11
  %22 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %23 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %22, i32 0, i32 0
  %24 = extractvalue { i64, i64 } %call3, 0
  store i64 %24, i64* %23, align 8
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %22, i32 0, i32 1
  %26 = extractvalue { i64, i64 } %call3, 1
  store i64 %26, i64* %25, align 8
  %27 = bitcast %struct.tnum* %reg_off to i8*
  %28 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %27, i8* align 8 %28, i64 16, i1 false)
  %29 = load i32, i32* %size.addr, align 4
  %conv4 = sext i32 %29 to i64
  %30 = bitcast %struct.tnum* %reg_off to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = load i64, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = load i64, i64* %33, align 8
  %call5 = call zeroext i1 @tnum_is_aligned(i64 %32, i64 %34, i64 noundef %conv4) #11
  br i1 %call5, label %if.end11, label %if.then6

if.then6:                                         ; preds = %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 5
  %36 = bitcast %struct.tnum* %var_off7 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call8 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %38, i64 %40) #11
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load i32, i32* %ip_align, align 4
  %arraydecay9 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 2
  %45 = load i32, i32* %off10, align 8
  %46 = load i32, i32* %off.addr, align 4
  %47 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.224, i64 0, i64 0), i32 noundef %43, i8* noundef %arraydecay9, i32 noundef %45, i32 noundef %46, i32 noundef %47) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then6, %if.then
  %48 = load i32, i32* %retval, align 4
  ret i32 %48
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_generic_ptr_alignment(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i8* noundef %pointer_desc, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %strict) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %pointer_desc.addr = alloca i8*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %strict.addr = alloca i8, align 1
  %reg_off = alloca %struct.tnum, align 8
  %tmp = alloca %struct.tnum, align 8
  %agg.tmp = alloca %struct.tnum, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i8* %pointer_desc, i8** %pointer_desc.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %strict to i8
  store i8 %frombool, i8* %strict.addr, align 1
  %0 = load i8, i8* %strict.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 5
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 2
  %4 = load i32, i32* %off1, align 8
  %5 = load i32, i32* %off.addr, align 4
  %add = add i32 %4, %5
  %conv = sext i32 %add to i64
  %call = call { i64, i64 } @tnum_const(i64 noundef %conv) #11
  %6 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %7 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = extractvalue { i64, i64 } %call, 0
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = extractvalue { i64, i64 } %call, 1
  store i64 %10, i64* %9, align 8
  %11 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %12 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 0
  %13 = load i64, i64* %12, align 8
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 8
  %16 = bitcast %struct.tnum* %agg.tmp to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call2 = call { i64, i64 } @tnum_add(i64 %13, i64 %15, i64 %18, i64 %20) #11
  %21 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 0
  %23 = extractvalue { i64, i64 } %call2, 0
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 1
  %25 = extractvalue { i64, i64 } %call2, 1
  store i64 %25, i64* %24, align 8
  %26 = bitcast %struct.tnum* %reg_off to i8*
  %27 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %26, i8* align 8 %27, i64 16, i1 false)
  %28 = load i32, i32* %size.addr, align 4
  %conv3 = sext i32 %28 to i64
  %29 = bitcast %struct.tnum* %reg_off to { i64, i64 }*
  %30 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 0
  %31 = load i64, i64* %30, align 8
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %29, i32 0, i32 1
  %33 = load i64, i64* %32, align 8
  %call4 = call zeroext i1 @tnum_is_aligned(i64 %31, i64 %33, i64 noundef %conv3) #11
  br i1 %call4, label %if.end10, label %if.then5

if.then5:                                         ; preds = %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 5
  %35 = bitcast %struct.tnum* %var_off6 to { i64, i64 }*
  %36 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 0
  %37 = load i64, i64* %36, align 8
  %38 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %35, i32 0, i32 1
  %39 = load i64, i64* %38, align 8
  %call7 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %37, i64 %39) #11
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = bitcast %struct.bpf_verifier_env* %40 to i8*
  %42 = load i8*, i8** %pointer_desc.addr, align 8
  %arraydecay8 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %43, i32 0, i32 2
  %44 = load i32, i32* %off9, align 8
  %45 = load i32, i32* %off.addr, align 4
  %46 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %41, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.225, i64 0, i64 0), i8* noundef %42, i8* noundef %arraydecay8, i32 noundef %44, i32 noundef %45, i32 noundef %46) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then5, %if.then
  %47 = load i32, i32* %retval, align 4
  ret i32 %47
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_packet_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  %__UNIQUE_ID___x418 = alloca i32, align 4
  %__UNIQUE_ID___y419 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 6
  %4 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = bitcast %struct.bpf_verifier_env* %5 to i8*
  %7 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %6, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.194, i64 0, i64 0), i32 noundef %7) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load i32, i32* %regno.addr, align 4
  %10 = load i32, i32* %off.addr, align 4
  %11 = load i32, i32* %size.addr, align 4
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 1
  %range = bitcast %struct.bpf_iter_aux_info* %13 to i16*
  %14 = load i16, i16* %range, align 8
  %conv = zext i16 %14 to i32
  %15 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %15 to i1
  %call1 = call i32 @__check_mem_access(%struct.bpf_verifier_env* noundef %8, i32 noundef %9, i32 noundef %10, i32 noundef %11, i32 noundef %conv, i1 noundef zeroext %tobool) #11
  store i32 %call1, i32* %err, align 4
  %16 = load i32, i32* %err, align 4
  %tobool2 = icmp ne i32 %16, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = bitcast %struct.bpf_verifier_env* %17 to i8*
  %19 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %18, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.238, i64 0, i64 0), i32 noundef %19) #11
  %20 = load i32, i32* %err, align 4
  store i32 %20, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %21, i32 0, i32 2
  %22 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %22, i32 0, i32 7
  %23 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_pkt_offset = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %23, i32 0, i32 3
  %24 = load i32, i32* %max_pkt_offset, align 8
  store i32 %24, i32* %__UNIQUE_ID___x418, align 4
  %25 = load i32, i32* %off.addr, align 4
  %conv5 = sext i32 %25 to i64
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  %27 = load i64, i64* %umax_value, align 8
  %add = add i64 %conv5, %27
  %28 = load i32, i32* %size.addr, align 4
  %conv6 = sext i32 %28 to i64
  %add7 = add i64 %add, %conv6
  %sub = sub i64 %add7, 1
  %conv8 = trunc i64 %sub to i32
  store i32 %conv8, i32* %__UNIQUE_ID___y419, align 4
  %29 = load i32, i32* %__UNIQUE_ID___x418, align 4
  %30 = load i32, i32* %__UNIQUE_ID___y419, align 4
  %cmp9 = icmp ugt i32 %29, %30
  br i1 %cmp9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end4
  %31 = load i32, i32* %__UNIQUE_ID___x418, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end4
  %32 = load i32, i32* %__UNIQUE_ID___y419, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %31, %cond.true ], [ %32, %cond.false ]
  store i32 %cond, i32* %tmp, align 4
  %33 = load i32, i32* %tmp, align 4
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog11 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %34, i32 0, i32 2
  %35 = load %struct.bpf_prog*, %struct.bpf_prog** %prog11, align 8
  %aux12 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %35, i32 0, i32 7
  %36 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux12, align 8
  %max_pkt_offset13 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %36, i32 0, i32 3
  store i32 %33, i32* %max_pkt_offset13, align 8
  %37 = load i32, i32* %err, align 4
  store i32 %37, i32* %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then3, %if.then
  %38 = load i32, i32* %retval, align 4
  ret i32 %38
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_access_type(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %cap = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 1
  %map_ptr = bitcast %struct.bpf_iter_aux_info* %3 to %struct.bpf_map**
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %4, %struct.bpf_map** %map, align 8
  %5 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call1 = call i32 @bpf_map_flags_to_cap(%struct.bpf_map* noundef %5) #11
  store i32 %call1, i32* %cap, align 4
  %6 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %6, 2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %7 = load i32, i32* %cap, align 4
  %conv = zext i32 %7 to i64
  %and = and i64 %conv, 2
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  %10 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %10, i32 0, i32 5
  %11 = load i32, i32* %value_size, align 32
  %12 = load i32, i32* %off.addr, align 4
  %13 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.226, i64 0, i64 0), i32 noundef %11, i32 noundef %12, i32 noundef %13) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %14 = load i32, i32* %type.addr, align 4
  %cmp2 = icmp eq i32 %14, 1
  br i1 %cmp2, label %land.lhs.true4, label %if.end10

land.lhs.true4:                                   ; preds = %if.end
  %15 = load i32, i32* %cap, align 4
  %conv5 = zext i32 %15 to i64
  %and6 = and i64 %conv5, 1
  %tobool7 = icmp ne i64 %and6, 0
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %land.lhs.true4
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size9 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %18, i32 0, i32 5
  %19 = load i32, i32* %value_size9, align 32
  %20 = load i32, i32* %off.addr, align 4
  %21 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([55 x i8], [55 x i8]* @.str.227, i64 0, i64 0), i32 noundef %19, i32 noundef %20, i32 noundef %21) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end10:                                         ; preds = %land.lhs.true4, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then8, %if.then
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %err = alloca i32, align 4
  %lock = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %7 = load i32, i32* %regno.addr, align 4
  %idxprom1 = zext i32 %7 to i64
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom1
  store %struct.bpf_reg_state* %arrayidx2, %struct.bpf_reg_state** %reg, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 1
  %map_ptr = bitcast %struct.bpf_iter_aux_info* %9 to %struct.bpf_map**
  %10 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %10, %struct.bpf_map** %map, align 8
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = load i32, i32* %regno.addr, align 4
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size.addr, align 4
  %15 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %15, i32 0, i32 5
  %16 = load i32, i32* %value_size, align 32
  %17 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %17 to i1
  %call = call i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %11, i32 noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef %16, i1 noundef zeroext %tobool) #11
  store i32 %call, i32* %err, align 4
  %18 = load i32, i32* %err, align 4
  %tobool3 = icmp ne i32 %18, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %19 = load i32, i32* %err, align 4
  store i32 %19, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %20 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %call4 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %20) #11
  br i1 %call4, label %if.then5, label %if.end18

if.then5:                                         ; preds = %if.end
  %21 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %spin_lock_off = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %21, i32 0, i32 8
  %22 = load i32, i32* %spin_lock_off, align 4
  store i32 %22, i32* %lock, align 4
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 6
  %24 = load i64, i64* %smin_value, align 8
  %25 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %25 to i64
  %add = add i64 %24, %conv
  %26 = load i32, i32* %lock, align 4
  %conv6 = zext i32 %26 to i64
  %add7 = add i64 %conv6, 4
  %cmp = icmp ult i64 %add, %add7
  br i1 %cmp, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.then5
  %27 = load i32, i32* %lock, align 4
  %conv9 = zext i32 %27 to i64
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 9
  %29 = load i64, i64* %umax_value, align 8
  %30 = load i32, i32* %off.addr, align 4
  %conv10 = sext i32 %30 to i64
  %add11 = add i64 %29, %conv10
  %31 = load i32, i32* %size.addr, align 4
  %conv12 = sext i32 %31 to i64
  %add13 = add i64 %add11, %conv12
  %cmp14 = icmp ult i64 %conv9, %add13
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = bitcast %struct.bpf_verifier_env* %32 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %33, i8* noundef getelementptr inbounds ([57 x i8], [57 x i8]* @.str.193, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %land.lhs.true, %if.then5
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.end
  %34 = load i32, i32* %err, align 4
  store i32 %34, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then16, %if.then
  %35 = load i32, i32* %retval, align 4
  ret i32 %35
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_mem_region_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %mem_size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %mem_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %mem_size, i32* %mem_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %7 = load i32, i32* %regno.addr, align 4
  %idxprom1 = zext i32 %7 to i64
  %arrayidx2 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom1
  store %struct.bpf_reg_state* %arrayidx2, %struct.bpf_reg_state** %reg, align 8
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 22
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %9 = load i32, i32* %level, align 8
  %and = and i32 %9, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %10, %struct.bpf_func_state* noundef %11) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 6
  %13 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %13, 0
  br i1 %cmp, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 6
  %15 = load i64, i64* %smin_value3, align 8
  %cmp4 = icmp eq i64 %15, -9223372036854775808
  br i1 %cmp4, label %if.then19, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %16 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %16 to i64
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value5, align 8
  %add = add i64 %conv, %18
  %19 = load i32, i32* %off.addr, align 4
  %conv6 = sext i32 %19 to i64
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 6
  %21 = load i64, i64* %smin_value7, align 8
  %add8 = add i64 %conv6, %21
  %conv9 = trunc i64 %add8 to i32
  %conv10 = sext i32 %conv9 to i64
  %cmp11 = icmp ne i64 %add, %conv10
  br i1 %cmp11, label %if.then19, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 6
  %23 = load i64, i64* %smin_value14, align 8
  %24 = load i32, i32* %off.addr, align 4
  %conv15 = sext i32 %24 to i64
  %add16 = add i64 %23, %conv15
  %cmp17 = icmp slt i64 %add16, 0
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %lor.lhs.false13, %lor.lhs.false, %land.lhs.true
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = bitcast %struct.bpf_verifier_env* %25 to i8*
  %27 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %26, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.194, i64 0, i64 0), i32 noundef %27) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end20:                                         ; preds = %lor.lhs.false13, %if.end
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = load i32, i32* %regno.addr, align 4
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 6
  %31 = load i64, i64* %smin_value21, align 8
  %32 = load i32, i32* %off.addr, align 4
  %conv22 = sext i32 %32 to i64
  %add23 = add i64 %31, %conv22
  %conv24 = trunc i64 %add23 to i32
  %33 = load i32, i32* %size.addr, align 4
  %34 = load i32, i32* %mem_size.addr, align 4
  %35 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool25 = trunc i8 %35 to i1
  %call = call i32 @__check_mem_access(%struct.bpf_verifier_env* noundef %28, i32 noundef %29, i32 noundef %conv24, i32 noundef %33, i32 noundef %34, i1 noundef zeroext %tobool25) #11
  store i32 %call, i32* %err, align 4
  %36 = load i32, i32* %err, align 4
  %tobool26 = icmp ne i32 %36, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end20
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = bitcast %struct.bpf_verifier_env* %37 to i8*
  %39 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %38, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.195, i64 0, i64 0), i32 noundef %39) #11
  %40 = load i32, i32* %err, align 4
  store i32 %40, i32* %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end20
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %41, i32 0, i32 9
  %42 = load i64, i64* %umax_value, align 8
  %cmp29 = icmp uge i64 %42, 536870912
  br i1 %cmp29, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end28
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = bitcast %struct.bpf_verifier_env* %43 to i8*
  %45 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %44, i8* noundef getelementptr inbounds ([72 x i8], [72 x i8]* @.str.196, i64 0, i64 0), i32 noundef %45) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.end28
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = load i32, i32* %regno.addr, align 4
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %umax_value33 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 9
  %49 = load i64, i64* %umax_value33, align 8
  %50 = load i32, i32* %off.addr, align 4
  %conv34 = sext i32 %50 to i64
  %add35 = add i64 %49, %conv34
  %conv36 = trunc i64 %add35 to i32
  %51 = load i32, i32* %size.addr, align 4
  %52 = load i32, i32* %mem_size.addr, align 4
  %53 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool37 = trunc i8 %53 to i1
  %call38 = call i32 @__check_mem_access(%struct.bpf_verifier_env* noundef %46, i32 noundef %47, i32 noundef %conv36, i32 noundef %51, i32 noundef %52, i1 noundef zeroext %tobool37) #11
  store i32 %call38, i32* %err, align 4
  %54 = load i32, i32* %err, align 4
  %tobool39 = icmp ne i32 %54, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end32
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = bitcast %struct.bpf_verifier_env* %55 to i8*
  %57 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %56, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.197, i64 0, i64 0), i32 noundef %57) #11
  %58 = load i32, i32* %err, align 4
  store i32 %58, i32* %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end32
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end41, %if.then40, %if.then31, %if.then27, %if.then19
  %59 = load i32, i32* %retval, align 4
  ret i32 %59
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_buffer_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i1 noundef zeroext %zero_size_allowed, i8* noundef %buf_info, i32* noundef %max_access) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %buf_info.addr = alloca i8*, align 8
  %max_access.addr = alloca i32*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store i8* %buf_info, i8** %buf_info.addr, align 8
  store i32* %max_access, i32** %max_access.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i8*, i8** %buf_info.addr, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %3 = load i32, i32* %regno.addr, align 4
  %4 = load i32, i32* %off.addr, align 4
  %5 = load i32, i32* %size.addr, align 4
  %call = call i32 @__check_buffer_access(%struct.bpf_verifier_env* noundef %0, i8* noundef %1, %struct.bpf_reg_state* noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5) #11
  store i32 %call, i32* %err, align 4
  %6 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load i32, i32* %err, align 4
  store i32 %7, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load i32, i32* %off.addr, align 4
  %9 = load i32, i32* %size.addr, align 4
  %add = add i32 %8, %9
  %10 = load i32*, i32** %max_access.addr, align 8
  %11 = load i32, i32* %10, align 4
  %cmp = icmp ugt i32 %add, %11
  br i1 %cmp, label %if.then1, label %if.end3

if.then1:                                         ; preds = %if.end
  %12 = load i32, i32* %off.addr, align 4
  %13 = load i32, i32* %size.addr, align 4
  %add2 = add i32 %12, %13
  %14 = load i32*, i32** %max_access.addr, align 8
  store i32 %add2, i32* %14, align 4
  br label %if.end3

if.end3:                                          ; preds = %if.then1, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_boundary(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %access_size, i1 noundef zeroext %zero_size_allowed, %struct.bpf_call_arg_meta* noundef %meta) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %access_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %meta.addr = alloca %struct.bpf_call_arg_meta*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %err = alloca i32, align 4
  %min_off = alloca i32, align 4
  %max_off = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  %stype = alloca i8*, align 8
  %tn_buf128 = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %access_size, i32* %access_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  store %struct.bpf_call_arg_meta* %meta, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call1 = call %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3) #11
  store %struct.bpf_func_state* %call1, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 5
  %5 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = load i64, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = load i64, i64* %8, align 8
  %call2 = call zeroext i1 @tnum_is_const(i64 %7, i64 %9) #11
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off3, i32 0, i32 0
  %11 = load i64, i64* %value, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 2
  %13 = load i32, i32* %off, align 8
  %conv = sext i32 %13 to i64
  %add = add i64 %11, %conv
  %conv4 = trunc i64 %add to i32
  store i32 %conv4, i32* %max_off, align 4
  store i32 %conv4, i32* %min_off, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = load i32, i32* %regno.addr, align 4
  %16 = load i32, i32* %min_off, align 4
  %17 = load i32, i32* %access_size.addr, align 4
  %18 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %18 to i1
  %call5 = call i32 @__check_stack_boundary(%struct.bpf_verifier_env* noundef %14, i32 noundef %15, i32 noundef %16, i32 noundef %17, i1 noundef zeroext %tobool) #11
  store i32 %call5, i32* %err, align 4
  %19 = load i32, i32* %err, align 4
  %tobool6 = icmp ne i32 %19, 0
  br i1 %tobool6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  %20 = load i32, i32* %err, align 4
  store i32 %20, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end44

if.else:                                          ; preds = %entry
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %21, i32 0, i32 17
  %22 = load i8, i8* %bypass_spec_v1, align 1
  %tobool8 = trunc i8 %22 to i1
  br i1 %tobool8, label %if.end13, label %if.then9

if.then9:                                         ; preds = %if.else
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 5
  %24 = bitcast %struct.tnum* %var_off10 to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = load i64, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = load i64, i64* %27, align 8
  %call11 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %26, i64 %28) #11
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load i32, i32* %regno.addr, align 4
  %arraydecay12 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([76 x i8], [76 x i8]* @.str.330, i64 0, i64 0), i32 noundef %31, i8* noundef %arraydecay12) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.else
  %32 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool14 = icmp ne %struct.bpf_call_arg_meta* %32, null
  br i1 %tobool14, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %if.end13
  %33 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %33, i32 0, i32 1
  %34 = load i8, i8* %raw_mode, align 8
  %tobool15 = trunc i8 %34 to i1
  br i1 %tobool15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.lhs.true
  store %struct.bpf_call_arg_meta* null, %struct.bpf_call_arg_meta** %meta.addr, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %land.lhs.true, %if.end13
  %35 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %35, i32 0, i32 7
  %36 = load i64, i64* %smax_value, align 8
  %cmp = icmp sge i64 %36, 536870912
  br i1 %cmp, label %if.then23, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end18
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value20 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %37, i32 0, i32 7
  %38 = load i64, i64* %smax_value20, align 8
  %cmp21 = icmp sle i64 %38, -536870912
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %lor.lhs.false, %if.end18
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = bitcast %struct.bpf_verifier_env* %39 to i8*
  %41 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %40, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.331, i64 0, i64 0), i32 noundef %41) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %lor.lhs.false
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %42, i32 0, i32 6
  %43 = load i64, i64* %smin_value, align 8
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 2
  %45 = load i32, i32* %off25, align 8
  %conv26 = sext i32 %45 to i64
  %add27 = add i64 %43, %conv26
  %conv28 = trunc i64 %add27 to i32
  store i32 %conv28, i32* %min_off, align 4
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smax_value29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %46, i32 0, i32 7
  %47 = load i64, i64* %smax_value29, align 8
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %off30 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 2
  %49 = load i32, i32* %off30, align 8
  %conv31 = sext i32 %49 to i64
  %add32 = add i64 %47, %conv31
  %conv33 = trunc i64 %add32 to i32
  store i32 %conv33, i32* %max_off, align 4
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = load i32, i32* %regno.addr, align 4
  %52 = load i32, i32* %min_off, align 4
  %53 = load i32, i32* %access_size.addr, align 4
  %54 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool34 = trunc i8 %54 to i1
  %call35 = call i32 @__check_stack_boundary(%struct.bpf_verifier_env* noundef %50, i32 noundef %51, i32 noundef %52, i32 noundef %53, i1 noundef zeroext %tobool34) #11
  store i32 %call35, i32* %err, align 4
  %55 = load i32, i32* %err, align 4
  %tobool36 = icmp ne i32 %55, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end24
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = bitcast %struct.bpf_verifier_env* %56 to i8*
  %58 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %57, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.332, i64 0, i64 0), i32 noundef %58) #11
  %59 = load i32, i32* %err, align 4
  store i32 %59, i32* %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.end24
  %60 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %61 = load i32, i32* %regno.addr, align 4
  %62 = load i32, i32* %max_off, align 4
  %63 = load i32, i32* %access_size.addr, align 4
  %64 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool39 = trunc i8 %64 to i1
  %call40 = call i32 @__check_stack_boundary(%struct.bpf_verifier_env* noundef %60, i32 noundef %61, i32 noundef %62, i32 noundef %63, i1 noundef zeroext %tobool39) #11
  store i32 %call40, i32* %err, align 4
  %65 = load i32, i32* %err, align 4
  %tobool41 = icmp ne i32 %65, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end38
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = bitcast %struct.bpf_verifier_env* %66 to i8*
  %68 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %67, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.333, i64 0, i64 0), i32 noundef %68) #11
  %69 = load i32, i32* %err, align 4
  store i32 %69, i32* %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.end38
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.end
  %70 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %tobool45 = icmp ne %struct.bpf_call_arg_meta* %70, null
  br i1 %tobool45, label %land.lhs.true46, label %if.end53

land.lhs.true46:                                  ; preds = %if.end44
  %71 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %raw_mode47 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %71, i32 0, i32 1
  %72 = load i8, i8* %raw_mode47, align 8
  %tobool48 = trunc i8 %72 to i1
  br i1 %tobool48, label %if.then50, label %if.end53

if.then50:                                        ; preds = %land.lhs.true46
  %73 = load i32, i32* %access_size.addr, align 4
  %74 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %access_size51 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %74, i32 0, i32 4
  store i32 %73, i32* %access_size51, align 8
  %75 = load i32, i32* %regno.addr, align 4
  %76 = load %struct.bpf_call_arg_meta*, %struct.bpf_call_arg_meta** %meta.addr, align 8
  %regno52 = getelementptr inbounds %struct.bpf_call_arg_meta, %struct.bpf_call_arg_meta* %76, i32 0, i32 3
  store i32 %75, i32* %regno52, align 4
  store i32 0, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %land.lhs.true46, %if.end44
  %77 = load i32, i32* %min_off, align 4
  store i32 %77, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc144, %if.end53
  %78 = load i32, i32* %i, align 4
  %79 = load i32, i32* %max_off, align 4
  %80 = load i32, i32* %access_size.addr, align 4
  %add54 = add i32 %79, %80
  %cmp55 = icmp slt i32 %78, %add54
  br i1 %cmp55, label %for.body, label %for.end146

for.body:                                         ; preds = %for.cond
  %81 = load i32, i32* %i, align 4
  %sub = sub i32 0, %81
  %sub57 = sub i32 %sub, 1
  store i32 %sub57, i32* %slot, align 4
  %82 = load i32, i32* %slot, align 4
  %div = sdiv i32 %82, 8
  store i32 %div, i32* %spi, align 4
  %83 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %83, i32 0, i32 6
  %84 = load i32, i32* %allocated_stack, align 8
  %85 = load i32, i32* %slot, align 4
  %cmp58 = icmp sle i32 %84, %85
  br i1 %cmp58, label %if.then60, label %if.end61

if.then60:                                        ; preds = %for.body
  br label %err122

if.end61:                                         ; preds = %for.body
  %86 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %86, i32 0, i32 7
  %87 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %88 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %88 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %87, i64 %idxprom
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 1
  %89 = load i32, i32* %slot, align 4
  %rem = srem i32 %89, 8
  %idxprom62 = sext i32 %rem to i64
  %arrayidx63 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom62
  store i8* %arrayidx63, i8** %stype, align 8
  %90 = load i8*, i8** %stype, align 8
  %91 = load i8, i8* %90, align 1
  %conv64 = zext i8 %91 to i32
  %cmp65 = icmp eq i32 %conv64, 2
  br i1 %cmp65, label %if.then67, label %if.end68

if.then67:                                        ; preds = %if.end61
  br label %mark

if.end68:                                         ; preds = %if.end61
  %92 = load i8*, i8** %stype, align 8
  %93 = load i8, i8* %92, align 1
  %conv69 = zext i8 %93 to i32
  %cmp70 = icmp eq i32 %conv69, 3
  br i1 %cmp70, label %if.then72, label %if.end73

if.then72:                                        ; preds = %if.end68
  %94 = load i8*, i8** %stype, align 8
  store i8 2, i8* %94, align 1
  br label %mark

if.end73:                                         ; preds = %if.end68
  %95 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack74 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %95, i32 0, i32 7
  %96 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack74, align 8
  %97 = load i32, i32* %spi, align 4
  %idxprom75 = sext i32 %97 to i64
  %arrayidx76 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %96, i64 %idxprom75
  %slot_type77 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx76, i32 0, i32 1
  %arrayidx78 = getelementptr [8 x i8], [8 x i8]* %slot_type77, i64 0, i64 0
  %98 = load i8, i8* %arrayidx78, align 8
  %conv79 = zext i8 %98 to i32
  %cmp80 = icmp eq i32 %conv79, 1
  br i1 %cmp80, label %land.lhs.true82, label %if.end89

land.lhs.true82:                                  ; preds = %if.end73
  %99 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack83 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %99, i32 0, i32 7
  %100 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack83, align 8
  %101 = load i32, i32* %spi, align 4
  %idxprom84 = sext i32 %101 to i64
  %arrayidx85 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %100, i64 %idxprom84
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx85, i32 0, i32 0
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 0
  %102 = load i32, i32* %type, align 8
  %cmp86 = icmp eq i32 %102, 19
  br i1 %cmp86, label %if.then88, label %if.end89

if.then88:                                        ; preds = %land.lhs.true82
  br label %mark

if.end89:                                         ; preds = %land.lhs.true82, %if.end73
  %103 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack90 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %103, i32 0, i32 7
  %104 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack90, align 8
  %105 = load i32, i32* %spi, align 4
  %idxprom91 = sext i32 %105 to i64
  %arrayidx92 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %104, i64 %idxprom91
  %slot_type93 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx92, i32 0, i32 1
  %arrayidx94 = getelementptr [8 x i8], [8 x i8]* %slot_type93, i64 0, i64 0
  %106 = load i8, i8* %arrayidx94, align 8
  %conv95 = zext i8 %106 to i32
  %cmp96 = icmp eq i32 %conv95, 1
  br i1 %cmp96, label %land.lhs.true98, label %if.end121

land.lhs.true98:                                  ; preds = %if.end89
  %107 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack99 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %107, i32 0, i32 7
  %108 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack99, align 8
  %109 = load i32, i32* %spi, align 4
  %idxprom100 = sext i32 %109 to i64
  %arrayidx101 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %108, i64 %idxprom100
  %spilled_ptr102 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx101, i32 0, i32 0
  %type103 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr102, i32 0, i32 0
  %110 = load i32, i32* %type103, align 8
  %cmp104 = icmp eq i32 %110, 1
  br i1 %cmp104, label %if.then106, label %if.end121

if.then106:                                       ; preds = %land.lhs.true98
  %111 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %112 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack107 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %112, i32 0, i32 7
  %113 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack107, align 8
  %114 = load i32, i32* %spi, align 4
  %idxprom108 = sext i32 %114 to i64
  %arrayidx109 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %113, i64 %idxprom108
  %spilled_ptr110 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx109, i32 0, i32 0
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %111, %struct.bpf_reg_state* noundef %spilled_ptr110) #11
  store i32 0, i32* %j, align 4
  br label %for.cond111

for.cond111:                                      ; preds = %for.inc, %if.then106
  %115 = load i32, i32* %j, align 4
  %cmp112 = icmp slt i32 %115, 8
  br i1 %cmp112, label %for.body114, label %for.end

for.body114:                                      ; preds = %for.cond111
  %116 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack115 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %116, i32 0, i32 7
  %117 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack115, align 8
  %118 = load i32, i32* %spi, align 4
  %idxprom116 = sext i32 %118 to i64
  %arrayidx117 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %117, i64 %idxprom116
  %slot_type118 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx117, i32 0, i32 1
  %119 = load i32, i32* %j, align 4
  %idxprom119 = sext i32 %119 to i64
  %arrayidx120 = getelementptr [8 x i8], [8 x i8]* %slot_type118, i64 0, i64 %idxprom119
  store i8 2, i8* %arrayidx120, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body114
  %120 = load i32, i32* %j, align 4
  %inc = add i32 %120, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond111

for.end:                                          ; preds = %for.cond111
  br label %mark

if.end121:                                        ; preds = %land.lhs.true98, %if.end89
  br label %err122

err122:                                           ; preds = %if.end121, %if.then60
  %121 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off123 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %121, i32 0, i32 5
  %122 = bitcast %struct.tnum* %var_off123 to { i64, i64 }*
  %123 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %122, i32 0, i32 0
  %124 = load i64, i64* %123, align 8
  %125 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %122, i32 0, i32 1
  %126 = load i64, i64* %125, align 8
  %call124 = call zeroext i1 @tnum_is_const(i64 %124, i64 %126) #11
  br i1 %call124, label %if.then125, label %if.else127

if.then125:                                       ; preds = %err122
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %128 = bitcast %struct.bpf_verifier_env* %127 to i8*
  %129 = load i32, i32* %min_off, align 4
  %130 = load i32, i32* %i, align 4
  %131 = load i32, i32* %min_off, align 4
  %sub126 = sub i32 %130, %131
  %132 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %128, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.334, i64 0, i64 0), i32 noundef %129, i32 noundef %sub126, i32 noundef %132) #11
  br label %if.end134

if.else127:                                       ; preds = %err122
  %arraydecay129 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf128, i64 0, i64 0
  %133 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off130 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %133, i32 0, i32 5
  %134 = bitcast %struct.tnum* %var_off130 to { i64, i64 }*
  %135 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %134, i32 0, i32 0
  %136 = load i64, i64* %135, align 8
  %137 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %134, i32 0, i32 1
  %138 = load i64, i64* %137, align 8
  %call131 = call i32 @tnum_strn(i8* noundef %arraydecay129, i64 noundef 48, i64 %136, i64 %138) #11
  %139 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %140 = bitcast %struct.bpf_verifier_env* %139 to i8*
  %arraydecay132 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf128, i64 0, i64 0
  %141 = load i32, i32* %i, align 4
  %142 = load i32, i32* %min_off, align 4
  %sub133 = sub i32 %141, %142
  %143 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %140, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.335, i64 0, i64 0), i8* noundef %arraydecay132, i32 noundef %sub133, i32 noundef %143) #11
  br label %if.end134

if.end134:                                        ; preds = %if.else127, %if.then125
  store i32 -13, i32* %retval, align 4
  br label %return

mark:                                             ; preds = %for.end, %if.then88, %if.then72, %if.then67
  %144 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %145 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack135 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %145, i32 0, i32 7
  %146 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack135, align 8
  %147 = load i32, i32* %spi, align 4
  %idxprom136 = sext i32 %147 to i64
  %arrayidx137 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %146, i64 %idxprom136
  %spilled_ptr138 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx137, i32 0, i32 0
  %148 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack139 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %148, i32 0, i32 7
  %149 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack139, align 8
  %150 = load i32, i32* %spi, align 4
  %idxprom140 = sext i32 %150 to i64
  %arrayidx141 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %149, i64 %idxprom140
  %spilled_ptr142 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx141, i32 0, i32 0
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr142, i32 0, i32 14
  %151 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %call143 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %144, %struct.bpf_reg_state* noundef %spilled_ptr138, %struct.bpf_reg_state* noundef %151, i8 noundef zeroext 2) #11
  br label %for.inc144

for.inc144:                                       ; preds = %mark
  %152 = load i32, i32* %i, align 4
  %inc145 = add i32 %152, 1
  store i32 %inc145, i32* %i, align 4
  br label %for.cond

for.end146:                                       ; preds = %for.cond
  %153 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %154 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %155 = load i32, i32* %min_off, align 4
  %call147 = call i32 @update_stack_depth(%struct.bpf_verifier_env* noundef %153, %struct.bpf_func_state* noundef %154, i32 noundef %155) #11
  store i32 %call147, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end146, %if.end134, %if.then50, %if.then42, %if.then37, %if.then23, %if.then9, %if.then7
  %156 = load i32, i32* %retval, align 4
  ret i32 %156
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_func_state* @func(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %cur = alloca %struct.bpf_verifier_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 15
  %4 = load i32, i32* %frameno, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  ret %struct.bpf_func_state* %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_stack_boundary(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %access_size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %access_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %reg = alloca %struct.bpf_reg_state*, align 8
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %access_size, i32* %access_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load i32, i32* %off.addr, align 4
  %cmp = icmp sge i32 %2, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp slt i32 %3, -512
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %4 = load i32, i32* %off.addr, align 4
  %5 = load i32, i32* %access_size.addr, align 4
  %add = add i32 %4, %5
  %cmp3 = icmp sgt i32 %add, 0
  br i1 %cmp3, label %if.then, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %6 = load i32, i32* %access_size.addr, align 4
  %cmp5 = icmp slt i32 %6, 0
  br i1 %cmp5, label %if.then, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %7 = load i32, i32* %access_size.addr, align 4
  %cmp7 = icmp eq i32 %7, 0
  br i1 %cmp7, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %lor.lhs.false6
  %8 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.end13, label %if.then

if.then:                                          ; preds = %land.lhs.true, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 5
  %10 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %call8 = call zeroext i1 @tnum_is_const(i64 %12, i64 %14) #11
  br i1 %call8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = bitcast %struct.bpf_verifier_env* %15 to i8*
  %17 = load i32, i32* %regno.addr, align 4
  %18 = load i32, i32* %off.addr, align 4
  %19 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %16, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.336, i64 0, i64 0), i32 noundef %17, i32 noundef %18, i32 noundef %19) #11
  br label %if.end

if.else:                                          ; preds = %if.then
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 5
  %21 = bitcast %struct.tnum* %var_off10 to { i64, i64 }*
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 0
  %23 = load i64, i64* %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 1
  %25 = load i64, i64* %24, align 8
  %call11 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %23, i64 %25) #11
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  %28 = load i32, i32* %regno.addr, align 4
  %arraydecay12 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %29 = load i32, i32* %access_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.337, i64 0, i64 0), i32 noundef %28, i8* noundef %arraydecay12, i32 noundef %29) #11
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then9
  store i32 -13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %land.lhs.true, %lor.lhs.false6
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.end
  %30 = load i32, i32* %retval, align 4
  ret i32 %30
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %state, %struct.bpf_reg_state* noundef %parent, i8 noundef zeroext %flag) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_reg_state*, align 8
  %parent.addr = alloca %struct.bpf_reg_state*, align 8
  %flag.addr = alloca i8, align 1
  %writes = alloca i8, align 1
  %cnt = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %state, %struct.bpf_reg_state** %state.addr, align 8
  store %struct.bpf_reg_state* %parent, %struct.bpf_reg_state** %parent.addr, align 8
  store i8 %flag, i8* %flag.addr, align 1
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state.addr, align 8
  %parent1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 14
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent1, align 8
  %cmp = icmp eq %struct.bpf_reg_state* %0, %2
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %writes, align 1
  store i32 0, i32* %cnt, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end26, %entry
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %tobool = icmp ne %struct.bpf_reg_state* %3, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i8, i8* %writes, align 1
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state.addr, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i32 0, i32 17
  %6 = load i32, i32* %live, align 8
  %and = and i32 %6, 4
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %while.end

if.end:                                           ; preds = %land.lhs.true, %while.body
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 17
  %8 = load i32, i32* %live4, align 8
  %and5 = and i32 %8, 8
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %10 = bitcast %struct.bpf_verifier_env* %9 to i8*
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 0
  %12 = load i32, i32* %type, align 8
  %idxprom = zext i32 %12 to i64
  %arrayidx = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %13 = load i8*, i8** %arrayidx, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %15 = load i64, i64* %value, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 2
  %17 = load i32, i32* %off, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %10, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.118, i64 0, i64 0), i8* noundef %13, i64 noundef %15, i32 noundef %17) #11
  store i32 -14, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 17
  %19 = load i32, i32* %live9, align 8
  %and10 = and i32 %19, 3
  %20 = load i8, i8* %flag.addr, align 1
  %conv = zext i8 %20 to i32
  %cmp11 = icmp eq i32 %and10, %conv
  br i1 %cmp11, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live13 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 17
  %22 = load i32, i32* %live13, align 8
  %and14 = and i32 %22, 2
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %if.end8
  br label %while.end

if.end17:                                         ; preds = %lor.lhs.false
  %23 = load i8, i8* %flag.addr, align 1
  %conv18 = zext i8 %23 to i32
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 17
  %25 = load i32, i32* %live19, align 8
  %or = or i32 %25, %conv18
  store i32 %or, i32* %live19, align 8
  %26 = load i8, i8* %flag.addr, align 1
  %conv20 = zext i8 %26 to i32
  %cmp21 = icmp eq i32 %conv20, 2
  br i1 %cmp21, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.end17
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  %live24 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 17
  %28 = load i32, i32* %live24, align 8
  %and25 = and i32 %28, -2
  store i32 %and25, i32* %live24, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %if.end17
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent.addr, align 8
  store %struct.bpf_reg_state* %29, %struct.bpf_reg_state** %state.addr, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state.addr, align 8
  %parent27 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 14
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent27, align 8
  store %struct.bpf_reg_state* %31, %struct.bpf_reg_state** %parent.addr, align 8
  store i8 1, i8* %writes, align 1
  %32 = load i32, i32* %cnt, align 4
  %inc = add i32 %32, 1
  store i32 %inc, i32* %cnt, align 4
  br label %while.cond

while.end:                                        ; preds = %if.then16, %if.then, %while.cond
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %longest_mark_read_walk = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 35
  %34 = load i32, i32* %longest_mark_read_walk, align 4
  %35 = load i32, i32* %cnt, align 4
  %cmp28 = icmp ult i32 %34, %35
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %while.end
  %36 = load i32, i32* %cnt, align 4
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %longest_mark_read_walk31 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %37, i32 0, i32 35
  store i32 %36, i32* %longest_mark_read_walk31, align 4
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %while.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end32, %if.then7
  %38 = load i32, i32* %retval, align 4
  ret i32 %38
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @update_stack_depth(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %func, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %func.addr = alloca %struct.bpf_func_state*, align 8
  %off.addr = alloca i32, align 4
  %stack = alloca i16, align 2
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %func, %struct.bpf_func_state** %func.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 23
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func.addr, align 8
  %subprogno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 3
  %2 = load i32, i32* %subprogno, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %stack_depth = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 2
  %3 = load i16, i16* %stack_depth, align 8
  store i16 %3, i16* %stack, align 2
  %4 = load i16, i16* %stack, align 2
  %conv = zext i16 %4 to i32
  %5 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %5
  %cmp = icmp sge i32 %conv, %sub
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, i32* %off.addr, align 4
  %sub2 = sub i32 0, %6
  %conv3 = trunc i32 %sub2 to i16
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %7, i32 0, i32 23
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %func.addr, align 8
  %subprogno5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 3
  %9 = load i32, i32* %subprogno5, align 8
  %idxprom6 = zext i32 %9 to i64
  %arrayidx7 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info4, i64 0, i64 %idxprom6
  %stack_depth8 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx7, i32 0, i32 2
  store i16 %conv3, i16* %stack_depth8, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32, i32* %retval, align 4
  ret i32 %10
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_buffer_access(%struct.bpf_verifier_env* noundef %env, i8* noundef %buf_info, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %buf_info.addr = alloca i8*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i8* %buf_info, i8** %buf_info.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = bitcast %struct.bpf_verifier_env* %1 to i8*
  %3 = load i32, i32* %regno.addr, align 4
  %4 = load i8*, i8** %buf_info.addr, align 8
  %5 = load i32, i32* %off.addr, align 4
  %6 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %2, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.242, i64 0, i64 0), i32 noundef %3, i8* noundef %4, i32 noundef %5, i32 noundef %6) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #11
  br i1 %call, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %if.end
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off1, i32 0, i32 0
  %14 = load i64, i64* %value, align 8
  %tobool = icmp ne i64 %14, 0
  br i1 %tobool, label %if.then2, label %if.end6

if.then2:                                         ; preds = %lor.lhs.false, %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %16 = bitcast %struct.tnum* %var_off3 to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call4 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %18, i64 %20) #11
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %22 = bitcast %struct.bpf_verifier_env* %21 to i8*
  %23 = load i32, i32* %regno.addr, align 4
  %24 = load i32, i32* %off.addr, align 4
  %arraydecay5 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %22, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.243, i64 0, i64 0), i32 noundef %23, i32 noundef %24, i8* noundef %arraydecay5) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then2, %if.then
  %25 = load i32, i32* %retval, align 4
  ret i32 %25
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @__check_mem_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %mem_size, i1 noundef zeroext %zero_size_allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %mem_size.addr = alloca i32, align 4
  %zero_size_allowed.addr = alloca i8, align 1
  %size_ok = alloca i8, align 1
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %mem_size, i32* %mem_size.addr, align 4
  %frombool = zext i1 %zero_size_allowed to i8
  store i8 %frombool, i8* %zero_size_allowed.addr, align 1
  %0 = load i32, i32* %size.addr, align 4
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %size.addr, align 4
  %cmp1 = icmp eq i32 %1, 0
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %2 = load i8, i8* %zero_size_allowed.addr, align 1
  %tobool = trunc i8 %2 to i1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %3 = phi i1 [ false, %lor.rhs ], [ %tobool, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %4 = phi i1 [ true, %entry ], [ %3, %land.end ]
  %frombool2 = zext i1 %4 to i8
  store i8 %frombool2, i8* %size_ok, align 1
  %5 = load i32, i32* %off.addr, align 4
  %cmp3 = icmp sge i32 %5, 0
  br i1 %cmp3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.end
  %6 = load i8, i8* %size_ok, align 1
  %tobool4 = trunc i8 %6 to i1
  br i1 %tobool4, label %land.lhs.true5, label %if.end

land.lhs.true5:                                   ; preds = %land.lhs.true
  %7 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %7 to i64
  %8 = load i32, i32* %size.addr, align 4
  %conv6 = sext i32 %8 to i64
  %add = add i64 %conv, %conv6
  %9 = load i32, i32* %mem_size.addr, align 4
  %conv7 = zext i32 %9 to i64
  %cmp8 = icmp ule i64 %add, %conv7
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true5
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true5, %land.lhs.true, %lor.end
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %10) #11
  %11 = load i32, i32* %regno.addr, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %call, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 0
  %13 = load i32, i32* %type, align 8
  switch i32 %13, label %sw.default [
    i32 4, label %sw.bb
    i32 8, label %sw.bb10
    i32 7, label %sw.bb10
    i32 9, label %sw.bb10
    i32 21, label %sw.bb11
  ]

sw.bb:                                            ; preds = %if.end
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  %16 = load i32, i32* %mem_size.addr, align 4
  %17 = load i32, i32* %off.addr, align 4
  %18 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.198, i64 0, i64 0), i32 noundef %16, i32 noundef %17, i32 noundef %18) #11
  br label %sw.epilog

sw.bb10:                                          ; preds = %if.end, %if.end, %if.end
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  %21 = load i32, i32* %off.addr, align 4
  %22 = load i32, i32* %size.addr, align 4
  %23 = load i32, i32* %regno.addr, align 4
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 3
  %25 = load i32, i32* %id, align 4
  %26 = load i32, i32* %off.addr, align 4
  %27 = load i32, i32* %mem_size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([66 x i8], [66 x i8]* @.str.199, i64 0, i64 0), i32 noundef %21, i32 noundef %22, i32 noundef %23, i32 noundef %25, i32 noundef %26, i32 noundef %27) #11
  br label %sw.epilog

sw.bb11:                                          ; preds = %if.end
  br label %sw.default

sw.default:                                       ; preds = %sw.bb11, %if.end
  %28 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %29 = bitcast %struct.bpf_verifier_env* %28 to i8*
  %30 = load i32, i32* %mem_size.addr, align 4
  %31 = load i32, i32* %off.addr, align 4
  %32 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %29, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.200, i64 0, i64 0), i32 noundef %30, i32 noundef %31, i32 noundef %32) #11
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb10, %sw.bb
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then
  %33 = load i32, i32* %retval, align 4
  ret i32 %33
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_map_flags_to_cap(%struct.bpf_map* noundef %map) #0 {
entry:
  %retval = alloca i32, align 4
  %map.addr = alloca %struct.bpf_map*, align 8
  %access_flags = alloca i32, align 4
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 7
  %1 = load i32, i32* %map_flags, align 8
  %and = and i32 %1, 384
  store i32 %and, i32* %access_flags, align 4
  %2 = load i32, i32* %access_flags, align 4
  %and1 = and i32 %2, 128
  %tobool = icmp ne i32 %and1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i32, i32* %access_flags, align 4
  %and2 = and i32 %3, 256
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.else
  store i32 2, i32* %retval, align 4
  br label %return

if.else5:                                         ; preds = %if.else
  store i32 3, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.else5, %if.then4, %if.then
  %4 = load i32, i32* %retval, align 4
  ret i32 %4
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @btf_struct_ids_match(%struct.bpf_verifier_log* noundef, i32 noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_raw_mode_ok(%struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %count = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 0, i32* %count, align 4
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %0, i32 0, i32 4
  %2 = bitcast %union.anon.168* %1 to %struct.gnet_stats_queue*
  %arg1_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %2, i32 0, i32 0
  %3 = load i32, i32* %arg1_type, align 8
  %cmp = icmp eq i32 %3, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %count, align 4
  %inc = add i32 %4, 1
  store i32 %inc, i32* %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %6 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %5, i32 0, i32 4
  %7 = bitcast %union.anon.168* %6 to %struct.gnet_stats_queue*
  %arg2_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %7, i32 0, i32 1
  %8 = load i32, i32* %arg2_type, align 4
  %cmp1 = icmp eq i32 %8, 8
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %9 = load i32, i32* %count, align 4
  %inc3 = add i32 %9, 1
  store i32 %inc3, i32* %count, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %10 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %11 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %10, i32 0, i32 4
  %12 = bitcast %union.anon.168* %11 to %struct.gnet_stats_queue*
  %arg3_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %12, i32 0, i32 2
  %13 = load i32, i32* %arg3_type, align 8
  %cmp5 = icmp eq i32 %13, 8
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %14 = load i32, i32* %count, align 4
  %inc7 = add i32 %14, 1
  store i32 %inc7, i32* %count, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %15 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %16 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %15, i32 0, i32 4
  %17 = bitcast %union.anon.168* %16 to %struct.gnet_stats_queue*
  %arg4_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %17, i32 0, i32 3
  %18 = load i32, i32* %arg4_type, align 4
  %cmp9 = icmp eq i32 %18, 8
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %19 = load i32, i32* %count, align 4
  %inc11 = add i32 %19, 1
  store i32 %inc11, i32* %count, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %20 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %21 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %20, i32 0, i32 4
  %22 = bitcast %union.anon.168* %21 to %struct.gnet_stats_queue*
  %arg5_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %22, i32 0, i32 4
  %23 = load i32, i32* %arg5_type, align 8
  %cmp13 = icmp eq i32 %23, 8
  br i1 %cmp13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %24 = load i32, i32* %count, align 4
  %inc15 = add i32 %24, 1
  store i32 %inc15, i32* %count, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %25 = load i32, i32* %count, align 4
  %cmp17 = icmp sle i32 %25, 1
  ret i1 %cmp17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_arg_pair_ok(%struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %retval = alloca i1, align 1
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %0, i32 0, i32 4
  %2 = bitcast %union.anon.168* %1 to %struct.gnet_stats_queue*
  %arg1_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %2, i32 0, i32 0
  %3 = load i32, i32* %arg1_type, align 8
  %call = call zeroext i1 @arg_type_is_mem_size(i32 noundef %3) #11
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %5 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %4, i32 0, i32 4
  %6 = bitcast %union.anon.168* %5 to %struct.gnet_stats_queue*
  %arg5_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %6, i32 0, i32 4
  %7 = load i32, i32* %arg5_type, align 8
  %call1 = call zeroext i1 @arg_type_is_mem_ptr(i32 noundef %7) #11
  br i1 %call1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %8 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %9 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %8, i32 0, i32 4
  %10 = bitcast %union.anon.168* %9 to %struct.gnet_stats_queue*
  %arg1_type3 = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %10, i32 0, i32 0
  %11 = load i32, i32* %arg1_type3, align 8
  %12 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %13 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %12, i32 0, i32 4
  %14 = bitcast %union.anon.168* %13 to %struct.gnet_stats_queue*
  %arg2_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %14, i32 0, i32 1
  %15 = load i32, i32* %arg2_type, align 4
  %call4 = call zeroext i1 @check_args_pair_invalid(i32 noundef %11, i32 noundef %15) #11
  br i1 %call4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false2
  %16 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %17 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %16, i32 0, i32 4
  %18 = bitcast %union.anon.168* %17 to %struct.gnet_stats_queue*
  %arg2_type6 = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %18, i32 0, i32 1
  %19 = load i32, i32* %arg2_type6, align 4
  %20 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %21 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %20, i32 0, i32 4
  %22 = bitcast %union.anon.168* %21 to %struct.gnet_stats_queue*
  %arg3_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %22, i32 0, i32 2
  %23 = load i32, i32* %arg3_type, align 8
  %call7 = call zeroext i1 @check_args_pair_invalid(i32 noundef %19, i32 noundef %23) #11
  br i1 %call7, label %if.then, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false5
  %24 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %25 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %24, i32 0, i32 4
  %26 = bitcast %union.anon.168* %25 to %struct.gnet_stats_queue*
  %arg3_type9 = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %26, i32 0, i32 2
  %27 = load i32, i32* %arg3_type9, align 8
  %28 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %29 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %28, i32 0, i32 4
  %30 = bitcast %union.anon.168* %29 to %struct.gnet_stats_queue*
  %arg4_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %30, i32 0, i32 3
  %31 = load i32, i32* %arg4_type, align 4
  %call10 = call zeroext i1 @check_args_pair_invalid(i32 noundef %27, i32 noundef %31) #11
  br i1 %call10, label %if.then, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false8
  %32 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %33 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %32, i32 0, i32 4
  %34 = bitcast %union.anon.168* %33 to %struct.gnet_stats_queue*
  %arg4_type12 = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %34, i32 0, i32 3
  %35 = load i32, i32* %arg4_type12, align 4
  %36 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %37 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %36, i32 0, i32 4
  %38 = bitcast %union.anon.168* %37 to %struct.gnet_stats_queue*
  %arg5_type13 = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %38, i32 0, i32 4
  %39 = load i32, i32* %arg5_type13, align 8
  %call14 = call zeroext i1 @check_args_pair_invalid(i32 noundef %35, i32 noundef %39) #11
  br i1 %call14, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false11, %lor.lhs.false8, %lor.lhs.false5, %lor.lhs.false2, %lor.lhs.false, %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false11
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %40 = load i1, i1* %retval, align 1
  ret i1 %40
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_btf_id_ok(%struct.bpf_func_proto* noundef %fn) #0 {
entry:
  %retval = alloca i1, align 1
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %conv = sext i32 %0 to i64
  %cmp = icmp ult i64 %conv, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %2 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %1, i32 0, i32 4
  %arg_type = bitcast %union.anon.168* %2 to [5 x i32]*
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [5 x i32], [5 x i32]* %arg_type, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4
  %cmp2 = icmp eq i32 %4, 20
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %5 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %6 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %5, i32 0, i32 5
  %arg_btf_id = bitcast %union.anon.170* %6 to [5 x i32*]*
  %7 = load i32, i32* %i, align 4
  %idxprom4 = sext i32 %7 to i64
  %arrayidx5 = getelementptr [5 x i32*], [5 x i32*]* %arg_btf_id, i64 0, i64 %idxprom4
  %8 = load i32*, i32** %arrayidx5, align 8
  %tobool = icmp ne i32* %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %land.lhs.true, %for.body
  %9 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %10 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %9, i32 0, i32 4
  %arg_type6 = bitcast %union.anon.168* %10 to [5 x i32]*
  %11 = load i32, i32* %i, align 4
  %idxprom7 = sext i32 %11 to i64
  %arrayidx8 = getelementptr [5 x i32], [5 x i32]* %arg_type6, i64 0, i64 %idxprom7
  %12 = load i32, i32* %arrayidx8, align 4
  %cmp9 = icmp ne i32 %12, 20
  br i1 %cmp9, label %land.lhs.true11, label %if.end17

land.lhs.true11:                                  ; preds = %if.end
  %13 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %14 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %13, i32 0, i32 5
  %arg_btf_id12 = bitcast %union.anon.170* %14 to [5 x i32*]*
  %15 = load i32, i32* %i, align 4
  %idxprom13 = sext i32 %15 to i64
  %arrayidx14 = getelementptr [5 x i32*], [5 x i32*]* %arg_btf_id12, i64 0, i64 %idxprom13
  %16 = load i32*, i32** %arrayidx14, align 8
  %tobool15 = icmp ne i32* %16, null
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true11
  store i1 false, i1* %retval, align 1
  br label %return

if.end17:                                         ; preds = %land.lhs.true11, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %17 = load i32, i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then16, %if.then
  %18 = load i1, i1* %retval, align 1
  ret i1 %18
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_refcount_ok(%struct.bpf_func_proto* noundef %fn, i32 noundef %func_id) #0 {
entry:
  %retval = alloca i1, align 1
  %fn.addr = alloca %struct.bpf_func_proto*, align 8
  %func_id.addr = alloca i32, align 4
  %count = alloca i32, align 4
  store %struct.bpf_func_proto* %fn, %struct.bpf_func_proto** %fn.addr, align 8
  store i32 %func_id, i32* %func_id.addr, align 4
  store i32 0, i32* %count, align 4
  %0 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %1 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %0, i32 0, i32 4
  %2 = bitcast %union.anon.168* %1 to %struct.gnet_stats_queue*
  %arg1_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %2, i32 0, i32 0
  %3 = load i32, i32* %arg1_type, align 8
  %call = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %3) #11
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %count, align 4
  %inc = add i32 %4, 1
  store i32 %inc, i32* %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %6 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %5, i32 0, i32 4
  %7 = bitcast %union.anon.168* %6 to %struct.gnet_stats_queue*
  %arg2_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %7, i32 0, i32 1
  %8 = load i32, i32* %arg2_type, align 4
  %call1 = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %8) #11
  br i1 %call1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %9 = load i32, i32* %count, align 4
  %inc3 = add i32 %9, 1
  store i32 %inc3, i32* %count, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %10 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %11 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %10, i32 0, i32 4
  %12 = bitcast %union.anon.168* %11 to %struct.gnet_stats_queue*
  %arg3_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %12, i32 0, i32 2
  %13 = load i32, i32* %arg3_type, align 8
  %call5 = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %13) #11
  br i1 %call5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %14 = load i32, i32* %count, align 4
  %inc7 = add i32 %14, 1
  store i32 %inc7, i32* %count, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %15 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %16 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %15, i32 0, i32 4
  %17 = bitcast %union.anon.168* %16 to %struct.gnet_stats_queue*
  %arg4_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %17, i32 0, i32 3
  %18 = load i32, i32* %arg4_type, align 4
  %call9 = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %18) #11
  br i1 %call9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %19 = load i32, i32* %count, align 4
  %inc11 = add i32 %19, 1
  store i32 %inc11, i32* %count, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %20 = load %struct.bpf_func_proto*, %struct.bpf_func_proto** %fn.addr, align 8
  %21 = getelementptr inbounds %struct.bpf_func_proto, %struct.bpf_func_proto* %20, i32 0, i32 4
  %22 = bitcast %union.anon.168* %21 to %struct.gnet_stats_queue*
  %arg5_type = getelementptr inbounds %struct.gnet_stats_queue, %struct.gnet_stats_queue* %22, i32 0, i32 4
  %23 = load i32, i32* %arg5_type, align 8
  %call13 = call zeroext i1 @arg_type_may_be_refcounted(i32 noundef %23) #11
  br i1 %call13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %24 = load i32, i32* %count, align 4
  %inc15 = add i32 %24, 1
  store i32 %inc15, i32* %count, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %25 = load i32, i32* %func_id.addr, align 4
  %call17 = call zeroext i1 @may_be_acquire_function(i32 noundef %25) #11
  br i1 %call17, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %if.end16
  %26 = load i32, i32* %count, align 4
  %tobool = icmp ne i32 %26, 0
  br i1 %tobool, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true
  store i1 false, i1* %retval, align 1
  br label %return

if.end19:                                         ; preds = %land.lhs.true, %if.end16
  %27 = load i32, i32* %count, align 4
  %cmp = icmp sle i32 %27, 1
  store i1 %cmp, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end19, %if.then18
  %28 = load i1, i1* %retval, align 1
  ret i1 %28
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @arg_type_may_be_refcounted(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 15
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @may_be_acquire_function(i32 noundef %func_id) #0 {
entry:
  %func_id.addr = alloca i32, align 4
  store i32 %func_id, i32* %func_id.addr, align 4
  %0 = load i32, i32* %func_id.addr, align 4
  %cmp = icmp eq i32 %0, 84
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %func_id.addr, align 4
  %cmp1 = icmp eq i32 %1, 85
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %func_id.addr, align 4
  %cmp3 = icmp eq i32 %2, 99
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %func_id.addr, align 4
  %cmp5 = icmp eq i32 %3, 1
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false4
  %4 = load i32, i32* %func_id.addr, align 4
  %cmp6 = icmp eq i32 %4, 131
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp6, %lor.rhs ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_args_pair_invalid(i32 noundef %arg_curr, i32 noundef %arg_next) #0 {
entry:
  %arg_curr.addr = alloca i32, align 4
  %arg_next.addr = alloca i32, align 4
  store i32 %arg_curr, i32* %arg_curr.addr, align 4
  store i32 %arg_next, i32* %arg_next.addr, align 4
  %0 = load i32, i32* %arg_curr.addr, align 4
  %call = call zeroext i1 @arg_type_is_mem_ptr(i32 noundef %0) #11
  br i1 %call, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* %arg_next.addr, align 4
  %call1 = call zeroext i1 @arg_type_is_mem_size(i32 noundef %1) #11
  br i1 %call1, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.lhs.true, %entry
  %2 = load i32, i32* %arg_curr.addr, align 4
  %call2 = call zeroext i1 @arg_type_is_mem_ptr(i32 noundef %2) #11
  br i1 %call2, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %lor.rhs
  %3 = load i32, i32* %arg_next.addr, align 4
  %call3 = call zeroext i1 @arg_type_is_mem_size(i32 noundef %3) #11
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %4 = phi i1 [ false, %lor.rhs ], [ %call3, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %4, %land.end ]
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clear_caller_saved_regs(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom
  %4 = load i32, i32* %arrayidx, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %1, %struct.bpf_reg_state* noundef %2, i32 noundef %4) #11
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom1 = sext i32 %6 to i64
  %arrayidx2 = getelementptr [6 x i32], [6 x i32]* @caller_saved, i64 0, i64 %idxprom1
  %7 = load i32, i32* %arrayidx2, align 4
  %call = call i32 @check_reg_arg(%struct.bpf_verifier_env* noundef %5, i32 noundef %7, i32 noundef 2) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_pkt_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @type_is_pkt_pointer(i32 noundef %3) #11
  ret i1 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_flow_key_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %3, 10
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_sk_reg(%struct.bpf_verifier_env* noundef %env, i32 noundef %regno) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %call = call %struct.bpf_reg_state* @reg_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 0
  %3 = load i32, i32* %type, align 8
  %call1 = call zeroext i1 @type_is_sk_pointer(i32 noundef %3) #11
  ret i1 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @type_is_sk_pointer(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 11
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 13
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 15
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp4 = icmp eq i32 %3, 18
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false2, %lor.lhs.false, %entry
  %4 = phi i1 [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp4, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_mismatch_ok(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 2, label %sw.bb
    i32 11, label %sw.bb
    i32 12, label %sw.bb
    i32 13, label %sw.bb
    i32 14, label %sw.bb
    i32 15, label %sw.bb
    i32 16, label %sw.bb
    i32 18, label %sw.bb
    i32 19, label %sw.bb
    i32 20, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i1 false, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_is_rdonly(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 7
  %1 = load i32, i32* %map_flags, align 8
  %and = and i32 %1, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %frozen = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %2, i32 0, i32 18
  %3 = load i8, i8* %frozen, align 1
  %tobool1 = trunc i8 %3 to i1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %tobool1, %land.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_map_direct_read(%struct.bpf_map* noundef %map, i32 noundef %off, i32 noundef %size, i64* noundef %val) #0 {
entry:
  %retval = alloca i32, align 4
  %map.addr = alloca %struct.bpf_map*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %val.addr = alloca i64*, align 8
  %ptr = alloca i8*, align 8
  %addr = alloca i64, align 8
  %err = alloca i32, align 4
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i64* %val, i64** %val.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 0
  %1 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_direct_value_addr = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %1, i32 0, i32 26
  %2 = load i32 (%struct.bpf_map*, i64*, i32)*, i32 (%struct.bpf_map*, i64*, i32)** %map_direct_value_addr, align 8
  %3 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %4 = load i32, i32* %off.addr, align 4
  %call = call i32 %2(%struct.bpf_map* noundef %3, i64* noundef %addr, i32 noundef %4) #11
  store i32 %call, i32* %err, align 4
  %5 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, i32* %err, align 4
  store i32 %6, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i64, i64* %addr, align 8
  %8 = inttoptr i64 %7 to i8*
  %9 = load i32, i32* %off.addr, align 4
  %idx.ext = sext i32 %9 to i64
  %add.ptr = getelementptr i8, i8* %8, i64 %idx.ext
  store i8* %add.ptr, i8** %ptr, align 8
  %10 = load i32, i32* %size.addr, align 4
  switch i32 %10, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb1
    i32 4, label %sw.bb3
    i32 8, label %sw.bb5
  ]

sw.bb:                                            ; preds = %if.end
  %11 = load i8*, i8** %ptr, align 8
  %12 = load i8, i8* %11, align 1
  %conv = zext i8 %12 to i64
  %13 = load i64*, i64** %val.addr, align 8
  store i64 %conv, i64* %13, align 8
  br label %sw.epilog

sw.bb1:                                           ; preds = %if.end
  %14 = load i8*, i8** %ptr, align 8
  %15 = bitcast i8* %14 to i16*
  %16 = load i16, i16* %15, align 2
  %conv2 = zext i16 %16 to i64
  %17 = load i64*, i64** %val.addr, align 8
  store i64 %conv2, i64* %17, align 8
  br label %sw.epilog

sw.bb3:                                           ; preds = %if.end
  %18 = load i8*, i8** %ptr, align 8
  %19 = bitcast i8* %18 to i32*
  %20 = load i32, i32* %19, align 4
  %conv4 = zext i32 %20 to i64
  %21 = load i64*, i64** %val.addr, align 8
  store i64 %conv4, i64* %21, align 8
  br label %sw.epilog

sw.bb5:                                           ; preds = %if.end
  %22 = load i8*, i8** %ptr, align 8
  %23 = bitcast i8* %22 to i64*
  %24 = load i64, i64* %23, align 8
  %25 = load i64*, i64** %val.addr, align 8
  store i64 %24, i64* %25, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb5, %sw.bb3, %sw.bb1, %sw.bb
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %if.then
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ctx_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %off, i32 noundef %size, i32 noundef %t, i32* noundef %reg_type, i32* noundef %btf_id) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %reg_type.addr = alloca i32*, align 8
  %btf_id.addr = alloca i32*, align 8
  %info = alloca %struct.bpf_insn_access_aux, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  store i32* %reg_type, i32** %reg_type.addr, align 8
  store i32* %btf_id, i32** %btf_id.addr, align 8
  %reg_type1 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 0
  %0 = load i32*, i32** %reg_type.addr, align 8
  %1 = load i32, i32* %0, align 4
  store i32 %1, i32* %reg_type1, align 8
  %2 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %3 = bitcast %struct.atomic_t* %2 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %3, i8 0, i64 4, i1 false)
  %log = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 2
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %4, i32 0, i32 22
  store %struct.bpf_verifier_log* %log2, %struct.bpf_verifier_log** %log, align 8
  %5 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %5, i32 0, i32 3
  %6 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %is_valid_access = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %6, i32 0, i32 1
  %7 = load i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)*, i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)** %is_valid_access, align 8
  %tobool = icmp ne i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)* %7, null
  br i1 %tobool, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %entry
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 3
  %9 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops3, align 8
  %is_valid_access4 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %9, i32 0, i32 1
  %10 = load i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)*, i1 (i32, i32, i32, %struct.bpf_prog*, %struct.bpf_insn_access_aux*)** %is_valid_access4, align 8
  %11 = load i32, i32* %off.addr, align 4
  %12 = load i32, i32* %size.addr, align 4
  %13 = load i32, i32* %t.addr, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 2
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %call = call zeroext i1 %10(i32 noundef %11, i32 noundef %12, i32 noundef %13, %struct.bpf_prog* noundef %15, %struct.bpf_insn_access_aux* noundef %info) #11
  br i1 %call, label %if.then, label %if.end18

if.then:                                          ; preds = %land.lhs.true
  %reg_type5 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 0
  %16 = load i32, i32* %reg_type5, align 8
  %17 = load i32*, i32** %reg_type.addr, align 8
  store i32 %16, i32* %17, align 4
  %18 = load i32*, i32** %reg_type.addr, align 8
  %19 = load i32, i32* %18, align 4
  %cmp = icmp eq i32 %19, 19
  br i1 %cmp, label %if.then7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %20 = load i32*, i32** %reg_type.addr, align 8
  %21 = load i32, i32* %20, align 4
  %cmp6 = icmp eq i32 %21, 20
  br i1 %cmp6, label %if.then7, label %if.else

if.then7:                                         ; preds = %lor.lhs.false, %if.then
  %22 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %btf_id8 = bitcast %struct.atomic_t* %22 to i32*
  %23 = load i32, i32* %btf_id8, align 4
  %24 = load i32*, i32** %btf_id.addr, align 8
  store i32 %23, i32* %24, align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %25 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %ctx_field_size = bitcast %struct.atomic_t* %25 to i32*
  %26 = load i32, i32* %ctx_field_size, align 4
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 20
  %28 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %29 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %29 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %28, i64 %idxprom
  %ctx_field_size9 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 2
  store i32 %26, i32* %ctx_field_size9, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then7
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %30, i32 0, i32 2
  %31 = load %struct.bpf_prog*, %struct.bpf_prog** %prog10, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %31, i32 0, i32 7
  %32 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_ctx_offset = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %32, i32 0, i32 2
  %33 = load i32, i32* %max_ctx_offset, align 4
  %34 = load i32, i32* %off.addr, align 4
  %35 = load i32, i32* %size.addr, align 4
  %add = add i32 %34, %35
  %cmp11 = icmp ult i32 %33, %add
  br i1 %cmp11, label %if.then12, label %if.end17

if.then12:                                        ; preds = %if.end
  %36 = load i32, i32* %off.addr, align 4
  %37 = load i32, i32* %size.addr, align 4
  %add13 = add i32 %36, %37
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog14 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %38, i32 0, i32 2
  %39 = load %struct.bpf_prog*, %struct.bpf_prog** %prog14, align 8
  %aux15 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %39, i32 0, i32 7
  %40 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux15, align 8
  %max_ctx_offset16 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %40, i32 0, i32 2
  store i32 %add13, i32* %max_ctx_offset16, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then12, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end18:                                         ; preds = %land.lhs.true, %entry
  %41 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %42 = bitcast %struct.bpf_verifier_env* %41 to i8*
  %43 = load i32, i32* %off.addr, align 4
  %44 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %42, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.228, i64 0, i64 0), i32 noundef %43, i32 noundef %44) #11
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.end17
  %45 = load i32, i32* %retval, align 4
  ret i32 %45
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #11
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %7 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 8
  %call2 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %9, i64 %11) #11
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %arraydecay3 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.201, i64 0, i64 0), i8* noundef %arraydecay3, i32 noundef %14, i32 noundef %15) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %16 = load i32, i32* %off.addr, align 4
  %cmp = icmp sge i32 %16, 0
  br i1 %cmp, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %17 = load i32, i32* %off.addr, align 4
  %cmp4 = icmp slt i32 %17, -512
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  %20 = load i32, i32* %off.addr, align 4
  %21 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.202, i64 0, i64 0), i32 noundef %20, i32 noundef %21) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %22 = load i32, i32* %retval, align 4
  ret i32 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_write(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state, i32 noundef %off, i32 noundef %size, i32 noundef %value_regno, i32 noundef %insn_idx) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %insn_idx.addr = alloca i32, align 4
  %cur = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %err = alloca i32, align 4
  %dst_reg = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %sanitize = alloca i8, align 1
  %poff = alloca i32*, align 8
  %soff = alloca i32, align 4
  %type109 = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  %0 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %0
  %sub1 = sub i32 %sub, 1
  store i32 %sub1, i32* %slot, align 4
  %1 = load i32, i32* %slot, align 4
  %div = sdiv i32 %1, 8
  store i32 %div, i32* %spi, align 4
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 2
  %3 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %3, i32 0, i32 11
  %4 = load i32, i32* %insn_idx.addr, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 %idxprom
  %dst_reg2 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg2, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv = zext i8 %bf.clear to i32
  store i32 %conv, i32* %dst_reg, align 4
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %reg, align 8
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %6 = load i32, i32* %slot, align 4
  %add = add i32 %6, 1
  %sub3 = sub i32 %add, 1
  %or = or i32 %sub3, 7
  %add4 = add i32 %or, 1
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 4
  %8 = load i32, i32* %acquired_refs, align 4
  %call = call i32 @realloc_func_state(%struct.bpf_func_state* noundef %5, i32 noundef %add4, i32 noundef %8, i1 noundef zeroext true) #11
  store i32 %call, i32* %err, align 4
  %9 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load i32, i32* %err, align 4
  store i32 %10, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 14
  %12 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool5 = trunc i8 %12 to i1
  br i1 %tobool5, label %if.end15, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 7
  %14 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %15 = load i32, i32* %spi, align 4
  %idxprom6 = sext i32 %15 to i64
  %arrayidx7 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %14, i64 %idxprom6
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx7, i32 0, i32 1
  %arrayidx8 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %16 = load i8, i8* %arrayidx8, align 8
  %conv9 = zext i8 %16 to i32
  %cmp = icmp eq i32 %conv9, 1
  br i1 %cmp, label %land.lhs.true11, label %if.end15

land.lhs.true11:                                  ; preds = %land.lhs.true
  %17 = load i32, i32* %size.addr, align 4
  %cmp12 = icmp ne i32 %17, 8
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true11
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %19 = bitcast %struct.bpf_verifier_env* %18 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %19, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.229, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %land.lhs.true11, %land.lhs.true, %if.end
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %20, i32 0, i32 8
  %21 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %21, i32 0, i32 0
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state16 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %22, i32 0, i32 8
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state16, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 4
  %24 = load i32, i32* %curframe, align 8
  %idxprom17 = zext i32 %24 to i64
  %arrayidx18 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom17
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx18, align 8
  store %struct.bpf_func_state* %25, %struct.bpf_func_state** %cur, align 8
  %26 = load i32, i32* %value_regno.addr, align 4
  %cmp19 = icmp sge i32 %26, 0
  br i1 %cmp19, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end15
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 0
  %28 = load i32, i32* %value_regno.addr, align 4
  %idxprom22 = sext i32 %28 to i64
  %arrayidx23 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom22
  store %struct.bpf_reg_state* %arrayidx23, %struct.bpf_reg_state** %reg, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end15
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool25 = icmp ne %struct.bpf_reg_state* %29, null
  br i1 %tobool25, label %land.lhs.true26, label %if.else

land.lhs.true26:                                  ; preds = %if.end24
  %30 = load i32, i32* %size.addr, align 4
  %cmp27 = icmp eq i32 %30, 8
  br i1 %cmp27, label %land.lhs.true29, label %if.else

land.lhs.true29:                                  ; preds = %land.lhs.true26
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call30 = call zeroext i1 @register_is_bounded(%struct.bpf_reg_state* noundef %31) #11
  br i1 %call30, label %land.lhs.true32, label %if.else

land.lhs.true32:                                  ; preds = %land.lhs.true29
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call33 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %32) #11
  br i1 %call33, label %if.else, label %land.lhs.true34

land.lhs.true34:                                  ; preds = %land.lhs.true32
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 16
  %34 = load i8, i8* %bpf_capable, align 2
  %tobool35 = trunc i8 %34 to i1
  br i1 %tobool35, label %if.then37, label %if.else

if.then37:                                        ; preds = %land.lhs.true34
  %35 = load i32, i32* %dst_reg, align 4
  %cmp38 = icmp ne i32 %35, 10
  br i1 %cmp38, label %if.then40, label %if.end45

if.then40:                                        ; preds = %if.then37
  %36 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %37 = load i32, i32* %value_regno.addr, align 4
  %call41 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %36, i32 noundef %37) #11
  store i32 %call41, i32* %err, align 4
  %38 = load i32, i32* %err, align 4
  %tobool42 = icmp ne i32 %38, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.then40
  %39 = load i32, i32* %err, align 4
  store i32 %39, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %if.then40
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %if.then37
  %40 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %41 = load i32, i32* %spi, align 4
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @save_register_state(%struct.bpf_func_state* noundef %40, i32 noundef %41, %struct.bpf_reg_state* noundef %42) #11
  br label %if.end172

if.else:                                          ; preds = %land.lhs.true34, %land.lhs.true32, %land.lhs.true29, %land.lhs.true26, %if.end24
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool46 = icmp ne %struct.bpf_reg_state* %43, null
  br i1 %tobool46, label %land.lhs.true47, label %if.else108

land.lhs.true47:                                  ; preds = %if.else
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %44, i32 0, i32 0
  %45 = load i32, i32* %type, align 8
  %call48 = call zeroext i1 @is_spillable_regtype(i32 noundef %45) #11
  br i1 %call48, label %if.then50, label %if.else108

if.then50:                                        ; preds = %land.lhs.true47
  %46 = load i32, i32* %size.addr, align 4
  %cmp51 = icmp ne i32 %46, 8
  br i1 %cmp51, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.then50
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = load i32, i32* %insn_idx.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %47, i32 noundef %48, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.102, i64 0, i64 0)) #11
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %50 = bitcast %struct.bpf_verifier_env* %49 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %50, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.230, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.then50
  %51 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %52 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur, align 8
  %cmp55 = icmp ne %struct.bpf_func_state* %51, %52
  br i1 %cmp55, label %land.lhs.true57, label %if.end62

land.lhs.true57:                                  ; preds = %if.end54
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type58 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %53, i32 0, i32 0
  %54 = load i32, i32* %type58, align 8
  %cmp59 = icmp eq i32 %54, 6
  br i1 %cmp59, label %if.then61, label %if.end62

if.then61:                                        ; preds = %land.lhs.true57
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = bitcast %struct.bpf_verifier_env* %55 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %56, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.231, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end62:                                         ; preds = %land.lhs.true57, %if.end54
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v4 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %57, i32 0, i32 18
  %58 = load i8, i8* %bypass_spec_v4, align 4
  %tobool63 = trunc i8 %58 to i1
  br i1 %tobool63, label %if.end107, label %if.then64

if.then64:                                        ; preds = %if.end62
  store i8 0, i8* %sanitize, align 1
  %59 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack65 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %59, i32 0, i32 7
  %60 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack65, align 8
  %61 = load i32, i32* %spi, align 4
  %idxprom66 = sext i32 %61 to i64
  %arrayidx67 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %60, i64 %idxprom66
  %slot_type68 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx67, i32 0, i32 1
  %arrayidx69 = getelementptr [8 x i8], [8 x i8]* %slot_type68, i64 0, i64 0
  %62 = load i8, i8* %arrayidx69, align 8
  %conv70 = zext i8 %62 to i32
  %cmp71 = icmp eq i32 %conv70, 1
  br i1 %cmp71, label %land.lhs.true73, label %if.end80

land.lhs.true73:                                  ; preds = %if.then64
  %63 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack74 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %63, i32 0, i32 7
  %64 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack74, align 8
  %65 = load i32, i32* %spi, align 4
  %idxprom75 = sext i32 %65 to i64
  %arrayidx76 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %64, i64 %idxprom75
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx76, i32 0, i32 0
  %call77 = call zeroext i1 @register_is_const(%struct.bpf_reg_state* noundef %spilled_ptr) #11
  br i1 %call77, label %if.then79, label %if.end80

if.then79:                                        ; preds = %land.lhs.true73
  store i8 1, i8* %sanitize, align 1
  br label %if.end80

if.end80:                                         ; preds = %if.then79, %land.lhs.true73, %if.then64
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end80
  %66 = load i32, i32* %i, align 4
  %cmp81 = icmp slt i32 %66, 8
  br i1 %cmp81, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %67 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack83 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %67, i32 0, i32 7
  %68 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack83, align 8
  %69 = load i32, i32* %spi, align 4
  %idxprom84 = sext i32 %69 to i64
  %arrayidx85 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %68, i64 %idxprom84
  %slot_type86 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx85, i32 0, i32 1
  %70 = load i32, i32* %i, align 4
  %idxprom87 = sext i32 %70 to i64
  %arrayidx88 = getelementptr [8 x i8], [8 x i8]* %slot_type86, i64 0, i64 %idxprom87
  %71 = load i8, i8* %arrayidx88, align 1
  %conv89 = zext i8 %71 to i32
  %cmp90 = icmp eq i32 %conv89, 2
  br i1 %cmp90, label %if.then92, label %if.end93

if.then92:                                        ; preds = %for.body
  store i8 1, i8* %sanitize, align 1
  br label %for.end

if.end93:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end93
  %72 = load i32, i32* %i, align 4
  %inc = add i32 %72, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then92, %for.cond
  %73 = load i8, i8* %sanitize, align 1
  %tobool94 = trunc i8 %73 to i1
  br i1 %tobool94, label %if.then95, label %if.end106

if.then95:                                        ; preds = %for.end
  %74 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %74, i32 0, i32 20
  %75 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %76 = load i32, i32* %insn_idx.addr, align 4
  %idxprom96 = sext i32 %76 to i64
  %arrayidx97 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %75, i64 %idxprom96
  %sanitize_stack_off = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx97, i32 0, i32 3
  store i32* %sanitize_stack_off, i32** %poff, align 8
  %77 = load i32, i32* %spi, align 4
  %sub98 = sub i32 0, %77
  %sub99 = sub i32 %sub98, 1
  %mul = mul i32 %sub99, 8
  store i32 %mul, i32* %soff, align 4
  %78 = load i32*, i32** %poff, align 8
  %79 = load i32, i32* %78, align 4
  %tobool100 = icmp ne i32 %79, 0
  br i1 %tobool100, label %land.lhs.true101, label %if.end105

land.lhs.true101:                                 ; preds = %if.then95
  %80 = load i32*, i32** %poff, align 8
  %81 = load i32, i32* %80, align 4
  %82 = load i32, i32* %soff, align 4
  %cmp102 = icmp ne i32 %81, %82
  br i1 %cmp102, label %if.then104, label %if.end105

if.then104:                                       ; preds = %land.lhs.true101
  %83 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %84 = bitcast %struct.bpf_verifier_env* %83 to i8*
  %85 = load i32, i32* %insn_idx.addr, align 4
  %86 = load i32*, i32** %poff, align 8
  %87 = load i32, i32* %86, align 4
  %88 = load i32, i32* %soff, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %84, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.232, i64 0, i64 0), i32 noundef %85, i32 noundef %87, i32 noundef %88) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end105:                                        ; preds = %land.lhs.true101, %if.then95
  %89 = load i32, i32* %soff, align 4
  %90 = load i32*, i32** %poff, align 8
  store i32 %89, i32* %90, align 4
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %for.end
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %if.end62
  %91 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %92 = load i32, i32* %spi, align 4
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  call void @save_register_state(%struct.bpf_func_state* noundef %91, i32 noundef %92, %struct.bpf_reg_state* noundef %93) #11
  br label %if.end171

if.else108:                                       ; preds = %land.lhs.true47, %if.else
  store i8 2, i8* %type109, align 1
  %94 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack110 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %94, i32 0, i32 7
  %95 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack110, align 8
  %96 = load i32, i32* %spi, align 4
  %idxprom111 = sext i32 %96 to i64
  %arrayidx112 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %95, i64 %idxprom111
  %spilled_ptr113 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx112, i32 0, i32 0
  %type114 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr113, i32 0, i32 0
  store i32 0, i32* %type114, align 8
  %97 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack115 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %97, i32 0, i32 7
  %98 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack115, align 8
  %99 = load i32, i32* %spi, align 4
  %idxprom116 = sext i32 %99 to i64
  %arrayidx117 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %98, i64 %idxprom116
  %slot_type118 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx117, i32 0, i32 1
  %arrayidx119 = getelementptr [8 x i8], [8 x i8]* %slot_type118, i64 0, i64 0
  %100 = load i8, i8* %arrayidx119, align 8
  %conv120 = zext i8 %100 to i32
  %cmp121 = icmp eq i32 %conv120, 1
  br i1 %cmp121, label %if.then123, label %if.end137

if.then123:                                       ; preds = %if.else108
  store i32 0, i32* %i, align 4
  br label %for.cond124

for.cond124:                                      ; preds = %for.inc134, %if.then123
  %101 = load i32, i32* %i, align 4
  %cmp125 = icmp slt i32 %101, 8
  br i1 %cmp125, label %for.body127, label %for.end136

for.body127:                                      ; preds = %for.cond124
  %102 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack128 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %102, i32 0, i32 7
  %103 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack128, align 8
  %104 = load i32, i32* %spi, align 4
  %idxprom129 = sext i32 %104 to i64
  %arrayidx130 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %103, i64 %idxprom129
  %slot_type131 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx130, i32 0, i32 1
  %105 = load i32, i32* %i, align 4
  %idxprom132 = sext i32 %105 to i64
  %arrayidx133 = getelementptr [8 x i8], [8 x i8]* %slot_type131, i64 0, i64 %idxprom132
  store i8 2, i8* %arrayidx133, align 1
  br label %for.inc134

for.inc134:                                       ; preds = %for.body127
  %106 = load i32, i32* %i, align 4
  %inc135 = add i32 %106, 1
  store i32 %inc135, i32* %i, align 4
  br label %for.cond124

for.end136:                                       ; preds = %for.cond124
  br label %if.end137

if.end137:                                        ; preds = %for.end136, %if.else108
  %107 = load i32, i32* %size.addr, align 4
  %cmp138 = icmp eq i32 %107, 8
  br i1 %cmp138, label %if.then140, label %if.end146

if.then140:                                       ; preds = %if.end137
  %108 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack141 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %108, i32 0, i32 7
  %109 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack141, align 8
  %110 = load i32, i32* %spi, align 4
  %idxprom142 = sext i32 %110 to i64
  %arrayidx143 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %109, i64 %idxprom142
  %spilled_ptr144 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx143, i32 0, i32 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr144, i32 0, i32 17
  %111 = load i32, i32* %live, align 8
  %or145 = or i32 %111, 4
  store i32 %or145, i32* %live, align 8
  br label %if.end146

if.end146:                                        ; preds = %if.then140, %if.end137
  %112 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %tobool147 = icmp ne %struct.bpf_reg_state* %112, null
  br i1 %tobool147, label %land.lhs.true148, label %if.end156

land.lhs.true148:                                 ; preds = %if.end146
  %113 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call149 = call zeroext i1 @register_is_null(%struct.bpf_reg_state* noundef %113) #11
  br i1 %call149, label %if.then151, label %if.end156

if.then151:                                       ; preds = %land.lhs.true148
  %114 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %115 = load i32, i32* %value_regno.addr, align 4
  %call152 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %114, i32 noundef %115) #11
  store i32 %call152, i32* %err, align 4
  %116 = load i32, i32* %err, align 4
  %tobool153 = icmp ne i32 %116, 0
  br i1 %tobool153, label %if.then154, label %if.end155

if.then154:                                       ; preds = %if.then151
  %117 = load i32, i32* %err, align 4
  store i32 %117, i32* %retval, align 4
  br label %return

if.end155:                                        ; preds = %if.then151
  store i8 3, i8* %type109, align 1
  br label %if.end156

if.end156:                                        ; preds = %if.end155, %land.lhs.true148, %if.end146
  store i32 0, i32* %i, align 4
  br label %for.cond157

for.cond157:                                      ; preds = %for.inc168, %if.end156
  %118 = load i32, i32* %i, align 4
  %119 = load i32, i32* %size.addr, align 4
  %cmp158 = icmp slt i32 %118, %119
  br i1 %cmp158, label %for.body160, label %for.end170

for.body160:                                      ; preds = %for.cond157
  %120 = load i8, i8* %type109, align 1
  %121 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack161 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %121, i32 0, i32 7
  %122 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack161, align 8
  %123 = load i32, i32* %spi, align 4
  %idxprom162 = sext i32 %123 to i64
  %arrayidx163 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %122, i64 %idxprom162
  %slot_type164 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx163, i32 0, i32 1
  %124 = load i32, i32* %slot, align 4
  %125 = load i32, i32* %i, align 4
  %sub165 = sub i32 %124, %125
  %rem = srem i32 %sub165, 8
  %idxprom166 = sext i32 %rem to i64
  %arrayidx167 = getelementptr [8 x i8], [8 x i8]* %slot_type164, i64 0, i64 %idxprom166
  store i8 %120, i8* %arrayidx167, align 1
  br label %for.inc168

for.inc168:                                       ; preds = %for.body160
  %126 = load i32, i32* %i, align 4
  %inc169 = add i32 %126, 1
  store i32 %inc169, i32* %i, align 4
  br label %for.cond157

for.end170:                                       ; preds = %for.cond157
  br label %if.end171

if.end171:                                        ; preds = %for.end170, %if.end107
  br label %if.end172

if.end172:                                        ; preds = %if.end171, %if.end45
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end172, %if.then154, %if.then104, %if.then61, %if.then53, %if.then43, %if.then14, %if.then
  %127 = load i32, i32* %retval, align 4
  ret i32 %127
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_stack_read(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %reg_state, i32 noundef %off, i32 noundef %size, i32 noundef %value_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg_state.addr = alloca %struct.bpf_func_state*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %slot = alloca i32, align 4
  %spi = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %stype = alloca i8*, align 8
  %zeros = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %reg_state, %struct.bpf_func_state** %reg_state.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load i32, i32* %off.addr, align 4
  %sub = sub i32 0, %6
  %sub1 = sub i32 %sub, 1
  store i32 %sub1, i32* %slot, align 4
  %7 = load i32, i32* %slot, align 4
  %div = sdiv i32 %7, 8
  store i32 %div, i32* %spi, align 4
  %8 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %8, i32 0, i32 6
  %9 = load i32, i32* %allocated_stack, align 8
  %10 = load i32, i32* %slot, align 4
  %cmp = icmp sle i32 %9, %10
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.233, i64 0, i64 0), i32 noundef %13, i32 noundef %14) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 7
  %16 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %17 = load i32, i32* %spi, align 4
  %idxprom2 = sext i32 %17 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %16, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  store i8* %arraydecay, i8** %stype, align 8
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %reg_state.addr, align 8
  %stack4 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 7
  %19 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack4, align 8
  %20 = load i32, i32* %spi, align 4
  %idxprom5 = sext i32 %20 to i64
  %arrayidx6 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %19, i64 %idxprom5
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx6, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %reg, align 8
  %21 = load i8*, i8** %stype, align 8
  %arrayidx7 = getelementptr i8, i8* %21, i64 0
  %22 = load i8, i8* %arrayidx7, align 1
  %conv = zext i8 %22 to i32
  %cmp8 = icmp eq i32 %conv, 1
  br i1 %cmp8, label %if.then10, label %if.else54

if.then10:                                        ; preds = %if.end
  %23 = load i32, i32* %size.addr, align 4
  %cmp11 = icmp ne i32 %23, 8
  br i1 %cmp11, label %if.then13, label %if.end26

if.then13:                                        ; preds = %if.then10
  %24 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %24, i32 0, i32 0
  %25 = load i32, i32* %type, align 8
  %cmp14 = icmp ne i32 %25, 1
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then13
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 0
  %28 = load i32, i32* %insn_idx, align 8
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %26, i32 noundef %28, i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str.102, i64 0, i64 0)) #11
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.234, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.then13
  %31 = load i32, i32* %value_regno.addr, align 4
  %cmp18 = icmp sge i32 %31, 0
  br i1 %cmp18, label %if.then20, label %if.end25

if.then20:                                        ; preds = %if.end17
  %32 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %33 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %33, i32 0, i32 0
  %arraydecay21 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %34 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %32, %struct.bpf_reg_state* noundef %arraydecay21, i32 noundef %34) #11
  %35 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs22 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %35, i32 0, i32 0
  %36 = load i32, i32* %value_regno.addr, align 4
  %idxprom23 = sext i32 %36 to i64
  %arrayidx24 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs22, i64 0, i64 %idxprom23
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx24, i32 0, i32 17
  %37 = load i32, i32* %live, align 8
  %or = or i32 %37, 4
  store i32 %or, i32* %live, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then20, %if.end17
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %40 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %40, i32 0, i32 14
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent, align 8
  %call = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %38, %struct.bpf_reg_state* noundef %39, %struct.bpf_reg_state* noundef %41, i8 noundef zeroext 2) #11
  store i32 0, i32* %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.then10
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end26
  %42 = load i32, i32* %i, align 4
  %cmp27 = icmp slt i32 %42, 8
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %43 = load i8*, i8** %stype, align 8
  %44 = load i32, i32* %slot, align 4
  %45 = load i32, i32* %i, align 4
  %sub29 = sub i32 %44, %45
  %rem = srem i32 %sub29, 8
  %idxprom30 = sext i32 %rem to i64
  %arrayidx31 = getelementptr i8, i8* %43, i64 %idxprom30
  %46 = load i8, i8* %arrayidx31, align 1
  %conv32 = zext i8 %46 to i32
  %cmp33 = icmp ne i32 %conv32, 1
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %for.body
  %47 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %48 = bitcast %struct.bpf_verifier_env* %47 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %48, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.235, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end36
  %49 = load i32, i32* %i, align 4
  %inc = add i32 %49, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %50 = load i32, i32* %value_regno.addr, align 4
  %cmp37 = icmp sge i32 %50, 0
  br i1 %cmp37, label %if.then39, label %if.else

if.then39:                                        ; preds = %for.end
  %51 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs40 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %51, i32 0, i32 0
  %52 = load i32, i32* %value_regno.addr, align 4
  %idxprom41 = sext i32 %52 to i64
  %arrayidx42 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs40, i64 0, i64 %idxprom41
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %54 = bitcast %struct.bpf_reg_state* %arrayidx42 to i8*
  %55 = bitcast %struct.bpf_reg_state* %53 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %54, i8* align 8 %55, i64 120, i1 false)
  %56 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs43 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %56, i32 0, i32 0
  %57 = load i32, i32* %value_regno.addr, align 4
  %idxprom44 = sext i32 %57 to i64
  %arrayidx45 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs43, i64 0, i64 %idxprom44
  %live46 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx45, i32 0, i32 17
  %58 = load i32, i32* %live46, align 8
  %or47 = or i32 %58, 4
  store i32 %or47, i32* %live46, align 8
  br label %if.end51

if.else:                                          ; preds = %for.end
  %59 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %59, i32 0, i32 14
  %60 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool = trunc i8 %60 to i1
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %call48 = call zeroext i1 @__is_pointer_value(i1 noundef zeroext %tobool, %struct.bpf_reg_state* noundef %61) #11
  br i1 %call48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.else
  %62 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %63 = bitcast %struct.bpf_verifier_env* %62 to i8*
  %64 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %63, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.236, i64 0, i64 0), i32 noundef %64) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end50:                                         ; preds = %if.else
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.then39
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %66 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent52 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i32 0, i32 14
  %68 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent52, align 8
  %call53 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %65, %struct.bpf_reg_state* noundef %66, %struct.bpf_reg_state* noundef %68, i8 noundef zeroext 2) #11
  br label %if.end105

if.else54:                                        ; preds = %if.end
  store i32 0, i32* %zeros, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond55

for.cond55:                                       ; preds = %for.inc78, %if.else54
  %69 = load i32, i32* %i, align 4
  %70 = load i32, i32* %size.addr, align 4
  %cmp56 = icmp slt i32 %69, %70
  br i1 %cmp56, label %for.body58, label %for.end80

for.body58:                                       ; preds = %for.cond55
  %71 = load i8*, i8** %stype, align 8
  %72 = load i32, i32* %slot, align 4
  %73 = load i32, i32* %i, align 4
  %sub59 = sub i32 %72, %73
  %rem60 = srem i32 %sub59, 8
  %idxprom61 = sext i32 %rem60 to i64
  %arrayidx62 = getelementptr i8, i8* %71, i64 %idxprom61
  %74 = load i8, i8* %arrayidx62, align 1
  %conv63 = zext i8 %74 to i32
  %cmp64 = icmp eq i32 %conv63, 2
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %for.body58
  br label %for.inc78

if.end67:                                         ; preds = %for.body58
  %75 = load i8*, i8** %stype, align 8
  %76 = load i32, i32* %slot, align 4
  %77 = load i32, i32* %i, align 4
  %sub68 = sub i32 %76, %77
  %rem69 = srem i32 %sub68, 8
  %idxprom70 = sext i32 %rem69 to i64
  %arrayidx71 = getelementptr i8, i8* %75, i64 %idxprom70
  %78 = load i8, i8* %arrayidx71, align 1
  %conv72 = zext i8 %78 to i32
  %cmp73 = icmp eq i32 %conv72, 3
  br i1 %cmp73, label %if.then75, label %if.end77

if.then75:                                        ; preds = %if.end67
  %79 = load i32, i32* %zeros, align 4
  %inc76 = add i32 %79, 1
  store i32 %inc76, i32* %zeros, align 4
  br label %for.inc78

if.end77:                                         ; preds = %if.end67
  %80 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %81 = bitcast %struct.bpf_verifier_env* %80 to i8*
  %82 = load i32, i32* %off.addr, align 4
  %83 = load i32, i32* %i, align 4
  %84 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %81, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.237, i64 0, i64 0), i32 noundef %82, i32 noundef %83, i32 noundef %84) #11
  store i32 -13, i32* %retval, align 4
  br label %return

for.inc78:                                        ; preds = %if.then75, %if.then66
  %85 = load i32, i32* %i, align 4
  %inc79 = add i32 %85, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond55

for.end80:                                        ; preds = %for.cond55
  %86 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %parent81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 14
  %89 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent81, align 8
  %call82 = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %86, %struct.bpf_reg_state* noundef %87, %struct.bpf_reg_state* noundef %89, i8 noundef zeroext 2) #11
  %90 = load i32, i32* %value_regno.addr, align 4
  %cmp83 = icmp sge i32 %90, 0
  br i1 %cmp83, label %if.then85, label %if.end104

if.then85:                                        ; preds = %for.end80
  %91 = load i32, i32* %zeros, align 4
  %92 = load i32, i32* %size.addr, align 4
  %cmp86 = icmp eq i32 %91, %92
  br i1 %cmp86, label %if.then88, label %if.else95

if.then88:                                        ; preds = %if.then85
  %93 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs89 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %93, i32 0, i32 0
  %94 = load i32, i32* %value_regno.addr, align 4
  %idxprom90 = sext i32 %94 to i64
  %arrayidx91 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs89, i64 0, i64 %idxprom90
  call void @__mark_reg_const_zero(%struct.bpf_reg_state* noundef %arrayidx91) #11
  %95 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs92 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %95, i32 0, i32 0
  %96 = load i32, i32* %value_regno.addr, align 4
  %idxprom93 = sext i32 %96 to i64
  %arrayidx94 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs92, i64 0, i64 %idxprom93
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx94, i32 0, i32 18
  store i8 1, i8* %precise, align 4
  br label %if.end98

if.else95:                                        ; preds = %if.then85
  %97 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %98 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs96 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %98, i32 0, i32 0
  %arraydecay97 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs96, i64 0, i64 0
  %99 = load i32, i32* %value_regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %97, %struct.bpf_reg_state* noundef %arraydecay97, i32 noundef %99) #11
  br label %if.end98

if.end98:                                         ; preds = %if.else95, %if.then88
  %100 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs99 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %100, i32 0, i32 0
  %101 = load i32, i32* %value_regno.addr, align 4
  %idxprom100 = sext i32 %101 to i64
  %arrayidx101 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs99, i64 0, i64 %idxprom100
  %live102 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx101, i32 0, i32 17
  %102 = load i32, i32* %live102, align 8
  %or103 = or i32 %102, 4
  store i32 %or103, i32* %live102, align 8
  br label %if.end104

if.end104:                                        ; preds = %if.end98, %for.end80
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %if.end51
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end105, %if.end77, %if.then49, %if.then35, %if.end25, %if.then16, %if.then
  %103 = load i32, i32* %retval, align 4
  ret i32 %103
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_flow_keys_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load i32, i32* %size.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp slt i32 %1, 0
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %off.addr, align 4
  %conv = sext i32 %2 to i64
  %3 = load i32, i32* %size.addr, align 4
  %conv3 = sext i32 %3 to i64
  %add = add i64 %conv, %conv3
  %cmp4 = icmp ugt i64 %add, 56
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  %6 = load i32, i32* %off.addr, align 4
  %7 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.239, i64 0, i64 0), i32 noundef %6, i32 noundef %7) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, i32* %retval, align 4
  ret i32 %8
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_sock_access(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_idx, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %t) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_idx.addr = alloca i32, align 4
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %regs = alloca %struct.bpf_reg_state*, align 8
  %reg = alloca %struct.bpf_reg_state*, align 8
  %info = alloca %struct.bpf_insn_access_aux, align 8
  %valid = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_idx, i32* %insn_idx.addr, align 4
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %t, i32* %t.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_reg_state* @cur_regs(%struct.bpf_verifier_env* noundef %0) #11
  store %struct.bpf_reg_state* %call, %struct.bpf_reg_state** %regs, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i64 %idxprom
  store %struct.bpf_reg_state* %arrayidx, %struct.bpf_reg_state** %reg, align 8
  %3 = bitcast %struct.bpf_insn_access_aux* %info to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %3, i8 0, i64 16, i1 false)
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 6
  %5 = load i64, i64* %smin_value, align 8
  %cmp = icmp slt i64 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  %8 = load i32, i32* %regno.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([84 x i8], [84 x i8]* @.str.194, i64 0, i64 0), i32 noundef %8) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 0
  %10 = load i32, i32* %type, align 8
  switch i32 %10, label %sw.default [
    i32 13, label %sw.bb
    i32 11, label %sw.bb2
    i32 15, label %sw.bb5
    i32 18, label %sw.bb8
  ]

sw.bb:                                            ; preds = %if.end
  %11 = load i32, i32* %off.addr, align 4
  %12 = load i32, i32* %size.addr, align 4
  %13 = load i32, i32* %t.addr, align 4
  %call1 = call zeroext i1 @bpf_sock_common_is_valid_access(i32 noundef %11, i32 noundef %12, i32 noundef %13, %struct.bpf_insn_access_aux* noundef %info) #11
  %frombool = zext i1 %call1 to i8
  store i8 %frombool, i8* %valid, align 1
  br label %sw.epilog

sw.bb2:                                           ; preds = %if.end
  %14 = load i32, i32* %off.addr, align 4
  %15 = load i32, i32* %size.addr, align 4
  %16 = load i32, i32* %t.addr, align 4
  %call3 = call zeroext i1 @bpf_sock_is_valid_access(i32 noundef %14, i32 noundef %15, i32 noundef %16, %struct.bpf_insn_access_aux* noundef %info) #11
  %frombool4 = zext i1 %call3 to i8
  store i8 %frombool4, i8* %valid, align 1
  br label %sw.epilog

sw.bb5:                                           ; preds = %if.end
  %17 = load i32, i32* %off.addr, align 4
  %18 = load i32, i32* %size.addr, align 4
  %19 = load i32, i32* %t.addr, align 4
  %call6 = call zeroext i1 @bpf_tcp_sock_is_valid_access(i32 noundef %17, i32 noundef %18, i32 noundef %19, %struct.bpf_insn_access_aux* noundef %info) #11
  %frombool7 = zext i1 %call6 to i8
  store i8 %frombool7, i8* %valid, align 1
  br label %sw.epilog

sw.bb8:                                           ; preds = %if.end
  %20 = load i32, i32* %off.addr, align 4
  %21 = load i32, i32* %size.addr, align 4
  %22 = load i32, i32* %t.addr, align 4
  %call9 = call zeroext i1 @bpf_xdp_sock_is_valid_access(i32 noundef %20, i32 noundef %21, i32 noundef %22, %struct.bpf_insn_access_aux* noundef %info) #11
  %frombool10 = zext i1 %call9 to i8
  store i8 %frombool10, i8* %valid, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  store i8 0, i8* %valid, align 1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb8, %sw.bb5, %sw.bb2, %sw.bb
  %23 = load i8, i8* %valid, align 1
  %tobool = trunc i8 %23 to i1
  br i1 %tobool, label %if.then11, label %if.end15

if.then11:                                        ; preds = %sw.epilog
  %24 = getelementptr inbounds %struct.bpf_insn_access_aux, %struct.bpf_insn_access_aux* %info, i32 0, i32 1
  %ctx_field_size = bitcast %struct.atomic_t* %24 to i32*
  %25 = load i32, i32* %ctx_field_size, align 4
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %26, i32 0, i32 20
  %27 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %28 = load i32, i32* %insn_idx.addr, align 4
  %idxprom12 = sext i32 %28 to i64
  %arrayidx13 = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %27, i64 %idxprom12
  %ctx_field_size14 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx13, i32 0, i32 2
  store i32 %25, i32* %ctx_field_size14, align 8
  store i32 0, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %sw.epilog
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load i32, i32* %regno.addr, align 4
  %32 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %type16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %32, i32 0, i32 0
  %33 = load i32, i32* %type16, align 8
  %idxprom17 = zext i32 %33 to i64
  %arrayidx18 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom17
  %34 = load i8*, i8** %arrayidx18, align 8
  %35 = load i32, i32* %off.addr, align 4
  %36 = load i32, i32* %size.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.240, i64 0, i64 0), i32 noundef %31, i8* noundef %34, i32 noundef %35, i32 noundef %36) #11
  store i32 -13, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then11, %if.then
  %37 = load i32, i32* %retval, align 4
  ret i32 %37
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_tp_buffer_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %regno, i32 noundef %off, i32 noundef %size) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %2 = load i32, i32* %regno.addr, align 4
  %3 = load i32, i32* %off.addr, align 4
  %4 = load i32, i32* %size.addr, align 4
  %call = call i32 @__check_buffer_access(%struct.bpf_verifier_env* noundef %0, i8* noundef getelementptr inbounds ([11 x i8], [11 x i8]* @.str.241, i64 0, i64 0), %struct.bpf_reg_state* noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) #11
  store i32 %call, i32* %err, align 4
  %5 = load i32, i32* %err, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, i32* %err, align 4
  store i32 %6, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i32, i32* %off.addr, align 4
  %8 = load i32, i32* %size.addr, align 4
  %add = add i32 %7, %8
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 2
  %10 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %10, i32 0, i32 7
  %11 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %max_tp_access = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %11, i32 0, i32 4
  %12 = load i32, i32* %max_tp_access, align 4
  %cmp = icmp ugt i32 %add, %12
  br i1 %cmp, label %if.then1, label %if.end6

if.then1:                                         ; preds = %if.end
  %13 = load i32, i32* %off.addr, align 4
  %14 = load i32, i32* %size.addr, align 4
  %add2 = add i32 %13, %14
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog3 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %15, i32 0, i32 2
  %16 = load %struct.bpf_prog*, %struct.bpf_prog** %prog3, align 8
  %aux4 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %16, i32 0, i32 7
  %17 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux4, align 8
  %max_tp_access5 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %17, i32 0, i32 4
  store i32 %add2, i32* %max_tp_access5, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then1, %if.end
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ptr_to_btf_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %atype, i32 noundef %value_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %atype.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %t = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %btf_id2 = alloca i32, align 4
  %ret = alloca i32, align 4
  %tn_buf = alloca [48 x i8], align 16
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %atype, i32* %atype.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %3, i32 0, i32 1
  %btf_id = bitcast %struct.bpf_iter_aux_info* %4 to i32*
  %5 = load i32, i32* %btf_id, align 8
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %2, i32 noundef %5) #11
  store %struct.btf_type* %call, %struct.btf_type** %t, align 8
  %6 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %7 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %7, i32 0, i32 0
  %8 = load i32, i32* %name_off, align 4
  %call1 = call i8* @btf_name_by_offset(%struct.btf* noundef %6, i32 noundef %8) #11
  store i8* %call1, i8** %tname, align 8
  %9 = load i32, i32* %off.addr, align 4
  %cmp = icmp slt i32 %9, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  %12 = load i32, i32* %regno.addr, align 4
  %13 = load i8*, i8** %tname, align 8
  %14 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.244, i64 0, i64 0), i32 noundef %12, i8* noundef %13, i32 noundef %14) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 5
  %16 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %17 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = load i64, i64* %17, align 8
  %19 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = load i64, i64* %19, align 8
  %call3 = call zeroext i1 @tnum_is_const(i64 %18, i64 %20) #11
  br i1 %call3, label %lor.lhs.false, label %if.then5

lor.lhs.false:                                    ; preds = %if.end
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off4, i32 0, i32 0
  %22 = load i64, i64* %value, align 8
  %tobool = icmp ne i64 %22, 0
  br i1 %tobool, label %if.then5, label %if.end9

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %var_off6 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 5
  %24 = bitcast %struct.tnum* %var_off6 to { i64, i64 }*
  %25 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = load i64, i64* %25, align 8
  %27 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = load i64, i64* %27, align 8
  %call7 = call i32 @tnum_strn(i8* noundef %arraydecay, i64 noundef 48, i64 %26, i64 %28) #11
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load i32, i32* %regno.addr, align 4
  %32 = load i8*, i8** %tname, align 8
  %33 = load i32, i32* %off.addr, align 4
  %arraydecay8 = getelementptr inbounds [48 x i8], [48 x i8]* %tn_buf, i64 0, i64 0
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.245, i64 0, i64 0), i32 noundef %31, i8* noundef %32, i32 noundef %33, i8* noundef %arraydecay8) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %lor.lhs.false
  %34 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %34, i32 0, i32 3
  %35 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops, align 8
  %btf_struct_access = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %35, i32 0, i32 5
  %36 = load i32 (%struct.bpf_verifier_log*, %struct.btf_type*, i32, i32, i32, i32*)*, i32 (%struct.bpf_verifier_log*, %struct.btf_type*, i32, i32, i32, i32*)** %btf_struct_access, align 8
  %tobool10 = icmp ne i32 (%struct.bpf_verifier_log*, %struct.btf_type*, i32, i32, i32, i32*)* %36, null
  br i1 %tobool10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end9
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %37, i32 0, i32 3
  %38 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %ops12, align 8
  %btf_struct_access13 = getelementptr inbounds %struct.bpf_verifier_ops, %struct.bpf_verifier_ops* %38, i32 0, i32 5
  %39 = load i32 (%struct.bpf_verifier_log*, %struct.btf_type*, i32, i32, i32, i32*)*, i32 (%struct.bpf_verifier_log*, %struct.btf_type*, i32, i32, i32, i32*)** %btf_struct_access13, align 8
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %40, i32 0, i32 22
  %41 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %42 = load i32, i32* %off.addr, align 4
  %43 = load i32, i32* %size.addr, align 4
  %44 = load i32, i32* %atype.addr, align 4
  %call14 = call i32 %39(%struct.bpf_verifier_log* noundef %log, %struct.btf_type* noundef %41, i32 noundef %42, i32 noundef %43, i32 noundef %44, i32* noundef %btf_id2) #11
  store i32 %call14, i32* %ret, align 4
  br label %if.end20

if.else:                                          ; preds = %if.end9
  %45 = load i32, i32* %atype.addr, align 4
  %cmp15 = icmp ne i32 %45, 1
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.else
  %46 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %47 = bitcast %struct.bpf_verifier_env* %46 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %47, i8* noundef getelementptr inbounds ([24 x i8], [24 x i8]* @.str.246, i64 0, i64 0)) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.else
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log18 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %48, i32 0, i32 22
  %49 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %50 = load i32, i32* %off.addr, align 4
  %51 = load i32, i32* %size.addr, align 4
  %52 = load i32, i32* %atype.addr, align 4
  %call19 = call i32 @btf_struct_access(%struct.bpf_verifier_log* noundef %log18, %struct.btf_type* noundef %49, i32 noundef %50, i32 noundef %51, i32 noundef %52, i32* noundef %btf_id2) #11
  store i32 %call19, i32* %ret, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.end17, %if.then11
  %53 = load i32, i32* %ret, align 4
  %cmp21 = icmp slt i32 %53, 0
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end20
  %54 = load i32, i32* %ret, align 4
  store i32 %54, i32* %retval, align 4
  br label %return

if.end23:                                         ; preds = %if.end20
  %55 = load i32, i32* %atype.addr, align 4
  %cmp24 = icmp eq i32 %55, 1
  br i1 %cmp24, label %land.lhs.true, label %if.end27

land.lhs.true:                                    ; preds = %if.end23
  %56 = load i32, i32* %value_regno.addr, align 4
  %cmp25 = icmp sge i32 %56, 0
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %land.lhs.true
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %59 = load i32, i32* %value_regno.addr, align 4
  %60 = load i32, i32* %ret, align 4
  %61 = load i32, i32* %btf_id2, align 4
  call void @mark_btf_ld_reg(%struct.bpf_verifier_env* noundef %57, %struct.bpf_reg_state* noundef %58, i32 noundef %59, i32 noundef %60, i32 noundef %61) #11
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %land.lhs.true, %if.end23
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then22, %if.then16, %if.then5, %if.then
  %62 = load i32, i32* %retval, align 4
  ret i32 %62
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_ptr_to_map_access(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno, i32 noundef %off, i32 noundef %size, i32 noundef %atype, i32 noundef %value_regno) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %off.addr = alloca i32, align 4
  %size.addr = alloca i32, align 4
  %atype.addr = alloca i32, align 4
  %value_regno.addr = alloca i32, align 4
  %reg = alloca %struct.bpf_reg_state*, align 8
  %map = alloca %struct.bpf_map*, align 8
  %t = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %btf_id = alloca i32, align 4
  %ret = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %off, i32* %off.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i32 %atype, i32* %atype.addr, align 4
  store i32 %value_regno, i32* %value_regno.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %1 = load i32, i32* %regno.addr, align 4
  %idx.ext = sext i32 %1 to i64
  %add.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i64 %idx.ext
  store %struct.bpf_reg_state* %add.ptr, %struct.bpf_reg_state** %reg, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg, align 8
  %3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 1
  %map_ptr = bitcast %struct.bpf_iter_aux_info* %3 to %struct.bpf_map**
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  store %struct.bpf_map* %4, %struct.bpf_map** %map, align 8
  %5 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool = icmp ne %struct.btf* %5, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.247, i64 0, i64 0)) #11
  store i32 -524, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %8, i32 0, i32 0
  %9 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %map_btf_id = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %9, i32 0, i32 35
  %10 = load i32*, i32** %map_btf_id, align 8
  %tobool1 = icmp ne i32* %10, null
  br i1 %tobool1, label %lor.lhs.false, label %if.then5

lor.lhs.false:                                    ; preds = %if.end
  %11 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops2 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %11, i32 0, i32 0
  %12 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops2, align 64
  %map_btf_id3 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %12, i32 0, i32 35
  %13 = load i32*, i32** %map_btf_id3, align 8
  %14 = load i32, i32* %13, align 4
  %tobool4 = icmp ne i32 %14, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = bitcast %struct.bpf_verifier_env* %15 to i8*
  %17 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %17, i32 0, i32 3
  %18 = load i32, i32* %map_type, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %16, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.248, i64 0, i64 0), i32 noundef %18) #11
  store i32 -524, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  %19 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %20 = load %struct.bpf_map*, %struct.bpf_map** %map, align 8
  %ops7 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %20, i32 0, i32 0
  %21 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops7, align 64
  %map_btf_id8 = getelementptr inbounds %struct.bpf_map_ops, %struct.bpf_map_ops* %21, i32 0, i32 35
  %22 = load i32*, i32** %map_btf_id8, align 8
  %23 = load i32, i32* %22, align 4
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %19, i32 noundef %23) #11
  store %struct.btf_type* %call, %struct.btf_type** %t, align 8
  %24 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %25 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %25, i32 0, i32 0
  %26 = load i32, i32* %name_off, align 4
  %call9 = call i8* @btf_name_by_offset(%struct.btf* noundef %24, i32 noundef %26) #11
  store i8* %call9, i8** %tname, align 8
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_to_map_access = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %27, i32 0, i32 15
  %28 = load i8, i8* %allow_ptr_to_map_access, align 1
  %tobool10 = trunc i8 %28 to i1
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end6
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load i8*, i8** %tname, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.249, i64 0, i64 0), i8* noundef %31) #11
  store i32 -1, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end6
  %32 = load i32, i32* %off.addr, align 4
  %cmp = icmp slt i32 %32, 0
  br i1 %cmp, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end12
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %34 = bitcast %struct.bpf_verifier_env* %33 to i8*
  %35 = load i32, i32* %regno.addr, align 4
  %36 = load i8*, i8** %tname, align 8
  %37 = load i32, i32* %off.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %34, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.250, i64 0, i64 0), i32 noundef %35, i8* noundef %36, i32 noundef %37) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end12
  %38 = load i32, i32* %atype.addr, align 4
  %cmp15 = icmp ne i32 %38, 1
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end14
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = bitcast %struct.bpf_verifier_env* %39 to i8*
  %41 = load i8*, i8** %tname, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %40, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.251, i64 0, i64 0), i8* noundef %41) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end14
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %42, i32 0, i32 22
  %43 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %44 = load i32, i32* %off.addr, align 4
  %45 = load i32, i32* %size.addr, align 4
  %46 = load i32, i32* %atype.addr, align 4
  %call18 = call i32 @btf_struct_access(%struct.bpf_verifier_log* noundef %log, %struct.btf_type* noundef %43, i32 noundef %44, i32 noundef %45, i32 noundef %46, i32* noundef %btf_id) #11
  store i32 %call18, i32* %ret, align 4
  %47 = load i32, i32* %ret, align 4
  %cmp19 = icmp slt i32 %47, 0
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  %48 = load i32, i32* %ret, align 4
  store i32 %48, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end17
  %49 = load i32, i32* %value_regno.addr, align 4
  %cmp22 = icmp sge i32 %49, 0
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end21
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %52 = load i32, i32* %value_regno.addr, align 4
  %53 = load i32, i32* %ret, align 4
  %54 = load i32, i32* %btf_id, align 4
  call void @mark_btf_ld_reg(%struct.bpf_verifier_env* noundef %50, %struct.bpf_reg_state* noundef %51, i32 noundef %52, i32 noundef %53, i32 noundef %54) #11
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.end21
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end24, %if.then20, %if.then16, %if.then13, %if.then11, %if.then5, %if.then
  %55 = load i32, i32* %retval, align 4
  ret i32 %55
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @coerce_reg_to_size(%struct.bpf_reg_state* noundef %reg, i32 noundef %size) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %size.addr = alloca i32, align 4
  %mask = alloca i64, align 8
  %tmp = alloca %struct.tnum, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 5
  %2 = load i32, i32* %size.addr, align 4
  %conv = trunc i32 %2 to i8
  %3 = bitcast %struct.tnum* %var_off1 to { i64, i64 }*
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = load i64, i64* %4, align 8
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = load i64, i64* %6, align 8
  %call = call { i64, i64 } @tnum_cast(i64 %5, i64 %7, i8 noundef zeroext %conv) #11
  %8 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call, 1
  store i64 %12, i64* %11, align 8
  %13 = bitcast %struct.tnum* %var_off to i8*
  %14 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %13, i8* align 8 %14, i64 16, i1 false)
  %15 = load i32, i32* %size.addr, align 4
  %mul = mul i32 %15, 8
  %sh_prom = zext i32 %mul to i64
  %shl = shl i64 1, %sh_prom
  %sub = sub i64 %shl, 1
  store i64 %sub, i64* %mask, align 8
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 8
  %17 = load i64, i64* %umin_value, align 8
  %18 = load i64, i64* %mask, align 8
  %neg = xor i64 %18, -1
  %and = and i64 %17, %neg
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 9
  %20 = load i64, i64* %umax_value, align 8
  %21 = load i64, i64* %mask, align 8
  %neg2 = xor i64 %21, -1
  %and3 = and i64 %20, %neg2
  %cmp = icmp eq i64 %and, %and3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %22 = load i64, i64* %mask, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 8
  %24 = load i64, i64* %umin_value5, align 8
  %and6 = and i64 %24, %22
  store i64 %and6, i64* %umin_value5, align 8
  %25 = load i64, i64* %mask, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 9
  %27 = load i64, i64* %umax_value7, align 8
  %and8 = and i64 %27, %25
  store i64 %and8, i64* %umax_value7, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value9 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i32 0, i32 8
  store i64 0, i64* %umin_value9, align 8
  %29 = load i64, i64* %mask, align 8
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 9
  store i64 %29, i64* %umax_value10, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value11 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 8
  %32 = load i64, i64* %umin_value11, align 8
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 6
  store i64 %32, i64* %smin_value, align 8
  %34 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %34, i32 0, i32 9
  %35 = load i64, i64* %umax_value12, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i32 0, i32 7
  store i64 %35, i64* %smax_value, align 8
  %37 = load i32, i32* %size.addr, align 4
  %cmp13 = icmp sge i32 %37, 4
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end
  br label %return

if.end16:                                         ; preds = %if.end
  %38 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__reg_combine_64_into_32(%struct.bpf_reg_state* noundef %38) #11
  br label %return

return:                                           ; preds = %if.end16, %if.then15
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_struct_access(%struct.bpf_verifier_log* noundef, %struct.btf_type* noundef, i32 noundef, i32 noundef, i32 noundef, i32* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_btf_ld_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %regs, i32 noundef %regno, i32 noundef %reg_type, i32 noundef %btf_id) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %regs.addr = alloca %struct.bpf_reg_state*, align 8
  %regno.addr = alloca i32, align 4
  %reg_type.addr = alloca i32, align 4
  %btf_id.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %regs, %struct.bpf_reg_state** %regs.addr, align 8
  store i32 %regno, i32* %regno.addr, align 4
  store i32 %reg_type, i32* %reg_type.addr, align 4
  store i32 %btf_id, i32* %btf_id.addr, align 4
  %0 = load i32, i32* %reg_type.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %3 = load i32, i32* %regno.addr, align 4
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %1, %struct.bpf_reg_state* noundef %2, i32 noundef %3) #11
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %6 = load i32, i32* %regno.addr, align 4
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %4, %struct.bpf_reg_state* noundef %5, i32 noundef %6) #11
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %8 = load i32, i32* %regno.addr, align 4
  %idxprom = zext i32 %8 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i64 %idxprom
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 0
  store i32 19, i32* %type, align 8
  %9 = load i32, i32* %btf_id.addr, align 4
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs.addr, align 8
  %11 = load i32, i32* %regno.addr, align 4
  %idxprom1 = zext i32 %11 to i64
  %arrayidx2 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i64 %idxprom1
  %12 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx2, i32 0, i32 1
  %btf_id3 = bitcast %struct.bpf_iter_aux_info* %12 to i32*
  store i32 %9, i32* %btf_id3, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_sock_common_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.bpf_insn_access_aux* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_sock_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.bpf_insn_access_aux* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_tcp_sock_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.bpf_insn_access_aux* noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_xdp_sock_is_valid_access(i32 noundef, i32 noundef, i32 noundef, %struct.bpf_insn_access_aux* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @__mark_reg_const_zero(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %0, i64 noundef 0) #11
  %1 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %1, i32 0, i32 0
  store i32 1, i32* %type, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @register_is_bounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 0
  %1 = load i32, i32* %type, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %call = call zeroext i1 @__is_scalar_unbounded(%struct.bpf_reg_state* noundef %2) #11
  %lnot = xor i1 %call, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  ret i1 %3
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @save_register_state(%struct.bpf_func_state* noundef %state, i32 noundef %spi, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %spi.addr = alloca i32, align 4
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  store i32 %spi, i32* %spi.addr, align 4
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 7
  %1 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %2 = load i32, i32* %spi.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %1, i64 %idxprom
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 0
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %4 = bitcast %struct.bpf_reg_state* %spilled_ptr to i8*
  %5 = bitcast %struct.bpf_reg_state* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %4, i8* align 8 %5, i64 120, i1 false)
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 7
  %7 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack1, align 8
  %8 = load i32, i32* %spi.addr, align 4
  %idxprom2 = sext i32 %8 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %7, i64 %idxprom2
  %spilled_ptr4 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr4, i32 0, i32 17
  %9 = load i32, i32* %live, align 8
  %or = or i32 %9, 4
  store i32 %or, i32* %live, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %10, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %stack5 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %11, i32 0, i32 7
  %12 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack5, align 8
  %13 = load i32, i32* %spi.addr, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %12, i64 %idxprom6
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx7, i32 0, i32 1
  %14 = load i32, i32* %i, align 4
  %idxprom8 = sext i32 %14 to i64
  %arrayidx9 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom8
  store i8 1, i8* %arrayidx9, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i32, i32* %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_spillable_regtype(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 4, label %sw.bb
    i32 5, label %sw.bb
    i32 6, label %sw.bb
    i32 2, label %sw.bb
    i32 8, label %sw.bb
    i32 7, label %sw.bb
    i32 9, label %sw.bb
    i32 10, label %sw.bb
    i32 3, label %sw.bb
    i32 11, label %sw.bb
    i32 12, label %sw.bb
    i32 13, label %sw.bb
    i32 14, label %sw.bb
    i32 15, label %sw.bb
    i32 16, label %sw.bb
    i32 18, label %sw.bb
    i32 19, label %sw.bb
    i32 20, label %sw.bb
    i32 23, label %sw.bb
    i32 24, label %sw.bb
    i32 25, label %sw.bb
    i32 26, label %sw.bb
    i32 27, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @__is_scalar_unbounded(%struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_unknown(i64 %3, i64 %5) #11
  br i1 %call, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 6
  %7 = load i64, i64* %smin_value, align 8
  %cmp = icmp eq i64 %7, -9223372036854775808
  br i1 %cmp, label %land.lhs.true1, label %land.end

land.lhs.true1:                                   ; preds = %land.lhs.true
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 7
  %9 = load i64, i64* %smax_value, align 8
  %cmp2 = icmp eq i64 %9, 9223372036854775807
  br i1 %cmp2, label %land.lhs.true3, label %land.end

land.lhs.true3:                                   ; preds = %land.lhs.true1
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 8
  %11 = load i64, i64* %umin_value, align 8
  %cmp4 = icmp eq i64 %11, 0
  br i1 %cmp4, label %land.lhs.true5, label %land.end

land.lhs.true5:                                   ; preds = %land.lhs.true3
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 9
  %13 = load i64, i64* %umax_value, align 8
  %cmp6 = icmp eq i64 %13, -1
  br i1 %cmp6, label %land.lhs.true7, label %land.end

land.lhs.true7:                                   ; preds = %land.lhs.true5
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 10
  %15 = load i32, i32* %s32_min_value, align 8
  %cmp8 = icmp eq i32 %15, -2147483648
  br i1 %cmp8, label %land.lhs.true9, label %land.end

land.lhs.true9:                                   ; preds = %land.lhs.true7
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %s32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %16, i32 0, i32 11
  %17 = load i32, i32* %s32_max_value, align 4
  %cmp10 = icmp eq i32 %17, 2147483647
  br i1 %cmp10, label %land.lhs.true11, label %land.end

land.lhs.true11:                                  ; preds = %land.lhs.true9
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_min_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 12
  %19 = load i32, i32* %u32_min_value, align 8
  %cmp12 = icmp eq i32 %19, 0
  br i1 %cmp12, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true11
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %u32_max_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 13
  %21 = load i32, i32* %u32_max_value, align 4
  %cmp13 = icmp eq i32 %21, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true11, %land.lhs.true9, %land.lhs.true7, %land.lhs.true5, %land.lhs.true3, %land.lhs.true1, %land.lhs.true, %entry
  %22 = phi i1 [ false, %land.lhs.true11 ], [ false, %land.lhs.true9 ], [ false, %land.lhs.true7 ], [ false, %land.lhs.true5 ], [ false, %land.lhs.true3 ], [ false, %land.lhs.true1 ], [ false, %land.lhs.true ], [ false, %entry ], [ %cmp13, %land.rhs ]
  ret i1 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @mark_insn_zext(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %def_idx = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 16
  %1 = load i32, i32* %subreg_def, align 4
  store i32 %1, i32* %def_idx, align 4
  %2 = load i32, i32* %def_idx, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 20
  %4 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %5 = load i32, i32* %def_idx, align 4
  %sub = sub i32 %5, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %4, i64 %idxprom
  %zext_dst = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 5
  store i8 1, i8* %zext_dst, align 4
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %subreg_def1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 16
  store i32 0, i32* %subreg_def1, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_reg_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %src_reg = alloca %struct.bpf_reg_state*, align 8
  %ptr_reg = alloca %struct.bpf_reg_state*, align 8
  %off_reg = alloca %struct.bpf_reg_state, align 8
  %opcode = alloca i8, align 1
  %err = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %__ret_warn_on99 = alloca i32, align 4
  %tmp124 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %ptr_reg, align 8
  %7 = bitcast %struct.bpf_reg_state* %off_reg to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %7, i8 0, i64 120, i1 false)
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %8, i32 0, i32 0
  %9 = load i8, i8* %code, align 4
  %conv = zext i8 %9 to i32
  %and = and i32 %conv, 240
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %opcode, align 1
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %11 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg3 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %11, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg3, align 1
  %bf.clear = and i8 %bf.load, 15
  %idxprom4 = zext i8 %bf.clear to i64
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i64 %idxprom4
  store %struct.bpf_reg_state* %arrayidx5, %struct.bpf_reg_state** %dst_reg, align 8
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %src_reg, align 8
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 0
  %13 = load i32, i32* %type, align 8
  %cmp = icmp ne i32 %13, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  store %struct.bpf_reg_state* %14, %struct.bpf_reg_state** %ptr_reg, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 3
  store i32 0, i32* %id, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %16 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code7 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %16, i32 0, i32 0
  %17 = load i8, i8* %code7, align 4
  %conv8 = zext i8 %17 to i32
  %and9 = and i32 %conv8, 8
  %cmp10 = icmp eq i32 %and9, 8
  br i1 %cmp10, label %if.then12, label %if.else65

if.then12:                                        ; preds = %if.end
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %19 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg13 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %19, i32 0, i32 1
  %bf.load14 = load i8, i8* %src_reg13, align 1
  %bf.lshr = lshr i8 %bf.load14, 4
  %idxprom15 = zext i8 %bf.lshr to i64
  %arrayidx16 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i64 %idxprom15
  store %struct.bpf_reg_state* %arrayidx16, %struct.bpf_reg_state** %src_reg, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %type17 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 0
  %21 = load i32, i32* %type17, align 8
  %cmp18 = icmp ne i32 %21, 1
  br i1 %cmp18, label %if.then20, label %if.else51

if.then20:                                        ; preds = %if.then12
  %22 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %22, i32 0, i32 0
  %23 = load i32, i32* %type21, align 8
  %cmp22 = icmp ne i32 %23, 1
  br i1 %cmp22, label %if.then24, label %if.else42

if.then24:                                        ; preds = %if.then20
  %24 = load i8, i8* %opcode, align 1
  %conv25 = zext i8 %24 to i32
  %cmp26 = icmp eq i32 %conv25, 16
  br i1 %cmp26, label %land.lhs.true, label %if.end34

land.lhs.true:                                    ; preds = %if.then24
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %25, i32 0, i32 14
  %26 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool = trunc i8 %26 to i1
  br i1 %tobool, label %if.then29, label %if.end34

if.then29:                                        ; preds = %land.lhs.true
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg30 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load31 = load i8, i8* %dst_reg30, align 1
  %bf.clear32 = and i8 %bf.load31, 15
  %conv33 = zext i8 %bf.clear32 to i32
  call void @mark_reg_unknown(%struct.bpf_verifier_env* noundef %27, %struct.bpf_reg_state* noundef %28, i32 noundef %conv33) #11
  store i32 0, i32* %retval, align 4
  br label %return

if.end34:                                         ; preds = %land.lhs.true, %if.then24
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg35 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %32, i32 0, i32 1
  %bf.load36 = load i8, i8* %dst_reg35, align 1
  %bf.clear37 = and i8 %bf.load36, 15
  %conv38 = zext i8 %bf.clear37 to i32
  %33 = load i8, i8* %opcode, align 1
  %conv39 = zext i8 %33 to i32
  %shr = ashr i32 %conv39, 4
  %idxprom40 = sext i32 %shr to i64
  %arrayidx41 = getelementptr [16 x i8*], [16 x i8*]* @bpf_alu_string, i64 0, i64 %idxprom40
  %34 = load i8*, i8** %arrayidx41, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.173, i64 0, i64 0), i32 noundef %conv38, i8* noundef %34) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.else42:                                        ; preds = %if.then20
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg43 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %36, i32 0, i32 1
  %bf.load44 = load i8, i8* %dst_reg43, align 1
  %bf.clear45 = and i8 %bf.load44, 15
  %conv46 = zext i8 %bf.clear45 to i32
  %call = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %35, i32 noundef %conv46) #11
  store i32 %call, i32* %err, align 4
  %37 = load i32, i32* %err, align 4
  %tobool47 = icmp ne i32 %37, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.else42
  %38 = load i32, i32* %err, align 4
  store i32 %38, i32* %retval, align 4
  br label %return

if.end49:                                         ; preds = %if.else42
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %41 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %call50 = call i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %39, %struct.bpf_insn* noundef %40, %struct.bpf_reg_state* noundef %41, %struct.bpf_reg_state* noundef %42) #11
  store i32 %call50, i32* %retval, align 4
  br label %return

if.else51:                                        ; preds = %if.then12
  %43 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %tobool52 = icmp ne %struct.bpf_reg_state* %43, null
  br i1 %tobool52, label %if.then53, label %if.end63

if.then53:                                        ; preds = %if.else51
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg54 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %45, i32 0, i32 1
  %bf.load55 = load i8, i8* %src_reg54, align 1
  %bf.lshr56 = lshr i8 %bf.load55, 4
  %conv57 = zext i8 %bf.lshr56 to i32
  %call58 = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %44, i32 noundef %conv57) #11
  store i32 %call58, i32* %err, align 4
  %46 = load i32, i32* %err, align 4
  %tobool59 = icmp ne i32 %46, 0
  br i1 %tobool59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.then53
  %47 = load i32, i32* %err, align 4
  store i32 %47, i32* %retval, align 4
  br label %return

if.end61:                                         ; preds = %if.then53
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %49 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %50 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %51 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call62 = call i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %48, %struct.bpf_insn* noundef %49, %struct.bpf_reg_state* noundef %50, %struct.bpf_reg_state* noundef %51) #11
  store i32 %call62, i32* %retval, align 4
  br label %return

if.end63:                                         ; preds = %if.else51
  br label %if.end64

if.end64:                                         ; preds = %if.end63
  br label %if.end72

if.else65:                                        ; preds = %if.end
  %type66 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %off_reg, i32 0, i32 0
  store i32 1, i32* %type66, align 8
  %52 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %52, i32 0, i32 3
  %53 = load i32, i32* %imm, align 4
  %conv67 = sext i32 %53 to i64
  call void @__mark_reg_known(%struct.bpf_reg_state* noundef %off_reg, i64 noundef %conv67) #11
  store %struct.bpf_reg_state* %off_reg, %struct.bpf_reg_state** %src_reg, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %tobool68 = icmp ne %struct.bpf_reg_state* %54, null
  br i1 %tobool68, label %if.then69, label %if.end71

if.then69:                                        ; preds = %if.else65
  %55 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %56 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %57 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %58 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call70 = call i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %55, %struct.bpf_insn* noundef %56, %struct.bpf_reg_state* noundef %57, %struct.bpf_reg_state* noundef %58) #11
  store i32 %call70, i32* %retval, align 4
  br label %return

if.end71:                                         ; preds = %if.else65
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %if.end64
  %59 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg, align 8
  %tobool73 = icmp ne %struct.bpf_reg_state* %59, null
  %lnot = xor i1 %tobool73, true
  %lnot74 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot74 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %60 = load i32, i32* %__ret_warn_on, align 4
  %tobool75 = icmp ne i32 %60, 0
  %lnot76 = xor i1 %tobool75, true
  %lnot78 = xor i1 %lnot76, true
  %lnot.ext79 = zext i1 %lnot78 to i32
  %conv80 = sext i32 %lnot.ext79 to i64
  %tobool81 = icmp ne i64 %conv80, 0
  br i1 %tobool81, label %if.then82, label %if.end89

if.then82:                                        ; preds = %if.end72
  br label %do.body

do.body:                                          ; preds = %if.then82
  br label %do.body83

do.body83:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body83
  br label %do.body84

do.body84:                                        ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 6818, i32 2307, i64 12) #10, !srcloc !63
  br label %do.end85

do.end85:                                         ; preds = %do.body84
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 434) #10, !srcloc !64
  br label %do.body86

do.body86:                                        ; preds = %do.end85
  br label %do.end87

do.end87:                                         ; preds = %do.body86
  br label %do.end88

do.end88:                                         ; preds = %do.end87
  br label %if.end89

if.end89:                                         ; preds = %do.end88, %if.end72
  %61 = load i32, i32* %__ret_warn_on, align 4
  %tobool90 = icmp ne i32 %61, 0
  %lnot91 = xor i1 %tobool90, true
  %lnot93 = xor i1 %lnot91, true
  %lnot.ext94 = zext i1 %lnot93 to i32
  %conv95 = sext i32 %lnot.ext94 to i64
  store i64 %conv95, i64* %tmp, align 8
  %62 = load i64, i64* %tmp, align 8
  %tobool96 = icmp ne i64 %62, 0
  br i1 %tobool96, label %if.then97, label %if.end98

if.then97:                                        ; preds = %if.end89
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %63, %struct.bpf_func_state* noundef %64) #11
  %65 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %66 = bitcast %struct.bpf_verifier_env* %65 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %66, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.174, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end98:                                         ; preds = %if.end89
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %tobool100 = icmp ne %struct.bpf_reg_state* %67, null
  %lnot101 = xor i1 %tobool100, true
  %lnot103 = xor i1 %lnot101, true
  %lnot105 = xor i1 %lnot103, true
  %lnot.ext106 = zext i1 %lnot105 to i32
  store i32 %lnot.ext106, i32* %__ret_warn_on99, align 4
  %68 = load i32, i32* %__ret_warn_on99, align 4
  %tobool107 = icmp ne i32 %68, 0
  %lnot108 = xor i1 %tobool107, true
  %lnot110 = xor i1 %lnot108, true
  %lnot.ext111 = zext i1 %lnot110 to i32
  %conv112 = sext i32 %lnot.ext111 to i64
  %tobool113 = icmp ne i64 %conv112, 0
  br i1 %tobool113, label %if.then114, label %if.end123

if.then114:                                       ; preds = %if.end98
  br label %do.body115

do.body115:                                       ; preds = %if.then114
  br label %do.body116

do.body116:                                       ; preds = %do.body115
  br label %do.end117

do.end117:                                        ; preds = %do.body116
  br label %do.body118

do.body118:                                       ; preds = %do.end117
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 6823, i32 2305, i64 12) #10, !srcloc !65
  br label %do.end119

do.end119:                                        ; preds = %do.body118
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 435) #10, !srcloc !66
  br label %do.body120

do.body120:                                       ; preds = %do.end119
  br label %do.end121

do.end121:                                        ; preds = %do.body120
  br label %do.end122

do.end122:                                        ; preds = %do.end121
  br label %if.end123

if.end123:                                        ; preds = %do.end122, %if.end98
  %69 = load i32, i32* %__ret_warn_on99, align 4
  %tobool125 = icmp ne i32 %69, 0
  %lnot126 = xor i1 %tobool125, true
  %lnot128 = xor i1 %lnot126, true
  %lnot.ext129 = zext i1 %lnot128 to i32
  %conv130 = sext i32 %lnot.ext129 to i64
  store i64 %conv130, i64* %tmp124, align 8
  %70 = load i64, i64* %tmp124, align 8
  %tobool131 = icmp ne i64 %70, 0
  br i1 %tobool131, label %if.then132, label %if.end133

if.then132:                                       ; preds = %if.end123
  %71 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %72 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  call void @print_verifier_state(%struct.bpf_verifier_env* noundef %71, %struct.bpf_func_state* noundef %72) #11
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %74 = bitcast %struct.bpf_verifier_env* %73 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %74, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.175, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end133:                                        ; preds = %if.end123
  %75 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %76 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %77 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %78 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %src_reg, align 8
  %call134 = call i32 @adjust_scalar_min_max_vals(%struct.bpf_verifier_env* noundef %75, %struct.bpf_insn* noundef %76, %struct.bpf_reg_state* noundef %77, %struct.bpf_reg_state* noundef byval(%struct.bpf_reg_state) align 8 %78) #11
  store i32 %call134, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end133, %if.then132, %if.then97, %if.then69, %if.end61, %if.then60, %if.end49, %if.then48, %if.end34, %if.then29
  %79 = load i32, i32* %retval, align 4
  ret i32 %79
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @adjust_ptr_min_max_vals(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %ptr_reg, %struct.bpf_reg_state* noundef %off_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %ptr_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %dst_reg = alloca %struct.bpf_reg_state*, align 8
  %known = alloca i8, align 1
  %smin_val = alloca i64, align 8
  %smax_val = alloca i64, align 8
  %smin_ptr = alloca i64, align 8
  %smax_ptr = alloca i64, align 8
  %umin_val = alloca i64, align 8
  %umax_val = alloca i64, align 8
  %umin_ptr = alloca i64, align 8
  %umax_ptr = alloca i64, align 8
  %dst = alloca i32, align 4
  %src = alloca i32, align 4
  %opcode = alloca i8, align 1
  %ret = alloca i32, align 4
  %tmp = alloca %struct.tnum, align 8
  %tmp235 = alloca %struct.tnum, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %ptr_reg, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  store %struct.bpf_reg_state* %off_reg, %struct.bpf_reg_state** %off_reg.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i32 0, i32 5
  %8 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %9 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %10, i64 %12) #11
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %known, align 1
  %13 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %13, i32 0, i32 6
  %14 = load i64, i64* %smin_value, align 8
  store i64 %14, i64* %smin_val, align 8
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 7
  %16 = load i64, i64* %smax_value, align 8
  store i64 %16, i64* %smax_val, align 8
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %smin_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 6
  %18 = load i64, i64* %smin_value2, align 8
  store i64 %18, i64* %smin_ptr, align 8
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %smax_value3 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 7
  %20 = load i64, i64* %smax_value3, align 8
  store i64 %20, i64* %smax_ptr, align 8
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 8
  %22 = load i64, i64* %umin_value, align 8
  store i64 %22, i64* %umin_val, align 8
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 9
  %24 = load i64, i64* %umax_value, align 8
  store i64 %24, i64* %umax_val, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %umin_value4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 8
  %26 = load i64, i64* %umin_value4, align 8
  store i64 %26, i64* %umin_ptr, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %umax_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 9
  %28 = load i64, i64* %umax_value5, align 8
  store i64 %28, i64* %umax_ptr, align 8
  %29 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %dst_reg6 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %29, i32 0, i32 1
  %bf.load = load i8, i8* %dst_reg6, align 1
  %bf.clear = and i8 %bf.load, 15
  %conv = zext i8 %bf.clear to i32
  store i32 %conv, i32* %dst, align 4
  %30 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %src_reg = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %30, i32 0, i32 1
  %bf.load7 = load i8, i8* %src_reg, align 1
  %bf.lshr = lshr i8 %bf.load7, 4
  %conv8 = zext i8 %bf.lshr to i32
  store i32 %conv8, i32* %src, align 4
  %31 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %31, i32 0, i32 0
  %32 = load i8, i8* %code, align 4
  %conv9 = zext i8 %32 to i32
  %and = and i32 %conv9, 240
  %conv10 = trunc i32 %and to i8
  store i8 %conv10, i8* %opcode, align 1
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %34 = load i32, i32* %dst, align 4
  %idxprom11 = zext i32 %34 to i64
  %arrayidx12 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i64 %idxprom11
  store %struct.bpf_reg_state* %arrayidx12, %struct.bpf_reg_state** %dst_reg, align 8
  %35 = load i8, i8* %known, align 1
  %tobool = trunc i8 %35 to i1
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false17

land.lhs.true:                                    ; preds = %entry
  %36 = load i64, i64* %smin_val, align 8
  %37 = load i64, i64* %smax_val, align 8
  %cmp = icmp ne i64 %36, %37
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %38 = load i64, i64* %umin_val, align 8
  %39 = load i64, i64* %umax_val, align 8
  %cmp15 = icmp ne i64 %38, %39
  br i1 %cmp15, label %if.then, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %lor.lhs.false, %entry
  %40 = load i64, i64* %smin_val, align 8
  %41 = load i64, i64* %smax_val, align 8
  %cmp18 = icmp sgt i64 %40, %41
  br i1 %cmp18, label %if.then, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %lor.lhs.false17
  %42 = load i64, i64* %umin_val, align 8
  %43 = load i64, i64* %umax_val, align 8
  %cmp21 = icmp ugt i64 %42, %43
  br i1 %cmp21, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false20, %lor.lhs.false17, %lor.lhs.false, %land.lhs.true
  %44 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %45 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %44, %struct.bpf_reg_state* noundef %45) #11
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false20
  %46 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code23 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %46, i32 0, i32 0
  %47 = load i8, i8* %code23, align 4
  %conv24 = zext i8 %47 to i32
  %and25 = and i32 %conv24, 7
  %cmp26 = icmp ne i32 %and25, 7
  br i1 %cmp26, label %if.then28, label %if.end37

if.then28:                                        ; preds = %if.end
  %48 = load i8, i8* %opcode, align 1
  %conv29 = zext i8 %48 to i32
  %cmp30 = icmp eq i32 %conv29, 16
  br i1 %cmp30, label %land.lhs.true32, label %if.end36

land.lhs.true32:                                  ; preds = %if.then28
  %49 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %49, i32 0, i32 14
  %50 = load i8, i8* %allow_ptr_leaks, align 8
  %tobool33 = trunc i8 %50 to i1
  br i1 %tobool33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %land.lhs.true32
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__mark_reg_unknown(%struct.bpf_verifier_env* noundef %51, %struct.bpf_reg_state* noundef %52) #11
  store i32 0, i32* %retval, align 4
  br label %return

if.end36:                                         ; preds = %land.lhs.true32, %if.then28
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = bitcast %struct.bpf_verifier_env* %53 to i8*
  %55 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %54, i8* noundef getelementptr inbounds ([42 x i8], [42 x i8]* @.str.176, i64 0, i64 0), i32 noundef %55) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end
  %56 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %56, i32 0, i32 0
  %57 = load i32, i32* %type, align 8
  switch i32 %57, label %sw.default [
    i32 5, label %sw.bb
    i32 3, label %sw.bb41
    i32 9, label %sw.bb53
    i32 11, label %sw.bb53
    i32 12, label %sw.bb53
    i32 13, label %sw.bb53
    i32 14, label %sw.bb53
    i32 15, label %sw.bb53
    i32 16, label %sw.bb53
    i32 18, label %sw.bb53
    i32 4, label %sw.bb57
  ]

sw.bb:                                            ; preds = %if.end37
  %58 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %59 = bitcast %struct.bpf_verifier_env* %58 to i8*
  %60 = load i32, i32* %dst, align 4
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type38 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 0
  %62 = load i32, i32* %type38, align 8
  %idxprom39 = zext i32 %62 to i64
  %arrayidx40 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom39
  %63 = load i8*, i8** %arrayidx40, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %59, i8* noundef getelementptr inbounds ([62 x i8], [62 x i8]* @.str.177, i64 0, i64 0), i32 noundef %60, i8* noundef %63) #11
  store i32 -13, i32* %retval, align 4
  br label %return

sw.bb41:                                          ; preds = %if.end37
  %64 = load i8, i8* %known, align 1
  %tobool42 = trunc i8 %64 to i1
  br i1 %tobool42, label %land.lhs.true44, label %if.end52

land.lhs.true44:                                  ; preds = %sw.bb41
  %65 = load i64, i64* %smin_val, align 8
  %cmp45 = icmp eq i64 %65, 0
  br i1 %cmp45, label %land.lhs.true47, label %if.end52

land.lhs.true47:                                  ; preds = %land.lhs.true44
  %66 = load i8, i8* %opcode, align 1
  %conv48 = zext i8 %66 to i32
  %cmp49 = icmp eq i32 %conv48, 0
  br i1 %cmp49, label %if.then51, label %if.end52

if.then51:                                        ; preds = %land.lhs.true47
  br label %sw.epilog

if.end52:                                         ; preds = %land.lhs.true47, %land.lhs.true44, %sw.bb41
  br label %sw.bb53

sw.bb53:                                          ; preds = %if.end52, %if.end37, %if.end37, %if.end37, %if.end37, %if.end37, %if.end37, %if.end37, %if.end37
  %67 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %68 = bitcast %struct.bpf_verifier_env* %67 to i8*
  %69 = load i32, i32* %dst, align 4
  %70 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type54 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %70, i32 0, i32 0
  %71 = load i32, i32* %type54, align 8
  %idxprom55 = zext i32 %71 to i64
  %arrayidx56 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom55
  %72 = load i8*, i8** %arrayidx56, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %68, i8* noundef getelementptr inbounds ([41 x i8], [41 x i8]* @.str.178, i64 0, i64 0), i32 noundef %69, i8* noundef %72) #11
  store i32 -13, i32* %retval, align 4
  br label %return

sw.bb57:                                          ; preds = %if.end37
  %73 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %allow_ptr_leaks58 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %73, i32 0, i32 14
  %74 = load i8, i8* %allow_ptr_leaks58, align 8
  %tobool59 = trunc i8 %74 to i1
  br i1 %tobool59, label %if.end72, label %land.lhs.true60

land.lhs.true60:                                  ; preds = %sw.bb57
  %75 = load i8, i8* %known, align 1
  %tobool61 = trunc i8 %75 to i1
  br i1 %tobool61, label %if.end72, label %land.lhs.true62

land.lhs.true62:                                  ; preds = %land.lhs.true60
  %76 = load i64, i64* %smin_val, align 8
  %cmp63 = icmp slt i64 %76, 0
  %conv64 = zext i1 %cmp63 to i32
  %77 = load i64, i64* %smax_val, align 8
  %cmp65 = icmp slt i64 %77, 0
  %conv66 = zext i1 %cmp65 to i32
  %cmp67 = icmp ne i32 %conv64, %conv66
  br i1 %cmp67, label %if.then69, label %if.end72

if.then69:                                        ; preds = %land.lhs.true62
  %78 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %79 = bitcast %struct.bpf_verifier_env* %78 to i8*
  %80 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %81 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %cmp70 = icmp eq %struct.bpf_reg_state* %80, %81
  br i1 %cmp70, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then69
  %82 = load i32, i32* %dst, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then69
  %83 = load i32, i32* %src, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %82, %cond.true ], [ %83, %cond.false ]
  call void (i8*, i8*, ...) @verbose(i8* noundef %79, i8* noundef getelementptr inbounds ([98 x i8], [98 x i8]* @.str.179, i64 0, i64 0), i32 noundef %cond) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end72:                                         ; preds = %land.lhs.true62, %land.lhs.true60, %sw.bb57
  br label %sw.default

sw.default:                                       ; preds = %if.end72, %if.end37
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.then51
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %84, i32 0, i32 0
  %85 = load i32, i32* %type73, align 8
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 0
  store i32 %85, i32* %type74, align 8
  %87 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %87, i32 0, i32 3
  %88 = load i32, i32* %id, align 4
  %89 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id75 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %89, i32 0, i32 3
  store i32 %88, i32* %id75, align 4
  %90 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %91 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %92 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type76 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %92, i32 0, i32 0
  %93 = load i32, i32* %type76, align 8
  %call77 = call zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %90, %struct.bpf_reg_state* noundef %91, i32 noundef %93) #11
  br i1 %call77, label %lor.lhs.false78, label %if.then81

lor.lhs.false78:                                  ; preds = %sw.epilog
  %94 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type79 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %96, i32 0, i32 0
  %97 = load i32, i32* %type79, align 8
  %call80 = call zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %94, %struct.bpf_reg_state* noundef %95, i32 noundef %97) #11
  br i1 %call80, label %if.end82, label %if.then81

if.then81:                                        ; preds = %lor.lhs.false78, %sw.epilog
  store i32 -22, i32* %retval, align 4
  br label %return

if.end82:                                         ; preds = %lor.lhs.false78
  %98 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__mark_reg32_unbounded(%struct.bpf_reg_state* noundef %98) #11
  %99 = load i8, i8* %opcode, align 1
  %conv83 = zext i8 %99 to i32
  switch i32 %conv83, label %sw.default258 [
    i32 0, label %sw.bb84
    i32 16, label %sw.bb159
    i32 80, label %sw.bb254
    i32 64, label %sw.bb254
    i32 160, label %sw.bb254
  ]

sw.bb84:                                          ; preds = %if.end82
  %100 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %101 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %102 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %103 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %104 = load i64, i64* %smin_val, align 8
  %cmp85 = icmp slt i64 %104, 0
  %call87 = call i32 @sanitize_ptr_alu(%struct.bpf_verifier_env* noundef %100, %struct.bpf_insn* noundef %101, %struct.bpf_reg_state* noundef %102, %struct.bpf_reg_state* noundef %103, i1 noundef zeroext %cmp85) #11
  store i32 %call87, i32* %ret, align 4
  %105 = load i32, i32* %ret, align 4
  %cmp88 = icmp slt i32 %105, 0
  br i1 %cmp88, label %if.then90, label %if.end91

if.then90:                                        ; preds = %sw.bb84
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %107 = bitcast %struct.bpf_verifier_env* %106 to i8*
  %108 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %107, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.180, i64 0, i64 0), i32 noundef %108) #11
  %109 = load i32, i32* %ret, align 4
  store i32 %109, i32* %retval, align 4
  br label %return

if.end91:                                         ; preds = %sw.bb84
  %110 = load i8, i8* %known, align 1
  %tobool92 = trunc i8 %110 to i1
  br i1 %tobool92, label %land.lhs.true94, label %if.end116

land.lhs.true94:                                  ; preds = %if.end91
  %111 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %111, i32 0, i32 2
  %112 = load i32, i32* %off, align 8
  %conv95 = sext i32 %112 to i64
  %113 = load i64, i64* %smin_val, align 8
  %add = add i64 %conv95, %113
  %114 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off96 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %114, i32 0, i32 2
  %115 = load i32, i32* %off96, align 8
  %conv97 = sext i32 %115 to i64
  %116 = load i64, i64* %smin_val, align 8
  %add98 = add i64 %conv97, %116
  %conv99 = trunc i64 %add98 to i32
  %conv100 = sext i32 %conv99 to i64
  %cmp101 = icmp eq i64 %add, %conv100
  br i1 %cmp101, label %if.then103, label %if.end116

if.then103:                                       ; preds = %land.lhs.true94
  %117 = load i64, i64* %smin_ptr, align 8
  %118 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value104 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %118, i32 0, i32 6
  store i64 %117, i64* %smin_value104, align 8
  %119 = load i64, i64* %smax_ptr, align 8
  %120 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value105 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %120, i32 0, i32 7
  store i64 %119, i64* %smax_value105, align 8
  %121 = load i64, i64* %umin_ptr, align 8
  %122 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value106 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %122, i32 0, i32 8
  store i64 %121, i64* %umin_value106, align 8
  %123 = load i64, i64* %umax_ptr, align 8
  %124 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value107 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %124, i32 0, i32 9
  store i64 %123, i64* %umax_value107, align 8
  %125 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off108 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %125, i32 0, i32 5
  %126 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off109 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %126, i32 0, i32 5
  %127 = bitcast %struct.tnum* %var_off108 to i8*
  %128 = bitcast %struct.tnum* %var_off109 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %127, i8* align 8 %128, i64 16, i1 false)
  %129 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off110 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %129, i32 0, i32 2
  %130 = load i32, i32* %off110, align 8
  %conv111 = sext i32 %130 to i64
  %131 = load i64, i64* %smin_val, align 8
  %add112 = add i64 %conv111, %131
  %conv113 = trunc i64 %add112 to i32
  %132 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off114 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %132, i32 0, i32 2
  store i32 %conv113, i32* %off114, align 8
  %133 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %134 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %133, i32 0, i32 1
  %raw = bitcast %struct.bpf_iter_aux_info* %134 to i64*
  %135 = load i64, i64* %raw, align 8
  %136 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %137 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %136, i32 0, i32 1
  %raw115 = bitcast %struct.bpf_iter_aux_info* %137 to i64*
  store i64 %135, i64* %raw115, align 8
  br label %sw.epilog263

if.end116:                                        ; preds = %land.lhs.true94, %if.end91
  %138 = load i64, i64* %smin_ptr, align 8
  %139 = load i64, i64* %smin_val, align 8
  %call117 = call zeroext i1 @signed_add_overflows(i64 noundef %138, i64 noundef %139) #11
  br i1 %call117, label %if.then122, label %lor.lhs.false119

lor.lhs.false119:                                 ; preds = %if.end116
  %140 = load i64, i64* %smax_ptr, align 8
  %141 = load i64, i64* %smax_val, align 8
  %call120 = call zeroext i1 @signed_add_overflows(i64 noundef %140, i64 noundef %141) #11
  br i1 %call120, label %if.then122, label %if.else

if.then122:                                       ; preds = %lor.lhs.false119, %if.end116
  %142 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value123 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %142, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value123, align 8
  %143 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value124 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %143, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value124, align 8
  br label %if.end129

if.else:                                          ; preds = %lor.lhs.false119
  %144 = load i64, i64* %smin_ptr, align 8
  %145 = load i64, i64* %smin_val, align 8
  %add125 = add i64 %144, %145
  %146 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value126 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %146, i32 0, i32 6
  store i64 %add125, i64* %smin_value126, align 8
  %147 = load i64, i64* %smax_ptr, align 8
  %148 = load i64, i64* %smax_val, align 8
  %add127 = add i64 %147, %148
  %149 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value128 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %149, i32 0, i32 7
  store i64 %add127, i64* %smax_value128, align 8
  br label %if.end129

if.end129:                                        ; preds = %if.else, %if.then122
  %150 = load i64, i64* %umin_ptr, align 8
  %151 = load i64, i64* %umin_val, align 8
  %add130 = add i64 %150, %151
  %152 = load i64, i64* %umin_ptr, align 8
  %cmp131 = icmp ult i64 %add130, %152
  br i1 %cmp131, label %if.then137, label %lor.lhs.false133

lor.lhs.false133:                                 ; preds = %if.end129
  %153 = load i64, i64* %umax_ptr, align 8
  %154 = load i64, i64* %umax_val, align 8
  %add134 = add i64 %153, %154
  %155 = load i64, i64* %umax_ptr, align 8
  %cmp135 = icmp ult i64 %add134, %155
  br i1 %cmp135, label %if.then137, label %if.else140

if.then137:                                       ; preds = %lor.lhs.false133, %if.end129
  %156 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value138 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %156, i32 0, i32 8
  store i64 0, i64* %umin_value138, align 8
  %157 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value139 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %157, i32 0, i32 9
  store i64 -1, i64* %umax_value139, align 8
  br label %if.end145

if.else140:                                       ; preds = %lor.lhs.false133
  %158 = load i64, i64* %umin_ptr, align 8
  %159 = load i64, i64* %umin_val, align 8
  %add141 = add i64 %158, %159
  %160 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value142 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %160, i32 0, i32 8
  store i64 %add141, i64* %umin_value142, align 8
  %161 = load i64, i64* %umax_ptr, align 8
  %162 = load i64, i64* %umax_val, align 8
  %add143 = add i64 %161, %162
  %163 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value144 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %163, i32 0, i32 9
  store i64 %add143, i64* %umax_value144, align 8
  br label %if.end145

if.end145:                                        ; preds = %if.else140, %if.then137
  %164 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off146 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %164, i32 0, i32 5
  %165 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off147 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %165, i32 0, i32 5
  %166 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off148 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %166, i32 0, i32 5
  %167 = bitcast %struct.tnum* %var_off147 to { i64, i64 }*
  %168 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %167, i32 0, i32 0
  %169 = load i64, i64* %168, align 8
  %170 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %167, i32 0, i32 1
  %171 = load i64, i64* %170, align 8
  %172 = bitcast %struct.tnum* %var_off148 to { i64, i64 }*
  %173 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %172, i32 0, i32 0
  %174 = load i64, i64* %173, align 8
  %175 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %172, i32 0, i32 1
  %176 = load i64, i64* %175, align 8
  %call149 = call { i64, i64 } @tnum_add(i64 %169, i64 %171, i64 %174, i64 %176) #11
  %177 = bitcast %struct.tnum* %tmp to { i64, i64 }*
  %178 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %177, i32 0, i32 0
  %179 = extractvalue { i64, i64 } %call149, 0
  store i64 %179, i64* %178, align 8
  %180 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %177, i32 0, i32 1
  %181 = extractvalue { i64, i64 } %call149, 1
  store i64 %181, i64* %180, align 8
  %182 = bitcast %struct.tnum* %var_off146 to i8*
  %183 = bitcast %struct.tnum* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %182, i8* align 8 %183, i64 16, i1 false)
  %184 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off150 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %184, i32 0, i32 2
  %185 = load i32, i32* %off150, align 8
  %186 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off151 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %186, i32 0, i32 2
  store i32 %185, i32* %off151, align 8
  %187 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %188 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %187, i32 0, i32 1
  %raw152 = bitcast %struct.bpf_iter_aux_info* %188 to i64*
  %189 = load i64, i64* %raw152, align 8
  %190 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %191 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %190, i32 0, i32 1
  %raw153 = bitcast %struct.bpf_iter_aux_info* %191 to i64*
  store i64 %189, i64* %raw153, align 8
  %192 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %call154 = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %192) #11
  br i1 %call154, label %if.then155, label %if.end158

if.then155:                                       ; preds = %if.end145
  %193 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %193, i32 0, i32 13
  %194 = load i32, i32* %id_gen, align 4
  %inc = add i32 %194, 1
  store i32 %inc, i32* %id_gen, align 4
  %195 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id156 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %195, i32 0, i32 3
  store i32 %inc, i32* %id156, align 4
  %196 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %197 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %196, i32 0, i32 1
  %raw157 = bitcast %struct.bpf_iter_aux_info* %197 to i64*
  store i64 0, i64* %raw157, align 8
  br label %if.end158

if.end158:                                        ; preds = %if.then155, %if.end145
  br label %sw.epilog263

sw.bb159:                                         ; preds = %if.end82
  %198 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %199 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %200 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %201 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %202 = load i64, i64* %smin_val, align 8
  %cmp160 = icmp slt i64 %202, 0
  %call162 = call i32 @sanitize_ptr_alu(%struct.bpf_verifier_env* noundef %198, %struct.bpf_insn* noundef %199, %struct.bpf_reg_state* noundef %200, %struct.bpf_reg_state* noundef %201, i1 noundef zeroext %cmp160) #11
  store i32 %call162, i32* %ret, align 4
  %203 = load i32, i32* %ret, align 4
  %cmp163 = icmp slt i32 %203, 0
  br i1 %cmp163, label %if.then165, label %if.end166

if.then165:                                       ; preds = %sw.bb159
  %204 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %205 = bitcast %struct.bpf_verifier_env* %204 to i8*
  %206 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %205, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.181, i64 0, i64 0), i32 noundef %206) #11
  %207 = load i32, i32* %ret, align 4
  store i32 %207, i32* %retval, align 4
  br label %return

if.end166:                                        ; preds = %sw.bb159
  %208 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %209 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %cmp167 = icmp eq %struct.bpf_reg_state* %208, %209
  br i1 %cmp167, label %if.then169, label %if.end170

if.then169:                                       ; preds = %if.end166
  %210 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %211 = bitcast %struct.bpf_verifier_env* %210 to i8*
  %212 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %211, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.182, i64 0, i64 0), i32 noundef %212) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end170:                                        ; preds = %if.end166
  %213 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type171 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %213, i32 0, i32 0
  %214 = load i32, i32* %type171, align 8
  %cmp172 = icmp eq i32 %214, 6
  br i1 %cmp172, label %if.then174, label %if.end175

if.then174:                                       ; preds = %if.end170
  %215 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %216 = bitcast %struct.bpf_verifier_env* %215 to i8*
  %217 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %216, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.183, i64 0, i64 0), i32 noundef %217) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end175:                                        ; preds = %if.end170
  %218 = load i8, i8* %known, align 1
  %tobool176 = trunc i8 %218 to i1
  br i1 %tobool176, label %land.lhs.true178, label %if.end204

land.lhs.true178:                                 ; preds = %if.end175
  %219 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off179 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %219, i32 0, i32 2
  %220 = load i32, i32* %off179, align 8
  %conv180 = sext i32 %220 to i64
  %221 = load i64, i64* %smin_val, align 8
  %sub = sub i64 %conv180, %221
  %222 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off181 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %222, i32 0, i32 2
  %223 = load i32, i32* %off181, align 8
  %conv182 = sext i32 %223 to i64
  %224 = load i64, i64* %smin_val, align 8
  %sub183 = sub i64 %conv182, %224
  %conv184 = trunc i64 %sub183 to i32
  %conv185 = sext i32 %conv184 to i64
  %cmp186 = icmp eq i64 %sub, %conv185
  br i1 %cmp186, label %if.then188, label %if.end204

if.then188:                                       ; preds = %land.lhs.true178
  %225 = load i64, i64* %smin_ptr, align 8
  %226 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value189 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %226, i32 0, i32 6
  store i64 %225, i64* %smin_value189, align 8
  %227 = load i64, i64* %smax_ptr, align 8
  %228 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value190 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %228, i32 0, i32 7
  store i64 %227, i64* %smax_value190, align 8
  %229 = load i64, i64* %umin_ptr, align 8
  %230 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value191 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %230, i32 0, i32 8
  store i64 %229, i64* %umin_value191, align 8
  %231 = load i64, i64* %umax_ptr, align 8
  %232 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value192 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %232, i32 0, i32 9
  store i64 %231, i64* %umax_value192, align 8
  %233 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off193 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %233, i32 0, i32 5
  %234 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off194 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %234, i32 0, i32 5
  %235 = bitcast %struct.tnum* %var_off193 to i8*
  %236 = bitcast %struct.tnum* %var_off194 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %235, i8* align 8 %236, i64 16, i1 false)
  %237 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %id195 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %237, i32 0, i32 3
  %238 = load i32, i32* %id195, align 4
  %239 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id196 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %239, i32 0, i32 3
  store i32 %238, i32* %id196, align 4
  %240 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off197 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %240, i32 0, i32 2
  %241 = load i32, i32* %off197, align 8
  %conv198 = sext i32 %241 to i64
  %242 = load i64, i64* %smin_val, align 8
  %sub199 = sub i64 %conv198, %242
  %conv200 = trunc i64 %sub199 to i32
  %243 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off201 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %243, i32 0, i32 2
  store i32 %conv200, i32* %off201, align 8
  %244 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %245 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %244, i32 0, i32 1
  %raw202 = bitcast %struct.bpf_iter_aux_info* %245 to i64*
  %246 = load i64, i64* %raw202, align 8
  %247 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %248 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %247, i32 0, i32 1
  %raw203 = bitcast %struct.bpf_iter_aux_info* %248 to i64*
  store i64 %246, i64* %raw203, align 8
  br label %sw.epilog263

if.end204:                                        ; preds = %land.lhs.true178, %if.end175
  %249 = load i64, i64* %smin_ptr, align 8
  %conv205 = trunc i64 %249 to i32
  %250 = load i64, i64* %smax_val, align 8
  %conv206 = trunc i64 %250 to i32
  %call207 = call zeroext i1 @signed_sub_overflows(i32 noundef %conv205, i32 noundef %conv206) #11
  br i1 %call207, label %if.then214, label %lor.lhs.false209

lor.lhs.false209:                                 ; preds = %if.end204
  %251 = load i64, i64* %smax_ptr, align 8
  %conv210 = trunc i64 %251 to i32
  %252 = load i64, i64* %smin_val, align 8
  %conv211 = trunc i64 %252 to i32
  %call212 = call zeroext i1 @signed_sub_overflows(i32 noundef %conv210, i32 noundef %conv211) #11
  br i1 %call212, label %if.then214, label %if.else217

if.then214:                                       ; preds = %lor.lhs.false209, %if.end204
  %253 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value215 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %253, i32 0, i32 6
  store i64 -9223372036854775808, i64* %smin_value215, align 8
  %254 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value216 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %254, i32 0, i32 7
  store i64 9223372036854775807, i64* %smax_value216, align 8
  br label %if.end222

if.else217:                                       ; preds = %lor.lhs.false209
  %255 = load i64, i64* %smin_ptr, align 8
  %256 = load i64, i64* %smax_val, align 8
  %sub218 = sub i64 %255, %256
  %257 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smin_value219 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %257, i32 0, i32 6
  store i64 %sub218, i64* %smin_value219, align 8
  %258 = load i64, i64* %smax_ptr, align 8
  %259 = load i64, i64* %smin_val, align 8
  %sub220 = sub i64 %258, %259
  %260 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %smax_value221 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %260, i32 0, i32 7
  store i64 %sub220, i64* %smax_value221, align 8
  br label %if.end222

if.end222:                                        ; preds = %if.else217, %if.then214
  %261 = load i64, i64* %umin_ptr, align 8
  %262 = load i64, i64* %umax_val, align 8
  %cmp223 = icmp ult i64 %261, %262
  br i1 %cmp223, label %if.then225, label %if.else228

if.then225:                                       ; preds = %if.end222
  %263 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value226 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %263, i32 0, i32 8
  store i64 0, i64* %umin_value226, align 8
  %264 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value227 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %264, i32 0, i32 9
  store i64 -1, i64* %umax_value227, align 8
  br label %if.end233

if.else228:                                       ; preds = %if.end222
  %265 = load i64, i64* %umin_ptr, align 8
  %266 = load i64, i64* %umax_val, align 8
  %sub229 = sub i64 %265, %266
  %267 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umin_value230 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %267, i32 0, i32 8
  store i64 %sub229, i64* %umin_value230, align 8
  %268 = load i64, i64* %umax_ptr, align 8
  %269 = load i64, i64* %umin_val, align 8
  %sub231 = sub i64 %268, %269
  %270 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %umax_value232 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %270, i32 0, i32 9
  store i64 %sub231, i64* %umax_value232, align 8
  br label %if.end233

if.end233:                                        ; preds = %if.else228, %if.then225
  %271 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off234 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %271, i32 0, i32 5
  %272 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off236 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %272, i32 0, i32 5
  %273 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %off_reg.addr, align 8
  %var_off237 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %273, i32 0, i32 5
  %274 = bitcast %struct.tnum* %var_off236 to { i64, i64 }*
  %275 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %274, i32 0, i32 0
  %276 = load i64, i64* %275, align 8
  %277 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %274, i32 0, i32 1
  %278 = load i64, i64* %277, align 8
  %279 = bitcast %struct.tnum* %var_off237 to { i64, i64 }*
  %280 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %279, i32 0, i32 0
  %281 = load i64, i64* %280, align 8
  %282 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %279, i32 0, i32 1
  %283 = load i64, i64* %282, align 8
  %call238 = call { i64, i64 } @tnum_sub(i64 %276, i64 %278, i64 %281, i64 %283) #11
  %284 = bitcast %struct.tnum* %tmp235 to { i64, i64 }*
  %285 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %284, i32 0, i32 0
  %286 = extractvalue { i64, i64 } %call238, 0
  store i64 %286, i64* %285, align 8
  %287 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %284, i32 0, i32 1
  %288 = extractvalue { i64, i64 } %call238, 1
  store i64 %288, i64* %287, align 8
  %289 = bitcast %struct.tnum* %var_off234 to i8*
  %290 = bitcast %struct.tnum* %tmp235 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %289, i8* align 8 %290, i64 16, i1 false)
  %291 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off239 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %291, i32 0, i32 2
  %292 = load i32, i32* %off239, align 8
  %293 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off240 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %293, i32 0, i32 2
  store i32 %292, i32* %off240, align 8
  %294 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %295 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %294, i32 0, i32 1
  %raw241 = bitcast %struct.bpf_iter_aux_info* %295 to i64*
  %296 = load i64, i64* %raw241, align 8
  %297 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %298 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %297, i32 0, i32 1
  %raw242 = bitcast %struct.bpf_iter_aux_info* %298 to i64*
  store i64 %296, i64* %raw242, align 8
  %299 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %call243 = call zeroext i1 @reg_is_pkt_pointer(%struct.bpf_reg_state* noundef %299) #11
  br i1 %call243, label %if.then244, label %if.end253

if.then244:                                       ; preds = %if.end233
  %300 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %id_gen245 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %300, i32 0, i32 13
  %301 = load i32, i32* %id_gen245, align 4
  %inc246 = add i32 %301, 1
  store i32 %inc246, i32* %id_gen245, align 4
  %302 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %id247 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %302, i32 0, i32 3
  store i32 %inc246, i32* %id247, align 4
  %303 = load i64, i64* %smin_val, align 8
  %cmp248 = icmp slt i64 %303, 0
  br i1 %cmp248, label %if.then250, label %if.end252

if.then250:                                       ; preds = %if.then244
  %304 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %305 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %304, i32 0, i32 1
  %raw251 = bitcast %struct.bpf_iter_aux_info* %305 to i64*
  store i64 0, i64* %raw251, align 8
  br label %if.end252

if.end252:                                        ; preds = %if.then250, %if.then244
  br label %if.end253

if.end253:                                        ; preds = %if.end252, %if.end233
  br label %sw.epilog263

sw.bb254:                                         ; preds = %if.end82, %if.end82, %if.end82
  %306 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %307 = bitcast %struct.bpf_verifier_env* %306 to i8*
  %308 = load i32, i32* %dst, align 4
  %309 = load i8, i8* %opcode, align 1
  %conv255 = zext i8 %309 to i32
  %shr = ashr i32 %conv255, 4
  %idxprom256 = sext i32 %shr to i64
  %arrayidx257 = getelementptr [16 x i8*], [16 x i8*]* @bpf_alu_string, i64 0, i64 %idxprom256
  %310 = load i8*, i8** %arrayidx257, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %307, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.184, i64 0, i64 0), i32 noundef %308, i8* noundef %310) #11
  store i32 -13, i32* %retval, align 4
  br label %return

sw.default258:                                    ; preds = %if.end82
  %311 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %312 = bitcast %struct.bpf_verifier_env* %311 to i8*
  %313 = load i32, i32* %dst, align 4
  %314 = load i8, i8* %opcode, align 1
  %conv259 = zext i8 %314 to i32
  %shr260 = ashr i32 %conv259, 4
  %idxprom261 = sext i32 %shr260 to i64
  %arrayidx262 = getelementptr [16 x i8*], [16 x i8*]* @bpf_alu_string, i64 0, i64 %idxprom261
  %315 = load i8*, i8** %arrayidx262, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %312, i8* noundef getelementptr inbounds ([52 x i8], [52 x i8]* @.str.185, i64 0, i64 0), i32 noundef %313, i8* noundef %315) #11
  store i32 -13, i32* %retval, align 4
  br label %return

sw.epilog263:                                     ; preds = %if.end253, %if.then188, %if.end158, %if.then103
  %316 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %317 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %318 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type264 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %318, i32 0, i32 0
  %319 = load i32, i32* %type264, align 8
  %call265 = call zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %316, %struct.bpf_reg_state* noundef %317, i32 noundef %319) #11
  br i1 %call265, label %if.end267, label %if.then266

if.then266:                                       ; preds = %sw.epilog263
  store i32 -22, i32* %retval, align 4
  br label %return

if.end267:                                        ; preds = %sw.epilog263
  %320 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__update_reg_bounds(%struct.bpf_reg_state* noundef %320) #11
  %321 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__reg_deduce_bounds(%struct.bpf_reg_state* noundef %321) #11
  %322 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  call void @__reg_bound_offset(%struct.bpf_reg_state* noundef %322) #11
  %323 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bypass_spec_v1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %323, i32 0, i32 17
  %324 = load i8, i8* %bypass_spec_v1, align 1
  %tobool268 = trunc i8 %324 to i1
  br i1 %tobool268, label %if.end293, label %if.then269

if.then269:                                       ; preds = %if.end267
  %325 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type270 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %325, i32 0, i32 0
  %326 = load i32, i32* %type270, align 8
  %cmp271 = icmp eq i32 %326, 4
  br i1 %cmp271, label %land.lhs.true273, label %if.else278

land.lhs.true273:                                 ; preds = %if.then269
  %327 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %328 = load i32, i32* %dst, align 4
  %329 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off274 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %329, i32 0, i32 2
  %330 = load i32, i32* %off274, align 8
  %call275 = call i32 @check_map_access(%struct.bpf_verifier_env* noundef %327, i32 noundef %328, i32 noundef %330, i32 noundef 1, i1 noundef zeroext false) #11
  %tobool276 = icmp ne i32 %call275, 0
  br i1 %tobool276, label %if.then277, label %if.else278

if.then277:                                       ; preds = %land.lhs.true273
  %331 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %332 = bitcast %struct.bpf_verifier_env* %331 to i8*
  %333 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %332, i8* noundef getelementptr inbounds ([77 x i8], [77 x i8]* @.str.186, i64 0, i64 0), i32 noundef %333) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.else278:                                       ; preds = %land.lhs.true273, %if.then269
  %334 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %type279 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %334, i32 0, i32 0
  %335 = load i32, i32* %type279, align 8
  %cmp280 = icmp eq i32 %335, 6
  br i1 %cmp280, label %land.lhs.true282, label %if.end291

land.lhs.true282:                                 ; preds = %if.else278
  %336 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %337 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %338 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %off283 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %338, i32 0, i32 2
  %339 = load i32, i32* %off283, align 8
  %conv284 = sext i32 %339 to i64
  %340 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg, align 8
  %var_off285 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %340, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off285, i32 0, i32 0
  %341 = load i64, i64* %value, align 8
  %add286 = add i64 %conv284, %341
  %conv287 = trunc i64 %add286 to i32
  %call288 = call i32 @check_stack_access(%struct.bpf_verifier_env* noundef %336, %struct.bpf_reg_state* noundef %337, i32 noundef %conv287, i32 noundef 1) #11
  %tobool289 = icmp ne i32 %call288, 0
  br i1 %tobool289, label %if.then290, label %if.end291

if.then290:                                       ; preds = %land.lhs.true282
  %342 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %343 = bitcast %struct.bpf_verifier_env* %342 to i8*
  %344 = load i32, i32* %dst, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %343, i8* noundef getelementptr inbounds ([70 x i8], [70 x i8]* @.str.187, i64 0, i64 0), i32 noundef %344) #11
  store i32 -13, i32* %retval, align 4
  br label %return

if.end291:                                        ; preds = %land.lhs.true282, %if.else278
  br label %if.end292

if.end292:                                        ; preds = %if.end291
  br label %if.end293

if.end293:                                        ; preds = %if.end292, %if.end267
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end293, %if.then290, %if.then277, %if.then266, %sw.default258, %sw.bb254, %if.then174, %if.then169, %if.then165, %if.then90, %if.then81, %cond.end, %sw.bb53, %sw.bb, %if.end36, %if.then35, %if.then
  %345 = load i32, i32* %retval, align 4
  ret i32 %345
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_reg_sane_offset(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %type.addr = alloca i32, align 4
  %known = alloca i8, align 1
  %val = alloca i64, align 8
  %smin = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 5
  %1 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %2 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = load i64, i64* %2, align 8
  %4 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = load i64, i64* %4, align 8
  %call = call zeroext i1 @tnum_is_const(i64 %3, i64 %5) #11
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %known, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %var_off1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off1, i32 0, i32 0
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %val, align 8
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  store i64 %9, i64* %smin, align 8
  %10 = load i8, i8* %known, align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %11 = load i64, i64* %val, align 8
  %cmp = icmp sge i64 %11, 536870912
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %12 = load i64, i64* %val, align 8
  %cmp2 = icmp sle i64 %12, -536870912
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  %15 = load i32, i32* %type.addr, align 4
  %idxprom = zext i32 %15 to i64
  %arrayidx = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom
  %16 = load i8*, i8** %arrayidx, align 8
  %17 = load i64, i64* %val, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.188, i64 0, i64 0), i8* noundef %16, i64 noundef %17) #11
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 2
  %19 = load i32, i32* %off, align 8
  %cmp3 = icmp sge i32 %19, 536870912
  br i1 %cmp3, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 2
  %21 = load i32, i32* %off5, align 8
  %cmp6 = icmp sle i32 %21, -536870912
  br i1 %cmp6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %lor.lhs.false4, %if.end
  %22 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %23 = bitcast %struct.bpf_verifier_env* %22 to i8*
  %24 = load i32, i32* %type.addr, align 4
  %idxprom8 = zext i32 %24 to i64
  %arrayidx9 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom8
  %25 = load i8*, i8** %arrayidx9, align 8
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %off10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %26, i32 0, i32 2
  %27 = load i32, i32* %off10, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %23, i8* noundef getelementptr inbounds ([37 x i8], [37 x i8]* @.str.189, i64 0, i64 0), i8* noundef %25, i32 noundef %27) #11
  store i1 false, i1* %retval, align 1
  br label %return

if.end11:                                         ; preds = %lor.lhs.false4
  %28 = load i64, i64* %smin, align 8
  %cmp12 = icmp eq i64 %28, -9223372036854775808
  br i1 %cmp12, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.end11
  %29 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %30 = bitcast %struct.bpf_verifier_env* %29 to i8*
  %31 = load i32, i32* %type.addr, align 4
  %idxprom14 = zext i32 %31 to i64
  %arrayidx15 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom14
  %32 = load i8*, i8** %arrayidx15, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %30, i8* noundef getelementptr inbounds ([78 x i8], [78 x i8]* @.str.190, i64 0, i64 0), i8* noundef %32) #11
  store i1 false, i1* %retval, align 1
  br label %return

if.end16:                                         ; preds = %if.end11
  %33 = load i64, i64* %smin, align 8
  %cmp17 = icmp sge i64 %33, 536870912
  br i1 %cmp17, label %if.then20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %if.end16
  %34 = load i64, i64* %smin, align 8
  %cmp19 = icmp sle i64 %34, -536870912
  br i1 %cmp19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %lor.lhs.false18, %if.end16
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = bitcast %struct.bpf_verifier_env* %35 to i8*
  %37 = load i64, i64* %smin, align 8
  %38 = load i32, i32* %type.addr, align 4
  %idxprom21 = zext i32 %38 to i64
  %arrayidx22 = getelementptr [28 x i8*], [28 x i8*]* @reg_type_str, i64 0, i64 %idxprom21
  %39 = load i8*, i8** %arrayidx22, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %36, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.191, i64 0, i64 0), i64 noundef %37, i8* noundef %39) #11
  store i1 false, i1* %retval, align 1
  br label %return

if.end23:                                         ; preds = %lor.lhs.false18
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end23, %if.then20, %if.then13, %if.then7, %if.then
  %40 = load i1, i1* %retval, align 1
  ret i1 %40
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @sanitize_ptr_alu(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_reg_state* noundef %ptr_reg, %struct.bpf_reg_state* noundef %dst_reg, i1 noundef zeroext %off_is_neg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %ptr_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %dst_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %off_is_neg.addr = alloca i8, align 1
  %vstate = alloca %struct.bpf_verifier_state*, align 8
  %aux = alloca %struct.bpf_insn_aux_data*, align 8
  %ptr_is_dst_reg = alloca i8, align 1
  %opcode = alloca i8, align 1
  %alu_state = alloca i32, align 4
  %alu_limit = alloca i32, align 4
  %tmp = alloca %struct.bpf_reg_state, align 8
  %ret = alloca i8, align 1
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_reg_state* %ptr_reg, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  store %struct.bpf_reg_state* %dst_reg, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %frombool = zext i1 %off_is_neg to i8
  store i8 %frombool, i8* %off_is_neg.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %vstate, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call %struct.bpf_insn_aux_data* @cur_aux(%struct.bpf_verifier_env* noundef %2) #11
  store %struct.bpf_insn_aux_data* %call, %struct.bpf_insn_aux_data** %aux, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %cmp = icmp eq %struct.bpf_reg_state* %3, %4
  %frombool1 = zext i1 %cmp to i8
  store i8 %frombool1, i8* %ptr_is_dst_reg, align 1
  %5 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %5, i32 0, i32 0
  %6 = load i8, i8* %code, align 4
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 240
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %opcode, align 1
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %call3 = call zeroext i1 @can_skip_alu_sanitation(%struct.bpf_verifier_env* noundef %7, %struct.bpf_insn* noundef %8) #11
  br i1 %call3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %9, i32 0, i32 6
  %10 = load i8, i8* %speculative, align 8
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %do_sim

if.end5:                                          ; preds = %if.end
  %11 = load i8, i8* %off_is_neg.addr, align 1
  %tobool6 = trunc i8 %11 to i1
  %12 = zext i1 %tobool6 to i64
  %cond = select i1 %tobool6, i32 4, i32 0
  store i32 %cond, i32* %alu_state, align 4
  %13 = load i8, i8* %ptr_is_dst_reg, align 1
  %tobool8 = trunc i8 %13 to i1
  %14 = zext i1 %tobool8 to i64
  %cond10 = select i1 %tobool8, i32 1, i32 2
  %15 = load i32, i32* %alu_state, align 4
  %or = or i32 %15, %cond10
  store i32 %or, i32* %alu_state, align 4
  %16 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %17 = load i8, i8* %opcode, align 1
  %18 = load i8, i8* %off_is_neg.addr, align 1
  %tobool11 = trunc i8 %18 to i1
  %call12 = call i32 @retrieve_ptr_limit(%struct.bpf_reg_state* noundef %16, i32* noundef %alu_limit, i8 noundef zeroext %17, i1 noundef zeroext %tobool11) #11
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end5
  store i32 0, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end5
  %19 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux, align 8
  %20 = load i32, i32* %alu_state, align 4
  %21 = load i32, i32* %alu_limit, align 4
  %call16 = call i32 @update_alu_sanitation_state(%struct.bpf_insn_aux_data* noundef %19, i32 noundef %20, i32 noundef %21) #11
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  store i32 -13, i32* %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end15
  br label %do_sim

do_sim:                                           ; preds = %if.end19, %if.then4
  %22 = load i8, i8* %ptr_is_dst_reg, align 1
  %tobool20 = trunc i8 %22 to i1
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %do_sim
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %24 = bitcast %struct.bpf_reg_state* %tmp to i8*
  %25 = bitcast %struct.bpf_reg_state* %23 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %24, i8* align 8 %25, i64 120, i1 false)
  %26 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %28 = bitcast %struct.bpf_reg_state* %26 to i8*
  %29 = bitcast %struct.bpf_reg_state* %27 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %28, i8* align 8 %29, i64 120, i1 false)
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %do_sim
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %31, i32 0, i32 0
  %32 = load i32, i32* %insn_idx, align 8
  %add = add i32 %32, 1
  %33 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx23 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %33, i32 0, i32 0
  %34 = load i32, i32* %insn_idx23, align 8
  %call24 = call %struct.bpf_verifier_state* @push_stack(%struct.bpf_verifier_env* noundef %30, i32 noundef %add, i32 noundef %34, i1 noundef zeroext true) #11
  %tobool25 = icmp ne %struct.bpf_verifier_state* %call24, null
  %frombool26 = zext i1 %tobool25 to i8
  store i8 %frombool26, i8* %ret, align 1
  %35 = load i8, i8* %ptr_is_dst_reg, align 1
  %tobool27 = trunc i8 %35 to i1
  br i1 %tobool27, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end22
  %36 = load i8, i8* %ret, align 1
  %tobool28 = trunc i8 %36 to i1
  br i1 %tobool28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %land.lhs.true
  %37 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %dst_reg.addr, align 8
  %38 = bitcast %struct.bpf_reg_state* %37 to i8*
  %39 = bitcast %struct.bpf_reg_state* %tmp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %38, i8* align 8 %39, i64 120, i1 false)
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %land.lhs.true, %if.end22
  %40 = load i8, i8* %ret, align 1
  %tobool32 = trunc i8 %40 to i1
  %lnot = xor i1 %tobool32, true
  %41 = zext i1 %lnot to i64
  %cond33 = select i1 %lnot, i32 -14, i32 0
  store i32 %cond33, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end31, %if.then18, %if.then14, %if.then
  %42 = load i32, i32* %retval, align 4
  ret i32 %42
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @retrieve_ptr_limit(%struct.bpf_reg_state* noundef %ptr_reg, i32* noundef %ptr_limit, i8 noundef zeroext %opcode, i1 noundef zeroext %off_is_neg) #0 {
entry:
  %retval = alloca i32, align 4
  %ptr_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %ptr_limit.addr = alloca i32*, align 8
  %opcode.addr = alloca i8, align 1
  %off_is_neg.addr = alloca i8, align 1
  %mask_to_left = alloca i8, align 1
  %off = alloca i32, align 4
  store %struct.bpf_reg_state* %ptr_reg, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  store i32* %ptr_limit, i32** %ptr_limit.addr, align 8
  store i8 %opcode, i8* %opcode.addr, align 1
  %frombool = zext i1 %off_is_neg to i8
  store i8 %frombool, i8* %off_is_neg.addr, align 1
  %0 = load i8, i8* %opcode.addr, align 1
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* %off_is_neg.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %entry
  %2 = load i8, i8* %opcode.addr, align 1
  %conv3 = zext i8 %2 to i32
  %cmp4 = icmp eq i32 %conv3, 16
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %3 = load i8, i8* %off_is_neg.addr, align 1
  %tobool6 = trunc i8 %3 to i1
  %lnot = xor i1 %tobool6, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %4 = phi i1 [ false, %lor.rhs ], [ %lnot, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.lhs.true
  %5 = phi i1 [ true, %land.lhs.true ], [ %4, %land.end ]
  %frombool7 = zext i1 %5 to i8
  store i8 %frombool7, i8* %mask_to_left, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  switch i32 %7, label %sw.default [
    i32 6, label %sw.bb
    i32 4, label %sw.bb13
  ]

sw.bb:                                            ; preds = %lor.end
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 2
  %9 = load i32, i32* %off8, align 8
  %conv9 = sext i32 %9 to i64
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 5
  %value = getelementptr inbounds %struct.tnum, %struct.tnum* %var_off, i32 0, i32 0
  %11 = load i64, i64* %value, align 8
  %add = add i64 %conv9, %11
  %conv10 = trunc i64 %add to i32
  store i32 %conv10, i32* %off, align 4
  %12 = load i8, i8* %mask_to_left, align 1
  %tobool11 = trunc i8 %12 to i1
  br i1 %tobool11, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %13 = load i32, i32* %off, align 4
  %add12 = add i32 512, %13
  %14 = load i32*, i32** %ptr_limit.addr, align 8
  store i32 %add12, i32* %14, align 4
  br label %if.end

if.else:                                          ; preds = %sw.bb
  %15 = load i32, i32* %off, align 4
  %sub = sub i32 0, %15
  %16 = load i32*, i32** %ptr_limit.addr, align 8
  store i32 %sub, i32* %16, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  store i32 0, i32* %retval, align 4
  br label %return

sw.bb13:                                          ; preds = %lor.end
  %17 = load i8, i8* %mask_to_left, align 1
  %tobool14 = trunc i8 %17 to i1
  br i1 %tobool14, label %if.then15, label %if.else20

if.then15:                                        ; preds = %sw.bb13
  %18 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %18, i32 0, i32 9
  %19 = load i64, i64* %umax_value, align 8
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off16 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 0, i32 2
  %21 = load i32, i32* %off16, align 8
  %conv17 = sext i32 %21 to i64
  %add18 = add i64 %19, %conv17
  %conv19 = trunc i64 %add18 to i32
  %22 = load i32*, i32** %ptr_limit.addr, align 8
  store i32 %conv19, i32* %22, align 4
  br label %if.end26

if.else20:                                        ; preds = %sw.bb13
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 6
  %24 = load i64, i64* %smin_value, align 8
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %off21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 2
  %26 = load i32, i32* %off21, align 8
  %conv22 = sext i32 %26 to i64
  %add23 = add i64 %24, %conv22
  %conv24 = trunc i64 %add23 to i32
  store i32 %conv24, i32* %off, align 4
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %ptr_reg.addr, align 8
  %28 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %27, i32 0, i32 1
  %map_ptr = bitcast %struct.bpf_iter_aux_info* %28 to %struct.bpf_map**
  %29 = load %struct.bpf_map*, %struct.bpf_map** %map_ptr, align 8
  %value_size = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %29, i32 0, i32 5
  %30 = load i32, i32* %value_size, align 32
  %31 = load i32, i32* %off, align 4
  %sub25 = sub i32 %30, %31
  %32 = load i32*, i32** %ptr_limit.addr, align 8
  store i32 %sub25, i32* %32, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.else20, %if.then15
  store i32 0, i32* %retval, align 4
  br label %return

sw.default:                                       ; preds = %lor.end
  store i32 -22, i32* %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %if.end26, %if.end
  %33 = load i32, i32* %retval, align 4
  ret i32 %33
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.ethtool_pauseparam* @find_linfo(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn_off) #0 {
entry:
  %retval = alloca %struct.ethtool_pauseparam*, align 8
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn_off.addr = alloca i32, align 4
  %linfo = alloca %struct.ethtool_pauseparam*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %i = alloca i32, align 4
  %nr_linfo = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn_off, i32* %insn_off.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 7
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %nr_linfo2 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 50
  %4 = load i32, i32* %nr_linfo2, align 4
  store i32 %4, i32* %nr_linfo, align 4
  %5 = load i32, i32* %nr_linfo, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %6 = load i32, i32* %insn_off.addr, align 4
  %7 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %7, i32 0, i32 4
  %8 = load i32, i32* %len, align 4
  %cmp = icmp uge i32 %6, %8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store %struct.ethtool_pauseparam* null, %struct.ethtool_pauseparam** %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %9 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux3 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %9, i32 0, i32 7
  %10 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux3, align 8
  %linfo4 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %10, i32 0, i32 47
  %11 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo4, align 8
  store %struct.ethtool_pauseparam* %11, %struct.ethtool_pauseparam** %linfo, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %12 = load i32, i32* %i, align 4
  %13 = load i32, i32* %nr_linfo, align 4
  %cmp5 = icmp ult i32 %12, %13
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load i32, i32* %insn_off.addr, align 4
  %15 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %16 = load i32, i32* %i, align 4
  %idxprom = zext i32 %16 to i64
  %arrayidx = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %15, i64 %idxprom
  %insn_off6 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx, i32 0, i32 0
  %17 = load i32, i32* %insn_off6, align 4
  %cmp7 = icmp ult i32 %14, %17
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.body
  br label %for.end

if.end9:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then8, %for.cond
  %19 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %20 = load i32, i32* %i, align 4
  %sub = sub i32 %20, 1
  %idxprom10 = zext i32 %sub to i64
  %arrayidx11 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %19, i64 %idxprom10
  store %struct.ethtool_pauseparam* %arrayidx11, %struct.ethtool_pauseparam** %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  %21 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %retval, align 8
  ret %struct.ethtool_pauseparam* %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @ltrim(i8* noundef %s) #0 {
entry:
  %s.addr = alloca i8*, align 8
  store i8* %s, i8** %s.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i8*, i8** %s.addr, align 8
  %1 = load i8, i8* %0, align 1
  %conv = zext i8 %1 to i32
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr [0 x i8], [0 x i8]* @_ctype, i64 0, i64 %idxprom
  %2 = load i8, i8* %arrayidx, align 1
  %conv1 = zext i8 %2 to i32
  %and = and i32 %conv1, 32
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i8*, i8** %s.addr, align 8
  %incdec.ptr = getelementptr i8, i8* %3, i32 1
  store i8* %incdec.ptr, i8** %s.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %4 = load i8*, i8** %s.addr, align 8
  ret i8* %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @print_liveness(%struct.bpf_verifier_env* noundef %env, i32 noundef %live) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %live.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %live, i32* %live.addr, align 4
  %0 = load i32, i32* %live.addr, align 4
  %and = and i32 %0, 15
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %2 = bitcast %struct.bpf_verifier_env* %1 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %2, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.160, i64 0, i64 0)) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, i32* %live.addr, align 4
  %and1 = and i32 %3, 3
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.161, i64 0, i64 0)) #11
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %6 = load i32, i32* %live.addr, align 4
  %and5 = and i32 %6, 4
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = bitcast %struct.bpf_verifier_env* %7 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %8, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.162, i64 0, i64 0)) #11
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end4
  %9 = load i32, i32* %live.addr, align 4
  %and9 = and i32 %9, 8
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %11 = bitcast %struct.bpf_verifier_env* %10 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %11, i8* noundef getelementptr inbounds ([2 x i8], [2 x i8]* @.str.163, i64 0, i64 0)) #11
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @reg_type_may_be_refcounted_or_null(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 11
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 12
  br i1 %cmp1, label %lor.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 15
  br i1 %cmp3, label %lor.end, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %3 = load i32, i32* %type.addr, align 4
  %cmp5 = icmp eq i32 %3, 16
  br i1 %cmp5, label %lor.end, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %4 = load i32, i32* %type.addr, align 4
  %cmp7 = icmp eq i32 %4, 21
  br i1 %cmp7, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false6
  %5 = load i32, i32* %type.addr, align 4
  %cmp8 = icmp eq i32 %5, 22
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false6, %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  %6 = phi i1 [ true, %lor.lhs.false6 ], [ true, %lor.lhs.false4 ], [ true, %lor.lhs.false2 ], [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp8, %lor.rhs ]
  ret i1 %6
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @test_bit(i64 noundef %nr, i64* noundef %addr) #0 {
entry:
  %nr.addr.i3 = alloca i64, align 8
  %addr.addr.i4 = alloca i64*, align 8
  %oldbit.i = alloca i8, align 1
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %v.addr.i = alloca i8*, align 8
  %size.addr.i = alloca i64, align 8
  %nr.addr = alloca i64, align 8
  %addr.addr = alloca i64*, align 8
  store i64 %nr, i64* %nr.addr, align 8
  store i64* %addr, i64** %addr.addr, align 8
  %0 = load i64*, i64** %addr.addr, align 8
  %1 = load i64, i64* %nr.addr, align 8
  %div = sdiv i64 %1, 64
  %add.ptr = getelementptr i64, i64* %0, i64 %div
  %2 = bitcast i64* %add.ptr to i8*
  store i8* %2, i8** %v.addr.i, align 8
  store i64 8, i64* %size.addr.i, align 8
  %3 = load i8*, i8** %v.addr.i, align 8
  %4 = load i64, i64* %size.addr.i, align 8
  %conv.i = trunc i64 %4 to i32
  %call.i = call zeroext i1 @kasan_check_read(i8* noundef %3, i32 noundef %conv.i) #13
  %5 = load i8*, i8** %v.addr.i, align 8
  %6 = load i64, i64* %size.addr.i, align 8
  call void @kcsan_check_access(i8* noundef %5, i64 noundef %6, i32 noundef 4) #13
  %7 = load i64, i64* %nr.addr, align 8
  %8 = call i1 @llvm.is.constant.i64(i64 %7)
  br i1 %8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %9 = load i64, i64* %nr.addr, align 8
  %10 = load i64*, i64** %addr.addr, align 8
  store i64 %9, i64* %nr.addr.i, align 8
  store i64* %10, i64** %addr.addr.i, align 8
  %11 = load i64, i64* %nr.addr.i, align 8
  %and.i = and i64 %11, 63
  %shl.i = shl i64 1, %and.i
  %12 = load i64*, i64** %addr.addr.i, align 8
  %13 = load i64, i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %13, 6
  %arrayidx.i = getelementptr i64, i64* %12, i64 %shr.i
  %14 = load volatile i64, i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %14
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv = zext i1 %cmp.i to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %15 = load i64, i64* %nr.addr, align 8
  %16 = load i64*, i64** %addr.addr, align 8
  store i64 %15, i64* %nr.addr.i3, align 8
  store i64* %16, i64** %addr.addr.i4, align 8
  %17 = load i64*, i64** %addr.addr.i4, align 8
  %18 = load i64, i64* %nr.addr.i3, align 8
  %19 = call i8 asm sideeffect " btq  $2,$1\0A\09/* output condition code c*/\0A", "={@ccc},*m,Ir,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* elementtype(i64) %17, i64 %18) #10, !srcloc !67
  store i8 %19, i8* %oldbit.i, align 1
  %20 = load i8, i8* %oldbit.i, align 1
  %tobool.i = trunc i8 %20 to i1
  %conv2 = zext i1 %tobool.i to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ %conv2, %cond.false ]
  %tobool = icmp ne i32 %cond, 0
  ret i1 %tobool
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @kasan_check_read(i8* noundef %p, i32 noundef %size) #0 {
entry:
  %p.addr = alloca i8*, align 8
  %size.addr = alloca i32, align 4
  store i8* %p, i8** %p.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  ret i1 true
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @kcsan_check_access(i8* noundef %ptr, i64 noundef %size, i32 noundef %type) #0 {
entry:
  %ptr.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %type.addr = alloca i32, align 4
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @test_tsk_thread_flag(%struct.task_struct* noundef %tsk, i32 noundef %flag) #0 {
entry:
  %tsk.addr = alloca %struct.task_struct*, align 8
  %flag.addr = alloca i32, align 4
  store %struct.task_struct* %tsk, %struct.task_struct** %tsk.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load %struct.task_struct*, %struct.task_struct** %tsk.addr, align 8
  %call = call %struct.thread_info* @task_thread_info(%struct.task_struct* noundef %0) #11
  %1 = load i32, i32* %flag.addr, align 4
  %call1 = call i32 @test_ti_thread_flag(%struct.thread_info* noundef %call, i32 noundef %1) #11
  ret i32 %call1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.thread_info* @task_thread_info(%struct.task_struct* noundef %task) #0 {
entry:
  %task.addr = alloca %struct.task_struct*, align 8
  store %struct.task_struct* %task, %struct.task_struct** %task.addr, align 8
  %0 = load %struct.task_struct*, %struct.task_struct** %task.addr, align 8
  %thread_info = getelementptr inbounds %struct.task_struct, %struct.task_struct* %0, i32 0, i32 0
  ret %struct.thread_info* %thread_info
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %idx.addr = alloca i32, align 4
  %cur = alloca %struct.bpf_verifier_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cur_state = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 8
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur_state, align 8
  store %struct.bpf_verifier_state* %1, %struct.bpf_verifier_state** %cur, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 0
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 4
  %4 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %5, %struct.bpf_func_state** %state, align 8
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %explored_states = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 9
  %7 = load %struct.bpf_verifier_state_list**, %struct.bpf_verifier_state_list*** %explored_states, align 8
  %8 = load i32, i32* %idx.addr, align 4
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 1
  %10 = load i32, i32* %callsite, align 8
  %xor = xor i32 %8, %10
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @state_htab_size(%struct.bpf_verifier_env* noundef %11) #11
  %rem = urem i32 %xor, %call
  %idxprom1 = zext i32 %rem to i64
  %arrayidx2 = getelementptr %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %7, i64 %idxprom1
  ret %struct.bpf_verifier_state_list** %arrayidx2
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clean_live_states(%struct.bpf_verifier_env* noundef %env, i32 noundef %insn, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca i32, align 4
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %sl = alloca %struct.bpf_verifier_state_list*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %insn, i32* %insn.addr, align 4
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %insn.addr, align 4
  %call = call %struct.bpf_verifier_state_list** @explored_state(%struct.bpf_verifier_env* noundef %0, i32 noundef %1) #11
  %2 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %call, align 8
  store %struct.bpf_verifier_state_list* %2, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.cond:                                       ; preds = %next, %entry
  %3 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %tobool = icmp ne %struct.bpf_verifier_state_list* %3, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %4, i32 0, i32 0
  %branches = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state, i32 0, i32 2
  %5 = load i32, i32* %branches, align 8
  %tobool1 = icmp ne i32 %5, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %next

if.end:                                           ; preds = %while.body
  %6 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state2 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %6, i32 0, i32 0
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state2, i32 0, i32 3
  %7 = load i32, i32* %insn_idx, align 4
  %8 = load i32, i32* %insn.addr, align 4
  %cmp = icmp ne i32 %7, %8
  br i1 %cmp, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %9 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state3 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %9, i32 0, i32 0
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state3, i32 0, i32 4
  %10 = load i32, i32* %curframe, align 8
  %11 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %11, i32 0, i32 4
  %12 = load i32, i32* %curframe4, align 8
  %cmp5 = icmp ne i32 %10, %12
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %lor.lhs.false, %if.end
  br label %next

if.end7:                                          ; preds = %lor.lhs.false
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %13 = load i32, i32* %i, align 4
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe8 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 4
  %15 = load i32, i32* %curframe8, align 8
  %cmp9 = icmp ule i32 %13, %15
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state10 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %16, i32 0, i32 0
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %state10, i32 0, i32 0
  %17 = load i32, i32* %i, align 4
  %idxprom = sext i32 %17 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %18 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %18, i32 0, i32 1
  %19 = load i32, i32* %callsite, align 8
  %20 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame11 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %20, i32 0, i32 0
  %21 = load i32, i32* %i, align 4
  %idxprom12 = sext i32 %21 to i64
  %arrayidx13 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame11, i64 0, i64 %idxprom12
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx13, align 8
  %callsite14 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 1
  %23 = load i32, i32* %callsite14, align 8
  %cmp15 = icmp ne i32 %19, %23
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %for.body
  br label %next

if.end17:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %24 = load i32, i32* %i, align 4
  %inc = add i32 %24, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %state18 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %26, i32 0, i32 0
  call void @clean_verifier_state(%struct.bpf_verifier_env* noundef %25, %struct.bpf_verifier_state* noundef %state18) #11
  br label %next

next:                                             ; preds = %for.end, %if.then16, %if.then6, %if.then
  %27 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %sl, align 8
  %next19 = getelementptr inbounds %struct.bpf_verifier_state_list, %struct.bpf_verifier_state_list* %27, i32 0, i32 1
  %28 = load %struct.bpf_verifier_state_list*, %struct.bpf_verifier_state_list** %next19, align 8
  store %struct.bpf_verifier_state_list* %28, %struct.bpf_verifier_state_list** %sl, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @states_maybe_looping(%struct.bpf_verifier_state* noundef %old, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %old.addr = alloca %struct.bpf_verifier_state*, align 8
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %fold = alloca %struct.bpf_func_state*, align 8
  %fcur = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %fr = alloca i32, align 4
  store %struct.bpf_verifier_state* %old, %struct.bpf_verifier_state** %old.addr, align 8
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 4
  %1 = load i32, i32* %curframe, align 8
  store i32 %1, i32* %fr, align 4
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe1, align 8
  %4 = load i32, i32* %fr, align 4
  %cmp = icmp ne i32 %3, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %5, i32 0, i32 0
  %6 = load i32, i32* %fr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %7, %struct.bpf_func_state** %fold, align 8
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 0
  %9 = load i32, i32* %fr, align 4
  %idxprom3 = sext i32 %9 to i64
  %arrayidx4 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame2, i64 0, i64 %idxprom3
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx4, align 8
  store %struct.bpf_func_state* %10, %struct.bpf_func_state** %fcur, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %11 = load i32, i32* %i, align 4
  %cmp5 = icmp slt i32 %11, 11
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %fold, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %12, i32 0, i32 0
  %13 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom6
  %14 = bitcast %struct.bpf_reg_state* %arrayidx7 to i8*
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %fcur, align 8
  %regs8 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 0
  %16 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %16 to i64
  %arrayidx10 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs8, i64 0, i64 %idxprom9
  %17 = bitcast %struct.bpf_reg_state* %arrayidx10 to i8*
  %call = call i32 @memcmp(i8* noundef %14, i8* noundef %17, i64 noundef 96) #11
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body
  store i1 false, i1* %retval, align 1
  br label %return

if.end12:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then11, %if.then
  %19 = load i1, i1* %retval, align 1
  ret i1 %19
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @states_equal(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %old, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %old.addr = alloca %struct.bpf_verifier_state*, align 8
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %old, %struct.bpf_verifier_state** %old.addr, align 8
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 4
  %1 = load i32, i32* %curframe, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe1, align 8
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %speculative = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 6
  %5 = load i8, i8* %speculative, align 8
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %6 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %speculative2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %6, i32 0, i32 6
  %7 = load i8, i8* %speculative2, align 8
  %tobool3 = trunc i8 %7 to i1
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  store i1 false, i1* %retval, align 1
  br label %return

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %8 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %active_spin_lock = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %8, i32 0, i32 5
  %9 = load i32, i32* %active_spin_lock, align 4
  %10 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %active_spin_lock6 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %10, i32 0, i32 5
  %11 = load i32, i32* %active_spin_lock6, align 4
  %cmp7 = icmp ne i32 %9, %11
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  store i1 false, i1* %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.end5
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end9
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe10 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %13, i32 0, i32 4
  %14 = load i32, i32* %curframe10, align 8
  %cmp11 = icmp ule i32 %12, %14
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %15, i32 0, i32 0
  %16 = load i32, i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %callsite = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 1
  %18 = load i32, i32* %callsite, align 8
  %19 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame12 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %19, i32 0, i32 0
  %20 = load i32, i32* %i, align 4
  %idxprom13 = sext i32 %20 to i64
  %arrayidx14 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame12, i64 0, i64 %idxprom13
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx14, align 8
  %callsite15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 1
  %22 = load i32, i32* %callsite15, align 8
  %cmp16 = icmp ne i32 %18, %22
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.body
  store i1 false, i1* %retval, align 1
  br label %return

if.end18:                                         ; preds = %for.body
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame19 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 0
  %24 = load i32, i32* %i, align 4
  %idxprom20 = sext i32 %24 to i64
  %arrayidx21 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame19, i64 0, i64 %idxprom20
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx21, align 8
  %26 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %frame22 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %26, i32 0, i32 0
  %27 = load i32, i32* %i, align 4
  %idxprom23 = sext i32 %27 to i64
  %arrayidx24 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame22, i64 0, i64 %idxprom23
  %28 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx24, align 8
  %call = call zeroext i1 @func_states_equal(%struct.bpf_func_state* noundef %25, %struct.bpf_func_state* noundef %28) #11
  br i1 %call, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.end18
  store i1 false, i1* %retval, align 1
  br label %return

if.end26:                                         ; preds = %if.end18
  br label %for.inc

for.inc:                                          ; preds = %if.end26
  %29 = load i32, i32* %i, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then25, %if.then17, %if.then8, %if.then4, %if.then
  %30 = load i1, i1* %retval, align 1
  ret i1 %30
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @propagate_liveness(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %vstate, %struct.bpf_verifier_state* noundef %vparent) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %vstate.addr = alloca %struct.bpf_verifier_state*, align 8
  %vparent.addr = alloca %struct.bpf_verifier_state*, align 8
  %state_reg = alloca %struct.bpf_reg_state*, align 8
  %parent_reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %parent = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %frame = alloca i32, align 4
  %err = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %vstate, %struct.bpf_verifier_state** %vstate.addr, align 8
  store %struct.bpf_verifier_state* %vparent, %struct.bpf_verifier_state** %vparent.addr, align 8
  store i32 0, i32* %err, align 4
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vparent.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 4
  %1 = load i32, i32* %curframe, align 8
  %2 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe1 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %2, i32 0, i32 4
  %3 = load i32, i32* %curframe1, align 8
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end25

if.then:                                          ; preds = %entry
  store i32 1, i32* %__ret_warn_on, align 4
  %4 = load i32, i32* %__ret_warn_on, align 4
  %tobool = icmp ne i32 %4, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool3 = icmp ne i64 %conv, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then4
  br label %do.body5

do.body5:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body5
  %5 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vparent.addr, align 8
  %curframe6 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %5, i32 0, i32 4
  %6 = load i32, i32* %curframe6, align 8
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe7 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 4
  %8 = load i32, i32* %curframe7, align 8
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.117, i64 0, i64 0), i32 noundef %6, i32 noundef %8) #11
  br label %do.body8

do.body8:                                         ; preds = %do.end
  br label %do.body9

do.body9:                                         ; preds = %do.body8
  br label %do.end10

do.end10:                                         ; preds = %do.body9
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 10865, i32 2313, i64 12) #10, !srcloc !68
  br label %do.end12

do.end12:                                         ; preds = %do.body11
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 491) #10, !srcloc !69
  br label %do.body13

do.body13:                                        ; preds = %do.end12
  br label %do.end14

do.end14:                                         ; preds = %do.body13
  br label %do.end15

do.end15:                                         ; preds = %do.end14
  br label %do.body16

do.body16:                                        ; preds = %do.end15
  br label %do.end17

do.end17:                                         ; preds = %do.body16
  br label %do.end18

do.end18:                                         ; preds = %do.end17
  br label %if.end

if.end:                                           ; preds = %do.end18, %if.then
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool19 = icmp ne i32 %9, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  store i64 %conv24, i64* %tmp, align 8
  %10 = load i64, i64* %tmp, align 8
  store i32 -14, i32* %retval, align 4
  br label %return

if.end25:                                         ; preds = %entry
  br label %do.body26

do.body26:                                        ; preds = %if.end25
  br label %do.end27

do.end27:                                         ; preds = %do.body26
  store i32 0, i32* %frame, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc80, %do.end27
  %11 = load i32, i32* %frame, align 4
  %12 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe28 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %12, i32 0, i32 4
  %13 = load i32, i32* %curframe28, align 8
  %cmp29 = icmp ule i32 %11, %13
  br i1 %cmp29, label %for.body, label %for.end82

for.body:                                         ; preds = %for.cond
  %14 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vparent.addr, align 8
  %frame31 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %14, i32 0, i32 0
  %15 = load i32, i32* %frame, align 4
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame31, i64 0, i64 %idxprom
  %16 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %16, %struct.bpf_func_state** %parent, align 8
  %17 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %frame32 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %17, i32 0, i32 0
  %18 = load i32, i32* %frame, align 4
  %idxprom33 = sext i32 %18 to i64
  %arrayidx34 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame32, i64 0, i64 %idxprom33
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx34, align 8
  store %struct.bpf_func_state* %19, %struct.bpf_func_state** %state, align 8
  %20 = load %struct.bpf_func_state*, %struct.bpf_func_state** %parent, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %20, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %parent_reg, align 8
  %21 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs35 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %21, i32 0, i32 0
  %arraydecay36 = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs35, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay36, %struct.bpf_reg_state** %state_reg, align 8
  %22 = load i32, i32* %frame, align 4
  %23 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %vstate.addr, align 8
  %curframe37 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %23, i32 0, i32 4
  %24 = load i32, i32* %curframe37, align 8
  %cmp38 = icmp ult i32 %22, %24
  %25 = zext i1 %cmp38 to i64
  %cond = select i1 %cmp38, i32 6, i32 0
  store i32 %cond, i32* %i, align 4
  br label %for.cond40

for.cond40:                                       ; preds = %for.inc, %for.body
  %26 = load i32, i32* %i, align 4
  %cmp41 = icmp slt i32 %26, 10
  br i1 %cmp41, label %for.body43, label %for.end

for.body43:                                       ; preds = %for.cond40
  %27 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %29 = load i32, i32* %i, align 4
  %idxprom44 = sext i32 %29 to i64
  %arrayidx45 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %28, i64 %idxprom44
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom46 = sext i32 %31 to i64
  %arrayidx47 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i64 %idxprom46
  %call = call i32 @propagate_liveness_reg(%struct.bpf_verifier_env* noundef %27, %struct.bpf_reg_state* noundef %arrayidx45, %struct.bpf_reg_state* noundef %arrayidx47) #11
  store i32 %call, i32* %err, align 4
  %32 = load i32, i32* %err, align 4
  %cmp48 = icmp slt i32 %32, 0
  br i1 %cmp48, label %if.then50, label %if.end51

if.then50:                                        ; preds = %for.body43
  %33 = load i32, i32* %err, align 4
  store i32 %33, i32* %retval, align 4
  br label %return

if.end51:                                         ; preds = %for.body43
  %34 = load i32, i32* %err, align 4
  %cmp52 = icmp eq i32 %34, 2
  br i1 %cmp52, label %if.then54, label %if.end57

if.then54:                                        ; preds = %if.end51
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %36 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg, align 8
  %37 = load i32, i32* %i, align 4
  %idxprom55 = sext i32 %37 to i64
  %arrayidx56 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %36, i64 %idxprom55
  call void @mark_insn_zext(%struct.bpf_verifier_env* noundef %35, %struct.bpf_reg_state* noundef %arrayidx56) #11
  br label %if.end57

if.end57:                                         ; preds = %if.then54, %if.end51
  br label %for.inc

for.inc:                                          ; preds = %if.end57
  %38 = load i32, i32* %i, align 4
  %inc = add i32 %38, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond40

for.end:                                          ; preds = %for.cond40
  store i32 0, i32* %i, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc77, %for.end
  %39 = load i32, i32* %i, align 4
  %40 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %40, i32 0, i32 6
  %41 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %41, 8
  %cmp59 = icmp slt i32 %39, %div
  br i1 %cmp59, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond58
  %42 = load i32, i32* %i, align 4
  %43 = load %struct.bpf_func_state*, %struct.bpf_func_state** %parent, align 8
  %allocated_stack61 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %43, i32 0, i32 6
  %44 = load i32, i32* %allocated_stack61, align 8
  %div62 = sdiv i32 %44, 8
  %cmp63 = icmp slt i32 %42, %div62
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond58
  %45 = phi i1 [ false, %for.cond58 ], [ %cmp63, %land.rhs ]
  br i1 %45, label %for.body65, label %for.end79

for.body65:                                       ; preds = %land.end
  %46 = load %struct.bpf_func_state*, %struct.bpf_func_state** %parent, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %46, i32 0, i32 7
  %47 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %48 = load i32, i32* %i, align 4
  %idxprom66 = sext i32 %48 to i64
  %arrayidx67 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %47, i64 %idxprom66
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx67, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %parent_reg, align 8
  %49 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack68 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %49, i32 0, i32 7
  %50 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack68, align 8
  %51 = load i32, i32* %i, align 4
  %idxprom69 = sext i32 %51 to i64
  %arrayidx70 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %50, i64 %idxprom69
  %spilled_ptr71 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx70, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr71, %struct.bpf_reg_state** %state_reg, align 8
  %52 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %53 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %54 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg, align 8
  %call72 = call i32 @propagate_liveness_reg(%struct.bpf_verifier_env* noundef %52, %struct.bpf_reg_state* noundef %53, %struct.bpf_reg_state* noundef %54) #11
  store i32 %call72, i32* %err, align 4
  %55 = load i32, i32* %err, align 4
  %cmp73 = icmp slt i32 %55, 0
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %for.body65
  %56 = load i32, i32* %err, align 4
  store i32 %56, i32* %retval, align 4
  br label %return

if.end76:                                         ; preds = %for.body65
  br label %for.inc77

for.inc77:                                        ; preds = %if.end76
  %57 = load i32, i32* %i, align 4
  %inc78 = add i32 %57, 1
  store i32 %inc78, i32* %i, align 4
  br label %for.cond58

for.end79:                                        ; preds = %land.end
  br label %for.inc80

for.inc80:                                        ; preds = %for.end79
  %58 = load i32, i32* %frame, align 4
  %inc81 = add i32 %58, 1
  store i32 %inc81, i32* %frame, align 4
  br label %for.cond

for.end82:                                        ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end82, %if.then75, %if.then50, %if.end
  %59 = load i32, i32* %retval, align 4
  ret i32 %59
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @push_jmp_history(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %cur) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %cur.addr = alloca %struct.bpf_verifier_state*, align 8
  %cnt = alloca i32, align 4
  %p = alloca %struct.util_est*, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %cur, %struct.bpf_verifier_state** %cur.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history_cnt = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 10
  %1 = load i32, i32* %jmp_history_cnt, align 8
  store i32 %1, i32* %cnt, align 4
  %2 = load i32, i32* %cnt, align 4
  %inc = add i32 %2, 1
  store i32 %inc, i32* %cnt, align 4
  %3 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %3, i32 0, i32 9
  %4 = load %struct.util_est*, %struct.util_est** %jmp_history, align 8
  %5 = bitcast %struct.util_est* %4 to i8*
  %6 = load i32, i32* %cnt, align 4
  %conv = zext i32 %6 to i64
  %mul = mul i64 %conv, 8
  %call = call i8* @krealloc(i8* noundef %5, i64 noundef %mul, i32 noundef 1051840) #11
  %7 = bitcast i8* %call to %struct.util_est*
  store %struct.util_est* %7, %struct.util_est** %p, align 8
  %8 = load %struct.util_est*, %struct.util_est** %p, align 8
  %tobool = icmp ne %struct.util_est* %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %9, i32 0, i32 0
  %10 = load i32, i32* %insn_idx, align 8
  %11 = load %struct.util_est*, %struct.util_est** %p, align 8
  %12 = load i32, i32* %cnt, align 4
  %sub = sub i32 %12, 1
  %idxprom = zext i32 %sub to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %11, i64 %idxprom
  %idx = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 1
  store i32 %10, i32* %idx, align 4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prev_insn_idx = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 1
  %14 = load i32, i32* %prev_insn_idx, align 4
  %15 = load %struct.util_est*, %struct.util_est** %p, align 8
  %16 = load i32, i32* %cnt, align 4
  %sub1 = sub i32 %16, 1
  %idxprom2 = zext i32 %sub1 to i64
  %arrayidx3 = getelementptr %struct.util_est, %struct.util_est* %15, i64 %idxprom2
  %prev_idx = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx3, i32 0, i32 0
  store i32 %14, i32* %prev_idx, align 4
  %17 = load %struct.util_est*, %struct.util_est** %p, align 8
  %18 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history4 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %18, i32 0, i32 9
  store %struct.util_est* %17, %struct.util_est** %jmp_history4, align 8
  %19 = load i32, i32* %cnt, align 4
  %20 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %cur.addr, align 8
  %jmp_history_cnt5 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %20, i32 0, i32 10
  store i32 %19, i32* %jmp_history_cnt5, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %21 = load i32, i32* %retval, align 4
  ret i32 %21
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @propagate_precision(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %old) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %old.addr = alloca %struct.bpf_verifier_state*, align 8
  %state_reg = alloca %struct.bpf_reg_state*, align 8
  %state = alloca %struct.bpf_func_state*, align 8
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %old, %struct.bpf_verifier_state** %old.addr, align 8
  store i32 0, i32* %err, align 4
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %1 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %old.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %1, i32 0, i32 4
  %2 = load i32, i32* %curframe, align 8
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 %idxprom
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  store %struct.bpf_func_state* %3, %struct.bpf_func_state** %state, align 8
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %state_reg, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %5, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp1 = icmp ne i32 %7, 1
  br i1 %cmp1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 18
  %9 = load i8, i8* %precise, align 4
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end:                                           ; preds = %lor.lhs.false
  %10 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %10, i32 0, i32 22
  %level = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log, i32 0, i32 0
  %11 = load i32, i32* %level, align 8
  %and = and i32 %11, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([17 x i8], [17 x i8]* @.str.119, i64 0, i64 0), i32 noundef %14) #11
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %15 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %16 = load i32, i32* %i, align 4
  %call = call i32 @mark_chain_precision(%struct.bpf_verifier_env* noundef %15, i32 noundef %16) #11
  store i32 %call, i32* %err, align 4
  %17 = load i32, i32* %err, align 4
  %cmp5 = icmp slt i32 %17, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %18 = load i32, i32* %err, align 4
  store i32 %18, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end4
  br label %for.inc

for.inc:                                          ; preds = %if.end7, %if.then
  %19 = load i32, i32* %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %i, align 4
  %20 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %incdec.ptr = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %20, i32 1
  store %struct.bpf_reg_state* %incdec.ptr, %struct.bpf_reg_state** %state_reg, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc41, %for.end
  %21 = load i32, i32* %i, align 4
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 6
  %23 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %23, 8
  %cmp9 = icmp slt i32 %21, %div
  br i1 %cmp9, label %for.body10, label %for.end43

for.body10:                                       ; preds = %for.cond8
  %24 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %24, i32 0, i32 7
  %25 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %26 = load i32, i32* %i, align 4
  %idxprom11 = sext i32 %26 to i64
  %arrayidx12 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %25, i64 %idxprom11
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx12, i32 0, i32 1
  %arrayidx13 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 0
  %27 = load i8, i8* %arrayidx13, align 8
  %conv = zext i8 %27 to i32
  %cmp14 = icmp ne i32 %conv, 1
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %for.body10
  br label %for.inc41

if.end17:                                         ; preds = %for.body10
  %28 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state, align 8
  %stack18 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %28, i32 0, i32 7
  %29 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack18, align 8
  %30 = load i32, i32* %i, align 4
  %idxprom19 = sext i32 %30 to i64
  %arrayidx20 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %29, i64 %idxprom19
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx20, i32 0, i32 0
  store %struct.bpf_reg_state* %spilled_ptr, %struct.bpf_reg_state** %state_reg, align 8
  %31 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %type21 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %31, i32 0, i32 0
  %32 = load i32, i32* %type21, align 8
  %cmp22 = icmp ne i32 %32, 1
  br i1 %cmp22, label %if.then27, label %lor.lhs.false24

lor.lhs.false24:                                  ; preds = %if.end17
  %33 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %state_reg, align 8
  %precise25 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %33, i32 0, i32 18
  %34 = load i8, i8* %precise25, align 4
  %tobool26 = trunc i8 %34 to i1
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %lor.lhs.false24, %if.end17
  br label %for.inc41

if.end28:                                         ; preds = %lor.lhs.false24
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %log29 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 22
  %level30 = getelementptr inbounds %struct.bpf_verifier_log, %struct.bpf_verifier_log* %log29, i32 0, i32 0
  %36 = load i32, i32* %level30, align 8
  %and31 = and i32 %36, 2
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.end28
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %38 = bitcast %struct.bpf_verifier_env* %37 to i8*
  %39 = load i32, i32* %i, align 4
  %sub = sub i32 0, %39
  %sub34 = sub i32 %sub, 1
  %mul = mul i32 %sub34, 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %38, i8* noundef getelementptr inbounds ([18 x i8], [18 x i8]* @.str.120, i64 0, i64 0), i32 noundef %mul) #11
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.end28
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = load i32, i32* %i, align 4
  %call36 = call i32 @mark_chain_precision_stack(%struct.bpf_verifier_env* noundef %40, i32 noundef %41) #11
  store i32 %call36, i32* %err, align 4
  %42 = load i32, i32* %err, align 4
  %cmp37 = icmp slt i32 %42, 0
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end35
  %43 = load i32, i32* %err, align 4
  store i32 %43, i32* %retval, align 4
  br label %return

if.end40:                                         ; preds = %if.end35
  br label %for.inc41

for.inc41:                                        ; preds = %if.end40, %if.then27, %if.then16
  %44 = load i32, i32* %i, align 4
  %inc42 = add i32 %44, 1
  store i32 %inc42, i32* %i, align 4
  br label %for.cond8

for.end43:                                        ; preds = %for.cond8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end43, %if.then39, %if.then6
  %45 = load i32, i32* %retval, align 4
  ret i32 %45
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @mark_chain_precision_stack(%struct.bpf_verifier_env* noundef %env, i32 noundef %spi) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %spi.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %spi, i32* %spi.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %1 = load i32, i32* %spi.addr, align 4
  %call = call i32 @__mark_chain_precision(%struct.bpf_verifier_env* noundef %0, i32 noundef -1, i32 noundef %1) #11
  ret i32 %call
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @krealloc(i8* noundef, i64 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @propagate_liveness_reg(%struct.bpf_verifier_env* noundef %env, %struct.bpf_reg_state* noundef %reg, %struct.bpf_reg_state* noundef %parent_reg) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %reg.addr = alloca %struct.bpf_reg_state*, align 8
  %parent_reg.addr = alloca %struct.bpf_reg_state*, align 8
  %parent_flag = alloca i8, align 1
  %flag = alloca i8, align 1
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_reg_state* %reg, %struct.bpf_reg_state** %reg.addr, align 8
  store %struct.bpf_reg_state* %parent_reg, %struct.bpf_reg_state** %parent_reg.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg.addr, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 17
  %1 = load i32, i32* %live, align 8
  %and = and i32 %1, 3
  %conv = trunc i32 %and to i8
  store i8 %conv, i8* %parent_flag, align 1
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %live1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 17
  %3 = load i32, i32* %live1, align 8
  %and2 = and i32 %3, 3
  %conv3 = trunc i32 %and2 to i8
  store i8 %conv3, i8* %flag, align 1
  %4 = load i8, i8* %parent_flag, align 1
  %conv4 = zext i8 %4 to i32
  %cmp = icmp eq i32 %conv4, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i8, i8* %flag, align 1
  %tobool = icmp ne i8 %5, 0
  br i1 %tobool, label %lor.lhs.false6, label %if.then

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %6 = load i8, i8* %parent_flag, align 1
  %conv7 = zext i8 %6 to i32
  %7 = load i8, i8* %flag, align 1
  %conv8 = zext i8 %7 to i32
  %cmp9 = icmp eq i32 %conv7, %conv8
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false6, %lor.lhs.false, %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false6
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %reg.addr, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %parent_reg.addr, align 8
  %11 = load i8, i8* %flag, align 1
  %call = call i32 @mark_reg_read(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %9, %struct.bpf_reg_state* noundef %10, i8 noundef zeroext %11) #11
  store i32 %call, i32* %err, align 4
  %12 = load i32, i32* %err, align 4
  %tobool11 = icmp ne i32 %12, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  %13 = load i32, i32* %err, align 4
  store i32 %13, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end
  %14 = load i8, i8* %flag, align 1
  %conv14 = zext i8 %14 to i32
  store i32 %conv14, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then12, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @func_states_equal(%struct.bpf_func_state* noundef %old, %struct.bpf_func_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %old.addr = alloca %struct.bpf_func_state*, align 8
  %cur.addr = alloca %struct.bpf_func_state*, align 8
  %idmap = alloca %struct.util_est*, align 8
  %ret = alloca i8, align 1
  %i = alloca i32, align 4
  store %struct.bpf_func_state* %old, %struct.bpf_func_state** %old.addr, align 8
  store %struct.bpf_func_state* %cur, %struct.bpf_func_state** %cur.addr, align 8
  store i8 0, i8* %ret, align 1
  %call = call i8* @kcalloc(i64 noundef 75, i64 noundef 8, i32 noundef 3264) #11
  %0 = bitcast i8* %call to %struct.util_est*
  store %struct.util_est* %0, %struct.util_est** %idmap, align 8
  %1 = load %struct.util_est*, %struct.util_est** %idmap, align 8
  %tobool = icmp ne %struct.util_est* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %2, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %3, i32 0, i32 0
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %5 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %5, i32 0, i32 0
  %6 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 %idxprom2
  %7 = load %struct.util_est*, %struct.util_est** %idmap, align 8
  %call4 = call zeroext i1 @regsafe(%struct.bpf_reg_state* noundef %arrayidx, %struct.bpf_reg_state* noundef %arrayidx3, %struct.util_est* noundef %7) #11
  br i1 %call4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %for.body
  br label %out_free

if.end6:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %8 = load i32, i32* %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %11 = load %struct.util_est*, %struct.util_est** %idmap, align 8
  %call7 = call zeroext i1 @stacksafe(%struct.bpf_func_state* noundef %9, %struct.bpf_func_state* noundef %10, %struct.util_est* noundef %11) #11
  br i1 %call7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %for.end
  br label %out_free

if.end9:                                          ; preds = %for.end
  %12 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %call10 = call zeroext i1 @refsafe(%struct.bpf_func_state* noundef %12, %struct.bpf_func_state* noundef %13) #11
  br i1 %call10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end9
  br label %out_free

if.end12:                                         ; preds = %if.end9
  store i8 1, i8* %ret, align 1
  br label %out_free

out_free:                                         ; preds = %if.end12, %if.then11, %if.then8, %if.then5
  %14 = load %struct.util_est*, %struct.util_est** %idmap, align 8
  %15 = bitcast %struct.util_est* %14 to i8*
  call void @kfree(i8* noundef %15) #11
  %16 = load i8, i8* %ret, align 1
  %tobool13 = trunc i8 %16 to i1
  store i1 %tobool13, i1* %retval, align 1
  br label %return

return:                                           ; preds = %out_free, %if.then
  %17 = load i1, i1* %retval, align 1
  ret i1 %17
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @regsafe(%struct.bpf_reg_state* noundef %rold, %struct.bpf_reg_state* noundef %rcur, %struct.util_est* noundef %idmap) #0 {
entry:
  %retval = alloca i1, align 1
  %rold.addr = alloca %struct.bpf_reg_state*, align 8
  %rcur.addr = alloca %struct.bpf_reg_state*, align 8
  %idmap.addr = alloca %struct.util_est*, align 8
  %equal = alloca i8, align 1
  store %struct.bpf_reg_state* %rold, %struct.bpf_reg_state** %rold.addr, align 8
  store %struct.bpf_reg_state* %rcur, %struct.bpf_reg_state** %rcur.addr, align 8
  store %struct.util_est* %idmap, %struct.util_est** %idmap.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 17
  %1 = load i32, i32* %live, align 8
  %and = and i32 %1, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %3 = bitcast %struct.bpf_reg_state* %2 to i8*
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %5 = bitcast %struct.bpf_reg_state* %4 to i8*
  %call = call i32 @memcmp(i8* noundef %3, i8* noundef %5, i64 noundef 96) #11
  %cmp = icmp eq i32 %call, 0
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %equal, align 1
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 0
  %7 = load i32, i32* %type, align 8
  %cmp1 = icmp eq i32 %7, 6
  br i1 %cmp1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %8 = load i8, i8* %equal, align 1
  %tobool3 = trunc i8 %8 to i1
  br i1 %tobool3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then2
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i32 0, i32 15
  %10 = load i32, i32* %frameno, align 8
  %11 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %frameno4 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %11, i32 0, i32 15
  %12 = load i32, i32* %frameno4, align 8
  %cmp5 = icmp eq i32 %10, %12
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then2
  %13 = phi i1 [ false, %if.then2 ], [ %cmp5, %land.rhs ]
  store i1 %13, i1* %retval, align 1
  br label %return

if.end6:                                          ; preds = %if.end
  %14 = load i8, i8* %equal, align 1
  %tobool7 = trunc i8 %14 to i1
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  store i1 true, i1* %retval, align 1
  br label %return

if.end9:                                          ; preds = %if.end6
  %15 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type10 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %15, i32 0, i32 0
  %16 = load i32, i32* %type10, align 8
  %cmp11 = icmp eq i32 %16, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  store i1 true, i1* %retval, align 1
  br label %return

if.end13:                                         ; preds = %if.end9
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i32 0, i32 0
  %18 = load i32, i32* %type14, align 8
  %cmp15 = icmp eq i32 %18, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  store i1 false, i1* %retval, align 1
  br label %return

if.end17:                                         ; preds = %if.end13
  %19 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type18 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %19, i32 0, i32 0
  %20 = load i32, i32* %type18, align 8
  switch i32 %20, label %sw.default [
    i32 1, label %sw.bb
    i32 4, label %sw.bb32
    i32 5, label %sw.bb42
    i32 7, label %sw.bb53
    i32 8, label %sw.bb53
    i32 2, label %sw.bb86
    i32 3, label %sw.bb86
    i32 9, label %sw.bb86
    i32 10, label %sw.bb86
    i32 11, label %sw.bb86
    i32 12, label %sw.bb86
    i32 13, label %sw.bb86
    i32 14, label %sw.bb86
    i32 15, label %sw.bb86
    i32 16, label %sw.bb86
    i32 18, label %sw.bb86
  ]

sw.bb:                                            ; preds = %if.end17
  %21 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %21, i32 0, i32 0
  %22 = load i32, i32* %type19, align 8
  %cmp20 = icmp eq i32 %22, 1
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %sw.bb
  %23 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %precise = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %23, i32 0, i32 18
  %24 = load i8, i8* %precise, align 4
  %tobool22 = trunc i8 %24 to i1
  br i1 %tobool22, label %if.end26, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then21
  %25 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %precise23 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %25, i32 0, i32 18
  %26 = load i8, i8* %precise23, align 4
  %tobool24 = trunc i8 %26 to i1
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %land.lhs.true
  store i1 true, i1* %retval, align 1
  br label %return

if.end26:                                         ; preds = %land.lhs.true, %if.then21
  %27 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %28 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %call27 = call zeroext i1 @range_within(%struct.bpf_reg_state* noundef %27, %struct.bpf_reg_state* noundef %28) #11
  br i1 %call27, label %land.rhs28, label %land.end31

land.rhs28:                                       ; preds = %if.end26
  %29 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %var_off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %29, i32 0, i32 5
  %30 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %var_off29 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %30, i32 0, i32 5
  %31 = bitcast %struct.tnum* %var_off to { i64, i64 }*
  %32 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = load i64, i64* %32, align 8
  %34 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = load i64, i64* %34, align 8
  %36 = bitcast %struct.tnum* %var_off29 to { i64, i64 }*
  %37 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = load i64, i64* %37, align 8
  %39 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = load i64, i64* %39, align 8
  %call30 = call zeroext i1 @tnum_in(i64 %33, i64 %35, i64 %38, i64 %40) #11
  br label %land.end31

land.end31:                                       ; preds = %land.rhs28, %if.end26
  %41 = phi i1 [ false, %if.end26 ], [ %call30, %land.rhs28 ]
  store i1 %41, i1* %retval, align 1
  br label %return

if.else:                                          ; preds = %sw.bb
  store i1 false, i1* %retval, align 1
  br label %return

sw.bb32:                                          ; preds = %if.end17
  %42 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %43 = bitcast %struct.bpf_reg_state* %42 to i8*
  %44 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %45 = bitcast %struct.bpf_reg_state* %44 to i8*
  %call33 = call i32 @memcmp(i8* noundef %43, i8* noundef %45, i64 noundef 20) #11
  %cmp34 = icmp eq i32 %call33, 0
  br i1 %cmp34, label %land.lhs.true35, label %land.end41

land.lhs.true35:                                  ; preds = %sw.bb32
  %46 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %47 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %call36 = call zeroext i1 @range_within(%struct.bpf_reg_state* noundef %46, %struct.bpf_reg_state* noundef %47) #11
  br i1 %call36, label %land.rhs37, label %land.end41

land.rhs37:                                       ; preds = %land.lhs.true35
  %48 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %var_off38 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %48, i32 0, i32 5
  %49 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %var_off39 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %49, i32 0, i32 5
  %50 = bitcast %struct.tnum* %var_off38 to { i64, i64 }*
  %51 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 0
  %52 = load i64, i64* %51, align 8
  %53 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %50, i32 0, i32 1
  %54 = load i64, i64* %53, align 8
  %55 = bitcast %struct.tnum* %var_off39 to { i64, i64 }*
  %56 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 0
  %57 = load i64, i64* %56, align 8
  %58 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %55, i32 0, i32 1
  %59 = load i64, i64* %58, align 8
  %call40 = call zeroext i1 @tnum_in(i64 %52, i64 %54, i64 %57, i64 %59) #11
  br label %land.end41

land.end41:                                       ; preds = %land.rhs37, %land.lhs.true35, %sw.bb32
  %60 = phi i1 [ false, %land.lhs.true35 ], [ false, %sw.bb32 ], [ %call40, %land.rhs37 ]
  store i1 %60, i1* %retval, align 1
  br label %return

sw.bb42:                                          ; preds = %if.end17
  %61 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type43 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %61, i32 0, i32 0
  %62 = load i32, i32* %type43, align 8
  %cmp44 = icmp ne i32 %62, 5
  br i1 %cmp44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %sw.bb42
  store i1 false, i1* %retval, align 1
  br label %return

if.end46:                                         ; preds = %sw.bb42
  %63 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %64 = bitcast %struct.bpf_reg_state* %63 to i8*
  %65 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %66 = bitcast %struct.bpf_reg_state* %65 to i8*
  %call47 = call i32 @memcmp(i8* noundef %64, i8* noundef %66, i64 noundef 20) #11
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end46
  store i1 false, i1* %retval, align 1
  br label %return

if.end50:                                         ; preds = %if.end46
  %67 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %id = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %67, i32 0, i32 3
  %68 = load i32, i32* %id, align 4
  %69 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %id51 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %69, i32 0, i32 3
  %70 = load i32, i32* %id51, align 4
  %71 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %call52 = call zeroext i1 @check_ids(i32 noundef %68, i32 noundef %70, %struct.util_est* noundef %71) #11
  store i1 %call52, i1* %retval, align 1
  br label %return

sw.bb53:                                          ; preds = %if.end17, %if.end17
  %72 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %type54 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %72, i32 0, i32 0
  %73 = load i32, i32* %type54, align 8
  %74 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %type55 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %74, i32 0, i32 0
  %75 = load i32, i32* %type55, align 8
  %cmp56 = icmp ne i32 %73, %75
  br i1 %cmp56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %sw.bb53
  store i1 false, i1* %retval, align 1
  br label %return

if.end58:                                         ; preds = %sw.bb53
  %76 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %77 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %76, i32 0, i32 1
  %range = bitcast %struct.bpf_iter_aux_info* %77 to i16*
  %78 = load i16, i16* %range, align 8
  %conv = zext i16 %78 to i32
  %79 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %80 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %79, i32 0, i32 1
  %range59 = bitcast %struct.bpf_iter_aux_info* %80 to i16*
  %81 = load i16, i16* %range59, align 8
  %conv60 = zext i16 %81 to i32
  %cmp61 = icmp sgt i32 %conv, %conv60
  br i1 %cmp61, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.end58
  store i1 false, i1* %retval, align 1
  br label %return

if.end64:                                         ; preds = %if.end58
  %82 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %off = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %82, i32 0, i32 2
  %83 = load i32, i32* %off, align 8
  %84 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %off65 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %84, i32 0, i32 2
  %85 = load i32, i32* %off65, align 8
  %cmp66 = icmp ne i32 %83, %85
  br i1 %cmp66, label %if.then68, label %if.end69

if.then68:                                        ; preds = %if.end64
  store i1 false, i1* %retval, align 1
  br label %return

if.end69:                                         ; preds = %if.end64
  %86 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %id70 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %86, i32 0, i32 3
  %87 = load i32, i32* %id70, align 4
  %tobool71 = icmp ne i32 %87, 0
  br i1 %tobool71, label %land.lhs.true72, label %if.end77

land.lhs.true72:                                  ; preds = %if.end69
  %88 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %id73 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %88, i32 0, i32 3
  %89 = load i32, i32* %id73, align 4
  %90 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %id74 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %90, i32 0, i32 3
  %91 = load i32, i32* %id74, align 4
  %92 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %call75 = call zeroext i1 @check_ids(i32 noundef %89, i32 noundef %91, %struct.util_est* noundef %92) #11
  br i1 %call75, label %if.end77, label %if.then76

if.then76:                                        ; preds = %land.lhs.true72
  store i1 false, i1* %retval, align 1
  br label %return

if.end77:                                         ; preds = %land.lhs.true72, %if.end69
  %93 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %94 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %call78 = call zeroext i1 @range_within(%struct.bpf_reg_state* noundef %93, %struct.bpf_reg_state* noundef %94) #11
  br i1 %call78, label %land.rhs80, label %land.end85

land.rhs80:                                       ; preds = %if.end77
  %95 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rold.addr, align 8
  %var_off81 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %95, i32 0, i32 5
  %96 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %rcur.addr, align 8
  %var_off82 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %96, i32 0, i32 5
  %97 = bitcast %struct.tnum* %var_off81 to { i64, i64 }*
  %98 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %97, i32 0, i32 0
  %99 = load i64, i64* %98, align 8
  %100 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %97, i32 0, i32 1
  %101 = load i64, i64* %100, align 8
  %102 = bitcast %struct.tnum* %var_off82 to { i64, i64 }*
  %103 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %102, i32 0, i32 0
  %104 = load i64, i64* %103, align 8
  %105 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %102, i32 0, i32 1
  %106 = load i64, i64* %105, align 8
  %call83 = call zeroext i1 @tnum_in(i64 %99, i64 %101, i64 %104, i64 %106) #11
  br label %land.end85

land.end85:                                       ; preds = %land.rhs80, %if.end77
  %107 = phi i1 [ false, %if.end77 ], [ %call83, %land.rhs80 ]
  store i1 %107, i1* %retval, align 1
  br label %return

sw.bb86:                                          ; preds = %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17, %if.end17
  br label %sw.default

sw.default:                                       ; preds = %sw.bb86, %if.end17
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %land.end85, %if.then76, %if.then68, %if.then63, %if.then57, %if.end50, %if.then49, %if.then45, %land.end41, %if.else, %land.end31, %if.then25, %if.then16, %if.then12, %if.then8, %land.end, %if.then
  %108 = load i1, i1* %retval, align 1
  ret i1 %108
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @stacksafe(%struct.bpf_func_state* noundef %old, %struct.bpf_func_state* noundef %cur, %struct.util_est* noundef %idmap) #0 {
entry:
  %retval = alloca i1, align 1
  %old.addr = alloca %struct.bpf_func_state*, align 8
  %cur.addr = alloca %struct.bpf_func_state*, align 8
  %idmap.addr = alloca %struct.util_est*, align 8
  %i = alloca i32, align 4
  %spi = alloca i32, align 4
  store %struct.bpf_func_state* %old, %struct.bpf_func_state** %old.addr, align 8
  store %struct.bpf_func_state* %cur, %struct.bpf_func_state** %cur.addr, align 8
  store %struct.util_est* %idmap, %struct.util_est** %idmap.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 6
  %2 = load i32, i32* %allocated_stack, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, i32* %i, align 4
  %div = sdiv i32 %3, 8
  store i32 %div, i32* %spi, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 7
  %5 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %6 = load i32, i32* %spi, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %5, i64 %idxprom
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx, i32 0, i32 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 17
  %7 = load i32, i32* %live, align 8
  %and = and i32 %7, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %add = add i32 %8, 7
  store i32 %add, i32* %i, align 4
  br label %for.inc

if.end:                                           ; preds = %for.body
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 7
  %10 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack1, align 8
  %11 = load i32, i32* %spi, align 4
  %idxprom2 = sext i32 %11 to i64
  %arrayidx3 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %10, i64 %idxprom2
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx3, i32 0, i32 1
  %12 = load i32, i32* %i, align 4
  %rem = srem i32 %12, 8
  %idxprom4 = sext i32 %rem to i64
  %arrayidx5 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom4
  %13 = load i8, i8* %arrayidx5, align 1
  %conv = zext i8 %13 to i32
  %cmp6 = icmp eq i32 %conv, 0
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  br label %for.inc

if.end9:                                          ; preds = %if.end
  %14 = load i32, i32* %i, align 4
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %allocated_stack10 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 6
  %16 = load i32, i32* %allocated_stack10, align 8
  %cmp11 = icmp sge i32 %14, %16
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  store i1 false, i1* %retval, align 1
  br label %return

if.end14:                                         ; preds = %if.end9
  %17 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %17, i32 0, i32 7
  %18 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack15, align 8
  %19 = load i32, i32* %spi, align 4
  %idxprom16 = sext i32 %19 to i64
  %arrayidx17 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %18, i64 %idxprom16
  %slot_type18 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx17, i32 0, i32 1
  %20 = load i32, i32* %i, align 4
  %rem19 = srem i32 %20, 8
  %idxprom20 = sext i32 %rem19 to i64
  %arrayidx21 = getelementptr [8 x i8], [8 x i8]* %slot_type18, i64 0, i64 %idxprom20
  %21 = load i8, i8* %arrayidx21, align 1
  %conv22 = zext i8 %21 to i32
  %cmp23 = icmp eq i32 %conv22, 2
  br i1 %cmp23, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %if.end14
  %22 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %stack25 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %22, i32 0, i32 7
  %23 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack25, align 8
  %24 = load i32, i32* %spi, align 4
  %idxprom26 = sext i32 %24 to i64
  %arrayidx27 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %23, i64 %idxprom26
  %slot_type28 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx27, i32 0, i32 1
  %25 = load i32, i32* %i, align 4
  %rem29 = srem i32 %25, 8
  %idxprom30 = sext i32 %rem29 to i64
  %arrayidx31 = getelementptr [8 x i8], [8 x i8]* %slot_type28, i64 0, i64 %idxprom30
  %26 = load i8, i8* %arrayidx31, align 1
  %conv32 = zext i8 %26 to i32
  %cmp33 = icmp eq i32 %conv32, 3
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %land.lhs.true
  br label %for.inc

if.end36:                                         ; preds = %land.lhs.true, %if.end14
  %27 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack37 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %27, i32 0, i32 7
  %28 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack37, align 8
  %29 = load i32, i32* %spi, align 4
  %idxprom38 = sext i32 %29 to i64
  %arrayidx39 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %28, i64 %idxprom38
  %slot_type40 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx39, i32 0, i32 1
  %30 = load i32, i32* %i, align 4
  %rem41 = srem i32 %30, 8
  %idxprom42 = sext i32 %rem41 to i64
  %arrayidx43 = getelementptr [8 x i8], [8 x i8]* %slot_type40, i64 0, i64 %idxprom42
  %31 = load i8, i8* %arrayidx43, align 1
  %conv44 = zext i8 %31 to i32
  %32 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %stack45 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %32, i32 0, i32 7
  %33 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack45, align 8
  %34 = load i32, i32* %spi, align 4
  %idxprom46 = sext i32 %34 to i64
  %arrayidx47 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %33, i64 %idxprom46
  %slot_type48 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx47, i32 0, i32 1
  %35 = load i32, i32* %i, align 4
  %rem49 = srem i32 %35, 8
  %idxprom50 = sext i32 %rem49 to i64
  %arrayidx51 = getelementptr [8 x i8], [8 x i8]* %slot_type48, i64 0, i64 %idxprom50
  %36 = load i8, i8* %arrayidx51, align 1
  %conv52 = zext i8 %36 to i32
  %cmp53 = icmp ne i32 %conv44, %conv52
  br i1 %cmp53, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end36
  store i1 false, i1* %retval, align 1
  br label %return

if.end56:                                         ; preds = %if.end36
  %37 = load i32, i32* %i, align 4
  %rem57 = srem i32 %37, 8
  %tobool58 = icmp ne i32 %rem57, 0
  br i1 %tobool58, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.end56
  br label %for.inc

if.end60:                                         ; preds = %if.end56
  %38 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack61 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %38, i32 0, i32 7
  %39 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack61, align 8
  %40 = load i32, i32* %spi, align 4
  %idxprom62 = sext i32 %40 to i64
  %arrayidx63 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %39, i64 %idxprom62
  %slot_type64 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx63, i32 0, i32 1
  %arrayidx65 = getelementptr [8 x i8], [8 x i8]* %slot_type64, i64 0, i64 0
  %41 = load i8, i8* %arrayidx65, align 8
  %conv66 = zext i8 %41 to i32
  %cmp67 = icmp ne i32 %conv66, 1
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.end60
  br label %for.inc

if.end70:                                         ; preds = %if.end60
  %42 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %stack71 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %42, i32 0, i32 7
  %43 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack71, align 8
  %44 = load i32, i32* %spi, align 4
  %idxprom72 = sext i32 %44 to i64
  %arrayidx73 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %43, i64 %idxprom72
  %spilled_ptr74 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx73, i32 0, i32 0
  %45 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %stack75 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %45, i32 0, i32 7
  %46 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack75, align 8
  %47 = load i32, i32* %spi, align 4
  %idxprom76 = sext i32 %47 to i64
  %arrayidx77 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %46, i64 %idxprom76
  %spilled_ptr78 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx77, i32 0, i32 0
  %48 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %call = call zeroext i1 @regsafe(%struct.bpf_reg_state* noundef %spilled_ptr74, %struct.bpf_reg_state* noundef %spilled_ptr78, %struct.util_est* noundef %48) #11
  br i1 %call, label %if.end80, label %if.then79

if.then79:                                        ; preds = %if.end70
  store i1 false, i1* %retval, align 1
  br label %return

if.end80:                                         ; preds = %if.end70
  br label %for.inc

for.inc:                                          ; preds = %if.end80, %if.then69, %if.then59, %if.then35, %if.then8, %if.then
  %49 = load i32, i32* %i, align 4
  %inc = add i32 %49, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then79, %if.then55, %if.then13
  %50 = load i1, i1* %retval, align 1
  ret i1 %50
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @refsafe(%struct.bpf_func_state* noundef %old, %struct.bpf_func_state* noundef %cur) #0 {
entry:
  %retval = alloca i1, align 1
  %old.addr = alloca %struct.bpf_func_state*, align 8
  %cur.addr = alloca %struct.bpf_func_state*, align 8
  store %struct.bpf_func_state* %old, %struct.bpf_func_state** %old.addr, align 8
  store %struct.bpf_func_state* %cur, %struct.bpf_func_state** %cur.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %acquired_refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 4
  %1 = load i32, i32* %acquired_refs, align 4
  %2 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %acquired_refs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %2, i32 0, i32 4
  %3 = load i32, i32* %acquired_refs1, align 4
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %refs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 5
  %5 = load %struct.util_est*, %struct.util_est** %refs, align 8
  %6 = bitcast %struct.util_est* %5 to i8*
  %7 = load %struct.bpf_func_state*, %struct.bpf_func_state** %cur.addr, align 8
  %refs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %7, i32 0, i32 5
  %8 = load %struct.util_est*, %struct.util_est** %refs2, align 8
  %9 = bitcast %struct.util_est* %8 to i8*
  %10 = load %struct.bpf_func_state*, %struct.bpf_func_state** %old.addr, align 8
  %acquired_refs3 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %10, i32 0, i32 4
  %11 = load i32, i32* %acquired_refs3, align 4
  %conv = sext i32 %11 to i64
  %mul = mul i64 8, %conv
  %call = call i32 @memcmp(i8* noundef %6, i8* noundef %9, i64 noundef %mul) #11
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  store i1 %lnot, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i1, i1* %retval, align 1
  ret i1 %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @range_within(%struct.bpf_reg_state* noundef %old, %struct.bpf_reg_state* noundef %cur) #0 {
entry:
  %old.addr = alloca %struct.bpf_reg_state*, align 8
  %cur.addr = alloca %struct.bpf_reg_state*, align 8
  store %struct.bpf_reg_state* %old, %struct.bpf_reg_state** %old.addr, align 8
  store %struct.bpf_reg_state* %cur, %struct.bpf_reg_state** %cur.addr, align 8
  %0 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %umin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %0, i32 0, i32 8
  %1 = load i64, i64* %umin_value, align 8
  %2 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %umin_value1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %2, i32 0, i32 8
  %3 = load i64, i64* %umin_value1, align 8
  %cmp = icmp ule i64 %1, %3
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %4 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %umax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %4, i32 0, i32 9
  %5 = load i64, i64* %umax_value, align 8
  %6 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %umax_value2 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %6, i32 0, i32 9
  %7 = load i64, i64* %umax_value2, align 8
  %cmp3 = icmp uge i64 %5, %7
  br i1 %cmp3, label %land.lhs.true4, label %land.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %8 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %smin_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %8, i32 0, i32 6
  %9 = load i64, i64* %smin_value, align 8
  %10 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %smin_value5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %10, i32 0, i32 6
  %11 = load i64, i64* %smin_value5, align 8
  %cmp6 = icmp sle i64 %9, %11
  br i1 %cmp6, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true4
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %old.addr, align 8
  %smax_value = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i32 0, i32 7
  %13 = load i64, i64* %smax_value, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %cur.addr, align 8
  %smax_value7 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %14, i32 0, i32 7
  %15 = load i64, i64* %smax_value7, align 8
  %cmp8 = icmp sge i64 %13, %15
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true4, %land.lhs.true, %entry
  %16 = phi i1 [ false, %land.lhs.true4 ], [ false, %land.lhs.true ], [ false, %entry ], [ %cmp8, %land.rhs ]
  ret i1 %16
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @check_ids(i32 noundef %old_id, i32 noundef %cur_id, %struct.util_est* noundef %idmap) #0 {
entry:
  %retval = alloca i1, align 1
  %old_id.addr = alloca i32, align 4
  %cur_id.addr = alloca i32, align 4
  %idmap.addr = alloca %struct.util_est*, align 8
  %i = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  store i32 %old_id, i32* %old_id.addr, align 4
  store i32 %cur_id, i32* %cur_id.addr, align 4
  store %struct.util_est* %idmap, %struct.util_est** %idmap.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp ult i32 %0, 75
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %2 = load i32, i32* %i, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %1, i64 %idxprom
  %old = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx, i32 0, i32 0
  %3 = load i32, i32* %old, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %4 = load i32, i32* %old_id.addr, align 4
  %5 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom1 = zext i32 %6 to i64
  %arrayidx2 = getelementptr %struct.util_est, %struct.util_est* %5, i64 %idxprom1
  %old3 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx2, i32 0, i32 0
  store i32 %4, i32* %old3, align 4
  %7 = load i32, i32* %cur_id.addr, align 4
  %8 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %9 = load i32, i32* %i, align 4
  %idxprom4 = zext i32 %9 to i64
  %arrayidx5 = getelementptr %struct.util_est, %struct.util_est* %8, i64 %idxprom4
  %cur = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx5, i32 0, i32 1
  store i32 %7, i32* %cur, align 4
  store i1 true, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  %10 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %11 = load i32, i32* %i, align 4
  %idxprom6 = zext i32 %11 to i64
  %arrayidx7 = getelementptr %struct.util_est, %struct.util_est* %10, i64 %idxprom6
  %old8 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx7, i32 0, i32 0
  %12 = load i32, i32* %old8, align 4
  %13 = load i32, i32* %old_id.addr, align 4
  %cmp9 = icmp eq i32 %12, %13
  br i1 %cmp9, label %if.then10, label %if.end15

if.then10:                                        ; preds = %if.end
  %14 = load %struct.util_est*, %struct.util_est** %idmap.addr, align 8
  %15 = load i32, i32* %i, align 4
  %idxprom11 = zext i32 %15 to i64
  %arrayidx12 = getelementptr %struct.util_est, %struct.util_est* %14, i64 %idxprom11
  %cur13 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx12, i32 0, i32 1
  %16 = load i32, i32* %cur13, align 4
  %17 = load i32, i32* %cur_id.addr, align 4
  %cmp14 = icmp eq i32 %16, %17
  store i1 %cmp14, i1* %retval, align 1
  br label %return

if.end15:                                         ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end15
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 1, i32* %__ret_warn_on, align 4
  %19 = load i32, i32* %__ret_warn_on, align 4
  %tobool16 = icmp ne i32 %19, 0
  %lnot = xor i1 %tobool16, true
  %lnot17 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot17 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool18 = icmp ne i64 %conv, 0
  br i1 %tobool18, label %if.then19, label %if.end26

if.then19:                                        ; preds = %for.end
  br label %do.body

do.body:                                          ; preds = %if.then19
  br label %do.body20

do.body20:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body20
  br label %do.body21

do.body21:                                        ; preds = %do.end
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 10445, i32 2307, i64 12) #10, !srcloc !70
  br label %do.end22

do.end22:                                         ; preds = %do.body21
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 489) #10, !srcloc !71
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  br label %do.end24

do.end24:                                         ; preds = %do.body23
  br label %do.end25

do.end25:                                         ; preds = %do.end24
  br label %if.end26

if.end26:                                         ; preds = %do.end25, %for.end
  %20 = load i32, i32* %__ret_warn_on, align 4
  %tobool27 = icmp ne i32 %20, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  store i64 %conv32, i64* %tmp, align 8
  %21 = load i64, i64* %tmp, align 8
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end26, %if.then10, %if.then
  %22 = load i1, i1* %retval, align 1
  ret i1 %22
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clean_verifier_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_verifier_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_verifier_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_verifier_state* %st, %struct.bpf_verifier_state** %st.addr, align 8
  %0 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %frame = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %0, i32 0, i32 0
  %arrayidx = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame, i64 0, i64 0
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %arrayidx1 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 0
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx1, i32 0, i32 17
  %2 = load i32, i32* %live, align 8
  %and = and i32 %2, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %i, align 4
  %4 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %curframe = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %4, i32 0, i32 4
  %5 = load i32, i32* %curframe, align 8
  %cmp = icmp ule i32 %3, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = load %struct.bpf_verifier_state*, %struct.bpf_verifier_state** %st.addr, align 8
  %frame2 = getelementptr inbounds %struct.bpf_verifier_state, %struct.bpf_verifier_state* %7, i32 0, i32 0
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx3 = getelementptr [8 x %struct.bpf_func_state*], [8 x %struct.bpf_func_state*]* %frame2, i64 0, i64 %idxprom
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %arrayidx3, align 8
  call void @clean_func_state(%struct.bpf_verifier_env* noundef %6, %struct.bpf_func_state* noundef %9) #11
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @clean_func_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %st) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %st.addr = alloca %struct.bpf_func_state*, align 8
  %live = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %st, %struct.bpf_func_state** %st.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %regs = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %1, i32 0, i32 0
  %2 = load i32, i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs, i64 0, i64 %idxprom
  %live1 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 17
  %3 = load i32, i32* %live1, align 8
  store i32 %3, i32* %live, align 4
  %4 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %regs2 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %4, i32 0, i32 0
  %5 = load i32, i32* %i, align 4
  %idxprom3 = sext i32 %5 to i64
  %arrayidx4 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs2, i64 0, i64 %idxprom3
  %live5 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx4, i32 0, i32 17
  %6 = load i32, i32* %live5, align 8
  %or = or i32 %6, 8
  store i32 %or, i32* %live5, align 8
  %7 = load i32, i32* %live, align 4
  %and = and i32 %7, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %regs6 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %9, i32 0, i32 0
  %10 = load i32, i32* %i, align 4
  %idxprom7 = sext i32 %10 to i64
  %arrayidx8 = getelementptr [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs6, i64 0, i64 %idxprom7
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %8, %struct.bpf_reg_state* noundef %arrayidx8) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %11 = load i32, i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc40, %for.end
  %12 = load i32, i32* %i, align 4
  %13 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %allocated_stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %13, i32 0, i32 6
  %14 = load i32, i32* %allocated_stack, align 8
  %div = sdiv i32 %14, 8
  %cmp10 = icmp slt i32 %12, %div
  br i1 %cmp10, label %for.body11, label %for.end42

for.body11:                                       ; preds = %for.cond9
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 7
  %16 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack, align 8
  %17 = load i32, i32* %i, align 4
  %idxprom12 = sext i32 %17 to i64
  %arrayidx13 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %16, i64 %idxprom12
  %spilled_ptr = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx13, i32 0, i32 0
  %live14 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr, i32 0, i32 17
  %18 = load i32, i32* %live14, align 8
  store i32 %18, i32* %live, align 4
  %19 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack15 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %19, i32 0, i32 7
  %20 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack15, align 8
  %21 = load i32, i32* %i, align 4
  %idxprom16 = sext i32 %21 to i64
  %arrayidx17 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %20, i64 %idxprom16
  %spilled_ptr18 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx17, i32 0, i32 0
  %live19 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %spilled_ptr18, i32 0, i32 17
  %22 = load i32, i32* %live19, align 8
  %or20 = or i32 %22, 8
  store i32 %or20, i32* %live19, align 8
  %23 = load i32, i32* %live, align 4
  %and21 = and i32 %23, 3
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.end39, label %if.then23

if.then23:                                        ; preds = %for.body11
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack24 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %25, i32 0, i32 7
  %26 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack24, align 8
  %27 = load i32, i32* %i, align 4
  %idxprom25 = sext i32 %27 to i64
  %arrayidx26 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %26, i64 %idxprom25
  %spilled_ptr27 = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx26, i32 0, i32 0
  call void @__mark_reg_not_init(%struct.bpf_verifier_env* noundef %24, %struct.bpf_reg_state* noundef %spilled_ptr27) #11
  store i32 0, i32* %j, align 4
  br label %for.cond28

for.cond28:                                       ; preds = %for.inc36, %if.then23
  %28 = load i32, i32* %j, align 4
  %cmp29 = icmp slt i32 %28, 8
  br i1 %cmp29, label %for.body30, label %for.end38

for.body30:                                       ; preds = %for.cond28
  %29 = load %struct.bpf_func_state*, %struct.bpf_func_state** %st.addr, align 8
  %stack31 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %29, i32 0, i32 7
  %30 = load %struct.bpf_stack_state*, %struct.bpf_stack_state** %stack31, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom32 = sext i32 %31 to i64
  %arrayidx33 = getelementptr %struct.bpf_stack_state, %struct.bpf_stack_state* %30, i64 %idxprom32
  %slot_type = getelementptr inbounds %struct.bpf_stack_state, %struct.bpf_stack_state* %arrayidx33, i32 0, i32 1
  %32 = load i32, i32* %j, align 4
  %idxprom34 = sext i32 %32 to i64
  %arrayidx35 = getelementptr [8 x i8], [8 x i8]* %slot_type, i64 0, i64 %idxprom34
  store i8 0, i8* %arrayidx35, align 1
  br label %for.inc36

for.inc36:                                        ; preds = %for.body30
  %33 = load i32, i32* %j, align 4
  %inc37 = add i32 %33, 1
  store i32 %inc37, i32* %j, align 4
  br label %for.cond28

for.end38:                                        ; preds = %for.cond28
  br label %if.end39

if.end39:                                         ; preds = %for.end38, %for.body11
  br label %for.inc40

for.inc40:                                        ; preds = %if.end39
  %34 = load i32, i32* %i, align 4
  %inc41 = add i32 %34, 1
  store i32 %inc41, i32* %i, align 4
  br label %for.cond9

for.end42:                                        ; preds = %for.cond9
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @init_reg_state(%struct.bpf_verifier_env* noundef %env, %struct.bpf_func_state* noundef %state) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %state.addr = alloca %struct.bpf_func_state*, align 8
  %regs = alloca %struct.bpf_reg_state*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_func_state* %state, %struct.bpf_func_state** %state.addr, align 8
  %0 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %regs1 = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [11 x %struct.bpf_reg_state], [11 x %struct.bpf_reg_state]* %regs1, i64 0, i64 0
  store %struct.bpf_reg_state* %arraydecay, %struct.bpf_reg_state** %regs, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %3 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %4 = load i32, i32* %i, align 4
  call void @mark_reg_not_init(%struct.bpf_verifier_env* noundef %2, %struct.bpf_reg_state* noundef %3, i32 noundef %4) #11
  %5 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %6 = load i32, i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %5, i64 %idxprom
  %live = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx, i32 0, i32 17
  store i32 0, i32* %live, align 8
  %7 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %8 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %8 to i64
  %arrayidx3 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %7, i64 %idxprom2
  %parent = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx3, i32 0, i32 14
  store %struct.bpf_reg_state* null, %struct.bpf_reg_state** %parent, align 8
  %9 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %10 = load i32, i32* %i, align 4
  %idxprom4 = sext i32 %10 to i64
  %arrayidx5 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %9, i64 %idxprom4
  %subreg_def = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx5, i32 0, i32 16
  store i32 0, i32* %subreg_def, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx6 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %12, i64 10
  %type = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx6, i32 0, i32 0
  store i32 6, i32* %type, align 8
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  call void @mark_reg_known_zero(%struct.bpf_verifier_env* noundef %13, %struct.bpf_reg_state* noundef %14, i32 noundef 10) #11
  %15 = load %struct.bpf_func_state*, %struct.bpf_func_state** %state.addr, align 8
  %frameno = getelementptr inbounds %struct.bpf_func_state, %struct.bpf_func_state* %15, i32 0, i32 2
  %16 = load i32, i32* %frameno, align 4
  %17 = load %struct.bpf_reg_state*, %struct.bpf_reg_state** %regs, align 8
  %arrayidx7 = getelementptr %struct.bpf_reg_state, %struct.bpf_reg_state* %17, i64 10
  %frameno8 = getelementptr inbounds %struct.bpf_reg_state, %struct.bpf_reg_state* %arrayidx7, i32 0, i32 15
  store i32 %16, i32* %frameno8, align 8
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @push_insn(i32 noundef %t, i32 noundef %w, i32 noundef %e, %struct.bpf_verifier_env* noundef %env, i1 noundef zeroext %loop_ok) #0 {
entry:
  %retval = alloca i32, align 4
  %t.addr = alloca i32, align 4
  %w.addr = alloca i32, align 4
  %e.addr = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %loop_ok.addr = alloca i8, align 1
  %insn_stack = alloca i32*, align 8
  %insn_state = alloca i32*, align 8
  store i32 %t, i32* %t.addr, align 4
  store i32 %w, i32* %w.addr, align 4
  store i32 %e, i32* %e.addr, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %frombool = zext i1 %loop_ok to i8
  store i8 %frombool, i8* %loop_ok.addr, align 1
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 24
  %insn_stack1 = getelementptr inbounds %struct.anon.178, %struct.anon.178* %cfg, i32 0, i32 1
  %1 = load i32*, i32** %insn_stack1, align 8
  store i32* %1, i32** %insn_stack, align 8
  %2 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg2 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %2, i32 0, i32 24
  %insn_state3 = getelementptr inbounds %struct.anon.178, %struct.anon.178* %cfg2, i32 0, i32 0
  %3 = load i32*, i32** %insn_state3, align 8
  store i32* %3, i32** %insn_state, align 8
  %4 = load i32, i32* %e.addr, align 4
  %cmp = icmp eq i32 %4, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load i32*, i32** %insn_state, align 8
  %6 = load i32, i32* %t.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr i32, i32* %5, i64 %idxprom
  %7 = load i32, i32* %arrayidx, align 4
  %cmp4 = icmp sge i32 %7, 17
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %8 = load i32, i32* %e.addr, align 4
  %cmp5 = icmp eq i32 %8, 2
  br i1 %cmp5, label %land.lhs.true6, label %if.end11

land.lhs.true6:                                   ; preds = %if.end
  %9 = load i32*, i32** %insn_state, align 8
  %10 = load i32, i32* %t.addr, align 4
  %idxprom7 = sext i32 %10 to i64
  %arrayidx8 = getelementptr i32, i32* %9, i64 %idxprom7
  %11 = load i32, i32* %arrayidx8, align 4
  %cmp9 = icmp sge i32 %11, 18
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %land.lhs.true6
  store i32 0, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %land.lhs.true6, %if.end
  %12 = load i32, i32* %w.addr, align 4
  %cmp12 = icmp slt i32 %12, 0
  br i1 %cmp12, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end11
  %13 = load i32, i32* %w.addr, align 4
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %14, i32 0, i32 2
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %15, i32 0, i32 4
  %16 = load i32, i32* %len, align 4
  %cmp13 = icmp uge i32 %13, %16
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %lor.lhs.false, %if.end11
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %18 = load i32, i32* %t.addr, align 4
  %19 = load i32, i32* %t.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %17, i32 noundef %18, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.86, i64 0, i64 0), i32 noundef %19) #11
  %20 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %21 = bitcast %struct.bpf_verifier_env* %20 to i8*
  %22 = load i32, i32* %t.addr, align 4
  %23 = load i32, i32* %w.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %21, i8* noundef getelementptr inbounds ([38 x i8], [38 x i8]* @.str.33, i64 0, i64 0), i32 noundef %22, i32 noundef %23) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end15:                                         ; preds = %lor.lhs.false
  %24 = load i32, i32* %e.addr, align 4
  %cmp16 = icmp eq i32 %24, 2
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end15
  %25 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %26 = load i32, i32* %w.addr, align 4
  call void @init_explored_state(%struct.bpf_verifier_env* noundef %25, i32 noundef %26) #11
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end15
  %27 = load i32*, i32** %insn_state, align 8
  %28 = load i32, i32* %w.addr, align 4
  %idxprom19 = sext i32 %28 to i64
  %arrayidx20 = getelementptr i32, i32* %27, i64 %idxprom19
  %29 = load i32, i32* %arrayidx20, align 4
  %cmp21 = icmp eq i32 %29, 0
  br i1 %cmp21, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.end18
  %30 = load i32, i32* %e.addr, align 4
  %or = or i32 16, %30
  %31 = load i32*, i32** %insn_state, align 8
  %32 = load i32, i32* %t.addr, align 4
  %idxprom23 = sext i32 %32 to i64
  %arrayidx24 = getelementptr i32, i32* %31, i64 %idxprom23
  store i32 %or, i32* %arrayidx24, align 4
  %33 = load i32*, i32** %insn_state, align 8
  %34 = load i32, i32* %w.addr, align 4
  %idxprom25 = sext i32 %34 to i64
  %arrayidx26 = getelementptr i32, i32* %33, i64 %idxprom25
  store i32 16, i32* %arrayidx26, align 4
  %35 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg27 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %35, i32 0, i32 24
  %cur_stack = getelementptr inbounds %struct.anon.178, %struct.anon.178* %cfg27, i32 0, i32 2
  %36 = load i32, i32* %cur_stack, align 8
  %37 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog28 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %37, i32 0, i32 2
  %38 = load %struct.bpf_prog*, %struct.bpf_prog** %prog28, align 8
  %len29 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %38, i32 0, i32 4
  %39 = load i32, i32* %len29, align 4
  %cmp30 = icmp uge i32 %36, %39
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.then22
  store i32 -7, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.then22
  %40 = load i32, i32* %w.addr, align 4
  %41 = load i32*, i32** %insn_stack, align 8
  %42 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %cfg33 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %42, i32 0, i32 24
  %cur_stack34 = getelementptr inbounds %struct.anon.178, %struct.anon.178* %cfg33, i32 0, i32 2
  %43 = load i32, i32* %cur_stack34, align 8
  %inc = add i32 %43, 1
  store i32 %inc, i32* %cur_stack34, align 8
  %idxprom35 = sext i32 %43 to i64
  %arrayidx36 = getelementptr i32, i32* %41, i64 %idxprom35
  store i32 %40, i32* %arrayidx36, align 4
  store i32 1, i32* %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end18
  %44 = load i32*, i32** %insn_state, align 8
  %45 = load i32, i32* %w.addr, align 4
  %idxprom37 = sext i32 %45 to i64
  %arrayidx38 = getelementptr i32, i32* %44, i64 %idxprom37
  %46 = load i32, i32* %arrayidx38, align 4
  %and = and i32 %46, 240
  %cmp39 = icmp eq i32 %and, 16
  br i1 %cmp39, label %if.then40, label %if.else45

if.then40:                                        ; preds = %if.else
  %47 = load i8, i8* %loop_ok.addr, align 1
  %tobool = trunc i8 %47 to i1
  br i1 %tobool, label %land.lhs.true41, label %if.end44

land.lhs.true41:                                  ; preds = %if.then40
  %48 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %bpf_capable = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %48, i32 0, i32 16
  %49 = load i8, i8* %bpf_capable, align 2
  %tobool42 = trunc i8 %49 to i1
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %land.lhs.true41
  store i32 0, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %land.lhs.true41, %if.then40
  %50 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %51 = load i32, i32* %t.addr, align 4
  %52 = load i32, i32* %t.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %50, i32 noundef %51, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.86, i64 0, i64 0), i32 noundef %52) #11
  %53 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %54 = load i32, i32* %w.addr, align 4
  %55 = load i32, i32* %w.addr, align 4
  call void (%struct.bpf_verifier_env*, i32, i8*, ...) @verbose_linfo(%struct.bpf_verifier_env* noundef %53, i32 noundef %54, i8* noundef getelementptr inbounds ([5 x i8], [5 x i8]* @.str.86, i64 0, i64 0), i32 noundef %55) #11
  %56 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %57 = bitcast %struct.bpf_verifier_env* %56 to i8*
  %58 = load i32, i32* %t.addr, align 4
  %59 = load i32, i32* %w.addr, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %57, i8* noundef getelementptr inbounds ([30 x i8], [30 x i8]* @.str.87, i64 0, i64 0), i32 noundef %58, i32 noundef %59) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.else45:                                        ; preds = %if.else
  %60 = load i32*, i32** %insn_state, align 8
  %61 = load i32, i32* %w.addr, align 4
  %idxprom46 = sext i32 %61 to i64
  %arrayidx47 = getelementptr i32, i32* %60, i64 %idxprom46
  %62 = load i32, i32* %arrayidx47, align 4
  %cmp48 = icmp eq i32 %62, 32
  br i1 %cmp48, label %if.then49, label %if.else53

if.then49:                                        ; preds = %if.else45
  %63 = load i32, i32* %e.addr, align 4
  %or50 = or i32 16, %63
  %64 = load i32*, i32** %insn_state, align 8
  %65 = load i32, i32* %t.addr, align 4
  %idxprom51 = sext i32 %65 to i64
  %arrayidx52 = getelementptr i32, i32* %64, i64 %idxprom51
  store i32 %or50, i32* %arrayidx52, align 4
  br label %if.end54

if.else53:                                        ; preds = %if.else45
  %66 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %67 = bitcast %struct.bpf_verifier_env* %66 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %67, i8* noundef getelementptr inbounds ([25 x i8], [25 x i8]* @.str.88, i64 0, i64 0)) #11
  store i32 -14, i32* %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.then49
  br label %if.end55

if.end55:                                         ; preds = %if.end54
  br label %if.end56

if.end56:                                         ; preds = %if.end55
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end56, %if.else53, %if.end44, %if.then43, %if.end32, %if.then31, %if.then14, %if.then10, %if.then
  %68 = load i32, i32* %retval, align 4
  ret i32 %68
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @init_explored_state(%struct.bpf_verifier_env* noundef %env, i32 noundef %idx) #0 {
entry:
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %idx.addr = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %idx, i32* %idx.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %insn_aux_data = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 20
  %1 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %insn_aux_data, align 8
  %2 = load i32, i32* %idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %1, i64 %idxprom
  %prune_point = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %arrayidx, i32 0, i32 8
  store i8 1, i8* %prune_point, align 4
  ret void
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_pseudo_btf_id(%struct.bpf_verifier_env* noundef %env, %struct.bpf_insn* noundef %insn, %struct.bpf_insn_aux_data* noundef %aux) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %insn.addr = alloca %struct.bpf_insn*, align 8
  %aux.addr = alloca %struct.bpf_insn_aux_data*, align 8
  %vsi = alloca %struct.bpf_ctx_arg_aux*, align 8
  %datasec = alloca %struct.btf_type*, align 8
  %t = alloca %struct.btf_type*, align 8
  %sym_name = alloca i8*, align 8
  %percpu = alloca i8, align 1
  %type = alloca i32, align 4
  %id = alloca i32, align 4
  %datasec_id = alloca i32, align 4
  %addr = alloca i64, align 8
  %i = alloca i32, align 4
  %ret = alloca %struct.btf_type*, align 8
  %tname = alloca i8*, align 8
  %tsize = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_insn* %insn, %struct.bpf_insn** %insn.addr, align 8
  store %struct.bpf_insn_aux_data* %aux, %struct.bpf_insn_aux_data** %aux.addr, align 8
  store i8 0, i8* %percpu, align 1
  %0 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %imm = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %0, i32 0, i32 3
  %1 = load i32, i32* %imm, align 4
  store i32 %1, i32* %id, align 4
  %2 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %tobool = icmp ne %struct.btf* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %4 = bitcast %struct.bpf_verifier_env* %3 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %4, i8* noundef getelementptr inbounds ([83 x i8], [83 x i8]* @.str.69, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %arrayidx = getelementptr %struct.bpf_insn, %struct.bpf_insn* %5, i64 1
  %imm1 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx, i32 0, i32 3
  %6 = load i32, i32* %imm1, align 4
  %cmp = icmp ne i32 %6, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = bitcast %struct.bpf_verifier_env* %7 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %8, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.70, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %9 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %10 = load i32, i32* %id, align 4
  %call = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %9, i32 noundef %10) #11
  store %struct.btf_type* %call, %struct.btf_type** %t, align 8
  %11 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %tobool4 = icmp ne %struct.btf_type* %11, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end3
  %12 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %13 = bitcast %struct.bpf_verifier_env* %12 to i8*
  %14 = load i32, i32* %id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %13, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.71, i64 0, i64 0), i32 noundef %14) #11
  store i32 -2, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  %15 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call7 = call zeroext i1 @btf_type_is_var(%struct.btf_type* noundef %15) #11
  br i1 %call7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end6
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load i32, i32* %id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.72, i64 0, i64 0), i32 noundef %18) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end6
  %19 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %20 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off = getelementptr inbounds %struct.btf_type, %struct.btf_type* %20, i32 0, i32 0
  %21 = load i32, i32* %name_off, align 4
  %call10 = call i8* @btf_name_by_offset(%struct.btf* noundef %19, i32 noundef %21) #11
  store i8* %call10, i8** %sym_name, align 8
  %22 = load i8*, i8** %sym_name, align 8
  %call11 = call i64 @kallsyms_lookup_name(i8* noundef %22) #11
  store i64 %call11, i64* %addr, align 8
  %23 = load i64, i64* %addr, align 8
  %tobool12 = icmp ne i64 %23, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end9
  %24 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %25 = bitcast %struct.bpf_verifier_env* %24 to i8*
  %26 = load i8*, i8** %sym_name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %25, i8* noundef getelementptr inbounds ([60 x i8], [60 x i8]* @.str.73, i64 0, i64 0), i8* noundef %26) #11
  store i32 -2, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end9
  %27 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %call15 = call i32 @btf_find_by_name_kind(%struct.btf* noundef %27, i8* noundef getelementptr inbounds ([14 x i8], [14 x i8]* @.str.74, i64 0, i64 0), i8 noundef zeroext 15) #11
  store i32 %call15, i32* %datasec_id, align 4
  %28 = load i32, i32* %datasec_id, align 4
  %cmp16 = icmp sgt i32 %28, 0
  br i1 %cmp16, label %if.then17, label %if.end28

if.then17:                                        ; preds = %if.end14
  %29 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %30 = load i32, i32* %datasec_id, align 4
  %call18 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %29, i32 noundef %30) #11
  store %struct.btf_type* %call18, %struct.btf_type** %datasec, align 8
  store i32 0, i32* %i, align 4
  %31 = load %struct.btf_type*, %struct.btf_type** %datasec, align 8
  %call19 = call %struct.bpf_ctx_arg_aux* @btf_type_var_secinfo(%struct.btf_type* noundef %31) #11
  store %struct.bpf_ctx_arg_aux* %call19, %struct.bpf_ctx_arg_aux** %vsi, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then17
  %32 = load i32, i32* %i, align 4
  %33 = load %struct.btf_type*, %struct.btf_type** %datasec, align 8
  %call20 = call zeroext i16 @btf_type_vlen(%struct.btf_type* noundef %33) #11
  %conv = zext i16 %call20 to i32
  %cmp21 = icmp slt i32 %32, %conv
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %34 = load %struct.bpf_ctx_arg_aux*, %struct.bpf_ctx_arg_aux** %vsi, align 8
  %type23 = getelementptr inbounds %struct.bpf_ctx_arg_aux, %struct.bpf_ctx_arg_aux* %34, i32 0, i32 0
  %35 = load i32, i32* %type23, align 4
  %36 = load i32, i32* %id, align 4
  %cmp24 = icmp eq i32 %35, %36
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %for.body
  store i8 1, i8* %percpu, align 1
  br label %for.end

if.end27:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end27
  %37 = load i32, i32* %i, align 4
  %inc = add i32 %37, 1
  store i32 %inc, i32* %i, align 4
  %38 = load %struct.bpf_ctx_arg_aux*, %struct.bpf_ctx_arg_aux** %vsi, align 8
  %incdec.ptr = getelementptr %struct.bpf_ctx_arg_aux, %struct.bpf_ctx_arg_aux* %38, i32 1
  store %struct.bpf_ctx_arg_aux* %incdec.ptr, %struct.bpf_ctx_arg_aux** %vsi, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then26, %for.cond
  br label %if.end28

if.end28:                                         ; preds = %for.end, %if.end14
  %39 = load i64, i64* %addr, align 8
  %conv29 = trunc i64 %39 to i32
  %40 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %arrayidx30 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %40, i64 0
  %imm31 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx30, i32 0, i32 3
  store i32 %conv29, i32* %imm31, align 4
  %41 = load i64, i64* %addr, align 8
  %shr = lshr i64 %41, 32
  %conv32 = trunc i64 %shr to i32
  %42 = load %struct.bpf_insn*, %struct.bpf_insn** %insn.addr, align 8
  %arrayidx33 = getelementptr %struct.bpf_insn, %struct.bpf_insn* %42, i64 1
  %imm34 = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx33, i32 0, i32 3
  store i32 %conv32, i32* %imm34, align 4
  %43 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %44 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %43, i32 0, i32 2
  %type35 = bitcast %struct.atomic_t* %44 to i32*
  %45 = load i32, i32* %type35, align 4
  store i32 %45, i32* %type, align 4
  %46 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %47 = load i32, i32* %type, align 4
  %call36 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %46, i32 noundef %47, i32* noundef null) #11
  store %struct.btf_type* %call36, %struct.btf_type** %t, align 8
  %48 = load i8, i8* %percpu, align 1
  %tobool37 = trunc i8 %48 to i1
  br i1 %tobool37, label %if.then38, label %if.else

if.then38:                                        ; preds = %if.end28
  %49 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %50 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %49, i32 0, i32 0
  %btf_var = bitcast %struct.atomic64_t* %50 to %struct.ethtool_link_ext_state_info*
  %reg_type = getelementptr inbounds %struct.ethtool_link_ext_state_info, %struct.ethtool_link_ext_state_info* %btf_var, i32 0, i32 0
  store i32 27, i32* %reg_type, align 8
  %51 = load i32, i32* %type, align 4
  %52 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %53 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %52, i32 0, i32 0
  %btf_var39 = bitcast %struct.atomic64_t* %53 to %struct.ethtool_link_ext_state_info*
  %54 = getelementptr inbounds %struct.ethtool_link_ext_state_info, %struct.ethtool_link_ext_state_info* %btf_var39, i32 0, i32 1
  %btf_id = bitcast %struct.atomic_t* %54 to i32*
  store i32 %51, i32* %btf_id, align 4
  br label %if.end58

if.else:                                          ; preds = %if.end28
  %55 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call40 = call zeroext i1 @btf_type_is_struct(%struct.btf_type* noundef %55) #11
  br i1 %call40, label %if.else52, label %if.then41

if.then41:                                        ; preds = %if.else
  %56 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %57 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call42 = call %struct.btf_type* @btf_resolve_size(%struct.btf* noundef %56, %struct.btf_type* noundef %57, i32* noundef %tsize) #11
  store %struct.btf_type* %call42, %struct.btf_type** %ret, align 8
  %58 = load %struct.btf_type*, %struct.btf_type** %ret, align 8
  %59 = bitcast %struct.btf_type* %58 to i8*
  %call43 = call zeroext i1 @IS_ERR(i8* noundef %59) #11
  br i1 %call43, label %if.then44, label %if.end48

if.then44:                                        ; preds = %if.then41
  %60 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %61 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %name_off45 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %61, i32 0, i32 0
  %62 = load i32, i32* %name_off45, align 4
  %call46 = call i8* @btf_name_by_offset(%struct.btf* noundef %60, i32 noundef %62) #11
  store i8* %call46, i8** %tname, align 8
  %63 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %64 = bitcast %struct.bpf_verifier_env* %63 to i8*
  %65 = load i8*, i8** %tname, align 8
  %66 = load %struct.btf_type*, %struct.btf_type** %ret, align 8
  %67 = bitcast %struct.btf_type* %66 to i8*
  %call47 = call i64 @PTR_ERR(i8* noundef %67) #11
  call void (i8*, i8*, ...) @verbose(i8* noundef %64, i8* noundef getelementptr inbounds ([54 x i8], [54 x i8]* @.str.75, i64 0, i64 0), i8* noundef %65, i64 noundef %call47) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.then41
  %68 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %69 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %68, i32 0, i32 0
  %btf_var49 = bitcast %struct.atomic64_t* %69 to %struct.ethtool_link_ext_state_info*
  %reg_type50 = getelementptr inbounds %struct.ethtool_link_ext_state_info, %struct.ethtool_link_ext_state_info* %btf_var49, i32 0, i32 0
  store i32 21, i32* %reg_type50, align 8
  %70 = load i32, i32* %tsize, align 4
  %71 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %72 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %71, i32 0, i32 0
  %btf_var51 = bitcast %struct.atomic64_t* %72 to %struct.ethtool_link_ext_state_info*
  %73 = getelementptr inbounds %struct.ethtool_link_ext_state_info, %struct.ethtool_link_ext_state_info* %btf_var51, i32 0, i32 1
  %mem_size = bitcast %struct.atomic_t* %73 to i32*
  store i32 %70, i32* %mem_size, align 4
  br label %if.end57

if.else52:                                        ; preds = %if.else
  %74 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %75 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %74, i32 0, i32 0
  %btf_var53 = bitcast %struct.atomic64_t* %75 to %struct.ethtool_link_ext_state_info*
  %reg_type54 = getelementptr inbounds %struct.ethtool_link_ext_state_info, %struct.ethtool_link_ext_state_info* %btf_var53, i32 0, i32 0
  store i32 19, i32* %reg_type54, align 8
  %76 = load i32, i32* %type, align 4
  %77 = load %struct.bpf_insn_aux_data*, %struct.bpf_insn_aux_data** %aux.addr, align 8
  %78 = getelementptr inbounds %struct.bpf_insn_aux_data, %struct.bpf_insn_aux_data* %77, i32 0, i32 0
  %btf_var55 = bitcast %struct.atomic64_t* %78 to %struct.ethtool_link_ext_state_info*
  %79 = getelementptr inbounds %struct.ethtool_link_ext_state_info, %struct.ethtool_link_ext_state_info* %btf_var55, i32 0, i32 1
  %btf_id56 = bitcast %struct.atomic_t* %79 to i32*
  store i32 %76, i32* %btf_id56, align 4
  br label %if.end57

if.end57:                                         ; preds = %if.else52, %if.end48
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.then38
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end58, %if.then44, %if.then13, %if.then8, %if.then5, %if.then2, %if.then
  %80 = load i32, i32* %retval, align 4
  ret i32 %80
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { %struct.file*, i32 } @fdget(i32 noundef %fd) #0 {
entry:
  %retval = alloca %struct.fd, align 8
  %fd.addr = alloca i32, align 4
  store i32 %fd, i32* %fd.addr, align 4
  %0 = load i32, i32* %fd.addr, align 4
  %call = call i64 @__fdget(i32 noundef %0) #11
  %call1 = call { %struct.file*, i32 } @__to_fd(i64 noundef %call) #11
  %1 = bitcast %struct.fd* %retval to { %struct.file*, i32 }*
  %2 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %1, i32 0, i32 0
  %3 = extractvalue { %struct.file*, i32 } %call1, 0
  store %struct.file* %3, %struct.file** %2, align 8
  %4 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %1, i32 0, i32 1
  %5 = extractvalue { %struct.file*, i32 } %call1, 1
  store i32 %5, i32* %4, align 8
  %6 = bitcast %struct.fd* %retval to { %struct.file*, i32 }*
  %7 = load { %struct.file*, i32 }, { %struct.file*, i32 }* %6, align 8
  ret { %struct.file*, i32 } %7
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.bpf_map* @__bpf_map_get(%struct.file*, i32) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_prog_compatibility(%struct.bpf_verifier_env* noundef %env, %struct.bpf_map* noundef %map, %struct.bpf_prog* noundef %prog) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  %prog.addr = alloca %struct.bpf_prog*, align 8
  %prog_type = alloca i32, align 4
  %__ret_warn_once = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %tmp = alloca i64, align 8
  %tmp37 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %call = call i32 @resolve_prog_type(%struct.bpf_prog* noundef %0) #11
  store i32 %call, i32* %prog_type, align 4
  %1 = load i32, i32* %prog_type, align 4
  %call1 = call zeroext i1 @is_tracing_prog_type(i32 noundef %1) #11
  br i1 %call1, label %land.lhs.true, label %if.end44

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call2 = call zeroext i1 @is_preallocated_map(%struct.bpf_map* noundef %2) #11
  br i1 %call2, label %if.end44, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %3 = load i32, i32* %prog_type, align 4
  %cmp = icmp eq i32 %3, 7
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %5 = bitcast %struct.bpf_verifier_env* %4 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %5, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.76, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  store i32 1, i32* %__ret_warn_once, align 4
  %6 = load i32, i32* %__ret_warn_once, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %7 = load i8, i8* @check_map_prog_compatibility.__warned, align 1
  %tobool4 = trunc i8 %7 to i1
  %lnot = xor i1 %tobool4, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %8 = phi i1 [ false, %if.end ], [ %lnot, %land.rhs ]
  %lnot5 = xor i1 %8, true
  %lnot6 = xor i1 %lnot5, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool7 = icmp ne i64 %conv, 0
  br i1 %tobool7, label %if.then8, label %if.end36

if.then8:                                         ; preds = %land.end
  store i8 1, i8* @check_map_prog_compatibility.__warned, align 1
  store i32 1, i32* %__ret_warn_on, align 4
  %9 = load i32, i32* %__ret_warn_on, align 4
  %tobool9 = icmp ne i32 %9, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %tobool15 = icmp ne i64 %conv14, 0
  br i1 %tobool15, label %if.then16, label %if.end29

if.then16:                                        ; preds = %if.then8
  br label %do.body

do.body:                                          ; preds = %if.then16
  br label %do.body17

do.body17:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.body17
  call void (i8*, ...) @__warn_printk(i8* noundef getelementptr inbounds ([49 x i8], [49 x i8]* @.str.77, i64 0, i64 0)) #11
  br label %do.body18

do.body18:                                        ; preds = %do.end
  br label %do.body19

do.body19:                                        ; preds = %do.body18
  br label %do.end20

do.end20:                                         ; preds = %do.body19
  br label %do.body21

do.body21:                                        ; preds = %do.end20
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32 11674, i32 2313, i64 12) #10, !srcloc !72
  br label %do.end22

do.end22:                                         ; preds = %do.body21
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 495) #10, !srcloc !73
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  br label %do.end24

do.end24:                                         ; preds = %do.body23
  br label %do.end25

do.end25:                                         ; preds = %do.end24
  br label %do.body26

do.body26:                                        ; preds = %do.end25
  br label %do.end27

do.end27:                                         ; preds = %do.body26
  br label %do.end28

do.end28:                                         ; preds = %do.end27
  br label %if.end29

if.end29:                                         ; preds = %do.end28, %if.then8
  %10 = load i32, i32* %__ret_warn_on, align 4
  %tobool30 = icmp ne i32 %10, 0
  %lnot31 = xor i1 %tobool30, true
  %lnot33 = xor i1 %lnot31, true
  %lnot.ext34 = zext i1 %lnot33 to i32
  %conv35 = sext i32 %lnot.ext34 to i64
  store i64 %conv35, i64* %tmp, align 8
  %11 = load i64, i64* %tmp, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.end29, %land.end
  %12 = load i32, i32* %__ret_warn_once, align 4
  %tobool38 = icmp ne i32 %12, 0
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  store i64 %conv43, i64* %tmp37, align 8
  %13 = load i64, i64* %tmp37, align 8
  %14 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %15 = bitcast %struct.bpf_verifier_env* %14 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %15, i8* noundef getelementptr inbounds ([101 x i8], [101 x i8]* @.str.78, i64 0, i64 0)) #11
  br label %if.end44

if.end44:                                         ; preds = %if.end36, %land.lhs.true, %entry
  %16 = load i32, i32* %prog_type, align 4
  %call45 = call zeroext i1 @is_tracing_prog_type(i32 noundef %16) #11
  br i1 %call45, label %land.lhs.true49, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end44
  %17 = load i32, i32* %prog_type, align 4
  %cmp47 = icmp eq i32 %17, 1
  br i1 %cmp47, label %land.lhs.true49, label %if.end53

land.lhs.true49:                                  ; preds = %lor.lhs.false, %if.end44
  %18 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call50 = call zeroext i1 @map_value_has_spin_lock(%struct.bpf_map* noundef %18) #11
  br i1 %call50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %land.lhs.true49
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %20 = bitcast %struct.bpf_verifier_env* %19 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %20, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.79, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end53:                                         ; preds = %land.lhs.true49, %lor.lhs.false
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 7
  %22 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %call54 = call zeroext i1 @bpf_prog_is_dev_bound(%struct.bpf_prog_aux* noundef %22) #11
  br i1 %call54, label %land.lhs.true59, label %lor.lhs.false56

lor.lhs.false56:                                  ; preds = %if.end53
  %23 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call57 = call zeroext i1 @bpf_map_is_dev_bound(%struct.bpf_map* noundef %23) #11
  br i1 %call57, label %land.lhs.true59, label %if.end62

land.lhs.true59:                                  ; preds = %lor.lhs.false56, %if.end53
  %24 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %25 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call60 = call zeroext i1 @bpf_offload_prog_map_match(%struct.bpf_prog* noundef %24, %struct.bpf_map* noundef %25) #11
  br i1 %call60, label %if.end62, label %if.then61

if.then61:                                        ; preds = %land.lhs.true59
  %26 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %27 = bitcast %struct.bpf_verifier_env* %26 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %27, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.80, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end62:                                         ; preds = %land.lhs.true59, %lor.lhs.false56
  %28 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %28, i32 0, i32 3
  %29 = load i32, i32* %map_type, align 8
  %cmp63 = icmp eq i32 %29, 26
  br i1 %cmp63, label %if.then65, label %if.end66

if.then65:                                        ; preds = %if.end62
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([43 x i8], [43 x i8]* @.str.81, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end66:                                         ; preds = %if.end62
  %32 = load %struct.bpf_prog*, %struct.bpf_prog** %prog.addr, align 8
  %aux67 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %32, i32 0, i32 7
  %33 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux67, align 8
  %sleepable = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %33, i32 0, i32 23
  %34 = load i8, i8* %sleepable, align 4
  %tobool68 = trunc i8 %34 to i1
  br i1 %tobool68, label %if.then69, label %if.end74

if.then69:                                        ; preds = %if.end66
  %35 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type70 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %35, i32 0, i32 3
  %36 = load i32, i32* %map_type70, align 8
  switch i32 %36, label %sw.default [
    i32 1, label %sw.bb
    i32 9, label %sw.bb
    i32 2, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.then69, %if.then69, %if.then69
  %37 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call71 = call zeroext i1 @is_preallocated_map(%struct.bpf_map* noundef %37) #11
  br i1 %call71, label %if.end73, label %if.then72

if.then72:                                        ; preds = %sw.bb
  %38 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %39 = bitcast %struct.bpf_verifier_env* %38 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %39, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.82, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end73:                                         ; preds = %sw.bb
  br label %sw.epilog

sw.default:                                       ; preds = %if.then69
  %40 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %41 = bitcast %struct.bpf_verifier_env* %40 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %41, i8* noundef getelementptr inbounds ([53 x i8], [53 x i8]* @.str.83, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %if.end73
  br label %if.end74

if.end74:                                         ; preds = %sw.epilog, %if.end66
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end74, %sw.default, %if.then72, %if.then65, %if.then61, %if.then52, %if.then3
  %42 = load i32, i32* %retval, align 4
  ret i32 %42
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal void @fdput(%struct.file* %fd.coerce0, i32 %fd.coerce1) #0 {
entry:
  %fd = alloca %struct.fd, align 8
  %0 = bitcast %struct.fd* %fd to { %struct.file*, i32 }*
  %1 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %0, i32 0, i32 0
  store %struct.file* %fd.coerce0, %struct.file** %1, align 8
  %2 = getelementptr inbounds { %struct.file*, i32 }, { %struct.file*, i32 }* %0, i32 0, i32 1
  store i32 %fd.coerce1, i32* %2, align 8
  %flags = getelementptr inbounds %struct.fd, %struct.fd* %fd, i32 0, i32 1
  %3 = load i32, i32* %flags, align 8
  %and = and i32 %3, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %file = getelementptr inbounds %struct.fd, %struct.fd* %fd, i32 0, i32 0
  %4 = load %struct.file*, %struct.file** %file, align 8
  call void @fput(%struct.file* noundef %4) #11
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @bpf_map_inc(%struct.bpf_map* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_is_cgroup_storage(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 3
  %1 = load i32, i32* %map_type, align 8
  %cmp = icmp eq i32 %1, 19
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %2, i32 0, i32 3
  %3 = load i32, i32* %map_type1, align 8
  %cmp2 = icmp eq i32 %3, 21
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_cgroup_storage_assign(%struct.bpf_prog_aux* noundef %aux, %struct.bpf_map* noundef %map) #0 {
entry:
  %aux.addr = alloca %struct.bpf_prog_aux*, align 8
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_prog_aux* %aux, %struct.bpf_prog_aux** %aux.addr, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  ret i32 0
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_opcode_in_insntable(i8 noundef zeroext) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @fput(%struct.file* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_tracing_prog_type(i32 noundef %type) #0 {
entry:
  %retval = alloca i1, align 1
  %type.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 2, label %sw.bb
    i32 5, label %sw.bb
    i32 7, label %sw.bb
    i32 17, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry
  store i1 true, i1* %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %1 = load i1, i1* %retval, align 1
  ret i1 %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @is_preallocated_map(%struct.bpf_map* noundef %map) #0 {
entry:
  %retval = alloca i1, align 1
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %call = call i32 @check_map_prealloc(%struct.bpf_map* noundef %0) #11
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %inner_map_meta = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %1, i32 0, i32 1
  %2 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta, align 8
  %tobool1 = icmp ne %struct.bpf_map* %2, null
  br i1 %tobool1, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %3 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %inner_map_meta2 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %3, i32 0, i32 1
  %4 = load %struct.bpf_map*, %struct.bpf_map** %inner_map_meta2, align 8
  %call3 = call i32 @check_map_prealloc(%struct.bpf_map* noundef %4) #11
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %land.lhs.true
  store i1 false, i1* %retval, align 1
  br label %return

if.end6:                                          ; preds = %land.lhs.true, %if.end
  store i1 true, i1* %retval, align 1
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %5 = load i1, i1* %retval, align 1
  ret i1 %5
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @bpf_map_is_dev_bound(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 0
  %1 = load %struct.bpf_map_ops*, %struct.bpf_map_ops** %ops, align 64
  %cmp = icmp eq %struct.bpf_map_ops* %1, @bpf_map_offload_ops
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  ret i1 %tobool
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_offload_prog_map_match(%struct.bpf_prog* noundef, %struct.bpf_map* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_map_prealloc(%struct.bpf_map* noundef %map) #0 {
entry:
  %map.addr = alloca %struct.bpf_map*, align 8
  store %struct.bpf_map* %map, %struct.bpf_map** %map.addr, align 8
  %0 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %0, i32 0, i32 3
  %1 = load i32, i32* %map_type, align 8
  %cmp = icmp ne i32 %1, 1
  br i1 %cmp, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type1 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %2, i32 0, i32 3
  %3 = load i32, i32* %map_type1, align 8
  %cmp2 = icmp ne i32 %3, 5
  br i1 %cmp2, label %land.lhs.true3, label %lor.rhs

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_type4 = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %4, i32 0, i32 3
  %5 = load i32, i32* %map_type4, align 8
  %cmp5 = icmp ne i32 %5, 13
  br i1 %cmp5, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true3, %land.lhs.true, %entry
  %6 = load %struct.bpf_map*, %struct.bpf_map** %map.addr, align 8
  %map_flags = getelementptr inbounds %struct.bpf_map, %struct.bpf_map* %6, i32 0, i32 7
  %7 = load i32, i32* %map_flags, align 8
  %and = and i32 %7, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true3
  %8 = phi i1 [ true, %land.lhs.true3 ], [ %lnot, %lor.rhs ]
  %lor.ext = zext i1 %8 to i32
  ret i32 %lor.ext
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @__fdget(i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal { %struct.file*, i32 } @__to_fd(i64 noundef %v) #0 {
entry:
  %retval = alloca %struct.fd, align 8
  %v.addr = alloca i64, align 8
  store i64 %v, i64* %v.addr, align 8
  %file = getelementptr inbounds %struct.fd, %struct.fd* %retval, i32 0, i32 0
  %0 = load i64, i64* %v.addr, align 8
  %and = and i64 %0, -4
  %1 = inttoptr i64 %and to %struct.file*
  store %struct.file* %1, %struct.file** %file, align 8
  %flags = getelementptr inbounds %struct.fd, %struct.fd* %retval, i32 0, i32 1
  %2 = load i64, i64* %v.addr, align 8
  %and1 = and i64 %2, 3
  %conv = trunc i64 %and1 to i32
  store i32 %conv, i32* %flags, align 8
  %3 = bitcast %struct.fd* %retval to { %struct.file*, i32 }*
  %4 = load { %struct.file*, i32 }, { %struct.file*, i32 }* %3, align 8
  ret { %struct.file*, i32 } %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_var(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 15
  %cmp = icmp eq i32 %and, 14
  ret i1 %cmp
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @btf_find_by_name_kind(%struct.btf* noundef, i8* noundef, i8 noundef zeroext) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_ctx_arg_aux* @btf_type_var_secinfo(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %add.ptr = getelementptr %struct.btf_type, %struct.btf_type* %0, i64 1
  %1 = bitcast %struct.btf_type* %add.ptr to %struct.bpf_ctx_arg_aux*
  ret %struct.bpf_ctx_arg_aux* %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i16 @btf_type_vlen(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %and = and i32 %1, 65535
  %conv = trunc i32 %and to i16
  ret i16 %conv
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_struct_ops_btf_id(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %t = alloca %struct.btf_type*, align 8
  %func_proto = alloca %struct.btf_type*, align 8
  %st_ops = alloca %struct.bpf_struct_ops*, align 8
  %member = alloca %struct.bpf_ctx_arg_aux*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %btf_id = alloca i32, align 4
  %member_idx = alloca i32, align 4
  %mname = alloca i8*, align 8
  %err = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog1, align 8
  store %struct.bpf_prog* %1, %struct.bpf_prog** %prog, align 8
  %2 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %2, i32 0, i32 7
  %3 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %attach_btf_id = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %3, i32 0, i32 9
  %4 = load i32, i32* %attach_btf_id, align 8
  store i32 %4, i32* %btf_id, align 4
  %5 = load i32, i32* %btf_id, align 4
  %call = call %struct.bpf_struct_ops* @bpf_struct_ops_find(i32 noundef %5) #11
  store %struct.bpf_struct_ops* %call, %struct.bpf_struct_ops** %st_ops, align 8
  %6 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %tobool = icmp ne %struct.bpf_struct_ops* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %7 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %8 = bitcast %struct.bpf_verifier_env* %7 to i8*
  %9 = load i32, i32* %btf_id, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %8, i8* noundef getelementptr inbounds ([44 x i8], [44 x i8]* @.str.55, i64 0, i64 0), i32 noundef %9) #11
  store i32 -524, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %10 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %type = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %10, i32 0, i32 6
  %11 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  store %struct.btf_type* %11, %struct.btf_type** %t, align 8
  %12 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %expected_attach_type = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %12, i32 0, i32 3
  %13 = load i32, i32* %expected_attach_type, align 8
  store i32 %13, i32* %member_idx, align 4
  %14 = load i32, i32* %member_idx, align 4
  %15 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call2 = call zeroext i16 @btf_type_vlen(%struct.btf_type* noundef %15) #11
  %conv = zext i16 %call2 to i32
  %cmp = icmp uge i32 %14, %conv
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load i32, i32* %member_idx, align 4
  %19 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %name = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %19, i32 0, i32 8
  %20 = load i8*, i8** %name, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.56, i64 0, i64 0), i32 noundef %18, i8* noundef %20) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %21 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %call6 = call %struct.bpf_ctx_arg_aux* @btf_type_member(%struct.btf_type* noundef %21) #11
  %22 = load i32, i32* %member_idx, align 4
  %idxprom = zext i32 %22 to i64
  %arrayidx = getelementptr %struct.bpf_ctx_arg_aux, %struct.bpf_ctx_arg_aux* %call6, i64 %idxprom
  store %struct.bpf_ctx_arg_aux* %arrayidx, %struct.bpf_ctx_arg_aux** %member, align 8
  %23 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %24 = load %struct.bpf_ctx_arg_aux*, %struct.bpf_ctx_arg_aux** %member, align 8
  %name_off = getelementptr inbounds %struct.bpf_ctx_arg_aux, %struct.bpf_ctx_arg_aux* %24, i32 0, i32 0
  %25 = load i32, i32* %name_off, align 4
  %call7 = call i8* @btf_name_by_offset(%struct.btf* noundef %23, i32 noundef %25) #11
  store i8* %call7, i8** %mname, align 8
  %26 = load %struct.btf*, %struct.btf** @btf_vmlinux, align 8
  %27 = load %struct.bpf_ctx_arg_aux*, %struct.bpf_ctx_arg_aux** %member, align 8
  %type8 = getelementptr inbounds %struct.bpf_ctx_arg_aux, %struct.bpf_ctx_arg_aux* %27, i32 0, i32 1
  %28 = load i32, i32* %type8, align 4
  %call9 = call %struct.btf_type* @btf_type_resolve_func_ptr(%struct.btf* noundef %26, i32 noundef %28, i32* noundef null) #11
  store %struct.btf_type* %call9, %struct.btf_type** %func_proto, align 8
  %29 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %tobool10 = icmp ne %struct.btf_type* %29, null
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %if.end5
  %30 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %31 = bitcast %struct.bpf_verifier_env* %30 to i8*
  %32 = load i8*, i8** %mname, align 8
  %33 = load i32, i32* %member_idx, align 4
  %34 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %name12 = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %34, i32 0, i32 8
  %35 = load i8*, i8** %name12, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %31, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.57, i64 0, i64 0), i8* noundef %32, i32 noundef %33, i8* noundef %35) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end5
  %36 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %check_member = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %36, i32 0, i32 2
  %37 = load i32 (%struct.btf_type*, %struct.bpf_ctx_arg_aux*)*, i32 (%struct.btf_type*, %struct.bpf_ctx_arg_aux*)** %check_member, align 8
  %tobool14 = icmp ne i32 (%struct.btf_type*, %struct.bpf_ctx_arg_aux*)* %37, null
  br i1 %tobool14, label %if.then15, label %if.end22

if.then15:                                        ; preds = %if.end13
  %38 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %check_member16 = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %38, i32 0, i32 2
  %39 = load i32 (%struct.btf_type*, %struct.bpf_ctx_arg_aux*)*, i32 (%struct.btf_type*, %struct.bpf_ctx_arg_aux*)** %check_member16, align 8
  %40 = load %struct.btf_type*, %struct.btf_type** %t, align 8
  %41 = load %struct.bpf_ctx_arg_aux*, %struct.bpf_ctx_arg_aux** %member, align 8
  %call17 = call i32 %39(%struct.btf_type* noundef %40, %struct.bpf_ctx_arg_aux* noundef %41) #11
  store i32 %call17, i32* %err, align 4
  %42 = load i32, i32* %err, align 4
  %tobool18 = icmp ne i32 %42, 0
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.then15
  %43 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %44 = bitcast %struct.bpf_verifier_env* %43 to i8*
  %45 = load i8*, i8** %mname, align 8
  %46 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %name20 = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %46, i32 0, i32 8
  %47 = load i8*, i8** %name20, align 8
  call void (i8*, i8*, ...) @verbose(i8* noundef %44, i8* noundef getelementptr inbounds ([46 x i8], [46 x i8]* @.str.58, i64 0, i64 0), i8* noundef %45, i8* noundef %47) #11
  %48 = load i32, i32* %err, align 4
  store i32 %48, i32* %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.then15
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.end13
  %49 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %50 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux23 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %50, i32 0, i32 7
  %51 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux23, align 8
  %attach_func_proto = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %51, i32 0, i32 27
  store %struct.btf_type* %49, %struct.btf_type** %attach_func_proto, align 8
  %52 = load i8*, i8** %mname, align 8
  %53 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux24 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %53, i32 0, i32 7
  %54 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux24, align 8
  %attach_func_name = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %54, i32 0, i32 28
  store i8* %52, i8** %attach_func_name, align 8
  %55 = load %struct.bpf_struct_ops*, %struct.bpf_struct_ops** %st_ops, align 8
  %verifier_ops = getelementptr inbounds %struct.bpf_struct_ops, %struct.bpf_struct_ops* %55, i32 0, i32 0
  %56 = load %struct.bpf_verifier_ops*, %struct.bpf_verifier_ops** %verifier_ops, align 8
  %57 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %ops = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %57, i32 0, i32 3
  store %struct.bpf_verifier_ops* %56, %struct.bpf_verifier_ops** %ops, align 8
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end22, %if.then19, %if.then11, %if.then4, %if.then
  %58 = load i32, i32* %retval, align 4
  ret i32 %58
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @bpf_iter_prog_supported(%struct.bpf_prog* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @bpf_lsm_verify_prog(%struct.bpf_verifier_log* noundef %vlog, %struct.bpf_prog* noundef %prog) #0 {
entry:
  %vlog.addr = alloca %struct.bpf_verifier_log*, align 8
  %prog.addr = alloca %struct.bpf_prog*, align 8
  store %struct.bpf_verifier_log* %vlog, %struct.bpf_verifier_log** %vlog.addr, align 8
  store %struct.bpf_prog* %prog, %struct.bpf_prog** %prog.addr, align 8
  ret i32 -95
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @bpf_trampoline_compute_key(%struct.bpf_prog* noundef %tgt_prog, i32 noundef %btf_id) #0 {
entry:
  %tgt_prog.addr = alloca %struct.bpf_prog*, align 8
  %btf_id.addr = alloca i32, align 4
  store %struct.bpf_prog* %tgt_prog, %struct.bpf_prog** %tgt_prog.addr, align 8
  store i32 %btf_id, i32* %btf_id.addr, align 4
  %0 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %tobool = icmp ne %struct.bpf_prog* %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %tgt_prog.addr, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 7
  %2 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %id = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %2, i32 0, i32 6
  %3 = load i32, i32* %id, align 4
  %conv = zext i32 %3 to i64
  %shl = shl i64 %conv, 32
  %4 = load i32, i32* %btf_id.addr, align 4
  %conv1 = zext i32 %4 to i64
  %or = or i64 %shl, %conv1
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load i32, i32* %btf_id.addr, align 4
  %conv2 = zext i32 %5 to i64
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %or, %cond.true ], [ %conv2, %cond.false ]
  ret i64 %cond
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_trampoline* @bpf_trampoline_get(i64 noundef %key, %struct.bpf_attach_target_info* noundef %tgt_info) #0 {
entry:
  %key.addr = alloca i64, align 8
  %tgt_info.addr = alloca %struct.bpf_attach_target_info*, align 8
  store i64 %key, i64* %key.addr, align 8
  store %struct.bpf_attach_target_info* %tgt_info, %struct.bpf_attach_target_info** %tgt_info.addr, align 8
  %call = call i8* @ERR_PTR(i64 noundef -95) #11
  %0 = bitcast i8* %call to %struct.bpf_trampoline*
  ret %struct.bpf_trampoline* %0
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @ERR_PTR(i64 noundef %error) #0 {
entry:
  %error.addr = alloca i64, align 8
  store i64 %error, i64* %error.addr, align 8
  %0 = load i64, i64* %error.addr, align 8
  %1 = inttoptr i64 %0 to i8*
  ret i8* %1
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_struct_ops* @bpf_struct_ops_find(i32 noundef %type_id) #0 {
entry:
  %type_id.addr = alloca i32, align 4
  store i32 %type_id, i32* %type_id.addr, align 4
  ret %struct.bpf_struct_ops* null
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal %struct.bpf_ctx_arg_aux* @btf_type_member(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %add.ptr = getelementptr %struct.btf_type, %struct.btf_type* %0, i64 1
  %1 = bitcast %struct.btf_type* %add.ptr to %struct.bpf_ctx_arg_aux*
  ret %struct.bpf_ctx_arg_aux* %1
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf_type* @btf_type_resolve_func_ptr(%struct.btf* noundef, i32 noundef, i32* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_abnormal_return(%struct.bpf_verifier_env* noundef %env) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %i = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %1, i32 0, i32 26
  %2 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %3, i32 0, i32 23
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %has_ld_abs = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 5
  %5 = load i8, i8* %has_ld_abs, align 4
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([47 x i8], [47 x i8]* @.str.37, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info1 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %8, i32 0, i32 23
  %9 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %9 to i64
  %arrayidx3 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info1, i64 0, i64 %idxprom2
  %has_tail_call = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx3, i32 0, i32 3
  %10 = load i8, i8* %has_tail_call, align 2
  %tobool4 = trunc i8 %10 to i1
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %12 = bitcast %struct.bpf_verifier_env* %11 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %12, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.38, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %13 = load i32, i32* %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then5, %if.then
  %14 = load i32, i32* %retval, align 4
  ret i32 %14
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local %struct.btf* @btf_get_by_fd(i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_btf_func(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, %union.bpf_attr* noundef %uattr) #0 {
entry:
  %retval.i.i = alloca i1, align 1
  %addr.addr.i.i = alloca i8*, align 8
  %bytes.addr.i.i = alloca i64, align 8
  %is_source.addr.i.i = alloca i8, align 1
  %sz.i.i = alloca i32, align 4
  %__ret_warn_on.i.i = alloca i32, align 4
  %tmp.i.i = alloca i64, align 8
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %uattr.addr = alloca %union.bpf_attr*, align 8
  %type = alloca %struct.btf_type*, align 8
  %func_proto = alloca %struct.btf_type*, align 8
  %ret_type = alloca %struct.btf_type*, align 8
  %i = alloca i32, align 4
  %nfuncs = alloca i32, align 4
  %urec_size = alloca i32, align 4
  %min_size = alloca i32, align 4
  %krec_size = alloca i32, align 4
  %krecord = alloca %struct.util_est*, align 8
  %info_aux = alloca %struct.bpf_func_info_aux*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %btf = alloca %struct.btf*, align 8
  %urecord = alloca i8*, align 8
  %prev_offset = alloca i32, align 4
  %scalar_return = alloca i8, align 1
  %ret = alloca i32, align 4
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %tmp16 = alloca i8*, align 8
  %__UNIQUE_ID___x485 = alloca i32, align 4
  %__UNIQUE_ID___y486 = alloca i32, align 4
  %tmp17 = alloca i32, align 4
  %tmp41 = alloca i64, align 8
  %__ret_pu = alloca i32, align 4
  %__ptr_pu = alloca i8*, align 8
  %__val_pu = alloca i32, align 4
  %tmp44 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  store %union.bpf_attr* %uattr, %union.bpf_attr** %uattr.addr, align 8
  store i32 8, i32* %krec_size, align 4
  store %struct.bpf_func_info_aux* null, %struct.bpf_func_info_aux** %info_aux, align 8
  store i32 0, i32* %prev_offset, align 4
  store i32 -12, i32* %ret, align 4
  %0 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %1 = bitcast %union.bpf_attr* %0 to %struct.anon.10*
  %func_info_cnt = getelementptr inbounds %struct.anon.10, %struct.anon.10* %1, i32 0, i32 15
  %2 = load i32, i32* %func_info_cnt, align 8
  store i32 %2, i32* %nfuncs, align 4
  %3 = load i32, i32* %nfuncs, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end3, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %call = call i32 @check_abnormal_return(%struct.bpf_verifier_env* noundef %4) #11
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %entry
  %5 = load i32, i32* %nfuncs, align 4
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %6, i32 0, i32 26
  %7 = load i32, i32* %subprog_cnt, align 4
  %cmp = icmp ne i32 %5, %7
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end3
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = bitcast %struct.bpf_verifier_env* %8 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %9, i8* noundef getelementptr inbounds ([63 x i8], [63 x i8]* @.str.39, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end3
  %10 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %11 = bitcast %union.bpf_attr* %10 to %struct.anon.10*
  %func_info_rec_size = getelementptr inbounds %struct.anon.10, %struct.anon.10* %11, i32 0, i32 13
  %12 = load i32, i32* %func_info_rec_size, align 4
  store i32 %12, i32* %urec_size, align 4
  %13 = load i32, i32* %urec_size, align 4
  %cmp6 = icmp ult i32 %13, 8
  br i1 %cmp6, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %14 = load i32, i32* %urec_size, align 4
  %cmp7 = icmp ugt i32 %14, 252
  br i1 %cmp7, label %if.then10, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false
  %15 = load i32, i32* %urec_size, align 4
  %conv = zext i32 %15 to i64
  %rem = urem i64 %conv, 4
  %tobool9 = icmp ne i64 %rem, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %lor.lhs.false8, %lor.lhs.false, %if.end5
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %17 = bitcast %struct.bpf_verifier_env* %16 to i8*
  %18 = load i32, i32* %urec_size, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %17, i8* noundef getelementptr inbounds ([31 x i8], [31 x i8]* @.str.40, i64 0, i64 0), i32 noundef %18) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end11:                                         ; preds = %lor.lhs.false8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog12 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 2
  %20 = load %struct.bpf_prog*, %struct.bpf_prog** %prog12, align 8
  store %struct.bpf_prog* %20, %struct.bpf_prog** %prog, align 8
  %21 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %21, i32 0, i32 7
  %22 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf13 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %22, i32 0, i32 44
  %23 = load %struct.btf*, %struct.btf** %btf13, align 8
  store %struct.btf* %23, %struct.btf** %btf, align 8
  %cmp14 = icmp eq i64* %__dummy, %__dummy2
  %conv15 = zext i1 %cmp14 to i32
  store i32 1, i32* %tmp, align 4
  %24 = load i32, i32* %tmp, align 4
  %25 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %26 = bitcast %union.bpf_attr* %25 to %struct.anon.10*
  %func_info = getelementptr inbounds %struct.anon.10, %struct.anon.10* %26, i32 0, i32 14
  %27 = load i64, i64* %func_info, align 8
  %28 = inttoptr i64 %27 to i8*
  store i8* %28, i8** %tmp16, align 8
  %29 = load i8*, i8** %tmp16, align 8
  store i8* %29, i8** %urecord, align 8
  %30 = load i32, i32* %krec_size, align 4
  store i32 %30, i32* %__UNIQUE_ID___x485, align 4
  %31 = load i32, i32* %urec_size, align 4
  store i32 %31, i32* %__UNIQUE_ID___y486, align 4
  %32 = load i32, i32* %__UNIQUE_ID___x485, align 4
  %33 = load i32, i32* %__UNIQUE_ID___y486, align 4
  %cmp18 = icmp ult i32 %32, %33
  br i1 %cmp18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end11
  %34 = load i32, i32* %__UNIQUE_ID___x485, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end11
  %35 = load i32, i32* %__UNIQUE_ID___y486, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %34, %cond.true ], [ %35, %cond.false ]
  store i32 %cond, i32* %tmp17, align 4
  %36 = load i32, i32* %tmp17, align 4
  store i32 %36, i32* %min_size, align 4
  %37 = load i32, i32* %nfuncs, align 4
  %conv20 = zext i32 %37 to i64
  %38 = load i32, i32* %krec_size, align 4
  %conv21 = zext i32 %38 to i64
  %call22 = call i8* @kvcalloc(i64 noundef %conv20, i64 noundef %conv21, i32 noundef 11456) #11
  %39 = bitcast i8* %call22 to %struct.util_est*
  store %struct.util_est* %39, %struct.util_est** %krecord, align 8
  %40 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %tobool23 = icmp ne %struct.util_est* %40, null
  br i1 %tobool23, label %if.end25, label %if.then24

if.then24:                                        ; preds = %cond.end
  store i32 -12, i32* %retval, align 4
  br label %return

if.end25:                                         ; preds = %cond.end
  %41 = load i32, i32* %nfuncs, align 4
  %conv26 = zext i32 %41 to i64
  %call27 = call i8* @kcalloc(i64 noundef %conv26, i64 noundef 4, i32 noundef 11456) #11
  %42 = bitcast i8* %call27 to %struct.bpf_func_info_aux*
  store %struct.bpf_func_info_aux* %42, %struct.bpf_func_info_aux** %info_aux, align 8
  %43 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %info_aux, align 8
  %tobool28 = icmp ne %struct.bpf_func_info_aux* %43, null
  br i1 %tobool28, label %if.end30, label %if.then29

if.then29:                                        ; preds = %if.end25
  br label %err_free

if.end30:                                         ; preds = %if.end25
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end30
  %44 = load i32, i32* %i, align 4
  %45 = load i32, i32* %nfuncs, align 4
  %cmp31 = icmp ult i32 %44, %45
  br i1 %cmp31, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %46 = load i8*, i8** %urecord, align 8
  %47 = load i32, i32* %krec_size, align 4
  %conv33 = zext i32 %47 to i64
  %48 = load i32, i32* %urec_size, align 4
  %conv34 = zext i32 %48 to i64
  %call35 = call i32 @bpf_check_uarg_tail_zero(i8* noundef %46, i64 noundef %conv33, i64 noundef %conv34) #11
  store i32 %call35, i32* %ret, align 4
  %49 = load i32, i32* %ret, align 4
  %tobool36 = icmp ne i32 %49, 0
  br i1 %tobool36, label %if.then37, label %if.end50

if.then37:                                        ; preds = %for.body
  %50 = load i32, i32* %ret, align 4
  %cmp38 = icmp eq i32 %50, -7
  br i1 %cmp38, label %if.then40, label %if.end49

if.then40:                                        ; preds = %if.then37
  %51 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %52 = bitcast %struct.bpf_verifier_env* %51 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %52, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.41, i64 0, i64 0)) #11
  call void @might_fault() #11
  %53 = load %union.bpf_attr*, %union.bpf_attr** %uattr.addr, align 8
  %54 = bitcast %union.bpf_attr* %53 to %struct.anon.10*
  %func_info_rec_size42 = getelementptr inbounds %struct.anon.10, %struct.anon.10* %54, i32 0, i32 13
  %55 = bitcast i32* %func_info_rec_size42 to i8*
  store i8* %55, i8** %__ptr_pu, align 8
  %56 = load i32, i32* %min_size, align 4
  store i32 %56, i32* %__val_pu, align 4
  %57 = call i64 @llvm.read_register.i64(metadata !5)
  %58 = load i8*, i8** %__ptr_pu, align 8
  %59 = load i32, i32* %__val_pu, align 4
  %60 = call { i8*, i64 } asm sideeffect "call __put_user_${4:P}", "={cx},={rsp},0,{rax},i,{rsp},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %58, i32 %59, i64 4, i64 %57) #10, !srcloc !74
  %asmresult = extractvalue { i8*, i64 } %60, 0
  %asmresult43 = extractvalue { i8*, i64 } %60, 1
  %61 = ptrtoint i8* %asmresult to i64
  %62 = trunc i64 %61 to i32
  store i32 %62, i32* %__ret_pu, align 4
  call void @llvm.write_register.i64(metadata !5, i64 %asmresult43)
  %63 = load i32, i32* %__ret_pu, align 4
  %conv45 = sext i32 %63 to i64
  store i64 %conv45, i64* %tmp44, align 8
  %64 = load i64, i64* %tmp44, align 8
  store i64 %64, i64* %tmp41, align 8
  %65 = load i64, i64* %tmp41, align 8
  %tobool46 = icmp ne i64 %65, 0
  br i1 %tobool46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.then40
  store i32 -14, i32* %ret, align 4
  br label %if.end48

if.end48:                                         ; preds = %if.then47, %if.then40
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.then37
  br label %err_free

if.end50:                                         ; preds = %for.body
  %66 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %67 = load i32, i32* %i, align 4
  %idxprom = zext i32 %67 to i64
  %arrayidx = getelementptr %struct.util_est, %struct.util_est* %66, i64 %idxprom
  %68 = bitcast %struct.util_est* %arrayidx to i8*
  %69 = load i8*, i8** %urecord, align 8
  %70 = load i32, i32* %min_size, align 4
  %conv51 = zext i32 %70 to i64
  store i8* %68, i8** %to.addr.i, align 8
  store i8* %69, i8** %from.addr.i, align 8
  store i64 %conv51, i64* %n.addr.i, align 8
  %71 = load i8*, i8** %to.addr.i, align 8
  %72 = load i64, i64* %n.addr.i, align 8
  store i8* %71, i8** %addr.addr.i.i, align 8
  store i64 %72, i64* %bytes.addr.i.i, align 8
  store i8 0, i8* %is_source.addr.i.i, align 1
  store i32 -1, i32* %sz.i.i, align 4
  %73 = load i32, i32* %sz.i.i, align 4
  %cmp.i.i = icmp sge i32 %73, 0
  br i1 %cmp.i.i, label %land.rhs.i.i, label %land.end.i.i

land.rhs.i.i:                                     ; preds = %if.end50
  %74 = load i32, i32* %sz.i.i, align 4
  %conv.i.i = sext i32 %74 to i64
  %75 = load i64, i64* %bytes.addr.i.i, align 8
  %cmp1.i.i = icmp ult i64 %conv.i.i, %75
  br label %land.end.i.i

land.end.i.i:                                     ; preds = %land.rhs.i.i, %if.end50
  %76 = phi i1 [ false, %if.end50 ], [ %cmp1.i.i, %land.rhs.i.i ]
  %lnot.i.i = xor i1 %76, true
  %lnot.ext.i.i = zext i1 %76 to i32
  %conv4.i.i = sext i32 %lnot.ext.i.i to i64
  br i1 %76, label %if.then.i.i, label %if.end10.i.i

if.then.i.i:                                      ; preds = %land.end.i.i
  %77 = load i64, i64* %bytes.addr.i.i, align 8
  %78 = call i1 @llvm.is.constant.i64(i64 %77) #10
  br i1 %78, label %if.else.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.then.i.i
  %79 = load i32, i32* %sz.i.i, align 4
  %80 = load i64, i64* %bytes.addr.i.i, align 8
  call void @copy_overflow(i32 noundef %79, i64 noundef %80) #13
  br label %if.end9.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %81 = load i8, i8* %is_source.addr.i.i, align 1
  %tobool6.i.i = trunc i8 %81 to i1
  br i1 %tobool6.i.i, label %if.then7.i.i, label %if.else8.i.i

if.then7.i.i:                                     ; preds = %if.else.i.i
  call void @__bad_copy_from() #13
  br label %if.end.i.i

if.else8.i.i:                                     ; preds = %if.else.i.i
  call void @__bad_copy_to() #13
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.else8.i.i, %if.then7.i.i
  br label %if.end9.i.i

if.end9.i.i:                                      ; preds = %if.end.i.i, %if.then5.i.i
  store i1 false, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

if.end10.i.i:                                     ; preds = %land.end.i.i
  %82 = load i64, i64* %bytes.addr.i.i, align 8
  %cmp11.i.i = icmp ugt i64 %82, 2147483647
  %lnot13.i.i = xor i1 %cmp11.i.i, true
  %lnot.ext16.i.i = zext i1 %cmp11.i.i to i32
  store i32 %lnot.ext16.i.i, i32* %__ret_warn_on.i.i, align 4
  %83 = load i32, i32* %__ret_warn_on.i.i, align 4
  %tobool17.i.i = icmp ne i32 %83, 0
  %lnot18.i.i = xor i1 %tobool17.i.i, true
  %lnot.ext21.i.i = zext i1 %tobool17.i.i to i32
  %conv22.i.i = sext i32 %lnot.ext21.i.i to i64
  br i1 %tobool17.i.i, label %if.then24.i.i, label %if.end31.i.i

if.then24.i.i:                                    ; preds = %if.end10.i.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.25, i64 0, i64 0), i32 150, i32 2307, i64 12) #10, !srcloc !8
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 33) #10, !srcloc !9
  br label %if.end31.i.i

if.end31.i.i:                                     ; preds = %if.then24.i.i, %if.end10.i.i
  %84 = load i32, i32* %__ret_warn_on.i.i, align 4
  %tobool32.i.i = icmp ne i32 %84, 0
  %lnot33.i.i = xor i1 %tobool32.i.i, true
  %lnot.ext36.i.i = zext i1 %tobool32.i.i to i32
  %conv37.i.i = sext i32 %lnot.ext36.i.i to i64
  store i64 %conv37.i.i, i64* %tmp.i.i, align 8
  %85 = load i64, i64* %tmp.i.i, align 8
  %tobool38.i.i = icmp ne i64 %85, 0
  br i1 %tobool38.i.i, label %if.then39.i.i, label %if.end40.i.i

if.then39.i.i:                                    ; preds = %if.end31.i.i
  store i1 false, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

if.end40.i.i:                                     ; preds = %if.end31.i.i
  %86 = load i8*, i8** %addr.addr.i.i, align 8
  %87 = load i64, i64* %bytes.addr.i.i, align 8
  %88 = load i8, i8* %is_source.addr.i.i, align 1
  %tobool41.i.i = trunc i8 %88 to i1
  call void @check_object_size(i8* noundef %86, i64 noundef %87, i1 noundef zeroext %tobool41.i.i) #13
  store i1 true, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

check_copy_size.exit.i:                           ; preds = %if.end40.i.i, %if.then39.i.i, %if.end9.i.i
  %89 = load i1, i1* %retval.i.i, align 1
  %lnot.i = xor i1 %89, true
  %lnot.ext.i = zext i1 %89 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %89, label %if.then.i, label %copy_from_user.exit

if.then.i:                                        ; preds = %check_copy_size.exit.i
  %90 = load i8*, i8** %to.addr.i, align 8
  %91 = load i8*, i8** %from.addr.i, align 8
  %92 = load i64, i64* %n.addr.i, align 8
  %call2.i = call i64 @_copy_from_user(i8* noundef %90, i8* noundef %91, i64 noundef %92) #13
  store i64 %call2.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.then.i, %check_copy_size.exit.i
  %93 = load i64, i64* %n.addr.i, align 8
  %tobool53 = icmp ne i64 %93, 0
  br i1 %tobool53, label %if.then54, label %if.end55

if.then54:                                        ; preds = %copy_from_user.exit
  store i32 -14, i32* %ret, align 4
  br label %err_free

if.end55:                                         ; preds = %copy_from_user.exit
  store i32 -22, i32* %ret, align 4
  %94 = load i32, i32* %i, align 4
  %cmp56 = icmp eq i32 %94, 0
  br i1 %cmp56, label %if.then58, label %if.else

if.then58:                                        ; preds = %if.end55
  %95 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %96 = load i32, i32* %i, align 4
  %idxprom59 = zext i32 %96 to i64
  %arrayidx60 = getelementptr %struct.util_est, %struct.util_est* %95, i64 %idxprom59
  %insn_off = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx60, i32 0, i32 0
  %97 = load i32, i32* %insn_off, align 4
  %tobool61 = icmp ne i32 %97, 0
  br i1 %tobool61, label %if.then62, label %if.end66

if.then62:                                        ; preds = %if.then58
  %98 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %99 = bitcast %struct.bpf_verifier_env* %98 to i8*
  %100 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %101 = load i32, i32* %i, align 4
  %idxprom63 = zext i32 %101 to i64
  %arrayidx64 = getelementptr %struct.util_est, %struct.util_est* %100, i64 %idxprom63
  %insn_off65 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx64, i32 0, i32 0
  %102 = load i32, i32* %insn_off65, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %99, i8* noundef getelementptr inbounds ([51 x i8], [51 x i8]* @.str.42, i64 0, i64 0), i32 noundef %102) #11
  br label %err_free

if.end66:                                         ; preds = %if.then58
  br label %if.end77

if.else:                                          ; preds = %if.end55
  %103 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %104 = load i32, i32* %i, align 4
  %idxprom67 = zext i32 %104 to i64
  %arrayidx68 = getelementptr %struct.util_est, %struct.util_est* %103, i64 %idxprom67
  %insn_off69 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx68, i32 0, i32 0
  %105 = load i32, i32* %insn_off69, align 4
  %106 = load i32, i32* %prev_offset, align 4
  %cmp70 = icmp ule i32 %105, %106
  br i1 %cmp70, label %if.then72, label %if.end76

if.then72:                                        ; preds = %if.else
  %107 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %108 = bitcast %struct.bpf_verifier_env* %107 to i8*
  %109 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %110 = load i32, i32* %i, align 4
  %idxprom73 = zext i32 %110 to i64
  %arrayidx74 = getelementptr %struct.util_est, %struct.util_est* %109, i64 %idxprom73
  %insn_off75 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx74, i32 0, i32 0
  %111 = load i32, i32* %insn_off75, align 4
  %112 = load i32, i32* %prev_offset, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %108, i8* noundef getelementptr inbounds ([69 x i8], [69 x i8]* @.str.43, i64 0, i64 0), i32 noundef %111, i32 noundef %112) #11
  br label %err_free

if.end76:                                         ; preds = %if.else
  br label %if.end77

if.end77:                                         ; preds = %if.end76, %if.end66
  %113 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %113, i32 0, i32 23
  %114 = load i32, i32* %i, align 4
  %idxprom78 = zext i32 %114 to i64
  %arrayidx79 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom78
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx79, i32 0, i32 0
  %115 = load i32, i32* %start, align 8
  %116 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %117 = load i32, i32* %i, align 4
  %idxprom80 = zext i32 %117 to i64
  %arrayidx81 = getelementptr %struct.util_est, %struct.util_est* %116, i64 %idxprom80
  %insn_off82 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx81, i32 0, i32 0
  %118 = load i32, i32* %insn_off82, align 4
  %cmp83 = icmp ne i32 %115, %118
  br i1 %cmp83, label %if.then85, label %if.end86

if.then85:                                        ; preds = %if.end77
  %119 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %120 = bitcast %struct.bpf_verifier_env* %119 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %120, i8* noundef getelementptr inbounds ([67 x i8], [67 x i8]* @.str.44, i64 0, i64 0)) #11
  br label %err_free

if.end86:                                         ; preds = %if.end77
  %121 = load %struct.btf*, %struct.btf** %btf, align 8
  %122 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %123 = load i32, i32* %i, align 4
  %idxprom87 = zext i32 %123 to i64
  %arrayidx88 = getelementptr %struct.util_est, %struct.util_est* %122, i64 %idxprom87
  %type_id = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx88, i32 0, i32 1
  %124 = load i32, i32* %type_id, align 4
  %call89 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %121, i32 noundef %124) #11
  store %struct.btf_type* %call89, %struct.btf_type** %type, align 8
  %125 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %tobool90 = icmp ne %struct.btf_type* %125, null
  br i1 %tobool90, label %lor.lhs.false91, label %if.then93

lor.lhs.false91:                                  ; preds = %if.end86
  %126 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %call92 = call zeroext i1 @btf_type_is_func(%struct.btf_type* noundef %126) #11
  br i1 %call92, label %if.end97, label %if.then93

if.then93:                                        ; preds = %lor.lhs.false91, %if.end86
  %127 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %128 = bitcast %struct.bpf_verifier_env* %127 to i8*
  %129 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %130 = load i32, i32* %i, align 4
  %idxprom94 = zext i32 %130 to i64
  %arrayidx95 = getelementptr %struct.util_est, %struct.util_est* %129, i64 %idxprom94
  %type_id96 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx95, i32 0, i32 1
  %131 = load i32, i32* %type_id96, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %128, i8* noundef getelementptr inbounds ([32 x i8], [32 x i8]* @.str.45, i64 0, i64 0), i32 noundef %131) #11
  br label %err_free

if.end97:                                         ; preds = %lor.lhs.false91
  %132 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %132, i32 0, i32 1
  %133 = load i32, i32* %info, align 4
  %and = and i32 %133, 65535
  %conv98 = trunc i32 %and to i16
  %134 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %info_aux, align 8
  %135 = load i32, i32* %i, align 4
  %idxprom99 = zext i32 %135 to i64
  %arrayidx100 = getelementptr %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %134, i64 %idxprom99
  %linkage = getelementptr inbounds %struct.bpf_func_info_aux, %struct.bpf_func_info_aux* %arrayidx100, i32 0, i32 0
  store i16 %conv98, i16* %linkage, align 2
  %136 = load %struct.btf*, %struct.btf** %btf, align 8
  %137 = load %struct.btf_type*, %struct.btf_type** %type, align 8
  %138 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %137, i32 0, i32 2
  %type101 = bitcast %struct.atomic_t* %138 to i32*
  %139 = load i32, i32* %type101, align 4
  %call102 = call %struct.btf_type* @btf_type_by_id(%struct.btf* noundef %136, i32 noundef %139) #11
  store %struct.btf_type* %call102, %struct.btf_type** %func_proto, align 8
  %140 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %tobool103 = icmp ne %struct.btf_type* %140, null
  br i1 %tobool103, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.end97
  %141 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %call104 = call zeroext i1 @btf_type_is_func_proto(%struct.btf_type* noundef %141) #11
  %lnot = xor i1 %call104, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end97
  %142 = phi i1 [ true, %if.end97 ], [ %lnot, %lor.rhs ]
  %lnot105 = xor i1 %142, true
  %lnot106 = xor i1 %lnot105, true
  %lnot.ext = zext i1 %lnot106 to i32
  %conv107 = sext i32 %lnot.ext to i64
  %tobool108 = icmp ne i64 %conv107, 0
  br i1 %tobool108, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.end
  br label %err_free

if.end110:                                        ; preds = %lor.end
  %143 = load %struct.btf*, %struct.btf** %btf, align 8
  %144 = load %struct.btf_type*, %struct.btf_type** %func_proto, align 8
  %145 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %144, i32 0, i32 2
  %type111 = bitcast %struct.atomic_t* %145 to i32*
  %146 = load i32, i32* %type111, align 4
  %call112 = call %struct.btf_type* @btf_type_skip_modifiers(%struct.btf* noundef %143, i32 noundef %146, i32* noundef null) #11
  store %struct.btf_type* %call112, %struct.btf_type** %ret_type, align 8
  %147 = load %struct.btf_type*, %struct.btf_type** %ret_type, align 8
  %call113 = call zeroext i1 @btf_type_is_small_int(%struct.btf_type* noundef %147) #11
  br i1 %call113, label %lor.end118, label %lor.rhs115

lor.rhs115:                                       ; preds = %if.end110
  %148 = load %struct.btf_type*, %struct.btf_type** %ret_type, align 8
  %call116 = call zeroext i1 @btf_type_is_enum(%struct.btf_type* noundef %148) #11
  br label %lor.end118

lor.end118:                                       ; preds = %lor.rhs115, %if.end110
  %149 = phi i1 [ true, %if.end110 ], [ %call116, %lor.rhs115 ]
  %frombool = zext i1 %149 to i8
  store i8 %frombool, i8* %scalar_return, align 1
  %150 = load i32, i32* %i, align 4
  %tobool119 = icmp ne i32 %150, 0
  br i1 %tobool119, label %land.lhs.true, label %if.end128

land.lhs.true:                                    ; preds = %lor.end118
  %151 = load i8, i8* %scalar_return, align 1
  %tobool120 = trunc i8 %151 to i1
  br i1 %tobool120, label %if.end128, label %land.lhs.true121

land.lhs.true121:                                 ; preds = %land.lhs.true
  %152 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info122 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %152, i32 0, i32 23
  %153 = load i32, i32* %i, align 4
  %idxprom123 = zext i32 %153 to i64
  %arrayidx124 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info122, i64 0, i64 %idxprom123
  %has_ld_abs = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx124, i32 0, i32 5
  %154 = load i8, i8* %has_ld_abs, align 4
  %tobool125 = trunc i8 %154 to i1
  br i1 %tobool125, label %if.then127, label %if.end128

if.then127:                                       ; preds = %land.lhs.true121
  %155 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %156 = bitcast %struct.bpf_verifier_env* %155 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %156, i8* noundef getelementptr inbounds ([56 x i8], [56 x i8]* @.str.46, i64 0, i64 0)) #11
  br label %err_free

if.end128:                                        ; preds = %land.lhs.true121, %land.lhs.true, %lor.end118
  %157 = load i32, i32* %i, align 4
  %tobool129 = icmp ne i32 %157, 0
  br i1 %tobool129, label %land.lhs.true130, label %if.end139

land.lhs.true130:                                 ; preds = %if.end128
  %158 = load i8, i8* %scalar_return, align 1
  %tobool131 = trunc i8 %158 to i1
  br i1 %tobool131, label %if.end139, label %land.lhs.true132

land.lhs.true132:                                 ; preds = %land.lhs.true130
  %159 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info133 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %159, i32 0, i32 23
  %160 = load i32, i32* %i, align 4
  %idxprom134 = zext i32 %160 to i64
  %arrayidx135 = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info133, i64 0, i64 %idxprom134
  %has_tail_call = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx135, i32 0, i32 3
  %161 = load i8, i8* %has_tail_call, align 2
  %tobool136 = trunc i8 %161 to i1
  br i1 %tobool136, label %if.then138, label %if.end139

if.then138:                                       ; preds = %land.lhs.true132
  %162 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %163 = bitcast %struct.bpf_verifier_env* %162 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %163, i8* noundef getelementptr inbounds ([59 x i8], [59 x i8]* @.str.47, i64 0, i64 0)) #11
  br label %err_free

if.end139:                                        ; preds = %land.lhs.true132, %land.lhs.true130, %if.end128
  %164 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %165 = load i32, i32* %i, align 4
  %idxprom140 = zext i32 %165 to i64
  %arrayidx141 = getelementptr %struct.util_est, %struct.util_est* %164, i64 %idxprom140
  %insn_off142 = getelementptr inbounds %struct.util_est, %struct.util_est* %arrayidx141, i32 0, i32 0
  %166 = load i32, i32* %insn_off142, align 4
  store i32 %166, i32* %prev_offset, align 4
  %167 = load i32, i32* %urec_size, align 4
  %168 = load i8*, i8** %urecord, align 8
  %idx.ext = zext i32 %167 to i64
  %add.ptr = getelementptr i8, i8* %168, i64 %idx.ext
  store i8* %add.ptr, i8** %urecord, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end139
  %169 = load i32, i32* %i, align 4
  %inc = add i32 %169, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %170 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %171 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux143 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %171, i32 0, i32 7
  %172 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux143, align 8
  %func_info144 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %172, i32 0, i32 45
  store %struct.util_est* %170, %struct.util_est** %func_info144, align 8
  %173 = load i32, i32* %nfuncs, align 4
  %174 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux145 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %174, i32 0, i32 7
  %175 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux145, align 8
  %func_info_cnt146 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %175, i32 0, i32 49
  store i32 %173, i32* %func_info_cnt146, align 8
  %176 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %info_aux, align 8
  %177 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux147 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %177, i32 0, i32 7
  %178 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux147, align 8
  %func_info_aux = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %178, i32 0, i32 46
  store %struct.bpf_func_info_aux* %176, %struct.bpf_func_info_aux** %func_info_aux, align 8
  store i32 0, i32* %retval, align 4
  br label %return

err_free:                                         ; preds = %if.then138, %if.then127, %if.then109, %if.then93, %if.then85, %if.then72, %if.then62, %if.then54, %if.end49, %if.then29
  %179 = load %struct.util_est*, %struct.util_est** %krecord, align 8
  %180 = bitcast %struct.util_est* %179 to i8*
  call void @kvfree(i8* noundef %180) #11
  %181 = load %struct.bpf_func_info_aux*, %struct.bpf_func_info_aux** %info_aux, align 8
  %182 = bitcast %struct.bpf_func_info_aux* %181 to i8*
  call void @kfree(i8* noundef %182) #11
  %183 = load i32, i32* %ret, align 4
  store i32 %183, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free, %for.end, %if.then24, %if.then10, %if.then4, %if.end, %if.then2
  %184 = load i32, i32* %retval, align 4
  ret i32 %184
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @check_btf_line(%struct.bpf_verifier_env* noundef %env, %union.bpf_attr* noundef %attr, %union.bpf_attr* noundef %uattr) #0 {
entry:
  %retval.i.i = alloca i1, align 1
  %addr.addr.i.i = alloca i8*, align 8
  %bytes.addr.i.i = alloca i64, align 8
  %is_source.addr.i.i = alloca i8, align 1
  %sz.i.i = alloca i32, align 4
  %__ret_warn_on.i.i = alloca i32, align 4
  %tmp.i.i = alloca i64, align 8
  %to.addr.i = alloca i8*, align 8
  %from.addr.i = alloca i8*, align 8
  %n.addr.i = alloca i64, align 8
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %attr.addr = alloca %union.bpf_attr*, align 8
  %uattr.addr = alloca %union.bpf_attr*, align 8
  %i = alloca i32, align 4
  %s = alloca i32, align 4
  %nr_linfo = alloca i32, align 4
  %ncopy = alloca i32, align 4
  %expected_size = alloca i32, align 4
  %rec_size = alloca i32, align 4
  %prev_offset = alloca i32, align 4
  %sub = alloca %struct.bpf_subprog_info*, align 8
  %linfo = alloca %struct.ethtool_pauseparam*, align 8
  %prog = alloca %struct.bpf_prog*, align 8
  %btf = alloca %struct.btf*, align 8
  %ulinfo = alloca i8*, align 8
  %err = alloca i32, align 4
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %tmp = alloca i32, align 4
  %tmp17 = alloca i8*, align 8
  %__UNIQUE_ID___x487 = alloca i32, align 4
  %__UNIQUE_ID___y488 = alloca i32, align 4
  %tmp18 = alloca i32, align 4
  %tmp31 = alloca i64, align 8
  %__ret_pu = alloca i32, align 4
  %__ptr_pu = alloca i8*, align 8
  %__val_pu = alloca i32, align 4
  %tmp34 = alloca i64, align 8
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store %union.bpf_attr* %attr, %union.bpf_attr** %attr.addr, align 8
  store %union.bpf_attr* %uattr, %union.bpf_attr** %uattr.addr, align 8
  store i32 0, i32* %prev_offset, align 4
  %0 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %1 = bitcast %union.bpf_attr* %0 to %struct.anon.10*
  %line_info_cnt = getelementptr inbounds %struct.anon.10, %struct.anon.10* %1, i32 0, i32 18
  %2 = load i32, i32* %line_info_cnt, align 8
  store i32 %2, i32* %nr_linfo, align 4
  %3 = load i32, i32* %nr_linfo, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %5 = bitcast %union.bpf_attr* %4 to %struct.anon.10*
  %line_info_rec_size = getelementptr inbounds %struct.anon.10, %struct.anon.10* %5, i32 0, i32 16
  %6 = load i32, i32* %line_info_rec_size, align 4
  store i32 %6, i32* %rec_size, align 4
  %7 = load i32, i32* %rec_size, align 4
  %conv = zext i32 %7 to i64
  %cmp = icmp ult i64 %conv, 16
  br i1 %cmp, label %if.then7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %8 = load i32, i32* %rec_size, align 4
  %cmp2 = icmp ugt i32 %8, 252
  br i1 %cmp2, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %9 = load i32, i32* %rec_size, align 4
  %conv5 = zext i32 %9 to i64
  %and = and i64 %conv5, 3
  %tobool6 = icmp ne i64 %and, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %lor.lhs.false4, %lor.lhs.false, %if.end
  store i32 -22, i32* %retval, align 4
  br label %return

if.end8:                                          ; preds = %lor.lhs.false4
  %10 = load i32, i32* %nr_linfo, align 4
  %conv9 = zext i32 %10 to i64
  %call = call i8* @kvcalloc(i64 noundef %conv9, i64 noundef 16, i32 noundef 11456) #11
  %11 = bitcast i8* %call to %struct.ethtool_pauseparam*
  store %struct.ethtool_pauseparam* %11, %struct.ethtool_pauseparam** %linfo, align 8
  %12 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %tobool10 = icmp ne %struct.ethtool_pauseparam* %12, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end8
  store i32 -12, i32* %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end8
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog13 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %13, i32 0, i32 2
  %14 = load %struct.bpf_prog*, %struct.bpf_prog** %prog13, align 8
  store %struct.bpf_prog* %14, %struct.bpf_prog** %prog, align 8
  %15 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %15, i32 0, i32 7
  %16 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux, align 8
  %btf14 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %16, i32 0, i32 44
  %17 = load %struct.btf*, %struct.btf** %btf14, align 8
  store %struct.btf* %17, %struct.btf** %btf, align 8
  store i32 0, i32* %s, align 4
  %18 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %18, i32 0, i32 23
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 0
  store %struct.bpf_subprog_info* %arraydecay, %struct.bpf_subprog_info** %sub, align 8
  %cmp15 = icmp eq i64* %__dummy, %__dummy2
  %conv16 = zext i1 %cmp15 to i32
  store i32 1, i32* %tmp, align 4
  %19 = load i32, i32* %tmp, align 4
  %20 = load %union.bpf_attr*, %union.bpf_attr** %attr.addr, align 8
  %21 = bitcast %union.bpf_attr* %20 to %struct.anon.10*
  %line_info = getelementptr inbounds %struct.anon.10, %struct.anon.10* %21, i32 0, i32 17
  %22 = load i64, i64* %line_info, align 8
  %23 = inttoptr i64 %22 to i8*
  store i8* %23, i8** %tmp17, align 8
  %24 = load i8*, i8** %tmp17, align 8
  store i8* %24, i8** %ulinfo, align 8
  store i32 16, i32* %expected_size, align 4
  %25 = load i32, i32* %expected_size, align 4
  store i32 %25, i32* %__UNIQUE_ID___x487, align 4
  %26 = load i32, i32* %rec_size, align 4
  store i32 %26, i32* %__UNIQUE_ID___y488, align 4
  %27 = load i32, i32* %__UNIQUE_ID___x487, align 4
  %28 = load i32, i32* %__UNIQUE_ID___y488, align 4
  %cmp19 = icmp ult i32 %27, %28
  br i1 %cmp19, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end12
  %29 = load i32, i32* %__UNIQUE_ID___x487, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end12
  %30 = load i32, i32* %__UNIQUE_ID___y488, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %29, %cond.true ], [ %30, %cond.false ]
  store i32 %cond, i32* %tmp18, align 4
  %31 = load i32, i32* %tmp18, align 4
  store i32 %31, i32* %ncopy, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %32 = load i32, i32* %i, align 4
  %33 = load i32, i32* %nr_linfo, align 4
  %cmp21 = icmp ult i32 %32, %33
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %34 = load i8*, i8** %ulinfo, align 8
  %35 = load i32, i32* %expected_size, align 4
  %conv23 = zext i32 %35 to i64
  %36 = load i32, i32* %rec_size, align 4
  %conv24 = zext i32 %36 to i64
  %call25 = call i32 @bpf_check_uarg_tail_zero(i8* noundef %34, i64 noundef %conv23, i64 noundef %conv24) #11
  store i32 %call25, i32* %err, align 4
  %37 = load i32, i32* %err, align 4
  %tobool26 = icmp ne i32 %37, 0
  br i1 %tobool26, label %if.then27, label %if.end40

if.then27:                                        ; preds = %for.body
  %38 = load i32, i32* %err, align 4
  %cmp28 = icmp eq i32 %38, -7
  br i1 %cmp28, label %if.then30, label %if.end39

if.then30:                                        ; preds = %if.then27
  %39 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %40 = bitcast %struct.bpf_verifier_env* %39 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %40, i8* noundef getelementptr inbounds ([36 x i8], [36 x i8]* @.str.48, i64 0, i64 0)) #11
  call void @might_fault() #11
  %41 = load %union.bpf_attr*, %union.bpf_attr** %uattr.addr, align 8
  %42 = bitcast %union.bpf_attr* %41 to %struct.anon.10*
  %line_info_rec_size32 = getelementptr inbounds %struct.anon.10, %struct.anon.10* %42, i32 0, i32 16
  %43 = bitcast i32* %line_info_rec_size32 to i8*
  store i8* %43, i8** %__ptr_pu, align 8
  %44 = load i32, i32* %expected_size, align 4
  store i32 %44, i32* %__val_pu, align 4
  %45 = call i64 @llvm.read_register.i64(metadata !5)
  %46 = load i8*, i8** %__ptr_pu, align 8
  %47 = load i32, i32* %__val_pu, align 4
  %48 = call { i8*, i64 } asm sideeffect "call __put_user_${4:P}", "={cx},={rsp},0,{rax},i,{rsp},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %46, i32 %47, i64 4, i64 %45) #10, !srcloc !75
  %asmresult = extractvalue { i8*, i64 } %48, 0
  %asmresult33 = extractvalue { i8*, i64 } %48, 1
  %49 = ptrtoint i8* %asmresult to i64
  %50 = trunc i64 %49 to i32
  store i32 %50, i32* %__ret_pu, align 4
  call void @llvm.write_register.i64(metadata !5, i64 %asmresult33)
  %51 = load i32, i32* %__ret_pu, align 4
  %conv35 = sext i32 %51 to i64
  store i64 %conv35, i64* %tmp34, align 8
  %52 = load i64, i64* %tmp34, align 8
  store i64 %52, i64* %tmp31, align 8
  %53 = load i64, i64* %tmp31, align 8
  %tobool36 = icmp ne i64 %53, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.then30
  store i32 -14, i32* %err, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.then30
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then27
  br label %err_free

if.end40:                                         ; preds = %for.body
  %54 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %55 = load i32, i32* %i, align 4
  %idxprom = zext i32 %55 to i64
  %arrayidx = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %54, i64 %idxprom
  %56 = bitcast %struct.ethtool_pauseparam* %arrayidx to i8*
  %57 = load i8*, i8** %ulinfo, align 8
  %58 = load i32, i32* %ncopy, align 4
  %conv41 = zext i32 %58 to i64
  store i8* %56, i8** %to.addr.i, align 8
  store i8* %57, i8** %from.addr.i, align 8
  store i64 %conv41, i64* %n.addr.i, align 8
  %59 = load i8*, i8** %to.addr.i, align 8
  %60 = load i64, i64* %n.addr.i, align 8
  store i8* %59, i8** %addr.addr.i.i, align 8
  store i64 %60, i64* %bytes.addr.i.i, align 8
  store i8 0, i8* %is_source.addr.i.i, align 1
  store i32 -1, i32* %sz.i.i, align 4
  %61 = load i32, i32* %sz.i.i, align 4
  %cmp.i.i = icmp sge i32 %61, 0
  br i1 %cmp.i.i, label %land.rhs.i.i, label %land.end.i.i

land.rhs.i.i:                                     ; preds = %if.end40
  %62 = load i32, i32* %sz.i.i, align 4
  %conv.i.i = sext i32 %62 to i64
  %63 = load i64, i64* %bytes.addr.i.i, align 8
  %cmp1.i.i = icmp ult i64 %conv.i.i, %63
  br label %land.end.i.i

land.end.i.i:                                     ; preds = %land.rhs.i.i, %if.end40
  %64 = phi i1 [ false, %if.end40 ], [ %cmp1.i.i, %land.rhs.i.i ]
  %lnot.i.i = xor i1 %64, true
  %lnot.ext.i.i = zext i1 %64 to i32
  %conv4.i.i = sext i32 %lnot.ext.i.i to i64
  br i1 %64, label %if.then.i.i, label %if.end10.i.i

if.then.i.i:                                      ; preds = %land.end.i.i
  %65 = load i64, i64* %bytes.addr.i.i, align 8
  %66 = call i1 @llvm.is.constant.i64(i64 %65) #10
  br i1 %66, label %if.else.i.i, label %if.then5.i.i

if.then5.i.i:                                     ; preds = %if.then.i.i
  %67 = load i32, i32* %sz.i.i, align 4
  %68 = load i64, i64* %bytes.addr.i.i, align 8
  call void @copy_overflow(i32 noundef %67, i64 noundef %68) #13
  br label %if.end9.i.i

if.else.i.i:                                      ; preds = %if.then.i.i
  %69 = load i8, i8* %is_source.addr.i.i, align 1
  %tobool6.i.i = trunc i8 %69 to i1
  br i1 %tobool6.i.i, label %if.then7.i.i, label %if.else8.i.i

if.then7.i.i:                                     ; preds = %if.else.i.i
  call void @__bad_copy_from() #13
  br label %if.end.i.i

if.else8.i.i:                                     ; preds = %if.else.i.i
  call void @__bad_copy_to() #13
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.else8.i.i, %if.then7.i.i
  br label %if.end9.i.i

if.end9.i.i:                                      ; preds = %if.end.i.i, %if.then5.i.i
  store i1 false, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

if.end10.i.i:                                     ; preds = %land.end.i.i
  %70 = load i64, i64* %bytes.addr.i.i, align 8
  %cmp11.i.i = icmp ugt i64 %70, 2147483647
  %lnot13.i.i = xor i1 %cmp11.i.i, true
  %lnot.ext16.i.i = zext i1 %cmp11.i.i to i32
  store i32 %lnot.ext16.i.i, i32* %__ret_warn_on.i.i, align 4
  %71 = load i32, i32* %__ret_warn_on.i.i, align 4
  %tobool17.i.i = icmp ne i32 %71, 0
  %lnot18.i.i = xor i1 %tobool17.i.i, true
  %lnot.ext21.i.i = zext i1 %tobool17.i.i to i32
  %conv22.i.i = sext i32 %lnot.ext21.i.i to i64
  br i1 %tobool17.i.i, label %if.then24.i.i, label %if.end31.i.i

if.then24.i.i:                                    ; preds = %if.end10.i.i
  call void asm sideeffect "1:\09.byte 0x0f, 0x0b\0A.pushsection __bug_table,\22aw\22\0A2:\09.long 1b - 2b\09# bug_entry::bug_addr\0A\09.long ${0:c} - 2b\09# bug_entry::file\0A\09.word ${1:c}\09# bug_entry::line\0A\09.word ${2:c}\09# bug_entry::flags\0A\09.org 2b+${3:c}\0A.popsection", "i,i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.25, i64 0, i64 0), i32 150, i32 2307, i64 12) #10, !srcloc !8
  call void asm sideeffect "${0:c}:\0A\09.pushsection .discard.reachable\0A\09.long ${0:c}b - .\0A\09.popsection\0A\09", "i,~{dirflag},~{fpsr},~{flags}"(i32 33) #10, !srcloc !9
  br label %if.end31.i.i

if.end31.i.i:                                     ; preds = %if.then24.i.i, %if.end10.i.i
  %72 = load i32, i32* %__ret_warn_on.i.i, align 4
  %tobool32.i.i = icmp ne i32 %72, 0
  %lnot33.i.i = xor i1 %tobool32.i.i, true
  %lnot.ext36.i.i = zext i1 %tobool32.i.i to i32
  %conv37.i.i = sext i32 %lnot.ext36.i.i to i64
  store i64 %conv37.i.i, i64* %tmp.i.i, align 8
  %73 = load i64, i64* %tmp.i.i, align 8
  %tobool38.i.i = icmp ne i64 %73, 0
  br i1 %tobool38.i.i, label %if.then39.i.i, label %if.end40.i.i

if.then39.i.i:                                    ; preds = %if.end31.i.i
  store i1 false, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

if.end40.i.i:                                     ; preds = %if.end31.i.i
  %74 = load i8*, i8** %addr.addr.i.i, align 8
  %75 = load i64, i64* %bytes.addr.i.i, align 8
  %76 = load i8, i8* %is_source.addr.i.i, align 1
  %tobool41.i.i = trunc i8 %76 to i1
  call void @check_object_size(i8* noundef %74, i64 noundef %75, i1 noundef zeroext %tobool41.i.i) #13
  store i1 true, i1* %retval.i.i, align 1
  br label %check_copy_size.exit.i

check_copy_size.exit.i:                           ; preds = %if.end40.i.i, %if.then39.i.i, %if.end9.i.i
  %77 = load i1, i1* %retval.i.i, align 1
  %lnot.i = xor i1 %77, true
  %lnot.ext.i = zext i1 %77 to i32
  %conv.i = sext i32 %lnot.ext.i to i64
  br i1 %77, label %if.then.i, label %copy_from_user.exit

if.then.i:                                        ; preds = %check_copy_size.exit.i
  %78 = load i8*, i8** %to.addr.i, align 8
  %79 = load i8*, i8** %from.addr.i, align 8
  %80 = load i64, i64* %n.addr.i, align 8
  %call2.i = call i64 @_copy_from_user(i8* noundef %78, i8* noundef %79, i64 noundef %80) #13
  store i64 %call2.i, i64* %n.addr.i, align 8
  br label %copy_from_user.exit

copy_from_user.exit:                              ; preds = %if.then.i, %check_copy_size.exit.i
  %81 = load i64, i64* %n.addr.i, align 8
  %tobool43 = icmp ne i64 %81, 0
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %copy_from_user.exit
  store i32 -14, i32* %err, align 4
  br label %err_free

if.end45:                                         ; preds = %copy_from_user.exit
  %82 = load i32, i32* %i, align 4
  %tobool46 = icmp ne i32 %82, 0
  br i1 %tobool46, label %land.lhs.true, label %lor.lhs.false51

land.lhs.true:                                    ; preds = %if.end45
  %83 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %84 = load i32, i32* %i, align 4
  %idxprom47 = zext i32 %84 to i64
  %arrayidx48 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %83, i64 %idxprom47
  %insn_off = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx48, i32 0, i32 0
  %85 = load i32, i32* %insn_off, align 4
  %86 = load i32, i32* %prev_offset, align 4
  %cmp49 = icmp ule i32 %85, %86
  br i1 %cmp49, label %if.then57, label %lor.lhs.false51

lor.lhs.false51:                                  ; preds = %land.lhs.true, %if.end45
  %87 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %88 = load i32, i32* %i, align 4
  %idxprom52 = zext i32 %88 to i64
  %arrayidx53 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %87, i64 %idxprom52
  %insn_off54 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx53, i32 0, i32 0
  %89 = load i32, i32* %insn_off54, align 4
  %90 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %90, i32 0, i32 4
  %91 = load i32, i32* %len, align 4
  %cmp55 = icmp uge i32 %89, %91
  br i1 %cmp55, label %if.then57, label %if.end62

if.then57:                                        ; preds = %lor.lhs.false51, %land.lhs.true
  %92 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %93 = bitcast %struct.bpf_verifier_env* %92 to i8*
  %94 = load i32, i32* %i, align 4
  %95 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %96 = load i32, i32* %i, align 4
  %idxprom58 = zext i32 %96 to i64
  %arrayidx59 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %95, i64 %idxprom58
  %insn_off60 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx59, i32 0, i32 0
  %97 = load i32, i32* %insn_off60, align 4
  %98 = load i32, i32* %prev_offset, align 4
  %99 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len61 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %99, i32 0, i32 4
  %100 = load i32, i32* %len61, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %93, i8* noundef getelementptr inbounds ([65 x i8], [65 x i8]* @.str.49, i64 0, i64 0), i32 noundef %94, i32 noundef %97, i32 noundef %98, i32 noundef %100) #11
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end62:                                         ; preds = %lor.lhs.false51
  %101 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %insnsi = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %101, i32 0, i32 11
  %102 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %103 = load i32, i32* %i, align 4
  %idxprom63 = zext i32 %103 to i64
  %arrayidx64 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %102, i64 %idxprom63
  %insn_off65 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx64, i32 0, i32 0
  %104 = load i32, i32* %insn_off65, align 4
  %idxprom66 = zext i32 %104 to i64
  %arrayidx67 = getelementptr [0 x %struct.bpf_insn], [0 x %struct.bpf_insn]* %insnsi, i64 0, i64 %idxprom66
  %code = getelementptr inbounds %struct.bpf_insn, %struct.bpf_insn* %arrayidx67, i32 0, i32 0
  %105 = load i8, i8* %code, align 8
  %tobool68 = icmp ne i8 %105, 0
  br i1 %tobool68, label %if.end70, label %if.then69

if.then69:                                        ; preds = %if.end62
  %106 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %107 = bitcast %struct.bpf_verifier_env* %106 to i8*
  %108 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %107, i8* noundef getelementptr inbounds ([45 x i8], [45 x i8]* @.str.50, i64 0, i64 0), i32 noundef %108) #11
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end70:                                         ; preds = %if.end62
  %109 = load %struct.btf*, %struct.btf** %btf, align 8
  %110 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %111 = load i32, i32* %i, align 4
  %idxprom71 = zext i32 %111 to i64
  %arrayidx72 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %110, i64 %idxprom71
  %line_off = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx72, i32 0, i32 2
  %112 = load i32, i32* %line_off, align 4
  %call73 = call i8* @btf_name_by_offset(%struct.btf* noundef %109, i32 noundef %112) #11
  %tobool74 = icmp ne i8* %call73, null
  br i1 %tobool74, label %lor.lhs.false75, label %if.then80

lor.lhs.false75:                                  ; preds = %if.end70
  %113 = load %struct.btf*, %struct.btf** %btf, align 8
  %114 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %115 = load i32, i32* %i, align 4
  %idxprom76 = zext i32 %115 to i64
  %arrayidx77 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %114, i64 %idxprom76
  %file_name_off = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx77, i32 0, i32 1
  %116 = load i32, i32* %file_name_off, align 4
  %call78 = call i8* @btf_name_by_offset(%struct.btf* noundef %113, i32 noundef %116) #11
  %tobool79 = icmp ne i8* %call78, null
  br i1 %tobool79, label %if.end81, label %if.then80

if.then80:                                        ; preds = %lor.lhs.false75, %if.end70
  %117 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %118 = bitcast %struct.bpf_verifier_env* %117 to i8*
  %119 = load i32, i32* %i, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %118, i8* noundef getelementptr inbounds ([50 x i8], [50 x i8]* @.str.51, i64 0, i64 0), i32 noundef %119) #11
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end81:                                         ; preds = %lor.lhs.false75
  %120 = load i32, i32* %s, align 4
  %121 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %121, i32 0, i32 26
  %122 = load i32, i32* %subprog_cnt, align 4
  %cmp82 = icmp ne i32 %120, %122
  br i1 %cmp82, label %if.then84, label %if.end106

if.then84:                                        ; preds = %if.end81
  %123 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %124 = load i32, i32* %i, align 4
  %idxprom85 = zext i32 %124 to i64
  %arrayidx86 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %123, i64 %idxprom85
  %insn_off87 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx86, i32 0, i32 0
  %125 = load i32, i32* %insn_off87, align 4
  %126 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %sub, align 8
  %127 = load i32, i32* %s, align 4
  %idxprom88 = zext i32 %127 to i64
  %arrayidx89 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %126, i64 %idxprom88
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx89, i32 0, i32 0
  %128 = load i32, i32* %start, align 4
  %cmp90 = icmp eq i32 %125, %128
  br i1 %cmp90, label %if.then92, label %if.else

if.then92:                                        ; preds = %if.then84
  %129 = load i32, i32* %i, align 4
  %130 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %sub, align 8
  %131 = load i32, i32* %s, align 4
  %idxprom93 = zext i32 %131 to i64
  %arrayidx94 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %130, i64 %idxprom93
  %linfo_idx = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx94, i32 0, i32 1
  store i32 %129, i32* %linfo_idx, align 4
  %132 = load i32, i32* %s, align 4
  %inc = add i32 %132, 1
  store i32 %inc, i32* %s, align 4
  br label %if.end105

if.else:                                          ; preds = %if.then84
  %133 = load %struct.bpf_subprog_info*, %struct.bpf_subprog_info** %sub, align 8
  %134 = load i32, i32* %s, align 4
  %idxprom95 = zext i32 %134 to i64
  %arrayidx96 = getelementptr %struct.bpf_subprog_info, %struct.bpf_subprog_info* %133, i64 %idxprom95
  %start97 = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx96, i32 0, i32 0
  %135 = load i32, i32* %start97, align 4
  %136 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %137 = load i32, i32* %i, align 4
  %idxprom98 = zext i32 %137 to i64
  %arrayidx99 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %136, i64 %idxprom98
  %insn_off100 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx99, i32 0, i32 0
  %138 = load i32, i32* %insn_off100, align 4
  %cmp101 = icmp ult i32 %135, %138
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %if.else
  %139 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %140 = bitcast %struct.bpf_verifier_env* %139 to i8*
  %141 = load i32, i32* %s, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %140, i8* noundef getelementptr inbounds ([35 x i8], [35 x i8]* @.str.52, i64 0, i64 0), i32 noundef %141) #11
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end104:                                        ; preds = %if.else
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %if.then92
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %if.end81
  %142 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %143 = load i32, i32* %i, align 4
  %idxprom107 = zext i32 %143 to i64
  %arrayidx108 = getelementptr %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %142, i64 %idxprom107
  %insn_off109 = getelementptr inbounds %struct.ethtool_pauseparam, %struct.ethtool_pauseparam* %arrayidx108, i32 0, i32 0
  %144 = load i32, i32* %insn_off109, align 4
  store i32 %144, i32* %prev_offset, align 4
  %145 = load i32, i32* %rec_size, align 4
  %146 = load i8*, i8** %ulinfo, align 8
  %idx.ext = zext i32 %145 to i64
  %add.ptr = getelementptr i8, i8* %146, i64 %idx.ext
  store i8* %add.ptr, i8** %ulinfo, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end106
  %147 = load i32, i32* %i, align 4
  %inc110 = add i32 %147, 1
  store i32 %inc110, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %148 = load i32, i32* %s, align 4
  %149 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt111 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %149, i32 0, i32 26
  %150 = load i32, i32* %subprog_cnt111, align 4
  %cmp112 = icmp ne i32 %148, %150
  br i1 %cmp112, label %if.then114, label %if.end117

if.then114:                                       ; preds = %for.end
  %151 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %152 = bitcast %struct.bpf_verifier_env* %151 to i8*
  %153 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt115 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %153, i32 0, i32 26
  %154 = load i32, i32* %subprog_cnt115, align 4
  %155 = load i32, i32* %s, align 4
  %sub116 = sub i32 %154, %155
  %156 = load i32, i32* %s, align 4
  call void (i8*, i8*, ...) @verbose(i8* noundef %152, i8* noundef getelementptr inbounds ([58 x i8], [58 x i8]* @.str.53, i64 0, i64 0), i32 noundef %sub116, i32 noundef %156) #11
  store i32 -22, i32* %err, align 4
  br label %err_free

if.end117:                                        ; preds = %for.end
  %157 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %158 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux118 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %158, i32 0, i32 7
  %159 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux118, align 8
  %linfo119 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %159, i32 0, i32 47
  store %struct.ethtool_pauseparam* %157, %struct.ethtool_pauseparam** %linfo119, align 8
  %160 = load i32, i32* %nr_linfo, align 4
  %161 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %aux120 = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %161, i32 0, i32 7
  %162 = load %struct.bpf_prog_aux*, %struct.bpf_prog_aux** %aux120, align 8
  %nr_linfo121 = getelementptr inbounds %struct.bpf_prog_aux, %struct.bpf_prog_aux* %162, i32 0, i32 50
  store i32 %160, i32* %nr_linfo121, align 4
  store i32 0, i32* %retval, align 4
  br label %return

err_free:                                         ; preds = %if.then114, %if.then103, %if.then80, %if.then69, %if.then57, %if.then44, %if.end39
  %163 = load %struct.ethtool_pauseparam*, %struct.ethtool_pauseparam** %linfo, align 8
  %164 = bitcast %struct.ethtool_pauseparam* %163 to i8*
  call void @kvfree(i8* noundef %164) #11
  %165 = load i32, i32* %err, align 4
  store i32 %165, i32* %retval, align 4
  br label %return

return:                                           ; preds = %err_free, %if.end117, %if.then11, %if.then7, %if.then
  %166 = load i32, i32* %retval, align 4
  ret i32 %166
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i32 @bpf_check_uarg_tail_zero(i8* noundef, i64 noundef, i64 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @_copy_from_user(i8* noundef, i8* noundef, i64 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_small_int(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %call = call zeroext i1 @btf_type_is_int(%struct.btf_type* noundef %0) #11
  br i1 %call, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %2 = getelementptr inbounds %struct.btf_type, %struct.btf_type* %1, i32 0, i32 2
  %size = bitcast %struct.atomic_t* %2 to i32*
  %3 = load i32, i32* %size, align 4
  %conv = zext i32 %3 to i64
  %cmp = icmp ule i64 %conv, 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  ret i1 %4
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_enum(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 15
  %cmp = icmp eq i32 %and, 6
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @btf_type_is_int(%struct.btf_type* noundef %t) #0 {
entry:
  %t.addr = alloca %struct.btf_type*, align 8
  store %struct.btf_type* %t, %struct.btf_type** %t.addr, align 8
  %0 = load %struct.btf_type*, %struct.btf_type** %t.addr, align 8
  %info = getelementptr inbounds %struct.btf_type, %struct.btf_type* %0, i32 0, i32 1
  %1 = load i32, i32* %info, align 4
  %shr = lshr i32 %1, 24
  %and = and i32 %shr, 15
  %cmp = icmp eq i32 %and, 1
  ret i1 %cmp
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i32 @add_subprog(%struct.bpf_verifier_env* noundef %env, i32 noundef %off) #0 {
entry:
  %retval = alloca i32, align 4
  %env.addr = alloca %struct.bpf_verifier_env*, align 8
  %off.addr = alloca i32, align 4
  %insn_cnt = alloca i32, align 4
  %ret = alloca i32, align 4
  store %struct.bpf_verifier_env* %env, %struct.bpf_verifier_env** %env.addr, align 8
  store i32 %off, i32* %off.addr, align 4
  %0 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %prog = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %0, i32 0, i32 2
  %1 = load %struct.bpf_prog*, %struct.bpf_prog** %prog, align 8
  %len = getelementptr inbounds %struct.bpf_prog, %struct.bpf_prog* %1, i32 0, i32 4
  %2 = load i32, i32* %len, align 4
  store i32 %2, i32* %insn_cnt, align 4
  %3 = load i32, i32* %off.addr, align 4
  %4 = load i32, i32* %insn_cnt, align 4
  %cmp = icmp sge i32 %3, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i32, i32* %off.addr, align 4
  %cmp1 = icmp slt i32 %5, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %7 = bitcast %struct.bpf_verifier_env* %6 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %7, i8* noundef getelementptr inbounds ([29 x i8], [29 x i8]* @.str.35, i64 0, i64 0)) #11
  store i32 -22, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %8 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %9 = load i32, i32* %off.addr, align 4
  %call = call i32 @find_subprog(%struct.bpf_verifier_env* noundef %8, i32 noundef %9) #11
  store i32 %call, i32* %ret, align 4
  %10 = load i32, i32* %ret, align 4
  %cmp2 = icmp sge i32 %10, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 0, i32* %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %11 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %11, i32 0, i32 26
  %12 = load i32, i32* %subprog_cnt, align 4
  %cmp5 = icmp uge i32 %12, 256
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  %13 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %14 = bitcast %struct.bpf_verifier_env* %13 to i8*
  call void (i8*, i8*, ...) @verbose(i8* noundef %14, i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.36, i64 0, i64 0)) #11
  store i32 -7, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end4
  %15 = load i32, i32* %off.addr, align 4
  %16 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %16, i32 0, i32 23
  %17 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt8 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %17, i32 0, i32 26
  %18 = load i32, i32* %subprog_cnt8, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %subprog_cnt8, align 4
  %idxprom = zext i32 %18 to i64
  %arrayidx = getelementptr [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info, i64 0, i64 %idxprom
  %start = getelementptr inbounds %struct.bpf_subprog_info, %struct.bpf_subprog_info* %arrayidx, i32 0, i32 0
  store i32 %15, i32* %start, align 8
  %19 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_info9 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %19, i32 0, i32 23
  %arraydecay = getelementptr inbounds [257 x %struct.bpf_subprog_info], [257 x %struct.bpf_subprog_info]* %subprog_info9, i64 0, i64 0
  %20 = bitcast %struct.bpf_subprog_info* %arraydecay to i8*
  %21 = load %struct.bpf_verifier_env*, %struct.bpf_verifier_env** %env.addr, align 8
  %subprog_cnt10 = getelementptr inbounds %struct.bpf_verifier_env, %struct.bpf_verifier_env* %21, i32 0, i32 26
  %22 = load i32, i32* %subprog_cnt10, align 4
  %conv = zext i32 %22 to i64
  call void @sort(i8* noundef %20, i64 noundef %conv, i64 noundef 16, i32 (i8*, i8*)* noundef @cmp_subprogs, void (i8*, i8*, i32)* noundef null) #11
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then3, %if.then
  %23 = load i32, i32* %retval, align 4
  ret i32 %23
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local void @sort(i8* noundef, i64 noundef, i64 noundef, i32 (i8*, i8*)* noundef, void (i8*, i8*, i32)* noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kvmalloc_array(i64 noundef %n, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %retval = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %bytes = alloca i64, align 8
  %__a = alloca i64, align 8
  %__b = alloca i64, align 8
  %__d = alloca i64*, align 8
  %tmp = alloca i8, align 1
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %n.addr, align 8
  store i64 %0, i64* %__a, align 8
  %1 = load i64, i64* %size.addr, align 8
  store i64 %1, i64* %__b, align 8
  store i64* %bytes, i64** %__d, align 8
  %cmp = icmp eq i64* %__a, %__b
  %conv = zext i1 %cmp to i32
  %2 = load i64*, i64** %__d, align 8
  %cmp1 = icmp eq i64* %__a, %2
  %conv2 = zext i1 %cmp1 to i32
  %3 = load i64, i64* %__a, align 8
  %4 = load i64, i64* %__b, align 8
  %5 = load i64*, i64** %__d, align 8
  %6 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %3, i64 %4)
  %7 = extractvalue { i64, i1 } %6, 1
  %8 = extractvalue { i64, i1 } %6, 0
  store i64 %8, i64* %5, align 8
  %frombool = zext i1 %7 to i8
  store i8 %frombool, i8* %tmp, align 1
  %9 = load i8, i8* %tmp, align 1
  %tobool = trunc i8 %9 to i1
  %call = call zeroext i1 @__must_check_overflow(i1 noundef zeroext %tobool) #11
  %lnot = xor i1 %call, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %tobool5 = icmp ne i64 %conv4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* null, i8** %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %bytes, align 8
  %11 = load i32, i32* %flags.addr, align 4
  %call6 = call i8* @kvmalloc(i64 noundef %10, i32 noundef %11) #11
  store i8* %call6, i8** %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i8*, i8** %retval, align 8
  ret i8* %12
}

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i8* @kvmalloc(i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* %size.addr, align 8
  %1 = load i32, i32* %flags.addr, align 4
  %call = call i8* @kvmalloc_node(i64 noundef %0, i32 noundef %1, i32 noundef -1) #11
  ret i8* %call
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i8* @kvmalloc_node(i64 noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal zeroext i1 @perfmon_capable() #0 {
entry:
  %call = call zeroext i1 @capable(i32 noundef 38) #11
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %call1 = call zeroext i1 @capable(i32 noundef 21) #11
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %0 = phi i1 [ true, %entry ], [ %call1, %lor.rhs ]
  ret i1 %0
}

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local zeroext i1 @capable(i32 noundef) #1

; Function Attrs: noredzone null_pointer_is_valid
declare dso_local i64 @ktime_get() #1

; Function Attrs: noinline noredzone nounwind null_pointer_is_valid sspstrong
define internal i64 @ktime_to_ns(i64 noundef %kt) #0 {
entry:
  %kt.addr = alloca i64, align 8
  store i64 %kt, i64* %kt.addr, align 8
  %0 = load i64, i64* %kt.addr, align 8
  ret i64 %0
}

attributes #0 = { noinline noredzone nounwind null_pointer_is_valid sspstrong "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" "warn-stack-size"="2048" }
attributes #1 = { noredzone null_pointer_is_valid "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #2 = { argmemonly nofree nounwind willreturn }
attributes #3 = { nofree nosync nounwind willreturn }
attributes #4 = { cold noredzone null_pointer_is_valid "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" }
attributes #5 = { convergent nofree nosync nounwind readnone willreturn }
attributes #6 = { noinline noredzone nounwind null_pointer_is_valid readnone sspstrong willreturn "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+retpoline-external-thunk,+retpoline-indirect-branches,+retpoline-indirect-calls,-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bf16,-avx512bitalg,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512fp16,-avx512ifma,-avx512pf,-avx512vbmi,-avx512vbmi2,-avx512vl,-avx512vnni,-avx512vp2intersect,-avx512vpopcntdq,-avxvnni,-f16c,-fma,-fma4,-gfni,-kl,-mmx,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-vaes,-vpclmulqdq,-widekl,-x87,-xop" "tune-cpu"="generic" "warn-stack-size"="2048" }
attributes #7 = { nofree nosync nounwind readnone speculatable willreturn }
attributes #8 = { argmemonly nofree nounwind willreturn writeonly }
attributes #9 = { nounwind readonly }
attributes #10 = { nounwind }
attributes #11 = { noredzone }
attributes #12 = { cold noredzone }
attributes #13 = { noredzone nounwind }
attributes #14 = { noredzone nounwind readnone willreturn }
attributes #15 = { nounwind readnone }

!llvm.ident = !{!0, !0}
!llvm.module.flags = !{!1, !2, !3, !4}
!llvm.named.register.rsp = !{!5}

!0 = !{!"Ubuntu clang version 14.0.0-1ubuntu1.1"}
!1 = !{i32 1, !"wchar_size", i32 2}
!2 = !{i32 1, !"Code Model", i32 2}
!3 = !{i32 1, !"override-stack-alignment", i32 8}
!4 = !{i32 4, !"SkipRaxSetup", i32 1}
!5 = !{!"rsp"}
!6 = !{i64 2156110303, i64 2156110332, i64 2156110378, i64 2156110436, i64 2156110490, i64 2156110544, i64 2156110599, i64 2156110630}
!7 = !{i64 2156111053, i64 2156111060, i64 2156111112, i64 2156111143, i64 2156111173}
!8 = !{i64 2149420295, i64 2149420324, i64 2149420370, i64 2149420428, i64 2149420482, i64 2149420536, i64 2149420591, i64 2149420622}
!9 = !{i64 2149421051, i64 2149421058, i64 2149421110, i64 2149421141, i64 2149421171}
!10 = !{i64 2149418462, i64 2149418491, i64 2149418537, i64 2149418595, i64 2149418649, i64 2149418703, i64 2149418758, i64 2149418789}
!11 = !{i64 2149419218, i64 2149419225, i64 2149419277, i64 2149419308, i64 2149419338}
!12 = !{i64 2150498408, i64 2150498437, i64 2150498483, i64 2150498541, i64 2150498595, i64 2150498649, i64 2150498704, i64 2150498735}
!13 = !{i64 2150499187, i64 2150499194, i64 2150499248, i64 2150499279, i64 2150499309}
!14 = !{i64 2156323680, i64 2156323709, i64 2156323755, i64 2156323813, i64 2156323867, i64 2156323921, i64 2156323976, i64 2156324007}
!15 = !{i64 2156324432, i64 2156324439, i64 2156324491, i64 2156324522, i64 2156324552}
!16 = !{i64 2156190370, i64 2156190399, i64 2156190445, i64 2156190503, i64 2156190557, i64 2156190611, i64 2156190666, i64 2156190697}
!17 = !{i64 2156191121, i64 2156191128, i64 2156191180, i64 2156191211, i64 2156191241}
!18 = !{i64 2156300127, i64 2156300156, i64 2156300202, i64 2156300260, i64 2156300314, i64 2156300368, i64 2156300423, i64 2156300454}
!19 = !{i64 2156300868, i64 2156300875, i64 2156300927, i64 2156300958, i64 2156300988}
!20 = !{i64 625445}
!21 = !{i64 2156303627, i64 2156303656, i64 2156303702, i64 2156303760, i64 2156303814, i64 2156303868, i64 2156303923, i64 2156303954}
!22 = !{i64 2156304379, i64 2156304386, i64 2156304438, i64 2156304469, i64 2156304499}
!23 = !{i64 2156196680, i64 2156196709, i64 2156196755, i64 2156196813, i64 2156196867, i64 2156196921, i64 2156196976, i64 2156197007}
!24 = !{i64 2156197431, i64 2156197438, i64 2156197490, i64 2156197521, i64 2156197551}
!25 = !{i64 2156131784, i64 2156131813, i64 2156131859, i64 2156131917, i64 2156131971, i64 2156132025, i64 2156132080, i64 2156132111}
!26 = !{i64 2156132524, i64 2156132531, i64 2156132583, i64 2156132614, i64 2156132644}
!27 = !{i64 2156167050, i64 2156167079, i64 2156167125, i64 2156167183, i64 2156167237, i64 2156167291, i64 2156167346, i64 2156167377}
!28 = !{i64 2156167790, i64 2156167797, i64 2156167849, i64 2156167880, i64 2156167910}
!29 = !{i64 2148657613}
!30 = !{i64 2156113462}
!31 = !{i64 2156122091, i64 2156122120, i64 2156122166, i64 2156122224, i64 2156122278, i64 2156122332, i64 2156122387, i64 2156122418}
!32 = !{i64 2156122841, i64 2156122848, i64 2156122900, i64 2156122931, i64 2156122961}
!33 = !{i64 2156124177, i64 2156124206, i64 2156124252, i64 2156124310, i64 2156124364, i64 2156124418, i64 2156124473, i64 2156124504}
!34 = !{i64 2156124927, i64 2156124934, i64 2156124986, i64 2156125017, i64 2156125047}
!35 = !{i64 2156288496, i64 2156288525, i64 2156288571, i64 2156288629, i64 2156288683, i64 2156288737, i64 2156288792, i64 2156288823}
!36 = !{i64 2156289248, i64 2156289255, i64 2156289307, i64 2156289338, i64 2156289368}
!37 = !{i64 2156291007, i64 2156291036, i64 2156291082, i64 2156291140, i64 2156291194, i64 2156291248, i64 2156291303, i64 2156291334}
!38 = !{i64 2156291759, i64 2156291766, i64 2156291818, i64 2156291849, i64 2156291879}
!39 = !{i64 2156129996, i64 2156130025, i64 2156130071, i64 2156130129, i64 2156130183, i64 2156130237, i64 2156130292, i64 2156130323}
!40 = !{i64 2156130747, i64 2156130754, i64 2156130806, i64 2156130837, i64 2156130867}
!41 = !{i64 2156264009, i64 2156264038, i64 2156264084, i64 2156264142, i64 2156264196, i64 2156264250, i64 2156264305, i64 2156264336}
!42 = !{i64 2156264760, i64 2156264767, i64 2156264819, i64 2156264850, i64 2156264880}
!43 = !{i64 2156265530, i64 2156265559, i64 2156265605, i64 2156265663, i64 2156265717, i64 2156265771, i64 2156265826, i64 2156265857}
!44 = !{i64 2156266281, i64 2156266288, i64 2156266340, i64 2156266371, i64 2156266401}
!45 = !{i64 2156168529, i64 2156168558, i64 2156168604, i64 2156168662, i64 2156168716, i64 2156168770, i64 2156168825, i64 2156168856}
!46 = !{i64 2156169269, i64 2156169276, i64 2156169328, i64 2156169359, i64 2156169389}
!47 = !{i64 2156261538, i64 2156261567, i64 2156261613, i64 2156261671, i64 2156261725, i64 2156261779, i64 2156261834, i64 2156261865}
!48 = !{i64 2156262289, i64 2156262296, i64 2156262348, i64 2156262379, i64 2156262409}
!49 = !{i64 2156257862, i64 2156257891, i64 2156257937, i64 2156257995, i64 2156258049, i64 2156258103, i64 2156258158, i64 2156258189}
!50 = !{i64 2156258613, i64 2156258620, i64 2156258672, i64 2156258703, i64 2156258733}
!51 = !{i64 2156259428, i64 2156259457, i64 2156259503, i64 2156259561, i64 2156259615, i64 2156259669, i64 2156259724, i64 2156259755}
!52 = !{i64 2156260179, i64 2156260186, i64 2156260238, i64 2156260269, i64 2156260299}
!53 = !{i64 2156178280, i64 2156178309, i64 2156178355, i64 2156178413, i64 2156178467, i64 2156178521, i64 2156178576, i64 2156178607}
!54 = !{i64 2156179031, i64 2156179038, i64 2156179090, i64 2156179121, i64 2156179151}
!55 = !{i64 2156180689, i64 2156180718, i64 2156180764, i64 2156180822, i64 2156180876, i64 2156180930, i64 2156180985, i64 2156181016}
!56 = !{i64 2156181440, i64 2156181447, i64 2156181499, i64 2156181530, i64 2156181560}
!57 = !{i64 2156171734, i64 2156171763, i64 2156171809, i64 2156171867, i64 2156171921, i64 2156171975, i64 2156172030, i64 2156172061}
!58 = !{i64 2156172485, i64 2156172492, i64 2156172544, i64 2156172575, i64 2156172605}
!59 = !{i64 2156173940, i64 2156173969, i64 2156174015, i64 2156174073, i64 2156174127, i64 2156174181, i64 2156174236, i64 2156174267}
!60 = !{i64 2156174691, i64 2156174698, i64 2156174750, i64 2156174781, i64 2156174811}
!61 = !{i64 2156176113, i64 2156176142, i64 2156176188, i64 2156176246, i64 2156176300, i64 2156176354, i64 2156176409, i64 2156176440}
!62 = !{i64 2156176864, i64 2156176871, i64 2156176923, i64 2156176954, i64 2156176984}
!63 = !{i64 2156214554, i64 2156214583, i64 2156214629, i64 2156214687, i64 2156214741, i64 2156214795, i64 2156214850, i64 2156214881}
!64 = !{i64 2156215305, i64 2156215312, i64 2156215364, i64 2156215395, i64 2156215425}
!65 = !{i64 2156216008, i64 2156216037, i64 2156216083, i64 2156216141, i64 2156216195, i64 2156216249, i64 2156216304, i64 2156216335}
!66 = !{i64 2156216748, i64 2156216755, i64 2156216807, i64 2156216838, i64 2156216868}
!67 = !{i64 2148153086, i64 2148153146}
!68 = !{i64 2156285508, i64 2156285537, i64 2156285583, i64 2156285641, i64 2156285695, i64 2156285749, i64 2156285804, i64 2156285835}
!69 = !{i64 2156286260, i64 2156286267, i64 2156286319, i64 2156286350, i64 2156286380}
!70 = !{i64 2156281580, i64 2156281609, i64 2156281655, i64 2156281713, i64 2156281767, i64 2156281821, i64 2156281876, i64 2156281907}
!71 = !{i64 2156282332, i64 2156282339, i64 2156282391, i64 2156282422, i64 2156282452}
!72 = !{i64 2156294914, i64 2156294943, i64 2156294989, i64 2156295047, i64 2156295101, i64 2156295155, i64 2156295210, i64 2156295241}
!73 = !{i64 2156295666, i64 2156295673, i64 2156295725, i64 2156295756, i64 2156295786}
!74 = !{i64 2156276999}
!75 = !{i64 2156280428}
